; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\ChaosCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_iChaosCastle_OffLineGiftRate@@3HA		; g_iChaosCastle_OffLineGiftRate
CONST	SEGMENT
_g_btCastleSafetyZoneMapXY DB 017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
_g_btCastleCenterHollowZoneMapXY DB 020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
_g_iChaosCastle_ExpTable DD 01388H
	DD	03e8H
	DD	03e8H
	DD	05dcH
	DD	05dcH
	DD	07d0H
	DD	07d0H
	DD	09c4H
	DD	09c4H
	DD	0bb8H
	DD	0bb8H
	DD	0dacH
	DD	0fa0H
	DD	01388H
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
	DD	0190H
	DD	0257H
	DD	0190H
	DD	0257H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
?g_iChaosCastle_OffLineGiftRate@@3HA DD 02H		; g_iChaosCastle_OffLineGiftRate
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
PUBLIC	?Clear@CHAOSCASTLE_REWARD@@QAEXXZ		; CHAOSCASTLE_REWARD::Clear
PUBLIC	?ClearChaosCastleData@CChaosCastle@@IAEXH@Z	; CChaosCastle::ClearChaosCastleData
PUBLIC	__real@3f800000
PUBLIC	?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetChaosCastleMapNumber
PUBLIC	??0_CHAOSCASTLE_DATA@@QAE@XZ			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA
PUBLIC	??1_CHAOSCASTLE_DATA@@QAE@XZ			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA
PUBLIC	??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
PUBLIC	??_7CChaosCastle@@6B@				; CChaosCastle::`vftable'
PUBLIC	??0CChaosCastle@@QAE@XZ				; CChaosCastle::CChaosCastle
PUBLIC	??_R4CChaosCastle@@6B@				; CChaosCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCChaosCastle@@@8			; CChaosCastle `RTTI Type Descriptor'
PUBLIC	??_R3CChaosCastle@@8				; CChaosCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CChaosCastle@@8				; CChaosCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CChaosCastle@@8			; CChaosCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	_srand:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__fltused:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECChaosCastle@@UAEPAXI@Z:PROC		; CChaosCastle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CChaosCastle@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CChaosCastle@@8 DD FLAT:??_R0?AVCChaosCastle@@@8 ; CChaosCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CChaosCastle@@8
rdata$r	SEGMENT
??_R2CChaosCastle@@8 DD FLAT:??_R1A@?0A@EA@CChaosCastle@@8 ; CChaosCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CChaosCastle@@8
rdata$r	SEGMENT
??_R3CChaosCastle@@8 DD 00H				; CChaosCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCChaosCastle@@@8
_DATA	SEGMENT
??_R0?AVCChaosCastle@@@8 DD FLAT:??_7type_info@@6B@	; CChaosCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCChaosCastle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CChaosCastle@@6B@
rdata$r	SEGMENT
??_R4CChaosCastle@@6B@ DD 00H				; CChaosCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCChaosCastle@@@8
	DD	FLAT:??_R3CChaosCastle@@8
rdata$r	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_7CChaosCastle@@6B@
CONST	SEGMENT
??_7CChaosCastle@@6B@ DD FLAT:??_R4CChaosCastle@@6B@	; CChaosCastle::`vftable'
	DD	FLAT:??_ECChaosCastle@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CChaosCastle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CChaosCastle@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CChaosCastle@@QAE@XZ$1
__ehfuncinfo$??0CChaosCastle@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CChaosCastle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_i$236359 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CChaosCastle@@QAE@XZ PROC				; CChaosCastle::CChaosCastle
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CChaosCastle@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CChaosCastle@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 20	 add	 ecx, 32			; 00000020H
  0003a	e8 00 00 00 00	 call	 ??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  0004b	68 00 00 00 00	 push	 OFFSET ??0_CHAOSCASTLE_DATA@@QAE@XZ
  00050	6a 07		 push	 7
  00052	68 70 08 00 00	 push	 2160			; 00000870H
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 c0 30	 add	 eax, 48			; 00000030H
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 32   : 	this->m_bCC_EVENT_ENABLE = FALSE;

  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 33   : 	this->m_iCC_TIME_MIN_OPEN = 10;

  00071	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c7 40 08 0a 00
	00 00		 mov	 DWORD PTR [eax+8], 10	; 0000000aH

; 34   : 	this->m_iCC_NORMAL_ITEM_DROP = 100;

  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	c7 40 14 64 00
	00 00		 mov	 DWORD PTR [eax+20], 100	; 00000064H

; 35   : 	this->m_iCC_EXCEL_ITEM_DROP = 1200;

  00085	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00088	c7 40 18 b0 04
	00 00		 mov	 DWORD PTR [eax+24], 1200 ; 000004b0H

; 36   : 	this->m_iCC_MONSTER_REGEN = 0;

  0008f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 37   : 
; 38   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00099	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$236359[ebp], 0
  000a0	eb 09		 jmp	 SHORT $LN3@CChaosCast
$LN2@CChaosCast:
  000a2	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  000a5	83 c0 01	 add	 eax, 1
  000a8	89 45 ec	 mov	 DWORD PTR _i$236359[ebp], eax
$LN3@CChaosCast:
  000ab	83 7d ec 07	 cmp	 DWORD PTR _i$236359[ebp], 7
  000af	0f 8d a6 00 00
	00		 jge	 $LN1@CChaosCast

; 39   : 	{
; 40   : 		this->m_stChaosCastleData[i].m_iCC_STATE = CC_STATE_NONE;

  000b5	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  000b8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  000be	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	c7 44 01 30 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+48], 0

; 41   : 		this->m_stChaosCastleData[i].m_iMapNumber = this->GetChaosCastleMapNumber(i);

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  000d5	8b 4d ec	 mov	 ecx, DWORD PTR _i$236359[ebp]
  000d8	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  000de	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e1	89 44 0a 34	 mov	 DWORD PTR [edx+ecx+52], eax

; 42   : 		this->m_stChaosCastleData[i].m_iChaosCastleIndex = i;

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  000e8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	8b 55 ec	 mov	 edx, DWORD PTR _i$236359[ebp]
  000f4	89 54 01 38	 mov	 DWORD PTR [ecx+eax+56], edx

; 43   : 		this->m_stChaosCastleData[i].m_iCC_REMAIN_MSEC = -1;

  000f8	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  000fb	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00101	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	c7 44 01 40 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+64], -1

; 44   : 		this->m_stChaosCastleData[i].m_iCC_TICK_COUNT = -1;

  0010c	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  0010f	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00115	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	c7 44 01 44 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+68], -1

; 45   : 		this->m_stChaosCastleData[i].m_iCC_REWARD_EXP = 1.0f; //season 4.5 add-on

  00120	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  00123	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00129	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	d9 e8		 fld1
  0012e	d9 9c 01 9c 08
	00 00		 fstp	 DWORD PTR [ecx+eax+2204]

; 46   : 		this->ClearChaosCastleData(i);

  00135	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  00138	50		 push	 eax
  00139	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	e8 00 00 00 00	 call	 ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ; CChaosCastle::ClearChaosCastleData

; 47   : 
; 48   : #ifdef _CONFLICT_
; 49   : 		this->m_RewardData[i].Clear();

  00141	8b 45 ec	 mov	 eax, DWORD PTR _i$236359[ebp]
  00144	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00147	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	8d 8c 01 40 3b
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+15168]
  00151	e8 00 00 00 00	 call	 ?Clear@CHAOSCASTLE_REWARD@@QAEXXZ ; CHAOSCASTLE_REWARD::Clear

; 50   : #endif
; 51   : 	}

  00156	e9 47 ff ff ff	 jmp	 $LN2@CChaosCast
$LN1@CChaosCast:

; 52   : 
; 53   : 	srand(time(NULL));

  0015b	6a 00		 push	 0
  0015d	e8 00 00 00 00	 call	 _time
  00162	83 c4 04	 add	 esp, 4
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _srand
  0016b	83 c4 04	 add	 esp, 4

; 54   : }

  0016e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00175	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00178	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00182	59		 pop	 ecx
  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CChaosCastle@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__unwindfunclet$??0CChaosCastle@@QAE@XZ$1:
  0000b	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00010	6a 07		 push	 7
  00012	68 70 08 00 00	 push	 2160			; 00000870H
  00017	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c0 30	 add	 eax, 48			; 00000030H
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00023	c3		 ret	 0
__ehhandler$??0CChaosCastle@@QAE@XZ:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CChaosCastle@@QAE@XZ
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CChaosCastle@@QAE@XZ ENDP				; CChaosCastle::CChaosCastle
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.h
;	COMDAT ?Clear@CHAOSCASTLE_REWARD@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CHAOSCASTLE_REWARD@@QAEXXZ PROC			; CHAOSCASTLE_REWARD::Clear, COMDAT
; _this$ = ecx

; 249  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 			this->AncientRate	= 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 251  : 			this->AncientCount	= 0;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 252  : 			this->ItemCount		= 0;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c6 40 05 00	 mov	 BYTE PTR [eax+5], 0

; 253  : 			this->ItemID		= -1;

  00023	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 254  : 			this->ItemIndex		= -1;

  0002f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 255  : 			this->ItemLevel		= 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 256  : 		};

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?Clear@CHAOSCASTLE_REWARD@@QAEXXZ ENDP			; CHAOSCASTLE_REWARD::Clear
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 40	 sub	 esp, 64			; 00000040H
  00196	53		 push	 ebx
  00197	56		 push	 esi
  00198	57		 push	 edi

; 133  :     return _time64(_Time);

  00199	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 __time64
  001a2	83 c4 04	 add	 esp, 4

; 134  : }

  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	5b		 pop	 ebx
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	??1CChaosCastle@@UAE@XZ				; CChaosCastle::~CChaosCastle
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCChaosCastle@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCChaosCastle@@UAEPAXI@Z PROC			; CChaosCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CChaosCastle@@UAE@XZ	; CChaosCastle::~CChaosCastle
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCChaosCastle@@UAEPAXI@Z ENDP			; CChaosCastle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
PUBLIC	??0_CHAOSCASTLE_USER@@QAE@XZ			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
; Function compile flags: /Odtp /ZI
;	COMDAT ??0_CHAOSCASTLE_DATA@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_CHAOSCASTLE_DATA@@QAE@XZ PROC			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	68 00 00 00 00	 push	 OFFSET ??0_CHAOSCASTLE_USER@@QAE@XZ ; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
  00011	6a 46		 push	 70			; 00000046H
  00013	6a 14		 push	 20			; 00000014H
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 3c	 add	 eax, 60			; 0000003cH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 5c 08 00
	00		 add	 ecx, 2140		; 0000085cH
  0002a	e8 00 00 00 00	 call	 ??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??0_CHAOSCASTLE_DATA@@QAE@XZ ENDP			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA
_TEXT	ENDS
PUBLIC	?Clear@_CHAOSCASTLE_USER@@QAEXXZ		; _CHAOSCASTLE_USER::Clear
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.h
;	COMDAT ??0_CHAOSCASTLE_USER@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_CHAOSCASTLE_USER@@QAE@XZ PROC			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER, COMDAT
; _this$ = ecx

; 157  : 	_CHAOSCASTLE_USER()	// line : 338

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 158  : 	{
; 159  : 		this->Clear();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Clear@_CHAOSCASTLE_USER@@QAEXXZ ; _CHAOSCASTLE_USER::Clear

; 160  : 	};	// line : 340

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_CHAOSCASTLE_USER@@QAE@XZ ENDP			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?Clear@_CHAOSCASTLE_USER@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@_CHAOSCASTLE_USER@@QAEXXZ PROC			; _CHAOSCASTLE_USER::Clear, COMDAT
; _this$ = ecx

; 163  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 		this->m_iIndex = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 165  : 		this->m_iEXP = 0;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 166  : 		this->m_iScore = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 167  : 		this->m_iUserState = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 168  : 		this->m_bSendQuitMsg = false;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0

; 169  : 	};	// line : 348

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?Clear@_CHAOSCASTLE_USER@@QAEXXZ ENDP			; _CHAOSCASTLE_USER::Clear
_TEXT	ENDS
PUBLIC	??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1_CHAOSCASTLE_DATA@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_CHAOSCASTLE_DATA@@QAE@XZ PROC			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 5c 08 00
	00		 add	 ecx, 2140		; 0000085cH
  00015	e8 00 00 00 00	 call	 ??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1_CHAOSCASTLE_DATA@@QAE@XZ ENDP			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1CChaosCastle@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CChaosCastle@@UAE@XZ$0
__ehfuncinfo$??1CChaosCastle@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CChaosCastle@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_i$236378 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CChaosCastle@@UAE@XZ PROC				; CChaosCastle::~CChaosCastle
; _this$ = ecx

; 57   : {

  001b0	55		 push	 ebp
  001b1	8b ec		 mov	 ebp, esp
  001b3	6a ff		 push	 -1
  001b5	68 00 00 00 00	 push	 __ehhandler$??1CChaosCastle@@UAE@XZ
  001ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  001c0	50		 push	 eax
  001c1	83 ec 48	 sub	 esp, 72			; 00000048H
  001c4	53		 push	 ebx
  001c5	56		 push	 esi
  001c6	57		 push	 edi
  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001cc	33 c5		 xor	 eax, ebp
  001ce	50		 push	 eax
  001cf	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  001d2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  001d8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  001db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001de	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CChaosCastle@@6B@
  001e4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 58   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  001eb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$236378[ebp], 0
  001f2	eb 09		 jmp	 SHORT $LN3@CChaosCast@2
$LN2@CChaosCast@2:
  001f4	8b 45 ec	 mov	 eax, DWORD PTR _i$236378[ebp]
  001f7	83 c0 01	 add	 eax, 1
  001fa	89 45 ec	 mov	 DWORD PTR _i$236378[ebp], eax
$LN3@CChaosCast@2:
  001fd	83 7d ec 07	 cmp	 DWORD PTR _i$236378[ebp], 7
  00201	7d 02		 jge	 SHORT $LN4@CChaosCast@2

; 59   : 	{
; 60   : 	}

  00203	eb ef		 jmp	 SHORT $LN2@CChaosCast@2
$LN4@CChaosCast@2:

; 61   : }

  00205	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  0020a	6a 07		 push	 7
  0020c	68 70 08 00 00	 push	 2160			; 00000870H
  00211	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00214	83 c0 30	 add	 eax, 48			; 00000030H
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0021d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00224	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00227	83 c1 20	 add	 ecx, 32			; 00000020H
  0022a	e8 00 00 00 00	 call	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
  0022f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00232	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00239	59		 pop	 ecx
  0023a	5f		 pop	 edi
  0023b	5e		 pop	 esi
  0023c	5b		 pop	 ebx
  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CChaosCastle@@UAE@XZ$0:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 20	 add	 ecx, 32			; 00000020H
  00045	e9 00 00 00 00	 jmp	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__ehhandler$??1CChaosCastle@@UAE@XZ:
  0004a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00051	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CChaosCastle@@UAE@XZ
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CChaosCastle@@UAE@XZ ENDP				; CChaosCastle::~CChaosCastle
PUBLIC	?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z	; CChaosCastle::ProcState_PlayEnd
PUBLIC	?ProcState_Playing@CChaosCastle@@IAEXH@Z	; CChaosCastle::ProcState_Playing
PUBLIC	?ProcState_Closed@CChaosCastle@@IAEXH@Z		; CChaosCastle::ProcState_Closed
PUBLIC	?ProcState_None@CChaosCastle@@IAEXH@Z		; CChaosCastle::ProcState_None
PUBLIC	?Run@CChaosCastle@@QAEXXZ			; CChaosCastle::Run
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv71 = -76						; size = 4
_i$236386 = -8						; size = 4
_this$ = -4						; size = 4
?Run@CChaosCastle@@QAEXXZ PROC				; CChaosCastle::Run
; _this$ = ecx

; 64   : {

  00250	55		 push	 ebp
  00251	8b ec		 mov	 ebp, esp
  00253	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00256	53		 push	 ebx
  00257	56		 push	 esi
  00258	57		 push	 edi
  00259	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 	if ( this->m_bCC_EVENT_ENABLE != FALSE )

  0025c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00263	0f 84 84 00 00
	00		 je	 $LN12@Run

; 66   : 	{
; 67   : 		for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00269	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$236386[ebp], 0
  00270	eb 09		 jmp	 SHORT $LN10@Run
$LN9@Run:
  00272	8b 45 f8	 mov	 eax, DWORD PTR _i$236386[ebp]
  00275	83 c0 01	 add	 eax, 1
  00278	89 45 f8	 mov	 DWORD PTR _i$236386[ebp], eax
$LN10@Run:
  0027b	83 7d f8 07	 cmp	 DWORD PTR _i$236386[ebp], 7
  0027f	7d 5b		 jge	 SHORT $LN8@Run

; 68   : 		{
; 69   : 			switch ( this->m_stChaosCastleData[i].m_iCC_STATE )

  00281	8b 45 f8	 mov	 eax, DWORD PTR _i$236386[ebp]
  00284	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0028a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028d	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00291	89 55 b4	 mov	 DWORD PTR tv71[ebp], edx
  00294	83 7d b4 03	 cmp	 DWORD PTR tv71[ebp], 3
  00298	77 40		 ja	 SHORT $LN6@Run
  0029a	8b 45 b4	 mov	 eax, DWORD PTR tv71[ebp]
  0029d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@Run[eax*4]
$LN5@Run:

; 70   : 			{
; 71   : 				case CC_STATE_NONE:
; 72   : 					this->ProcState_None(i);

  002a4	8b 45 f8	 mov	 eax, DWORD PTR _i$236386[ebp]
  002a7	50		 push	 eax
  002a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ab	e8 00 00 00 00	 call	 ?ProcState_None@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_None

; 73   : 					break;

  002b0	eb 28		 jmp	 SHORT $LN6@Run
$LN4@Run:

; 74   : 
; 75   : 				case CC_STATE_CLOSED:
; 76   : 					this->ProcState_Closed(i);

  002b2	8b 45 f8	 mov	 eax, DWORD PTR _i$236386[ebp]
  002b5	50		 push	 eax
  002b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ?ProcState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_Closed

; 77   : 					break;

  002be	eb 1a		 jmp	 SHORT $LN6@Run
$LN3@Run:

; 78   : 
; 79   : 				case CC_STATE_PLAYING:
; 80   : 					this->ProcState_Playing(i);

  002c0	8b 45 f8	 mov	 eax, DWORD PTR _i$236386[ebp]
  002c3	50		 push	 eax
  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?ProcState_Playing@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_Playing

; 81   : 					break;

  002cc	eb 0c		 jmp	 SHORT $LN6@Run
$LN2@Run:

; 82   : 
; 83   : 				case CC_STATE_PLAYEND:
; 84   : 					this->ProcState_PlayEnd(i);

  002ce	8b 45 f8	 mov	 eax, DWORD PTR _i$236386[ebp]
  002d1	50		 push	 eax
  002d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d5	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_PlayEnd
$LN6@Run:

; 85   : 					break;
; 86   : 			}
; 87   : 		}

  002da	eb 96		 jmp	 SHORT $LN9@Run
$LN8@Run:

; 88   : 
; 89   : 		if ( szAuthKey[13] != AUTHKEY13 )

  002dc	0f be 05 0d 00
	00 00		 movsx	 eax, BYTE PTR ?szAuthKey@@3PADA+13
  002e3	83 f8 bb	 cmp	 eax, -69		; ffffffbbH
  002e6	74 05		 je	 SHORT $LN12@Run

; 90   : 		{
; 91   : 			DestroyGIocp();

  002e8	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN12@Run:

; 92   : 		}
; 93   : 
; 94   : 	}
; 95   : }

  002ed	5f		 pop	 edi
  002ee	5e		 pop	 esi
  002ef	5b		 pop	 ebx
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c3		 ret	 0
$LN14@Run:
  002f4	00 00 00 00	 DD	 $LN5@Run
  002f8	00 00 00 00	 DD	 $LN4@Run
  002fc	00 00 00 00	 DD	 $LN3@Run
  00300	00 00 00 00	 DD	 $LN2@Run
?Run@CChaosCastle@@QAEXXZ ENDP				; CChaosCastle::Run
_TEXT	ENDS
PUBLIC	?SetState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SetState
PUBLIC	?Init@CChaosCastle@@QAEX_N@Z			; CChaosCastle::Init
_BSS	SEGMENT
_g_rtPOINT_TRAP DB 040H DUP (?)
_g_rtPOINT_FRAME DB 040H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
_TEXT	SEGMENT
_iTRAP_STEP$236407 = -12				; size = 4
_i$236403 = -8						; size = 4
_this$ = -4						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CChaosCastle@@QAEX_N@Z PROC			; CChaosCastle::Init
; _this$ = ecx

; 98   : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00316	53		 push	 ebx
  00317	56		 push	 esi
  00318	57		 push	 edi
  00319	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	this->m_bCC_EVENT_ENABLE = bEVENT_ENABLE;

  0031c	0f b6 45 08	 movzx	 eax, BYTE PTR _bEVENT_ENABLE$[ebp]
  00320	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00323	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 100  : 
; 101  : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00326	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$236403[ebp], 0
  0032d	eb 09		 jmp	 SHORT $LN6@Init
$LN5@Init:
  0032f	8b 45 f8	 mov	 eax, DWORD PTR _i$236403[ebp]
  00332	83 c0 01	 add	 eax, 1
  00335	89 45 f8	 mov	 DWORD PTR _i$236403[ebp], eax
$LN6@Init:
  00338	83 7d f8 07	 cmp	 DWORD PTR _i$236403[ebp], 7
  0033c	7d 10		 jge	 SHORT $LN4@Init

; 102  : 	{
; 103  : 		this->SetState(i, CC_STATE_CLOSED);

  0033e	6a 01		 push	 1
  00340	8b 45 f8	 mov	 eax, DWORD PTR _i$236403[ebp]
  00343	50		 push	 eax
  00344	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00347	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 104  : 	}

  0034c	eb e1		 jmp	 SHORT $LN5@Init
$LN4@Init:

; 105  : 
; 106  : 	for ( int iTRAP_STEP = 0; iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  0034e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iTRAP_STEP$236407[ebp], 0
  00355	eb 09		 jmp	 SHORT $LN3@Init
$LN2@Init:
  00357	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  0035a	83 c0 01	 add	 eax, 1
  0035d	89 45 f4	 mov	 DWORD PTR _iTRAP_STEP$236407[ebp], eax
$LN3@Init:
  00360	83 7d f4 04	 cmp	 DWORD PTR _iTRAP_STEP$236407[ebp], 4
  00364	0f 8d b5 02 00
	00		 jge	 $LN7@Init

; 107  : 	{
; 108  : 		g_rtPOINT_FRAME[0].left = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0]) / 2 + 1;

  0036a	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  0036f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  00375	99		 cdq
  00376	2b c2		 sub	 eax, edx
  00378	d1 f8		 sar	 eax, 1
  0037a	83 c0 01	 add	 eax, 1
  0037d	a3 00 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME, eax

; 109  : 		g_rtPOINT_FRAME[0].top = g_iChaosCastle_GroundAxis[1];

  00382	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  00387	a3 04 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+4, eax

; 110  : 		g_rtPOINT_FRAME[0].right = ::g_iChaosCastle_GroundAxis[2];

  0038c	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  00391	a3 08 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+8, eax

; 111  : 		g_rtPOINT_FRAME[0].bottom = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 ;

  00396	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  0039b	03 05 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  003a1	99		 cdq
  003a2	2b c2		 sub	 eax, edx
  003a4	d1 f8		 sar	 eax, 1
  003a6	a3 0c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+12, eax

; 112  : 
; 113  : 		g_rtPOINT_FRAME[1].left = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0]) / 2 + 1;

  003ab	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  003b0	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  003b6	99		 cdq
  003b7	2b c2		 sub	 eax, edx
  003b9	d1 f8		 sar	 eax, 1
  003bb	83 c0 01	 add	 eax, 1
  003be	a3 10 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+16, eax

; 114  : 		g_rtPOINT_FRAME[1].top = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 + 1;

  003c3	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  003c8	03 05 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  003ce	99		 cdq
  003cf	2b c2		 sub	 eax, edx
  003d1	d1 f8		 sar	 eax, 1
  003d3	83 c0 01	 add	 eax, 1
  003d6	a3 14 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+20, eax

; 115  : 		g_rtPOINT_FRAME[1].right = g_iChaosCastle_GroundAxis[2];

  003db	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  003e0	a3 18 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+24, eax

; 116  : 		g_rtPOINT_FRAME[1].bottom = ::g_iChaosCastle_GroundAxis[3];

  003e5	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  003ea	a3 1c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+28, eax

; 117  : 		
; 118  : 		g_rtPOINT_FRAME[2].left = ::g_iChaosCastle_GroundAxis[0];

  003ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  003f4	a3 20 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+32, eax

; 119  : 		g_rtPOINT_FRAME[2].top = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 + 1;

  003f9	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  003fe	03 05 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  00404	99		 cdq
  00405	2b c2		 sub	 eax, edx
  00407	d1 f8		 sar	 eax, 1
  00409	83 c0 01	 add	 eax, 1
  0040c	a3 24 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+36, eax

; 120  : 		g_rtPOINT_FRAME[2].right = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0] ) / 2 ;

  00411	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  00416	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  0041c	99		 cdq
  0041d	2b c2		 sub	 eax, edx
  0041f	d1 f8		 sar	 eax, 1
  00421	a3 28 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+40, eax

; 121  : 		g_rtPOINT_FRAME[2].bottom = ::g_iChaosCastle_GroundAxis[3];

  00426	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  0042b	a3 2c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+44, eax

; 122  : 
; 123  : 		g_rtPOINT_FRAME[3].left = ::g_iChaosCastle_GroundAxis[0];

  00430	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  00435	a3 30 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+48, eax

; 124  : 		g_rtPOINT_FRAME[3].top = ::g_iChaosCastle_GroundAxis[1];

  0043a	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  0043f	a3 34 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+52, eax

; 125  : 		g_rtPOINT_FRAME[3].right = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0] ) / 2;

  00444	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  00449	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  0044f	99		 cdq
  00450	2b c2		 sub	 eax, edx
  00452	d1 f8		 sar	 eax, 1
  00454	a3 38 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+56, eax

; 126  : 		g_rtPOINT_FRAME[3].bottom = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2;

  00459	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  0045e	03 05 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  00464	99		 cdq
  00465	2b c2		 sub	 eax, edx
  00467	d1 f8		 sar	 eax, 1
  00469	a3 3c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+60, eax

; 127  : 
; 128  : 		g_rtPOINT_TRAP[0].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  0046e	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  00471	c1 e0 04	 shl	 eax, 4
  00474	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  00477	c1 e1 04	 shl	 ecx, 4
  0047a	8b 80 08 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  00480	03 81 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx]
  00486	99		 cdq
  00487	2b c2		 sub	 eax, edx
  00489	d1 f8		 sar	 eax, 1
  0048b	83 c0 01	 add	 eax, 1
  0048e	a3 00 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP, eax

; 129  : 		g_rtPOINT_TRAP[0].top = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1];

  00493	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  00496	c1 e0 04	 shl	 eax, 4
  00499	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  0049f	89 0d 04 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+4, ecx

; 130  : 		g_rtPOINT_TRAP[0].right = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][2];

  004a5	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  004a8	c1 e0 04	 shl	 eax, 4
  004ab	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  004b1	89 0d 08 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+8, ecx

; 131  : 		g_rtPOINT_TRAP[0].bottom = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1]) / 2;

  004b7	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  004ba	c1 e0 04	 shl	 eax, 4
  004bd	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  004c0	c1 e1 04	 shl	 ecx, 4
  004c3	8b 80 0c 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  004c9	03 81 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx+4]
  004cf	99		 cdq
  004d0	2b c2		 sub	 eax, edx
  004d2	d1 f8		 sar	 eax, 1
  004d4	a3 0c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+12, eax

; 132  : 
; 133  : 		g_rtPOINT_TRAP[1].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  004d9	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  004dc	c1 e0 04	 shl	 eax, 4
  004df	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  004e2	c1 e1 04	 shl	 ecx, 4
  004e5	8b 80 08 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  004eb	03 81 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx]
  004f1	99		 cdq
  004f2	2b c2		 sub	 eax, edx
  004f4	d1 f8		 sar	 eax, 1
  004f6	83 c0 01	 add	 eax, 1
  004f9	a3 10 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+16, eax

; 134  : 		g_rtPOINT_TRAP[1].top = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2 + 1;

  004fe	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  00501	c1 e0 04	 shl	 eax, 4
  00504	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  00507	c1 e1 04	 shl	 ecx, 4
  0050a	8b 80 0c 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  00510	03 81 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx+4]
  00516	99		 cdq
  00517	2b c2		 sub	 eax, edx
  00519	d1 f8		 sar	 eax, 1
  0051b	83 c0 01	 add	 eax, 1
  0051e	a3 14 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+20, eax

; 135  : 		g_rtPOINT_TRAP[1].right = g_iChaosCastle_DamageAxis[iTRAP_STEP][2];

  00523	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  00526	c1 e0 04	 shl	 eax, 4
  00529	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  0052f	89 0d 18 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+24, ecx

; 136  : 		g_rtPOINT_TRAP[1].bottom = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3];

  00535	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  00538	c1 e0 04	 shl	 eax, 4
  0053b	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  00541	89 0d 1c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+28, ecx

; 137  : 
; 138  : 		g_rtPOINT_TRAP[2].left = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0];

  00547	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  0054a	c1 e0 04	 shl	 eax, 4
  0054d	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  00553	89 0d 20 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+32, ecx

; 139  : 		g_rtPOINT_TRAP[2].top = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2 + 1;

  00559	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  0055c	c1 e0 04	 shl	 eax, 4
  0055f	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  00562	c1 e1 04	 shl	 ecx, 4
  00565	8b 80 0c 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  0056b	03 81 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx+4]
  00571	99		 cdq
  00572	2b c2		 sub	 eax, edx
  00574	d1 f8		 sar	 eax, 1
  00576	83 c0 01	 add	 eax, 1
  00579	a3 24 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+36, eax

; 140  : 		g_rtPOINT_TRAP[2].right = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ) / 2;

  0057e	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  00581	c1 e0 04	 shl	 eax, 4
  00584	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  00587	c1 e1 04	 shl	 ecx, 4
  0058a	8b 80 08 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  00590	03 81 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx]
  00596	99		 cdq
  00597	2b c2		 sub	 eax, edx
  00599	d1 f8		 sar	 eax, 1
  0059b	a3 28 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+40, eax

; 141  : 		g_rtPOINT_TRAP[2].bottom = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3];

  005a0	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  005a3	c1 e0 04	 shl	 eax, 4
  005a6	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  005ac	89 0d 2c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+44, ecx

; 142  : 
; 143  : 		g_rtPOINT_TRAP[3].left = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0];

  005b2	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  005b5	c1 e0 04	 shl	 eax, 4
  005b8	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  005be	89 0d 30 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+48, ecx

; 144  : 		g_rtPOINT_TRAP[3].top = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1];

  005c4	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  005c7	c1 e0 04	 shl	 eax, 4
  005ca	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  005d0	89 0d 34 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+52, ecx

; 145  : 		g_rtPOINT_TRAP[3].right = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ) / 2;

  005d6	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  005d9	c1 e0 04	 shl	 eax, 4
  005dc	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  005df	c1 e1 04	 shl	 ecx, 4
  005e2	8b 80 08 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  005e8	03 81 00 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx]
  005ee	99		 cdq
  005ef	2b c2		 sub	 eax, edx
  005f1	d1 f8		 sar	 eax, 1
  005f3	a3 38 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+56, eax

; 146  : 		g_rtPOINT_TRAP[3].bottom = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2;

  005f8	8b 45 f4	 mov	 eax, DWORD PTR _iTRAP_STEP$236407[ebp]
  005fb	c1 e0 04	 shl	 eax, 4
  005fe	8b 4d f4	 mov	 ecx, DWORD PTR _iTRAP_STEP$236407[ebp]
  00601	c1 e1 04	 shl	 ecx, 4
  00604	8b 80 0c 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  0060a	03 81 04 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_DamageAxis[ecx+4]
  00610	99		 cdq
  00611	2b c2		 sub	 eax, edx
  00613	d1 f8		 sar	 eax, 1
  00615	a3 3c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+60, eax

; 147  : 	}

  0061a	e9 38 fd ff ff	 jmp	 $LN2@Init
$LN7@Init:

; 148  : }

  0061f	5f		 pop	 edi
  00620	5e		 pop	 esi
  00621	5b		 pop	 ebx
  00622	8b e5		 mov	 esp, ebp
  00624	5d		 pop	 ebp
  00625	c2 04 00	 ret	 4
?Init@CChaosCastle@@QAEX_N@Z ENDP			; CChaosCastle::Init
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
PUBLIC	?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
PUBLIC	?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
PUBLIC	??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CChaosCastle@@QAEXPAD@Z			; CChaosCastle::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@ DB '[Chao'
	DB	's Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv413 = -128						; size = 4
tv402 = -128						; size = 4
tv391 = -128						; size = 4
tv380 = -128						; size = 4
tv369 = -128						; size = 4
tv411 = -124						; size = 4
tv400 = -124						; size = 4
tv389 = -124						; size = 4
tv378 = -124						; size = 4
tv367 = -124						; size = 4
tv188 = -120						; size = 4
tv408 = -118						; size = 2
tv397 = -118						; size = 2
tv386 = -118						; size = 2
tv375 = -118						; size = 2
tv364 = -118						; size = 2
$T241988 = -116						; size = 4
$T241989 = -112						; size = 4
$T241990 = -108						; size = 4
$T241991 = -104						; size = 4
$T241992 = -100						; size = 4
_CastleLevel$236592 = -32				; size = 4
_iChaosCastleIndex$236585 = -28				; size = 4
_Schedule$236575 = -24					; size = 8
_iChaosCastleCount$ = -16				; size = 4
_type$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CChaosCastle@@QAEXPAD@Z PROC			; CChaosCastle::Load
; _this$ = ecx

; 151  : {

  00630	55		 push	 ebp
  00631	8b ec		 mov	 ebp, esp
  00633	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00639	53		 push	 ebx
  0063a	56		 push	 esi
  0063b	57		 push	 edi
  0063c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	SMDFile = fopen(filename, "r");

  0063f	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00644	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00647	50		 push	 eax
  00648	e8 00 00 00 00	 call	 _fopen
  0064d	83 c4 08	 add	 esp, 8
  00650	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 153  : 
; 154  : 	if ( SMDFile == NULL )

  00655	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  0065c	75 16		 jne	 SHORT $LN25@Load

; 155  : 	{
; 156  : 		MsgBox("[Chaos Castle] Info file Load Fail [%s]", filename);

  0065e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00661	50		 push	 eax
  00662	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@
  00667	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0066c	83 c4 08	 add	 esp, 8

; 157  : 		return;

  0066f	e9 53 04 00 00	 jmp	 $LN26@Load
$LN25@Load:

; 158  : 	}
; 159  : 
; 160  : 	int Token;
; 161  : 	int type = -1;

  00674	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1

; 162  : 	int iChaosCastleCount = -1;

  0067b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _iChaosCastleCount$[ebp], -1

; 163  : 
; 164  : 	this->m_vtChaosCastleOpenTime.erase( this->m_vtChaosCastleOpenTime.begin(), this->m_vtChaosCastleOpenTime.end());

  00682	8d 45 90	 lea	 eax, DWORD PTR $T241989[ebp]
  00685	50		 push	 eax
  00686	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00689	83 c1 20	 add	 ecx, 32			; 00000020H
  0068c	e8 00 00 00 00	 call	 ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
  00691	8b 08		 mov	 ecx, DWORD PTR [eax]
  00693	89 4d 8c	 mov	 DWORD PTR $T241988[ebp], ecx
  00696	8d 55 98	 lea	 edx, DWORD PTR $T241991[ebp]
  00699	52		 push	 edx
  0069a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0069d	83 c1 20	 add	 ecx, 32			; 00000020H
  006a0	e8 00 00 00 00	 call	 ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
  006a5	8b 00		 mov	 eax, DWORD PTR [eax]
  006a7	89 45 94	 mov	 DWORD PTR $T241990[ebp], eax
  006aa	8b 4d 8c	 mov	 ecx, DWORD PTR $T241988[ebp]
  006ad	51		 push	 ecx
  006ae	8b 55 94	 mov	 edx, DWORD PTR $T241990[ebp]
  006b1	52		 push	 edx
  006b2	8d 45 9c	 lea	 eax, DWORD PTR $T241992[ebp]
  006b5	50		 push	 eax
  006b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006b9	83 c1 20	 add	 ecx, 32			; 00000020H
  006bc	e8 00 00 00 00	 call	 ?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
$LN24@Load:

; 165  : 
; 166  : 	while ( true )

  006c1	b8 01 00 00 00	 mov	 eax, 1
  006c6	85 c0		 test	 eax, eax
  006c8	0f 84 d9 03 00
	00		 je	 $LN23@Load

; 167  : 	{
; 168  : 		Token = GetToken();

  006ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006d3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 169  : 
; 170  : 		if ( Token == 2 )

  006d6	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  006da	75 05		 jne	 SHORT $LN22@Load

; 171  : 		{
; 172  : 			break;

  006dc	e9 c6 03 00 00	 jmp	 $LN23@Load
$LN22@Load:

; 173  : 		}
; 174  : 
; 175  : 		type = (int)TokenNumber;

  006e1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006e7	e8 00 00 00 00	 call	 __ftol2_sse
  006ec	89 45 f4	 mov	 DWORD PTR _type$[ebp], eax
$LN21@Load:

; 176  : 
; 177  : 		while ( true )

  006ef	b8 01 00 00 00	 mov	 eax, 1
  006f4	85 c0		 test	 eax, eax
  006f6	0f 84 a6 03 00
	00		 je	 $LN20@Load

; 178  : 		{
; 179  : 			if ( type == 0 )	// Time Setting

  006fc	83 7d f4 00	 cmp	 DWORD PTR _type$[ebp], 0
  00700	75 6b		 jne	 SHORT $LN19@Load

; 180  : 			{
; 181  : 				Token = GetToken();

  00702	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00707	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 182  : 
; 183  : 				if ( strcmp("end", TokenString) == 0 )

  0070a	68 00 00 00 00	 push	 OFFSET _TokenString
  0070f	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00714	e8 00 00 00 00	 call	 _strcmp
  00719	83 c4 08	 add	 esp, 8
  0071c	85 c0		 test	 eax, eax
  0071e	75 05		 jne	 SHORT $LN18@Load

; 184  : 				{
; 185  : 					break;

  00720	e9 7d 03 00 00	 jmp	 $LN20@Load
$LN18@Load:

; 186  : 				}
; 187  : 
; 188  : 				this->m_iCC_TIME_MIN_OPEN = (int)TokenNumber;

  00725	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0072b	e8 00 00 00 00	 call	 __ftol2_sse
  00730	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00733	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 189  : 
; 190  : 				Token = GetToken();

  00736	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0073b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 191  : 				this->m_iCC_TIME_MIN_PLAY = (int)TokenNumber;

  0073e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00744	e8 00 00 00 00	 call	 __ftol2_sse
  00749	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 192  : 
; 193  : 				Token = GetToken();

  0074f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00754	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 194  : 				this->m_iCC_TIME_MIN_REST = (int)TokenNumber;

  00757	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0075d	e8 00 00 00 00	 call	 __ftol2_sse
  00762	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00765	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00768	e9 30 03 00 00	 jmp	 $LN2@Load
$LN19@Load:

; 195  : 			}
; 196  : 			else if ( type == 1 ) // Drops

  0076d	83 7d f4 01	 cmp	 DWORD PTR _type$[ebp], 1
  00771	75 6b		 jne	 SHORT $LN16@Load

; 197  : 			{
; 198  : 				Token = GetToken();

  00773	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00778	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 199  : 
; 200  : 				if ( strcmp("end", TokenString) == 0 )

  0077b	68 00 00 00 00	 push	 OFFSET _TokenString
  00780	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00785	e8 00 00 00 00	 call	 _strcmp
  0078a	83 c4 08	 add	 esp, 8
  0078d	85 c0		 test	 eax, eax
  0078f	75 05		 jne	 SHORT $LN15@Load

; 201  : 				{
; 202  : 					break;

  00791	e9 0c 03 00 00	 jmp	 $LN20@Load
$LN15@Load:

; 203  : 				}
; 204  : 
; 205  : 				this->m_iCC_NORMAL_ITEM_DROP = (int)TokenNumber;

  00796	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0079c	e8 00 00 00 00	 call	 __ftol2_sse
  007a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007a4	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 206  : 
; 207  : 				Token = GetToken();

  007a7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007ac	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 208  : 				this->m_iCC_EXCEL_ITEM_DROP = (int)TokenNumber;

  007af	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007b5	e8 00 00 00 00	 call	 __ftol2_sse
  007ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007bd	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 209  : 
; 210  : 				Token = GetToken();

  007c0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007c5	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 211  : 				this->m_iCC_MONSTER_REGEN = (int)TokenNumber;

  007c8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007ce	e8 00 00 00 00	 call	 __ftol2_sse
  007d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007d6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007d9	e9 bf 02 00 00	 jmp	 $LN2@Load
$LN16@Load:

; 212  : 			}
; 213  : 			else if ( type == 2 ) // Schedule

  007de	83 7d f4 02	 cmp	 DWORD PTR _type$[ebp], 2
  007e2	75 5b		 jne	 SHORT $LN13@Load

; 214  : 			{
; 215  : 				Token = GetToken();

  007e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007e9	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 216  : 
; 217  : 				if ( strcmp("end", TokenString) == 0 )

  007ec	68 00 00 00 00	 push	 OFFSET _TokenString
  007f1	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  007f6	e8 00 00 00 00	 call	 _strcmp
  007fb	83 c4 08	 add	 esp, 8
  007fe	85 c0		 test	 eax, eax
  00800	75 05		 jne	 SHORT $LN12@Load

; 218  : 				{
; 219  : 					break;

  00802	e9 9b 02 00 00	 jmp	 $LN20@Load
$LN12@Load:

; 220  : 				}
; 221  : 				
; 222  : 				CHAOSCASTLE_START_TIME Schedule;
; 223  : 
; 224  : 				Schedule.m_iHour = (int)TokenNumber;

  00807	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0080d	e8 00 00 00 00	 call	 __ftol2_sse
  00812	89 45 e8	 mov	 DWORD PTR _Schedule$236575[ebp], eax

; 225  : 
; 226  : 				Token = GetToken();

  00815	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0081a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 227  : 				Schedule.m_iMinute = (int)TokenNumber;

  0081d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00823	e8 00 00 00 00	 call	 __ftol2_sse
  00828	89 45 ec	 mov	 DWORD PTR _Schedule$236575[ebp+4], eax

; 228  : 
; 229  : 				this->m_vtChaosCastleOpenTime.push_back(Schedule);

  0082b	8d 45 e8	 lea	 eax, DWORD PTR _Schedule$236575[ebp]
  0082e	50		 push	 eax
  0082f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00832	83 c1 20	 add	 ecx, 32			; 00000020H
  00835	e8 00 00 00 00	 call	 ?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
  0083a	e9 5e 02 00 00	 jmp	 $LN2@Load
$LN13@Load:

; 230  : 			}
; 231  : 			else if ( type == 3 ) // ItemDropProb

  0083f	83 7d f4 03	 cmp	 DWORD PTR _type$[ebp], 3
  00843	75 4b		 jne	 SHORT $LN10@Load

; 232  : 			{
; 233  : 				Token = GetToken();

  00845	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0084a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 234  : 
; 235  : 				if ( strcmp("end", TokenString) == 0 )

  0084d	68 00 00 00 00	 push	 OFFSET _TokenString
  00852	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00857	e8 00 00 00 00	 call	 _strcmp
  0085c	83 c4 08	 add	 esp, 8
  0085f	85 c0		 test	 eax, eax
  00861	75 05		 jne	 SHORT $LN9@Load

; 236  : 				{
; 237  : 					break;

  00863	e9 3a 02 00 00	 jmp	 $LN20@Load
$LN9@Load:

; 238  : 				}
; 239  : 		
; 240  : 				g_iChaosCastle_OffLineGiftRate = (int)TokenNumber;

  00868	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0086e	e8 00 00 00 00	 call	 __ftol2_sse
  00873	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA, eax ; g_iChaosCastle_OffLineGiftRate

; 241  : 				g_iChaosCastle_OffLineGiftRate %= 10000;

  00878	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA ; g_iChaosCastle_OffLineGiftRate
  0087d	99		 cdq
  0087e	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00883	f7 f9		 idiv	 ecx
  00885	89 15 00 00 00
	00		 mov	 DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA, edx ; g_iChaosCastle_OffLineGiftRate
  0088b	e9 0d 02 00 00	 jmp	 $LN2@Load
$LN10@Load:

; 242  : 			}
; 243  : 			//Season 4.5 add-on
; 244  : 			else if ( type == 4 )

  00890	83 7d f4 04	 cmp	 DWORD PTR _type$[ebp], 4
  00894	0f 85 82 00 00
	00		 jne	 $LN7@Load

; 245  : 			{
; 246  : 				Token = GetToken();

  0089a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0089f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 247  : 
; 248  : 				if (strcmp("end", TokenString) == 0)

  008a2	68 00 00 00 00	 push	 OFFSET _TokenString
  008a7	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  008ac	e8 00 00 00 00	 call	 _strcmp
  008b1	83 c4 08	 add	 esp, 8
  008b4	85 c0		 test	 eax, eax
  008b6	75 05		 jne	 SHORT $LN6@Load

; 249  : 				{
; 250  : 					break;

  008b8	e9 e5 01 00 00	 jmp	 $LN20@Load
$LN6@Load:

; 251  : 				}
; 252  : 			
; 253  : 				int iChaosCastleIndex = (int)TokenNumber;

  008bd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  008c3	e8 00 00 00 00	 call	 __ftol2_sse
  008c8	89 45 e4	 mov	 DWORD PTR _iChaosCastleIndex$236585[ebp], eax

; 254  : 
; 255  : 				if ( CC_FLOOR_RANGE(iChaosCastleIndex) != FALSE )

  008cb	83 7d e4 00	 cmp	 DWORD PTR _iChaosCastleIndex$236585[ebp], 0
  008cf	7d 09		 jge	 SHORT $LN28@Load
  008d1	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv188[ebp], 0
  008d8	eb 0c		 jmp	 SHORT $LN29@Load
$LN28@Load:
  008da	33 c0		 xor	 eax, eax
  008dc	83 7d e4 06	 cmp	 DWORD PTR _iChaosCastleIndex$236585[ebp], 6
  008e0	0f 9e c0	 setle	 al
  008e3	89 45 88	 mov	 DWORD PTR tv188[ebp], eax
$LN29@Load:
  008e6	83 7d 88 00	 cmp	 DWORD PTR tv188[ebp], 0
  008ea	74 23		 je	 SHORT $LN5@Load

; 256  : 				{
; 257  : 					Token = GetToken();

  008ec	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  008f1	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 258  : 					this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REWARD_EXP = TokenNumber;

  008f4	8b 45 e4	 mov	 eax, DWORD PTR _iChaosCastleIndex$236585[ebp]
  008f7	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  008fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00900	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00906	d9 9c 01 9c 08
	00 00		 fstp	 DWORD PTR [ecx+eax+2204]

; 259  : 				}
; 260  : 				else

  0090d	eb 08		 jmp	 SHORT $LN4@Load
$LN5@Load:

; 261  : 				{
; 262  : 					Token = GetToken();

  0090f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00914	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
$LN4@Load:

; 263  : 				}

  00917	e9 81 01 00 00	 jmp	 $LN2@Load
$LN7@Load:

; 264  : 			}
; 265  : #ifdef _CONFLICT_
; 266  : 			else if( type == 5 )

  0091c	83 7d f4 05	 cmp	 DWORD PTR _type$[ebp], 5
  00920	0f 85 77 01 00
	00		 jne	 $LN2@Load

; 267  : 			{
; 268  : 				Token = GetToken();

  00926	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0092b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 269  : 				// ----
; 270  : 				if (strcmp("end", TokenString) == 0)

  0092e	68 00 00 00 00	 push	 OFFSET _TokenString
  00933	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00938	e8 00 00 00 00	 call	 _strcmp
  0093d	83 c4 08	 add	 esp, 8
  00940	85 c0		 test	 eax, eax
  00942	75 05		 jne	 SHORT $LN1@Load

; 271  : 				{
; 272  : 					break;

  00944	e9 59 01 00 00	 jmp	 $LN20@Load
$LN1@Load:

; 273  : 				}
; 274  : 				// ----
; 275  : 				int CastleLevel = TokenNumber;

  00949	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0094f	e8 00 00 00 00	 call	 __ftol2_sse
  00954	89 45 e0	 mov	 DWORD PTR _CastleLevel$236592[ebp], eax

; 276  : 				// ----
; 277  : 				Token = GetToken();

  00957	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0095c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 278  : 				this->m_RewardData[CastleLevel].AncientRate		= TokenNumber;

  0095f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00965	e8 00 00 00 00	 call	 __ftol2_sse
  0096a	8b 4d e0	 mov	 ecx, DWORD PTR _CastleLevel$236592[ebp]
  0096d	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00970	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00973	89 84 0a 40 3b
	00 00		 mov	 DWORD PTR [edx+ecx+15168], eax

; 279  : 				// ----
; 280  : 				Token = GetToken();

  0097a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0097f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 281  : 				this->m_RewardData[CastleLevel].AncientCount	= TokenNumber;

  00982	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00988	d9 7d 8a	 fnstcw	 WORD PTR tv364[ebp]
  0098b	0f b7 45 8a	 movzx	 eax, WORD PTR tv364[ebp]
  0098f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00994	89 45 84	 mov	 DWORD PTR tv367[ebp], eax
  00997	d9 6d 84	 fldcw	 WORD PTR tv367[ebp]
  0099a	db 5d 80	 fistp	 DWORD PTR tv369[ebp]
  0099d	d9 6d 8a	 fldcw	 WORD PTR tv364[ebp]
  009a0	8a 45 80	 mov	 al, BYTE PTR tv369[ebp]
  009a3	8b 4d e0	 mov	 ecx, DWORD PTR _CastleLevel$236592[ebp]
  009a6	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  009a9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009ac	88 84 0a 44 3b
	00 00		 mov	 BYTE PTR [edx+ecx+15172], al

; 282  : 				// ----
; 283  : 				Token = GetToken();

  009b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009b8	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 284  : 				this->m_RewardData[CastleLevel].ItemCount		= TokenNumber;

  009bb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009c1	d9 7d 8a	 fnstcw	 WORD PTR tv375[ebp]
  009c4	0f b7 45 8a	 movzx	 eax, WORD PTR tv375[ebp]
  009c8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  009cd	89 45 84	 mov	 DWORD PTR tv378[ebp], eax
  009d0	d9 6d 84	 fldcw	 WORD PTR tv378[ebp]
  009d3	db 5d 80	 fistp	 DWORD PTR tv380[ebp]
  009d6	d9 6d 8a	 fldcw	 WORD PTR tv375[ebp]
  009d9	8a 45 80	 mov	 al, BYTE PTR tv380[ebp]
  009dc	8b 4d e0	 mov	 ecx, DWORD PTR _CastleLevel$236592[ebp]
  009df	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  009e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009e5	88 84 0a 45 3b
	00 00		 mov	 BYTE PTR [edx+ecx+15173], al

; 285  : 				// ----
; 286  : 				Token = GetToken();

  009ec	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009f1	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 287  : 				this->m_RewardData[CastleLevel].ItemID			= TokenNumber;

  009f4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009fa	d9 7d 8a	 fnstcw	 WORD PTR tv386[ebp]
  009fd	0f b7 45 8a	 movzx	 eax, WORD PTR tv386[ebp]
  00a01	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a06	89 45 84	 mov	 DWORD PTR tv389[ebp], eax
  00a09	d9 6d 84	 fldcw	 WORD PTR tv389[ebp]
  00a0c	db 5d 80	 fistp	 DWORD PTR tv391[ebp]
  00a0f	d9 6d 8a	 fldcw	 WORD PTR tv386[ebp]
  00a12	66 8b 45 80	 mov	 ax, WORD PTR tv391[ebp]
  00a16	8b 4d e0	 mov	 ecx, DWORD PTR _CastleLevel$236592[ebp]
  00a19	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00a1c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a1f	66 89 84 0a 46
	3b 00 00	 mov	 WORD PTR [edx+ecx+15174], ax

; 288  : 				// ----
; 289  : 				Token = GetToken();

  00a27	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00a2c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 290  : 				this->m_RewardData[CastleLevel].ItemIndex		= TokenNumber;

  00a2f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00a35	d9 7d 8a	 fnstcw	 WORD PTR tv397[ebp]
  00a38	0f b7 45 8a	 movzx	 eax, WORD PTR tv397[ebp]
  00a3c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a41	89 45 84	 mov	 DWORD PTR tv400[ebp], eax
  00a44	d9 6d 84	 fldcw	 WORD PTR tv400[ebp]
  00a47	db 5d 80	 fistp	 DWORD PTR tv402[ebp]
  00a4a	d9 6d 8a	 fldcw	 WORD PTR tv397[ebp]
  00a4d	66 8b 45 80	 mov	 ax, WORD PTR tv402[ebp]
  00a51	8b 4d e0	 mov	 ecx, DWORD PTR _CastleLevel$236592[ebp]
  00a54	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00a57	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a5a	66 89 84 0a 48
	3b 00 00	 mov	 WORD PTR [edx+ecx+15176], ax

; 291  : 				// ----
; 292  : 				Token = GetToken();

  00a62	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00a67	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 293  : 				this->m_RewardData[CastleLevel].ItemLevel		= TokenNumber;

  00a6a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00a70	d9 7d 8a	 fnstcw	 WORD PTR tv408[ebp]
  00a73	0f b7 45 8a	 movzx	 eax, WORD PTR tv408[ebp]
  00a77	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a7c	89 45 84	 mov	 DWORD PTR tv411[ebp], eax
  00a7f	d9 6d 84	 fldcw	 WORD PTR tv411[ebp]
  00a82	db 5d 80	 fistp	 DWORD PTR tv413[ebp]
  00a85	d9 6d 8a	 fldcw	 WORD PTR tv408[ebp]
  00a88	66 8b 45 80	 mov	 ax, WORD PTR tv413[ebp]
  00a8c	8b 4d e0	 mov	 ecx, DWORD PTR _CastleLevel$236592[ebp]
  00a8f	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00a92	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a95	66 89 84 0a 4a
	3b 00 00	 mov	 WORD PTR [edx+ecx+15178], ax
$LN2@Load:

; 294  : 			}
; 295  : #endif
; 296  : 		}

  00a9d	e9 4d fc ff ff	 jmp	 $LN21@Load
$LN20@Load:

; 297  : 	}

  00aa2	e9 1a fc ff ff	 jmp	 $LN24@Load
$LN23@Load:

; 298  : 
; 299  : 	fclose(SMDFile);

  00aa7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00aac	50		 push	 eax
  00aad	e8 00 00 00 00	 call	 _fclose
  00ab2	83 c4 04	 add	 esp, 4

; 300  : 
; 301  : 	LogAdd("%s file load!", filename);

  00ab5	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00ab8	50		 push	 eax
  00ab9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00abe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00ac4	83 c4 08	 add	 esp, 8
$LN26@Load:

; 302  : }

  00ac7	5f		 pop	 edi
  00ac8	5e		 pop	 esi
  00ac9	5b		 pop	 ebx
  00aca	8b e5		 mov	 esp, ebp
  00acc	5d		 pop	 ebp
  00acd	c2 04 00	 ret	 4
?Load@CChaosCastle@@QAEXPAD@Z ENDP			; CChaosCastle::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00ad0	55		 push	 ebp
  00ad1	8b ec		 mov	 ebp, esp
  00ad3	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00ad9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00ade	33 c5		 xor	 eax, ebp
  00ae0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00ae3	53		 push	 ebx
  00ae4	56		 push	 esi
  00ae5	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00ae6	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00aed	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00af2	50		 push	 eax
  00af3	e8 00 00 00 00	 call	 _fgetc
  00af8	83 c4 04	 add	 esp, 4
  00afb	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00afe	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00b02	83 f9 ff	 cmp	 ecx, -1
  00b05	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00b07	b8 02 00 00 00	 mov	 eax, 2
  00b0c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00b11	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00b13	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b17	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00b1a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  00b1c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00b21	50		 push	 eax
  00b22	e8 00 00 00 00	 call	 _fgetc
  00b27	83 c4 04	 add	 esp, 4
  00b2a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00b2d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00b31	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00b34	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00b36	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b3a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00b3d	74 1c		 je	 SHORT $LN23@GetToken
  00b3f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b43	83 f8 ff	 cmp	 eax, -1
  00b46	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00b48	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00b4d	50		 push	 eax
  00b4e	e8 00 00 00 00	 call	 _fgetc
  00b53	83 c4 04	 add	 esp, 4
  00b56	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00b59	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  00b5b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b5f	83 f8 ff	 cmp	 eax, -1
  00b62	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00b64	b8 02 00 00 00	 mov	 eax, 2
  00b69	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  00b6e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b72	50		 push	 eax
  00b73	e8 00 00 00 00	 call	 _isspace
  00b78	83 c4 04	 add	 esp, 4
  00b7b	85 c0		 test	 eax, eax
  00b7d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00b83	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b87	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  00b8d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00b93	83 e9 22	 sub	 ecx, 34			; 00000022H
  00b96	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  00b9c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00ba3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00ba9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  00baf	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00bb6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  00bbd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00bc7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00bcc	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00bd1	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00bd6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00be0	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00be5	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  00bea	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  00bef	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00bf9	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00bfe	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00c03	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00c08	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00c12	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00c17	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  00c1c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00c21	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  00c2b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00c30	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00c35	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00c3a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c3f	50		 push	 eax
  00c40	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c44	51		 push	 ecx
  00c45	e8 00 00 00 00	 call	 _ungetc
  00c4a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  00c4d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00c50	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00c53	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c58	50		 push	 eax
  00c59	e8 00 00 00 00	 call	 _getc
  00c5e	83 c4 04	 add	 esp, 4
  00c61	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00c64	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c68	83 f9 ff	 cmp	 ecx, -1
  00c6b	74 36		 je	 SHORT $LN12@GetToken
  00c6d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c71	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00c74	74 1a		 je	 SHORT $LN11@GetToken
  00c76	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c7a	50		 push	 eax
  00c7b	e8 00 00 00 00	 call	 _isdigit
  00c80	83 c4 04	 add	 esp, 4
  00c83	85 c0		 test	 eax, eax
  00c85	75 09		 jne	 SHORT $LN11@GetToken
  00c87	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c8b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00c8e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00c90	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00c93	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00c96	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00c98	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00c9b	83 c0 01	 add	 eax, 1
  00c9e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00ca1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00ca3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ca6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00ca9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00cac	50		 push	 eax
  00cad	e8 00 00 00 00	 call	 _atof
  00cb2	83 c4 04	 add	 esp, 4
  00cb5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00cbb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00cc5	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00cca	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00ccf	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00cd4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00cdb	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00ce0	50		 push	 eax
  00ce1	e8 00 00 00 00	 call	 _getc
  00ce6	83 c4 04	 add	 esp, 4
  00ce9	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00cec	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00cf0	83 f9 ff	 cmp	 ecx, -1
  00cf3	74 1c		 je	 SHORT $LN8@GetToken
  00cf5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00cf9	83 f8 22	 cmp	 eax, 34			; 00000022H
  00cfc	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00cfe	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00d01	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00d04	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00d06	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00d09	83 c0 01	 add	 eax, 1
  00d0c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00d0f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00d11	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d15	83 f8 22	 cmp	 eax, 34			; 00000022H
  00d18	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00d1a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d1f	50		 push	 eax
  00d20	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00d24	51		 push	 ecx
  00d25	e8 00 00 00 00	 call	 _ungetc
  00d2a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00d2d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00d30	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00d33	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00d3d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d42	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00d47	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00d4c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d50	50		 push	 eax
  00d51	e8 00 00 00 00	 call	 _isalpha
  00d56	83 c4 04	 add	 esp, 4
  00d59	85 c0		 test	 eax, eax
  00d5b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00d61	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00d68	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00d6b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00d6e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00d70	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00d73	83 c0 01	 add	 eax, 1
  00d76	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00d79	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d7e	50		 push	 eax
  00d7f	e8 00 00 00 00	 call	 _getc
  00d84	83 c4 04	 add	 esp, 4
  00d87	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00d8a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00d8e	83 f9 ff	 cmp	 ecx, -1
  00d91	74 36		 je	 SHORT $LN3@GetToken
  00d93	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d97	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00d9a	74 1a		 je	 SHORT $LN2@GetToken
  00d9c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00da0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00da3	74 11		 je	 SHORT $LN2@GetToken
  00da5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00da9	50		 push	 eax
  00daa	e8 00 00 00 00	 call	 _isalnum
  00daf	83 c4 04	 add	 esp, 4
  00db2	85 c0		 test	 eax, eax
  00db4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00db6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00db9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00dbc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00dbe	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00dc1	83 c0 01	 add	 eax, 1
  00dc4	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00dc7	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00dc9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00dce	50		 push	 eax
  00dcf	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00dd3	51		 push	 ecx
  00dd4	e8 00 00 00 00	 call	 _ungetc
  00dd9	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  00ddc	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ddf	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00de2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  00dec	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00df1	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00df3	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00df5	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00dff	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e04	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00e06	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00e08	5f		 pop	 edi
  00e09	5e		 pop	 esi
  00e0a	5b		 pop	 ebx
  00e0b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e0e	33 cd		 xor	 ecx, ebp
  00e10	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e15	8b e5		 mov	 esp, ebp
  00e17	5d		 pop	 ebp
  00e18	c3		 ret	 0
  00e19	8d 49 00	 npad	 3
$LN35@GetToken:
  00e1c	00 00 00 00	 DD	 $LN10@GetToken
  00e20	00 00 00 00	 DD	 $LN19@GetToken
  00e24	00 00 00 00	 DD	 $LN17@GetToken
  00e28	00 00 00 00	 DD	 $LN14@GetToken
  00e2c	00 00 00 00	 DD	 $LN18@GetToken
  00e30	00 00 00 00	 DD	 $LN16@GetToken
  00e34	00 00 00 00	 DD	 $LN15@GetToken
  00e38	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00e3c	00		 DB	 0
  00e3d	01		 DB	 1
  00e3e	07		 DB	 7
  00e3f	07		 DB	 7
  00e40	07		 DB	 7
  00e41	07		 DB	 7
  00e42	07		 DB	 7
  00e43	07		 DB	 7
  00e44	07		 DB	 7
  00e45	07		 DB	 7
  00e46	02		 DB	 2
  00e47	03		 DB	 3
  00e48	03		 DB	 3
  00e49	07		 DB	 7
  00e4a	03		 DB	 3
  00e4b	03		 DB	 3
  00e4c	03		 DB	 3
  00e4d	03		 DB	 3
  00e4e	03		 DB	 3
  00e4f	03		 DB	 3
  00e50	03		 DB	 3
  00e51	03		 DB	 3
  00e52	03		 DB	 3
  00e53	03		 DB	 3
  00e54	07		 DB	 7
  00e55	04		 DB	 4
  00e56	07		 DB	 7
  00e57	07		 DB	 7
  00e58	07		 DB	 7
  00e59	07		 DB	 7
  00e5a	07		 DB	 7
  00e5b	07		 DB	 7
  00e5c	07		 DB	 7
  00e5d	07		 DB	 7
  00e5e	07		 DB	 7
  00e5f	07		 DB	 7
  00e60	07		 DB	 7
  00e61	07		 DB	 7
  00e62	07		 DB	 7
  00e63	07		 DB	 7
  00e64	07		 DB	 7
  00e65	07		 DB	 7
  00e66	07		 DB	 7
  00e67	07		 DB	 7
  00e68	07		 DB	 7
  00e69	07		 DB	 7
  00e6a	07		 DB	 7
  00e6b	07		 DB	 7
  00e6c	07		 DB	 7
  00e6d	07		 DB	 7
  00e6e	07		 DB	 7
  00e6f	07		 DB	 7
  00e70	07		 DB	 7
  00e71	07		 DB	 7
  00e72	07		 DB	 7
  00e73	07		 DB	 7
  00e74	07		 DB	 7
  00e75	07		 DB	 7
  00e76	07		 DB	 7
  00e77	07		 DB	 7
  00e78	07		 DB	 7
  00e79	07		 DB	 7
  00e7a	07		 DB	 7
  00e7b	07		 DB	 7
  00e7c	07		 DB	 7
  00e7d	07		 DB	 7
  00e7e	07		 DB	 7
  00e7f	07		 DB	 7
  00e80	07		 DB	 7
  00e81	07		 DB	 7
  00e82	07		 DB	 7
  00e83	07		 DB	 7
  00e84	07		 DB	 7
  00e85	07		 DB	 7
  00e86	07		 DB	 7
  00e87	07		 DB	 7
  00e88	07		 DB	 7
  00e89	07		 DB	 7
  00e8a	07		 DB	 7
  00e8b	07		 DB	 7
  00e8c	07		 DB	 7
  00e8d	07		 DB	 7
  00e8e	07		 DB	 7
  00e8f	07		 DB	 7
  00e90	07		 DB	 7
  00e91	07		 DB	 7
  00e92	07		 DB	 7
  00e93	07		 DB	 7
  00e94	07		 DB	 7
  00e95	05		 DB	 5
  00e96	07		 DB	 7
  00e97	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@ ; `string'
PUBLIC	??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ ; `string'
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
PUBLIC	??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ ; `string'
PUBLIC	?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
PUBLIC	__$ArrayPad$
PUBLIC	?CheckSync@CChaosCastle@@IAEXH@Z		; CChaosCastle::CheckSync
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.cpp
CONST	SEGMENT
??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@ DB '['
	DB	'Chaos Castle] (%d) Sync Start Time. [%d] min remain (START HO'
	DB	'UR:%d, MIN:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
CONST	SEGMENT
??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ DB '['
	DB	'Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Termi'
	DB	'nated (bTIME_CHANGED=%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
CONST	SEGMENT
??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ DB '['
	DB	'Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Termi'
	DB	'nated (m_vtChaosCastleOpenTime.empty())', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv192 = -140						; size = 4
tv67 = -140						; size = 4
$T242004 = -136						; size = 4
$T242005 = -132						; size = 4
$T242006 = -128						; size = 4
$T242007 = -124						; size = 4
$T242008 = -120						; size = 4
$T242009 = -116						; size = 4
_stCCTime$236642 = -48					; size = 4
_stCCTime$236632 = -44					; size = 4
_it$ = -40						; size = 4
_bTIME_CHANGED$ = -36					; size = 4
_iMIN_MINUTE$ = -32					; size = 4
_iMIN_HOUR$ = -28					; size = 4
_sysTime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckSync@CChaosCastle@@IAEXH@Z PROC			; CChaosCastle::CheckSync
; _this$ = ecx

; 305  : {

  00ea0	55		 push	 ebp
  00ea1	8b ec		 mov	 ebp, esp
  00ea3	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00ea9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00eae	33 c5		 xor	 eax, ebp
  00eb0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00eb3	53		 push	 ebx
  00eb4	56		 push	 esi
  00eb5	57		 push	 edi
  00eb6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 306  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00eb9	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  00ebd	7d 0c		 jge	 SHORT $LN20@CheckSync
  00ebf	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00ec9	eb 0f		 jmp	 SHORT $LN21@CheckSync
$LN20@CheckSync:
  00ecb	33 c0		 xor	 eax, eax
  00ecd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  00ed1	0f 9e c0	 setle	 al
  00ed4	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN21@CheckSync:
  00eda	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  00ee1	75 05		 jne	 SHORT $LN17@CheckSync

; 307  : 	{
; 308  : 		return;

  00ee3	e9 cb 02 00 00	 jmp	 $LN18@CheckSync
$LN17@CheckSync:

; 309  : 	}
; 310  : 
; 311  : 	if ( this->m_vtChaosCastleOpenTime.empty() != false )

  00ee8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00eeb	83 c1 20	 add	 ecx, 32			; 00000020H
  00eee	e8 00 00 00 00	 call	 ?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
  00ef3	0f b6 c0	 movzx	 eax, al
  00ef6	85 c0		 test	 eax, eax
  00ef8	74 2a		 je	 SHORT $LN16@CheckSync

; 312  : 	{
; 313  : 		LogAddC(2, "[Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Terminated (m_vtChaosCastleOpenTime.empty())", iChaosCastleIndex);

  00efa	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00efd	50		 push	 eax
  00efe	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
  00f03	6a 02		 push	 2
  00f05	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00f0b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 		this->SetState(iChaosCastleIndex+1, CC_STATE_NONE);

  00f0e	6a 00		 push	 0
  00f10	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00f13	83 c0 01	 add	 eax, 1
  00f16	50		 push	 eax
  00f17	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00f1a	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 315  : 		
; 316  : 		return;

  00f1f	e9 8f 02 00 00	 jmp	 $LN18@CheckSync
$LN16@CheckSync:

; 317  : 	}
; 318  : 
; 319  : 	SYSTEMTIME sysTime;
; 320  : 	GetLocalTime(&sysTime);

  00f24	8d 45 e8	 lea	 eax, DWORD PTR _sysTime$[ebp]
  00f27	50		 push	 eax
  00f28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 321  : 	int iMIN_HOUR = 24;

  00f2e	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 322  : 	int iMIN_MINUTE = 60;

  00f35	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH

; 323  : 	BOOL bTIME_CHANGED = FALSE;

  00f3c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0

; 324  : 	std::vector<CHAOSCASTLE_START_TIME>::iterator it;

  00f43	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00f46	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >

; 325  : 	for (it = this->m_vtChaosCastleOpenTime.begin() ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  00f4b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T242004[ebp]
  00f51	50		 push	 eax
  00f52	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00f55	83 c1 20	 add	 ecx, 32			; 00000020H
  00f58	e8 00 00 00 00	 call	 ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
  00f5d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f5f	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx
  00f62	eb 11		 jmp	 SHORT $LN15@CheckSync
$LN14@CheckSync:
  00f64	6a 00		 push	 0
  00f66	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T242005[ebp]
  00f6c	50		 push	 eax
  00f6d	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00f70	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
$LN15@CheckSync:
  00f75	8d 45 80	 lea	 eax, DWORD PTR $T242006[ebp]
  00f78	50		 push	 eax
  00f79	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00f7c	83 c1 20	 add	 ecx, 32			; 00000020H
  00f7f	e8 00 00 00 00	 call	 ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
  00f84	50		 push	 eax
  00f85	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00f88	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
  00f8d	0f b6 c8	 movzx	 ecx, al
  00f90	85 c9		 test	 ecx, ecx
  00f92	74 62		 je	 SHORT $LN13@CheckSync

; 326  : 	{
; 327  : 		CHAOSCASTLE_START_TIME * stCCTime = &(*it);

  00f94	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00f97	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
  00f9c	89 45 d4	 mov	 DWORD PTR _stCCTime$236632[ebp], eax

; 328  : 
; 329  : 		if ( (sysTime.wHour * 60 + sysTime.wMinute) < (stCCTime->m_iHour * 60 + stCCTime->m_iMinute) )

  00f9f	0f b7 45 f0	 movzx	 eax, WORD PTR _sysTime$[ebp+8]
  00fa3	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00fa6	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  00faa	03 c1		 add	 eax, ecx
  00fac	8b 55 d4	 mov	 edx, DWORD PTR _stCCTime$236632[ebp]
  00faf	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00fb1	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00fb4	8b 55 d4	 mov	 edx, DWORD PTR _stCCTime$236632[ebp]
  00fb7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00fba	3b c1		 cmp	 eax, ecx
  00fbc	7d 33		 jge	 SHORT $LN12@CheckSync

; 330  : 		{
; 331  : 			if ( ( iMIN_HOUR * 60 + iMIN_MINUTE ) > ( stCCTime->m_iHour * 60 + stCCTime->m_iMinute ) )

  00fbe	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  00fc1	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00fc4	03 45 e0	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  00fc7	8b 4d d4	 mov	 ecx, DWORD PTR _stCCTime$236632[ebp]
  00fca	8b 11		 mov	 edx, DWORD PTR [ecx]
  00fcc	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00fcf	8b 4d d4	 mov	 ecx, DWORD PTR _stCCTime$236632[ebp]
  00fd2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00fd5	3b c2		 cmp	 eax, edx
  00fd7	7e 18		 jle	 SHORT $LN12@CheckSync

; 332  : 			{
; 333  : 				bTIME_CHANGED = TRUE;

  00fd9	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1

; 334  : 				iMIN_HOUR = stCCTime->m_iHour;

  00fe0	8b 45 d4	 mov	 eax, DWORD PTR _stCCTime$236632[ebp]
  00fe3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fe5	89 4d e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 335  : 				iMIN_MINUTE = stCCTime->m_iMinute;

  00fe8	8b 45 d4	 mov	 eax, DWORD PTR _stCCTime$236632[ebp]
  00feb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00fee	89 4d e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN12@CheckSync:

; 336  : 			}
; 337  : 		}
; 338  : 	}

  00ff1	e9 6e ff ff ff	 jmp	 $LN14@CheckSync
$LN13@CheckSync:

; 339  : 
; 340  : 	if ( bTIME_CHANGED == FALSE )

  00ff6	83 7d dc 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  00ffa	0f 85 91 00 00
	00		 jne	 $LN10@CheckSync

; 341  : 	{
; 342  : 		it = this->m_vtChaosCastleOpenTime.begin();

  01000	8d 45 84	 lea	 eax, DWORD PTR $T242007[ebp]
  01003	50		 push	 eax
  01004	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01007	83 c1 20	 add	 ecx, 32			; 00000020H
  0100a	e8 00 00 00 00	 call	 ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
  0100f	8b 08		 mov	 ecx, DWORD PTR [eax]
  01011	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx

; 343  : 		iMIN_HOUR = 24;

  01014	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 344  : 		iMIN_MINUTE = 60;

  0101b	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH
  01022	eb 0e		 jmp	 SHORT $LN9@CheckSync
$LN8@CheckSync:

; 345  : 
; 346  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  01024	6a 00		 push	 0
  01026	8d 45 88	 lea	 eax, DWORD PTR $T242008[ebp]
  01029	50		 push	 eax
  0102a	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  0102d	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
$LN9@CheckSync:
  01032	8d 45 8c	 lea	 eax, DWORD PTR $T242009[ebp]
  01035	50		 push	 eax
  01036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01039	83 c1 20	 add	 ecx, 32			; 00000020H
  0103c	e8 00 00 00 00	 call	 ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
  01041	50		 push	 eax
  01042	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01045	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
  0104a	0f b6 c8	 movzx	 ecx, al
  0104d	85 c9		 test	 ecx, ecx
  0104f	74 40		 je	 SHORT $LN10@CheckSync

; 347  : 		{
; 348  : 			CHAOSCASTLE_START_TIME * stCCTime = &(*it);

  01051	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01054	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
  01059	89 45 d0	 mov	 DWORD PTR _stCCTime$236642[ebp], eax

; 349  : 
; 350  : 			if ( ( iMIN_HOUR * 60 + iMIN_MINUTE ) > ( stCCTime->m_iHour * 60 + stCCTime->m_iMinute ) )

  0105c	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  0105f	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01062	03 45 e0	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  01065	8b 4d d0	 mov	 ecx, DWORD PTR _stCCTime$236642[ebp]
  01068	8b 11		 mov	 edx, DWORD PTR [ecx]
  0106a	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0106d	8b 4d d0	 mov	 ecx, DWORD PTR _stCCTime$236642[ebp]
  01070	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  01073	3b c2		 cmp	 eax, edx
  01075	7e 18		 jle	 SHORT $LN6@CheckSync

; 351  : 			{
; 352  : 				bTIME_CHANGED = 2;

  01077	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2

; 353  : 				iMIN_HOUR = stCCTime->m_iHour;

  0107e	8b 45 d0	 mov	 eax, DWORD PTR _stCCTime$236642[ebp]
  01081	8b 08		 mov	 ecx, DWORD PTR [eax]
  01083	89 4d e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 354  : 				iMIN_MINUTE = stCCTime->m_iMinute;

  01086	8b 45 d0	 mov	 eax, DWORD PTR _stCCTime$236642[ebp]
  01089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0108c	89 4d e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN6@CheckSync:

; 355  : 			}
; 356  : 		}

  0108f	eb 93		 jmp	 SHORT $LN8@CheckSync
$LN10@CheckSync:

; 357  : 	}
; 358  : 
; 359  : 	switch ( bTIME_CHANGED )

  01091	8b 45 dc	 mov	 eax, DWORD PTR _bTIME_CHANGED$[ebp]
  01094	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv192[ebp], eax
  0109a	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR tv192[ebp], 1
  010a1	74 0e		 je	 SHORT $LN3@CheckSync
  010a3	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR tv192[ebp], 2
  010aa	74 49		 je	 SHORT $LN2@CheckSync
  010ac	e9 8b 00 00 00	 jmp	 $LN1@CheckSync
$LN3@CheckSync:

; 360  : 	{
; 361  : 		case TRUE:
; 362  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = (((iMIN_HOUR * 60 * 60) + (iMIN_MINUTE * 60)) - ((sysTime.wHour * 60 * 60) + (sysTime.wMinute * 60) + (sysTime.wSecond))) * 1000;

  010b1	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  010b4	6b c0 3c	 imul	 eax, 60			; 0000003cH
  010b7	6b c0 3c	 imul	 eax, 60			; 0000003cH
  010ba	8b 4d e0	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  010bd	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  010c0	03 c1		 add	 eax, ecx
  010c2	0f b7 55 f0	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  010c6	6b d2 3c	 imul	 edx, 60			; 0000003cH
  010c9	6b d2 3c	 imul	 edx, 60			; 0000003cH
  010cc	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  010d0	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  010d3	03 d1		 add	 edx, ecx
  010d5	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  010d9	03 d1		 add	 edx, ecx
  010db	2b c2		 sub	 eax, edx
  010dd	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  010e3	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  010e6	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  010ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  010ef	89 44 11 40	 mov	 DWORD PTR [ecx+edx+64], eax

; 363  : 			break;

  010f3	eb 72		 jmp	 SHORT $LN4@CheckSync
$LN2@CheckSync:

; 364  : 
; 365  : 		case 2:
; 366  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = ((((iMIN_HOUR+24) * 60 * 60) + (iMIN_MINUTE * 60)) - ((sysTime.wHour * 60 * 60) + (sysTime.wMinute * 60) + (sysTime.wSecond))) * 1000;

  010f5	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  010f8	83 c0 18	 add	 eax, 24			; 00000018H
  010fb	6b c0 3c	 imul	 eax, 60			; 0000003cH
  010fe	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01101	8b 4d e0	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  01104	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01107	03 c1		 add	 eax, ecx
  01109	0f b7 55 f0	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  0110d	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01110	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01113	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  01117	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0111a	03 d1		 add	 edx, ecx
  0111c	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  01120	03 d1		 add	 edx, ecx
  01122	2b c2		 sub	 eax, edx
  01124	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  0112a	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0112d	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  01133	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01136	89 44 11 40	 mov	 DWORD PTR [ecx+edx+64], eax

; 367  : 			break;

  0113a	eb 2b		 jmp	 SHORT $LN4@CheckSync
$LN1@CheckSync:

; 368  : 
; 369  : 		default:
; 370  : 			LogAddC(2, "[Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Terminated (bTIME_CHANGED=%d)",
; 371  : 				iChaosCastleIndex + 1, bTIME_CHANGED);

  0113c	8b 45 dc	 mov	 eax, DWORD PTR _bTIME_CHANGED$[ebp]
  0113f	50		 push	 eax
  01140	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01143	83 c1 01	 add	 ecx, 1
  01146	51		 push	 ecx
  01147	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
  0114c	6a 02		 push	 2
  0114e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01154	83 c4 10	 add	 esp, 16			; 00000010H

; 372  : 			this->SetState(iChaosCastleIndex, CC_STATE_NONE);

  01157	6a 00		 push	 0
  01159	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0115c	50		 push	 eax
  0115d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01160	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 373  : 			return;

  01165	eb 4c		 jmp	 SHORT $LN18@CheckSync
$LN4@CheckSync:

; 374  : 
; 375  : 	}
; 376  : 
; 377  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  01167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0116d	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01170	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  01176	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01179	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 378  : 
; 379  : 	LogAddTD("[Chaos Castle] (%d) Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)",
; 380  : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000,
; 381  : 		iMIN_HOUR, iMIN_MINUTE);

  0117d	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  01180	50		 push	 eax
  01181	8b 4d e4	 mov	 ecx, DWORD PTR _iMIN_HOUR$[ebp]
  01184	51		 push	 ecx
  01185	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  01188	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  0118e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01191	8b 44 10 40	 mov	 eax, DWORD PTR [eax+edx+64]
  01195	99		 cdq
  01196	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0119b	f7 f9		 idiv	 ecx
  0119d	50		 push	 eax
  0119e	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  011a1	83 c2 01	 add	 edx, 1
  011a4	52		 push	 edx
  011a5	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@
  011aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  011b0	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@CheckSync:

; 382  : }

  011b3	5f		 pop	 edi
  011b4	5e		 pop	 esi
  011b5	5b		 pop	 ebx
  011b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011b9	33 cd		 xor	 ecx, ebp
  011bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011c0	8b e5		 mov	 esp, ebp
  011c2	5d		 pop	 ebp
  011c3	c2 04 00	 ret	 4
?CheckSync@CChaosCastle@@IAEXH@Z ENDP			; CChaosCastle::CheckSync
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_None@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_None
; _this$ = ecx

; 385  : {

  011d0	55		 push	 ebp
  011d1	8b ec		 mov	 ebp, esp
  011d3	83 ec 44	 sub	 esp, 68			; 00000044H
  011d6	53		 push	 ebx
  011d7	56		 push	 esi
  011d8	57		 push	 edi
  011d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 386  : 	return;
; 387  : }

  011dc	5f		 pop	 edi
  011dd	5e		 pop	 esi
  011de	5b		 pop	 ebx
  011df	8b e5		 mov	 esp, ebp
  011e1	5d		 pop	 ebp
  011e2	c2 04 00	 ret	 4
?ProcState_None@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_None
_TEXT	ENDS
PUBLIC	?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z	; CChaosCastle::SendAllUserAnyMsg
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?g_bChaosCastle@@3HA:DWORD			; g_bChaosCastle
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv259 = -364						; size = 4
tv240 = -364						; size = 4
tv260 = -360						; size = 4
tv241 = -360						; size = 4
_i$236673 = -292					; size = 4
_pMsg$236671 = -288					; size = 4
_pNotice$236667 = -284					; size = 272
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_Closed@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_Closed
; _this$ = ecx

; 390  : {

  011f0	55		 push	 ebp
  011f1	8b ec		 mov	 ebp, esp
  011f3	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  011f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  011fe	33 c5		 xor	 eax, ebp
  01200	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01203	53		 push	 ebx
  01204	56		 push	 esi
  01205	57		 push	 edi
  01206	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  01209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0120f	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01212	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  01218	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0121b	2b 44 0a 44	 sub	 eax, DWORD PTR [edx+ecx+68]
  0121f	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 392  : 
; 393  : 	if ( iTICK_MSEC >= 1000 )

  01222	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  01229	0f 8c b5 03 00
	00		 jl	 $LN16@ProcState_

; 394  : 	{
; 395  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  0122f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01232	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01238	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0123b	8b 54 01 40	 mov	 edx, DWORD PTR [ecx+eax+64]
  0123f	2b 55 f4	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  01242	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01245	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0124b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0124e	89 54 01 40	 mov	 DWORD PTR [ecx+eax+64], edx

; 396  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  01252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01258	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0125b	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  01261	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01264	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 397  : 
; 398  : 		if ( g_bChaosCastle != FALSE )

  01268	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle
  0126f	0f 84 6f 03 00
	00		 je	 $LN16@ProcState_

; 399  : 		{
; 400  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ( this->m_iCC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER == false)

  01275	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01278	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0127e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01281	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01284	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01287	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0128d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01290	39 54 01 40	 cmp	 DWORD PTR [ecx+eax+64], edx
  01294	7f 37		 jg	 SHORT $LN14@ProcState_
  01296	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01299	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0129f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012a2	0f b6 54 01 4c	 movzx	 edx, BYTE PTR [ecx+eax+76]
  012a7	85 d2		 test	 edx, edx
  012a9	75 22		 jne	 SHORT $LN14@ProcState_

; 401  : 			{
; 402  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = true;

  012ab	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  012ae	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  012b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012b7	c6 44 01 4c 01	 mov	 BYTE PTR [ecx+eax+76], 1

; 403  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_PARTY = true;

  012bc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  012bf	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  012c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012c8	c6 44 01 4d 01	 mov	 BYTE PTR [ecx+eax+77], 1
$LN14@ProcState_:

; 404  : 			}
; 405  : 
; 406  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ( this->m_iCC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && (this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC/60000) !=this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT)

  012cd	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  012d0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  012d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012d9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  012dc	6b d2 3c	 imul	 edx, 60			; 0000003cH
  012df	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  012e5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012e8	39 54 01 40	 cmp	 DWORD PTR [ecx+eax+64], edx
  012ec	0f 8f bb 00 00
	00		 jg	 $LN13@ProcState_
  012f2	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  012f5	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  012fb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012fe	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  01303	0f 8e a4 00 00
	00		 jle	 $LN13@ProcState_
  01309	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0130c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01312	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01315	8b 44 01 40	 mov	 eax, DWORD PTR [ecx+eax+64]
  01319	99		 cdq
  0131a	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0131f	f7 f9		 idiv	 ecx
  01321	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  01324	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  0132a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0132d	3b 44 11 48	 cmp	 eax, DWORD PTR [ecx+edx+72]
  01331	74 7a		 je	 SHORT $LN13@ProcState_

; 407  : 			{
; 408  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000;

  01333	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01336	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0133c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0133f	8b 44 01 40	 mov	 eax, DWORD PTR [ecx+eax+64]
  01343	99		 cdq
  01344	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  01349	f7 f9		 idiv	 ecx
  0134b	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0134e	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  01354	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01357	89 44 11 48	 mov	 DWORD PTR [ecx+edx+72], eax

; 409  : 
; 410  : 				if ( iChaosCastleIndex == 0 )

  0135b	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  0135f	75 4c		 jne	 SHORT $LN13@ProcState_

; 411  : 				{
; 412  : 					PMSG_NOTICE pNotice;
; 413  : 
; 414  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 208)), this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT+1);

  01361	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01364	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0136a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0136d	8b 54 01 48	 mov	 edx, DWORD PTR [ecx+eax+72]
  01371	83 c2 01	 add	 edx, 1
  01374	52		 push	 edx
  01375	68 d0 04 00 00	 push	 1232			; 000004d0H
  0137a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0137f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01384	50		 push	 eax
  01385	6a 00		 push	 0
  01387	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$236667[ebp]
  0138d	50		 push	 eax
  0138e	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  01393	83 c4 10	 add	 esp, 16			; 00000010H

; 415  : 					this->SendAllUserAnyMsg( (LPBYTE)&pNotice, pNotice.h.size);

  01396	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$236667[ebp+1]
  0139d	50		 push	 eax
  0139e	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$236667[ebp]
  013a4	51		 push	 ecx
  013a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013a8	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z ; CChaosCastle::SendAllUserAnyMsg
$LN13@ProcState_:

; 416  : 				}
; 417  : 			}
; 418  : 
; 419  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_ENTER == false )

  013ad	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  013b0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  013b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013b9	81 7c 01 40 30
	75 00 00	 cmp	 DWORD PTR [ecx+eax+64], 30000 ; 00007530H
  013c1	0f 8f 1d 02 00
	00		 jg	 $LN16@ProcState_
  013c7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  013ca	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  013d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013d3	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  013d8	0f 8e 06 02 00
	00		 jle	 $LN16@ProcState_
  013de	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  013e1	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  013e7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013ea	0f b6 54 01 4f	 movzx	 edx, BYTE PTR [ecx+eax+79]
  013ef	85 d2		 test	 edx, edx
  013f1	0f 85 ed 01 00
	00		 jne	 $LN16@ProcState_

; 420  : 			{
; 421  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_ENTER = true;

  013f7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  013fa	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01400	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01403	c6 44 01 4f 01	 mov	 BYTE PTR [ecx+eax+79], 1

; 422  : 
; 423  : 				if ( iChaosCastleIndex == 0 )

  01408	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  0140c	0f 85 d2 01 00
	00		 jne	 $LN16@ProcState_

; 424  : 				{
; 425  : 					PMSG_SET_DEVILSQUARE pMsg;
; 426  : 
; 427  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  01412	6a 04		 push	 4
  01414	68 92 00 00 00	 push	 146			; 00000092H
  01419	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$236671[ebp]
  0141f	50		 push	 eax
  01420	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  01425	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 					pMsg.Type = 10;

  01428	c6 85 e3 fe ff
	ff 0a		 mov	 BYTE PTR _pMsg$236671[ebp+3], 10 ; 0000000aH

; 429  : 
; 430  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0142f	c7 85 dc fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$236673[ebp], 14000 ; 000036b0H
  01439	eb 0f		 jmp	 SHORT $LN9@ProcState_
$LN8@ProcState_:
  0143b	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  01441	83 c0 01	 add	 eax, 1
  01444	89 85 dc fe ff
	ff		 mov	 DWORD PTR _i$236673[ebp], eax
$LN9@ProcState_:
  0144a	81 bd dc fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$236673[ebp], 15000 ; 00003a98H
  01454	0f 8d 8a 01 00
	00		 jge	 $LN16@ProcState_

; 431  : 					{
; 432  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  0145a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  01460	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01466	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0146c	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  01471	0f 85 68 01 00
	00		 jne	 $LN6@ProcState_
  01477	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  0147d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01483	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01489	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0148e	83 fa 01	 cmp	 edx, 1
  01491	0f 85 48 01 00
	00		 jne	 $LN6@ProcState_

; 433  : 						{
; 434  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  01497	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  0149d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  014a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014a9	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  014b1	83 fa 35	 cmp	 edx, 53			; 00000035H
  014b4	75 0c		 jne	 SHORT $LN21@ProcState_
  014b6	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv241[ebp], 1
  014c0	eb 5f		 jmp	 SHORT $LN22@ProcState_
$LN21@ProcState_:
  014c2	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  014c8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  014ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014d4	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  014dc	83 fa 12	 cmp	 edx, 18			; 00000012H
  014df	7d 0c		 jge	 SHORT $LN19@ProcState_
  014e1	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv240[ebp], 0
  014eb	eb 28		 jmp	 SHORT $LN20@ProcState_
$LN19@ProcState_:
  014ed	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  014f3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  014f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014ff	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01507	33 c0		 xor	 eax, eax
  01509	83 fa 17	 cmp	 edx, 23			; 00000017H
  0150c	0f 9e c0	 setle	 al
  0150f	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
$LN20@ProcState_:
  01515	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  0151b	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN22@ProcState_:
  01521	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv241[ebp], 0
  01528	0f 85 b1 00 00
	00		 jne	 $LN6@ProcState_

; 435  : 							{
; 436  : 								if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  0152e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  01534	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0153a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01540	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01548	83 fa 34	 cmp	 edx, 52			; 00000034H
  0154b	75 0c		 jne	 SHORT $LN25@ProcState_
  0154d	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv260[ebp], 1
  01557	eb 5f		 jmp	 SHORT $LN26@ProcState_
$LN25@ProcState_:
  01559	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  0155f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01565	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0156b	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01573	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  01576	7d 0c		 jge	 SHORT $LN23@ProcState_
  01578	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
  01582	eb 28		 jmp	 SHORT $LN24@ProcState_
$LN23@ProcState_:
  01584	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236673[ebp]
  0158a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01590	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01596	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0159e	33 c0		 xor	 eax, eax
  015a0	83 fa 11	 cmp	 edx, 17			; 00000011H
  015a3	0f 9e c0	 setle	 al
  015a6	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv259[ebp], eax
$LN24@ProcState_:
  015ac	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv259[ebp]
  015b2	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv260[ebp], ecx
$LN26@ProcState_:
  015b8	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv260[ebp], 0
  015bf	75 1e		 jne	 SHORT $LN6@ProcState_

; 437  : 								{
; 438  : 									DataSend(i, (LPBYTE)&pMsg, pMsg.h.size);

  015c1	0f b6 85 e1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$236671[ebp+1]
  015c8	50		 push	 eax
  015c9	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$236671[ebp]
  015cf	51		 push	 ecx
  015d0	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _i$236673[ebp]
  015d6	52		 push	 edx
  015d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  015dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@ProcState_:

; 439  : 								}
; 440  : 							}
; 441  : 						}
; 442  : 					}

  015df	e9 57 fe ff ff	 jmp	 $LN8@ProcState_
$LN16@ProcState_:

; 443  : 				}
; 444  : 			}
; 445  : 		}
; 446  : 	}
; 447  : 
; 448  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  015e4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  015e7	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  015ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  015f0	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  015f5	7f 27		 jg	 SHORT $LN17@ProcState_

; 449  : 	{
; 450  : 		if ( g_bChaosCastle != FALSE )

  015f7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle
  015fe	74 10		 je	 SHORT $LN2@ProcState_

; 451  : 		{
; 452  : 			this->SetState(iChaosCastleIndex, CC_STATE_PLAYING);

  01600	6a 02		 push	 2
  01602	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01605	50		 push	 eax
  01606	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01609	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 453  : 		}
; 454  : 		else

  0160e	eb 0e		 jmp	 SHORT $LN17@ProcState_
$LN2@ProcState_:

; 455  : 		{
; 456  : 			this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  01610	6a 01		 push	 1
  01612	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01615	50		 push	 eax
  01616	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01619	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN17@ProcState_:

; 457  : 		}
; 458  : 	}
; 459  : }

  0161e	5f		 pop	 edi
  0161f	5e		 pop	 esi
  01620	5b		 pop	 ebx
  01621	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01624	33 cd		 xor	 ecx, ebp
  01626	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0162b	8b e5		 mov	 esp, ebp
  0162d	5d		 pop	 ebp
  0162e	c2 04 00	 ret	 4
?ProcState_Closed@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	?GetCurrentState@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetCurrentState
PUBLIC	??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@ ; `string'
PUBLIC	?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z	; CChaosCastle::SendAllLoserFailMessage
PUBLIC	??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ ; `string'
PUBLIC	??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ ; `string'
PUBLIC	?GiveWinnerItem@CChaosCastle@@QAEXHH@Z		; CChaosCastle::GiveWinnerItem
PUBLIC	?SendWinMessage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendWinMessage
PUBLIC	??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@ ; `string'
PUBLIC	?GetCurrentWinUser@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurrentWinUser
PUBLIC	?GetMonsterListCount@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetMonsterListCount
PUBLIC	?CheckPlayEnded@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckPlayEnded
PUBLIC	?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z	; CChaosCastle::PullObjInnerPlace
PUBLIC	?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z	; CChaosCastle::SetMapAttrHollow
PUBLIC	?ProcessTrapStatus@CChaosCastle@@QAEXH@Z	; CChaosCastle::ProcessTrapStatus
PUBLIC	?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckMonsterInDieTile
PUBLIC	?CheckUserInDieTile@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckUserInDieTile
PUBLIC	?ProcessFallUser@CChaosCastle@@QAEXH@Z		; CChaosCastle::ProcessFallUser
PUBLIC	??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ ; `string'
PUBLIC	??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ ; `string'
PUBLIC	?GetCurPlayUser@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetCurPlayUser
PUBLIC	?SendNoticeState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendNoticeState
PUBLIC	?SetItemsToMonster@CChaosCastle@@QAEXH@Z	; CChaosCastle::SetItemsToMonster
PUBLIC	?SetMonster@CChaosCastle@@QAEHH@Z		; CChaosCastle::SetMonster
PUBLIC	?ReCalcUserCount@CChaosCastle@@QAEHH@Z		; CChaosCastle::ReCalcUserCount
PUBLIC	?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo
PUBLIC	?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z	; CChaosCastle::UnSafetyCastleZone
PUBLIC	?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Chaos Castle][Bug Tracer] (%d) Left Monster AttrInfo %d/%d', 00H ; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@
CONST	SEGMENT
??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@ DB '['
	DB	'Chaos Castle] (%d) is Over : TIME-OUT (Left User:%d, Monster:'
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
CONST	SEGMENT
??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ DB '['
	DB	'Chaos Castle] (%d) Has No Winner : Monster Left (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
CONST	SEGMENT
??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ DB '['
	DB	'Chaos Castle] (%d) Has No Winner.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
CONST	SEGMENT
??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class='
	DB	'%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Ene'
	DB	'rgy=%d, LeaderShip=%d, Map=%d, Pk=%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
CONST	SEGMENT
??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ DB '['
	DB	'Chaos Castle] (%d) Chaos Castle Quest Closed - No User', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
CONST	SEGMENT
??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ DB '['
	DB	'Chaos Castle] (%d) Chaos Castle Quest Start (UserCount:%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv666 = -404						; size = 4
tv667 = -400						; size = 4
tv637 = -400						; size = 4
_CC_MONSTER_COUNT$236758 = -332				; size = 4
_i$236753 = -328					; size = 4
_iMonsterCount$236747 = -324				; size = 4
_iWinnerIndex$236746 = -320				; size = 4
_iMonsterCount$236738 = -316				; size = 4
_iWinnerIndex$236737 = -312				; size = 4
_iMonsterCount$236728 = -308				; size = 4
_iWinnerIndex$236727 = -304				; size = 4
_bPlayEnded$236725 = -300				; size = 4
_iCurPlayUser$236720 = -296				; size = 4
_pNotice$236715 = -292					; size = 272
_pMsg$236711 = -20					; size = 4
_pMsg$236707 = -16					; size = 4
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_Playing@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_Playing
; _this$ = ecx

; 462  : {

  01640	55		 push	 ebp
  01641	8b ec		 mov	 ebp, esp
  01643	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  01649	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0164e	33 c5		 xor	 eax, ebp
  01650	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01653	53		 push	 ebx
  01654	56		 push	 esi
  01655	57		 push	 edi
  01656	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  01659	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0165f	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01662	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  01668	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0166b	2b 44 0a 44	 sub	 eax, DWORD PTR [edx+ecx+68]
  0166f	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 464  : 
; 465  : 	if ( iTICK_MSEC >= 1000 )

  01672	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  01679	0f 8c 87 08 00
	00		 jl	 $LN16@ProcState_@2

; 466  : 	{
; 467  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  0167f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01682	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01688	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0168b	8b 54 01 40	 mov	 edx, DWORD PTR [ecx+eax+64]
  0168f	2b 55 f4	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  01692	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01695	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0169b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0169e	89 54 01 40	 mov	 DWORD PTR [ecx+eax+64], edx

; 468  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  016a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  016a8	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  016ab	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  016b1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  016b4	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 469  : 
; 470  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ((this->m_iCC_TIME_MIN_PLAY*60-30)*1000) &&
; 471  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_PLAY == false )

  016b8	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  016bb	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  016c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  016c4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  016c7	6b d2 3c	 imul	 edx, 60			; 0000003cH
  016ca	83 ea 1e	 sub	 edx, 30			; 0000001eH
  016cd	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  016d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  016d6	39 54 01 40	 cmp	 DWORD PTR [ecx+eax+64], edx
  016da	7f 4f		 jg	 SHORT $LN33@ProcState_@2
  016dc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  016df	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  016e5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  016e8	0f b6 54 01 50	 movzx	 edx, BYTE PTR [ecx+eax+80]
  016ed	85 d2		 test	 edx, edx
  016ef	75 3a		 jne	 SHORT $LN33@ProcState_@2

; 472  : 		{
; 473  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_PLAY = true;

  016f1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  016f4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  016fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  016fd	c6 44 01 50 01	 mov	 BYTE PTR [ecx+eax+80], 1

; 474  : 			
; 475  : 			PMSG_SET_DEVILSQUARE pMsg;
; 476  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  01702	6a 04		 push	 4
  01704	68 92 00 00 00	 push	 146			; 00000092H
  01709	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$236707[ebp]
  0170c	50		 push	 eax
  0170d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  01712	83 c4 0c	 add	 esp, 12			; 0000000cH

; 477  : 			pMsg.Type = 11;

  01715	c6 45 f3 0b	 mov	 BYTE PTR _pMsg$236707[ebp+3], 11 ; 0000000bH

; 478  : 			this->SendChaosCastleAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  01719	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0171c	50		 push	 eax
  0171d	6a 04		 push	 4
  0171f	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$236707[ebp]
  01722	51		 push	 ecx
  01723	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01726	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN33@ProcState_@2:

; 479  : 		}
; 480  : 
; 481  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 &&
; 482  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0  &&
; 483  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_END == false )

  0172b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0172e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01734	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01737	81 7c 01 40 30
	75 00 00	 cmp	 DWORD PTR [ecx+eax+64], 30000 ; 00007530H
  0173f	7f 62		 jg	 SHORT $LN32@ProcState_@2
  01741	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01744	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0174a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0174d	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  01752	7e 4f		 jle	 SHORT $LN32@ProcState_@2
  01754	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01757	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0175d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01760	0f b6 54 01 51	 movzx	 edx, BYTE PTR [ecx+eax+81]
  01765	85 d2		 test	 edx, edx
  01767	75 3a		 jne	 SHORT $LN32@ProcState_@2

; 484  : 		{
; 485  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_END = true;

  01769	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0176c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01772	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01775	c6 44 01 51 01	 mov	 BYTE PTR [ecx+eax+81], 1

; 486  : 			PMSG_SET_DEVILSQUARE pMsg;
; 487  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0177a	6a 04		 push	 4
  0177c	68 92 00 00 00	 push	 146			; 00000092H
  01781	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$236711[ebp]
  01784	50		 push	 eax
  01785	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0178a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 488  : 			pMsg.Type = 12;

  0178d	c6 45 ef 0c	 mov	 BYTE PTR _pMsg$236711[ebp+3], 12 ; 0000000cH

; 489  : 			this->SendChaosCastleAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  01791	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01794	50		 push	 eax
  01795	6a 04		 push	 4
  01797	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$236711[ebp]
  0179a	51		 push	 ecx
  0179b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0179e	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN32@ProcState_@2:

; 490  : 		}
; 491  : 
; 492  : 		// Set Play Quest
; 493  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ((this->m_iCC_TIME_MIN_PLAY*60-60)*1000) &&
; 494  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == false )

  017a3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  017a6	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  017ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017af	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  017b2	6b d2 3c	 imul	 edx, 60			; 0000003cH
  017b5	83 ea 3c	 sub	 edx, 60			; 0000003cH
  017b8	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  017be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017c1	39 54 01 40	 cmp	 DWORD PTR [ecx+eax+64], edx
  017c5	0f 8f 4b 01 00
	00		 jg	 $LN31@ProcState_@2
  017cb	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  017ce	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  017d4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017d7	0f b6 54 01 4e	 movzx	 edx, BYTE PTR [ecx+eax+78]
  017dc	85 d2		 test	 edx, edx
  017de	0f 85 32 01 00
	00		 jne	 $LN31@ProcState_@2

; 495  : 		{
; 496  : 			PMSG_NOTICE pNotice;
; 497  : 
; 498  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = (this->m_iCC_TIME_MIN_PLAY*60)*1000;

  017e4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  017e7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  017ea	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  017ed	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  017f3	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  017f6	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  017fc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  017ff	89 4c 10 40	 mov	 DWORD PTR [eax+edx+64], ecx

; 499  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_PARTY = false;

  01803	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01806	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0180c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0180f	c6 44 01 4d 00	 mov	 BYTE PTR [ecx+eax+77], 0

; 500  : 
; 501  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4,209)), iChaosCastleIndex+1);

  01814	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01817	83 c0 01	 add	 eax, 1
  0181a	50		 push	 eax
  0181b	68 d1 04 00 00	 push	 1233			; 000004d1H
  01820	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01825	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0182a	50		 push	 eax
  0182b	6a 00		 push	 0
  0182d	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$236715[ebp]
  01833	51		 push	 ecx
  01834	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  01839	83 c4 10	 add	 esp, 16			; 00000010H

; 502  : 			this->SendChaosCastleAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iChaosCastleIndex);

  0183c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0183f	50		 push	 eax
  01840	0f b6 8d dd fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$236715[ebp+1]
  01847	51		 push	 ecx
  01848	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$236715[ebp]
  0184e	52		 push	 edx
  0184f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01852	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg

; 503  : 
; 504  : 			this->UnSafetyCastleZone(iChaosCastleIndex);

  01857	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0185a	50		 push	 eax
  0185b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0185e	e8 00 00 00 00	 call	 ?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z ; CChaosCastle::UnSafetyCastleZone

; 505  : 			this->SendCastleZoneSafetyInfo(iChaosCastleIndex, 0);

  01863	6a 00		 push	 0
  01865	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01868	50		 push	 eax
  01869	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0186c	e8 00 00 00 00	 call	 ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo

; 506  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START = true;

  01871	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01874	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0187a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0187d	c6 44 01 4e 01	 mov	 BYTE PTR [ecx+eax+78], 1

; 507  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_USER_COUNT = this->ReCalcUserCount(iChaosCastleIndex);

  01882	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01885	50		 push	 eax
  01886	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01889	e8 00 00 00 00	 call	 ?ReCalcUserCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::ReCalcUserCount
  0188e	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01891	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  01897	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0189a	89 44 0a 58	 mov	 DWORD PTR [edx+ecx+88], eax

; 508  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT = this->SetMonster(iChaosCastleIndex);

  0189e	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  018a1	50		 push	 eax
  018a2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018a5	e8 00 00 00 00	 call	 ?SetMonster@CChaosCastle@@QAEHH@Z ; CChaosCastle::SetMonster
  018aa	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  018ad	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  018b3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  018b6	89 44 0a 60	 mov	 DWORD PTR [edx+ecx+96], eax

; 509  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT; 

  018ba	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  018bd	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  018c3	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  018c6	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  018cc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  018cf	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  018d2	8b 44 06 60	 mov	 eax, DWORD PTR [esi+eax+96]
  018d6	89 44 0a 5c	 mov	 DWORD PTR [edx+ecx+92], eax

; 510  : 			this->SetItemsToMonster(iChaosCastleIndex);

  018da	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  018dd	50		 push	 eax
  018de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018e1	e8 00 00 00 00	 call	 ?SetItemsToMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::SetItemsToMonster

; 511  : 			this->SendNoticeState(iChaosCastleIndex, 5);

  018e6	6a 05		 push	 5
  018e8	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  018eb	50		 push	 eax
  018ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018ef	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 512  : 			
; 513  : 			LogAddTD("[Chaos Castle] (%d) Chaos Castle Quest Start (UserCount:%d)",	iChaosCastleIndex+1, this->GetCurPlayUser(iChaosCastleIndex));

  018f4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  018f7	50		 push	 eax
  018f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018fb	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  01900	50		 push	 eax
  01901	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01904	83 c1 01	 add	 ecx, 1
  01907	51		 push	 ecx
  01908	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
  0190d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01913	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@ProcState_@2:

; 514  : 		}
; 515  : 
; 516  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == false && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER == false )

  01916	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01919	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0191f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01922	0f b6 54 01 4e	 movzx	 edx, BYTE PTR [ecx+eax+78]
  01927	85 d2		 test	 edx, edx
  01929	75 58		 jne	 SHORT $LN29@ProcState_@2
  0192b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0192e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01934	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01937	0f b6 54 01 4c	 movzx	 edx, BYTE PTR [ecx+eax+76]
  0193c	85 d2		 test	 edx, edx
  0193e	75 43		 jne	 SHORT $LN29@ProcState_@2

; 517  : 		{
; 518  : 			int iCurPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  01940	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01943	50		 push	 eax
  01944	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01947	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0194c	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _iCurPlayUser$236720[ebp], eax

; 519  : 
; 520  : 			if (iCurPlayUser == 0 )

  01952	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _iCurPlayUser$236720[ebp], 0
  01959	75 28		 jne	 SHORT $LN29@ProcState_@2

; 521  : 			{
; 522  : 				this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  0195b	6a 01		 push	 1
  0195d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01960	50		 push	 eax
  01961	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01964	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 523  : 				LogAddTD("[Chaos Castle] (%d) Chaos Castle Quest Closed - No User",	iChaosCastleIndex+1);

  01969	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0196c	83 c0 01	 add	 eax, 1
  0196f	50		 push	 eax
  01970	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
  01975	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0197b	83 c4 08	 add	 esp, 8

; 524  : 				return;

  0197e	e9 07 0a 00 00	 jmp	 $LN35@ProcState_@2
$LN29@ProcState_@2:

; 525  : 			}
; 526  : 		}
; 527  : 
; 528  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == true )

  01983	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01986	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0198c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0198f	0f b6 54 01 4e	 movzx	 edx, BYTE PTR [ecx+eax+78]
  01994	83 fa 01	 cmp	 edx, 1
  01997	0f 85 69 05 00
	00		 jne	 $LN16@ProcState_@2

; 529  : 		{
; 530  : 			this->ProcessFallUser(iChaosCastleIndex);

  0199d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  019a0	50		 push	 eax
  019a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019a4	e8 00 00 00 00	 call	 ?ProcessFallUser@CChaosCastle@@QAEXH@Z ; CChaosCastle::ProcessFallUser

; 531  : 			this->CheckUserInDieTile(iChaosCastleIndex);

  019a9	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  019ac	50		 push	 eax
  019ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019b0	e8 00 00 00 00	 call	 ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckUserInDieTile

; 532  : 			this->CheckMonsterInDieTile(iChaosCastleIndex);

  019b5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  019b8	50		 push	 eax
  019b9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019bc	e8 00 00 00 00	 call	 ?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckMonsterInDieTile

; 533  : 			this->ProcessTrapStatus(iChaosCastleIndex);

  019c1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  019c4	50		 push	 eax
  019c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019c8	e8 00 00 00 00	 call	 ?ProcessTrapStatus@CChaosCastle@@QAEXH@Z ; CChaosCastle::ProcessTrapStatus

; 534  : 
; 535  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS != this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_OLD_STATUS )

  019cd	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  019d0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  019d6	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  019d9	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  019df	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  019e2	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  019e5	8b 44 02 64	 mov	 eax, DWORD PTR [edx+eax+100]
  019e9	3b 44 0e 68	 cmp	 eax, DWORD PTR [esi+ecx+104]
  019ed	74 5a		 je	 SHORT $LN27@ProcState_@2

; 536  : 			{
; 537  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_OLD_STATUS = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS;

  019ef	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  019f2	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  019f8	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  019fb	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  01a01	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01a04	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  01a07	8b 44 06 64	 mov	 eax, DWORD PTR [esi+eax+100]
  01a0b	89 44 0a 68	 mov	 DWORD PTR [edx+ecx+104], eax

; 538  : 				this->SetMapAttrHollow(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS);

  01a0f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a12	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01a18	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a1b	8b 54 01 64	 mov	 edx, DWORD PTR [ecx+eax+100]
  01a1f	52		 push	 edx
  01a20	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a23	50		 push	 eax
  01a24	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a27	e8 00 00 00 00	 call	 ?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetMapAttrHollow

; 539  : 				this->PullObjInnerPlace(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS);

  01a2c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a2f	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01a35	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a38	8b 54 01 64	 mov	 edx, DWORD PTR [ecx+eax+100]
  01a3c	52		 push	 edx
  01a3d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a40	50		 push	 eax
  01a41	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a44	e8 00 00 00 00	 call	 ?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z ; CChaosCastle::PullObjInnerPlace
$LN27@ProcState_@2:

; 540  : 			}
; 541  : 
; 542  : 			BOOL bPlayEnded = this->CheckPlayEnded(iChaosCastleIndex);

  01a49	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a4c	50		 push	 eax
  01a4d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a50	e8 00 00 00 00	 call	 ?CheckPlayEnded@CChaosCastle@@QAEHH@Z ; CChaosCastle::CheckPlayEnded
  01a55	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _bPlayEnded$236725[ebp], eax

; 543  : 
; 544  : 			if ( bPlayEnded == TRUE )

  01a5b	83 bd d4 fe ff
	ff 01		 cmp	 DWORD PTR _bPlayEnded$236725[ebp], 1
  01a62	0f 85 3d 02 00
	00		 jne	 $LN26@ProcState_@2

; 545  : 			{
; 546  : 				int iWinnerIndex = -1;

  01a68	c7 85 d0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$236727[ebp], -1

; 547  : 				int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  01a72	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a75	50		 push	 eax
  01a76	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a79	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  01a7e	89 85 cc fe ff
	ff		 mov	 DWORD PTR _iMonsterCount$236728[ebp], eax

; 548  : 
; 549  : 				if ( iMonsterCount <= 0 )

  01a84	83 bd cc fe ff
	ff 00		 cmp	 DWORD PTR _iMonsterCount$236728[ebp], 0
  01a8b	0f 8f c8 01 00
	00		 jg	 $LN25@ProcState_@2

; 550  : 				{
; 551  : 					iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  01a91	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01a94	50		 push	 eax
  01a95	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a98	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  01a9d	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _iWinnerIndex$236727[ebp], eax

; 552  : 
; 553  : 					if ( iWinnerIndex != -1 )

  01aa3	83 bd d0 fe ff
	ff ff		 cmp	 DWORD PTR _iWinnerIndex$236727[ebp], -1
  01aaa	0f 84 92 01 00
	00		 je	 $LN24@ProcState_@2

; 554  : 					{
; 555  : 						LogAddTD("[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 556  : 							iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 557  : 							gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 558  : 							gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 559  : 							gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 560  : 							gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  01ab0	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01ab6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01abc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ac2	0f be 94 01 3d
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+317]
  01aca	52		 push	 edx
  01acb	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01ad1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ad7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01add	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01ae5	52		 push	 edx
  01ae6	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01aec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01af2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01af8	0f b7 94 01 18
	01 00 00	 movzx	 edx, WORD PTR [ecx+eax+280]
  01b00	52		 push	 edx
  01b01	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01b07	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b13	0f b7 94 01 fa
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+250]
  01b1b	52		 push	 edx
  01b1c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01b22	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b28	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b2e	0f b7 94 01 f8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+248]
  01b36	52		 push	 edx
  01b37	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01b3d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b43	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b49	0f b7 94 01 f6
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+246]
  01b51	52		 push	 edx
  01b52	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01b58	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b64	0f b7 94 01 f4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+244]
  01b6c	52		 push	 edx
  01b6d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01b73	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b79	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b7f	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  01b86	52		 push	 edx
  01b87	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01b8d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b99	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  01ba0	52		 push	 edx
  01ba1	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01ba7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01bad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01bb3	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  01bbb	52		 push	 edx
  01bbc	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01bc2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01bc8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01bce	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  01bd6	52		 push	 edx
  01bd7	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01bdd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01be3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01be9	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  01bed	52		 push	 edx
  01bee	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01bf4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01bfa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c00	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  01c04	52		 push	 edx
  01c05	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01c08	83 c0 01	 add	 eax, 1
  01c0b	50		 push	 eax
  01c0c	68 00 00 00 00	 push	 OFFSET ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
  01c11	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01c17	83 c4 3c	 add	 esp, 60			; 0000003cH

; 561  : 
; 562  : 						this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);

  01c1a	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01c20	50		 push	 eax
  01c21	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01c24	51		 push	 ecx
  01c25	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c28	e8 00 00 00 00	 call	 ?SendWinMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendWinMessage

; 563  : 						this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);

  01c2d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01c33	50		 push	 eax
  01c34	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01c37	51		 push	 ecx
  01c38	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c3b	e8 00 00 00 00	 call	 ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveWinnerItem

; 564  : 					}
; 565  : 					else

  01c40	eb 15		 jmp	 SHORT $LN23@ProcState_@2
$LN24@ProcState_@2:

; 566  : 					{
; 567  : 						LogAddTD("[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  01c42	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01c45	83 c0 01	 add	 eax, 1
  01c48	50		 push	 eax
  01c49	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  01c4e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01c54	83 c4 08	 add	 esp, 8
$LN23@ProcState_@2:

; 568  : 					}
; 569  : 				}
; 570  : 				else

  01c57	eb 26		 jmp	 SHORT $LN22@ProcState_@2
$LN25@ProcState_@2:

; 571  : 				{
; 572  : 					LogAddTD("[Chaos Castle] (%d) Has No Winner : Monster Left (%d)", iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  01c59	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01c5c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01c62	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c65	8b 54 01 60	 mov	 edx, DWORD PTR [ecx+eax+96]
  01c69	52		 push	 edx
  01c6a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01c6d	83 c0 01	 add	 eax, 1
  01c70	50		 push	 eax
  01c71	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  01c76	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01c7c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@ProcState_@2:

; 573  : 				}
; 574  : 
; 575  : 				this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);

  01c7f	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236727[ebp]
  01c85	50		 push	 eax
  01c86	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01c89	51		 push	 ecx
  01c8a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c8d	e8 00 00 00 00	 call	 ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendAllLoserFailMessage

; 576  : 				this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);

  01c92	6a 03		 push	 3
  01c94	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01c97	50		 push	 eax
  01c98	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c9b	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 577  : 				return;

  01ca0	e9 e5 06 00 00	 jmp	 $LN35@ProcState_@2
$LN26@ProcState_@2:

; 578  : 			}
; 579  : 		
; 580  : 			if ( bPlayEnded == 2 )

  01ca5	83 bd d4 fe ff
	ff 02		 cmp	 DWORD PTR _bPlayEnded$236725[ebp], 2
  01cac	0f 85 3d 02 00
	00		 jne	 $LN21@ProcState_@2

; 581  : 			{
; 582  : 				int iWinnerIndex = -1;

  01cb2	c7 85 c8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$236737[ebp], -1

; 583  : 				int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  01cbc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01cbf	50		 push	 eax
  01cc0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01cc3	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  01cc8	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _iMonsterCount$236738[ebp], eax

; 584  : 
; 585  : 				if ( iMonsterCount <= 0 )

  01cce	83 bd c4 fe ff
	ff 00		 cmp	 DWORD PTR _iMonsterCount$236738[ebp], 0
  01cd5	0f 8f c8 01 00
	00		 jg	 $LN20@ProcState_@2

; 586  : 				{
; 587  : 					iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  01cdb	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01cde	50		 push	 eax
  01cdf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ce2	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  01ce7	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _iWinnerIndex$236737[ebp], eax

; 588  : 
; 589  : 					if ( iWinnerIndex != -1 )

  01ced	83 bd c8 fe ff
	ff ff		 cmp	 DWORD PTR _iWinnerIndex$236737[ebp], -1
  01cf4	0f 84 92 01 00
	00		 je	 $LN19@ProcState_@2

; 590  : 					{
; 591  : 						LogAddTD("[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 592  : 							iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 593  : 							gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 594  : 							gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 595  : 							gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 596  : 							gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  01cfa	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01d00	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d06	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d0c	0f be 94 01 3d
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+317]
  01d14	52		 push	 edx
  01d15	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01d1b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d21	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d27	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01d2f	52		 push	 edx
  01d30	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01d36	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d42	0f b7 94 01 18
	01 00 00	 movzx	 edx, WORD PTR [ecx+eax+280]
  01d4a	52		 push	 edx
  01d4b	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01d51	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d57	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d5d	0f b7 94 01 fa
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+250]
  01d65	52		 push	 edx
  01d66	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01d6c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d78	0f b7 94 01 f8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+248]
  01d80	52		 push	 edx
  01d81	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01d87	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d8d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d93	0f b7 94 01 f6
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+246]
  01d9b	52		 push	 edx
  01d9c	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01da2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01da8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01dae	0f b7 94 01 f4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+244]
  01db6	52		 push	 edx
  01db7	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01dbd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01dc3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01dc9	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  01dd0	52		 push	 edx
  01dd1	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01dd7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ddd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01de3	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  01dea	52		 push	 edx
  01deb	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01df1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01df7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01dfd	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  01e05	52		 push	 edx
  01e06	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01e0c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01e12	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e18	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  01e20	52		 push	 edx
  01e21	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01e27	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01e2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e33	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  01e37	52		 push	 edx
  01e38	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01e3e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01e44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e4a	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  01e4e	52		 push	 edx
  01e4f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01e52	83 c0 01	 add	 eax, 1
  01e55	50		 push	 eax
  01e56	68 00 00 00 00	 push	 OFFSET ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
  01e5b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01e61	83 c4 3c	 add	 esp, 60			; 0000003cH

; 597  : 
; 598  : 						this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);

  01e64	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01e6a	50		 push	 eax
  01e6b	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01e6e	51		 push	 ecx
  01e6f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e72	e8 00 00 00 00	 call	 ?SendWinMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendWinMessage

; 599  : 						this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);

  01e77	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01e7d	50		 push	 eax
  01e7e	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01e81	51		 push	 ecx
  01e82	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e85	e8 00 00 00 00	 call	 ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveWinnerItem

; 600  : 					}
; 601  : 					else

  01e8a	eb 15		 jmp	 SHORT $LN18@ProcState_@2
$LN19@ProcState_@2:

; 602  : 					{
; 603  : 						LogAddTD("[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  01e8c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01e8f	83 c0 01	 add	 eax, 1
  01e92	50		 push	 eax
  01e93	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  01e98	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01e9e	83 c4 08	 add	 esp, 8
$LN18@ProcState_@2:

; 604  : 					}
; 605  : 				}
; 606  : 				else

  01ea1	eb 26		 jmp	 SHORT $LN17@ProcState_@2
$LN20@ProcState_@2:

; 607  : 				{
; 608  : 					LogAddTD("[Chaos Castle] (%d) Has No Winner : Monster Left (%d)",
; 609  : 						iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  01ea3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01ea6	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01eac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01eaf	8b 54 01 60	 mov	 edx, DWORD PTR [ecx+eax+96]
  01eb3	52		 push	 edx
  01eb4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01eb7	83 c0 01	 add	 eax, 1
  01eba	50		 push	 eax
  01ebb	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  01ec0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01ec6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@ProcState_@2:

; 610  : 				}
; 611  : 
; 612  : 				this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);

  01ec9	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236737[ebp]
  01ecf	50		 push	 eax
  01ed0	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01ed3	51		 push	 ecx
  01ed4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ed7	e8 00 00 00 00	 call	 ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendAllLoserFailMessage

; 613  : 				this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);

  01edc	6a 03		 push	 3
  01ede	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01ee1	50		 push	 eax
  01ee2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ee5	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 614  : 
; 615  : 				return;

  01eea	e9 9b 04 00 00	 jmp	 $LN35@ProcState_@2
$LN21@ProcState_@2:

; 616  : 			}
; 617  : 		
; 618  : 			if ( bPlayEnded == FALSE )

  01eef	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _bPlayEnded$236725[ebp], 0
  01ef6	75 0e		 jne	 SHORT $LN16@ProcState_@2

; 619  : 			{
; 620  : 				this->SendNoticeState(iChaosCastleIndex, 6);

  01ef8	6a 06		 push	 6
  01efa	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01efd	50		 push	 eax
  01efe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f01	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
$LN16@ProcState_@2:

; 621  : 			}
; 622  : 		}
; 623  : 	}
; 624  : 
; 625  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  01f06	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01f09	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  01f0f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f12	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  01f17	0f 8f 6d 04 00
	00		 jg	 $LN15@ProcState_@2

; 626  : 	{
; 627  : 		LogAddTD("[Chaos Castle] (%d) is Over : TIME-OUT (Left User:%d, Monster:%d)", iChaosCastleIndex+1, this->GetCurPlayUser(iChaosCastleIndex), this->GetMonsterListCount(iChaosCastleIndex));

  01f1d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01f20	50		 push	 eax
  01f21	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f24	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  01f29	50		 push	 eax
  01f2a	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  01f2d	51		 push	 ecx
  01f2e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f31	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  01f36	50		 push	 eax
  01f37	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  01f3a	83 c2 01	 add	 edx, 1
  01f3d	52		 push	 edx
  01f3e	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@
  01f43	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01f49	83 c4 10	 add	 esp, 16			; 00000010H

; 628  : 
; 629  : 		int iWinnerIndex = -1;

  01f4c	c7 85 c0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$236746[ebp], -1

; 630  : 		int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  01f56	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01f59	50		 push	 eax
  01f5a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f5d	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  01f62	89 85 bc fe ff
	ff		 mov	 DWORD PTR _iMonsterCount$236747[ebp], eax

; 631  : 
; 632  : 		if ( iMonsterCount <= 0 )

  01f68	83 bd bc fe ff
	ff 00		 cmp	 DWORD PTR _iMonsterCount$236747[ebp], 0
  01f6f	0f 8f cb 01 00
	00		 jg	 $LN14@ProcState_@2

; 633  : 		{
; 634  : 			iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  01f75	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  01f78	50		 push	 eax
  01f79	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f7c	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  01f81	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _iWinnerIndex$236746[ebp], eax

; 635  : 
; 636  : 			if ( iWinnerIndex != -1 )

  01f87	83 bd c0 fe ff
	ff ff		 cmp	 DWORD PTR _iWinnerIndex$236746[ebp], -1
  01f8e	0f 84 92 01 00
	00		 je	 $LN13@ProcState_@2

; 637  : 			{
; 638  : 				LogAddTD("[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 639  : 					iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 640  : 					gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 641  : 					gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 642  : 					gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 643  : 					gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  01f94	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  01f9a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01fa0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fa6	0f be 94 01 3d
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+317]
  01fae	52		 push	 edx
  01faf	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  01fb5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01fbb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fc1	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01fc9	52		 push	 edx
  01fca	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  01fd0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01fd6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fdc	0f b7 94 01 18
	01 00 00	 movzx	 edx, WORD PTR [ecx+eax+280]
  01fe4	52		 push	 edx
  01fe5	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  01feb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ff1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ff7	0f b7 94 01 fa
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+250]
  01fff	52		 push	 edx
  02000	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  02006	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0200c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02012	0f b7 94 01 f8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+248]
  0201a	52		 push	 edx
  0201b	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  02021	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0202d	0f b7 94 01 f6
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+246]
  02035	52		 push	 edx
  02036	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  0203c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02048	0f b7 94 01 f4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+244]
  02050	52		 push	 edx
  02051	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  02057	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0205d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02063	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  0206a	52		 push	 edx
  0206b	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  02071	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0207d	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  02084	52		 push	 edx
  02085	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  0208b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02097	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  0209f	52		 push	 edx
  020a0	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  020a6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  020ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020b2	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  020ba	52		 push	 edx
  020bb	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  020c1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  020c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020cd	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  020d1	52		 push	 edx
  020d2	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  020d8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  020de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020e4	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  020e8	52		 push	 edx
  020e9	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  020ec	83 c0 01	 add	 eax, 1
  020ef	50		 push	 eax
  020f0	68 00 00 00 00	 push	 OFFSET ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
  020f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  020fb	83 c4 3c	 add	 esp, 60			; 0000003cH

; 644  : 
; 645  : 				this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);

  020fe	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  02104	50		 push	 eax
  02105	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  02108	51		 push	 ecx
  02109	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0210c	e8 00 00 00 00	 call	 ?SendWinMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendWinMessage

; 646  : 				this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);

  02111	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  02117	50		 push	 eax
  02118	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0211b	51		 push	 ecx
  0211c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0211f	e8 00 00 00 00	 call	 ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveWinnerItem

; 647  : 			}
; 648  : 			else

  02124	eb 15		 jmp	 SHORT $LN12@ProcState_@2
$LN13@ProcState_@2:

; 649  : 			{
; 650  : 				LogAddTD("[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  02126	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02129	83 c0 01	 add	 eax, 1
  0212c	50		 push	 eax
  0212d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  02132	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02138	83 c4 08	 add	 esp, 8
$LN12@ProcState_@2:

; 651  : 			}
; 652  : 		}
; 653  : 		else

  0213b	e9 29 02 00 00	 jmp	 $LN1@ProcState_@2
$LN14@ProcState_@2:

; 654  : 		{
; 655  : 			if( this->GetCurrentState(iChaosCastleIndex) == 1) //season 2.5 add-on

  02140	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02143	50		 push	 eax
  02144	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02147	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  0214c	83 f8 01	 cmp	 eax, 1
  0214f	0f 85 ee 01 00
	00		 jne	 $LN10@ProcState_@2

; 656  : 			{
; 657  : 				for ( int i=0;i<MAX_CHAOSCASTLE_MONSTER;i++)

  02155	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$236753[ebp], 0
  0215f	eb 0f		 jmp	 SHORT $LN9@ProcState_@2
$LN8@ProcState_@2:
  02161	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _i$236753[ebp]
  02167	83 c0 01	 add	 eax, 1
  0216a	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _i$236753[ebp], eax
$LN9@ProcState_@2:
  02170	83 bd b8 fe ff
	ff 64		 cmp	 DWORD PTR _i$236753[ebp], 100 ; 00000064H
  02177	0f 8d c4 01 00
	00		 jge	 $LN7@ProcState_@2

; 658  : 				{
; 659  : 					if(this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] == -1)

  0217d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02180	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02186	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02189	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0218d	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _i$236753[ebp]
  02193	83 bc 82 b4 05
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1460], -1
  0219b	75 02		 jne	 SHORT $LN6@ProcState_@2

; 660  : 					{
; 661  : 						continue;

  0219d	eb c2		 jmp	 SHORT $LN8@ProcState_@2
$LN6@ProcState_@2:

; 662  : 					}
; 663  : 
; 664  : 					int CC_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i];

  0219f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  021a2	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  021a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  021ab	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  021af	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _i$236753[ebp]
  021b5	8b 8c 82 b4 05
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+1460]
  021bc	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _CC_MONSTER_COUNT$236758[ebp], ecx

; 665  : 					
; 666  : 					if ( ((CC_MONSTER_COUNT<0)?FALSE:(CC_MONSTER_COUNT>OBJ_MAXMONSTER-1)?FALSE:TRUE) == FALSE ) 

  021c2	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR _CC_MONSTER_COUNT$236758[ebp], 0
  021c9	7d 0c		 jge	 SHORT $LN37@ProcState_@2
  021cb	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv637[ebp], 0
  021d5	eb 15		 jmp	 SHORT $LN38@ProcState_@2
$LN37@ProcState_@2:
  021d7	33 c0		 xor	 eax, eax
  021d9	81 bd b4 fe ff
	ff c7 32 00 00	 cmp	 DWORD PTR _CC_MONSTER_COUNT$236758[ebp], 12999 ; 000032c7H
  021e3	0f 9e c0	 setle	 al
  021e6	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv637[ebp], eax
$LN38@ProcState_@2:
  021ec	83 bd 70 fe ff
	ff 00		 cmp	 DWORD PTR tv637[ebp], 0
  021f3	75 26		 jne	 SHORT $LN5@ProcState_@2

; 667  : 					{
; 668  : 						this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] = -1;

  021f5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  021f8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  021fe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02201	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  02205	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _i$236753[ebp]
  0220b	c7 84 82 b4 05
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax*4+1460], -1

; 669  : 						continue;

  02216	e9 46 ff ff ff	 jmp	 $LN8@ProcState_@2
$LN5@ProcState_@2:

; 670  : 					}
; 671  : 
; 672  : 					if(gObj[CC_MONSTER_COUNT].Life > 0.0f)

  0221b	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  02221	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0222d	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  02234	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0223a	df e0		 fnstsw	 ax
  0223c	f6 c4 41	 test	 ah, 65			; 00000041H
  0223f	0f 85 f7 00 00
	00		 jne	 $LN2@ProcState_@2

; 673  : 					{
; 674  : 						if(CC_MAP_RANGE(gObj[CC_MONSTER_COUNT].MapNumber) != FALSE)

  02245	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  0224b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02251	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02257	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0225f	83 fa 35	 cmp	 edx, 53			; 00000035H
  02262	75 0c		 jne	 SHORT $LN41@ProcState_@2
  02264	c7 85 70 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv667[ebp], 1
  0226e	eb 5f		 jmp	 SHORT $LN42@ProcState_@2
$LN41@ProcState_@2:
  02270	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  02276	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0227c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02282	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0228a	83 fa 12	 cmp	 edx, 18			; 00000012H
  0228d	7d 0c		 jge	 SHORT $LN39@ProcState_@2
  0228f	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv666[ebp], 0
  02299	eb 28		 jmp	 SHORT $LN40@ProcState_@2
$LN39@ProcState_@2:
  0229b	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  022a1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  022a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  022ad	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  022b5	33 c0		 xor	 eax, eax
  022b7	83 fa 17	 cmp	 edx, 23			; 00000017H
  022ba	0f 9e c0	 setle	 al
  022bd	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv666[ebp], eax
$LN40@ProcState_@2:
  022c3	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv666[ebp]
  022c9	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv667[ebp], ecx
$LN42@ProcState_@2:
  022cf	83 bd 70 fe ff
	ff 00		 cmp	 DWORD PTR tv667[ebp], 0
  022d6	74 64		 je	 SHORT $LN2@ProcState_@2

; 675  : 						{
; 676  : 							if(gObj[CC_MONSTER_COUNT].Connected > 0)

  022d8	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  022de	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  022e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  022ea	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  022ef	7e 4b		 jle	 SHORT $LN2@ProcState_@2

; 677  : 							{
; 678  : 								LogAddTD("[Chaos Castle][Bug Tracer] (%d) Left Monster AttrInfo %d/%d", iChaosCastleIndex+1, gObj[CC_MONSTER_COUNT].X, gObj[CC_MONSTER_COUNT].Y);

  022f1	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  022f7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  022fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02303	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  0230b	52		 push	 edx
  0230c	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$236758[ebp]
  02312	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02318	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0231e	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  02326	52		 push	 edx
  02327	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0232a	83 c0 01	 add	 eax, 1
  0232d	50		 push	 eax
  0232e	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  02333	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02339	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@ProcState_@2:

; 679  : 							}
; 680  : 						}
; 681  : 					}
; 682  : 				}

  0233c	e9 20 fe ff ff	 jmp	 $LN8@ProcState_@2
$LN7@ProcState_@2:

; 683  : 			}
; 684  : 			else

  02341	eb 26		 jmp	 SHORT $LN1@ProcState_@2
$LN10@ProcState_@2:

; 685  : 			{
; 686  : 				LogAddTD("[Chaos Castle] (%d) Has No Winner : Monster Left (%d)", iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  02343	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02346	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0234c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0234f	8b 54 01 60	 mov	 edx, DWORD PTR [ecx+eax+96]
  02353	52		 push	 edx
  02354	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02357	83 c0 01	 add	 eax, 1
  0235a	50		 push	 eax
  0235b	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  02360	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02366	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ProcState_@2:

; 687  : 			}
; 688  : 		}
; 689  : 
; 690  : 		this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);

  02369	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _iWinnerIndex$236746[ebp]
  0236f	50		 push	 eax
  02370	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  02373	51		 push	 ecx
  02374	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02377	e8 00 00 00 00	 call	 ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendAllLoserFailMessage

; 691  : 		this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);

  0237c	6a 03		 push	 3
  0237e	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02381	50		 push	 eax
  02382	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02385	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN15@ProcState_@2:
$LN35@ProcState_@2:

; 692  : 	}
; 693  : }

  0238a	5f		 pop	 edi
  0238b	5e		 pop	 esi
  0238c	5b		 pop	 ebx
  0238d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02390	33 cd		 xor	 ecx, ebp
  02392	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02397	8b e5		 mov	 esp, ebp
  02399	5d		 pop	 ebp
  0239a	c2 04 00	 ret	 4
?ProcState_Playing@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_Playing
_TEXT	ENDS
PUBLIC	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z		; CChaosCastle::ObjSetPosition
PUBLIC	?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back
PUBLIC	?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
PUBLIC	?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
PUBLIC	?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
PUBLIC	??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
PUBLIC	??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
PUBLIC	__$ArrayPad$
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
xdata$x	SEGMENT
__unwindtable$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z$0
__ehfuncinfo$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv322 = -272						; size = 4
tv323 = -268						; size = 4
tv293 = -268						; size = 4
tv72 = -268						; size = 4
tv67 = -268						; size = 4
_y$237186 = -200					; size = 4
_x$237185 = -196					; size = 4
_iMapNumber$237183 = -192				; size = 4
_iMAP_ITEM$237179 = -188				; size = 4
_ptEMPTY$237177 = -184					; size = 8
_n$237170 = -176					; size = 4
_btMapAttr$237168 = -169				; size = 1
_iMapNumber$237167 = -168				; size = 4
_iSY$237166 = -164					; size = 4
_iSX$237165 = -160					; size = 4
_iMON_INDEX$237162 = -156				; size = 4
_iMON$237157 = -152					; size = 4
_ptEMPTY$237155 = -148					; size = 8
_n$237148 = -140					; size = 4
_btMapAttr$237146 = -133				; size = 1
_iMapNumber$237145 = -132				; size = 4
_iSY$237144 = -128					; size = 4
_iSX$237143 = -124					; size = 4
_i$237137 = -120					; size = 4
_iPT$237136 = -116					; size = 8
_btMapAttr$237134 = -105				; size = 1
_iMapNumber$237133 = -104				; size = 4
_iMAPY$237129 = -100					; size = 4
_iMAPX$237125 = -96					; size = 4
_iAXIS$237121 = -92					; size = 4
_vtMAP_UNTRAP$ = -88					; size = 64
_iUSER_AXIS$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
_iTRAP_STEP$ = 12					; size = 4
?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::PullObjInnerPlace
; _this$ = ecx

; 696  : {

  023a0	55		 push	 ebp
  023a1	8b ec		 mov	 ebp, esp
  023a3	6a ff		 push	 -1
  023a5	68 00 00 00 00	 push	 __ehhandler$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
  023aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  023b0	50		 push	 eax
  023b1	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  023b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  023bc	33 c5		 xor	 eax, ebp
  023be	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  023c1	53		 push	 ebx
  023c2	56		 push	 esi
  023c3	57		 push	 edi
  023c4	50		 push	 eax
  023c5	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  023c8	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  023ce	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 697  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  023d1	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  023d5	7d 0c		 jge	 SHORT $LN49@PullObjInn
  023d7	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  023e1	eb 0f		 jmp	 SHORT $LN50@PullObjInn
$LN49@PullObjInn:
  023e3	33 c0		 xor	 eax, eax
  023e5	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  023e9	0f 9e c0	 setle	 al
  023ec	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN50@PullObjInn:
  023f2	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  023f9	75 05		 jne	 SHORT $LN46@PullObjInn

; 698  : 		return;

  023fb	e9 e0 08 00 00	 jmp	 $LN47@PullObjInn
$LN46@PullObjInn:

; 699  : 
; 700  : 	if ( CC_TRAP_STEP_RANGE(iTRAP_STEP) == FALSE )

  02400	83 7d 0c 00	 cmp	 DWORD PTR _iTRAP_STEP$[ebp], 0
  02404	7d 0c		 jge	 SHORT $LN51@PullObjInn
  02406	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
  02410	eb 0f		 jmp	 SHORT $LN52@PullObjInn
$LN51@PullObjInn:
  02412	33 c0		 xor	 eax, eax
  02414	83 7d 0c 03	 cmp	 DWORD PTR _iTRAP_STEP$[ebp], 3
  02418	0f 9e c0	 setle	 al
  0241b	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN52@PullObjInn:
  02421	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR tv72[ebp], 0
  02428	75 05		 jne	 SHORT $LN45@PullObjInn

; 701  : 		return;

  0242a	e9 b1 08 00 00	 jmp	 $LN47@PullObjInn
$LN45@PullObjInn:

; 702  : 
; 703  : 	if ( iTRAP_STEP == 0 )

  0242f	83 7d 0c 00	 cmp	 DWORD PTR _iTRAP_STEP$[ebp], 0
  02433	75 05		 jne	 SHORT $LN44@PullObjInn

; 704  : 		return;

  02435	e9 a6 08 00 00	 jmp	 $LN47@PullObjInn
$LN44@PullObjInn:

; 705  : 
; 706  : 	int iUSER_AXIS = 0;

  0243a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iUSER_AXIS$[ebp], 0

; 707  : 	std::vector<POINT> vtMAP_UNTRAP[MAX_CC_TRAP_STEP];

  02441	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  02446	68 00 00 00 00	 push	 OFFSET ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
  0244b	6a 04		 push	 4
  0244d	6a 10		 push	 16			; 00000010H
  0244f	8d 45 a8	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  02452	50		 push	 eax
  02453	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  02458	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 708  : 
; 709  : 	for ( int iAXIS = 0; iAXIS < MAX_CC_TRAP_STEP ; iAXIS++)

  0245f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _iAXIS$237121[ebp], 0
  02466	eb 09		 jmp	 SHORT $LN43@PullObjInn
$LN42@PullObjInn:
  02468	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$237121[ebp]
  0246b	83 c0 01	 add	 eax, 1
  0246e	89 45 a4	 mov	 DWORD PTR _iAXIS$237121[ebp], eax
$LN43@PullObjInn:
  02471	83 7d a4 04	 cmp	 DWORD PTR _iAXIS$237121[ebp], 4
  02475	0f 8d d1 00 00
	00		 jge	 $LN41@PullObjInn

; 710  : 	{
; 711  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  0247b	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$237121[ebp]
  0247e	c1 e0 04	 shl	 eax, 4
  02481	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax]
  02487	89 4d a0	 mov	 DWORD PTR _iMAPX$237125[ebp], ecx
  0248a	eb 09		 jmp	 SHORT $LN40@PullObjInn
$LN39@PullObjInn:
  0248c	8b 45 a0	 mov	 eax, DWORD PTR _iMAPX$237125[ebp]
  0248f	83 c0 01	 add	 eax, 1
  02492	89 45 a0	 mov	 DWORD PTR _iMAPX$237125[ebp], eax
$LN40@PullObjInn:
  02495	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$237121[ebp]
  02498	c1 e0 04	 shl	 eax, 4
  0249b	8b 4d a0	 mov	 ecx, DWORD PTR _iMAPX$237125[ebp]
  0249e	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax+8]
  024a4	0f 8f 9d 00 00
	00		 jg	 $LN38@PullObjInn

; 712  : 		{
; 713  : 			for ( int iMAPY = g_rtPOINT_TRAP[iAXIS].top ; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++ )

  024aa	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$237121[ebp]
  024ad	c1 e0 04	 shl	 eax, 4
  024b0	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax+4]
  024b6	89 4d 9c	 mov	 DWORD PTR _iMAPY$237129[ebp], ecx
  024b9	eb 09		 jmp	 SHORT $LN37@PullObjInn
$LN36@PullObjInn:
  024bb	8b 45 9c	 mov	 eax, DWORD PTR _iMAPY$237129[ebp]
  024be	83 c0 01	 add	 eax, 1
  024c1	89 45 9c	 mov	 DWORD PTR _iMAPY$237129[ebp], eax
$LN37@PullObjInn:
  024c4	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$237121[ebp]
  024c7	c1 e0 04	 shl	 eax, 4
  024ca	8b 4d 9c	 mov	 ecx, DWORD PTR _iMAPY$237129[ebp]
  024cd	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax+12]
  024d3	7f 6d		 jg	 SHORT $LN35@PullObjInn

; 714  : 			{
; 715  : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  024d5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  024d8	50		 push	 eax
  024d9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  024dc	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  024e1	89 45 98	 mov	 DWORD PTR _iMapNumber$237133[ebp], eax

; 716  : 
; 717  : 				BYTE btMapAttr = MapC[iMapNumber].GetAttr(iMAPX, iMAPY);

  024e4	8b 45 9c	 mov	 eax, DWORD PTR _iMAPY$237129[ebp]
  024e7	50		 push	 eax
  024e8	8b 4d a0	 mov	 ecx, DWORD PTR _iMAPX$237125[ebp]
  024eb	51		 push	 ecx
  024ec	8b 4d 98	 mov	 ecx, DWORD PTR _iMapNumber$237133[ebp]
  024ef	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  024f5	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  024fb	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  02500	88 45 97	 mov	 BYTE PTR _btMapAttr$237134[ebp], al

; 718  : 
; 719  : 				if ( (btMapAttr&2) != 2 && (btMapAttr&4) != 4 && (btMapAttr&8) != 8 ) 

  02503	0f b6 45 97	 movzx	 eax, BYTE PTR _btMapAttr$237134[ebp]
  02507	83 e0 02	 and	 eax, 2
  0250a	75 31		 jne	 SHORT $LN34@PullObjInn
  0250c	0f b6 45 97	 movzx	 eax, BYTE PTR _btMapAttr$237134[ebp]
  02510	83 e0 04	 and	 eax, 4
  02513	75 28		 jne	 SHORT $LN34@PullObjInn
  02515	0f b6 45 97	 movzx	 eax, BYTE PTR _btMapAttr$237134[ebp]
  02519	83 e0 08	 and	 eax, 8
  0251c	75 1f		 jne	 SHORT $LN34@PullObjInn

; 720  : 				{
; 721  : 					POINT iPT = {iMAPX, iMAPY};

  0251e	8b 45 a0	 mov	 eax, DWORD PTR _iMAPX$237125[ebp]
  02521	89 45 8c	 mov	 DWORD PTR _iPT$237136[ebp], eax
  02524	8b 45 9c	 mov	 eax, DWORD PTR _iMAPY$237129[ebp]
  02527	89 45 90	 mov	 DWORD PTR _iPT$237136[ebp+4], eax

; 722  : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  0252a	8d 45 8c	 lea	 eax, DWORD PTR _iPT$237136[ebp]
  0252d	50		 push	 eax
  0252e	8b 4d a4	 mov	 ecx, DWORD PTR _iAXIS$237121[ebp]
  02531	c1 e1 04	 shl	 ecx, 4
  02534	8d 4c 0d a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx]
  02538	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
$LN34@PullObjInn:

; 723  : 				}
; 724  : 			}

  0253d	e9 79 ff ff ff	 jmp	 $LN36@PullObjInn
$LN35@PullObjInn:

; 725  : 		}

  02542	e9 45 ff ff ff	 jmp	 $LN39@PullObjInn
$LN38@PullObjInn:

; 726  : 	}

  02547	e9 1c ff ff ff	 jmp	 $LN42@PullObjInn
$LN41@PullObjInn:

; 727  : 
; 728  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0254c	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _i$237137[ebp], 0
  02553	eb 09		 jmp	 SHORT $LN33@PullObjInn
$LN32@PullObjInn:
  02555	8b 45 88	 mov	 eax, DWORD PTR _i$237137[ebp]
  02558	83 c0 01	 add	 eax, 1
  0255b	89 45 88	 mov	 DWORD PTR _i$237137[ebp], eax
$LN33@PullObjInn:
  0255e	83 7d 88 46	 cmp	 DWORD PTR _i$237137[ebp], 70 ; 00000046H
  02562	0f 8d 8b 02 00
	00		 jge	 $LN31@PullObjInn

; 729  : 	{
; 730  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  02568	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0256b	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02571	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02574	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  02578	8b 45 88	 mov	 eax, DWORD PTR _i$237137[ebp]
  0257b	6b c0 14	 imul	 eax, 20			; 00000014H
  0257e	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  02583	0f 84 65 02 00
	00		 je	 $LN21@PullObjInn

; 731  : 		{
; 732  : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (this->GetChaosCastleMapNumber(iChaosCastleIndex)) )

  02589	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0258c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02592	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02595	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  02599	8b 45 88	 mov	 eax, DWORD PTR _i$237137[ebp]
  0259c	6b c0 14	 imul	 eax, 20			; 00000014H
  0259f	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  025a3	51		 push	 ecx
  025a4	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  025a9	83 c4 04	 add	 esp, 4
  025ac	83 f8 01	 cmp	 eax, 1
  025af	0f 85 39 02 00
	00		 jne	 $LN21@PullObjInn
  025b5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  025b8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  025be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  025c1	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  025c5	8b 45 88	 mov	 eax, DWORD PTR _i$237137[ebp]
  025c8	6b c0 14	 imul	 eax, 20			; 00000014H
  025cb	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  025cf	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  025d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025db	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  025e3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  025e6	50		 push	 eax
  025e7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  025ea	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  025ef	3b f0		 cmp	 esi, eax
  025f1	0f 85 f7 01 00
	00		 jne	 $LN21@PullObjInn

; 733  : 			{
; 734  : 				int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  025f7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  025fa	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02600	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02603	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  02607	8b 45 88	 mov	 eax, DWORD PTR _i$237137[ebp]
  0260a	6b c0 14	 imul	 eax, 20			; 00000014H
  0260d	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  02611	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02617	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0261d	0f bf 84 0a 44
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+324]
  02625	89 45 84	 mov	 DWORD PTR _iSX$237143[ebp], eax

; 735  : 				int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;

  02628	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0262b	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02631	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02634	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  02638	8b 45 88	 mov	 eax, DWORD PTR _i$237137[ebp]
  0263b	6b c0 14	 imul	 eax, 20			; 00000014H
  0263e	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  02642	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02648	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0264e	0f bf 84 0a 46
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+326]
  02656	89 45 80	 mov	 DWORD PTR _iSY$237144[ebp], eax

; 736  : 
; 737  : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  02659	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0265c	50		 push	 eax
  0265d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02660	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  02665	89 85 7c ff ff
	ff		 mov	 DWORD PTR _iMapNumber$237145[ebp], eax

; 738  : 
; 739  : 				BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  0266b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237145[ebp]
  02671	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02677	8b 4d 80	 mov	 ecx, DWORD PTR _iSY$237144[ebp]
  0267a	c1 e1 08	 shl	 ecx, 8
  0267d	03 4d 84	 add	 ecx, DWORD PTR _iSX$237143[ebp]
  02680	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  02686	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0268a	83 e0 08	 and	 eax, 8
  0268d	88 85 7b ff ff
	ff		 mov	 BYTE PTR _btMapAttr$237146[ebp], al

; 740  : 
; 741  : 				if ( btMapAttr == 8 )

  02693	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _btMapAttr$237146[ebp]
  0269a	83 f8 08	 cmp	 eax, 8
  0269d	0f 85 4b 01 00
	00		 jne	 $LN21@PullObjInn

; 742  : 				{
; 743  : 					int n=0;

  026a3	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$237148[ebp], 0

; 744  : 					for ( n=0;n<MAX_CC_TRAP_STEP;n++)

  026ad	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$237148[ebp], 0
  026b7	eb 0f		 jmp	 SHORT $LN27@PullObjInn
$LN26@PullObjInn:
  026b9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$237148[ebp]
  026bf	83 c0 01	 add	 eax, 1
  026c2	89 85 74 ff ff
	ff		 mov	 DWORD PTR _n$237148[ebp], eax
$LN27@PullObjInn:
  026c8	83 bd 74 ff ff
	ff 04		 cmp	 DWORD PTR _n$237148[ebp], 4
  026cf	7d 5d		 jge	 SHORT $LN25@PullObjInn

; 745  : 					{
; 746  : 						if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 747  : 							 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  026d1	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$237148[ebp]
  026d7	c1 e0 04	 shl	 eax, 4
  026da	8b 4d 84	 mov	 ecx, DWORD PTR _iSX$237143[ebp]
  026dd	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax]
  026e3	7c 47		 jl	 SHORT $LN24@PullObjInn
  026e5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$237148[ebp]
  026eb	c1 e0 04	 shl	 eax, 4
  026ee	8b 4d 84	 mov	 ecx, DWORD PTR _iSX$237143[ebp]
  026f1	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+8]
  026f7	7f 33		 jg	 SHORT $LN24@PullObjInn
  026f9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$237148[ebp]
  026ff	c1 e0 04	 shl	 eax, 4
  02702	8b 4d 80	 mov	 ecx, DWORD PTR _iSY$237144[ebp]
  02705	3b 88 04 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+4]
  0270b	7c 1f		 jl	 SHORT $LN24@PullObjInn
  0270d	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$237148[ebp]
  02713	c1 e0 04	 shl	 eax, 4
  02716	8b 4d 80	 mov	 ecx, DWORD PTR _iSY$237144[ebp]
  02719	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+12]
  0271f	7f 0b		 jg	 SHORT $LN24@PullObjInn

; 748  : 						{
; 749  : 							iUSER_AXIS = n;

  02721	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$237148[ebp]
  02727	89 45 e8	 mov	 DWORD PTR _iUSER_AXIS$[ebp], eax

; 750  : 							break;

  0272a	eb 02		 jmp	 SHORT $LN25@PullObjInn
$LN24@PullObjInn:

; 751  : 						}
; 752  : 					}

  0272c	eb 8b		 jmp	 SHORT $LN26@PullObjInn
$LN25@PullObjInn:

; 753  : 
; 754  : 					if ( n == MAX_CC_TRAP_STEP )

  0272e	83 bd 74 ff ff
	ff 04		 cmp	 DWORD PTR _n$237148[ebp], 4
  02735	75 05		 jne	 SHORT $LN23@PullObjInn

; 755  : 						continue;

  02737	e9 19 fe ff ff	 jmp	 $LN32@PullObjInn
$LN23@PullObjInn:

; 756  : 
; 757  : 					if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  0273c	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  0273f	c1 e0 04	 shl	 eax, 4
  02742	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  02746	e8 00 00 00 00	 call	 ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
  0274b	0f b6 c8	 movzx	 ecx, al
  0274e	85 c9		 test	 ecx, ecx
  02750	0f 85 98 00 00
	00		 jne	 $LN21@PullObjInn

; 758  : 					{
; 759  : 						POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  02756	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  02759	c1 e0 04	 shl	 eax, 4
  0275c	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  02760	e8 00 00 00 00	 call	 ?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
  02765	8b 08		 mov	 ecx, DWORD PTR [eax]
  02767	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0276a	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _ptEMPTY$237155[ebp], ecx
  02770	89 95 70 ff ff
	ff		 mov	 DWORD PTR _ptEMPTY$237155[ebp+4], edx

; 760  : 						vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  02776	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  02779	c1 e0 04	 shl	 eax, 4
  0277c	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  02780	e8 00 00 00 00	 call	 ?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back

; 761  : 
; 762  : 						if ( this->ObjSetPosition(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, ptEMPTY.x, ptEMPTY.y) == TRUE )

  02785	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _ptEMPTY$237155[ebp+4]
  0278b	50		 push	 eax
  0278c	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _ptEMPTY$237155[ebp]
  02792	51		 push	 ecx
  02793	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  02796	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  0279c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0279f	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  027a3	8b 55 88	 mov	 edx, DWORD PTR _i$237137[ebp]
  027a6	6b d2 14	 imul	 edx, 20			; 00000014H
  027a9	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  027ad	50		 push	 eax
  027ae	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  027b1	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  027b6	83 f8 01	 cmp	 eax, 1
  027b9	75 33		 jne	 SHORT $LN21@PullObjInn

; 763  : 						{
; 764  : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = GetTickCount();

  027bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  027c1	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  027c4	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  027ca	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  027cd	8d 4c 0a 30	 lea	 ecx, DWORD PTR [edx+ecx+48]
  027d1	8b 55 88	 mov	 edx, DWORD PTR _i$237137[ebp]
  027d4	6b d2 14	 imul	 edx, 20			; 00000014H
  027d7	8b 4c 11 3c	 mov	 ecx, DWORD PTR [ecx+edx+60]
  027db	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  027e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  027e7	89 84 0a a8 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3752], eax
$LN21@PullObjInn:

; 765  : 						}
; 766  : 					}
; 767  : 				}
; 768  : 			}
; 769  : 		}
; 770  : 	}

  027ee	e9 62 fd ff ff	 jmp	 $LN32@PullObjInn
$LN31@PullObjInn:

; 771  : 
; 772  : 	for ( int iMON = 0; iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++ )

  027f3	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _iMON$237157[ebp], 0
  027fd	eb 0f		 jmp	 SHORT $LN20@PullObjInn
$LN19@PullObjInn:
  027ff	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _iMON$237157[ebp]
  02805	83 c0 01	 add	 eax, 1
  02808	89 85 68 ff ff
	ff		 mov	 DWORD PTR _iMON$237157[ebp], eax
$LN20@PullObjInn:
  0280e	83 bd 68 ff ff
	ff 64		 cmp	 DWORD PTR _iMON$237157[ebp], 100 ; 00000064H
  02815	0f 8d 3f 03 00
	00		 jge	 $LN18@PullObjInn

; 773  : 	{
; 774  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  0281b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0281e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02824	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02827	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0282b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _iMON$237157[ebp]
  02831	83 bc 82 b4 05
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1460], -1
  02839	75 02		 jne	 SHORT $LN17@PullObjInn

; 775  : 			continue;

  0283b	eb c2		 jmp	 SHORT $LN19@PullObjInn
$LN17@PullObjInn:

; 776  : 
; 777  : 		int iMON_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON];

  0283d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02840	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02846	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02849	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0284d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _iMON$237157[ebp]
  02853	8b 8c 82 b4 05
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+1460]
  0285a	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _iMON_INDEX$237162[ebp], ecx

; 778  : 
; 779  : 		if ( !CHECK_LIMIT(iMON_INDEX, OBJ_MAXMONSTER))

  02860	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _iMON_INDEX$237162[ebp], 0
  02867	7d 0c		 jge	 SHORT $LN53@PullObjInn
  02869	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv293[ebp], 0
  02873	eb 15		 jmp	 SHORT $LN54@PullObjInn
$LN53@PullObjInn:
  02875	33 c0		 xor	 eax, eax
  02877	81 bd 64 ff ff
	ff c7 32 00 00	 cmp	 DWORD PTR _iMON_INDEX$237162[ebp], 12999 ; 000032c7H
  02881	0f 9e c0	 setle	 al
  02884	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv293[ebp], eax
$LN54@PullObjInn:
  0288a	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR tv293[ebp], 0
  02891	75 26		 jne	 SHORT $LN16@PullObjInn

; 780  : 		{
; 781  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] = -1;

  02893	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02896	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0289c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0289f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  028a3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _iMON$237157[ebp]
  028a9	c7 84 82 b4 05
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax*4+1460], -1

; 782  : 			continue;

  028b4	e9 46 ff ff ff	 jmp	 $LN19@PullObjInn
$LN16@PullObjInn:

; 783  : 		}
; 784  : 
; 785  : 		if ( gObj[iMON_INDEX].Life > 0.0f && CC_MAP_RANGE(gObj[iMON_INDEX].MapNumber) != FALSE && gObj[iMON_INDEX].Connected > PLAYER_EMPTY )

  028b9	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  028bf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  028c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028cb	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  028d2	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  028d8	df e0		 fnstsw	 ax
  028da	f6 c4 41	 test	 ah, 65			; 00000041H
  028dd	0f 85 72 02 00
	00		 jne	 $LN7@PullObjInn
  028e3	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  028e9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  028ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028f5	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  028fd	83 fa 35	 cmp	 edx, 53			; 00000035H
  02900	75 0c		 jne	 SHORT $LN57@PullObjInn
  02902	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv323[ebp], 1
  0290c	eb 5f		 jmp	 SHORT $LN58@PullObjInn
$LN57@PullObjInn:
  0290e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  02914	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0291a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02920	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  02928	83 fa 12	 cmp	 edx, 18			; 00000012H
  0292b	7d 0c		 jge	 SHORT $LN55@PullObjInn
  0292d	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv322[ebp], 0
  02937	eb 28		 jmp	 SHORT $LN56@PullObjInn
$LN55@PullObjInn:
  02939	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  0293f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02945	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0294b	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  02953	33 c0		 xor	 eax, eax
  02955	83 fa 17	 cmp	 edx, 23			; 00000017H
  02958	0f 9e c0	 setle	 al
  0295b	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv322[ebp], eax
$LN56@PullObjInn:
  02961	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv322[ebp]
  02967	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv323[ebp], ecx
$LN58@PullObjInn:
  0296d	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR tv323[ebp], 0
  02974	0f 84 db 01 00
	00		 je	 $LN7@PullObjInn
  0297a	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  02980	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02986	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0298c	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  02991	0f 8e be 01 00
	00		 jle	 $LN7@PullObjInn

; 786  : 		{
; 787  : 			int iSX = gObj[iMON_INDEX].X;

  02997	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  0299d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  029a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029a9	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  029b1	89 95 60 ff ff
	ff		 mov	 DWORD PTR _iSX$237165[ebp], edx

; 788  : 			int iSY = gObj[iMON_INDEX].Y;

  029b7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _iMON_INDEX$237162[ebp]
  029bd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  029c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029c9	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  029d1	89 95 5c ff ff
	ff		 mov	 DWORD PTR _iSY$237166[ebp], edx

; 789  : 			int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  029d7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  029da	50		 push	 eax
  029db	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  029de	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  029e3	89 85 58 ff ff
	ff		 mov	 DWORD PTR _iMapNumber$237167[ebp], eax

; 790  : 
; 791  : 			BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  029e9	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237167[ebp]
  029ef	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  029f5	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iSY$237166[ebp]
  029fb	c1 e1 08	 shl	 ecx, 8
  029fe	03 8d 60 ff ff
	ff		 add	 ecx, DWORD PTR _iSX$237165[ebp]
  02a04	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  02a0a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  02a0e	83 e0 08	 and	 eax, 8
  02a11	88 85 57 ff ff
	ff		 mov	 BYTE PTR _btMapAttr$237168[ebp], al

; 792  : 
; 793  : 			if ( btMapAttr == 8 )

  02a17	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _btMapAttr$237168[ebp]
  02a1e	83 f8 08	 cmp	 eax, 8
  02a21	0f 85 2e 01 00
	00		 jne	 $LN7@PullObjInn

; 794  : 			{
; 795  : 				int n=0;

  02a27	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$237170[ebp], 0

; 796  : 				for (n=0;n<MAX_CC_TRAP_STEP;n++)

  02a31	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$237170[ebp], 0
  02a3b	eb 0f		 jmp	 SHORT $LN13@PullObjInn
$LN12@PullObjInn:
  02a3d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _n$237170[ebp]
  02a43	83 c0 01	 add	 eax, 1
  02a46	89 85 50 ff ff
	ff		 mov	 DWORD PTR _n$237170[ebp], eax
$LN13@PullObjInn:
  02a4c	83 bd 50 ff ff
	ff 04		 cmp	 DWORD PTR _n$237170[ebp], 4
  02a53	7d 6c		 jge	 SHORT $LN11@PullObjInn

; 797  : 				{
; 798  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 799  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  02a55	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _n$237170[ebp]
  02a5b	c1 e0 04	 shl	 eax, 4
  02a5e	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _iSX$237165[ebp]
  02a64	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax]
  02a6a	7c 50		 jl	 SHORT $LN10@PullObjInn
  02a6c	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _n$237170[ebp]
  02a72	c1 e0 04	 shl	 eax, 4
  02a75	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _iSX$237165[ebp]
  02a7b	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+8]
  02a81	7f 39		 jg	 SHORT $LN10@PullObjInn
  02a83	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _n$237170[ebp]
  02a89	c1 e0 04	 shl	 eax, 4
  02a8c	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iSY$237166[ebp]
  02a92	3b 88 04 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+4]
  02a98	7c 22		 jl	 SHORT $LN10@PullObjInn
  02a9a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _n$237170[ebp]
  02aa0	c1 e0 04	 shl	 eax, 4
  02aa3	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iSY$237166[ebp]
  02aa9	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+12]
  02aaf	7f 0b		 jg	 SHORT $LN10@PullObjInn

; 800  : 					{
; 801  : 						iUSER_AXIS = n;

  02ab1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _n$237170[ebp]
  02ab7	89 45 e8	 mov	 DWORD PTR _iUSER_AXIS$[ebp], eax

; 802  : 						break;

  02aba	eb 05		 jmp	 SHORT $LN11@PullObjInn
$LN10@PullObjInn:

; 803  : 					}
; 804  : 				}

  02abc	e9 7c ff ff ff	 jmp	 $LN12@PullObjInn
$LN11@PullObjInn:

; 805  : 
; 806  : 				if ( n == MAX_CC_TRAP_STEP )

  02ac1	83 bd 50 ff ff
	ff 04		 cmp	 DWORD PTR _n$237170[ebp], 4
  02ac8	75 05		 jne	 SHORT $LN9@PullObjInn

; 807  : 					continue;

  02aca	e9 30 fd ff ff	 jmp	 $LN19@PullObjInn
$LN9@PullObjInn:

; 808  : 
; 809  : 				if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  02acf	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  02ad2	c1 e0 04	 shl	 eax, 4
  02ad5	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  02ad9	e8 00 00 00 00	 call	 ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
  02ade	0f b6 c8	 movzx	 ecx, al
  02ae1	85 c9		 test	 ecx, ecx
  02ae3	75 70		 jne	 SHORT $LN7@PullObjInn

; 810  : 				{
; 811  : 					POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  02ae5	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  02ae8	c1 e0 04	 shl	 eax, 4
  02aeb	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  02aef	e8 00 00 00 00	 call	 ?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
  02af4	8b 08		 mov	 ecx, DWORD PTR [eax]
  02af6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02af9	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _ptEMPTY$237177[ebp], ecx
  02aff	89 95 4c ff ff
	ff		 mov	 DWORD PTR _ptEMPTY$237177[ebp+4], edx

; 812  : 					vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  02b05	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  02b08	c1 e0 04	 shl	 eax, 4
  02b0b	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  02b0f	e8 00 00 00 00	 call	 ?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back

; 813  : 
; 814  : 					if ( this->ObjSetPosition(iMON_INDEX, ptEMPTY.x, ptEMPTY.y) == TRUE )

  02b14	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _ptEMPTY$237177[ebp+4]
  02b1a	50		 push	 eax
  02b1b	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _ptEMPTY$237177[ebp]
  02b21	51		 push	 ecx
  02b22	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _iMON_INDEX$237162[ebp]
  02b28	52		 push	 edx
  02b29	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02b2c	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  02b31	83 f8 01	 cmp	 eax, 1
  02b34	75 1f		 jne	 SHORT $LN7@PullObjInn

; 815  : 					{
; 816  : 						gObj[iMON_INDEX].m_iChaosCastleBlowTime = GetTickCount();

  02b36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  02b3c	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _iMON_INDEX$237162[ebp]
  02b42	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02b48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b4e	89 84 0a a8 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3752], eax
$LN7@PullObjInn:

; 817  : 					}
; 818  : 				}
; 819  : 			}
; 820  : 		}
; 821  : 	}

  02b55	e9 a5 fc ff ff	 jmp	 $LN19@PullObjInn
$LN18@PullObjInn:

; 822  : 
; 823  : 	for ( int iMAP_ITEM =0;iMAP_ITEM<MAX_MAPITEM;iMAP_ITEM++)

  02b5a	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _iMAP_ITEM$237179[ebp], 0
  02b64	eb 0f		 jmp	 SHORT $LN6@PullObjInn
$LN5@PullObjInn:
  02b66	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _iMAP_ITEM$237179[ebp]
  02b6c	83 c0 01	 add	 eax, 1
  02b6f	89 85 44 ff ff
	ff		 mov	 DWORD PTR _iMAP_ITEM$237179[ebp], eax
$LN6@PullObjInn:
  02b75	81 bd 44 ff ff
	ff 2c 01 00 00	 cmp	 DWORD PTR _iMAP_ITEM$237179[ebp], 300 ; 0000012cH
  02b7f	0f 8d 42 01 00
	00		 jge	 $LN4@PullObjInn

; 824  : 	{
; 825  : 		int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  02b85	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02b88	50		 push	 eax
  02b89	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02b8c	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  02b91	89 85 40 ff ff
	ff		 mov	 DWORD PTR _iMapNumber$237183[ebp], eax

; 826  : 
; 827  : 		if ( MapC[iMapNumber].m_cItem[iMAP_ITEM].IsItem() )

  02b97	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237183[ebp]
  02b9d	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02ba3	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iMAP_ITEM$237179[ebp]
  02ba9	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  02baf	8d 8c 08 24 00
	00 00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+ecx+36]
  02bb6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  02bbb	85 c0		 test	 eax, eax
  02bbd	0f 84 ff 00 00
	00		 je	 $LN2@PullObjInn

; 828  : 		{
; 829  : 			int x = MapC[iMapNumber].m_cItem[iMAP_ITEM].px;

  02bc3	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237183[ebp]
  02bc9	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02bcf	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iMAP_ITEM$237179[ebp]
  02bd5	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  02bdb	0f b6 94 08 f8
	00 00 00	 movzx	 edx, BYTE PTR ?MapC@@3PAVMapClass@@A[eax+ecx+248]
  02be3	89 95 3c ff ff
	ff		 mov	 DWORD PTR _x$237185[ebp], edx

; 830  : 			int y = MapC[iMapNumber].m_cItem[iMAP_ITEM].py;

  02be9	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237183[ebp]
  02bef	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02bf5	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iMAP_ITEM$237179[ebp]
  02bfb	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  02c01	0f b6 94 08 f9
	00 00 00	 movzx	 edx, BYTE PTR ?MapC@@3PAVMapClass@@A[eax+ecx+249]
  02c09	89 95 38 ff ff
	ff		 mov	 DWORD PTR _y$237186[ebp], edx

; 831  : 
; 832  : 			if ( x < ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] || x > ::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] ||
; 833  : 				 y < ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] || y > ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] )

  02c0f	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02c12	c1 e0 04	 shl	 eax, 4
  02c15	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _x$237185[ebp]
  02c1b	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  02c21	7c 3c		 jl	 SHORT $LN1@PullObjInn
  02c23	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02c26	c1 e0 04	 shl	 eax, 4
  02c29	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _x$237185[ebp]
  02c2f	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  02c35	7f 28		 jg	 SHORT $LN1@PullObjInn
  02c37	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02c3a	c1 e0 04	 shl	 eax, 4
  02c3d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _y$237186[ebp]
  02c43	3b 88 04 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  02c49	7c 14		 jl	 SHORT $LN1@PullObjInn
  02c4b	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02c4e	c1 e0 04	 shl	 eax, 4
  02c51	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _y$237186[ebp]
  02c57	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  02c5d	7e 63		 jle	 SHORT $LN2@PullObjInn
$LN1@PullObjInn:

; 834  : 			{
; 835  : 				MapC[iMapNumber].m_cItem[iMAP_ITEM].m_State = 8;

  02c5f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237183[ebp]
  02c65	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02c6b	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iMAP_ITEM$237179[ebp]
  02c71	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  02c77	c7 84 08 fc 00
	00 00 08 00 00
	00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[eax+ecx+252], 8

; 836  : 				MapC[iMapNumber].m_cItem[iMAP_ITEM].Give = true;

  02c82	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237183[ebp]
  02c88	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02c8e	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iMAP_ITEM$237179[ebp]
  02c94	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  02c9a	c6 84 08 fb 00
	00 00 01	 mov	 BYTE PTR ?MapC@@3PAVMapClass@@A[eax+ecx+251], 1

; 837  : 				MapC[iMapNumber].m_cItem[iMAP_ITEM].live = false;

  02ca2	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$237183[ebp]
  02ca8	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02cae	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iMAP_ITEM$237179[ebp]
  02cb4	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  02cba	c6 84 08 fa 00
	00 00 00	 mov	 BYTE PTR ?MapC@@3PAVMapClass@@A[eax+ecx+250], 0
$LN2@PullObjInn:

; 838  : 			}
; 839  : 		}
; 840  : 	}

  02cc2	e9 9f fe ff ff	 jmp	 $LN5@PullObjInn
$LN4@PullObjInn:

; 841  : }

  02cc7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02cce	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  02cd3	6a 04		 push	 4
  02cd5	6a 10		 push	 16			; 00000010H
  02cd7	8d 45 a8	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  02cda	50		 push	 eax
  02cdb	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN47@PullObjInn:
  02ce0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02ce3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  02cea	59		 pop	 ecx
  02ceb	5f		 pop	 edi
  02cec	5e		 pop	 esi
  02ced	5b		 pop	 ebx
  02cee	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02cf1	33 cd		 xor	 ecx, ebp
  02cf3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02cf8	8b e5		 mov	 esp, ebp
  02cfa	5d		 pop	 ebp
  02cfb	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z$0:
  00065	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  0006a	6a 04		 push	 4
  0006c	6a 10		 push	 16			; 00000010H
  0006e	8d 45 a8	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00077	c3		 ret	 0
__ehhandler$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z:
  00078	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0007c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007f	8b 8a ec fe ff
	ff		 mov	 ecx, DWORD PTR [edx-276]
  00085	33 c8		 xor	 ecx, eax
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0008f	33 c8		 xor	 ecx, eax
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
  0009b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::PullObjInnerPlace
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv72 = -88						; size = 4
tv67 = -88						; size = 4
_iMapNumber$237209 = -20				; size = 4
_c$237205 = -16						; size = 4
_b$237201 = -12						; size = 4
_a$237197 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iTRAP_STEP$ = 12					; size = 4
?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SetMapAttrHollow
; _this$ = ecx

; 844  : {

  02d00	55		 push	 ebp
  02d01	8b ec		 mov	 ebp, esp
  02d03	83 ec 58	 sub	 esp, 88			; 00000058H
  02d06	53		 push	 ebx
  02d07	56		 push	 esi
  02d08	57		 push	 edi
  02d09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 845  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  02d0c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  02d10	7d 09		 jge	 SHORT $LN15@SetMapAttr
  02d12	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  02d19	eb 0c		 jmp	 SHORT $LN16@SetMapAttr
$LN15@SetMapAttr:
  02d1b	33 c0		 xor	 eax, eax
  02d1d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  02d21	0f 9e c0	 setle	 al
  02d24	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN16@SetMapAttr:
  02d27	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  02d2b	75 05		 jne	 SHORT $LN12@SetMapAttr

; 846  : 	{
; 847  : 		return;

  02d2d	e9 18 01 00 00	 jmp	 $LN13@SetMapAttr
$LN12@SetMapAttr:

; 848  : 	}
; 849  : 
; 850  : 	if ( CC_TRAP_STEP_RANGE(iTRAP_STEP) == FALSE )

  02d32	83 7d 0c 00	 cmp	 DWORD PTR _iTRAP_STEP$[ebp], 0
  02d36	7d 09		 jge	 SHORT $LN17@SetMapAttr
  02d38	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  02d3f	eb 0c		 jmp	 SHORT $LN18@SetMapAttr
$LN17@SetMapAttr:
  02d41	33 c0		 xor	 eax, eax
  02d43	83 7d 0c 03	 cmp	 DWORD PTR _iTRAP_STEP$[ebp], 3
  02d47	0f 9e c0	 setle	 al
  02d4a	89 45 a8	 mov	 DWORD PTR tv72[ebp], eax
$LN18@SetMapAttr:
  02d4d	83 7d a8 00	 cmp	 DWORD PTR tv72[ebp], 0
  02d51	75 05		 jne	 SHORT $LN11@SetMapAttr

; 851  : 	{
; 852  : 		return;

  02d53	e9 f2 00 00 00	 jmp	 $LN13@SetMapAttr
$LN11@SetMapAttr:

; 853  : 	}
; 854  : 
; 855  : 	if ( iTRAP_STEP == 0 )

  02d58	83 7d 0c 00	 cmp	 DWORD PTR _iTRAP_STEP$[ebp], 0
  02d5c	75 05		 jne	 SHORT $LN10@SetMapAttr

; 856  : 	{
; 857  : 		return;

  02d5e	e9 e7 00 00 00	 jmp	 $LN13@SetMapAttr
$LN10@SetMapAttr:

; 858  : 	}
; 859  : 
; 860  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  02d63	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _a$237197[ebp], 0
  02d6a	eb 09		 jmp	 SHORT $LN9@SetMapAttr
$LN8@SetMapAttr:
  02d6c	8b 45 f8	 mov	 eax, DWORD PTR _a$237197[ebp]
  02d6f	83 c0 01	 add	 eax, 1
  02d72	89 45 f8	 mov	 DWORD PTR _a$237197[ebp], eax
$LN9@SetMapAttr:
  02d75	83 7d f8 04	 cmp	 DWORD PTR _a$237197[ebp], 4
  02d79	0f 8d cb 00 00
	00		 jge	 $LN13@SetMapAttr

; 861  : 	{
; 862  : 		for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  02d7f	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02d82	c1 e0 06	 shl	 eax, 6
  02d85	8b 4d f8	 mov	 ecx, DWORD PTR _a$237197[ebp]
  02d88	c1 e1 04	 shl	 ecx, 4
  02d8b	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx]
  02d92	89 55 f4	 mov	 DWORD PTR _b$237201[ebp], edx
  02d95	eb 09		 jmp	 SHORT $LN6@SetMapAttr
$LN5@SetMapAttr:
  02d97	8b 45 f4	 mov	 eax, DWORD PTR _b$237201[ebp]
  02d9a	83 c0 01	 add	 eax, 1
  02d9d	89 45 f4	 mov	 DWORD PTR _b$237201[ebp], eax
$LN6@SetMapAttr:
  02da0	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02da3	c1 e0 06	 shl	 eax, 6
  02da6	8b 4d f8	 mov	 ecx, DWORD PTR _a$237197[ebp]
  02da9	c1 e1 04	 shl	 ecx, 4
  02dac	8b 55 f4	 mov	 edx, DWORD PTR _b$237201[ebp]
  02daf	3b 94 08 08 00
	00 00		 cmp	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx+8]
  02db6	0f 8f 89 00 00
	00		 jg	 $LN4@SetMapAttr

; 863  : 		{
; 864  : 			for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  02dbc	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02dbf	c1 e0 06	 shl	 eax, 6
  02dc2	8b 4d f8	 mov	 ecx, DWORD PTR _a$237197[ebp]
  02dc5	c1 e1 04	 shl	 ecx, 4
  02dc8	8b 94 08 04 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx+4]
  02dcf	89 55 f0	 mov	 DWORD PTR _c$237205[ebp], edx
  02dd2	eb 09		 jmp	 SHORT $LN3@SetMapAttr
$LN2@SetMapAttr:
  02dd4	8b 45 f0	 mov	 eax, DWORD PTR _c$237205[ebp]
  02dd7	83 c0 01	 add	 eax, 1
  02dda	89 45 f0	 mov	 DWORD PTR _c$237205[ebp], eax
$LN3@SetMapAttr:
  02ddd	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  02de0	c1 e0 06	 shl	 eax, 6
  02de3	8b 4d f8	 mov	 ecx, DWORD PTR _a$237197[ebp]
  02de6	c1 e1 04	 shl	 ecx, 4
  02de9	8b 55 f0	 mov	 edx, DWORD PTR _c$237205[ebp]
  02dec	3b 94 08 0c 00
	00 00		 cmp	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx+12]
  02df3	7f 4b		 jg	 SHORT $LN1@SetMapAttr

; 865  : 			{
; 866  : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  02df5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02df8	50		 push	 eax
  02df9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02dfc	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  02e01	89 45 ec	 mov	 DWORD PTR _iMapNumber$237209[ebp], eax

; 867  : 				MapC[iMapNumber].m_attrbuf[ c * 256 + b] |= 8;

  02e04	8b 45 ec	 mov	 eax, DWORD PTR _iMapNumber$237209[ebp]
  02e07	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02e0d	8b 4d f0	 mov	 ecx, DWORD PTR _c$237205[ebp]
  02e10	c1 e1 08	 shl	 ecx, 8
  02e13	03 4d f4	 add	 ecx, DWORD PTR _b$237201[ebp]
  02e16	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  02e1c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  02e20	83 c8 08	 or	 eax, 8
  02e23	8b 4d ec	 mov	 ecx, DWORD PTR _iMapNumber$237209[ebp]
  02e26	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  02e2c	8b 55 f0	 mov	 edx, DWORD PTR _c$237205[ebp]
  02e2f	c1 e2 08	 shl	 edx, 8
  02e32	03 55 f4	 add	 edx, DWORD PTR _b$237201[ebp]
  02e35	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  02e3b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 868  : 			}

  02e3e	eb 94		 jmp	 SHORT $LN2@SetMapAttr
$LN1@SetMapAttr:

; 869  : 		}

  02e40	e9 52 ff ff ff	 jmp	 $LN5@SetMapAttr
$LN4@SetMapAttr:

; 870  : 	}

  02e45	e9 22 ff ff ff	 jmp	 $LN8@SetMapAttr
$LN13@SetMapAttr:

; 871  : 	
; 872  : }

  02e4a	5f		 pop	 edi
  02e4b	5e		 pop	 esi
  02e4c	5b		 pop	 ebx
  02e4d	8b e5		 mov	 esp, ebp
  02e4f	5d		 pop	 ebp
  02e50	c2 08 00	 ret	 8
?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SetMapAttrHollow
_TEXT	ENDS
PUBLIC	?SetMapAttrFill@CChaosCastle@@QAEXH@Z		; CChaosCastle::SetMapAttrFill
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -92						; size = 4
_iMapNumber$237231 = -24				; size = 4
_c$237227 = -20						; size = 4
_b$237223 = -16						; size = 4
_a$237219 = -12						; size = 4
_iTRAP_STEP$237215 = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetMapAttrFill@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SetMapAttrFill
; _this$ = ecx

; 875  : {

  02e60	55		 push	 ebp
  02e61	8b ec		 mov	 ebp, esp
  02e63	83 ec 5c	 sub	 esp, 92			; 0000005cH
  02e66	53		 push	 ebx
  02e67	56		 push	 esi
  02e68	57		 push	 edi
  02e69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  02e6c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  02e70	7d 09		 jge	 SHORT $LN16@SetMapAttr@2
  02e72	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  02e79	eb 0c		 jmp	 SHORT $LN17@SetMapAttr@2
$LN16@SetMapAttr@2:
  02e7b	33 c0		 xor	 eax, eax
  02e7d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  02e81	0f 9e c0	 setle	 al
  02e84	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN17@SetMapAttr@2:
  02e87	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  02e8b	75 05		 jne	 SHORT $LN13@SetMapAttr@2

; 877  : 	{
; 878  : 		return;

  02e8d	e9 08 01 00 00	 jmp	 $LN14@SetMapAttr@2
$LN13@SetMapAttr@2:

; 879  : 	}
; 880  : 	
; 881  : 	for ( int iTRAP_STEP=1;iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  02e92	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iTRAP_STEP$237215[ebp], 1
  02e99	eb 09		 jmp	 SHORT $LN12@SetMapAttr@2
$LN11@SetMapAttr@2:
  02e9b	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$237215[ebp]
  02e9e	83 c0 01	 add	 eax, 1
  02ea1	89 45 f8	 mov	 DWORD PTR _iTRAP_STEP$237215[ebp], eax
$LN12@SetMapAttr@2:
  02ea4	83 7d f8 04	 cmp	 DWORD PTR _iTRAP_STEP$237215[ebp], 4
  02ea8	0f 8d ec 00 00
	00		 jge	 $LN14@SetMapAttr@2

; 882  : 	{
; 883  : 		for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  02eae	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _a$237219[ebp], 0
  02eb5	eb 09		 jmp	 SHORT $LN9@SetMapAttr@2
$LN8@SetMapAttr@2:
  02eb7	8b 45 f4	 mov	 eax, DWORD PTR _a$237219[ebp]
  02eba	83 c0 01	 add	 eax, 1
  02ebd	89 45 f4	 mov	 DWORD PTR _a$237219[ebp], eax
$LN9@SetMapAttr@2:
  02ec0	83 7d f4 04	 cmp	 DWORD PTR _a$237219[ebp], 4
  02ec4	0f 8d cb 00 00
	00		 jge	 $LN7@SetMapAttr@2

; 884  : 		{
; 885  : 			for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  02eca	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$237215[ebp]
  02ecd	c1 e0 06	 shl	 eax, 6
  02ed0	8b 4d f4	 mov	 ecx, DWORD PTR _a$237219[ebp]
  02ed3	c1 e1 04	 shl	 ecx, 4
  02ed6	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx]
  02edd	89 55 f0	 mov	 DWORD PTR _b$237223[ebp], edx
  02ee0	eb 09		 jmp	 SHORT $LN6@SetMapAttr@2
$LN5@SetMapAttr@2:
  02ee2	8b 45 f0	 mov	 eax, DWORD PTR _b$237223[ebp]
  02ee5	83 c0 01	 add	 eax, 1
  02ee8	89 45 f0	 mov	 DWORD PTR _b$237223[ebp], eax
$LN6@SetMapAttr@2:
  02eeb	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$237215[ebp]
  02eee	c1 e0 06	 shl	 eax, 6
  02ef1	8b 4d f4	 mov	 ecx, DWORD PTR _a$237219[ebp]
  02ef4	c1 e1 04	 shl	 ecx, 4
  02ef7	8b 55 f0	 mov	 edx, DWORD PTR _b$237223[ebp]
  02efa	3b 94 08 08 00
	00 00		 cmp	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx+8]
  02f01	0f 8f 89 00 00
	00		 jg	 $LN4@SetMapAttr@2

; 886  : 			{
; 887  : 				for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  02f07	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$237215[ebp]
  02f0a	c1 e0 06	 shl	 eax, 6
  02f0d	8b 4d f4	 mov	 ecx, DWORD PTR _a$237219[ebp]
  02f10	c1 e1 04	 shl	 ecx, 4
  02f13	8b 94 08 04 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx+4]
  02f1a	89 55 ec	 mov	 DWORD PTR _c$237227[ebp], edx
  02f1d	eb 09		 jmp	 SHORT $LN3@SetMapAttr@2
$LN2@SetMapAttr@2:
  02f1f	8b 45 ec	 mov	 eax, DWORD PTR _c$237227[ebp]
  02f22	83 c0 01	 add	 eax, 1
  02f25	89 45 ec	 mov	 DWORD PTR _c$237227[ebp], eax
$LN3@SetMapAttr@2:
  02f28	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$237215[ebp]
  02f2b	c1 e0 06	 shl	 eax, 6
  02f2e	8b 4d f4	 mov	 ecx, DWORD PTR _a$237219[ebp]
  02f31	c1 e1 04	 shl	 ecx, 4
  02f34	8b 55 ec	 mov	 edx, DWORD PTR _c$237227[ebp]
  02f37	3b 94 08 0c 00
	00 00		 cmp	 edx, DWORD PTR _g_iChaosCastle_MapHollowZone[eax+ecx+12]
  02f3e	7f 4b		 jg	 SHORT $LN1@SetMapAttr@2

; 888  : 				{
; 889  : 					int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  02f40	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02f43	50		 push	 eax
  02f44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02f47	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  02f4c	89 45 e8	 mov	 DWORD PTR _iMapNumber$237231[ebp], eax

; 890  : 					MapC[iMapNumber].m_attrbuf[ c * 256 + b] &= ~8;

  02f4f	8b 45 e8	 mov	 eax, DWORD PTR _iMapNumber$237231[ebp]
  02f52	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  02f58	8b 4d ec	 mov	 ecx, DWORD PTR _c$237227[ebp]
  02f5b	c1 e1 08	 shl	 ecx, 8
  02f5e	03 4d f0	 add	 ecx, DWORD PTR _b$237223[ebp]
  02f61	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  02f67	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  02f6b	83 e0 f7	 and	 eax, -9			; fffffff7H
  02f6e	8b 4d e8	 mov	 ecx, DWORD PTR _iMapNumber$237231[ebp]
  02f71	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  02f77	8b 55 ec	 mov	 edx, DWORD PTR _c$237227[ebp]
  02f7a	c1 e2 08	 shl	 edx, 8
  02f7d	03 55 f0	 add	 edx, DWORD PTR _b$237223[ebp]
  02f80	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  02f86	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 891  : 				}

  02f89	eb 94		 jmp	 SHORT $LN2@SetMapAttr@2
$LN1@SetMapAttr@2:

; 892  : 			}

  02f8b	e9 52 ff ff ff	 jmp	 $LN5@SetMapAttr@2
$LN4@SetMapAttr@2:

; 893  : 		}

  02f90	e9 22 ff ff ff	 jmp	 $LN8@SetMapAttr@2
$LN7@SetMapAttr@2:

; 894  : 	}

  02f95	e9 01 ff ff ff	 jmp	 $LN11@SetMapAttr@2
$LN14@SetMapAttr@2:

; 895  : }

  02f9a	5f		 pop	 edi
  02f9b	5e		 pop	 esi
  02f9c	5b		 pop	 ebx
  02f9d	8b e5		 mov	 esp, ebp
  02f9f	5d		 pop	 ebp
  02fa0	c2 04 00	 ret	 4
?SetMapAttrFill@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SetMapAttrFill
; Function compile flags: /Odtp /ZI
_pMsg$237239 = -12					; size = 4
_iTICK_MSEC$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_PlayEnd
; _this$ = ecx

; 898  : {

  02fb0	55		 push	 ebp
  02fb1	8b ec		 mov	 ebp, esp
  02fb3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  02fb6	53		 push	 ebx
  02fb7	56		 push	 esi
  02fb8	57		 push	 edi
  02fb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 899  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  02fbc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  02fc2	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  02fc5	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  02fcb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02fce	2b 44 0a 44	 sub	 eax, DWORD PTR [edx+ecx+68]
  02fd2	89 45 f8	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 900  : 
; 901  : 	if ( iTICK_MSEC >= 1000 )

  02fd5	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  02fdc	0f 8c bd 00 00
	00		 jl	 $LN3@ProcState_@3

; 902  : 	{
; 903  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  02fe2	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02fe5	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02feb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02fee	8b 54 01 40	 mov	 edx, DWORD PTR [ecx+eax+64]
  02ff2	2b 55 f8	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  02ff5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  02ff8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  02ffe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03001	89 54 01 40	 mov	 DWORD PTR [ecx+eax+64], edx

; 904  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  03005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0300b	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0300e	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  03014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03017	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 905  : 		this->CheckUserInDieTile(iChaosCastleIndex);

  0301b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0301e	50		 push	 eax
  0301f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03022	e8 00 00 00 00	 call	 ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckUserInDieTile

; 906  : 
; 907  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_QUIT == false)

  03027	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0302a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03033	81 7c 01 40 30
	75 00 00	 cmp	 DWORD PTR [ecx+eax+64], 30000 ; 00007530H
  0303b	7f 62		 jg	 SHORT $LN3@ProcState_@3
  0303d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03040	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03049	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  0304e	7e 4f		 jle	 SHORT $LN3@ProcState_@3
  03050	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03053	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0305c	0f b6 54 01 52	 movzx	 edx, BYTE PTR [ecx+eax+82]
  03061	85 d2		 test	 edx, edx
  03063	75 3a		 jne	 SHORT $LN3@ProcState_@3

; 908  : 		{
; 909  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_QUIT = true;

  03065	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03068	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0306e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03071	c6 44 01 52 01	 mov	 BYTE PTR [ecx+eax+82], 1

; 910  : 
; 911  : 			PMSG_SET_DEVILSQUARE pMsg;
; 912  : 
; 913  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  03076	6a 04		 push	 4
  03078	68 92 00 00 00	 push	 146			; 00000092H
  0307d	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$237239[ebp]
  03080	50		 push	 eax
  03081	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  03086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 914  : 			pMsg.Type = 13;

  03089	c6 45 f7 0d	 mov	 BYTE PTR _pMsg$237239[ebp+3], 13 ; 0000000dH

; 915  : 
; 916  : 			this->SendChaosCastleAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  0308d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03090	50		 push	 eax
  03091	6a 04		 push	 4
  03093	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$237239[ebp]
  03096	51		 push	 ecx
  03097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0309a	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN3@ProcState_@3:

; 917  : 		}
; 918  : 	}
; 919  : 
; 920  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  0309f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  030a2	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  030a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  030ab	83 7c 01 40 00	 cmp	 DWORD PTR [ecx+eax+64], 0
  030b0	7f 0e		 jg	 SHORT $LN4@ProcState_@3

; 921  : 	{
; 922  : 		this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  030b2	6a 01		 push	 1
  030b4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  030b7	50		 push	 eax
  030b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  030bb	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN4@ProcState_@3:

; 923  : 	}
; 924  : }

  030c0	5f		 pop	 edi
  030c1	5e		 pop	 esi
  030c2	5b		 pop	 ebx
  030c3	8b e5		 mov	 esp, ebp
  030c5	5d		 pop	 ebp
  030c6	c2 04 00	 ret	 4
?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_PlayEnd
_TEXT	ENDS
PUBLIC	?SetState_PlayEnd@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_PlayEnd
PUBLIC	?SetState_Playing@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_Playing
PUBLIC	?SetState_Closed@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_Closed
PUBLIC	?SetState_None@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_None
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv77 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iCC_STATE$ = 12					; size = 4
?SetState@CChaosCastle@@QAEXHH@Z PROC			; CChaosCastle::SetState
; _this$ = ecx

; 931  : {

  030d0	55		 push	 ebp
  030d1	8b ec		 mov	 ebp, esp
  030d3	83 ec 48	 sub	 esp, 72			; 00000048H
  030d6	53		 push	 ebx
  030d7	56		 push	 esi
  030d8	57		 push	 edi
  030d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 932  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  030dc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  030e0	7d 09		 jge	 SHORT $LN12@SetState
  030e2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  030e9	eb 0c		 jmp	 SHORT $LN13@SetState
$LN12@SetState:
  030eb	33 c0		 xor	 eax, eax
  030ed	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  030f1	0f 9e c0	 setle	 al
  030f4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN13@SetState:
  030f7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  030fb	75 02		 jne	 SHORT $LN9@SetState

; 933  : 	{
; 934  : 		return;

  030fd	eb 7a		 jmp	 SHORT $LN10@SetState
$LN9@SetState:

; 935  : 	}
; 936  : 
; 937  : 	if ( iCC_STATE < CC_STATE_NONE || iCC_STATE > CC_STATE_PLAYEND )

  030ff	83 7d 0c 00	 cmp	 DWORD PTR _iCC_STATE$[ebp], 0
  03103	7c 06		 jl	 SHORT $LN7@SetState
  03105	83 7d 0c 03	 cmp	 DWORD PTR _iCC_STATE$[ebp], 3
  03109	7e 02		 jle	 SHORT $LN8@SetState
$LN7@SetState:

; 938  : 	{
; 939  : 		return;

  0310b	eb 6c		 jmp	 SHORT $LN10@SetState
$LN8@SetState:

; 940  : 	}
; 941  : 
; 942  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE = iCC_STATE;

  0310d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03110	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03116	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03119	8b 55 0c	 mov	 edx, DWORD PTR _iCC_STATE$[ebp]
  0311c	89 54 01 30	 mov	 DWORD PTR [ecx+eax+48], edx

; 943  : 
; 944  : 	switch ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE )

  03120	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03123	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0312c	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  03130	89 55 b8	 mov	 DWORD PTR tv77[ebp], edx
  03133	83 7d b8 03	 cmp	 DWORD PTR tv77[ebp], 3
  03137	77 40		 ja	 SHORT $LN10@SetState
  03139	8b 45 b8	 mov	 eax, DWORD PTR tv77[ebp]
  0313c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@SetState[eax*4]
$LN4@SetState:

; 945  : 	{
; 946  : 		case CC_STATE_NONE:
; 947  : 			this->SetState_None(iChaosCastleIndex);

  03143	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03146	50		 push	 eax
  03147	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0314a	e8 00 00 00 00	 call	 ?SetState_None@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_None

; 948  : 			break;

  0314f	eb 28		 jmp	 SHORT $LN10@SetState
$LN3@SetState:

; 949  : 
; 950  : 		case CC_STATE_CLOSED:
; 951  : 			this->SetState_Closed(iChaosCastleIndex);

  03151	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03154	50		 push	 eax
  03155	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03158	e8 00 00 00 00	 call	 ?SetState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Closed

; 952  : 			break;

  0315d	eb 1a		 jmp	 SHORT $LN10@SetState
$LN2@SetState:

; 953  : 
; 954  : 		case CC_STATE_PLAYING:
; 955  : 			this->SetState_Playing(iChaosCastleIndex);

  0315f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03162	50		 push	 eax
  03163	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03166	e8 00 00 00 00	 call	 ?SetState_Playing@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Playing

; 956  : 			break;

  0316b	eb 0c		 jmp	 SHORT $LN10@SetState
$LN1@SetState:

; 957  : 
; 958  : 		case CC_STATE_PLAYEND:
; 959  : 			this->SetState_PlayEnd(iChaosCastleIndex);

  0316d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03170	50		 push	 eax
  03171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03174	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_PlayEnd
$LN10@SetState:

; 960  : 	}
; 961  : 	
; 962  : }

  03179	5f		 pop	 edi
  0317a	5e		 pop	 esi
  0317b	5b		 pop	 ebx
  0317c	8b e5		 mov	 esp, ebp
  0317e	5d		 pop	 ebp
  0317f	c2 08 00	 ret	 8
  03182	8b ff		 npad	 2
$LN14@SetState:
  03184	00 00 00 00	 DD	 $LN4@SetState
  03188	00 00 00 00	 DD	 $LN3@SetState
  0318c	00 00 00 00	 DD	 $LN2@SetState
  03190	00 00 00 00	 DD	 $LN1@SetState
?SetState@CChaosCastle@@QAEXHH@Z ENDP			; CChaosCastle::SetState
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetState_None@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_None
; _this$ = ecx

; 965  : {

  031a0	55		 push	 ebp
  031a1	8b ec		 mov	 ebp, esp
  031a3	83 ec 44	 sub	 esp, 68			; 00000044H
  031a6	53		 push	 ebx
  031a7	56		 push	 esi
  031a8	57		 push	 edi
  031a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 966  : 	return;
; 967  : }

  031ac	5f		 pop	 edi
  031ad	5e		 pop	 esi
  031ae	5b		 pop	 ebx
  031af	8b e5		 mov	 esp, ebp
  031b1	5d		 pop	 ebp
  031b2	c2 04 00	 ret	 4
?SetState_None@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_None
_TEXT	ENDS
PUBLIC	??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
PUBLIC	?SafetyCastleZone@CChaosCastle@@QAEXH@Z		; CChaosCastle::SafetyCastleZone
PUBLIC	?ClearMonster@CChaosCastle@@QAEXH@Z		; CChaosCastle::ClearMonster
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
;	COMDAT ??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
CONST	SEGMENT
??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Chaos Castle] (%d) SetState CLOSED', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -76						; size = 4
_n$237268 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetState_Closed@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_Closed
; _this$ = ecx

; 970  : {

  031c0	55		 push	 ebp
  031c1	8b ec		 mov	 ebp, esp
  031c3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  031c6	53		 push	 ebx
  031c7	56		 push	 esi
  031c8	57		 push	 edi
  031c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 971  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  031cc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  031d0	7d 09		 jge	 SHORT $LN9@SetState_C
  031d2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  031d9	eb 0c		 jmp	 SHORT $LN10@SetState_C
$LN9@SetState_C:
  031db	33 c0		 xor	 eax, eax
  031dd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  031e1	0f 9e c0	 setle	 al
  031e4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@SetState_C:
  031e7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  031eb	75 05		 jne	 SHORT $LN6@SetState_C

; 972  : 	{
; 973  : 		return;

  031ed	e9 c7 00 00 00	 jmp	 $LN7@SetState_C
$LN6@SetState_C:

; 974  : 	}
; 975  : 
; 976  : 	this->SendNoticeState(iChaosCastleIndex, 7);

  031f2	6a 07		 push	 7
  031f4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  031f7	50		 push	 eax
  031f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  031fb	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 977  : 	this->ClearChaosCastleData(iChaosCastleIndex);

  03200	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03203	50		 push	 eax
  03204	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03207	e8 00 00 00 00	 call	 ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ; CChaosCastle::ClearChaosCastleData

; 978  : 	this->ClearMonster(iChaosCastleIndex);

  0320c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0320f	50		 push	 eax
  03210	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03213	e8 00 00 00 00	 call	 ?ClearMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::ClearMonster

; 979  : 
; 980  : 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  03218	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _n$237268[ebp], 14000 ; 000036b0H
  0321f	eb 09		 jmp	 SHORT $LN5@SetState_C
$LN4@SetState_C:
  03221	8b 45 f8	 mov	 eax, DWORD PTR _n$237268[ebp]
  03224	83 c0 01	 add	 eax, 1
  03227	89 45 f8	 mov	 DWORD PTR _n$237268[ebp], eax
$LN5@SetState_C:
  0322a	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _n$237268[ebp], 15000 ; 00003a98H
  03231	7d 4d		 jge	 SHORT $LN3@SetState_C

; 981  : 	{
; 982  : 		if ( gObj[n].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  03233	8b 45 f8	 mov	 eax, DWORD PTR _n$237268[ebp]
  03236	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0323c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03242	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  0324a	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0324d	52		 push	 edx
  0324e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03251	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  03256	3b f0		 cmp	 esi, eax
  03258	75 24		 jne	 SHORT $LN2@SetState_C

; 983  : 		{
; 984  : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  0325a	8b 45 f8	 mov	 eax, DWORD PTR _n$237268[ebp]
  0325d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03263	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03269	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0326e	7e 0e		 jle	 SHORT $LN2@SetState_C

; 985  : 			{
; 986  : 				gObjMoveGate(n, 22);

  03270	6a 16		 push	 22			; 00000016H
  03272	8b 45 f8	 mov	 eax, DWORD PTR _n$237268[ebp]
  03275	50		 push	 eax
  03276	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0327b	83 c4 08	 add	 esp, 8
$LN2@SetState_C:

; 987  : 			}
; 988  : 		}
; 989  : 	}

  0327e	eb a1		 jmp	 SHORT $LN4@SetState_C
$LN3@SetState_C:

; 990  : 
; 991  : 	this->SafetyCastleZone(iChaosCastleIndex);

  03280	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03283	50		 push	 eax
  03284	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03287	e8 00 00 00 00	 call	 ?SafetyCastleZone@CChaosCastle@@QAEXH@Z ; CChaosCastle::SafetyCastleZone

; 992  : 	this->SetMapAttrFill(iChaosCastleIndex);

  0328c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0328f	50		 push	 eax
  03290	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03293	e8 00 00 00 00	 call	 ?SetMapAttrFill@CChaosCastle@@QAEXH@Z ; CChaosCastle::SetMapAttrFill

; 993  : 	this->CheckSync(iChaosCastleIndex);

  03298	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0329b	50		 push	 eax
  0329c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0329f	e8 00 00 00 00	 call	 ?CheckSync@CChaosCastle@@IAEXH@Z ; CChaosCastle::CheckSync

; 994  : 
; 995  : 	LogAddTD("[Chaos Castle] (%d) SetState CLOSED", iChaosCastleIndex+1);

  032a4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  032a7	83 c0 01	 add	 eax, 1
  032aa	50		 push	 eax
  032ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  032b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  032b6	83 c4 08	 add	 esp, 8
$LN7@SetState_C:

; 996  : }

  032b9	5f		 pop	 edi
  032ba	5e		 pop	 esi
  032bb	5b		 pop	 ebx
  032bc	8b e5		 mov	 esp, ebp
  032be	5d		 pop	 ebp
  032bf	c2 04 00	 ret	 4
?SetState_Closed@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@ ; `string'
PUBLIC	?PlayFailedRollBack@CChaosCastle@@QAEXH@Z	; CChaosCastle::PlayFailedRollBack
PUBLIC	?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z	; CChaosCastle::CheckCanStartPlay
;	COMDAT ??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Chaos Castle] (%d) SetState PLAYING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@
CONST	SEGMENT
??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@ DB '['
	DB	'Chaos Castle] (%d) Failed to Start Chaos Castle : Lack of Use'
	DB	'r', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetState_Playing@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_Playing
; _this$ = ecx

; 999  : {

  032d0	55		 push	 ebp
  032d1	8b ec		 mov	 ebp, esp
  032d3	83 ec 48	 sub	 esp, 72			; 00000048H
  032d6	53		 push	 ebx
  032d7	56		 push	 esi
  032d8	57		 push	 edi
  032d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1000 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  032dc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  032e0	7d 09		 jge	 SHORT $LN6@SetState_P
  032e2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  032e9	eb 0c		 jmp	 SHORT $LN7@SetState_P
$LN6@SetState_P:
  032eb	33 c0		 xor	 eax, eax
  032ed	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  032f1	0f 9e c0	 setle	 al
  032f4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@SetState_P:
  032f7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  032fb	75 05		 jne	 SHORT $LN3@SetState_P

; 1001 : 	{
; 1002 : 		return;

  032fd	e9 95 00 00 00	 jmp	 $LN4@SetState_P
$LN3@SetState_P:

; 1003 : 	}
; 1004 : 
; 1005 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = false;

  03302	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03305	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0330b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0330e	c6 44 01 4c 00	 mov	 BYTE PTR [ecx+eax+76], 0

; 1006 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = this->m_iCC_TIME_MIN_PLAY * 60 * 1000;

  03313	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03316	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  03319	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0331c	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  03322	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  03325	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  0332b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0332e	89 4c 10 40	 mov	 DWORD PTR [eax+edx+64], ecx

; 1007 : 	this->SendCastleZoneSafetyInfo(iChaosCastleIndex, true);

  03332	6a 01		 push	 1
  03334	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03337	50		 push	 eax
  03338	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0333b	e8 00 00 00 00	 call	 ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo

; 1008 : 
; 1009 : 	if ( this->CheckCanStartPlay(iChaosCastleIndex) == false )

  03340	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03343	50		 push	 eax
  03344	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03347	e8 00 00 00 00	 call	 ?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanStartPlay
  0334c	0f b6 c8	 movzx	 ecx, al
  0334f	85 c9		 test	 ecx, ecx
  03351	75 2f		 jne	 SHORT $LN2@SetState_P

; 1010 : 	{
; 1011 : 		this->PlayFailedRollBack(iChaosCastleIndex);

  03353	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03356	50		 push	 eax
  03357	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0335a	e8 00 00 00 00	 call	 ?PlayFailedRollBack@CChaosCastle@@QAEXH@Z ; CChaosCastle::PlayFailedRollBack

; 1012 : 		LogAddTD("[Chaos Castle] (%d) Failed to Start Chaos Castle : Lack of User", iChaosCastleIndex +1 );

  0335f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03362	83 c0 01	 add	 eax, 1
  03365	50		 push	 eax
  03366	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@
  0336b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03371	83 c4 08	 add	 esp, 8

; 1013 : 		this->SetState_Closed(iChaosCastleIndex);

  03374	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03377	50		 push	 eax
  03378	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0337b	e8 00 00 00 00	 call	 ?SetState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Closed

; 1014 : 	}
; 1015 : 	else

  03380	eb 15		 jmp	 SHORT $LN4@SetState_P
$LN2@SetState_P:

; 1016 : 	{
; 1017 : 		LogAddTD("[Chaos Castle] (%d) SetState PLAYING", iChaosCastleIndex + 1 );

  03382	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03385	83 c0 01	 add	 eax, 1
  03388	50		 push	 eax
  03389	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  0338e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03394	83 c4 08	 add	 esp, 8
$LN4@SetState_P:

; 1018 : 	}
; 1019 : }

  03397	5f		 pop	 edi
  03398	5e		 pop	 esi
  03399	5b		 pop	 ebx
  0339a	8b e5		 mov	 esp, ebp
  0339c	5d		 pop	 ebp
  0339d	c2 04 00	 ret	 4
?SetState_Playing@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_Playing
_TEXT	ENDS
PUBLIC	??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
;	COMDAT ??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Chaos Castle] (%d) SetState PLAYEND', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetState_PlayEnd@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_PlayEnd
; _this$ = ecx

; 1022 : {

  033a0	55		 push	 ebp
  033a1	8b ec		 mov	 ebp, esp
  033a3	83 ec 48	 sub	 esp, 72			; 00000048H
  033a6	53		 push	 ebx
  033a7	56		 push	 esi
  033a8	57		 push	 edi
  033a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1023 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  033ac	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  033b0	7d 09		 jge	 SHORT $LN4@SetState_P@2
  033b2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  033b9	eb 0c		 jmp	 SHORT $LN5@SetState_P@2
$LN4@SetState_P@2:
  033bb	33 c0		 xor	 eax, eax
  033bd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  033c1	0f 9e c0	 setle	 al
  033c4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@SetState_P@2:
  033c7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  033cb	75 02		 jne	 SHORT $LN1@SetState_P@2

; 1024 : 	{
; 1025 : 		return;

  033cd	eb 5f		 jmp	 SHORT $LN2@SetState_P@2
$LN1@SetState_P@2:

; 1026 : 	}
; 1027 : 
; 1028 : 	this->SendNoticeState(iChaosCastleIndex, 7);

  033cf	6a 07		 push	 7
  033d1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  033d4	50		 push	 eax
  033d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  033d8	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 1029 : 	this->ClearMonster(iChaosCastleIndex);

  033dd	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  033e0	50		 push	 eax
  033e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  033e4	e8 00 00 00 00	 call	 ?ClearMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::ClearMonster

; 1030 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = false;

  033e9	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  033ec	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  033f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  033f5	c6 44 01 4c 00	 mov	 BYTE PTR [ecx+eax+76], 0

; 1031 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = this->m_iCC_TIME_MIN_REST * 60 * 1000;

  033fa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  033fd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  03400	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  03403	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  03409	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0340c	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  03412	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03415	89 4c 10 40	 mov	 DWORD PTR [eax+edx+64], ecx

; 1032 : 
; 1033 : 	LogAddTD("[Chaos Castle] (%d) SetState PLAYEND", iChaosCastleIndex+1);

  03419	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0341c	83 c0 01	 add	 eax, 1
  0341f	50		 push	 eax
  03420	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  03425	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0342b	83 c4 08	 add	 esp, 8
$LN2@SetState_P@2:

; 1034 : 
; 1035 : 
; 1036 : }

  0342e	5f		 pop	 edi
  0342f	5e		 pop	 esi
  03430	5b		 pop	 ebx
  03431	8b e5		 mov	 esp, ebp
  03433	5d		 pop	 ebp
  03434	c2 04 00	 ret	 4
?SetState_PlayEnd@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_PlayEnd
_TEXT	ENDS
PUBLIC	?Clear@_CHAOSCASTLE_DATA@@QAEXXZ		; _CHAOSCASTLE_DATA::Clear
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -76						; size = 4
_i$237295 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ClearChaosCastleData@CChaosCastle@@IAEXH@Z PROC	; CChaosCastle::ClearChaosCastleData
; _this$ = ecx

; 1039 : {

  03440	55		 push	 ebp
  03441	8b ec		 mov	 ebp, esp
  03443	83 ec 4c	 sub	 esp, 76			; 0000004cH
  03446	53		 push	 ebx
  03447	56		 push	 esi
  03448	57		 push	 edi
  03449	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1040 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0344c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  03450	7d 09		 jge	 SHORT $LN8@ClearChaos
  03452	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03459	eb 0c		 jmp	 SHORT $LN9@ClearChaos
$LN8@ClearChaos:
  0345b	33 c0		 xor	 eax, eax
  0345d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03461	0f 9e c0	 setle	 al
  03464	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@ClearChaos:
  03467	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0346b	75 05		 jne	 SHORT $LN5@ClearChaos

; 1041 : 	{
; 1042 : 		return;

  0346d	e9 5f 01 00 00	 jmp	 $LN6@ClearChaos
$LN5@ClearChaos:

; 1043 : 	}
; 1044 : 
; 1045 : 	this->m_stChaosCastleData[iChaosCastleIndex].Clear();

  03472	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03475	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0347b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0347e	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  03482	e8 00 00 00 00	 call	 ?Clear@_CHAOSCASTLE_DATA@@QAEXXZ ; _CHAOSCASTLE_DATA::Clear

; 1046 : 
; 1047 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++ )

  03487	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$237295[ebp], 0
  0348e	eb 09		 jmp	 SHORT $LN4@ClearChaos
$LN3@ClearChaos:
  03490	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  03493	83 c0 01	 add	 eax, 1
  03496	89 45 f8	 mov	 DWORD PTR _i$237295[ebp], eax
$LN4@ClearChaos:
  03499	83 7d f8 46	 cmp	 DWORD PTR _i$237295[ebp], 70 ; 00000046H
  0349d	0f 8d 2e 01 00
	00		 jge	 $LN6@ClearChaos

; 1048 : 	{
; 1049 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  034a3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  034a6	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  034ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  034af	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  034b3	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  034b6	6b c0 14	 imul	 eax, 20			; 00000014H
  034b9	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  034be	0f 84 e9 00 00
	00		 je	 $LN1@ClearChaos

; 1050 : 		{
; 1051 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  034c4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  034c7	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  034cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  034d0	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  034d4	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  034d7	6b c0 14	 imul	 eax, 20			; 00000014H
  034da	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  034de	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  034e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  034ea	c6 84 0a a5 0e
	00 00 ff	 mov	 BYTE PTR [edx+ecx+3749], -1

; 1052 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  034f2	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  034f5	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  034fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  034fe	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03502	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  03505	6b c0 14	 imul	 eax, 20			; 00000014H
  03508	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0350c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03512	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03518	c6 84 0a a6 0e
	00 00 ff	 mov	 BYTE PTR [edx+ecx+3750], -1

; 1053 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  03520	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03523	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03529	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0352c	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03530	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  03533	6b c0 14	 imul	 eax, 20			; 00000014H
  03536	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0353a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03540	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03546	c7 84 0a a8 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+3752], 0

; 1054 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  03551	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03554	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0355a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0355d	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03561	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  03564	6b c0 14	 imul	 eax, 20			; 00000014H
  03567	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0356b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03571	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03577	c6 84 0a ac 0e
	00 00 00	 mov	 BYTE PTR [edx+ecx+3756], 0

; 1055 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  0357f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03582	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03588	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0358b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0358f	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  03592	6b c0 14	 imul	 eax, 20			; 00000014H
  03595	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  03599	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0359f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  035a5	c6 84 0a ad 0e
	00 00 00	 mov	 BYTE PTR [edx+ecx+3757], 0
$LN1@ClearChaos:

; 1056 : 		}
; 1057 : 
; 1058 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  035ad	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  035b0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  035b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  035b9	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  035bd	8b 45 f8	 mov	 eax, DWORD PTR _i$237295[ebp]
  035c0	6b c0 14	 imul	 eax, 20			; 00000014H
  035c3	8d 4c 02 3c	 lea	 ecx, DWORD PTR [edx+eax+60]
  035c7	e8 00 00 00 00	 call	 ?Clear@_CHAOSCASTLE_USER@@QAEXXZ ; _CHAOSCASTLE_USER::Clear

; 1059 : 	}

  035cc	e9 bf fe ff ff	 jmp	 $LN3@ClearChaos
$LN6@ClearChaos:

; 1060 : }

  035d1	5f		 pop	 edi
  035d2	5e		 pop	 esi
  035d3	5b		 pop	 ebx
  035d4	8b e5		 mov	 esp, ebp
  035d6	5d		 pop	 ebp
  035d7	c2 04 00	 ret	 4
?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ENDP	; CChaosCastle::ClearChaosCastleData
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.h
;	COMDAT ?Clear@_CHAOSCASTLE_DATA@@QAEXXZ
_TEXT	SEGMENT
_iFALL$221187 = -12					; size = 4
_iMON$221183 = -8					; size = 4
_this$ = -4						; size = 4
?Clear@_CHAOSCASTLE_DATA@@QAEXXZ PROC			; _CHAOSCASTLE_DATA::Clear, COMDAT
; _this$ = ecx

; 207  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		this->m_iMISSION_SUCCESS = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 209  : 		this->m_iCC_NOTIFY_COUNT = -1;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [eax+24], -1

; 210  : 		this->m_bCC_MSG_BEFORE_ENTER = false;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c6 40 1f 00	 mov	 BYTE PTR [eax+31], 0

; 211  : 		this->m_bCC_MSG_BEFORE_PLAY = false;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 212  : 		this->m_bCC_MSG_BEFORE_END = false;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 213  : 		this->m_bCC_MSG_BEFORE_QUIT = false;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c6 40 22 00	 mov	 BYTE PTR [eax+34], 0

; 214  : 		this->m_bCC_CAN_ENTER = false;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c6 40 1c 00	 mov	 BYTE PTR [eax+28], 0

; 215  : 		this->m_bCC_CAN_PARTY = false;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c6 40 1d 00	 mov	 BYTE PTR [eax+29], 0

; 216  : 		this->m_bCC_PLAY_START = false;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c6 40 1e 00	 mov	 BYTE PTR [eax+30], 0

; 217  : 		this->m_iCC_ENTERED_USER = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 218  : 		this->m_iCC_FIRST_USER_COUNT = 0;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 219  : 		this->m_iCC_FIRST_MONSTER_COUNT = 0;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 220  : 		this->m_lCC_CURRENT_MONSTER_COUNT = 0;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 221  : 		this->m_iCC_TRAP_STATUS = 0;

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 222  : 		this->m_iCC_TRAP_OLD_STATUS = 0;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 223  : 
; 224  : 		for ( int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++)

  0008d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMON$221183[ebp], 0
  00094	eb 09		 jmp	 SHORT $LN6@Clear
$LN5@Clear:
  00096	8b 45 f8	 mov	 eax, DWORD PTR _iMON$221183[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 f8	 mov	 DWORD PTR _iMON$221183[ebp], eax
$LN6@Clear:
  0009f	83 7d f8 64	 cmp	 DWORD PTR _iMON$221183[ebp], 100 ; 00000064H
  000a3	7d 13		 jge	 SHORT $LN4@Clear

; 225  : 		{
; 226  : 			this->m_lCC_MONSTER_COUNT[iMON] = -1;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _iMON$221183[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	c7 84 81 b4 05
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+1460], -1

; 227  : 		}

  000b6	eb de		 jmp	 SHORT $LN5@Clear
$LN4@Clear:

; 228  : 
; 229  : 		for ( int iFALL = 0; iFALL < MAX_CHAOSCASTLE_USER ; iFALL ++)

  000b8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iFALL$221187[ebp], 0
  000bf	eb 09		 jmp	 SHORT $LN3@Clear
$LN2@Clear:
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _iFALL$221187[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	89 45 f4	 mov	 DWORD PTR _iFALL$221187[ebp], eax
$LN3@Clear:
  000ca	83 7d f4 46	 cmp	 DWORD PTR _iFALL$221187[ebp], 70 ; 00000046H
  000ce	7d 13		 jge	 SHORT $LN1@Clear

; 230  : 		{
; 231  : 			this->m_lFallUser[iFALL] = -1;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _iFALL$221187[ebp]
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	c7 84 81 44 07
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+1860], -1

; 232  : 		}

  000e1	eb de		 jmp	 SHORT $LN2@Clear
$LN1@Clear:

; 233  : 
; 234  : 		this->m_mapMonsterItemList.clear();

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	81 c1 5c 08 00
	00		 add	 ecx, 2140		; 0000085cH
  000ec	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear

; 235  : 	};	// line : 408

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?Clear@_CHAOSCASTLE_DATA@@QAEXXZ ENDP			; _CHAOSCASTLE_DATA::Clear
_TEXT	ENDS
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.cpp
_TEXT	SEGMENT
tv67 = -76						; size = 4
_n$237305 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ClearMonster@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ClearMonster
; _this$ = ecx

; 1063 : {

  035e0	55		 push	 ebp
  035e1	8b ec		 mov	 ebp, esp
  035e3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  035e6	53		 push	 ebx
  035e7	56		 push	 esi
  035e8	57		 push	 edi
  035e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1064 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  035ec	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  035f0	7d 09		 jge	 SHORT $LN8@ClearMonst
  035f2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  035f9	eb 0c		 jmp	 SHORT $LN9@ClearMonst
$LN8@ClearMonst:
  035fb	33 c0		 xor	 eax, eax
  035fd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03601	0f 9e c0	 setle	 al
  03604	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@ClearMonst:
  03607	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0360b	75 02		 jne	 SHORT $LN5@ClearMonst

; 1065 : 	{
; 1066 : 		return;

  0360d	eb 50		 jmp	 SHORT $LN6@ClearMonst
$LN5@ClearMonst:

; 1067 : 	}
; 1068 : 
; 1069 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0360f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$237305[ebp], 0
  03616	eb 09		 jmp	 SHORT $LN4@ClearMonst
$LN3@ClearMonst:
  03618	8b 45 f8	 mov	 eax, DWORD PTR _n$237305[ebp]
  0361b	83 c0 01	 add	 eax, 1
  0361e	89 45 f8	 mov	 DWORD PTR _n$237305[ebp], eax
$LN4@ClearMonst:
  03621	81 7d f8 c8 32
	00 00		 cmp	 DWORD PTR _n$237305[ebp], 13000 ; 000032c8H
  03628	7d 35		 jge	 SHORT $LN6@ClearMonst

; 1070 : 	{
; 1071 : 		if ( gObj[n].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex))

  0362a	8b 45 f8	 mov	 eax, DWORD PTR _n$237305[ebp]
  0362d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03633	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03639	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  03641	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  03644	52		 push	 edx
  03645	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03648	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  0364d	3b f0		 cmp	 esi, eax
  0364f	75 0c		 jne	 SHORT $LN1@ClearMonst

; 1072 : 		{
; 1073 : 			gObjDel(n);

  03651	8b 45 f8	 mov	 eax, DWORD PTR _n$237305[ebp]
  03654	50		 push	 eax
  03655	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0365a	83 c4 04	 add	 esp, 4
$LN1@ClearMonst:

; 1074 : 		}
; 1075 : 	}

  0365d	eb b9		 jmp	 SHORT $LN3@ClearMonst
$LN6@ClearMonst:

; 1076 : }

  0365f	5f		 pop	 edi
  03660	5e		 pop	 esi
  03661	5b		 pop	 ebx
  03662	8b e5		 mov	 esp, ebp
  03664	5d		 pop	 ebp
  03665	c2 04 00	 ret	 4
?ClearMonster@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ClearMonster
_TEXT	ENDS
PUBLIC	?AddMonsterList@CChaosCastle@@QAEXHH@Z		; CChaosCastle::AddMonsterList
PUBLIC	?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetChaosCastleIndex
EXTRN	_rand:PROC
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv94 = -96						; size = 4
tv67 = -96						; size = 4
_btChaosCastleIndex$237327 = -26			; size = 1
_btMapNumber$237326 = -25				; size = 1
_wMonsterIndex$237325 = -24				; size = 2
_n$237319 = -20						; size = 4
_result$ = -16						; size = 4
_iMAX_ADDABLE_MONSTER_COUNT$ = -12			; size = 4
_iNOW_ADDED_MONSTER_COUNT$ = -8				; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetMonster@CChaosCastle@@QAEHH@Z PROC			; CChaosCastle::SetMonster
; _this$ = ecx

; 1079 : {

  03670	55		 push	 ebp
  03671	8b ec		 mov	 ebp, esp
  03673	83 ec 64	 sub	 esp, 100		; 00000064H
  03676	53		 push	 ebx
  03677	56		 push	 esi
  03678	57		 push	 edi
  03679	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1080 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0367c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  03680	7d 09		 jge	 SHORT $LN12@SetMonster
  03682	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03689	eb 0c		 jmp	 SHORT $LN13@SetMonster
$LN12@SetMonster:
  0368b	33 c0		 xor	 eax, eax
  0368d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03691	0f 9e c0	 setle	 al
  03694	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@SetMonster:
  03697	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0369b	75 0a		 jne	 SHORT $LN9@SetMonster

; 1081 : 	{
; 1082 : 		return -1;

  0369d	b8 ff ff ff ff	 mov	 eax, -1
  036a2	e9 52 03 00 00	 jmp	 $LN10@SetMonster
$LN9@SetMonster:

; 1083 : 	}
; 1084 : 
; 1085 : 	int iNOW_ADDED_MONSTER_COUNT = 0;

  036a7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp], 0

; 1086 : 	int iMAX_ADDABLE_MONSTER_COUNT = MAX_CC_MONSTERS - this->GetCurPlayUser(iChaosCastleIndex);

  036ae	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  036b1	50		 push	 eax
  036b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  036b5	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  036ba	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  036bf	2b c8		 sub	 ecx, eax
  036c1	89 4d f4	 mov	 DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp], ecx

; 1087 : 	int result;
; 1088 : 
; 1089 : 	if ( iMAX_ADDABLE_MONSTER_COUNT < 0 )

  036c4	79 07		 jns	 SHORT $LN8@SetMonster

; 1090 : 	{
; 1091 : 		iMAX_ADDABLE_MONSTER_COUNT = 0;

  036c6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp], 0
$LN8@SetMonster:

; 1092 : 	}
; 1093 : 
; 1094 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  036cd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _n$237319[ebp], 0
  036d4	eb 09		 jmp	 SHORT $LN7@SetMonster
$LN6@SetMonster:
  036d6	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  036d9	83 c0 01	 add	 eax, 1
  036dc	89 45 ec	 mov	 DWORD PTR _n$237319[ebp], eax
$LN7@SetMonster:
  036df	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  036e2	3b 05 84 2c 03
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  036e8	0f 8d 08 03 00
	00		 jge	 $LN5@SetMonster

; 1095 : 	{
; 1096 : 		if ( iNOW_ADDED_MONSTER_COUNT >= iMAX_ADDABLE_MONSTER_COUNT )

  036ee	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  036f1	3b 45 f4	 cmp	 eax, DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp]
  036f4	7c 05		 jl	 SHORT $LN4@SetMonster

; 1097 : 		{
; 1098 : 			break;

  036f6	e9 fb 02 00 00	 jmp	 $LN5@SetMonster
$LN4@SetMonster:

; 1099 : 		}
; 1100 : 
; 1101 : 		if ( CC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE )

  036fb	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  036fe	c1 e0 04	 shl	 eax, 4
  03701	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  03708	83 f9 35	 cmp	 ecx, 53			; 00000035H
  0370b	75 09		 jne	 SHORT $LN16@SetMonster
  0370d	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
  03714	eb 39		 jmp	 SHORT $LN17@SetMonster
$LN16@SetMonster:
  03716	8b 55 ec	 mov	 edx, DWORD PTR _n$237319[ebp]
  03719	c1 e2 04	 shl	 edx, 4
  0371c	0f b6 82 08 00
	00 00		 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edx+8]
  03723	83 f8 12	 cmp	 eax, 18			; 00000012H
  03726	7d 09		 jge	 SHORT $LN14@SetMonster
  03728	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  0372f	eb 18		 jmp	 SHORT $LN15@SetMonster
$LN14@SetMonster:
  03731	8b 4d ec	 mov	 ecx, DWORD PTR _n$237319[ebp]
  03734	c1 e1 04	 shl	 ecx, 4
  03737	0f b6 91 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[ecx+8]
  0373e	33 c0		 xor	 eax, eax
  03740	83 fa 17	 cmp	 edx, 23			; 00000017H
  03743	0f 9e c0	 setle	 al
  03746	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
$LN15@SetMonster:
  03749	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  0374c	89 4d a0	 mov	 DWORD PTR tv94[ebp], ecx
$LN17@SetMonster:
  0374f	83 7d a0 00	 cmp	 DWORD PTR tv94[ebp], 0
  03753	0f 84 98 02 00
	00		 je	 $LN3@SetMonster

; 1102 : 		{
; 1103 : 			WORD wMonsterIndex = gMSetBase.m_Mp[n].m_Type;

  03759	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  0375c	c1 e0 04	 shl	 eax, 4
  0375f	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  03766	66 89 4d e8	 mov	 WORD PTR _wMonsterIndex$237325[ebp], cx

; 1104 : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  0376a	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  0376d	c1 e0 04	 shl	 eax, 4
  03770	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  03776	88 4d e7	 mov	 BYTE PTR _btMapNumber$237326[ebp], cl

; 1105 : 			BYTE btChaosCastleIndex = this->GetChaosCastleIndex(btMapNumber);

  03779	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMapNumber$237326[ebp]
  0377d	50		 push	 eax
  0377e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03781	e8 00 00 00 00	 call	 ?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleIndex
  03786	88 45 e6	 mov	 BYTE PTR _btChaosCastleIndex$237327[ebp], al

; 1106 : 
; 1107 : 			if ( btChaosCastleIndex != iChaosCastleIndex )

  03789	0f b6 45 e6	 movzx	 eax, BYTE PTR _btChaosCastleIndex$237327[ebp]
  0378d	3b 45 08	 cmp	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03790	74 05		 je	 SHORT $LN2@SetMonster

; 1108 : 			{
; 1109 : 				continue;

  03792	e9 3f ff ff ff	 jmp	 $LN6@SetMonster
$LN2@SetMonster:

; 1110 : 			}
; 1111 : 
; 1112 : 			result = gObjAddMonster(btMapNumber);

  03797	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMapNumber$237326[ebp]
  0379b	50		 push	 eax
  0379c	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  037a1	83 c4 04	 add	 esp, 4
  037a4	0f bf c8	 movsx	 ecx, ax
  037a7	89 4d f0	 mov	 DWORD PTR _result$[ebp], ecx

; 1113 : 
; 1114 : 			if ( result >= 0 )

  037aa	83 7d f0 00	 cmp	 DWORD PTR _result$[ebp], 0
  037ae	0f 8c 3d 02 00
	00		 jl	 $LN3@SetMonster

; 1115 : 			{
; 1116 : 				gObj[result].m_PosNum = n;

  037b4	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  037b7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  037bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  037c3	66 8b 55 ec	 mov	 dx, WORD PTR _n$237319[ebp]
  037c7	66 89 94 01 b0
	03 00 00	 mov	 WORD PTR [ecx+eax+944], dx

; 1117 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;

  037cf	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  037d2	c1 e0 04	 shl	 eax, 4
  037d5	66 0f b6 88 0a
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  037dd	8b 55 f0	 mov	 edx, DWORD PTR _result$[ebp]
  037e0	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  037e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  037eb	66 89 8c 10 44
	01 00 00	 mov	 WORD PTR [eax+edx+324], cx

; 1118 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;

  037f3	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  037f6	c1 e0 04	 shl	 eax, 4
  037f9	66 0f b6 88 0b
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+11]
  03801	8b 55 f0	 mov	 edx, DWORD PTR _result$[ebp]
  03804	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0380a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0380f	66 89 8c 10 46
	01 00 00	 mov	 WORD PTR [eax+edx+326], cx

; 1119 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  03817	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  0381a	c1 e0 04	 shl	 eax, 4
  0381d	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  03820	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03826	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0382c	8a 80 08 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  03832	88 84 0a 49 01
	00 00		 mov	 BYTE PTR [edx+ecx+329], al

; 1120 : 				gObj[result].TX = gObj[result].X;

  03839	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  0383c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03842	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  03845	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0384b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03851	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03857	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  0385f	66 89 84 0a 7c
	01 00 00	 mov	 WORD PTR [edx+ecx+380], ax

; 1121 : 				gObj[result].TY = gObj[result].Y;

  03867	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  0386a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03870	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  03873	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03879	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0387f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03885	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  0388d	66 89 84 0a 7e
	01 00 00	 mov	 WORD PTR [edx+ecx+382], ax

; 1122 : 				gObj[result].m_OldX = gObj[result].X;

  03895	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  03898	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0389e	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  038a1	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  038a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  038ad	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  038b3	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  038bb	66 89 84 0a 78
	01 00 00	 mov	 WORD PTR [edx+ecx+376], ax

; 1123 : 				gObj[result].m_OldY = gObj[result].Y;

  038c3	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  038c6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  038cc	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  038cf	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  038d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  038db	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  038e1	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  038e9	66 89 84 0a 7a
	01 00 00	 mov	 WORD PTR [edx+ecx+378], ax

; 1124 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;

  038f1	8b 45 ec	 mov	 eax, DWORD PTR _n$237319[ebp]
  038f4	c1 e0 04	 shl	 eax, 4
  038f7	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  038fa	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03900	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03906	8a 80 0c 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+12]
  0390c	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 1125 : 				gObj[result].StartX = gObj[result].X;

  03913	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  03916	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0391c	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  0391f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03925	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0392b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03931	8a 84 06 44 01
	00 00		 mov	 al, BYTE PTR [esi+eax+324]
  03938	88 84 0a 76 01
	00 00		 mov	 BYTE PTR [edx+ecx+374], al

; 1126 : 				gObj[result].StartY = gObj[result].Y;

  0393f	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  03942	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03948	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  0394b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03951	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03957	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0395d	8a 84 06 46 01
	00 00		 mov	 al, BYTE PTR [esi+eax+326]
  03964	88 84 0a 77 01
	00 00		 mov	 BYTE PTR [edx+ecx+375], al

; 1127 : 				gObjSetMonster(result, wMonsterIndex);

  0396b	0f b7 45 e8	 movzx	 eax, WORD PTR _wMonsterIndex$237325[ebp]
  0396f	50		 push	 eax
  03970	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  03973	51		 push	 ecx
  03974	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  03979	83 c4 08	 add	 esp, 8

; 1128 : 				gObj[result].MaxRegenTime = this->m_iCC_MONSTER_REGEN;

  0397c	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  0397f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03985	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0398b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0398e	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  03991	89 94 01 ac 03
	00 00		 mov	 DWORD PTR [ecx+eax+940], edx

; 1129 : 				gObj[result].m_cChaosCastleIndex = btChaosCastleIndex;

  03998	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  0399b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  039a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  039a7	8a 55 e6	 mov	 dl, BYTE PTR _btChaosCastleIndex$237327[ebp]
  039aa	88 94 01 a5 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3749], dl

; 1130 : 				gObj[result].Dir = rand() % 8;

  039b1	e8 00 00 00 00	 call	 _rand
  039b6	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  039bb	79 05		 jns	 SHORT $LN18@SetMonster
  039bd	48		 dec	 eax
  039be	83 c8 f8	 or	 eax, -8			; fffffff8H
  039c1	40		 inc	 eax
$LN18@SetMonster:
  039c2	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  039c5	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  039cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  039d1	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 1131 : 				iNOW_ADDED_MONSTER_COUNT++;

  039d8	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  039db	83 c0 01	 add	 eax, 1
  039de	89 45 f8	 mov	 DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp], eax

; 1132 : 				this->AddMonsterList(iChaosCastleIndex, result);

  039e1	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  039e4	50		 push	 eax
  039e5	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  039e8	51		 push	 ecx
  039e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  039ec	e8 00 00 00 00	 call	 ?AddMonsterList@CChaosCastle@@QAEXHH@Z ; CChaosCastle::AddMonsterList
$LN3@SetMonster:

; 1133 : 			}
; 1134 : 		}
; 1135 : 	}

  039f1	e9 e0 fc ff ff	 jmp	 $LN6@SetMonster
$LN5@SetMonster:

; 1136 : 
; 1137 : 	return iNOW_ADDED_MONSTER_COUNT;

  039f6	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
$LN10@SetMonster:

; 1138 : }

  039f9	5f		 pop	 edi
  039fa	5e		 pop	 esi
  039fb	5b		 pop	 ebx
  039fc	8b e5		 mov	 esp, ebp
  039fe	5d		 pop	 ebp
  039ff	c2 04 00	 ret	 4
?SetMonster@CChaosCastle@@QAEHH@Z ENDP			; CChaosCastle::SetMonster
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -76						; size = 4
_iMON$237336 = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
?AddMonsterList@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::AddMonsterList
; _this$ = ecx

; 1141 : {

  03a10	55		 push	 ebp
  03a11	8b ec		 mov	 ebp, esp
  03a13	83 ec 4c	 sub	 esp, 76			; 0000004cH
  03a16	53		 push	 ebx
  03a17	56		 push	 esi
  03a18	57		 push	 edi
  03a19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1142 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  03a1c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  03a20	7d 09		 jge	 SHORT $LN8@AddMonster
  03a22	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03a29	eb 0c		 jmp	 SHORT $LN9@AddMonster
$LN8@AddMonster:
  03a2b	33 c0		 xor	 eax, eax
  03a2d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03a31	0f 9e c0	 setle	 al
  03a34	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@AddMonster:
  03a37	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  03a3b	75 02		 jne	 SHORT $LN5@AddMonster

; 1143 : 	{
; 1144 : 		return;

  03a3d	eb 5e		 jmp	 SHORT $LN6@AddMonster
$LN5@AddMonster:

; 1145 : 	}
; 1146 : 
; 1147 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  03a3f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMON$237336[ebp], 0
  03a46	eb 09		 jmp	 SHORT $LN4@AddMonster
$LN3@AddMonster:
  03a48	8b 45 f8	 mov	 eax, DWORD PTR _iMON$237336[ebp]
  03a4b	83 c0 01	 add	 eax, 1
  03a4e	89 45 f8	 mov	 DWORD PTR _iMON$237336[ebp], eax
$LN4@AddMonster:
  03a51	83 7d f8 64	 cmp	 DWORD PTR _iMON$237336[ebp], 100 ; 00000064H
  03a55	7d 46		 jge	 SHORT $LN6@AddMonster

; 1148 : 	{
; 1149 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  03a57	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03a5a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03a60	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03a63	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03a67	8b 45 f8	 mov	 eax, DWORD PTR _iMON$237336[ebp]
  03a6a	83 bc 82 b4 05
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1460], -1
  03a72	75 27		 jne	 SHORT $LN1@AddMonster

; 1150 : 		{
; 1151 : 			InterlockedExchange((LPLONG)&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON], iMonsterIndex);

  03a74	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  03a77	50		 push	 eax
  03a78	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  03a7b	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  03a81	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03a84	8d 44 0a 30	 lea	 eax, DWORD PTR [edx+ecx+48]
  03a88	8b 4d f8	 mov	 ecx, DWORD PTR _iMON$237336[ebp]
  03a8b	8d 94 88 b4 05
	00 00		 lea	 edx, DWORD PTR [eax+ecx*4+1460]
  03a92	52		 push	 edx
  03a93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 1152 : 			break;

  03a99	eb 02		 jmp	 SHORT $LN6@AddMonster
$LN1@AddMonster:

; 1153 : 		}
; 1154 : 	}

  03a9b	eb ab		 jmp	 SHORT $LN3@AddMonster
$LN6@AddMonster:

; 1155 : }

  03a9d	5f		 pop	 edi
  03a9e	5e		 pop	 esi
  03a9f	5b		 pop	 ebx
  03aa0	8b e5		 mov	 esp, ebp
  03aa2	5d		 pop	 ebp
  03aa3	c2 08 00	 ret	 8
?AddMonsterList@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::AddMonsterList
_TEXT	ENDS
PUBLIC	??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ ; `string'
PUBLIC	??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ ; `string'
PUBLIC	?DelMonsterList@CChaosCastle@@QAEXHH@Z		; CChaosCastle::DelMonsterList
EXTRN	__imp__InterlockedDecrement@4:PROC
;	COMDAT ??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
CONST	SEGMENT
??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ DB '['
	DB	'Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : OUT - '
	DB	'Index(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
CONST	SEGMENT
??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ DB '['
	DB	'Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : ENTER '
	DB	'- Index(%d)', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -76						; size = 4
_iMON$237349 = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
?DelMonsterList@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::DelMonsterList
; _this$ = ecx

; 1158 : {

  03ab0	55		 push	 ebp
  03ab1	8b ec		 mov	 ebp, esp
  03ab3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  03ab6	53		 push	 ebx
  03ab7	56		 push	 esi
  03ab8	57		 push	 edi
  03ab9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1159 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  03abc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  03ac0	7d 09		 jge	 SHORT $LN9@DelMonster
  03ac2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03ac9	eb 0c		 jmp	 SHORT $LN10@DelMonster
$LN9@DelMonster:
  03acb	33 c0		 xor	 eax, eax
  03acd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03ad1	0f 9e c0	 setle	 al
  03ad4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@DelMonster:
  03ad7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  03adb	75 05		 jne	 SHORT $LN6@DelMonster

; 1160 : 	{
; 1161 : 		return;

  03add	e9 f0 00 00 00	 jmp	 $LN7@DelMonster
$LN6@DelMonster:

; 1162 : 	}
; 1163 : 
; 1164 : 	LogAddTD("[Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : ENTER - Index(%d)",
; 1165 : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT, iMonsterIndex);

  03ae2	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  03ae5	50		 push	 eax
  03ae6	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  03ae9	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  03aef	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03af2	8b 44 0a 60	 mov	 eax, DWORD PTR [edx+ecx+96]
  03af6	50		 push	 eax
  03af7	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  03afa	83 c1 01	 add	 ecx, 1
  03afd	51		 push	 ecx
  03afe	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
  03b03	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03b09	83 c4 10	 add	 esp, 16			; 00000010H

; 1166 : 
; 1167 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  03b0c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMON$237349[ebp], 0
  03b13	eb 09		 jmp	 SHORT $LN5@DelMonster
$LN4@DelMonster:
  03b15	8b 45 f8	 mov	 eax, DWORD PTR _iMON$237349[ebp]
  03b18	83 c0 01	 add	 eax, 1
  03b1b	89 45 f8	 mov	 DWORD PTR _iMON$237349[ebp], eax
$LN5@DelMonster:
  03b1e	83 7d f8 64	 cmp	 DWORD PTR _iMON$237349[ebp], 100 ; 00000064H
  03b22	7d 46		 jge	 SHORT $LN3@DelMonster

; 1168 : 	{
; 1169 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == iMonsterIndex )

  03b24	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03b27	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03b2d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03b30	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03b34	8b 45 f8	 mov	 eax, DWORD PTR _iMON$237349[ebp]
  03b37	8b 8c 82 b4 05
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+1460]
  03b3e	3b 4d 0c	 cmp	 ecx, DWORD PTR _iMonsterIndex$[ebp]
  03b41	75 25		 jne	 SHORT $LN2@DelMonster

; 1170 : 		{
; 1171 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON], -1);

  03b43	6a ff		 push	 -1
  03b45	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03b48	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03b4e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03b51	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03b55	8b 45 f8	 mov	 eax, DWORD PTR _iMON$237349[ebp]
  03b58	8d 8c 82 b4 05
	00 00		 lea	 ecx, DWORD PTR [edx+eax*4+1460]
  03b5f	51		 push	 ecx
  03b60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 1172 : 			break;

  03b66	eb 02		 jmp	 SHORT $LN3@DelMonster
$LN2@DelMonster:

; 1173 : 		}
; 1174 : 	}

  03b68	eb ab		 jmp	 SHORT $LN4@DelMonster
$LN3@DelMonster:

; 1175 : 
; 1176 : 	InterlockedDecrement(&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  03b6a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03b6d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03b73	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03b76	8d 54 01 60	 lea	 edx, DWORD PTR [ecx+eax+96]
  03b7a	52		 push	 edx
  03b7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 1177 : 
; 1178 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT < 0 )

  03b81	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03b84	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03b8a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03b8d	83 7c 01 60 00	 cmp	 DWORD PTR [ecx+eax+96], 0
  03b92	7d 14		 jge	 SHORT $LN1@DelMonster

; 1179 : 	{
; 1180 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT = 0;

  03b94	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03b97	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03b9d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03ba0	c7 44 01 60 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+96], 0
$LN1@DelMonster:

; 1181 : 	}
; 1182 : 
; 1183 : 	LogAddTD("[Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : OUT - Index(%d)",
; 1184 : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT, iMonsterIndex);

  03ba8	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  03bab	50		 push	 eax
  03bac	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  03baf	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  03bb5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03bb8	8b 44 0a 60	 mov	 eax, DWORD PTR [edx+ecx+96]
  03bbc	50		 push	 eax
  03bbd	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  03bc0	83 c1 01	 add	 ecx, 1
  03bc3	51		 push	 ecx
  03bc4	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
  03bc9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03bcf	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@DelMonster:

; 1185 : }

  03bd2	5f		 pop	 edi
  03bd3	5e		 pop	 esi
  03bd4	5b		 pop	 ebx
  03bd5	8b e5		 mov	 esp, ebp
  03bd7	5d		 pop	 ebp
  03bd8	c2 08 00	 ret	 8
?DelMonsterList@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::DelMonsterList
; Function compile flags: /Odtp /ZI
tv148 = -88						; size = 4
tv149 = -84						; size = 4
tv87 = -84						; size = 4
tv67 = -84						; size = 4
_CC_MONSTER_COUNT$237367 = -16				; size = 4
_i$237362 = -12						; size = 4
_iAliveMonsterCount$ = -8				; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetMonsterListCount@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetMonsterListCount
; _this$ = ecx

; 1188 : {

  03be0	55		 push	 ebp
  03be1	8b ec		 mov	 ebp, esp
  03be3	83 ec 58	 sub	 esp, 88			; 00000058H
  03be6	53		 push	 ebx
  03be7	56		 push	 esi
  03be8	57		 push	 edi
  03be9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1189 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  03bec	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  03bf0	7d 09		 jge	 SHORT $LN12@GetMonster
  03bf2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03bf9	eb 0c		 jmp	 SHORT $LN13@GetMonster
$LN12@GetMonster:
  03bfb	33 c0		 xor	 eax, eax
  03bfd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03c01	0f 9e c0	 setle	 al
  03c04	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN13@GetMonster:
  03c07	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  03c0b	75 0a		 jne	 SHORT $LN9@GetMonster

; 1190 : 	{
; 1191 : 		return -1;

  03c0d	b8 ff ff ff ff	 mov	 eax, -1
  03c12	e9 6c 01 00 00	 jmp	 $LN10@GetMonster
$LN9@GetMonster:

; 1192 : 	}
; 1193 : 
; 1194 : 	int iAliveMonsterCount = 0;

  03c17	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iAliveMonsterCount$[ebp], 0

; 1195 : 
; 1196 : 	for ( int i=0;i<MAX_CHAOSCASTLE_MONSTER;i++) //loc3

  03c1e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$237362[ebp], 0
  03c25	eb 09		 jmp	 SHORT $LN8@GetMonster
$LN7@GetMonster:
  03c27	8b 45 f4	 mov	 eax, DWORD PTR _i$237362[ebp]
  03c2a	83 c0 01	 add	 eax, 1
  03c2d	89 45 f4	 mov	 DWORD PTR _i$237362[ebp], eax
$LN8@GetMonster:
  03c30	83 7d f4 64	 cmp	 DWORD PTR _i$237362[ebp], 100 ; 00000064H
  03c34	0f 8d 46 01 00
	00		 jge	 $LN6@GetMonster

; 1197 : 	{
; 1198 : 		if(this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] == -1)

  03c3a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03c3d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03c43	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03c46	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03c4a	8b 45 f4	 mov	 eax, DWORD PTR _i$237362[ebp]
  03c4d	83 bc 82 b4 05
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1460], -1
  03c55	75 02		 jne	 SHORT $LN5@GetMonster

; 1199 : 		{
; 1200 : 			continue;

  03c57	eb ce		 jmp	 SHORT $LN7@GetMonster
$LN5@GetMonster:

; 1201 : 		}
; 1202 : 
; 1203 : 		int CC_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i]; //loc4

  03c59	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03c5c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03c62	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03c65	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03c69	8b 45 f4	 mov	 eax, DWORD PTR _i$237362[ebp]
  03c6c	8b 8c 82 b4 05
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+1460]
  03c73	89 4d f0	 mov	 DWORD PTR _CC_MONSTER_COUNT$237367[ebp], ecx

; 1204 : 					
; 1205 : 		if ( ((CC_MONSTER_COUNT<0)?FALSE:(CC_MONSTER_COUNT>OBJ_MAXMONSTER-1)?FALSE:TRUE) == FALSE ) 

  03c76	83 7d f0 00	 cmp	 DWORD PTR _CC_MONSTER_COUNT$237367[ebp], 0
  03c7a	7d 09		 jge	 SHORT $LN14@GetMonster
  03c7c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  03c83	eb 0f		 jmp	 SHORT $LN15@GetMonster
$LN14@GetMonster:
  03c85	33 c0		 xor	 eax, eax
  03c87	81 7d f0 c7 32
	00 00		 cmp	 DWORD PTR _CC_MONSTER_COUNT$237367[ebp], 12999 ; 000032c7H
  03c8e	0f 9e c0	 setle	 al
  03c91	89 45 ac	 mov	 DWORD PTR tv87[ebp], eax
$LN15@GetMonster:
  03c94	83 7d ac 00	 cmp	 DWORD PTR tv87[ebp], 0
  03c98	75 23		 jne	 SHORT $LN4@GetMonster

; 1206 : 		{
; 1207 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] = -1;

  03c9a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03c9d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03ca3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03ca6	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  03caa	8b 45 f4	 mov	 eax, DWORD PTR _i$237362[ebp]
  03cad	c7 84 82 b4 05
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax*4+1460], -1

; 1208 : 			continue;

  03cb8	e9 6a ff ff ff	 jmp	 $LN7@GetMonster
$LN4@GetMonster:

; 1209 : 		}
; 1210 : 
; 1211 : 		if(gObj[CC_MONSTER_COUNT].Life > 0.0f)

  03cbd	8b 45 f0	 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$237367[ebp]
  03cc0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03cc6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03ccc	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  03cd3	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  03cd9	df e0		 fnstsw	 ax
  03cdb	f6 c4 41	 test	 ah, 65			; 00000041H
  03cde	0f 85 97 00 00
	00		 jne	 $LN1@GetMonster

; 1212 : 		{
; 1213 : 			if(CC_MAP_RANGE(gObj[CC_MONSTER_COUNT].MapNumber) != FALSE)

  03ce4	8b 45 f0	 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$237367[ebp]
  03ce7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03ced	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03cf3	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03cfb	83 fa 35	 cmp	 edx, 53			; 00000035H
  03cfe	75 09		 jne	 SHORT $LN18@GetMonster
  03d00	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv149[ebp], 1
  03d07	eb 4d		 jmp	 SHORT $LN19@GetMonster
$LN18@GetMonster:
  03d09	8b 45 f0	 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$237367[ebp]
  03d0c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03d12	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03d18	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03d20	83 fa 12	 cmp	 edx, 18			; 00000012H
  03d23	7d 09		 jge	 SHORT $LN16@GetMonster
  03d25	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv148[ebp], 0
  03d2c	eb 22		 jmp	 SHORT $LN17@GetMonster
$LN16@GetMonster:
  03d2e	8b 45 f0	 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$237367[ebp]
  03d31	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03d37	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03d3d	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03d45	33 c0		 xor	 eax, eax
  03d47	83 fa 17	 cmp	 edx, 23			; 00000017H
  03d4a	0f 9e c0	 setle	 al
  03d4d	89 45 a8	 mov	 DWORD PTR tv148[ebp], eax
$LN17@GetMonster:
  03d50	8b 4d a8	 mov	 ecx, DWORD PTR tv148[ebp]
  03d53	89 4d ac	 mov	 DWORD PTR tv149[ebp], ecx
$LN19@GetMonster:
  03d56	83 7d ac 00	 cmp	 DWORD PTR tv149[ebp], 0
  03d5a	74 1f		 je	 SHORT $LN1@GetMonster

; 1214 : 			{
; 1215 : 				if(gObj[CC_MONSTER_COUNT].Connected > 0)

  03d5c	8b 45 f0	 mov	 eax, DWORD PTR _CC_MONSTER_COUNT$237367[ebp]
  03d5f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03d65	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03d6b	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  03d70	7e 09		 jle	 SHORT $LN1@GetMonster

; 1216 : 				{
; 1217 : 					iAliveMonsterCount++;

  03d72	8b 45 f8	 mov	 eax, DWORD PTR _iAliveMonsterCount$[ebp]
  03d75	83 c0 01	 add	 eax, 1
  03d78	89 45 f8	 mov	 DWORD PTR _iAliveMonsterCount$[ebp], eax
$LN1@GetMonster:

; 1218 : 				}
; 1219 : 			}
; 1220 : 		}
; 1221 : 	}

  03d7b	e9 a7 fe ff ff	 jmp	 $LN7@GetMonster
$LN6@GetMonster:

; 1222 : 	
; 1223 : 	return iAliveMonsterCount;

  03d80	8b 45 f8	 mov	 eax, DWORD PTR _iAliveMonsterCount$[ebp]
$LN10@GetMonster:

; 1224 : }

  03d83	5f		 pop	 edi
  03d84	5e		 pop	 esi
  03d85	5b		 pop	 ebx
  03d86	8b e5		 mov	 esp, ebp
  03d88	5d		 pop	 ebp
  03d89	c2 04 00	 ret	 4
?GetMonsterListCount@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetMonsterListCount
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >
PUBLIC	??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
PUBLIC	??0_MONSTER_ITEM_DROP@@QAE@XZ			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
EXTRN	?gNewServer@@3HA:DWORD				; gNewServer
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -176						; size = 4
$T242105 = -172						; size = 4
$T242106 = -168						; size = 4
$T242107 = -164						; size = 12
$T242108 = -152						; size = 8
$T242109 = -144						; size = 4
$T242110 = -140						; size = 4
$T242111 = -136						; size = 12
$T242112 = -124						; size = 8
_iMONSTER_INDEX$238026 = -52				; size = 4
_iC$238022 = -48					; size = 4
_iB$238018 = -44					; size = 4
_iA$238014 = -40					; size = 4
_iMONSTER_INDEX$237543 = -36				; size = 4
_iC$237539 = -32					; size = 4
_iB$237535 = -28					; size = 4
_iA$237531 = -24					; size = 4
_MID$ = -20						; size = 8
_it$ = -12						; size = 4
_iMAX_MONSTER$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetItemsToMonster@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SetItemsToMonster
; _this$ = ecx

; 1227 : {

  03d90	55		 push	 ebp
  03d91	8b ec		 mov	 ebp, esp
  03d93	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  03d99	53		 push	 ebx
  03d9a	56		 push	 esi
  03d9b	57		 push	 edi
  03d9c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1228 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  03d9f	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  03da3	7d 0c		 jge	 SHORT $LN27@SetItemsTo
  03da5	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  03daf	eb 0f		 jmp	 SHORT $LN28@SetItemsTo
$LN27@SetItemsTo:
  03db1	33 c0		 xor	 eax, eax
  03db3	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  03db7	0f 9e c0	 setle	 al
  03dba	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN28@SetItemsTo:
  03dc0	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  03dc7	75 05		 jne	 SHORT $LN24@SetItemsTo

; 1229 : 	{
; 1230 : 		return;

  03dc9	e9 b3 02 00 00	 jmp	 $LN25@SetItemsTo
$LN24@SetItemsTo:

; 1231 : 	}
; 1232 : 
; 1233 : 	int iMAX_MONSTER = this->GetMonsterListCount(iChaosCastleIndex);

  03dce	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03dd1	50		 push	 eax
  03dd2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03dd5	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  03dda	89 45 f8	 mov	 DWORD PTR _iMAX_MONSTER$[ebp], eax

; 1234 : 
; 1235 : 	if ( iMAX_MONSTER <= 0 )

  03ddd	83 7d f8 00	 cmp	 DWORD PTR _iMAX_MONSTER$[ebp], 0
  03de1	7f 05		 jg	 SHORT $LN23@SetItemsTo

; 1236 : 	{
; 1237 : 		return;

  03de3	e9 99 02 00 00	 jmp	 $LN25@SetItemsTo
$LN23@SetItemsTo:

; 1238 : 	}
; 1239 : 
; 1240 : 	std::map<int, _MONSTER_ITEM_DROP>::iterator it;

  03de8	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  03deb	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >

; 1241 : 	_MONSTER_ITEM_DROP MID;

  03df0	8d 4d ec	 lea	 ecx, DWORD PTR _MID$[ebp]
  03df3	e8 00 00 00 00	 call	 ??0_MONSTER_ITEM_DROP@@QAE@XZ ; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP

; 1242 : 
; 1243 : 	if(gNewServer == TRUE) //season4.5 add-on

  03df8	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gNewServer@@3HA, 1 ; gNewServer
  03dff	0f 85 42 01 00
	00		 jne	 $LN22@SetItemsTo

; 1244 : 	{
; 1245 : 		for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  03e05	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iA$237531[ebp], 0
  03e0c	eb 09		 jmp	 SHORT $LN21@SetItemsTo
$LN20@SetItemsTo:
  03e0e	8b 45 e8	 mov	 eax, DWORD PTR _iA$237531[ebp]
  03e11	83 c0 01	 add	 eax, 1
  03e14	89 45 e8	 mov	 DWORD PTR _iA$237531[ebp], eax
$LN21@SetItemsTo:
  03e17	83 7d e8 02	 cmp	 DWORD PTR _iA$237531[ebp], 2
  03e1b	0f 8d 21 01 00
	00		 jge	 $LN19@SetItemsTo

; 1246 : 		{
; 1247 : 			for ( int iB=0; iB< ::g_iChaosCastle_MonsterItemsNewServer[iChaosCastleIndex][iA][1] ; iB++)

  03e21	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iB$237535[ebp], 0
  03e28	eb 09		 jmp	 SHORT $LN18@SetItemsTo
$LN17@SetItemsTo:
  03e2a	8b 45 e4	 mov	 eax, DWORD PTR _iB$237535[ebp]
  03e2d	83 c0 01	 add	 eax, 1
  03e30	89 45 e4	 mov	 DWORD PTR _iB$237535[ebp], eax
$LN18@SetItemsTo:
  03e33	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03e36	c1 e0 04	 shl	 eax, 4
  03e39	8b 4d e8	 mov	 ecx, DWORD PTR _iA$237531[ebp]
  03e3c	8b 55 e4	 mov	 edx, DWORD PTR _iB$237535[ebp]
  03e3f	3b 94 c8 04 00
	00 00		 cmp	 edx, DWORD PTR _g_iChaosCastle_MonsterItemsNewServer[eax+ecx*8+4]
  03e46	0f 8d f1 00 00
	00		 jge	 $LN16@SetItemsTo

; 1248 : 			{
; 1249 : 				for ( int iC=0;iC<200;iC++)

  03e4c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iC$237539[ebp], 0
  03e53	eb 09		 jmp	 SHORT $LN15@SetItemsTo
$LN14@SetItemsTo:
  03e55	8b 45 e0	 mov	 eax, DWORD PTR _iC$237539[ebp]
  03e58	83 c0 01	 add	 eax, 1
  03e5b	89 45 e0	 mov	 DWORD PTR _iC$237539[ebp], eax
$LN15@SetItemsTo:
  03e5e	81 7d e0 c8 00
	00 00		 cmp	 DWORD PTR _iC$237539[ebp], 200 ; 000000c8H
  03e65	0f 8d cd 00 00
	00		 jge	 $LN13@SetItemsTo

; 1250 : 				{
; 1251 : 					int iMONSTER_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[rand() % iMAX_MONSTER];

  03e6b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03e6e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03e74	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03e77	8d 74 01 30	 lea	 esi, DWORD PTR [ecx+eax+48]
  03e7b	e8 00 00 00 00	 call	 _rand
  03e80	99		 cdq
  03e81	f7 7d f8	 idiv	 DWORD PTR _iMAX_MONSTER$[ebp]
  03e84	8b 94 96 b4 05
	00 00		 mov	 edx, DWORD PTR [esi+edx*4+1460]
  03e8b	89 55 dc	 mov	 DWORD PTR _iMONSTER_INDEX$237543[ebp], edx

; 1252 : 					it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMONSTER_INDEX);

  03e8e	8d 45 dc	 lea	 eax, DWORD PTR _iMONSTER_INDEX$237543[ebp]
  03e91	50		 push	 eax
  03e92	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T242105[ebp]
  03e98	51		 push	 ecx
  03e99	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  03e9c	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  03ea2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03ea5	8d 8c 10 8c 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2188]
  03eac	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
  03eb1	8b 08		 mov	 ecx, DWORD PTR [eax]
  03eb3	89 4d f4	 mov	 DWORD PTR _it$[ebp], ecx

; 1253 : 
; 1254 : 					if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  03eb6	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T242106[ebp]
  03ebc	50		 push	 eax
  03ebd	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  03ec0	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  03ec6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03ec9	8d 8c 0a 8c 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+2188]
  03ed0	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  03ed5	50		 push	 eax
  03ed6	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  03ed9	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  03ede	0f b6 c0	 movzx	 eax, al
  03ee1	85 c0		 test	 eax, eax
  03ee3	74 4e		 je	 SHORT $LN12@SetItemsTo

; 1255 : 					{
; 1256 : 						MID.m_iIndex = iMONSTER_INDEX;

  03ee5	8b 45 dc	 mov	 eax, DWORD PTR _iMONSTER_INDEX$237543[ebp]
  03ee8	89 45 ec	 mov	 DWORD PTR _MID$[ebp], eax

; 1257 : 						MID.m_iItemKind = ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][0];

  03eeb	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03eee	c1 e0 04	 shl	 eax, 4
  03ef1	8b 4d e8	 mov	 ecx, DWORD PTR _iA$237531[ebp]
  03ef4	8b 94 c8 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_MonsterItems[eax+ecx*8]
  03efb	89 55 f0	 mov	 DWORD PTR _MID$[ebp+4], edx

; 1258 : 						this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.insert( std::pair<int,_MONSTER_ITEM_DROP>(iMONSTER_INDEX, MID) );

  03efe	8d 45 ec	 lea	 eax, DWORD PTR _MID$[ebp]
  03f01	50		 push	 eax
  03f02	8d 4d dc	 lea	 ecx, DWORD PTR _iMONSTER_INDEX$237543[ebp]
  03f05	51		 push	 ecx
  03f06	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T242107[ebp]
  03f0c	e8 00 00 00 00	 call	 ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
  03f11	50		 push	 eax
  03f12	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T242108[ebp]
  03f18	52		 push	 edx
  03f19	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03f1c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03f22	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03f25	8d 8c 01 8c 08
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+2188]
  03f2c	e8 00 00 00 00	 call	 ??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >

; 1259 : 						break;

  03f31	eb 05		 jmp	 SHORT $LN13@SetItemsTo
$LN12@SetItemsTo:

; 1260 : 					}
; 1261 : 				}

  03f33	e9 1d ff ff ff	 jmp	 $LN14@SetItemsTo
$LN13@SetItemsTo:

; 1262 : 			}

  03f38	e9 ed fe ff ff	 jmp	 $LN17@SetItemsTo
$LN16@SetItemsTo:

; 1263 : 		}

  03f3d	e9 cc fe ff ff	 jmp	 $LN20@SetItemsTo
$LN19@SetItemsTo:

; 1264 : 	}
; 1265 : 	else

  03f42	e9 3a 01 00 00	 jmp	 $LN25@SetItemsTo
$LN22@SetItemsTo:

; 1266 : 	{
; 1267 : 		for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  03f47	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _iA$238014[ebp], 0
  03f4e	eb 09		 jmp	 SHORT $LN10@SetItemsTo
$LN9@SetItemsTo:
  03f50	8b 45 d8	 mov	 eax, DWORD PTR _iA$238014[ebp]
  03f53	83 c0 01	 add	 eax, 1
  03f56	89 45 d8	 mov	 DWORD PTR _iA$238014[ebp], eax
$LN10@SetItemsTo:
  03f59	83 7d d8 02	 cmp	 DWORD PTR _iA$238014[ebp], 2
  03f5d	0f 8d 1e 01 00
	00		 jge	 $LN25@SetItemsTo

; 1268 : 		{
; 1269 : 			for ( int iB=0; iB< ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][1] ; iB++)

  03f63	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iB$238018[ebp], 0
  03f6a	eb 09		 jmp	 SHORT $LN7@SetItemsTo
$LN6@SetItemsTo:
  03f6c	8b 45 d4	 mov	 eax, DWORD PTR _iB$238018[ebp]
  03f6f	83 c0 01	 add	 eax, 1
  03f72	89 45 d4	 mov	 DWORD PTR _iB$238018[ebp], eax
$LN7@SetItemsTo:
  03f75	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03f78	c1 e0 04	 shl	 eax, 4
  03f7b	8b 4d d8	 mov	 ecx, DWORD PTR _iA$238014[ebp]
  03f7e	8b 55 d4	 mov	 edx, DWORD PTR _iB$238018[ebp]
  03f81	3b 94 c8 04 00
	00 00		 cmp	 edx, DWORD PTR _g_iChaosCastle_MonsterItems[eax+ecx*8+4]
  03f88	0f 8d ee 00 00
	00		 jge	 $LN5@SetItemsTo

; 1270 : 			{
; 1271 : 				for ( int iC=0;iC<200;iC++)

  03f8e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _iC$238022[ebp], 0
  03f95	eb 09		 jmp	 SHORT $LN4@SetItemsTo
$LN3@SetItemsTo:
  03f97	8b 45 d0	 mov	 eax, DWORD PTR _iC$238022[ebp]
  03f9a	83 c0 01	 add	 eax, 1
  03f9d	89 45 d0	 mov	 DWORD PTR _iC$238022[ebp], eax
$LN4@SetItemsTo:
  03fa0	81 7d d0 c8 00
	00 00		 cmp	 DWORD PTR _iC$238022[ebp], 200 ; 000000c8H
  03fa7	0f 8d ca 00 00
	00		 jge	 $LN2@SetItemsTo

; 1272 : 				{
; 1273 : 					int iMONSTER_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[rand() % iMAX_MONSTER];

  03fad	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  03fb0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  03fb6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03fb9	8d 74 01 30	 lea	 esi, DWORD PTR [ecx+eax+48]
  03fbd	e8 00 00 00 00	 call	 _rand
  03fc2	99		 cdq
  03fc3	f7 7d f8	 idiv	 DWORD PTR _iMAX_MONSTER$[ebp]
  03fc6	8b 94 96 b4 05
	00 00		 mov	 edx, DWORD PTR [esi+edx*4+1460]
  03fcd	89 55 cc	 mov	 DWORD PTR _iMONSTER_INDEX$238026[ebp], edx

; 1274 : 					it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMONSTER_INDEX);

  03fd0	8d 45 cc	 lea	 eax, DWORD PTR _iMONSTER_INDEX$238026[ebp]
  03fd3	50		 push	 eax
  03fd4	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T242109[ebp]
  03fda	51		 push	 ecx
  03fdb	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  03fde	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  03fe4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03fe7	8d 8c 10 8c 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2188]
  03fee	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
  03ff3	8b 08		 mov	 ecx, DWORD PTR [eax]
  03ff5	89 4d f4	 mov	 DWORD PTR _it$[ebp], ecx

; 1275 : 
; 1276 : 					if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  03ff8	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T242110[ebp]
  03ffe	50		 push	 eax
  03fff	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  04002	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  04008	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0400b	8d 8c 0a 8c 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+2188]
  04012	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  04017	50		 push	 eax
  04018	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0401b	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  04020	0f b6 c0	 movzx	 eax, al
  04023	85 c0		 test	 eax, eax
  04025	74 4b		 je	 SHORT $LN1@SetItemsTo

; 1277 : 					{
; 1278 : 						MID.m_iIndex = iMONSTER_INDEX;

  04027	8b 45 cc	 mov	 eax, DWORD PTR _iMONSTER_INDEX$238026[ebp]
  0402a	89 45 ec	 mov	 DWORD PTR _MID$[ebp], eax

; 1279 : 						MID.m_iItemKind = ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][0];

  0402d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04030	c1 e0 04	 shl	 eax, 4
  04033	8b 4d d8	 mov	 ecx, DWORD PTR _iA$238014[ebp]
  04036	8b 94 c8 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_MonsterItems[eax+ecx*8]
  0403d	89 55 f0	 mov	 DWORD PTR _MID$[ebp+4], edx

; 1280 : 						this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.insert( std::pair<int,_MONSTER_ITEM_DROP>(iMONSTER_INDEX, MID) );

  04040	8d 45 ec	 lea	 eax, DWORD PTR _MID$[ebp]
  04043	50		 push	 eax
  04044	8d 4d cc	 lea	 ecx, DWORD PTR _iMONSTER_INDEX$238026[ebp]
  04047	51		 push	 ecx
  04048	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T242111[ebp]
  0404e	e8 00 00 00 00	 call	 ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
  04053	50		 push	 eax
  04054	8d 55 84	 lea	 edx, DWORD PTR $T242112[ebp]
  04057	52		 push	 edx
  04058	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0405b	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04064	8d 8c 01 8c 08
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+2188]
  0406b	e8 00 00 00 00	 call	 ??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >

; 1281 : 						break;

  04070	eb 05		 jmp	 SHORT $LN2@SetItemsTo
$LN1@SetItemsTo:

; 1282 : 					}
; 1283 : 				}

  04072	e9 20 ff ff ff	 jmp	 $LN3@SetItemsTo
$LN2@SetItemsTo:

; 1284 : 			}

  04077	e9 f0 fe ff ff	 jmp	 $LN6@SetItemsTo
$LN5@SetItemsTo:

; 1285 : 		}

  0407c	e9 cf fe ff ff	 jmp	 $LN9@SetItemsTo
$LN25@SetItemsTo:

; 1286 : 	}
; 1287 : }

  04081	5f		 pop	 edi
  04082	5e		 pop	 esi
  04083	5b		 pop	 ebx
  04084	8b e5		 mov	 esp, ebp
  04086	5d		 pop	 ebp
  04087	c2 04 00	 ret	 4
?SetItemsToMonster@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SetItemsToMonster
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.h
_TEXT	ENDS
;	COMDAT ??0_MONSTER_ITEM_DROP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_MONSTER_ITEM_DROP@@QAE@XZ PROC			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP, COMDAT
; _this$ = ecx

; 141  : 	_MONSTER_ITEM_DROP()	// line : 229

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 142  : 	{
; 143  : 		this->m_iIndex = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 144  : 		this->m_iItemKind = -1;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 145  : 	};	// line : 232

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0_MONSTER_ITEM_DROP@@QAE@XZ ENDP			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP
_TEXT	ENDS
PUBLIC	??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@ ; `string'
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
PUBLIC	?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z	; CChaosCastle::SearchNDropMonsterItem
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
;	COMDAT ??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.cpp
CONST	SEGMENT
??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@ DB '['
	DB	'Chaos Castle] (%d) Monster Dropped ChaosCastle Item To [%s][%'
	DB	's] (Item:%s)', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv184 = -96						; size = 4
tv77 = -96						; size = 4
tv72 = -96						; size = 4
tv67 = -96						; size = 4
$T242122 = -92						; size = 4
_iLevel$ = -24						; size = 4
_iType$ = -20						; size = 4
_MID$ = -16						; size = 8
_it$ = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
_iMaxHitUserIndex$ = 16					; size = 4
?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z PROC	; CChaosCastle::SearchNDropMonsterItem
; _this$ = ecx

; 1290 : {

  04090	55		 push	 ebp
  04091	8b ec		 mov	 ebp, esp
  04093	83 ec 60	 sub	 esp, 96			; 00000060H
  04096	53		 push	 ebx
  04097	56		 push	 esi
  04098	57		 push	 edi
  04099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0409c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  040a0	7d 09		 jge	 SHORT $LN9@SearchNDro
  040a2	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  040a9	eb 0c		 jmp	 SHORT $LN10@SearchNDro
$LN9@SearchNDro:
  040ab	33 c0		 xor	 eax, eax
  040ad	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  040b1	0f 9e c0	 setle	 al
  040b4	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@SearchNDro:
  040b7	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  040bb	75 05		 jne	 SHORT $LN6@SearchNDro

; 1292 : 	{
; 1293 : 		return;

  040bd	e9 ca 01 00 00	 jmp	 $LN7@SearchNDro
$LN6@SearchNDro:

; 1294 : 	}
; 1295 : 
; 1296 : 	if ( OBJMAX_RANGE(iMonsterIndex) == FALSE )

  040c2	83 7d 0c 00	 cmp	 DWORD PTR _iMonsterIndex$[ebp], 0
  040c6	7d 09		 jge	 SHORT $LN11@SearchNDro
  040c8	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  040cf	eb 0f		 jmp	 SHORT $LN12@SearchNDro
$LN11@SearchNDro:
  040d1	33 c0		 xor	 eax, eax
  040d3	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _iMonsterIndex$[ebp], 14999 ; 00003a97H
  040da	0f 9e c0	 setle	 al
  040dd	89 45 a0	 mov	 DWORD PTR tv72[ebp], eax
$LN12@SearchNDro:
  040e0	83 7d a0 00	 cmp	 DWORD PTR tv72[ebp], 0
  040e4	75 05		 jne	 SHORT $LN5@SearchNDro

; 1297 : 	{
; 1298 : 		return;

  040e6	e9 a1 01 00 00	 jmp	 $LN7@SearchNDro
$LN5@SearchNDro:

; 1299 : 	}
; 1300 : 
; 1301 : 	if ( OBJMAX_RANGE(iMaxHitUserIndex) == FALSE )

  040eb	83 7d 10 00	 cmp	 DWORD PTR _iMaxHitUserIndex$[ebp], 0
  040ef	7d 09		 jge	 SHORT $LN13@SearchNDro
  040f1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  040f8	eb 0f		 jmp	 SHORT $LN14@SearchNDro
$LN13@SearchNDro:
  040fa	33 c0		 xor	 eax, eax
  040fc	81 7d 10 97 3a
	00 00		 cmp	 DWORD PTR _iMaxHitUserIndex$[ebp], 14999 ; 00003a97H
  04103	0f 9e c0	 setle	 al
  04106	89 45 a0	 mov	 DWORD PTR tv77[ebp], eax
$LN14@SearchNDro:
  04109	83 7d a0 00	 cmp	 DWORD PTR tv77[ebp], 0
  0410d	75 05		 jne	 SHORT $LN4@SearchNDro

; 1302 : 	{
; 1303 : 		return;

  0410f	e9 78 01 00 00	 jmp	 $LN7@SearchNDro
$LN4@SearchNDro:

; 1304 : 	}
; 1305 : 
; 1306 : 	std::map<int, _MONSTER_ITEM_DROP>::iterator it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMonsterIndex);

  04114	8d 45 0c	 lea	 eax, DWORD PTR _iMonsterIndex$[ebp]
  04117	50		 push	 eax
  04118	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0411b	51		 push	 ecx
  0411c	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0411f	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  04125	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  04128	8d 8c 10 8c 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2188]
  0412f	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find

; 1307 : 
; 1308 : 	if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  04134	8d 45 a4	 lea	 eax, DWORD PTR $T242122[ebp]
  04137	50		 push	 eax
  04138	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0413b	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  04141	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  04144	8d 8c 0a 8c 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+2188]
  0414b	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  04150	50		 push	 eax
  04151	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  04154	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  04159	0f b6 c0	 movzx	 eax, al
  0415c	85 c0		 test	 eax, eax
  0415e	74 05		 je	 SHORT $LN3@SearchNDro

; 1309 : 	{
; 1310 : 		return;

  04160	e9 27 01 00 00	 jmp	 $LN7@SearchNDro
$LN3@SearchNDro:

; 1311 : 	}
; 1312 : 
; 1313 : 	_MONSTER_ITEM_DROP MID = it->second;

  04165	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  04168	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
  0416d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  04170	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  04173	89 4d f0	 mov	 DWORD PTR _MID$[ebp], ecx
  04176	89 55 f4	 mov	 DWORD PTR _MID$[ebp+4], edx

; 1314 : 	int iType = MID.m_iItemKind;

  04179	8b 45 f4	 mov	 eax, DWORD PTR _MID$[ebp+4]
  0417c	89 45 ec	 mov	 DWORD PTR _iType$[ebp], eax

; 1315 : 	int iLevel = 0;

  0417f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iLevel$[ebp], 0

; 1316 : 	
; 1317 : 	if ( iType == ITEMGET(13,15) )

  04186	81 7d ec 0f 1a
	00 00		 cmp	 DWORD PTR _iType$[ebp], 6671 ; 00001a0fH
  0418d	75 14		 jne	 SHORT $LN2@SearchNDro

; 1318 : 	{
; 1319 : 		iLevel = rand()%4;

  0418f	e8 00 00 00 00	 call	 _rand
  04194	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  04199	79 05		 jns	 SHORT $LN17@SearchNDro
  0419b	48		 dec	 eax
  0419c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0419f	40		 inc	 eax
$LN17@SearchNDro:
  041a0	89 45 e8	 mov	 DWORD PTR _iLevel$[ebp], eax
$LN2@SearchNDro:

; 1320 : 	}
; 1321 : 
; 1322 : 	::ItemSerialCreateSend(gObj[iMaxHitUserIndex].m_Index, (BYTE)gObj[iMaxHitUserIndex].MapNumber, (BYTE)gObj[iMaxHitUserIndex].X,
; 1323 : 		(BYTE)gObj[iMaxHitUserIndex].Y, iType, (BYTE)iLevel, 0, 0, 0, 0, iMaxHitUserIndex, 0, 0);

  041a3	6a 00		 push	 0
  041a5	6a 00		 push	 0
  041a7	8b 45 10	 mov	 eax, DWORD PTR _iMaxHitUserIndex$[ebp]
  041aa	50		 push	 eax
  041ab	6a 00		 push	 0
  041ad	6a 00		 push	 0
  041af	6a 00		 push	 0
  041b1	6a 00		 push	 0
  041b3	0f b6 4d e8	 movzx	 ecx, BYTE PTR _iLevel$[ebp]
  041b7	51		 push	 ecx
  041b8	8b 55 ec	 mov	 edx, DWORD PTR _iType$[ebp]
  041bb	52		 push	 edx
  041bc	8b 45 10	 mov	 eax, DWORD PTR _iMaxHitUserIndex$[ebp]
  041bf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  041c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  041cb	0f b6 94 01 46
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+326]
  041d3	52		 push	 edx
  041d4	8b 45 10	 mov	 eax, DWORD PTR _iMaxHitUserIndex$[ebp]
  041d7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  041dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  041e3	0f b6 94 01 44
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+324]
  041eb	52		 push	 edx
  041ec	8b 45 10	 mov	 eax, DWORD PTR _iMaxHitUserIndex$[ebp]
  041ef	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  041f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  041fb	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  04203	52		 push	 edx
  04204	8b 45 10	 mov	 eax, DWORD PTR _iMaxHitUserIndex$[ebp]
  04207	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0420d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04213	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  04216	52		 push	 edx
  04217	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0421c	83 c4 34	 add	 esp, 52			; 00000034H

; 1324 : 
; 1325 : 	if ( OBJMAX_RANGE(iMaxHitUserIndex) != FALSE )

  0421f	83 7d 10 00	 cmp	 DWORD PTR _iMaxHitUserIndex$[ebp], 0
  04223	7d 09		 jge	 SHORT $LN15@SearchNDro
  04225	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv184[ebp], 0
  0422c	eb 0f		 jmp	 SHORT $LN16@SearchNDro
$LN15@SearchNDro:
  0422e	33 c0		 xor	 eax, eax
  04230	81 7d 10 97 3a
	00 00		 cmp	 DWORD PTR _iMaxHitUserIndex$[ebp], 14999 ; 00003a97H
  04237	0f 9e c0	 setle	 al
  0423a	89 45 a0	 mov	 DWORD PTR tv184[ebp], eax
$LN16@SearchNDro:
  0423d	83 7d a0 00	 cmp	 DWORD PTR tv184[ebp], 0
  04241	74 49		 je	 SHORT $LN7@SearchNDro

; 1326 : 	{
; 1327 : 		LogAddTD("[Chaos Castle] (%d) Monster Dropped ChaosCastle Item To [%s][%s] (Item:%s)",
; 1328 : 			iChaosCastleIndex+1, gObj[iMaxHitUserIndex].AccountID, gObj[iMaxHitUserIndex].Name,
; 1329 : 			ItemAttribute[iType].Name);

  04243	8b 45 ec	 mov	 eax, DWORD PTR _iType$[ebp]
  04246	6b c0 70	 imul	 eax, 112		; 00000070H
  04249	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0424e	50		 push	 eax
  0424f	8b 4d 10	 mov	 ecx, DWORD PTR _iMaxHitUserIndex$[ebp]
  04252	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04258	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0425e	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  04262	50		 push	 eax
  04263	8b 4d 10	 mov	 ecx, DWORD PTR _iMaxHitUserIndex$[ebp]
  04266	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0426c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04272	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  04276	50		 push	 eax
  04277	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0427a	83 c1 01	 add	 ecx, 1
  0427d	51		 push	 ecx
  0427e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@
  04283	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  04289	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@SearchNDro:

; 1330 : 	}
; 1331 : }

  0428c	5f		 pop	 edi
  0428d	5e		 pop	 esi
  0428e	5b		 pop	 ebx
  0428f	8b e5		 mov	 esp, ebp
  04291	5d		 pop	 ebp
  04292	c2 0c 00	 ret	 12			; 0000000cH
?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z ENDP	; CChaosCastle::SearchNDropMonsterItem
; Function compile flags: /Odtp /ZI
_i$238075 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z PROC	; CChaosCastle::SendAllUserAnyMsg
; _this$ = ecx

; 1334 : {

  042a0	55		 push	 ebp
  042a1	8b ec		 mov	 ebp, esp
  042a3	83 ec 48	 sub	 esp, 72			; 00000048H
  042a6	53		 push	 ebx
  042a7	56		 push	 esi
  042a8	57		 push	 edi
  042a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1335 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  042ac	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _i$238075[ebp], 14000 ; 000036b0H
  042b3	eb 09		 jmp	 SHORT $LN5@SendAllUse
$LN4@SendAllUse:
  042b5	8b 45 f8	 mov	 eax, DWORD PTR _i$238075[ebp]
  042b8	83 c0 01	 add	 eax, 1
  042bb	89 45 f8	 mov	 DWORD PTR _i$238075[ebp], eax
$LN5@SendAllUse:
  042be	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _i$238075[ebp], 15000 ; 00003a98H
  042c5	7d 45		 jge	 SHORT $LN6@SendAllUse

; 1336 : 	{
; 1337 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  042c7	8b 45 f8	 mov	 eax, DWORD PTR _i$238075[ebp]
  042ca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  042d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  042d6	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  042db	75 2d		 jne	 SHORT $LN2@SendAllUse

; 1338 : 		{
; 1339 : 			if ( gObj[i].Type == OBJ_USER )

  042dd	8b 45 f8	 mov	 eax, DWORD PTR _i$238075[ebp]
  042e0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  042e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  042ec	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  042f1	83 fa 01	 cmp	 edx, 1
  042f4	75 14		 jne	 SHORT $LN2@SendAllUse

; 1340 : 			{
; 1341 : 				DataSend(i, lpMsg, iSize);

  042f6	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  042f9	50		 push	 eax
  042fa	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  042fd	51		 push	 ecx
  042fe	8b 55 f8	 mov	 edx, DWORD PTR _i$238075[ebp]
  04301	52		 push	 edx
  04302	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  04307	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendAllUse:

; 1342 : 			}
; 1343 : 		}
; 1344 : 	}

  0430a	eb a9		 jmp	 SHORT $LN4@SendAllUse
$LN6@SendAllUse:

; 1345 : }

  0430c	5f		 pop	 edi
  0430d	5e		 pop	 esi
  0430e	5b		 pop	 ebx
  0430f	8b e5		 mov	 esp, ebp
  04311	5d		 pop	 ebp
  04312	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z ENDP	; CChaosCastle::SendAllUserAnyMsg
; Function compile flags: /Odtp /ZI
tv67 = -76						; size = 4
_i$238088 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iChaosCastleIndex$ = 16				; size = 4
?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z PROC	; CChaosCastle::SendChaosCastleAnyMsg
; _this$ = ecx

; 1348 : {

  04320	55		 push	 ebp
  04321	8b ec		 mov	 ebp, esp
  04323	83 ec 4c	 sub	 esp, 76			; 0000004cH
  04326	53		 push	 ebx
  04327	56		 push	 esi
  04328	57		 push	 edi
  04329	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1349 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0432c	83 7d 10 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04330	7d 09		 jge	 SHORT $LN10@SendChaosC
  04332	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04339	eb 0c		 jmp	 SHORT $LN11@SendChaosC
$LN10@SendChaosC:
  0433b	33 c0		 xor	 eax, eax
  0433d	83 7d 10 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04341	0f 9e c0	 setle	 al
  04344	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendChaosC:
  04347	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0434b	75 05		 jne	 SHORT $LN7@SendChaosC

; 1350 : 	{
; 1351 : 		return;

  0434d	e9 fe 00 00 00	 jmp	 $LN8@SendChaosC
$LN7@SendChaosC:

; 1352 : 	}
; 1353 : 
; 1354 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  04352	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$238088[ebp], 0
  04359	eb 09		 jmp	 SHORT $LN6@SendChaosC
$LN5@SendChaosC:
  0435b	8b 45 f8	 mov	 eax, DWORD PTR _i$238088[ebp]
  0435e	83 c0 01	 add	 eax, 1
  04361	89 45 f8	 mov	 DWORD PTR _i$238088[ebp], eax
$LN6@SendChaosC:
  04364	83 7d f8 46	 cmp	 DWORD PTR _i$238088[ebp], 70 ; 00000046H
  04368	0f 8d e2 00 00
	00		 jge	 $LN8@SendChaosC

; 1355 : 	{
; 1356 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  0436e	8b 45 10	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04371	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04377	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0437a	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0437e	8b 45 f8	 mov	 eax, DWORD PTR _i$238088[ebp]
  04381	6b c0 14	 imul	 eax, 20			; 00000014H
  04384	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  04389	0f 84 bc 00 00
	00		 je	 $LN3@SendChaosC

; 1357 : 		{
; 1358 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) != FALSE )

  0438f	8b 45 10	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04392	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04398	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0439b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0439f	8b 45 f8	 mov	 eax, DWORD PTR _i$238088[ebp]
  043a2	6b c0 14	 imul	 eax, 20			; 00000014H
  043a5	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  043a9	51		 push	 ecx
  043aa	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  043af	83 c4 04	 add	 esp, 4
  043b2	85 c0		 test	 eax, eax
  043b4	0f 84 91 00 00
	00		 je	 $LN3@SendChaosC

; 1359 : 			{
; 1360 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  043ba	8b 45 10	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  043bd	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  043c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  043c6	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  043ca	8b 45 f8	 mov	 eax, DWORD PTR _i$238088[ebp]
  043cd	6b c0 14	 imul	 eax, 20			; 00000014H
  043d0	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  043d4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  043da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  043e0	0f be 84 0a a5
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3749]
  043e8	83 f8 ff	 cmp	 eax, -1
  043eb	74 5e		 je	 SHORT $LN3@SendChaosC
  043ed	8b 45 10	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  043f0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  043f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  043f9	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  043fd	8b 45 f8	 mov	 eax, DWORD PTR _i$238088[ebp]
  04400	6b c0 14	 imul	 eax, 20			; 00000014H
  04403	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04407	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0440d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04413	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  0441b	83 f8 ff	 cmp	 eax, -1
  0441e	74 2b		 je	 SHORT $LN3@SendChaosC

; 1361 : 				{
; 1362 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  04420	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  04423	50		 push	 eax
  04424	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04427	51		 push	 ecx
  04428	8b 55 10	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0442b	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  04431	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  04434	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  04438	8b 55 f8	 mov	 edx, DWORD PTR _i$238088[ebp]
  0443b	6b d2 14	 imul	 edx, 20			; 00000014H
  0443e	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  04442	50		 push	 eax
  04443	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  04448	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendChaosC:

; 1363 : 				}
; 1364 : 			}
; 1365 : 		}
; 1366 : 	}

  0444b	e9 0b ff ff ff	 jmp	 $LN5@SendChaosC
$LN8@SendChaosC:

; 1367 : }

  04450	5f		 pop	 edi
  04451	5e		 pop	 esi
  04452	5b		 pop	 ebx
  04453	8b e5		 mov	 esp, ebp
  04455	5d		 pop	 ebp
  04456	c2 0c 00	 ret	 12			; 0000000cH
?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ENDP	; CChaosCastle::SendChaosCastleAnyMsg
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z	; CChaosCastle::SendNoticeMessage
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -352						; size = 4
_i$238103 = -284					; size = 4
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z PROC	; CChaosCastle::SendNoticeMessage
; _this$ = ecx

; 1370 : {

  04460	55		 push	 ebp
  04461	8b ec		 mov	 ebp, esp
  04463	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  04469	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0446e	33 c5		 xor	 eax, ebp
  04470	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  04473	53		 push	 ebx
  04474	56		 push	 esi
  04475	57		 push	 edi
  04476	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1371 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04479	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  0447d	7d 0c		 jge	 SHORT $LN10@SendNotice
  0447f	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  04489	eb 0f		 jmp	 SHORT $LN11@SendNotice
$LN10@SendNotice:
  0448b	33 c0		 xor	 eax, eax
  0448d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04491	0f 9e c0	 setle	 al
  04494	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendNotice:
  0449a	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  044a1	75 05		 jne	 SHORT $LN7@SendNotice

; 1372 : 	{
; 1373 : 		return;

  044a3	e9 3b 01 00 00	 jmp	 $LN8@SendNotice
$LN7@SendNotice:

; 1374 : 	}
; 1375 : 
; 1376 : 	PMSG_NOTICE pNotice;
; 1377 : 	TNotice::MakeNoticeMsgEx((TNotice *)&pNotice, 0, lpszMSG);

  044a8	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  044ab	50		 push	 eax
  044ac	6a 00		 push	 0
  044ae	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  044b4	51		 push	 ecx
  044b5	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  044ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1378 : 
; 1379 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  044bd	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$238103[ebp], 0
  044c7	eb 0f		 jmp	 SHORT $LN6@SendNotice
$LN5@SendNotice:
  044c9	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$238103[ebp]
  044cf	83 c0 01	 add	 eax, 1
  044d2	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$238103[ebp], eax
$LN6@SendNotice:
  044d8	83 bd e4 fe ff
	ff 46		 cmp	 DWORD PTR _i$238103[ebp], 70 ; 00000046H
  044df	0f 8d fe 00 00
	00		 jge	 $LN8@SendNotice

; 1380 : 	{
; 1381 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  044e5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  044e8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  044ee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  044f1	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  044f5	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$238103[ebp]
  044fb	6b c0 14	 imul	 eax, 20			; 00000014H
  044fe	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  04503	0f 84 d5 00 00
	00		 je	 $LN3@SendNotice

; 1382 : 		{
; 1383 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  04509	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0450c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04512	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  04515	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04519	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$238103[ebp]
  0451f	6b c0 14	 imul	 eax, 20			; 00000014H
  04522	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04526	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0452c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04532	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  04537	0f 8e a1 00 00
	00		 jle	 $LN3@SendNotice

; 1384 : 			{
; 1385 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  0453d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04540	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04546	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  04549	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0454d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$238103[ebp]
  04553	6b c0 14	 imul	 eax, 20			; 00000014H
  04556	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0455a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04560	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04566	0f be 84 0a a5
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3749]
  0456e	83 f8 ff	 cmp	 eax, -1
  04571	74 6b		 je	 SHORT $LN3@SendNotice
  04573	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04576	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0457c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0457f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04583	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$238103[ebp]
  04589	6b c0 14	 imul	 eax, 20			; 00000014H
  0458c	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04590	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04596	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0459c	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  045a4	83 f8 ff	 cmp	 eax, -1
  045a7	74 35		 je	 SHORT $LN3@SendNotice

; 1386 : 				{
; 1387 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  045a9	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  045b0	50		 push	 eax
  045b1	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  045b7	51		 push	 ecx
  045b8	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  045bb	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  045c1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  045c4	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  045c8	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _i$238103[ebp]
  045ce	6b d2 14	 imul	 edx, 20			; 00000014H
  045d1	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  045d5	50		 push	 eax
  045d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  045db	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendNotice:

; 1388 : 				}
; 1389 : 			}
; 1390 : 		}
; 1391 : 	}

  045de	e9 e6 fe ff ff	 jmp	 $LN5@SendNotice
$LN8@SendNotice:

; 1392 : 
; 1393 : }

  045e3	5f		 pop	 edi
  045e4	5e		 pop	 esi
  045e5	5b		 pop	 ebx
  045e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  045e9	33 cd		 xor	 ecx, ebp
  045eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  045f0	8b e5		 mov	 esp, ebp
  045f2	5d		 pop	 ebp
  045f3	c2 08 00	 ret	 8
?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z ENDP	; CChaosCastle::SendNoticeMessage
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -96						; size = 4
_i$238120 = -28						; size = 4
_pMsg$ = -24						; size = 14
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendNoticeState
; _this$ = ecx

; 1396 : {

  04600	55		 push	 ebp
  04601	8b ec		 mov	 ebp, esp
  04603	83 ec 60	 sub	 esp, 96			; 00000060H
  04606	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0460b	33 c5		 xor	 eax, ebp
  0460d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  04610	53		 push	 ebx
  04611	56		 push	 esi
  04612	57		 push	 edi
  04613	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1397 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04616	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  0461a	7d 09		 jge	 SHORT $LN10@SendNotice@2
  0461c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04623	eb 0c		 jmp	 SHORT $LN11@SendNotice@2
$LN10@SendNotice@2:
  04625	33 c0		 xor	 eax, eax
  04627	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  0462b	0f 9e c0	 setle	 al
  0462e	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendNotice@2:
  04631	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  04635	75 05		 jne	 SHORT $LN7@SendNotice@2

; 1398 : 	{
; 1399 : 		return;

  04637	e9 8b 01 00 00	 jmp	 $LN8@SendNotice@2
$LN7@SendNotice@2:

; 1400 : 	}
; 1401 : 
; 1402 : 	PMSG_STATEBLOODCASTLE pMsg;
; 1403 : 
; 1404 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0463c	6a 0e		 push	 14			; 0000000eH
  0463e	68 9b 00 00 00	 push	 155			; 0000009bH
  04643	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  04646	50		 push	 eax
  04647	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0464c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1405 : 	pMsg.btPlayState = iPlayState;

  0464f	8a 45 0c	 mov	 al, BYTE PTR _iPlayState$[ebp]
  04652	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 1406 : 	pMsg.wRemainSec = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 1000;

  04655	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04658	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0465e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  04661	8b 44 01 40	 mov	 eax, DWORD PTR [ecx+eax+64]
  04665	99		 cdq
  04666	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0466b	f7 f9		 idiv	 ecx
  0466d	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 1407 : 	pMsg.wMaxKillMonster = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_USER_COUNT + this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_MONSTER_COUNT;

  04671	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04674	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0467a	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0467d	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  04683	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  04686	8b 44 02 58	 mov	 eax, DWORD PTR [edx+eax+88]
  0468a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0468d	03 44 0a 5c	 add	 eax, DWORD PTR [edx+ecx+92]
  04691	66 89 45 ee	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 1408 : 	pMsg.wCurKillMonster = this->GetCurPlayUser(iChaosCastleIndex) + this->GetMonsterListCount(iChaosCastleIndex);

  04695	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04698	50		 push	 eax
  04699	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0469c	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  046a1	8b f0		 mov	 esi, eax
  046a3	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  046a6	51		 push	 ecx
  046a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  046aa	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  046af	03 f0		 add	 esi, eax
  046b1	66 89 75 f0	 mov	 WORD PTR _pMsg$[ebp+8], si

; 1409 : 	pMsg.wUserHaveWeapon = -1;

  046b5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  046ba	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+10], ax

; 1410 : 	pMsg.btWeaponNum = -1;

  046be	c6 45 f4 ff	 mov	 BYTE PTR _pMsg$[ebp+12], 255 ; 000000ffH

; 1411 : 
; 1412 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  046c2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$238120[ebp], 0
  046c9	eb 09		 jmp	 SHORT $LN6@SendNotice@2
$LN5@SendNotice@2:
  046cb	8b 45 e4	 mov	 eax, DWORD PTR _i$238120[ebp]
  046ce	83 c0 01	 add	 eax, 1
  046d1	89 45 e4	 mov	 DWORD PTR _i$238120[ebp], eax
$LN6@SendNotice@2:
  046d4	83 7d e4 46	 cmp	 DWORD PTR _i$238120[ebp], 70 ; 00000046H
  046d8	0f 8d e9 00 00
	00		 jge	 $LN8@SendNotice@2

; 1413 : 	{
; 1414 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  046de	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  046e1	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  046e7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  046ea	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  046ee	8b 45 e4	 mov	 eax, DWORD PTR _i$238120[ebp]
  046f1	6b c0 14	 imul	 eax, 20			; 00000014H
  046f4	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  046f9	0f 84 c3 00 00
	00		 je	 $LN3@SendNotice@2

; 1415 : 		{
; 1416 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  046ff	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04702	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04708	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0470b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0470f	8b 45 e4	 mov	 eax, DWORD PTR _i$238120[ebp]
  04712	6b c0 14	 imul	 eax, 20			; 00000014H
  04715	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04719	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0471f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04725	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  0472a	0f 8e 92 00 00
	00		 jle	 $LN3@SendNotice@2

; 1417 : 			{
; 1418 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  04730	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04733	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04739	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0473c	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04740	8b 45 e4	 mov	 eax, DWORD PTR _i$238120[ebp]
  04743	6b c0 14	 imul	 eax, 20			; 00000014H
  04746	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0474a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04750	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04756	0f be 84 0a a5
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3749]
  0475e	83 f8 ff	 cmp	 eax, -1
  04761	74 5f		 je	 SHORT $LN3@SendNotice@2
  04763	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04766	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0476c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0476f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04773	8b 45 e4	 mov	 eax, DWORD PTR _i$238120[ebp]
  04776	6b c0 14	 imul	 eax, 20			; 00000014H
  04779	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0477d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04783	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04789	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  04791	83 f8 ff	 cmp	 eax, -1
  04794	74 2c		 je	 SHORT $LN3@SendNotice@2

; 1419 : 				{
; 1420 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  04796	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0479a	50		 push	 eax
  0479b	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0479e	51		 push	 ecx
  0479f	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  047a2	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  047a8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  047ab	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  047af	8b 55 e4	 mov	 edx, DWORD PTR _i$238120[ebp]
  047b2	6b d2 14	 imul	 edx, 20			; 00000014H
  047b5	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  047b9	50		 push	 eax
  047ba	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  047bf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendNotice@2:

; 1421 : 				}
; 1422 : 			}
; 1423 : 		}
; 1424 : 	}

  047c2	e9 04 ff ff ff	 jmp	 $LN5@SendNotice@2
$LN8@SendNotice@2:

; 1425 : }

  047c7	5f		 pop	 edi
  047c8	5e		 pop	 esi
  047c9	5b		 pop	 ebx
  047ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  047cd	33 cd		 xor	 ecx, ebp
  047cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  047d4	8b e5		 mov	 esp, ebp
  047d6	5d		 pop	 ebp
  047d7	c2 08 00	 ret	 8
?SendNoticeState@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendNoticeState
_TEXT	ENDS
PUBLIC	?RewardUserEXP@CChaosCastle@@QAEXHHH@Z		; CChaosCastle::RewardUserEXP
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv81 = -76						; size = 4
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_iChaosCastleSubIndex$ = -8				; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?SendWinMessage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendWinMessage
; _this$ = ecx

; 1428 : {

  047e0	55		 push	 ebp
  047e1	8b ec		 mov	 ebp, esp
  047e3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  047e6	53		 push	 ebx
  047e7	56		 push	 esi
  047e8	57		 push	 edi
  047e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1429 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  047ec	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  047f0	7d 09		 jge	 SHORT $LN7@SendWinMes
  047f2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  047f9	eb 0c		 jmp	 SHORT $LN8@SendWinMes
$LN7@SendWinMes:
  047fb	33 c0		 xor	 eax, eax
  047fd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04801	0f 9e c0	 setle	 al
  04804	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN8@SendWinMes:
  04807	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0480b	75 05		 jne	 SHORT $LN4@SendWinMes

; 1430 : 	{
; 1431 : 		return;

  0480d	e9 ea 00 00 00	 jmp	 $LN5@SendWinMes
$LN4@SendWinMes:

; 1432 : 	}
; 1433 : 
; 1434 : 	if ( OBJMAX_RANGE(iWinnerIndex) == FALSE )

  04812	83 7d 0c 00	 cmp	 DWORD PTR _iWinnerIndex$[ebp], 0
  04816	7d 09		 jge	 SHORT $LN9@SendWinMes
  04818	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  0481f	eb 0f		 jmp	 SHORT $LN10@SendWinMes
$LN9@SendWinMes:
  04821	33 c0		 xor	 eax, eax
  04823	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _iWinnerIndex$[ebp], 14999 ; 00003a97H
  0482a	0f 9e c0	 setle	 al
  0482d	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN10@SendWinMes:
  04830	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  04834	75 05		 jne	 SHORT $LN3@SendWinMes

; 1435 : 	{
; 1436 : 		return;

  04836	e9 c1 00 00 00	 jmp	 $LN5@SendWinMes
$LN3@SendWinMes:

; 1437 : 	}
; 1438 : 
; 1439 : 	int iChaosCastleSubIndex = gObj[iWinnerIndex].m_cChaosCastleSubIndex;

  0483b	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  0483e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04844	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0484a	0f be 94 01 a6
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3750]
  04852	89 55 f8	 mov	 DWORD PTR _iChaosCastleSubIndex$[ebp], edx

; 1440 : 
; 1441 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  04855	83 7d f8 00	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 0
  04859	7d 09		 jge	 SHORT $LN11@SendWinMes
  0485b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  04862	eb 0c		 jmp	 SHORT $LN12@SendWinMes
$LN11@SendWinMes:
  04864	33 c0		 xor	 eax, eax
  04866	83 7d f8 45	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 69 ; 00000045H
  0486a	0f 9e c0	 setle	 al
  0486d	89 45 b4	 mov	 DWORD PTR tv81[ebp], eax
$LN12@SendWinMes:
  04870	83 7d b4 00	 cmp	 DWORD PTR tv81[ebp], 0
  04874	75 05		 jne	 SHORT $LN2@SendWinMes

; 1442 : 	{
; 1443 : 		return;

  04876	e9 81 00 00 00	 jmp	 $LN5@SendWinMes
$LN2@SendWinMes:

; 1444 : 	}
; 1445 : 
; 1446 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg == true )

  0487b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0487e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04884	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04887	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0488b	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  0488e	6b c0 14	 imul	 eax, 20			; 00000014H
  04891	0f b6 4c 02 4c	 movzx	 ecx, BYTE PTR [edx+eax+76]
  04896	83 f9 01	 cmp	 ecx, 1
  04899	75 02		 jne	 SHORT $LN1@SendWinMes

; 1447 : 	{
; 1448 : 		return;

  0489b	eb 5f		 jmp	 SHORT $LN5@SendWinMes
$LN1@SendWinMes:

; 1449 : 	}
; 1450 : 
; 1451 : 	this->RewardUserEXP(iChaosCastleIndex, gObj[iWinnerIndex].m_cChaosCastleSubIndex, true );

  0489d	6a 01		 push	 1
  0489f	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  048a2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  048a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  048ae	0f be 94 01 a6
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3750]
  048b6	52		 push	 edx
  048b7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  048ba	50		 push	 eax
  048bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  048be	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1452 : 	::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 210)), iWinnerIndex, 1);

  048c3	6a 01		 push	 1
  048c5	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  048c8	50		 push	 eax
  048c9	68 d2 04 00 00	 push	 1234			; 000004d2H
  048ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  048d3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  048d8	50		 push	 eax
  048d9	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  048de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1453 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg = true;

  048e1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  048e4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  048ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  048ed	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  048f1	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  048f4	6b c0 14	 imul	 eax, 20			; 00000014H
  048f7	c6 44 02 4c 01	 mov	 BYTE PTR [edx+eax+76], 1
$LN5@SendWinMes:

; 1454 : }

  048fc	5f		 pop	 edi
  048fd	5e		 pop	 esi
  048fe	5b		 pop	 ebx
  048ff	8b e5		 mov	 esp, ebp
  04901	5d		 pop	 ebp
  04902	c2 08 00	 ret	 8
?SendWinMessage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendWinMessage
_TEXT	ENDS
PUBLIC	?SendFailMessage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendFailMessage
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv81 = -76						; size = 4
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_iChaosCastleSubIndex$ = -8				; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iLoserIndex$ = 12					; size = 4
?SendFailMessage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendFailMessage
; _this$ = ecx

; 1457 : {

  04910	55		 push	 ebp
  04911	8b ec		 mov	 ebp, esp
  04913	83 ec 4c	 sub	 esp, 76			; 0000004cH
  04916	53		 push	 ebx
  04917	56		 push	 esi
  04918	57		 push	 edi
  04919	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0491c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04920	7d 09		 jge	 SHORT $LN7@SendFailMe
  04922	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04929	eb 0c		 jmp	 SHORT $LN8@SendFailMe
$LN7@SendFailMe:
  0492b	33 c0		 xor	 eax, eax
  0492d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04931	0f 9e c0	 setle	 al
  04934	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN8@SendFailMe:
  04937	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0493b	75 05		 jne	 SHORT $LN4@SendFailMe

; 1459 : 	{
; 1460 : 		return;

  0493d	e9 e0 00 00 00	 jmp	 $LN5@SendFailMe
$LN4@SendFailMe:

; 1461 : 	}
; 1462 : 
; 1463 : 	if ( OBJMAX_RANGE(iLoserIndex) == FALSE )

  04942	83 7d 0c 00	 cmp	 DWORD PTR _iLoserIndex$[ebp], 0
  04946	7d 09		 jge	 SHORT $LN9@SendFailMe
  04948	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  0494f	eb 0f		 jmp	 SHORT $LN10@SendFailMe
$LN9@SendFailMe:
  04951	33 c0		 xor	 eax, eax
  04953	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _iLoserIndex$[ebp], 14999 ; 00003a97H
  0495a	0f 9e c0	 setle	 al
  0495d	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN10@SendFailMe:
  04960	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  04964	75 05		 jne	 SHORT $LN3@SendFailMe

; 1464 : 	{
; 1465 : 		return;

  04966	e9 b7 00 00 00	 jmp	 $LN5@SendFailMe
$LN3@SendFailMe:

; 1466 : 	}
; 1467 : 
; 1468 : 	int iChaosCastleSubIndex = gObj[iLoserIndex].m_cChaosCastleSubIndex;

  0496b	8b 45 0c	 mov	 eax, DWORD PTR _iLoserIndex$[ebp]
  0496e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04974	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0497a	0f be 94 01 a6
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3750]
  04982	89 55 f8	 mov	 DWORD PTR _iChaosCastleSubIndex$[ebp], edx

; 1469 : 
; 1470 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  04985	83 7d f8 00	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 0
  04989	7d 09		 jge	 SHORT $LN11@SendFailMe
  0498b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  04992	eb 0c		 jmp	 SHORT $LN12@SendFailMe
$LN11@SendFailMe:
  04994	33 c0		 xor	 eax, eax
  04996	83 7d f8 45	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 69 ; 00000045H
  0499a	0f 9e c0	 setle	 al
  0499d	89 45 b4	 mov	 DWORD PTR tv81[ebp], eax
$LN12@SendFailMe:
  049a0	83 7d b4 00	 cmp	 DWORD PTR tv81[ebp], 0
  049a4	75 02		 jne	 SHORT $LN2@SendFailMe

; 1471 : 	{
; 1472 : 		return;

  049a6	eb 7a		 jmp	 SHORT $LN5@SendFailMe
$LN2@SendFailMe:

; 1473 : 	}
; 1474 : 
; 1475 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg == true )

  049a8	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  049ab	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  049b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  049b4	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  049b8	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  049bb	6b c0 14	 imul	 eax, 20			; 00000014H
  049be	0f b6 4c 02 4c	 movzx	 ecx, BYTE PTR [edx+eax+76]
  049c3	83 f9 01	 cmp	 ecx, 1
  049c6	75 02		 jne	 SHORT $LN1@SendFailMe

; 1476 : 	{
; 1477 : 		return;

  049c8	eb 58		 jmp	 SHORT $LN5@SendFailMe
$LN1@SendFailMe:

; 1478 : 	}
; 1479 : 
; 1480 : 	this->RewardUserEXP(iChaosCastleIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleSubIndex, false );

  049ca	6a 00		 push	 0
  049cc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  049cf	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  049d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  049d8	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  049dc	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  049df	6b c0 14	 imul	 eax, 20			; 00000014H
  049e2	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  049e6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  049ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  049f2	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  049fa	50		 push	 eax
  049fb	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  049fe	51		 push	 ecx
  049ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04a02	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1481 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg = true;

  04a07	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04a0a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04a10	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04a13	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04a17	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  04a1a	6b c0 14	 imul	 eax, 20			; 00000014H
  04a1d	c6 44 02 4c 01	 mov	 BYTE PTR [edx+eax+76], 1
$LN5@SendFailMe:

; 1482 : }

  04a22	5f		 pop	 edi
  04a23	5e		 pop	 esi
  04a24	5b		 pop	 ebx
  04a25	8b e5		 mov	 esp, ebp
  04a27	5d		 pop	 ebp
  04a28	c2 08 00	 ret	 8
?SendFailMessage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendFailMessage
; Function compile flags: /Odtp /ZI
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_i$238155 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z PROC	; CChaosCastle::SendAllLoserFailMessage
; _this$ = ecx

; 1485 : {

  04a30	55		 push	 ebp
  04a31	8b ec		 mov	 ebp, esp
  04a33	83 ec 4c	 sub	 esp, 76			; 0000004cH
  04a36	53		 push	 ebx
  04a37	56		 push	 esi
  04a38	57		 push	 edi
  04a39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1486 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04a3c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04a40	7d 09		 jge	 SHORT $LN11@SendAllLos
  04a42	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04a49	eb 0c		 jmp	 SHORT $LN12@SendAllLos
$LN11@SendAllLos:
  04a4b	33 c0		 xor	 eax, eax
  04a4d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04a51	0f 9e c0	 setle	 al
  04a54	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@SendAllLos:
  04a57	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  04a5b	75 05		 jne	 SHORT $LN8@SendAllLos

; 1487 : 	{
; 1488 : 		return;

  04a5d	e9 44 01 00 00	 jmp	 $LN9@SendAllLos
$LN8@SendAllLos:

; 1489 : 	}
; 1490 : 
; 1491 : 	if ( OBJMAX_RANGE(iWinnerIndex) == FALSE && iWinnerIndex != -1)	

  04a62	83 7d 0c 00	 cmp	 DWORD PTR _iWinnerIndex$[ebp], 0
  04a66	7d 09		 jge	 SHORT $LN13@SendAllLos
  04a68	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  04a6f	eb 0f		 jmp	 SHORT $LN14@SendAllLos
$LN13@SendAllLos:
  04a71	33 c0		 xor	 eax, eax
  04a73	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _iWinnerIndex$[ebp], 14999 ; 00003a97H
  04a7a	0f 9e c0	 setle	 al
  04a7d	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN14@SendAllLos:
  04a80	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  04a84	75 0b		 jne	 SHORT $LN7@SendAllLos
  04a86	83 7d 0c ff	 cmp	 DWORD PTR _iWinnerIndex$[ebp], -1
  04a8a	74 05		 je	 SHORT $LN7@SendAllLos

; 1492 : 	{
; 1493 : 		return;

  04a8c	e9 15 01 00 00	 jmp	 $LN9@SendAllLos
$LN7@SendAllLos:

; 1494 : 	}
; 1495 : 
; 1496 : 
; 1497 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  04a91	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$238155[ebp], 0
  04a98	eb 09		 jmp	 SHORT $LN6@SendAllLos
$LN5@SendAllLos:
  04a9a	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04a9d	83 c0 01	 add	 eax, 1
  04aa0	89 45 f8	 mov	 DWORD PTR _i$238155[ebp], eax
$LN6@SendAllLos:
  04aa3	83 7d f8 46	 cmp	 DWORD PTR _i$238155[ebp], 70 ; 00000046H
  04aa7	0f 8d f9 00 00
	00		 jge	 $LN9@SendAllLos

; 1498 : 	{
; 1499 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  04aad	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04ab0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04ab6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04ab9	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04abd	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04ac0	6b c0 14	 imul	 eax, 20			; 00000014H
  04ac3	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  04ac8	0f 84 d3 00 00
	00		 je	 $LN3@SendAllLos

; 1500 : 		{
; 1501 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != iWinnerIndex )

  04ace	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04ad1	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04ad7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04ada	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04ade	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04ae1	6b c0 14	 imul	 eax, 20			; 00000014H
  04ae4	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04ae8	3b 4d 0c	 cmp	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  04aeb	0f 84 b0 00 00
	00		 je	 $LN3@SendAllLos

; 1502 : 			{
; 1503 : 				if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg == false )

  04af1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04af4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04afa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04afd	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04b01	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04b04	6b c0 14	 imul	 eax, 20			; 00000014H
  04b07	0f b6 4c 02 4c	 movzx	 ecx, BYTE PTR [edx+eax+76]
  04b0c	85 c9		 test	 ecx, ecx
  04b0e	0f 85 8d 00 00
	00		 jne	 $LN3@SendAllLos

; 1504 : 				{
; 1505 : 					this->RewardUserEXP(iChaosCastleIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex, false);

  04b14	6a 00		 push	 0
  04b16	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04b19	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04b1f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04b22	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04b26	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04b29	6b c0 14	 imul	 eax, 20			; 00000014H
  04b2c	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04b30	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04b36	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b3c	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  04b44	50		 push	 eax
  04b45	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  04b48	51		 push	 ecx
  04b49	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04b4c	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1506 : 					::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 211)), this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 1);

  04b51	6a 01		 push	 1
  04b53	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04b56	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04b5c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04b5f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04b63	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04b66	6b c0 14	 imul	 eax, 20			; 00000014H
  04b69	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04b6d	51		 push	 ecx
  04b6e	68 d3 04 00 00	 push	 1235			; 000004d3H
  04b73	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  04b78	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  04b7d	50		 push	 eax
  04b7e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  04b83	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1507 : 					this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = true;

  04b86	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04b89	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04b8f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04b92	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04b96	8b 45 f8	 mov	 eax, DWORD PTR _i$238155[ebp]
  04b99	6b c0 14	 imul	 eax, 20			; 00000014H
  04b9c	c6 44 02 4c 01	 mov	 BYTE PTR [edx+eax+76], 1
$LN3@SendAllLos:

; 1508 : 				}
; 1509 : 			}
; 1510 : 		}
; 1511 : 	}

  04ba1	e9 f4 fe ff ff	 jmp	 $LN5@SendAllLos
$LN9@SendAllLos:

; 1512 : }

  04ba6	5f		 pop	 edi
  04ba7	5e		 pop	 esi
  04ba8	5b		 pop	 ebx
  04ba9	8b e5		 mov	 esp, ebp
  04bab	5d		 pop	 ebp
  04bac	c2 08 00	 ret	 8
?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ENDP	; CChaosCastle::SendAllLoserFailMessage
_TEXT	ENDS
PUBLIC	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z	; CChaosCastle::EnterUserChaosCastle
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -80						; size = 4
_i$238169 = -12						; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::EnterUserChaosCastle
; _this$ = ecx

; 1515 : {

  04bb0	55		 push	 ebp
  04bb1	8b ec		 mov	 ebp, esp
  04bb3	83 ec 50	 sub	 esp, 80			; 00000050H
  04bb6	53		 push	 ebx
  04bb7	56		 push	 esi
  04bb8	57		 push	 edi
  04bb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1516 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04bbc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04bc0	7d 09		 jge	 SHORT $LN11@EnterUserC
  04bc2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04bc9	eb 0c		 jmp	 SHORT $LN12@EnterUserC
$LN11@EnterUserC:
  04bcb	33 c0		 xor	 eax, eax
  04bcd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04bd1	0f 9e c0	 setle	 al
  04bd4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN12@EnterUserC:
  04bd7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  04bdb	75 0a		 jne	 SHORT $LN8@EnterUserC

; 1517 : 	{
; 1518 : 		return -1;

  04bdd	b8 ff ff ff ff	 mov	 eax, -1
  04be2	e9 77 01 00 00	 jmp	 $LN9@EnterUserC
$LN8@EnterUserC:

; 1519 : 	}
; 1520 : 
; 1521 : 	int iRET_VAL = -1;

  04be7	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1

; 1522 : 
; 1523 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  04bee	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238169[ebp], 0
  04bf5	eb 09		 jmp	 SHORT $LN7@EnterUserC
$LN6@EnterUserC:
  04bf7	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04bfa	83 c0 01	 add	 eax, 1
  04bfd	89 45 f4	 mov	 DWORD PTR _i$238169[ebp], eax
$LN7@EnterUserC:
  04c00	83 7d f4 46	 cmp	 DWORD PTR _i$238169[ebp], 70 ; 00000046H
  04c04	0f 8d 51 01 00
	00		 jge	 $LN5@EnterUserC

; 1524 : 	{
; 1525 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  04c0a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04c0d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04c13	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04c16	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04c1a	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04c1d	6b c0 14	 imul	 eax, 20			; 00000014H
  04c20	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  04c25	74 2a		 je	 SHORT $LN4@EnterUserC

; 1526 : 		{
; 1527 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  04c27	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04c2a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04c30	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04c33	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04c37	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04c3a	6b c0 14	 imul	 eax, 20			; 00000014H
  04c3d	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04c41	3b 4d 0c	 cmp	 ecx, DWORD PTR _iUserIndex$[ebp]
  04c44	75 0b		 jne	 SHORT $LN4@EnterUserC

; 1528 : 			{
; 1529 : 				iRET_VAL = i;

  04c46	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04c49	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1530 : 				break;

  04c4c	e9 0a 01 00 00	 jmp	 $LN5@EnterUserC
$LN4@EnterUserC:

; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == -1 )

  04c51	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04c54	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04c5a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04c5d	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04c61	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04c64	6b c0 14	 imul	 eax, 20			; 00000014H
  04c67	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  04c6c	0f 85 e4 00 00
	00		 jne	 $LN2@EnterUserC

; 1535 : 		{
; 1536 : 			iRET_VAL = i;

  04c72	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04c75	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1537 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex = iUserIndex;

  04c78	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04c7b	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04c81	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04c84	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04c88	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04c8b	6b c0 14	 imul	 eax, 20			; 00000014H
  04c8e	8b 4d 0c	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  04c91	89 4c 02 3c	 mov	 DWORD PTR [edx+eax+60], ecx

; 1538 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iEXP = 0;

  04c95	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04c98	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04c9e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04ca1	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04ca5	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04ca8	6b c0 14	 imul	 eax, 20			; 00000014H
  04cab	c7 44 02 40 00
	00 00 00	 mov	 DWORD PTR [edx+eax+64], 0

; 1539 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iScore = 0;

  04cb3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04cb6	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04cbc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04cbf	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04cc3	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04cc6	6b c0 14	 imul	 eax, 20			; 00000014H
  04cc9	c7 44 02 44 00
	00 00 00	 mov	 DWORD PTR [edx+eax+68], 0

; 1540 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState = 0;

  04cd1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04cd4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04cda	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04cdd	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04ce1	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04ce4	6b c0 14	 imul	 eax, 20			; 00000014H
  04ce7	c7 44 02 48 00
	00 00 00	 mov	 DWORD PTR [edx+eax+72], 0

; 1541 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = false;

  04cef	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04cf2	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04cf8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04cfb	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04cff	8b 45 f4	 mov	 eax, DWORD PTR _i$238169[ebp]
  04d02	6b c0 14	 imul	 eax, 20			; 00000014H
  04d05	c6 44 02 4c 00	 mov	 BYTE PTR [edx+eax+76], 0

; 1542 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER++;

  04d0a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04d0d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04d13	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d16	8b 54 01 54	 mov	 edx, DWORD PTR [ecx+eax+84]
  04d1a	83 c2 01	 add	 edx, 1
  04d1d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04d20	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04d26	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d29	89 54 01 54	 mov	 DWORD PTR [ecx+eax+84], edx

; 1543 : 	
; 1544 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER > MAX_CHAOSCASTLE_USER)

  04d2d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04d30	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04d36	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d39	83 7c 01 54 46	 cmp	 DWORD PTR [ecx+eax+84], 70 ; 00000046H
  04d3e	7e 14		 jle	 SHORT $LN1@EnterUserC

; 1545 : 			{
; 1546 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = MAX_CHAOSCASTLE_USER;

  04d40	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04d43	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04d49	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d4c	c7 44 01 54 46
	00 00 00	 mov	 DWORD PTR [ecx+eax+84], 70 ; 00000046H
$LN1@EnterUserC:

; 1547 : 			}
; 1548 : 
; 1549 : 			break;

  04d54	eb 05		 jmp	 SHORT $LN5@EnterUserC
$LN2@EnterUserC:

; 1550 : 		}
; 1551 : 	}

  04d56	e9 9c fe ff ff	 jmp	 $LN6@EnterUserC
$LN5@EnterUserC:

; 1552 : 
; 1553 : 	return iRET_VAL;

  04d5b	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN9@EnterUserC:

; 1554 : }

  04d5e	5f		 pop	 edi
  04d5f	5e		 pop	 esi
  04d60	5b		 pop	 ebx
  04d61	8b e5		 mov	 esp, ebp
  04d63	5d		 pop	 ebp
  04d64	c2 08 00	 ret	 8
?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::EnterUserChaosCastle
_TEXT	ENDS
PUBLIC	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z	; CChaosCastle::LeaveUserChaosCastle
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -80						; size = 4
_i$238184 = -12						; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::LeaveUserChaosCastle
; _this$ = ecx

; 1557 : {

  04d70	55		 push	 ebp
  04d71	8b ec		 mov	 ebp, esp
  04d73	83 ec 50	 sub	 esp, 80			; 00000050H
  04d76	53		 push	 ebx
  04d77	56		 push	 esi
  04d78	57		 push	 edi
  04d79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1558 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04d7c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04d80	7d 09		 jge	 SHORT $LN9@LeaveUserC
  04d82	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04d89	eb 0c		 jmp	 SHORT $LN10@LeaveUserC
$LN9@LeaveUserC:
  04d8b	33 c0		 xor	 eax, eax
  04d8d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04d91	0f 9e c0	 setle	 al
  04d94	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@LeaveUserC:
  04d97	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  04d9b	75 0a		 jne	 SHORT $LN6@LeaveUserC

; 1559 : 	{
; 1560 : 		return -1;

  04d9d	b8 ff ff ff ff	 mov	 eax, -1
  04da2	e9 33 01 00 00	 jmp	 $LN7@LeaveUserC
$LN6@LeaveUserC:

; 1561 : 	}
; 1562 : 
; 1563 : 	int iRET_VAL = -1;

  04da7	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1

; 1564 : 
; 1565 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  04dae	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238184[ebp], 0
  04db5	eb 09		 jmp	 SHORT $LN5@LeaveUserC
$LN4@LeaveUserC:
  04db7	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04dba	83 c0 01	 add	 eax, 1
  04dbd	89 45 f4	 mov	 DWORD PTR _i$238184[ebp], eax
$LN5@LeaveUserC:
  04dc0	83 7d f4 46	 cmp	 DWORD PTR _i$238184[ebp], 70 ; 00000046H
  04dc4	0f 8d 0d 01 00
	00		 jge	 $LN3@LeaveUserC

; 1566 : 	{
; 1567 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  04dca	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04dcd	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04dd3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04dd6	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04dda	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04ddd	6b c0 14	 imul	 eax, 20			; 00000014H
  04de0	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  04de4	3b 4d 0c	 cmp	 ecx, DWORD PTR _iUserIndex$[ebp]
  04de7	0f 85 e5 00 00
	00		 jne	 $LN2@LeaveUserC

; 1568 : 		{
; 1569 : 			iRET_VAL = iUserIndex;

  04ded	8b 45 0c	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  04df0	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1570 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex = -1;

  04df3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04df6	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04dfc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04dff	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04e03	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04e06	6b c0 14	 imul	 eax, 20			; 00000014H
  04e09	c7 44 02 3c ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+60], -1

; 1571 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iEXP = 0;

  04e11	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04e14	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04e1a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e1d	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04e21	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04e24	6b c0 14	 imul	 eax, 20			; 00000014H
  04e27	c7 44 02 40 00
	00 00 00	 mov	 DWORD PTR [edx+eax+64], 0

; 1572 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iScore = 0;

  04e2f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04e32	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04e38	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e3b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04e3f	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04e42	6b c0 14	 imul	 eax, 20			; 00000014H
  04e45	c7 44 02 44 00
	00 00 00	 mov	 DWORD PTR [edx+eax+68], 0

; 1573 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState = 0;

  04e4d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04e50	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04e56	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e59	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04e5d	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04e60	6b c0 14	 imul	 eax, 20			; 00000014H
  04e63	c7 44 02 48 00
	00 00 00	 mov	 DWORD PTR [edx+eax+72], 0

; 1574 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = false;

  04e6b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04e6e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04e74	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e77	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04e7b	8b 45 f4	 mov	 eax, DWORD PTR _i$238184[ebp]
  04e7e	6b c0 14	 imul	 eax, 20			; 00000014H
  04e81	c6 44 02 4c 00	 mov	 BYTE PTR [edx+eax+76], 0

; 1575 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER--;

  04e86	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04e89	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04e8f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e92	8b 54 01 54	 mov	 edx, DWORD PTR [ecx+eax+84]
  04e96	83 ea 01	 sub	 edx, 1
  04e99	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04e9c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04ea2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04ea5	89 54 01 54	 mov	 DWORD PTR [ecx+eax+84], edx

; 1576 : 	
; 1577 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER < 0)

  04ea9	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04eac	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04eb2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04eb5	83 7c 01 54 00	 cmp	 DWORD PTR [ecx+eax+84], 0
  04eba	7d 14		 jge	 SHORT $LN1@LeaveUserC

; 1578 : 			{
; 1579 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = 0;

  04ebc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04ebf	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04ec5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04ec8	c7 44 01 54 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+84], 0
$LN1@LeaveUserC:

; 1580 : 			}
; 1581 : 
; 1582 : 			break;

  04ed0	eb 05		 jmp	 SHORT $LN3@LeaveUserC
$LN2@LeaveUserC:

; 1583 : 		}
; 1584 : 	}

  04ed2	e9 e0 fe ff ff	 jmp	 $LN4@LeaveUserC
$LN3@LeaveUserC:

; 1585 : 
; 1586 : 	return iRET_VAL;

  04ed7	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN7@LeaveUserC:

; 1587 : }

  04eda	5f		 pop	 edi
  04edb	5e		 pop	 esi
  04edc	5b		 pop	 ebx
  04edd	8b e5		 mov	 esp, ebp
  04edf	5d		 pop	 ebp
  04ee0	c2 08 00	 ret	 8
?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::LeaveUserChaosCastle
_TEXT	ENDS
PUBLIC	?AddFallUser@CChaosCastle@@QAEXHH@Z		; CChaosCastle::AddFallUser
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -76						; size = 4
_iFALL$238196 = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?AddFallUser@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::AddFallUser
; _this$ = ecx

; 1590 : {

  04ef0	55		 push	 ebp
  04ef1	8b ec		 mov	 ebp, esp
  04ef3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  04ef6	53		 push	 ebx
  04ef7	56		 push	 esi
  04ef8	57		 push	 edi
  04ef9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1591 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04efc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04f00	7d 09		 jge	 SHORT $LN8@AddFallUse
  04f02	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04f09	eb 0c		 jmp	 SHORT $LN9@AddFallUse
$LN8@AddFallUse:
  04f0b	33 c0		 xor	 eax, eax
  04f0d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04f11	0f 9e c0	 setle	 al
  04f14	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@AddFallUse:
  04f17	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  04f1b	75 02		 jne	 SHORT $LN5@AddFallUse

; 1592 : 	{
; 1593 : 		return;

  04f1d	eb 5e		 jmp	 SHORT $LN6@AddFallUse
$LN5@AddFallUse:

; 1594 : 	}
; 1595 : 
; 1596 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  04f1f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iFALL$238196[ebp], 0
  04f26	eb 09		 jmp	 SHORT $LN4@AddFallUse
$LN3@AddFallUse:
  04f28	8b 45 f8	 mov	 eax, DWORD PTR _iFALL$238196[ebp]
  04f2b	83 c0 01	 add	 eax, 1
  04f2e	89 45 f8	 mov	 DWORD PTR _iFALL$238196[ebp], eax
$LN4@AddFallUse:
  04f31	83 7d f8 46	 cmp	 DWORD PTR _iFALL$238196[ebp], 70 ; 00000046H
  04f35	7d 46		 jge	 SHORT $LN6@AddFallUse

; 1597 : 	{
; 1598 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL] == -1 )

  04f37	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04f3a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04f40	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04f43	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04f47	8b 45 f8	 mov	 eax, DWORD PTR _iFALL$238196[ebp]
  04f4a	83 bc 82 44 07
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1860], -1
  04f52	75 27		 jne	 SHORT $LN1@AddFallUse

; 1599 : 		{
; 1600 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL], iUserIndex);

  04f54	8b 45 0c	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  04f57	50		 push	 eax
  04f58	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  04f5b	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  04f61	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  04f64	8d 44 0a 30	 lea	 eax, DWORD PTR [edx+ecx+48]
  04f68	8b 4d f8	 mov	 ecx, DWORD PTR _iFALL$238196[ebp]
  04f6b	8d 94 88 44 07
	00 00		 lea	 edx, DWORD PTR [eax+ecx*4+1860]
  04f72	52		 push	 edx
  04f73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 1601 : 			break;

  04f79	eb 02		 jmp	 SHORT $LN6@AddFallUse
$LN1@AddFallUse:

; 1602 : 		}
; 1603 : 	}

  04f7b	eb ab		 jmp	 SHORT $LN3@AddFallUse
$LN6@AddFallUse:

; 1604 : }

  04f7d	5f		 pop	 edi
  04f7e	5e		 pop	 esi
  04f7f	5b		 pop	 ebx
  04f80	8b e5		 mov	 esp, ebp
  04f82	5d		 pop	 ebp
  04f83	c2 08 00	 ret	 8
?AddFallUser@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::AddFallUser
_TEXT	ENDS
PUBLIC	__real@00000000
EXTRN	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z:PROC ; GCDiePlayerSend
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -80						; size = 4
_iFALL_INDEX$238211 = -12				; size = 4
_iFALL$238206 = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcessFallUser@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ProcessFallUser
; _this$ = ecx

; 1607 : {

  04f90	55		 push	 ebp
  04f91	8b ec		 mov	 ebp, esp
  04f93	83 ec 50	 sub	 esp, 80			; 00000050H
  04f96	53		 push	 ebx
  04f97	56		 push	 esi
  04f98	57		 push	 edi
  04f99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1608 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  04f9c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  04fa0	7d 09		 jge	 SHORT $LN9@ProcessFal
  04fa2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04fa9	eb 0c		 jmp	 SHORT $LN10@ProcessFal
$LN9@ProcessFal:
  04fab	33 c0		 xor	 eax, eax
  04fad	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  04fb1	0f 9e c0	 setle	 al
  04fb4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@ProcessFal:
  04fb7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  04fbb	75 05		 jne	 SHORT $LN6@ProcessFal

; 1609 : 	{
; 1610 : 		return;

  04fbd	e9 ad 01 00 00	 jmp	 $LN7@ProcessFal
$LN6@ProcessFal:

; 1611 : 	}
; 1612 : 
; 1613 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  04fc2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iFALL$238206[ebp], 0
  04fc9	eb 09		 jmp	 SHORT $LN5@ProcessFal
$LN4@ProcessFal:
  04fcb	8b 45 f8	 mov	 eax, DWORD PTR _iFALL$238206[ebp]
  04fce	83 c0 01	 add	 eax, 1
  04fd1	89 45 f8	 mov	 DWORD PTR _iFALL$238206[ebp], eax
$LN5@ProcessFal:
  04fd4	83 7d f8 46	 cmp	 DWORD PTR _iFALL$238206[ebp], 70 ; 00000046H
  04fd8	0f 8d 91 01 00
	00		 jge	 $LN3@ProcessFal

; 1614 : 	{
; 1615 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL] != -1 )

  04fde	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  04fe1	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  04fe7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04fea	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  04fee	8b 45 f8	 mov	 eax, DWORD PTR _iFALL$238206[ebp]
  04ff1	83 bc 82 44 07
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1860], -1
  04ff9	0f 84 6b 01 00
	00		 je	 $LN1@ProcessFal

; 1616 : 		{
; 1617 : 			int iFALL_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL];

  04fff	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  05002	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  05008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0500b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0500f	8b 45 f8	 mov	 eax, DWORD PTR _iFALL$238206[ebp]
  05012	8b 8c 82 44 07
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+1860]
  05019	89 4d f4	 mov	 DWORD PTR _iFALL_INDEX$238211[ebp], ecx

; 1618 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL], -1);

  0501c	6a ff		 push	 -1
  0501e	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  05021	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  05027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0502a	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0502e	8b 45 f8	 mov	 eax, DWORD PTR _iFALL$238206[ebp]
  05031	8d 8c 82 44 07
	00 00		 lea	 ecx, DWORD PTR [edx+eax*4+1860]
  05038	51		 push	 ecx
  05039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 1619 : 
; 1620 : 			if ( (gObj[iFALL_INDEX].MapNumber) == this->GetChaosCastleMapNumber(iChaosCastleIndex) &&  gObjIsConnected(iFALL_INDEX) &&  gObj[iFALL_INDEX].Life > 0 )

  0503f	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  05042	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0504e	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  05056	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  05059	52		 push	 edx
  0505a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0505d	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  05062	3b f0		 cmp	 esi, eax
  05064	0f 85 00 01 00
	00		 jne	 $LN1@ProcessFal
  0506a	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  0506d	50		 push	 eax
  0506e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  05073	83 c4 04	 add	 esp, 4
  05076	85 c0		 test	 eax, eax
  05078	0f 84 ec 00 00
	00		 je	 $LN1@ProcessFal
  0507e	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  05081	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0508d	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  05094	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0509a	df e0		 fnstsw	 ax
  0509c	f6 c4 41	 test	 ah, 65			; 00000041H
  0509f	0f 85 c5 00 00
	00		 jne	 $LN1@ProcessFal

; 1621 : 			{
; 1622 : 				gObj[iFALL_INDEX].Life = 0;

  050a5	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  050a8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  050ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  050b4	d9 ee		 fldz
  050b6	d9 9c 01 fc 00
	00 00		 fstp	 DWORD PTR [ecx+eax+252]

; 1623 : 				gObj[iFALL_INDEX].m_State = 4;

  050bd	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  050c0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  050c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  050cc	c7 84 01 20 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [ecx+eax+544], 4

; 1624 : 				gObj[iFALL_INDEX].KillerType = 1;

  050d7	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  050da	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  050e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  050e6	c6 84 01 a1 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+929], 1

; 1625 : 				gObj[iFALL_INDEX].RegenTime = GetTickCount();

  050ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  050f4	8b 4d f4	 mov	 ecx, DWORD PTR _iFALL_INDEX$238211[ebp]
  050f7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  050fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05103	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 1626 : 				gObj[iFALL_INDEX].DieRegen = 1;

  0510a	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  0510d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05119	c6 84 01 a2 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+930], 1

; 1627 : 				gObj[iFALL_INDEX].PathCount = 0;

  05121	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  05124	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0512a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05130	c7 84 01 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+388], 0

; 1628 : 				
; 1629 : 				GCDiePlayerSend(&gObj[iFALL_INDEX], gObj[iFALL_INDEX].m_Index, 0, 0);

  0513b	6a 00		 push	 0
  0513d	6a 00		 push	 0
  0513f	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  05142	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0514e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05151	52		 push	 edx
  05152	8b 45 f4	 mov	 eax, DWORD PTR _iFALL_INDEX$238211[ebp]
  05155	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0515b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05161	50		 push	 eax
  05162	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  05167	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@ProcessFal:

; 1630 : 			}
; 1631 : 		}
; 1632 : 	}

  0516a	e9 5c fe ff ff	 jmp	 $LN4@ProcessFal
$LN3@ProcessFal:
$LN7@ProcessFal:

; 1633 : }

  0516f	5f		 pop	 edi
  05170	5e		 pop	 esi
  05171	5b		 pop	 ebx
  05172	8b e5		 mov	 esp, ebp
  05174	5d		 pop	 ebp
  05175	c2 04 00	 ret	 4
?ProcessFallUser@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ProcessFallUser
_TEXT	ENDS
PUBLIC	?SetUserState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SetUserState
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv87 = -80						; size = 4
tv85 = -80						; size = 4
tv80 = -80						; size = 4
tv67 = -80						; size = 4
_iChaosCastleSubIndex$ = -12				; size = 4
_iChaosCastleIndex$ = -8				; size = 4
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
_iState$ = 12						; size = 4
?SetUserState@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SetUserState
; _this$ = ecx

; 1636 : {

  05180	55		 push	 ebp
  05181	8b ec		 mov	 ebp, esp
  05183	83 ec 50	 sub	 esp, 80			; 00000050H
  05186	53		 push	 ebx
  05187	56		 push	 esi
  05188	57		 push	 edi
  05189	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 : 	if ( !OBJMAX_RANGE(iUserIndex))

  0518c	83 7d 08 00	 cmp	 DWORD PTR _iUserIndex$[ebp], 0
  05190	7d 09		 jge	 SHORT $LN10@SetUserSta
  05192	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05199	eb 0f		 jmp	 SHORT $LN11@SetUserSta
$LN10@SetUserSta:
  0519b	33 c0		 xor	 eax, eax
  0519d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iUserIndex$[ebp], 14999 ; 00003a97H
  051a4	0f 9e c0	 setle	 al
  051a7	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SetUserSta:
  051aa	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  051ae	75 05		 jne	 SHORT $LN7@SetUserSta

; 1638 : 		return;

  051b0	e9 cc 00 00 00	 jmp	 $LN8@SetUserSta
$LN7@SetUserSta:

; 1639 : 
; 1640 : 	int iChaosCastleIndex = gObj[iUserIndex].m_cChaosCastleIndex;

  051b5	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  051b8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  051be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  051c4	0f be 94 01 a5
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3749]
  051cc	89 55 f8	 mov	 DWORD PTR _iChaosCastleIndex$[ebp], edx

; 1641 : 	int iChaosCastleSubIndex = gObj[iUserIndex].m_cChaosCastleSubIndex;

  051cf	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  051d2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  051d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  051de	0f be 94 01 a6
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3750]
  051e6	89 55 f4	 mov	 DWORD PTR _iChaosCastleSubIndex$[ebp], edx

; 1642 : 
; 1643 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  051e9	83 7d f8 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  051ed	7d 09		 jge	 SHORT $LN12@SetUserSta
  051ef	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  051f6	eb 0c		 jmp	 SHORT $LN13@SetUserSta
$LN12@SetUserSta:
  051f8	33 c0		 xor	 eax, eax
  051fa	83 7d f8 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  051fe	0f 9e c0	 setle	 al
  05201	89 45 b0	 mov	 DWORD PTR tv80[ebp], eax
$LN13@SetUserSta:
  05204	83 7d b0 00	 cmp	 DWORD PTR tv80[ebp], 0
  05208	75 02		 jne	 SHORT $LN6@SetUserSta

; 1644 : 		return;

  0520a	eb 75		 jmp	 SHORT $LN8@SetUserSta
$LN6@SetUserSta:

; 1645 : 
; 1646 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  0520c	83 7d f4 00	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 0
  05210	7d 09		 jge	 SHORT $LN14@SetUserSta
  05212	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  05219	eb 0c		 jmp	 SHORT $LN15@SetUserSta
$LN14@SetUserSta:
  0521b	33 c0		 xor	 eax, eax
  0521d	83 7d f4 45	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 69 ; 00000045H
  05221	0f 9e c0	 setle	 al
  05224	89 45 b0	 mov	 DWORD PTR tv85[ebp], eax
$LN15@SetUserSta:
  05227	83 7d b0 00	 cmp	 DWORD PTR tv85[ebp], 0
  0522b	75 02		 jne	 SHORT $LN5@SetUserSta

; 1647 : 		return;

  0522d	eb 52		 jmp	 SHORT $LN8@SetUserSta
$LN5@SetUserSta:

; 1648 : 
; 1649 : 	switch ( iState )

  0522f	8b 45 0c	 mov	 eax, DWORD PTR _iState$[ebp]
  05232	89 45 b0	 mov	 DWORD PTR tv87[ebp], eax
  05235	83 7d b0 00	 cmp	 DWORD PTR tv87[ebp], 0
  05239	74 08		 je	 SHORT $LN2@SetUserSta
  0523b	83 7d b0 01	 cmp	 DWORD PTR tv87[ebp], 1
  0523f	74 22		 je	 SHORT $LN1@SetUserSta
  05241	eb 3e		 jmp	 SHORT $LN8@SetUserSta
$LN2@SetUserSta:

; 1650 : 	{
; 1651 : 		case 0:
; 1652 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iUserState = 0;

  05243	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  05246	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0524c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0524f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  05253	8b 45 f4	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  05256	6b c0 14	 imul	 eax, 20			; 00000014H
  05259	c7 44 02 48 00
	00 00 00	 mov	 DWORD PTR [edx+eax+72], 0

; 1653 : 			break;

  05261	eb 1e		 jmp	 SHORT $LN8@SetUserSta
$LN1@SetUserSta:

; 1654 : 		case 1:
; 1655 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iUserState = 1;

  05263	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  05266	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0526c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0526f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  05273	8b 45 f4	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  05276	6b c0 14	 imul	 eax, 20			; 00000014H
  05279	c7 44 02 48 01
	00 00 00	 mov	 DWORD PTR [edx+eax+72], 1
$LN8@SetUserSta:

; 1656 : 	}
; 1657 : }

  05281	5f		 pop	 edi
  05282	5e		 pop	 esi
  05283	5b		 pop	 ebx
  05284	8b e5		 mov	 esp, ebp
  05286	5d		 pop	 ebp
  05287	c2 08 00	 ret	 8
?SetUserState@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SetUserState
_TEXT	ENDS
PUBLIC	?LevelUp@CChaosCastle@@QAEHHHH@Z		; CChaosCastle::LevelUp
PUBLIC	?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z	; CChaosCastle::CalcSendRewardEXP
EXTRN	?GCKillPlayerExtSend@@YAXHH_JHH@Z:PROC		; GCKillPlayerExtSend
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
EXTRN	?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z:PROC ; gObjUserSetExp
EXTRN	?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; gObjSealUserSetExp
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	__ftol2:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv193 = -92						; size = 4
_iMAX_LEVCOUNT$ = -24					; size = 4
_iCAL_EXP$ = -20					; size = 8
_iRET_EXP$ = -12					; size = 8
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
_iEXP$ = 12						; size = 4
_iKILLCOUNT_USER$ = 16					; size = 4
_iKILLCOUNT_MONSTER$ = 20				; size = 4
?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z PROC	; CChaosCastle::CalcSendRewardEXP
; _this$ = ecx

; 1660 : {

  05290	55		 push	 ebp
  05291	8b ec		 mov	 ebp, esp
  05293	83 ec 5c	 sub	 esp, 92			; 0000005cH
  05296	53		 push	 ebx
  05297	56		 push	 esi
  05298	57		 push	 edi
  05299	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1661 : 	if ( iEXP <= 0 )

  0529c	83 7d 0c 00	 cmp	 DWORD PTR _iEXP$[ebp], 0
  052a0	7f 07		 jg	 SHORT $LN9@CalcSendRe

; 1662 : 	{
; 1663 : 		return 0;

  052a2	33 c0		 xor	 eax, eax
  052a4	e9 ab 01 00 00	 jmp	 $LN10@CalcSendRe
$LN9@CalcSendRe:

; 1664 : 	}
; 1665 : 
; 1666 : 	if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty )

  052a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  052ae	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  052b3	83 f8 01	 cmp	 eax, 1
  052b6	75 22		 jne	 SHORT $LN8@CalcSendRe
  052b8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  052bf	74 19		 je	 SHORT $LN8@CalcSendRe

; 1667 : 	{
; 1668 : 		iEXP = iEXP * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;

  052c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  052c6	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  052cb	0f af 45 0c	 imul	 eax, DWORD PTR _iEXP$[ebp]
  052cf	99		 cdq
  052d0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  052d5	f7 f9		 idiv	 ecx
  052d7	89 45 0c	 mov	 DWORD PTR _iEXP$[ebp], eax
$LN8@CalcSendRe:

; 1669 : 	}
; 1670 : 
; 1671 : 	__int64 iRET_EXP = 0;

  052da	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp], 0
  052e1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp+4], 0

; 1672 : 	__int64 iCAL_EXP = iEXP;

  052e8	8b 45 0c	 mov	 eax, DWORD PTR _iEXP$[ebp]
  052eb	99		 cdq
  052ec	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  052ef	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx

; 1673 : 
; 1674 : 	int iMAX_LEVCOUNT = 0;

  052f2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iMAX_LEVCOUNT$[ebp], 0

; 1675 : 
; 1676 : 	if ( !gObjIsConnected(iUserIndex))

  052f9	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  052fc	50		 push	 eax
  052fd	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  05302	83 c4 04	 add	 esp, 4
  05305	85 c0		 test	 eax, eax
  05307	75 07		 jne	 SHORT $LN7@CalcSendRe

; 1677 : 	{
; 1678 : 		return 0;

  05309	33 c0		 xor	 eax, eax
  0530b	e9 44 01 00 00	 jmp	 $LN10@CalcSendRe
$LN7@CalcSendRe:

; 1679 : 	}
; 1680 : 
; 1681 : 	iRET_EXP = iCAL_EXP;

  05310	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  05313	89 45 f4	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  05316	8b 4d f0	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp+4]
  05319	89 4d f8	 mov	 DWORD PTR _iRET_EXP$[ebp+4], ecx

; 1682 : 
; 1683 : 	if ( gObj[iUserIndex].Type == OBJ_USER )

  0531c	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0531f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0532b	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  05330	83 fa 01	 cmp	 edx, 1
  05333	0f 85 18 01 00
	00		 jne	 $LN1@CalcSendRe
$LN5@CalcSendRe:

; 1684 : 	{
; 1685 : 		while ( iCAL_EXP > 0 )

  05339	83 7d f0 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp+4], 0
  0533d	0f 8c d3 00 00
	00		 jl	 $LN4@CalcSendRe
  05343	7f 0a		 jg	 SHORT $LN12@CalcSendRe
  05345	83 7d ec 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp], 0
  05349	0f 86 c7 00 00
	00		 jbe	 $LN4@CalcSendRe
$LN12@CalcSendRe:

; 1686 : 		{
; 1687 : 			if ( iCAL_EXP > 0 )

  0534f	83 7d f0 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp+4], 0
  05353	0f 8c a4 00 00
	00		 jl	 $LN3@CalcSendRe
  05359	7f 0a		 jg	 SHORT $LN13@CalcSendRe
  0535b	83 7d ec 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp], 0
  0535f	0f 86 98 00 00
	00		 jbe	 $LN3@CalcSendRe
$LN13@CalcSendRe:

; 1688 : 			{
; 1689 : 				gObjSealUserSetExp(&gObj[iUserIndex], iCAL_EXP, TRUE); //Seal Exp

  05365	6a 01		 push	 1
  05367	8d 45 ec	 lea	 eax, DWORD PTR _iCAL_EXP$[ebp]
  0536a	50		 push	 eax
  0536b	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  0536e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05374	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0537a	51		 push	 ecx
  0537b	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp
  05380	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1690 : 				gObjUserSetExp(&gObj[iUserIndex],iCAL_EXP);	//Panda Use

  05383	8d 45 ec	 lea	 eax, DWORD PTR _iCAL_EXP$[ebp]
  05386	50		 push	 eax
  05387	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  0538a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05390	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05396	51		 push	 ecx
  05397	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp
  0539c	83 c4 08	 add	 esp, 8

; 1691 : 
; 1692 : 				iCAL_EXP = (__int64)((int)(iCAL_EXP) * this->m_stChaosCastleData[gObj[iUserIndex].m_cChaosCastleIndex].m_iCC_REWARD_EXP); //season 4.5 add-on

  0539f	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  053a2	89 45 a4	 mov	 DWORD PTR tv193[ebp], eax
  053a5	db 45 a4	 fild	 DWORD PTR tv193[ebp]
  053a8	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  053ab	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  053b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053b7	0f be 84 0a a5
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3749]
  053bf	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  053c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  053c8	d8 8c 01 9c 08
	00 00		 fmul	 DWORD PTR [ecx+eax+2204]
  053cf	e8 00 00 00 00	 call	 __ftol2
  053d4	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  053d7	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx

; 1693 : 				iRET_EXP = (int)(iCAL_EXP); //season 4.5 changed + fix

  053da	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  053dd	99		 cdq
  053de	89 45 f4	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  053e1	89 55 f8	 mov	 DWORD PTR _iRET_EXP$[ebp+4], edx

; 1694 : 				iCAL_EXP = this->LevelUp(iUserIndex, iCAL_EXP, 3);

  053e4	6a 03		 push	 3
  053e6	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  053e9	50		 push	 eax
  053ea	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  053ed	51		 push	 ecx
  053ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  053f1	e8 00 00 00 00	 call	 ?LevelUp@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::LevelUp
  053f6	99		 cdq
  053f7	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  053fa	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
$LN3@CalcSendRe:

; 1695 : 			}
; 1696 : 
; 1697 : 			iMAX_LEVCOUNT++;

  053fd	8b 45 e8	 mov	 eax, DWORD PTR _iMAX_LEVCOUNT$[ebp]
  05400	83 c0 01	 add	 eax, 1
  05403	89 45 e8	 mov	 DWORD PTR _iMAX_LEVCOUNT$[ebp], eax

; 1698 : 
; 1699 : 			if ( iMAX_LEVCOUNT > 1000 )

  05406	81 7d e8 e8 03
	00 00		 cmp	 DWORD PTR _iMAX_LEVCOUNT$[ebp], 1000 ; 000003e8H
  0540d	7e 02		 jle	 SHORT $LN2@CalcSendRe

; 1700 : 			{
; 1701 : 				break;

  0540f	eb 05		 jmp	 SHORT $LN4@CalcSendRe
$LN2@CalcSendRe:

; 1702 : 			}
; 1703 : 		}

  05411	e9 23 ff ff ff	 jmp	 $LN5@CalcSendRe
$LN4@CalcSendRe:

; 1704 : 
; 1705 : 		if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iUserIndex]) == FALSE) //season3 add-on

  05416	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05419	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0541f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05425	50		 push	 eax
  05426	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  0542b	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  05430	85 c0		 test	 eax, eax
  05432	75 1d		 jne	 SHORT $LN1@CalcSendRe

; 1706 : 		{
; 1707 : 			GCKillPlayerExtSend(iUserIndex, (WORD)-1, iRET_EXP, 0, 0);

  05434	6a 00		 push	 0
  05436	6a 00		 push	 0
  05438	8b 45 f8	 mov	 eax, DWORD PTR _iRET_EXP$[ebp+4]
  0543b	50		 push	 eax
  0543c	8b 4d f4	 mov	 ecx, DWORD PTR _iRET_EXP$[ebp]
  0543f	51		 push	 ecx
  05440	68 ff ff 00 00	 push	 65535			; 0000ffffH
  05445	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05448	52		 push	 edx
  05449	e8 00 00 00 00	 call	 ?GCKillPlayerExtSend@@YAXHH_JHH@Z ; GCKillPlayerExtSend
  0544e	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@CalcSendRe:

; 1708 : 		}
; 1709 : 	}
; 1710 : 
; 1711 : 	return iRET_EXP;

  05451	8b 45 f4	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
$LN10@CalcSendRe:

; 1712 : }

  05454	5f		 pop	 edi
  05455	5e		 pop	 esi
  05456	5b		 pop	 ebx
  05457	8b e5		 mov	 esp, ebp
  05459	5d		 pop	 ebp
  0545a	c2 10 00	 ret	 16			; 00000010H
?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z ENDP	; CChaosCastle::CalcSendRewardEXP
_TEXT	ENDS
PUBLIC	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetUserLevelToEnter
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$238261 = -12						; size = 4
_iENTER_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetUserLevelToEnter
; _this$ = ecx

; 1715 : {

  05460	55		 push	 ebp
  05461	8b ec		 mov	 ebp, esp
  05463	83 ec 4c	 sub	 esp, 76			; 0000004cH
  05466	53		 push	 ebx
  05467	56		 push	 esi
  05468	57		 push	 edi
  05469	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1716 : 	if ( !gObjIsConnected(iUserIndex))

  0546c	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0546f	50		 push	 eax
  05470	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  05475	83 c4 04	 add	 esp, 4
  05478	85 c0		 test	 eax, eax
  0547a	75 08		 jne	 SHORT $LN11@GetUserLev

; 1717 : 	{
; 1718 : 		return -1;

  0547c	83 c8 ff	 or	 eax, -1
  0547f	e9 4f 01 00 00	 jmp	 $LN12@GetUserLev
$LN11@GetUserLev:

; 1719 : 	}
; 1720 : 
; 1721 : 	int iENTER_LEVEL = -1;

  05484	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], -1

; 1722 : 
; 1723 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iUserIndex]) != FALSE) //Season3 add-on

  0548b	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0548e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05494	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0549a	50		 push	 eax
  0549b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  054a0	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  054a5	85 c0		 test	 eax, eax
  054a7	74 0c		 je	 SHORT $LN10@GetUserLev

; 1724 : 	{
; 1725 : 		iENTER_LEVEL = 6;

  054a9	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], 6

; 1726 : 	}
; 1727 : 	else

  054b0	e9 1b 01 00 00	 jmp	 $LN9@GetUserLev
$LN10@GetUserLev:

; 1728 : 	{
; 1729 : 		for(int i=0;i<MAX_CHAOSCASTLE_LEVEL-1;i++) //exclude last floor

  054b5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238261[ebp], 0
  054bc	eb 09		 jmp	 SHORT $LN8@GetUserLev
$LN7@GetUserLev:
  054be	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  054c1	83 c0 01	 add	 eax, 1
  054c4	89 45 f4	 mov	 DWORD PTR _i$238261[ebp], eax
$LN8@GetUserLev:
  054c7	83 7d f4 06	 cmp	 DWORD PTR _i$238261[ebp], 6
  054cb	0f 8d ff 00 00
	00		 jge	 $LN9@GetUserLev

; 1730 : 		{
; 1731 : 			if ( gObj[iUserIndex].Class == CLASS_DARKLORD 
; 1732 : #ifdef MONK
; 1733 : 				|| gObj[iUserIndex].Class == CLASS_MONK
; 1734 : #endif
; 1735 : 				|| gObj[iUserIndex].Class == CLASS_MAGUMSA )

  054d1	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  054d4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054e0	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  054e8	83 fa 04	 cmp	 edx, 4
  054eb	74 38		 je	 SHORT $LN4@GetUserLev
  054ed	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  054f0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054fc	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05504	83 fa 06	 cmp	 edx, 6
  05507	74 1c		 je	 SHORT $LN4@GetUserLev
  05509	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0550c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05512	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05518	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05520	83 fa 03	 cmp	 edx, 3
  05523	75 54		 jne	 SHORT $LN5@GetUserLev
$LN4@GetUserLev:

; 1736 : 			{
; 1737 : 				if ( gObj[iUserIndex].Level >= g_sttCHAOSCASTLE_LEVEL[i].iLOWER_BOUND_MAGUMSA && gObj[iUserIndex].Level <= g_sttCHAOSCASTLE_LEVEL[i].iUPPER_BOUND_MAGUMSA )

  05525	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05528	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0552e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05534	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  0553c	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  0553f	c1 e0 04	 shl	 eax, 4
  05542	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+8]
  05548	7c 2d		 jl	 SHORT $LN3@GetUserLev
  0554a	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0554d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05553	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05559	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  05561	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  05564	c1 e0 04	 shl	 eax, 4
  05567	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+12]
  0556d	7f 08		 jg	 SHORT $LN3@GetUserLev

; 1738 : 				{
; 1739 : 					iENTER_LEVEL = i;

  0556f	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  05572	89 45 f8	 mov	 DWORD PTR _iENTER_LEVEL$[ebp], eax

; 1740 : 					break;

  05575	eb 59		 jmp	 SHORT $LN9@GetUserLev
$LN3@GetUserLev:

; 1741 : 				}
; 1742 : 			}
; 1743 : 			else

  05577	eb 52		 jmp	 SHORT $LN2@GetUserLev
$LN5@GetUserLev:

; 1744 : 			{
; 1745 : 				if ( gObj[iUserIndex].Level >= g_sttCHAOSCASTLE_LEVEL[i].iLOWER_BOUND && gObj[iUserIndex].Level <= g_sttCHAOSCASTLE_LEVEL[i].iUPPER_BOUND )

  05579	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0557c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05582	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05588	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  05590	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  05593	c1 e0 04	 shl	 eax, 4
  05596	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax]
  0559c	7c 2d		 jl	 SHORT $LN2@GetUserLev
  0559e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  055a1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  055a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  055ad	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  055b5	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  055b8	c1 e0 04	 shl	 eax, 4
  055bb	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+4]
  055c1	7f 08		 jg	 SHORT $LN2@GetUserLev

; 1746 : 				{
; 1747 : 					iENTER_LEVEL = i;

  055c3	8b 45 f4	 mov	 eax, DWORD PTR _i$238261[ebp]
  055c6	89 45 f8	 mov	 DWORD PTR _iENTER_LEVEL$[ebp], eax

; 1748 : 					break;

  055c9	eb 05		 jmp	 SHORT $LN9@GetUserLev
$LN2@GetUserLev:

; 1749 : 				}
; 1750 : 			}
; 1751 : 		}

  055cb	e9 ee fe ff ff	 jmp	 $LN7@GetUserLev
$LN9@GetUserLev:

; 1752 : 	}	
; 1753 : 			 
; 1754 : 	return iENTER_LEVEL;

  055d0	8b 45 f8	 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
$LN12@GetUserLev:

; 1755 : }

  055d3	5f		 pop	 edi
  055d4	5e		 pop	 esi
  055d5	5b		 pop	 ebx
  055d6	8b e5		 mov	 esp, ebp
  055d8	5d		 pop	 ebp
  055d9	c2 04 00	 ret	 4
?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetUserLevelToEnter
_TEXT	ENDS
PUBLIC	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z	; CChaosCastle::CheckUserEnterMoney
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv72 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
_iEnterLevel$ = 12					; size = 4
?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::CheckUserEnterMoney
; _this$ = ecx

; 1758 : {

  055e0	55		 push	 ebp
  055e1	8b ec		 mov	 ebp, esp
  055e3	83 ec 48	 sub	 esp, 72			; 00000048H
  055e6	53		 push	 ebx
  055e7	56		 push	 esi
  055e8	57		 push	 edi
  055e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  055ec	83 7d 08 00	 cmp	 DWORD PTR _iUserIndex$[ebp], 0
  055f0	7d 09		 jge	 SHORT $LN6@CheckUserE
  055f2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  055f9	eb 0f		 jmp	 SHORT $LN7@CheckUserE
$LN6@CheckUserE:
  055fb	33 c0		 xor	 eax, eax
  055fd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iUserIndex$[ebp], 14999 ; 00003a97H
  05604	0f 9e c0	 setle	 al
  05607	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckUserE:
  0560a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0560e	75 04		 jne	 SHORT $LN3@CheckUserE

; 1760 : 	{
; 1761 : 		return FALSE;

  05610	33 c0		 xor	 eax, eax
  05612	eb 50		 jmp	 SHORT $LN4@CheckUserE
$LN3@CheckUserE:

; 1762 : 	}
; 1763 : 
; 1764 : 	if ( CC_FLOOR_RANGE(iEnterLevel) == FALSE )

  05614	83 7d 0c 00	 cmp	 DWORD PTR _iEnterLevel$[ebp], 0
  05618	7d 09		 jge	 SHORT $LN8@CheckUserE
  0561a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  05621	eb 0c		 jmp	 SHORT $LN9@CheckUserE
$LN8@CheckUserE:
  05623	33 c0		 xor	 eax, eax
  05625	83 7d 0c 06	 cmp	 DWORD PTR _iEnterLevel$[ebp], 6
  05629	0f 9e c0	 setle	 al
  0562c	89 45 b8	 mov	 DWORD PTR tv72[ebp], eax
$LN9@CheckUserE:
  0562f	83 7d b8 00	 cmp	 DWORD PTR tv72[ebp], 0
  05633	75 04		 jne	 SHORT $LN2@CheckUserE

; 1765 : 	{
; 1766 : 		return FALSE;

  05635	33 c0		 xor	 eax, eax
  05637	eb 2b		 jmp	 SHORT $LN4@CheckUserE
$LN2@CheckUserE:

; 1767 : 	}
; 1768 : 
; 1769 : 	if ( gObj[iUserIndex].Money >= ::g_iChaosCastle_EnterCost[iEnterLevel] )

  05639	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0563c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05642	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05648	8b 55 0c	 mov	 edx, DWORD PTR _iEnterLevel$[ebp]
  0564b	8b 84 01 f0 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+240]
  05652	3b 04 95 00 00
	00 00		 cmp	 eax, DWORD PTR _g_iChaosCastle_EnterCost[edx*4]
  05659	7c 07		 jl	 SHORT $LN1@CheckUserE

; 1770 : 	{
; 1771 : 		return TRUE;

  0565b	b8 01 00 00 00	 mov	 eax, 1
  05660	eb 02		 jmp	 SHORT $LN4@CheckUserE
$LN1@CheckUserE:

; 1772 : 	}
; 1773 : 
; 1774 : 	return FALSE;

  05662	33 c0		 xor	 eax, eax
$LN4@CheckUserE:

; 1775 : }

  05664	5f		 pop	 edi
  05665	5e		 pop	 esi
  05666	5b		 pop	 ebx
  05667	8b e5		 mov	 esp, ebp
  05669	5d		 pop	 ebp
  0566a	c2 08 00	 ret	 8
?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::CheckUserEnterMoney
_TEXT	ENDS
PUBLIC	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z	; CChaosCastle::PayUserEnterMoney
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv72 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
_iEnterLevel$ = 12					; size = 4
?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z PROC		; CChaosCastle::PayUserEnterMoney
; _this$ = ecx

; 1778 : {

  05670	55		 push	 ebp
  05671	8b ec		 mov	 ebp, esp
  05673	83 ec 48	 sub	 esp, 72			; 00000048H
  05676	53		 push	 ebx
  05677	56		 push	 esi
  05678	57		 push	 edi
  05679	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1779 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  0567c	83 7d 08 00	 cmp	 DWORD PTR _iUserIndex$[ebp], 0
  05680	7d 09		 jge	 SHORT $LN6@PayUserEnt
  05682	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05689	eb 0f		 jmp	 SHORT $LN7@PayUserEnt
$LN6@PayUserEnt:
  0568b	33 c0		 xor	 eax, eax
  0568d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iUserIndex$[ebp], 14999 ; 00003a97H
  05694	0f 9e c0	 setle	 al
  05697	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@PayUserEnt:
  0569a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0569e	75 07		 jne	 SHORT $LN3@PayUserEnt

; 1780 : 	{
; 1781 : 		return FALSE;

  056a0	33 c0		 xor	 eax, eax
  056a2	e9 ac 00 00 00	 jmp	 $LN4@PayUserEnt
$LN3@PayUserEnt:

; 1782 : 	}
; 1783 : 
; 1784 : 	if ( CC_FLOOR_RANGE(iEnterLevel) == FALSE )

  056a7	83 7d 0c 00	 cmp	 DWORD PTR _iEnterLevel$[ebp], 0
  056ab	7d 09		 jge	 SHORT $LN8@PayUserEnt
  056ad	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  056b4	eb 0c		 jmp	 SHORT $LN9@PayUserEnt
$LN8@PayUserEnt:
  056b6	33 c0		 xor	 eax, eax
  056b8	83 7d 0c 06	 cmp	 DWORD PTR _iEnterLevel$[ebp], 6
  056bc	0f 9e c0	 setle	 al
  056bf	89 45 b8	 mov	 DWORD PTR tv72[ebp], eax
$LN9@PayUserEnt:
  056c2	83 7d b8 00	 cmp	 DWORD PTR tv72[ebp], 0
  056c6	75 07		 jne	 SHORT $LN2@PayUserEnt

; 1785 : 	{
; 1786 : 		return FALSE;

  056c8	33 c0		 xor	 eax, eax
  056ca	e9 84 00 00 00	 jmp	 $LN4@PayUserEnt
$LN2@PayUserEnt:

; 1787 : 	}
; 1788 : 
; 1789 : 	if ( gObj[iUserIndex].Money >= ::g_iChaosCastle_EnterCost[iEnterLevel] )

  056cf	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  056d2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  056d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  056de	8b 55 0c	 mov	 edx, DWORD PTR _iEnterLevel$[ebp]
  056e1	8b 84 01 f0 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+240]
  056e8	3b 04 95 00 00
	00 00		 cmp	 eax, DWORD PTR _g_iChaosCastle_EnterCost[edx*4]
  056ef	7c 60		 jl	 SHORT $LN1@PayUserEnt

; 1790 : 	{
; 1791 : 		gObj[iUserIndex].Money -= ::g_iChaosCastle_EnterCost[iEnterLevel];

  056f1	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  056f4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  056fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05700	8b 55 0c	 mov	 edx, DWORD PTR _iEnterLevel$[ebp]
  05703	8b 84 01 f0 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+240]
  0570a	2b 04 95 00 00
	00 00		 sub	 eax, DWORD PTR _g_iChaosCastle_EnterCost[edx*4]
  05711	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05714	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0571a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05720	89 84 0a f0 00
	00 00		 mov	 DWORD PTR [edx+ecx+240], eax

; 1792 : 		GCMoneySend(iUserIndex, gObj[iUserIndex].Money);

  05727	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0572a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05730	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05736	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  0573d	52		 push	 edx
  0573e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05741	50		 push	 eax
  05742	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  05747	83 c4 08	 add	 esp, 8

; 1793 : 		return TRUE;

  0574a	b8 01 00 00 00	 mov	 eax, 1
  0574f	eb 02		 jmp	 SHORT $LN4@PayUserEnt
$LN1@PayUserEnt:

; 1794 : 	}
; 1795 : 
; 1796 : 	return FALSE;

  05751	33 c0		 xor	 eax, eax
$LN4@PayUserEnt:

; 1797 : }

  05753	5f		 pop	 edi
  05754	5e		 pop	 esi
  05755	5b		 pop	 ebx
  05756	8b e5		 mov	 esp, ebp
  05758	5d		 pop	 ebp
  05759	c2 08 00	 ret	 8
?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ENDP		; CChaosCastle::PayUserEnterMoney
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GiveUserDamage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::GiveUserDamage
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pResult$ = -44						; size = 36
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iUserIndex$ = 8					; size = 4
_iDamage$ = 12						; size = 4
?GiveUserDamage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::GiveUserDamage
; _this$ = ecx

; 1800 : {

  05760	55		 push	 ebp
  05761	8b ec		 mov	 ebp, esp
  05763	83 ec 6c	 sub	 esp, 108		; 0000006cH
  05766	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0576b	33 c5		 xor	 eax, ebp
  0576d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  05770	53		 push	 ebx
  05771	56		 push	 esi
  05772	57		 push	 edi
  05773	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1801 : 	if ( !gObjIsConnected(iUserIndex))

  05776	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05779	50		 push	 eax
  0577a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0577f	83 c4 04	 add	 esp, 4
  05782	85 c0		 test	 eax, eax
  05784	75 05		 jne	 SHORT $LN4@GiveUserDa

; 1802 : 		return;

  05786	e9 d9 01 00 00	 jmp	 $LN5@GiveUserDa
$LN4@GiveUserDa:

; 1803 : 
; 1804 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  0578b	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0578e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05794	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0579a	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  057a1	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  057a7	df e0		 fnstsw	 ax
  057a9	f6 c4 41	 test	 ah, 65			; 00000041H
  057ac	7a 05		 jp	 SHORT $LN3@GiveUserDa

; 1805 : 		return;

  057ae	e9 b1 01 00 00	 jmp	 $LN5@GiveUserDa
$LN3@GiveUserDa:

; 1806 : 
; 1807 : 	PMSG_ATTACKRESULT pResult;
; 1808 : 
; 1809 : 	PHeadSetB((LPBYTE)&pResult, PROTOCOL_ATTACK, sizeof(pResult));

  057b3	6a 24		 push	 36			; 00000024H
  057b5	6a 11		 push	 17			; 00000011H
  057b7	8d 45 d4	 lea	 eax, DWORD PTR _pResult$[ebp]
  057ba	50		 push	 eax
  057bb	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  057c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1810 : 	pResult.NumberH = SET_NUMBERH(iUserIndex);

  057c3	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  057c6	c1 e8 08	 shr	 eax, 8
  057c9	88 45 d7	 mov	 BYTE PTR _pResult$[ebp+3], al

; 1811 : 	pResult.NumberL = SET_NUMBERL(iUserIndex);

  057cc	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  057cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  057d4	88 45 d8	 mov	 BYTE PTR _pResult$[ebp+4], al

; 1812 : 	pResult.DamageH = SET_NUMBERH(iDamage);

  057d7	8b 45 0c	 mov	 eax, DWORD PTR _iDamage$[ebp]
  057da	c1 e8 08	 shr	 eax, 8
  057dd	88 45 d9	 mov	 BYTE PTR _pResult$[ebp+5], al

; 1813 : 	pResult.DamageL = SET_NUMBERL(iDamage);

  057e0	8b 45 0c	 mov	 eax, DWORD PTR _iDamage$[ebp]
  057e3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  057e8	88 45 da	 mov	 BYTE PTR _pResult$[ebp+6], al

; 1814 : 	pResult.btShieldDamageH = 0;

  057eb	c6 45 dc 00	 mov	 BYTE PTR _pResult$[ebp+8], 0

; 1815 : 	pResult.btShieldDamageL = 0;

  057ef	c6 45 dd 00	 mov	 BYTE PTR _pResult$[ebp+9], 0

; 1816 : 
; 1817 : 	//Fix HP/SD Bug
; 1818 : #if(FIX_HPSDBAR)
; 1819 : 	pResult.AttackDamage = iDamage;

  057f3	8b 45 0c	 mov	 eax, DWORD PTR _iDamage$[ebp]
  057f6	89 45 e8	 mov	 DWORD PTR _pResult$[ebp+20], eax

; 1820 : 	pResult.iShieldDamage = 0;

  057f9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+24], 0

; 1821 : 	pResult.Life	= 0;

  05800	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+12], 0

; 1822 : 	pResult.MaxLife = 0;

  05807	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+16], 0

; 1823 : 	pResult.SD	= 0;

  0580e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+28], 0

; 1824 : 	pResult.MaxSD = 0;

  05815	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+32], 0

; 1825 : #endif
; 1826 : 
; 1827 : 	if ( gObj[iUserIndex].Type == OBJ_USER )

  0581c	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0581f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05825	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0582b	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  05830	83 fa 01	 cmp	 edx, 1
  05833	75 15		 jne	 SHORT $LN2@GiveUserDa

; 1828 : 	{
; 1829 : 		DataSend(iUserIndex, (LPBYTE)&pResult, pResult.h.size);

  05835	0f b6 45 d5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  05839	50		 push	 eax
  0583a	8d 4d d4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0583d	51		 push	 ecx
  0583e	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05841	52		 push	 edx
  05842	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  05847	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GiveUserDa:

; 1830 : 	}
; 1831 : 
; 1832 : 	gObj[iUserIndex].Life -= iDamage;

  0584a	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0584d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05853	db 45 0c	 fild	 DWORD PTR _iDamage$[ebp]
  05856	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0585c	d8 ac 01 fc 00
	00 00		 fsubr	 DWORD PTR [ecx+eax+252]
  05863	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05866	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0586c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05871	d9 9c 10 fc 00
	00 00		 fstp	 DWORD PTR [eax+edx+252]

; 1833 : 
; 1834 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  05878	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0587b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05881	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05887	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  0588e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  05894	df e0		 fnstsw	 ax
  05896	f6 c4 41	 test	 ah, 65			; 00000041H
  05899	0f 8a c5 00 00
	00		 jp	 $LN1@GiveUserDa

; 1835 : 	{
; 1836 : 		gObj[iUserIndex].Life = 0;

  0589f	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  058a2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  058a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058ae	d9 ee		 fldz
  058b0	d9 9c 01 fc 00
	00 00		 fstp	 DWORD PTR [ecx+eax+252]

; 1837 : 		gObj[iUserIndex].m_State = 4;

  058b7	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  058ba	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  058c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058c6	c7 84 01 20 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [ecx+eax+544], 4

; 1838 : 		gObj[iUserIndex].KillerType = 1;

  058d1	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  058d4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  058da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058e0	c6 84 01 a1 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+929], 1

; 1839 : 		gObj[iUserIndex].RegenTime = GetTickCount();

  058e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  058ee	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  058f1	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  058f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058fd	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 1840 : 		gObj[iUserIndex].DieRegen = 1;

  05904	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05907	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0590d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05913	c6 84 01 a2 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+930], 1

; 1841 : 		gObj[iUserIndex].PathCount = 0;

  0591b	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0591e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05924	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0592a	c7 84 01 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+388], 0

; 1842 : 		
; 1843 : 		GCDiePlayerSend(&gObj[iUserIndex], gObj[iUserIndex].m_Index, 0, 0);

  05935	6a 00		 push	 0
  05937	6a 00		 push	 0
  05939	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0593c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05942	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05948	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0594b	52		 push	 edx
  0594c	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0594f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05955	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0595b	50		 push	 eax
  0595c	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  05961	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GiveUserDa:
$LN5@GiveUserDa:

; 1844 : 	}
; 1845 : }

  05964	5f		 pop	 edi
  05965	5e		 pop	 esi
  05966	5b		 pop	 ebx
  05967	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0596a	33 cd		 xor	 ecx, ebp
  0596c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  05971	8b e5		 mov	 esp, ebp
  05973	5d		 pop	 ebp
  05974	c2 08 00	 ret	 8
?GiveUserDamage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::GiveUserDamage
_TEXT	ENDS
PUBLIC	??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LevelUp@CAchievements@@QAEXH@Z:PROC		; CAchievements::LevelUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	_strlen:PROC
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	_sprintf:PROC
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
EXTRN	?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z:PROC ; CMasterLevelSystem::MasterLevelUp
;	COMDAT ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ DB ',(%s)(%s) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
CONST	SEGMENT
??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ DB '4'
	DB	'00 LevelUp (%s)(%s) Party ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -352						; size = 4
_iSize$238353 = -284					; size = 4
_i$238348 = -280					; size = 4
_iPartyNumIndex$238347 = -276				; size = 4
_szMsg$238345 = -272					; size = 256
_iPartyNumber$238344 = -16				; size = 4
_iLEFT_EXP$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iUserIndex$ = 8					; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CChaosCastle@@QAEHHHH@Z PROC			; CChaosCastle::LevelUp
; _this$ = ecx

; 1848 : {

  05980	55		 push	 ebp
  05981	8b ec		 mov	 ebp, esp
  05983	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  05989	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0598e	33 c5		 xor	 eax, ebp
  05990	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  05993	53		 push	 ebx
  05994	56		 push	 esi
  05995	57		 push	 edi
  05996	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1849 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  05999	83 7d 08 00	 cmp	 DWORD PTR _iUserIndex$[ebp], 0
  0599d	7d 0c		 jge	 SHORT $LN17@LevelUp
  0599f	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  059a9	eb 12		 jmp	 SHORT $LN18@LevelUp
$LN17@LevelUp:
  059ab	33 c0		 xor	 eax, eax
  059ad	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iUserIndex$[ebp], 14999 ; 00003a97H
  059b4	0f 9e c0	 setle	 al
  059b7	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN18@LevelUp:
  059bd	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  059c4	75 07		 jne	 SHORT $LN14@LevelUp

; 1850 : 	{
; 1851 : 		return 0;

  059c6	33 c0		 xor	 eax, eax
  059c8	e9 a4 06 00 00	 jmp	 $LN15@LevelUp
$LN14@LevelUp:

; 1852 : 	}
; 1853 : 
; 1854 : 	int iLEFT_EXP = 0;

  059cd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iLEFT_EXP$[ebp], 0

; 1855 : 
; 1856 : 	if(g_MasterLevelSystem.MasterLevelUp(&gObj[iUserIndex], (__int64&)iAddExp,1,0) != 0) //season3 add-on

  059d4	6a 00		 push	 0
  059d6	6a 01		 push	 1
  059d8	8d 45 0c	 lea	 eax, DWORD PTR _iAddExp$[ebp]
  059db	50		 push	 eax
  059dc	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  059df	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  059e5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  059eb	51		 push	 ecx
  059ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  059f1	e8 00 00 00 00	 call	 ?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z ; CMasterLevelSystem::MasterLevelUp
  059f6	85 c0		 test	 eax, eax
  059f8	74 07		 je	 SHORT $LN13@LevelUp

; 1857 : 	{
; 1858 : 		return 0;

  059fa	33 c0		 xor	 eax, eax
  059fc	e9 70 06 00 00	 jmp	 $LN15@LevelUp
$LN13@LevelUp:

; 1859 : 	}
; 1860 : 
; 1861 : 	::gObjSetExpPetItem(iUserIndex, iAddExp);

  05a01	8b 45 0c	 mov	 eax, DWORD PTR _iAddExp$[ebp]
  05a04	50		 push	 eax
  05a05	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05a08	51		 push	 ecx
  05a09	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem
  05a0e	83 c4 08	 add	 esp, 8

; 1862 : 
; 1863 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d", gObj[iUserIndex].MapNumber, gObj[iUserIndex].X, gObj[iUserIndex].Y, gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].Level, gObj[iUserIndex].Experience, iAddExp, 0, iEventType);

  05a11	8b 45 10	 mov	 eax, DWORD PTR _iEventType$[ebp]
  05a14	50		 push	 eax
  05a15	6a 00		 push	 0
  05a17	8b 4d 0c	 mov	 ecx, DWORD PTR _iAddExp$[ebp]
  05a1a	51		 push	 ecx
  05a1b	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a1e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05a24	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a29	8b 8c 10 c8 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+200]
  05a30	51		 push	 ecx
  05a31	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a34	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05a3a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a3f	0f bf 8c 10 be
	00 00 00	 movsx	 ecx, WORD PTR [eax+edx+190]
  05a47	51		 push	 ecx
  05a48	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a4b	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05a51	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a56	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  05a5a	51		 push	 ecx
  05a5b	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a5e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05a64	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a69	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  05a6d	51		 push	 ecx
  05a6e	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a71	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05a77	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a7c	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  05a84	51		 push	 ecx
  05a85	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a88	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05a8e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a93	0f bf 8c 10 44
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+324]
  05a9b	51		 push	 ecx
  05a9c	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  05a9f	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05aa5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05aaa	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  05ab2	51		 push	 ecx
  05ab3	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  05ab8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  05abe	83 c4 2c	 add	 esp, 44			; 0000002cH

; 1864 : 
; 1865 : 	if ( gObj[iUserIndex].Level >= MAX_CHAR_LEVEL )

  05ac1	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05ac4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05aca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ad0	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  05ad8	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  05ade	7c 34		 jl	 SHORT $LN12@LevelUp

; 1866 : 	{
; 1867 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iUserIndex].m_Index, 1);

  05ae0	6a 01		 push	 1
  05ae2	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05ae5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05aeb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05af1	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05af4	52		 push	 edx
  05af5	68 70 04 00 00	 push	 1136			; 00000470H
  05afa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  05aff	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  05b04	50		 push	 eax
  05b05	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  05b0a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1868 : 		return 0;

  05b0d	33 c0		 xor	 eax, eax
  05b0f	e9 5d 05 00 00	 jmp	 $LN15@LevelUp
$LN12@LevelUp:

; 1869 : 	}
; 1870 : 
; 1871 : 	if ( (gObj[iUserIndex].Experience + iAddExp) < gObj[iUserIndex].NextExp )

  05b14	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05b17	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05b1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05b23	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  05b2a	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  05b2d	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05b30	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05b36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05b3c	3b 94 01 cc 00
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+204]
  05b43	73 34		 jae	 SHORT $LN11@LevelUp

; 1872 : 	{
; 1873 : 		gObj[iUserIndex].Experience += iAddExp;

  05b45	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05b48	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05b4e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05b54	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  05b5b	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  05b5e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05b61	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05b67	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05b6d	89 94 01 c8 00
	00 00		 mov	 DWORD PTR [ecx+eax+200], edx

; 1874 : 	}
; 1875 : 	else

  05b74	e9 e7 04 00 00	 jmp	 $LN5@LevelUp
$LN11@LevelUp:

; 1876 : 	{
; 1877 : 		iLEFT_EXP = gObj[iUserIndex].Experience + iAddExp - gObj[iUserIndex].NextExp;

  05b79	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05b7c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05b82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05b88	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  05b8f	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  05b92	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05b95	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05b9b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ba1	2b 94 01 cc 00
	00 00		 sub	 edx, DWORD PTR [ecx+eax+204]
  05ba8	89 55 f4	 mov	 DWORD PTR _iLEFT_EXP$[ebp], edx

; 1878 : 		gObj[iUserIndex].Experience = gObj[iUserIndex].NextExp;

  05bab	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05bae	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05bb4	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05bb7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05bbd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05bc3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05bc9	8b 84 06 cc 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+204]
  05bd0	89 84 0a c8 00
	00 00		 mov	 DWORD PTR [edx+ecx+200], eax

; 1879 : 		gObj[iUserIndex].Level++;

  05bd7	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05bda	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05be0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05be6	66 8b 94 01 be
	00 00 00	 mov	 dx, WORD PTR [ecx+eax+190]
  05bee	66 83 c2 01	 add	 dx, 1
  05bf2	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05bf5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05bfb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c01	66 89 94 01 be
	00 00 00	 mov	 WORD PTR [ecx+eax+190], dx

; 1880 : 
; 1881 : 		if ( gObj[iUserIndex].Class == CLASS_DARKLORD 
; 1882 : #ifdef MONK
; 1883 : 			|| gObj[iUserIndex].Class == CLASS_MONK
; 1884 : #endif
; 1885 : 			|| gObj[iUserIndex].Class == CLASS_MAGUMSA )

  05c09	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05c0c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05c12	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c18	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05c20	83 fa 04	 cmp	 edx, 4
  05c23	74 38		 je	 SHORT $LN8@LevelUp
  05c25	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05c28	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05c2e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c34	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05c3c	83 fa 06	 cmp	 edx, 6
  05c3f	74 1c		 je	 SHORT $LN8@LevelUp
  05c41	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05c44	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05c4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c50	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05c58	83 fa 03	 cmp	 edx, 3
  05c5b	75 31		 jne	 SHORT $LN9@LevelUp
$LN8@LevelUp:

; 1886 : 		{
; 1887 : 			gObj[iUserIndex].LevelUpPoint += 7;

  05c5d	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05c60	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05c66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c6c	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  05c73	83 c2 07	 add	 edx, 7
  05c76	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05c79	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05c7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c85	89 94 01 c0 00
	00 00		 mov	 DWORD PTR [ecx+eax+192], edx

; 1888 : 		}
; 1889 : 		else

  05c8c	eb 2f		 jmp	 SHORT $LN7@LevelUp
$LN9@LevelUp:

; 1890 : 		{
; 1891 : 			gObj[iUserIndex].LevelUpPoint += 5;

  05c8e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05c91	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05c97	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05c9d	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  05ca4	83 c2 05	 add	 edx, 5
  05ca7	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05caa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05cb0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05cb6	89 94 01 c0 00
	00 00		 mov	 DWORD PTR [ecx+eax+192], edx
$LN7@LevelUp:

; 1892 : 		}
; 1893 : 
; 1894 : 		if ( gObj[iUserIndex].PlusStatQuestClear != false )

  05cbd	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05cc0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05cc6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ccc	0f b6 94 01 a5
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+165]
  05cd4	85 d2		 test	 edx, edx
  05cd6	74 7c		 je	 SHORT $LN6@LevelUp

; 1895 : 		{
; 1896 : 			gObj[iUserIndex].LevelUpPoint++;

  05cd8	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05cdb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05ce1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ce7	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  05cee	83 c2 01	 add	 edx, 1
  05cf1	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05cf4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05cfa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d00	89 94 01 c0 00
	00 00		 mov	 DWORD PTR [ecx+eax+192], edx

; 1897 : 
; 1898 : 			LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 1899 : 				gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].LevelUpPoint);

  05d07	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05d0a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05d10	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d16	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  05d1d	52		 push	 edx
  05d1e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05d21	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05d27	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d2d	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  05d31	52		 push	 edx
  05d32	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05d35	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05d3b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d41	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  05d45	52		 push	 edx
  05d46	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  05d4b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  05d51	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@LevelUp:

; 1900 : 		}
; 1901 : 
; 1902 : 		gObj[iUserIndex].MaxLife += DCInfo.DefClass[gObj[iUserIndex].Class].LevelLife;

  05d54	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05d57	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05d5d	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05d60	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05d66	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d6c	0f b7 8c 0a b8
	00 00 00	 movzx	 ecx, WORD PTR [edx+ecx+184]
  05d74	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  05d7a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d80	d9 84 02 00 01
	00 00		 fld	 DWORD PTR [edx+eax+256]
  05d87	d8 81 10 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+16]
  05d8d	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05d90	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05d96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05d9c	d9 9c 01 00 01
	00 00		 fstp	 DWORD PTR [ecx+eax+256]

; 1903 : 		gObj[iUserIndex].MaxMana += DCInfo.DefClass[gObj[iUserIndex].Class].LevelMana;

  05da3	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05da6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05dac	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05daf	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05db5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05dbb	0f b7 8c 0a b8
	00 00 00	 movzx	 ecx, WORD PTR [edx+ecx+184]
  05dc3	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  05dc9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05dcf	d9 84 02 14 01
	00 00		 fld	 DWORD PTR [edx+eax+276]
  05dd6	d8 81 1c 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+28]
  05ddc	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05ddf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05de5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05deb	d9 9c 01 14 01
	00 00		 fstp	 DWORD PTR [ecx+eax+276]

; 1904 : 		gObj[iUserIndex].Life = gObj[iUserIndex].MaxLife;

  05df2	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05df5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05dfb	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05dfe	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05e04	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e0a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e10	d9 84 06 00 01
	00 00		 fld	 DWORD PTR [esi+eax+256]
  05e17	d9 9c 0a fc 00
	00 00		 fstp	 DWORD PTR [edx+ecx+252]

; 1905 : 		gObj[iUserIndex].Mana = gObj[iUserIndex].MaxMana;

  05e1e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05e21	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05e27	8b 4d 08	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  05e2a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05e30	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e36	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e3c	d9 84 06 14 01
	00 00		 fld	 DWORD PTR [esi+eax+276]
  05e43	d9 9c 0a 10 01
	00 00		 fstp	 DWORD PTR [edx+ecx+272]

; 1906 : 		gObjNextExpCal(&gObj[iUserIndex]);

  05e4a	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05e4d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05e53	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e59	50		 push	 eax
  05e5a	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal
  05e5f	83 c4 04	 add	 esp, 4

; 1907 : 		gObjSetBP(gObj[iUserIndex].m_Index);

  05e62	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05e65	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05e6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e71	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05e74	52		 push	 edx
  05e75	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  05e7a	83 c4 04	 add	 esp, 4

; 1908 : 		GCLevelUpMsgSend(gObj[iUserIndex].m_Index, 1);

  05e7d	6a 01		 push	 1
  05e7f	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05e82	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05e88	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05e8e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05e91	52		 push	 edx
  05e92	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend
  05e97	83 c4 08	 add	 esp, 8

; 1909 : 		gObjCalcMaxLifePower(gObj[iUserIndex].m_Index);

  05e9a	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05e9d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05ea3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ea9	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05eac	52		 push	 edx
  05ead	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  05eb2	83 c4 04	 add	 esp, 4

; 1910 : 		LogAddTD(lMsg.Get(MSGGET(2, 8)), gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].Level);

  05eb5	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05eb8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05ebe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ec4	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  05ecc	52		 push	 edx
  05ecd	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05ed0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05ed6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05edc	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  05ee0	52		 push	 edx
  05ee1	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05ee4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05eea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05ef0	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  05ef4	52		 push	 edx
  05ef5	68 08 02 00 00	 push	 520			; 00000208H
  05efa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  05eff	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  05f04	50		 push	 eax
  05f05	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  05f0b	83 c4 10	 add	 esp, 16			; 00000010H

; 1911 : 
; 1912 : 		//----------------------------------------------------------------------------------------------
; 1913 : 
; 1914 : 		if( gObj[iUserIndex].Level == 400 && gObj[iUserIndex].PartyNumber >= 0 ) //Season 2.5 add-on (Party Level 400 Display)

  05f0e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05f11	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05f17	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05f1d	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  05f25	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  05f2b	0f 85 2f 01 00
	00		 jne	 $LN5@LevelUp
  05f31	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05f34	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05f3a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05f40	83 bc 01 2c 04
	00 00 00	 cmp	 DWORD PTR [ecx+eax+1068], 0
  05f48	0f 8c 12 01 00
	00		 jl	 $LN5@LevelUp

; 1915 : 		{
; 1916 : 			int iPartyNumber = gObj[iUserIndex].PartyNumber;

  05f4e	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05f51	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05f57	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05f5d	8b 94 01 2c 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1068]
  05f64	89 55 f0	 mov	 DWORD PTR _iPartyNumber$238344[ebp], edx

; 1917 : 			char szMsg[256];
; 1918 : 			sprintf(szMsg,"400 LevelUp (%s)(%s) Party ",gObj[iUserIndex].AccountID,gObj[iUserIndex].Name);

  05f67	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05f6a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05f70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05f76	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  05f7a	52		 push	 edx
  05f7b	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  05f7e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05f84	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05f8a	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  05f8e	52		 push	 edx
  05f8f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
  05f94	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$238345[ebp]
  05f9a	50		 push	 eax
  05f9b	e8 00 00 00 00	 call	 _sprintf
  05fa0	83 c4 10	 add	 esp, 16			; 00000010H

; 1919 : 			int iPartyNumIndex;
; 1920 : 
; 1921 : 			for( int i = 0; i<MAX_USER_IN_PARTY; i++ )

  05fa3	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$238348[ebp], 0
  05fad	eb 0f		 jmp	 SHORT $LN4@LevelUp
$LN3@LevelUp:
  05faf	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _i$238348[ebp]
  05fb5	83 c0 01	 add	 eax, 1
  05fb8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _i$238348[ebp], eax
$LN4@LevelUp:
  05fbe	83 bd e8 fe ff
	ff 0a		 cmp	 DWORD PTR _i$238348[ebp], 10 ; 0000000aH
  05fc5	0f 8d 85 00 00
	00		 jge	 $LN2@LevelUp

; 1922 : 			{
; 1923 : 				iPartyNumIndex = gParty.m_PartyS[iPartyNumber].Number[i];

  05fcb	8b 45 f0	 mov	 eax, DWORD PTR _iPartyNumber$238344[ebp]
  05fce	6b c0 6c	 imul	 eax, 108		; 0000006cH
  05fd1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$238348[ebp]
  05fd7	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  05fde	89 95 ec fe ff
	ff		 mov	 DWORD PTR _iPartyNumIndex$238347[ebp], edx

; 1924 : 
; 1925 : 				if( iPartyNumIndex >= 0  )

  05fe4	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _iPartyNumIndex$238347[ebp], 0
  05feb	7c 5e		 jl	 SHORT $LN1@LevelUp

; 1926 : 				{
; 1927 : 					int iSize = strlen(szMsg);

  05fed	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$238345[ebp]
  05ff3	50		 push	 eax
  05ff4	e8 00 00 00 00	 call	 _strlen
  05ff9	83 c4 04	 add	 esp, 4
  05ffc	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iSize$238353[ebp], eax

; 1928 : 					sprintf(&szMsg[iSize],",(%s)(%s) ",gObj[iPartyNumIndex].AccountID,gObj[iPartyNumIndex].Name);

  06002	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iPartyNumIndex$238347[ebp]
  06008	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0600e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06014	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  06018	52		 push	 edx
  06019	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iPartyNumIndex$238347[ebp]
  0601f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0602b	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0602f	52		 push	 edx
  06030	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
  06035	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iSize$238353[ebp]
  0603b	8d 8c 05 f0 fe
	ff ff		 lea	 ecx, DWORD PTR _szMsg$238345[ebp+eax]
  06042	51		 push	 ecx
  06043	e8 00 00 00 00	 call	 _sprintf
  06048	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@LevelUp:

; 1929 : 				}
; 1930 : 			}

  0604b	e9 5f ff ff ff	 jmp	 $LN3@LevelUp
$LN2@LevelUp:

; 1931 : 			LogAddTD(szMsg);

  06050	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$238345[ebp]
  06056	50		 push	 eax
  06057	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0605d	83 c4 04	 add	 esp, 4
$LN5@LevelUp:

; 1932 : 		}
; 1933 : 	}
; 1934 : 
; 1935 : #if(SYSTEM_ACHIEVEMENTS)
; 1936 : 	g_Achievements.LevelUp(iUserIndex);

  06060	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  06063	50		 push	 eax
  06064	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  06069	e8 00 00 00 00	 call	 ?LevelUp@CAchievements@@QAEXH@Z ; CAchievements::LevelUp

; 1937 : #endif
; 1938 : 
; 1939 : 	return iLEFT_EXP;

  0606e	8b 45 f4	 mov	 eax, DWORD PTR _iLEFT_EXP$[ebp]
$LN15@LevelUp:

; 1940 : }

  06071	5f		 pop	 edi
  06072	5e		 pop	 esi
  06073	5b		 pop	 ebx
  06074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06077	33 cd		 xor	 ecx, ebp
  06079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0607e	8b e5		 mov	 esp, ebp
  06080	5d		 pop	 ebp
  06081	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CChaosCastle@@QAEHHHH@Z ENDP			; CChaosCastle::LevelUp
; Function compile flags: /Odtp /ZI
tv67 = -100						; size = 4
_iMONSTER_COUNT$238374 = -32				; size = 4
_iUSER_COUNT$238373 = -28				; size = 4
_iUSER_SCORE$238369 = -24				; size = 4
_lpObj$238368 = -20					; size = 4
_i$238362 = -16						; size = 4
_iCC_WINNER_INDEX$ = -12				; size = 4
_iCC_SCORE$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentWinUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentWinUser
; _this$ = ecx

; 1943 : {

  06090	55		 push	 ebp
  06091	8b ec		 mov	 ebp, esp
  06093	83 ec 64	 sub	 esp, 100		; 00000064H
  06096	53		 push	 ebx
  06097	56		 push	 esi
  06098	57		 push	 edi
  06099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1944 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0609c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  060a0	7d 09		 jge	 SHORT $LN14@GetCurrent
  060a2	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  060a9	eb 0c		 jmp	 SHORT $LN15@GetCurrent
$LN14@GetCurrent:
  060ab	33 c0		 xor	 eax, eax
  060ad	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  060b1	0f 9e c0	 setle	 al
  060b4	89 45 9c	 mov	 DWORD PTR tv67[ebp], eax
$LN15@GetCurrent:
  060b7	83 7d 9c 00	 cmp	 DWORD PTR tv67[ebp], 0
  060bb	75 0a		 jne	 SHORT $LN11@GetCurrent

; 1945 : 	{
; 1946 : 		return -1;

  060bd	b8 ff ff ff ff	 mov	 eax, -1
  060c2	e9 a0 01 00 00	 jmp	 $LN12@GetCurrent
$LN11@GetCurrent:

; 1947 : 	}
; 1948 : 
; 1949 : 	int iCC_SCORE = -1;

  060c7	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iCC_SCORE$[ebp], -1

; 1950 : 	int iCC_WINNER_INDEX = -1;

  060ce	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], -1

; 1951 : 
; 1952 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  060d5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$238362[ebp], 0
  060dc	eb 09		 jmp	 SHORT $LN10@GetCurrent
$LN9@GetCurrent:
  060de	8b 45 f0	 mov	 eax, DWORD PTR _i$238362[ebp]
  060e1	83 c0 01	 add	 eax, 1
  060e4	89 45 f0	 mov	 DWORD PTR _i$238362[ebp], eax
$LN10@GetCurrent:
  060e7	83 7d f0 46	 cmp	 DWORD PTR _i$238362[ebp], 70 ; 00000046H
  060eb	0f 8d 06 01 00
	00		 jge	 $LN8@GetCurrent

; 1953 : 	{
; 1954 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  060f1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  060f4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  060fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  060fd	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  06101	8b 45 f0	 mov	 eax, DWORD PTR _i$238362[ebp]
  06104	6b c0 14	 imul	 eax, 20			; 00000014H
  06107	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  0610c	0f 84 e0 00 00
	00		 je	 $LN7@GetCurrent

; 1955 : 		{
; 1956 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 1957 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) &&	
; 1958 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState == 0 )

  06112	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06115	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0611b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0611e	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  06122	8b 45 f0	 mov	 eax, DWORD PTR _i$238362[ebp]
  06125	6b c0 14	 imul	 eax, 20			; 00000014H
  06128	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0612c	51		 push	 ecx
  0612d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  06132	83 c4 04	 add	 esp, 4
  06135	83 f8 01	 cmp	 eax, 1
  06138	0f 85 b4 00 00
	00		 jne	 $LN7@GetCurrent
  0613e	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06141	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  06147	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0614a	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0614e	8b 45 f0	 mov	 eax, DWORD PTR _i$238362[ebp]
  06151	6b c0 14	 imul	 eax, 20			; 00000014H
  06154	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  06158	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0615e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06164	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  0616c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0616f	50		 push	 eax
  06170	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06173	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  06178	3b f0		 cmp	 esi, eax
  0617a	75 76		 jne	 SHORT $LN7@GetCurrent
  0617c	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0617f	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  06185	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06188	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0618c	8b 45 f0	 mov	 eax, DWORD PTR _i$238362[ebp]
  0618f	6b c0 14	 imul	 eax, 20			; 00000014H
  06192	83 7c 02 48 00	 cmp	 DWORD PTR [edx+eax+72], 0
  06197	75 59		 jne	 SHORT $LN7@GetCurrent

; 1959 : 			{
; 1960 : 				LPOBJ lpObj = &gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex];

  06199	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0619c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  061a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  061a5	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  061a9	8b 45 f0	 mov	 eax, DWORD PTR _i$238362[ebp]
  061ac	6b c0 14	 imul	 eax, 20			; 00000014H
  061af	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  061b3	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  061b9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  061bf	89 4d ec	 mov	 DWORD PTR _lpObj$238368[ebp], ecx

; 1961 : 
; 1962 : 				int iUSER_SCORE = lpObj->m_cKillUserCount + lpObj->m_cKillMonsterCount * 2;

  061c2	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$238368[ebp]
  061c5	0f be 88 ac 0e
	00 00		 movsx	 ecx, BYTE PTR [eax+3756]
  061cc	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$238368[ebp]
  061cf	0f be 82 ad 0e
	00 00		 movsx	 eax, BYTE PTR [edx+3757]
  061d6	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  061d9	89 4d e8	 mov	 DWORD PTR _iUSER_SCORE$238369[ebp], ecx

; 1963 : 
; 1964 : 				if ( iCC_SCORE < iUSER_SCORE )

  061dc	8b 45 f8	 mov	 eax, DWORD PTR _iCC_SCORE$[ebp]
  061df	3b 45 e8	 cmp	 eax, DWORD PTR _iUSER_SCORE$238369[ebp]
  061e2	7d 0e		 jge	 SHORT $LN7@GetCurrent

; 1965 : 				{
; 1966 : 					iCC_SCORE = iUSER_SCORE;

  061e4	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_SCORE$238369[ebp]
  061e7	89 45 f8	 mov	 DWORD PTR _iCC_SCORE$[ebp], eax

; 1967 : 					iCC_WINNER_INDEX = lpObj->m_Index;

  061ea	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$238368[ebp]
  061ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  061ef	89 4d f4	 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], ecx
$LN7@GetCurrent:

; 1968 : 				}
; 1969 : 			}
; 1970 : 		}
; 1971 : 	}

  061f2	e9 e7 fe ff ff	 jmp	 $LN9@GetCurrent
$LN8@GetCurrent:

; 1972 : 
; 1973 : 	if ( iCC_WINNER_INDEX != -1 )

  061f7	83 7d f4 ff	 cmp	 DWORD PTR _iCC_WINNER_INDEX$[ebp], -1
  061fb	74 67		 je	 SHORT $LN4@GetCurrent

; 1974 : 	{
; 1975 : 		if ( gObj[iCC_WINNER_INDEX].m_cKillUserCount == 0 && gObj[iCC_WINNER_INDEX].m_cKillMonsterCount == 0 )

  061fd	8b 45 f4	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
  06200	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06206	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0620c	0f be 94 01 ac
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3756]
  06214	85 d2		 test	 edx, edx
  06216	75 4c		 jne	 SHORT $LN4@GetCurrent
  06218	8b 45 f4	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
  0621b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06221	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06227	0f be 94 01 ad
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3757]
  0622f	85 d2		 test	 edx, edx
  06231	75 31		 jne	 SHORT $LN4@GetCurrent

; 1976 : 		{
; 1977 : 			int iUSER_COUNT = this->GetCurPlayUser(iChaosCastleIndex);

  06233	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06236	50		 push	 eax
  06237	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0623a	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0623f	89 45 e4	 mov	 DWORD PTR _iUSER_COUNT$238373[ebp], eax

; 1978 : 			int iMONSTER_COUNT = this->GetMonsterListCount(iChaosCastleIndex);

  06242	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06245	50		 push	 eax
  06246	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06249	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  0624e	89 45 e0	 mov	 DWORD PTR _iMONSTER_COUNT$238374[ebp], eax

; 1979 : 
; 1980 : 			if ( iUSER_COUNT != 1 || iMONSTER_COUNT != 0 )

  06251	83 7d e4 01	 cmp	 DWORD PTR _iUSER_COUNT$238373[ebp], 1
  06255	75 06		 jne	 SHORT $LN1@GetCurrent
  06257	83 7d e0 00	 cmp	 DWORD PTR _iMONSTER_COUNT$238374[ebp], 0
  0625b	74 07		 je	 SHORT $LN4@GetCurrent
$LN1@GetCurrent:

; 1981 : 			{
; 1982 : 				iCC_WINNER_INDEX = -1;

  0625d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], -1
$LN4@GetCurrent:

; 1983 : 			}
; 1984 : 		}
; 1985 : 	}
; 1986 : 
; 1987 : 	return iCC_WINNER_INDEX;

  06264	8b 45 f4	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
$LN12@GetCurrent:

; 1988 : }

  06267	5f		 pop	 edi
  06268	5e		 pop	 esi
  06269	5b		 pop	 ebx
  0626a	8b e5		 mov	 esp, ebp
  0626c	5d		 pop	 ebp
  0626d	c2 04 00	 ret	 4
?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentWinUser
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CChaosCastle@@QAEHHH@Z		; CChaosCastle::CheckEnterLevel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CChaosCastle@@QAEHHH@Z PROC		; CChaosCastle::CheckEnterLevel
; _this$ = ecx

; 1991 : {

  06270	55		 push	 ebp
  06271	8b ec		 mov	 ebp, esp
  06273	83 ec 48	 sub	 esp, 72			; 00000048H
  06276	53		 push	 ebx
  06277	56		 push	 esi
  06278	57		 push	 edi
  06279	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1992 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0627c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  06280	7d 09		 jge	 SHORT $LN15@CheckEnter
  06282	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06289	eb 0f		 jmp	 SHORT $LN16@CheckEnter
$LN15@CheckEnter:
  0628b	33 c0		 xor	 eax, eax
  0628d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  06294	0f 9e c0	 setle	 al
  06297	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN16@CheckEnter:
  0629a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0629e	75 0a		 jne	 SHORT $LN12@CheckEnter

; 1993 : 	{
; 1994 : 		return 2;

  062a0	b8 02 00 00 00	 mov	 eax, 2
  062a5	e9 04 02 00 00	 jmp	 $LN13@CheckEnter
$LN12@CheckEnter:

; 1995 : 	}
; 1996 : 
; 1997 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  062aa	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  062ad	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  062b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  062b9	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  062be	83 fa 01	 cmp	 edx, 1
  062c1	75 16		 jne	 SHORT $LN10@CheckEnter
  062c3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  062c6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  062cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  062d2	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  062d7	7f 0a		 jg	 SHORT $LN11@CheckEnter
$LN10@CheckEnter:

; 1998 : 	{
; 1999 : 		return 2;

  062d9	b8 02 00 00 00	 mov	 eax, 2
  062de	e9 cb 01 00 00	 jmp	 $LN13@CheckEnter
$LN11@CheckEnter:

; 2000 : 	}
; 2001 : 
; 2002 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 2003 : #ifdef MONK
; 2004 : 		|| gObj[iIndex].Class == CLASS_MONK
; 2005 : #endif
; 2006 : 		|| gObj[iIndex].Class == CLASS_MAGUMSA )

  062e3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  062e6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  062ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  062f2	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  062fa	83 fa 04	 cmp	 edx, 4
  062fd	74 3c		 je	 SHORT $LN8@CheckEnter
  062ff	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06302	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06308	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0630e	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  06316	83 fa 06	 cmp	 edx, 6
  06319	74 20		 je	 SHORT $LN8@CheckEnter
  0631b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0631e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06324	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0632a	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  06332	83 fa 03	 cmp	 edx, 3
  06335	0f 85 be 00 00
	00		 jne	 $LN9@CheckEnter
$LN8@CheckEnter:

; 2007 : 	{
; 2008 : 		if ( gObj[iIndex].Level >= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  0633b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0633e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06344	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0634a	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  06352	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  06355	83 e8 01	 sub	 eax, 1
  06358	c1 e0 04	 shl	 eax, 4
  0635b	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+8]
  06361	7c 2f		 jl	 SHORT $LN7@CheckEnter
  06363	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06366	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0636c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06372	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  0637a	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  0637d	83 e8 01	 sub	 eax, 1
  06380	c1 e0 04	 shl	 eax, 4
  06383	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+12]
  06389	7f 07		 jg	 SHORT $LN7@CheckEnter

; 2009 : 		{
; 2010 : 			return 0;

  0638b	33 c0		 xor	 eax, eax
  0638d	e9 1c 01 00 00	 jmp	 $LN13@CheckEnter
$LN7@CheckEnter:

; 2011 : 		}
; 2012 : 
; 2013 : 		if ( gObj[iIndex].Level < g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  06392	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06395	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0639b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  063a1	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  063a9	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  063ac	83 e8 01	 sub	 eax, 1
  063af	c1 e0 04	 shl	 eax, 4
  063b2	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+8]
  063b8	7d 08		 jge	 SHORT $LN6@CheckEnter

; 2014 : 		{
; 2015 : 			return -1;

  063ba	83 c8 ff	 or	 eax, -1
  063bd	e9 ec 00 00 00	 jmp	 $LN13@CheckEnter
$LN6@CheckEnter:

; 2016 : 		}
; 2017 : 
; 2018 : 		if ( gObj[iIndex].Level > g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  063c2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  063c5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  063cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  063d1	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  063d9	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  063dc	83 e8 01	 sub	 eax, 1
  063df	c1 e0 04	 shl	 eax, 4
  063e2	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+12]
  063e8	7e 0a		 jle	 SHORT $LN5@CheckEnter

; 2019 : 		{
; 2020 : 			return 1;

  063ea	b8 01 00 00 00	 mov	 eax, 1
  063ef	e9 ba 00 00 00	 jmp	 $LN13@CheckEnter
$LN5@CheckEnter:

; 2021 : 		}
; 2022 : 	}
; 2023 : 	else

  063f4	e9 b0 00 00 00	 jmp	 $LN4@CheckEnter
$LN9@CheckEnter:

; 2024 : 	{
; 2025 : 		if ( gObj[iIndex].Level >= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  063f9	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  063fc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06402	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06408	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  06410	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  06413	83 e8 01	 sub	 eax, 1
  06416	c1 e0 04	 shl	 eax, 4
  06419	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax]
  0641f	7c 2c		 jl	 SHORT $LN3@CheckEnter
  06421	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06424	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0642a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06430	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  06438	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  0643b	83 e8 01	 sub	 eax, 1
  0643e	c1 e0 04	 shl	 eax, 4
  06441	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+4]
  06447	7f 04		 jg	 SHORT $LN3@CheckEnter

; 2026 : 		{
; 2027 : 			return 0;

  06449	33 c0		 xor	 eax, eax
  0644b	eb 61		 jmp	 SHORT $LN13@CheckEnter
$LN3@CheckEnter:

; 2028 : 		}
; 2029 : 
; 2030 : 		if ( gObj[iIndex].Level < g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  0644d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06450	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06456	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0645c	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  06464	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  06467	83 e8 01	 sub	 eax, 1
  0646a	c1 e0 04	 shl	 eax, 4
  0646d	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax]
  06473	7d 05		 jge	 SHORT $LN2@CheckEnter

; 2031 : 		{
; 2032 : 			return -1;

  06475	83 c8 ff	 or	 eax, -1
  06478	eb 34		 jmp	 SHORT $LN13@CheckEnter
$LN2@CheckEnter:

; 2033 : 		}
; 2034 : 
; 2035 : 		if ( gObj[iIndex].Level > g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  0647a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0647d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06483	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06489	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  06491	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  06494	83 e8 01	 sub	 eax, 1
  06497	c1 e0 04	 shl	 eax, 4
  0649a	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax+4]
  064a0	7e 07		 jle	 SHORT $LN4@CheckEnter

; 2036 : 		{
; 2037 : 			return 1;

  064a2	b8 01 00 00 00	 mov	 eax, 1
  064a7	eb 05		 jmp	 SHORT $LN13@CheckEnter
$LN4@CheckEnter:

; 2038 : 		}
; 2039 : 	}
; 2040 : 
; 2041 : 	return 2;

  064a9	b8 02 00 00 00	 mov	 eax, 2
$LN13@CheckEnter:

; 2042 : }

  064ae	5f		 pop	 edi
  064af	5e		 pop	 esi
  064b0	5b		 pop	 ebx
  064b1	8b e5		 mov	 esp, ebp
  064b3	5d		 pop	 ebp
  064b4	c2 08 00	 ret	 8
?CheckEnterLevel@CChaosCastle@@QAEHHH@Z ENDP		; CChaosCastle::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?CheckEnterItem@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckEnterItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv138 = -80						; size = 4
tv67 = -80						; size = 4
_x$238402 = -12						; size = 4
_iITEM_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckEnterItem@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckEnterItem
; _this$ = ecx

; 2045 : {

  064c0	55		 push	 ebp
  064c1	8b ec		 mov	 ebp, esp
  064c3	83 ec 50	 sub	 esp, 80			; 00000050H
  064c6	53		 push	 ebx
  064c7	56		 push	 esi
  064c8	57		 push	 edi
  064c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2046 : 	int iITEM_LEVEL = 0;

  064cc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0

; 2047 : 
; 2048 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  064d3	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  064d7	7d 09		 jge	 SHORT $LN13@CheckEnter@2
  064d9	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  064e0	eb 0f		 jmp	 SHORT $LN14@CheckEnter@2
$LN13@CheckEnter@2:
  064e2	33 c0		 xor	 eax, eax
  064e4	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  064eb	0f 9e c0	 setle	 al
  064ee	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN14@CheckEnter@2:
  064f1	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  064f5	75 07		 jne	 SHORT $LN10@CheckEnter@2

; 2049 : 	{
; 2050 : 		return 0;

  064f7	33 c0		 xor	 eax, eax
  064f9	e9 10 01 00 00	 jmp	 $LN11@CheckEnter@2
$LN10@CheckEnter@2:

; 2051 : 	}
; 2052 : 
; 2053 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  064fe	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06501	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06507	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0650d	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  06512	83 fa 01	 cmp	 edx, 1
  06515	75 16		 jne	 SHORT $LN8@CheckEnter@2
  06517	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0651a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06520	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06526	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0652b	7f 07		 jg	 SHORT $LN9@CheckEnter@2
$LN8@CheckEnter@2:

; 2054 : 	{
; 2055 : 		return 0;

  0652d	33 c0		 xor	 eax, eax
  0652f	e9 da 00 00 00	 jmp	 $LN11@CheckEnter@2
$LN9@CheckEnter@2:

; 2056 : 	}
; 2057 : 
; 2058 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  06534	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$238402[ebp], 0
  0653b	eb 09		 jmp	 SHORT $LN7@CheckEnter@2
$LN6@CheckEnter@2:
  0653d	8b 45 f4	 mov	 eax, DWORD PTR _x$238402[ebp]
  06540	83 c0 01	 add	 eax, 1
  06543	89 45 f4	 mov	 DWORD PTR _x$238402[ebp], eax
$LN7@CheckEnter@2:
  06546	81 7d f4 cc 00
	00 00		 cmp	 DWORD PTR _x$238402[ebp], 204 ; 000000ccH
  0654d	0f 8d b8 00 00
	00		 jge	 $LN5@CheckEnter@2

; 2059 : 	{
; 2060 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  06553	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06556	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0655c	8b 4d f4	 mov	 ecx, DWORD PTR _x$238402[ebp]
  0655f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  06565	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0656b	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  06572	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  06577	83 f8 01	 cmp	 eax, 1
  0657a	0f 85 86 00 00
	00		 jne	 $LN4@CheckEnter@2

; 2061 : 		{
; 2062 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,29) )

  06580	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06583	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06589	8b 4d f4	 mov	 ecx, DWORD PTR _x$238402[ebp]
  0658c	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  06592	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06598	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0659f	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  065a4	81 f9 1d 1a 00
	00		 cmp	 ecx, 6685		; 00001a1dH
  065aa	75 5a		 jne	 SHORT $LN4@CheckEnter@2

; 2063 : 			{
; 2064 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  065ac	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  065af	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  065b5	8b 4d f4	 mov	 ecx, DWORD PTR _x$238402[ebp]
  065b8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  065be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  065c4	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  065cb	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  065d0	89 4d f8	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 2065 : 
; 2066 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CHAOSCASTLE_LEVEL+1) == FALSE )

  065d3	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  065d7	7d 09		 jge	 SHORT $LN15@CheckEnter@2
  065d9	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
  065e0	eb 0c		 jmp	 SHORT $LN16@CheckEnter@2
$LN15@CheckEnter@2:
  065e2	33 c0		 xor	 eax, eax
  065e4	83 7d f8 07	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 7
  065e8	0f 9e c0	 setle	 al
  065eb	89 45 b0	 mov	 DWORD PTR tv138[ebp], eax
$LN16@CheckEnter@2:
  065ee	83 7d b0 00	 cmp	 DWORD PTR tv138[ebp], 0
  065f2	75 07		 jne	 SHORT $LN2@CheckEnter@2

; 2067 : 				{
; 2068 : 					iITEM_LEVEL = 0;

  065f4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0
$LN2@CheckEnter@2:

; 2069 : 				}
; 2070 : 
; 2071 : 				if ( iITEM_LEVEL != 0 )

  065fb	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  065ff	74 05		 je	 SHORT $LN4@CheckEnter@2

; 2072 : 				{
; 2073 : 					return iITEM_LEVEL;

  06601	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  06604	eb 08		 jmp	 SHORT $LN11@CheckEnter@2
$LN4@CheckEnter@2:

; 2074 : 				}
; 2075 : 			}
; 2076 : 		}
; 2077 : 	}

  06606	e9 32 ff ff ff	 jmp	 $LN6@CheckEnter@2
$LN5@CheckEnter@2:

; 2078 : 
; 2079 : 	return iITEM_LEVEL;

  0660b	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
$LN11@CheckEnter@2:

; 2080 : }

  0660e	5f		 pop	 edi
  0660f	5e		 pop	 esi
  06610	5b		 pop	 ebx
  06611	8b e5		 mov	 esp, ebp
  06613	5d		 pop	 ebp
  06614	c2 04 00	 ret	 4
?CheckEnterItem@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckEnterItem
; Function compile flags: /Odtp /ZI
tv67 = -80						; size = 4
_iCUR_MONSTER_COUNT$ = -12				; size = 4
_iCUR_USER_COUNT$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckPlayEnded@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckPlayEnded
; _this$ = ecx

; 2083 : {

  06620	55		 push	 ebp
  06621	8b ec		 mov	 ebp, esp
  06623	83 ec 50	 sub	 esp, 80			; 00000050H
  06626	53		 push	 ebx
  06627	56		 push	 esi
  06628	57		 push	 edi
  06629	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2084 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0662c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  06630	7d 09		 jge	 SHORT $LN6@CheckPlayE
  06632	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06639	eb 0c		 jmp	 SHORT $LN7@CheckPlayE
$LN6@CheckPlayE:
  0663b	33 c0		 xor	 eax, eax
  0663d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  06641	0f 9e c0	 setle	 al
  06644	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckPlayE:
  06647	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0664b	75 04		 jne	 SHORT $LN3@CheckPlayE

; 2085 : 	{
; 2086 : 		return FALSE;

  0664d	33 c0		 xor	 eax, eax
  0664f	eb 40		 jmp	 SHORT $LN4@CheckPlayE
$LN3@CheckPlayE:

; 2087 : 	}
; 2088 : 
; 2089 : 	int iCUR_USER_COUNT = this->GetCurPlayUser(iChaosCastleIndex);

  06651	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06654	50		 push	 eax
  06655	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06658	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0665d	89 45 f8	 mov	 DWORD PTR _iCUR_USER_COUNT$[ebp], eax

; 2090 : 	int iCUR_MONSTER_COUNT = this->GetMonsterListCount(iChaosCastleIndex);

  06660	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06663	50		 push	 eax
  06664	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06667	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  0666c	89 45 f4	 mov	 DWORD PTR _iCUR_MONSTER_COUNT$[ebp], eax

; 2091 : 
; 2092 : 	if ( iCUR_USER_COUNT <= 0 )

  0666f	83 7d f8 00	 cmp	 DWORD PTR _iCUR_USER_COUNT$[ebp], 0
  06673	7f 07		 jg	 SHORT $LN2@CheckPlayE

; 2093 : 	{
; 2094 : 		return 2;

  06675	b8 02 00 00 00	 mov	 eax, 2
  0667a	eb 15		 jmp	 SHORT $LN4@CheckPlayE
$LN2@CheckPlayE:

; 2095 : 	}
; 2096 : 
; 2097 : 	if ( iCUR_USER_COUNT == 1 && iCUR_MONSTER_COUNT <= 0)

  0667c	83 7d f8 01	 cmp	 DWORD PTR _iCUR_USER_COUNT$[ebp], 1
  06680	75 0d		 jne	 SHORT $LN1@CheckPlayE
  06682	83 7d f4 00	 cmp	 DWORD PTR _iCUR_MONSTER_COUNT$[ebp], 0
  06686	7f 07		 jg	 SHORT $LN1@CheckPlayE

; 2098 : 	{
; 2099 : 		return 1;

  06688	b8 01 00 00 00	 mov	 eax, 1
  0668d	eb 02		 jmp	 SHORT $LN4@CheckPlayE
$LN1@CheckPlayE:

; 2100 : 	}
; 2101 : 
; 2102 : 	return 0;

  0668f	33 c0		 xor	 eax, eax
$LN4@CheckPlayE:

; 2103 : }

  06691	5f		 pop	 edi
  06692	5e		 pop	 esi
  06693	5b		 pop	 ebx
  06694	8b e5		 mov	 esp, ebp
  06696	5d		 pop	 ebp
  06697	c2 04 00	 ret	 4
?CheckPlayEnded@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckPlayEnded
_TEXT	ENDS
PUBLIC	?CheckCanEnter@CChaosCastle@@QAE_NH@Z		; CChaosCastle::CheckCanEnter
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckCanEnter@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckCanEnter
; _this$ = ecx

; 2106 : {

  066a0	55		 push	 ebp
  066a1	8b ec		 mov	 ebp, esp
  066a3	83 ec 48	 sub	 esp, 72			; 00000048H
  066a6	53		 push	 ebx
  066a7	56		 push	 esi
  066a8	57		 push	 edi
  066a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2107 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  066ac	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  066b0	7d 09		 jge	 SHORT $LN4@CheckCanEn
  066b2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  066b9	eb 0c		 jmp	 SHORT $LN5@CheckCanEn
$LN4@CheckCanEn:
  066bb	33 c0		 xor	 eax, eax
  066bd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  066c1	0f 9e c0	 setle	 al
  066c4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckCanEn:
  066c7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  066cb	75 04		 jne	 SHORT $LN1@CheckCanEn

; 2108 : 	{
; 2109 : 		return false;

  066cd	32 c0		 xor	 al, al
  066cf	eb 10		 jmp	 SHORT $LN2@CheckCanEn
$LN1@CheckCanEn:

; 2110 : 	}
; 2111 : 
; 2112 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER;

  066d1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  066d4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  066da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  066dd	8a 44 01 4c	 mov	 al, BYTE PTR [ecx+eax+76]
$LN2@CheckCanEn:

; 2113 : }

  066e1	5f		 pop	 edi
  066e2	5e		 pop	 esi
  066e3	5b		 pop	 ebx
  066e4	8b e5		 mov	 esp, ebp
  066e6	5d		 pop	 ebp
  066e7	c2 04 00	 ret	 4
?CheckCanEnter@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckCanEnter
_TEXT	ENDS
PUBLIC	?CheckPlayStart@CChaosCastle@@QAE_NH@Z		; CChaosCastle::CheckPlayStart
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckPlayStart@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckPlayStart
; _this$ = ecx

; 2116 : {

  066f0	55		 push	 ebp
  066f1	8b ec		 mov	 ebp, esp
  066f3	83 ec 48	 sub	 esp, 72			; 00000048H
  066f6	53		 push	 ebx
  066f7	56		 push	 esi
  066f8	57		 push	 edi
  066f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2117 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  066fc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  06700	7d 09		 jge	 SHORT $LN4@CheckPlayS
  06702	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06709	eb 0c		 jmp	 SHORT $LN5@CheckPlayS
$LN4@CheckPlayS:
  0670b	33 c0		 xor	 eax, eax
  0670d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  06711	0f 9e c0	 setle	 al
  06714	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckPlayS:
  06717	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0671b	75 04		 jne	 SHORT $LN1@CheckPlayS

; 2118 : 	{
; 2119 : 		return false;

  0671d	32 c0		 xor	 al, al
  0671f	eb 10		 jmp	 SHORT $LN2@CheckPlayS
$LN1@CheckPlayS:

; 2120 : 	}
; 2121 : 
; 2122 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START;

  06721	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06724	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0672a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0672d	8a 44 01 4e	 mov	 al, BYTE PTR [ecx+eax+78]
$LN2@CheckPlayS:

; 2123 : }

  06731	5f		 pop	 edi
  06732	5e		 pop	 esi
  06733	5b		 pop	 ebx
  06734	8b e5		 mov	 esp, ebp
  06736	5d		 pop	 ebp
  06737	c2 04 00	 ret	 4
?CheckPlayStart@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckPlayStart
_TEXT	ENDS
PUBLIC	??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@ ; `string'
EXTRN	?ExConfig@@3VcExConfigs@@A:BYTE			; ExConfig
;	COMDAT ??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@
CONST	SEGMENT
??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@ DB '['
	DB	'Chaos Castle] (%d) GetCurPlayUser() FAILED (UserCount:%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -76						; size = 4
_iEnteredUser$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckCanStartPlay
; _this$ = ecx

; 2126 : {

  06740	55		 push	 ebp
  06741	8b ec		 mov	 ebp, esp
  06743	83 ec 4c	 sub	 esp, 76			; 0000004cH
  06746	53		 push	 ebx
  06747	56		 push	 esi
  06748	57		 push	 edi
  06749	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2127 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0674c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  06750	7d 09		 jge	 SHORT $LN5@CheckCanSt
  06752	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06759	eb 0c		 jmp	 SHORT $LN6@CheckCanSt
$LN5@CheckCanSt:
  0675b	33 c0		 xor	 eax, eax
  0675d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  06761	0f 9e c0	 setle	 al
  06764	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN6@CheckCanSt:
  06767	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0676b	75 04		 jne	 SHORT $LN2@CheckCanSt

; 2128 : 	{
; 2129 : 		return false;

  0676d	32 c0		 xor	 al, al
  0676f	eb 39		 jmp	 SHORT $LN3@CheckCanSt
$LN2@CheckCanSt:

; 2130 : 	}
; 2131 : 
; 2132 : 	int iEnteredUser = this->GetCurPlayUser(iChaosCastleIndex);

  06771	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06774	50		 push	 eax
  06775	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06778	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0677d	89 45 f8	 mov	 DWORD PTR _iEnteredUser$[ebp], eax

; 2133 : 
; 2134 : 	if ( iEnteredUser < ExConfig.Event.Ex_CCMinPlayer )

  06780	8b 45 f8	 mov	 eax, DWORD PTR _iEnteredUser$[ebp]
  06783	3b 05 0c 08 00
	00		 cmp	 eax, DWORD PTR ?ExConfig@@3VcExConfigs@@A+2060
  06789	7d 1d		 jge	 SHORT $LN1@CheckCanSt

; 2135 : 	{
; 2136 : 		LogAddTD("[Chaos Castle] (%d) GetCurPlayUser() FAILED (UserCount:%d)", iChaosCastleIndex+1, iEnteredUser);

  0678b	8b 45 f8	 mov	 eax, DWORD PTR _iEnteredUser$[ebp]
  0678e	50		 push	 eax
  0678f	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  06792	83 c1 01	 add	 ecx, 1
  06795	51		 push	 ecx
  06796	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@
  0679b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  067a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2137 : 
; 2138 : 		return false;

  067a4	32 c0		 xor	 al, al
  067a6	eb 02		 jmp	 SHORT $LN3@CheckCanSt
$LN1@CheckCanSt:

; 2139 : 	}
; 2140 : 
; 2141 : 	return true;

  067a8	b0 01		 mov	 al, 1
$LN3@CheckCanSt:

; 2142 : }

  067aa	5f		 pop	 edi
  067ab	5e		 pop	 esi
  067ac	5b		 pop	 ebx
  067ad	8b e5		 mov	 esp, ebp
  067af	5d		 pop	 ebp
  067b0	c2 04 00	 ret	 4
?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckCanStartPlay
; Function compile flags: /Odtp /ZI
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentState@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentState
; _this$ = ecx

; 2145 : {

  067c0	55		 push	 ebp
  067c1	8b ec		 mov	 ebp, esp
  067c3	83 ec 48	 sub	 esp, 72			; 00000048H
  067c6	53		 push	 ebx
  067c7	56		 push	 esi
  067c8	57		 push	 edi
  067c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2146 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  067cc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  067d0	7d 09		 jge	 SHORT $LN4@GetCurrent@2
  067d2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  067d9	eb 0c		 jmp	 SHORT $LN5@GetCurrent@2
$LN4@GetCurrent@2:
  067db	33 c0		 xor	 eax, eax
  067dd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  067e1	0f 9e c0	 setle	 al
  067e4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GetCurrent@2:
  067e7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  067eb	75 07		 jne	 SHORT $LN1@GetCurrent@2

; 2147 : 	{
; 2148 : 		return -1;

  067ed	b8 ff ff ff ff	 mov	 eax, -1
  067f2	eb 10		 jmp	 SHORT $LN2@GetCurrent@2
$LN1@GetCurrent@2:

; 2149 : 	}
; 2150 : 
; 2151 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE;

  067f4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  067f7	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  067fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06800	8b 44 01 30	 mov	 eax, DWORD PTR [ecx+eax+48]
$LN2@GetCurrent@2:

; 2152 : }

  06804	5f		 pop	 edi
  06805	5e		 pop	 esi
  06806	5b		 pop	 ebx
  06807	8b e5		 mov	 esp, ebp
  06809	5d		 pop	 ebp
  0680a	c2 04 00	 ret	 4
?GetCurrentState@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentState
_TEXT	ENDS
PUBLIC	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurEnteredUser
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurEnteredUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurEnteredUser
; _this$ = ecx

; 2155 : {

  06810	55		 push	 ebp
  06811	8b ec		 mov	 ebp, esp
  06813	83 ec 48	 sub	 esp, 72			; 00000048H
  06816	53		 push	 ebx
  06817	56		 push	 esi
  06818	57		 push	 edi
  06819	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2156 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0681c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  06820	7d 09		 jge	 SHORT $LN4@GetCurEnte
  06822	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06829	eb 0c		 jmp	 SHORT $LN5@GetCurEnte
$LN4@GetCurEnte:
  0682b	33 c0		 xor	 eax, eax
  0682d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  06831	0f 9e c0	 setle	 al
  06834	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GetCurEnte:
  06837	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0683b	75 07		 jne	 SHORT $LN1@GetCurEnte

; 2157 : 	{
; 2158 : 		return -1;

  0683d	b8 ff ff ff ff	 mov	 eax, -1
  06842	eb 10		 jmp	 SHORT $LN2@GetCurEnte
$LN1@GetCurEnte:

; 2159 : 	}
; 2160 : 
; 2161 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER;

  06844	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06847	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0684d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06850	8b 44 01 54	 mov	 eax, DWORD PTR [ecx+eax+84]
$LN2@GetCurEnte:

; 2162 : }

  06854	5f		 pop	 edi
  06855	5e		 pop	 esi
  06856	5b		 pop	 ebx
  06857	8b e5		 mov	 esp, ebp
  06859	5d		 pop	 ebp
  0685a	c2 04 00	 ret	 4
?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurEnteredUser
; Function compile flags: /Odtp /ZI
tv67 = -80						; size = 4
_i$238453 = -12						; size = 4
_iPlayUser$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurPlayUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurPlayUser
; _this$ = ecx

; 2165 : {

  06860	55		 push	 ebp
  06861	8b ec		 mov	 ebp, esp
  06863	83 ec 50	 sub	 esp, 80			; 00000050H
  06866	53		 push	 ebx
  06867	56		 push	 esi
  06868	57		 push	 edi
  06869	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2166 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0686c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  06870	7d 09		 jge	 SHORT $LN9@GetCurPlay
  06872	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06879	eb 0c		 jmp	 SHORT $LN10@GetCurPlay
$LN9@GetCurPlay:
  0687b	33 c0		 xor	 eax, eax
  0687d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  06881	0f 9e c0	 setle	 al
  06884	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@GetCurPlay:
  06887	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0688b	75 0a		 jne	 SHORT $LN6@GetCurPlay

; 2167 : 	{
; 2168 : 		return -1;

  0688d	b8 ff ff ff ff	 mov	 eax, -1
  06892	e9 b7 00 00 00	 jmp	 $LN7@GetCurPlay
$LN6@GetCurPlay:

; 2169 : 	}
; 2170 : 
; 2171 : 	int iPlayUser = 0;

  06897	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iPlayUser$[ebp], 0

; 2172 : 
; 2173 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0689e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238453[ebp], 0
  068a5	eb 09		 jmp	 SHORT $LN5@GetCurPlay
$LN4@GetCurPlay:
  068a7	8b 45 f4	 mov	 eax, DWORD PTR _i$238453[ebp]
  068aa	83 c0 01	 add	 eax, 1
  068ad	89 45 f4	 mov	 DWORD PTR _i$238453[ebp], eax
$LN5@GetCurPlay:
  068b0	83 7d f4 46	 cmp	 DWORD PTR _i$238453[ebp], 70 ; 00000046H
  068b4	0f 8d 91 00 00
	00		 jge	 $LN3@GetCurPlay

; 2174 : 	{
; 2175 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  068ba	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  068bd	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  068c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  068c6	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  068ca	8b 45 f4	 mov	 eax, DWORD PTR _i$238453[ebp]
  068cd	6b c0 14	 imul	 eax, 20			; 00000014H
  068d0	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  068d5	74 6f		 je	 SHORT $LN2@GetCurPlay

; 2176 : 		{
; 2177 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 2178 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  068d7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  068da	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  068e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  068e3	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  068e7	8b 45 f4	 mov	 eax, DWORD PTR _i$238453[ebp]
  068ea	6b c0 14	 imul	 eax, 20			; 00000014H
  068ed	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  068f1	51		 push	 ecx
  068f2	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  068f7	83 c4 04	 add	 esp, 4
  068fa	83 f8 01	 cmp	 eax, 1
  068fd	75 47		 jne	 SHORT $LN2@GetCurPlay
  068ff	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06902	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  06908	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0690b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0690f	8b 45 f4	 mov	 eax, DWORD PTR _i$238453[ebp]
  06912	6b c0 14	 imul	 eax, 20			; 00000014H
  06915	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  06919	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0691f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06925	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  0692d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06930	50		 push	 eax
  06931	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06934	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  06939	3b f0		 cmp	 esi, eax
  0693b	75 09		 jne	 SHORT $LN2@GetCurPlay

; 2179 : 			{
; 2180 : 				iPlayUser++;

  0693d	8b 45 f8	 mov	 eax, DWORD PTR _iPlayUser$[ebp]
  06940	83 c0 01	 add	 eax, 1
  06943	89 45 f8	 mov	 DWORD PTR _iPlayUser$[ebp], eax
$LN2@GetCurPlay:

; 2181 : 			}
; 2182 : 		}
; 2183 : 	}

  06946	e9 5c ff ff ff	 jmp	 $LN4@GetCurPlay
$LN3@GetCurPlay:

; 2184 : 
; 2185 : 	return iPlayUser;

  0694b	8b 45 f8	 mov	 eax, DWORD PTR _iPlayUser$[ebp]
$LN7@GetCurPlay:

; 2186 : }

  0694e	5f		 pop	 edi
  0694f	5e		 pop	 esi
  06950	5b		 pop	 ebx
  06951	8b e5		 mov	 esp, ebp
  06953	5d		 pop	 ebp
  06954	c2 04 00	 ret	 4
?GetCurPlayUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurPlayUser
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetRemainTime@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetRemainTime
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv187 = -144						; size = 4
$T242233 = -140						; size = 4
$T242234 = -136						; size = 4
$T242235 = -132						; size = 4
$T242236 = -128						; size = 4
$T242237 = -124						; size = 4
$T242238 = -120						; size = 4
_pRET$238491 = -52					; size = 4
_pRET$238481 = -48					; size = 4
_it$238474 = -44					; size = 4
_bTIME_CHANGED$238469 = -40				; size = 4
_iMIN_MINUTE$238468 = -36				; size = 4
_iMIN_HOUR$238467 = -32					; size = 4
_sysTime$238466 = -28					; size = 16
_iREMAIN_MINUTE$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetRemainTime@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetRemainTime
; _this$ = ecx

; 2189 : {

  06960	55		 push	 ebp
  06961	8b ec		 mov	 ebp, esp
  06963	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  06969	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0696e	33 c5		 xor	 eax, ebp
  06970	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06973	53		 push	 ebx
  06974	56		 push	 esi
  06975	57		 push	 edi
  06976	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2190 : 	int iREMAIN_MINUTE = 0;

  06979	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0

; 2191 : 
; 2192 : 	if ( this->GetCurrentState(iChaosCastleIndex) == 1 )

  06980	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06983	50		 push	 eax
  06984	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06987	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  0698c	83 f8 01	 cmp	 eax, 1
  0698f	75 29		 jne	 SHORT $LN18@GetRemainT

; 2193 : 	{
; 2194 : 		iREMAIN_MINUTE = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000 - this->m_iCC_TIME_MIN_OPEN + 1;

  06991	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06994	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0699a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0699d	8b 44 01 40	 mov	 eax, DWORD PTR [ecx+eax+64]
  069a1	99		 cdq
  069a2	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  069a7	f7 f9		 idiv	 ecx
  069a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  069ac	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  069af	83 c0 01	 add	 eax, 1
  069b2	89 45 f4	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 2195 : 	}
; 2196 : 	else

  069b5	e9 0f 02 00 00	 jmp	 $LN17@GetRemainT
$LN18@GetRemainT:

; 2197 : 	{
; 2198 : 		SYSTEMTIME sysTime;
; 2199 : 		GetLocalTime(&sysTime);

  069ba	8d 45 e4	 lea	 eax, DWORD PTR _sysTime$238466[ebp]
  069bd	50		 push	 eax
  069be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 2200 : 		int iMIN_HOUR = 24;

  069c4	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$238467[ebp], 24 ; 00000018H

; 2201 : 		int iMIN_MINUTE = 60;

  069cb	c7 45 dc 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$238468[ebp], 60 ; 0000003cH

; 2202 : 		BOOL bTIME_CHANGED = FALSE;

  069d2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$238469[ebp], 0

; 2203 : 		std::vector<CHAOSCASTLE_START_TIME>::iterator it;

  069d9	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  069dc	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >

; 2204 : 
; 2205 : 		for( it = this->m_vtChaosCastleOpenTime.begin();  it != this->m_vtChaosCastleOpenTime.end(); it++)

  069e1	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T242233[ebp]
  069e7	50		 push	 eax
  069e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  069eb	83 c1 20	 add	 ecx, 32			; 00000020H
  069ee	e8 00 00 00 00	 call	 ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
  069f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  069f5	89 4d d4	 mov	 DWORD PTR _it$238474[ebp], ecx
  069f8	eb 11		 jmp	 SHORT $LN16@GetRemainT
$LN15@GetRemainT:
  069fa	6a 00		 push	 0
  069fc	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T242234[ebp]
  06a02	50		 push	 eax
  06a03	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  06a06	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
$LN16@GetRemainT:
  06a0b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T242235[ebp]
  06a11	50		 push	 eax
  06a12	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06a15	83 c1 20	 add	 ecx, 32			; 00000020H
  06a18	e8 00 00 00 00	 call	 ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
  06a1d	50		 push	 eax
  06a1e	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  06a21	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
  06a26	0f b6 c8	 movzx	 ecx, al
  06a29	85 c9		 test	 ecx, ecx
  06a2b	74 62		 je	 SHORT $LN14@GetRemainT

; 2206 : 		{
; 2207 : 			CHAOSCASTLE_START_TIME & pRET = *it;

  06a2d	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  06a30	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
  06a35	89 45 d0	 mov	 DWORD PTR _pRET$238481[ebp], eax

; 2208 : 			
; 2209 : 			if ( (sysTime.wHour * 60 + sysTime.wMinute) < (pRET.m_iHour * 60 + pRET.m_iMinute))

  06a38	0f b7 45 ec	 movzx	 eax, WORD PTR _sysTime$238466[ebp+8]
  06a3c	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06a3f	0f b7 4d ee	 movzx	 ecx, WORD PTR _sysTime$238466[ebp+10]
  06a43	03 c1		 add	 eax, ecx
  06a45	8b 55 d0	 mov	 edx, DWORD PTR _pRET$238481[ebp]
  06a48	8b 0a		 mov	 ecx, DWORD PTR [edx]
  06a4a	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  06a4d	8b 55 d0	 mov	 edx, DWORD PTR _pRET$238481[ebp]
  06a50	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  06a53	3b c1		 cmp	 eax, ecx
  06a55	7d 33		 jge	 SHORT $LN13@GetRemainT

; 2210 : 			{
; 2211 : 				if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute))

  06a57	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_HOUR$238467[ebp]
  06a5a	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06a5d	03 45 dc	 add	 eax, DWORD PTR _iMIN_MINUTE$238468[ebp]
  06a60	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$238481[ebp]
  06a63	8b 11		 mov	 edx, DWORD PTR [ecx]
  06a65	6b d2 3c	 imul	 edx, 60			; 0000003cH
  06a68	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$238481[ebp]
  06a6b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  06a6e	3b c2		 cmp	 eax, edx
  06a70	7e 18		 jle	 SHORT $LN13@GetRemainT

; 2212 : 				{
; 2213 : 					bTIME_CHANGED = 1;

  06a72	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$238469[ebp], 1

; 2214 : 					iMIN_HOUR = pRET.m_iHour;

  06a79	8b 45 d0	 mov	 eax, DWORD PTR _pRET$238481[ebp]
  06a7c	8b 08		 mov	 ecx, DWORD PTR [eax]
  06a7e	89 4d e0	 mov	 DWORD PTR _iMIN_HOUR$238467[ebp], ecx

; 2215 : 					iMIN_MINUTE = pRET.m_iMinute;

  06a81	8b 45 d0	 mov	 eax, DWORD PTR _pRET$238481[ebp]
  06a84	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  06a87	89 4d dc	 mov	 DWORD PTR _iMIN_MINUTE$238468[ebp], ecx
$LN13@GetRemainT:

; 2216 : 				}
; 2217 : 			}
; 2218 : 		}

  06a8a	e9 6b ff ff ff	 jmp	 $LN15@GetRemainT
$LN14@GetRemainT:

; 2219 : 					
; 2220 : 		if ( bTIME_CHANGED == 0 )

  06a8f	83 7d d8 00	 cmp	 DWORD PTR _bTIME_CHANGED$238469[ebp], 0
  06a93	0f 85 91 00 00
	00		 jne	 $LN11@GetRemainT

; 2221 : 		{
; 2222 : 			it = this->m_vtChaosCastleOpenTime.begin();

  06a99	8d 45 80	 lea	 eax, DWORD PTR $T242236[ebp]
  06a9c	50		 push	 eax
  06a9d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06aa0	83 c1 20	 add	 ecx, 32			; 00000020H
  06aa3	e8 00 00 00 00	 call	 ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
  06aa8	8b 08		 mov	 ecx, DWORD PTR [eax]
  06aaa	89 4d d4	 mov	 DWORD PTR _it$238474[ebp], ecx

; 2223 : 			iMIN_HOUR = 24;

  06aad	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$238467[ebp], 24 ; 00000018H

; 2224 : 			iMIN_MINUTE = 60;

  06ab4	c7 45 dc 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$238468[ebp], 60 ; 0000003cH
  06abb	eb 0e		 jmp	 SHORT $LN10@GetRemainT
$LN9@GetRemainT:

; 2225 : 
; 2226 : 			for(; it != this->m_vtChaosCastleOpenTime.end(); it++)

  06abd	6a 00		 push	 0
  06abf	8d 45 84	 lea	 eax, DWORD PTR $T242237[ebp]
  06ac2	50		 push	 eax
  06ac3	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  06ac6	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
$LN10@GetRemainT:
  06acb	8d 45 88	 lea	 eax, DWORD PTR $T242238[ebp]
  06ace	50		 push	 eax
  06acf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06ad2	83 c1 20	 add	 ecx, 32			; 00000020H
  06ad5	e8 00 00 00 00	 call	 ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
  06ada	50		 push	 eax
  06adb	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  06ade	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
  06ae3	0f b6 c8	 movzx	 ecx, al
  06ae6	85 c9		 test	 ecx, ecx
  06ae8	74 40		 je	 SHORT $LN11@GetRemainT

; 2227 : 			{
; 2228 : 				CHAOSCASTLE_START_TIME & pRET = *it;

  06aea	8d 4d d4	 lea	 ecx, DWORD PTR _it$238474[ebp]
  06aed	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
  06af2	89 45 cc	 mov	 DWORD PTR _pRET$238491[ebp], eax

; 2229 : 			
; 2230 : 				if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute))

  06af5	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_HOUR$238467[ebp]
  06af8	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06afb	03 45 dc	 add	 eax, DWORD PTR _iMIN_MINUTE$238468[ebp]
  06afe	8b 4d cc	 mov	 ecx, DWORD PTR _pRET$238491[ebp]
  06b01	8b 11		 mov	 edx, DWORD PTR [ecx]
  06b03	6b d2 3c	 imul	 edx, 60			; 0000003cH
  06b06	8b 4d cc	 mov	 ecx, DWORD PTR _pRET$238491[ebp]
  06b09	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  06b0c	3b c2		 cmp	 eax, edx
  06b0e	7e 18		 jle	 SHORT $LN7@GetRemainT

; 2231 : 				{
; 2232 : 					bTIME_CHANGED = 2;

  06b10	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$238469[ebp], 2

; 2233 : 					iMIN_HOUR = pRET.m_iHour;

  06b17	8b 45 cc	 mov	 eax, DWORD PTR _pRET$238491[ebp]
  06b1a	8b 08		 mov	 ecx, DWORD PTR [eax]
  06b1c	89 4d e0	 mov	 DWORD PTR _iMIN_HOUR$238467[ebp], ecx

; 2234 : 					iMIN_MINUTE = pRET.m_iMinute;

  06b1f	8b 45 cc	 mov	 eax, DWORD PTR _pRET$238491[ebp]
  06b22	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  06b25	89 4d dc	 mov	 DWORD PTR _iMIN_MINUTE$238468[ebp], ecx
$LN7@GetRemainT:

; 2235 : 				}
; 2236 : 			}

  06b28	eb 93		 jmp	 SHORT $LN9@GetRemainT
$LN11@GetRemainT:

; 2237 : 		}
; 2238 : 
; 2239 : 		switch ( bTIME_CHANGED )

  06b2a	8b 45 d8	 mov	 eax, DWORD PTR _bTIME_CHANGED$238469[ebp]
  06b2d	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv187[ebp], eax
  06b33	83 bd 70 ff ff
	ff 01		 cmp	 DWORD PTR tv187[ebp], 1
  06b3a	74 0b		 je	 SHORT $LN4@GetRemainT
  06b3c	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR tv187[ebp], 2
  06b43	74 3e		 je	 SHORT $LN3@GetRemainT
  06b45	eb 7b		 jmp	 SHORT $LN2@GetRemainT
$LN4@GetRemainT:

; 2240 : 		{
; 2241 : 			case 1:
; 2242 : 				iREMAIN_MINUTE = (((iMIN_HOUR * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond))) /60 + 1;

  06b47	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_HOUR$238467[ebp]
  06b4a	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06b4d	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06b50	8b 4d dc	 mov	 ecx, DWORD PTR _iMIN_MINUTE$238468[ebp]
  06b53	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  06b56	03 c1		 add	 eax, ecx
  06b58	0f b7 55 ec	 movzx	 edx, WORD PTR _sysTime$238466[ebp+8]
  06b5c	6b d2 3c	 imul	 edx, 60			; 0000003cH
  06b5f	6b d2 3c	 imul	 edx, 60			; 0000003cH
  06b62	0f b7 4d ee	 movzx	 ecx, WORD PTR _sysTime$238466[ebp+10]
  06b66	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  06b69	03 d1		 add	 edx, ecx
  06b6b	0f b7 4d f0	 movzx	 ecx, WORD PTR _sysTime$238466[ebp+12]
  06b6f	03 d1		 add	 edx, ecx
  06b71	2b c2		 sub	 eax, edx
  06b73	99		 cdq
  06b74	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  06b79	f7 f9		 idiv	 ecx
  06b7b	83 c0 01	 add	 eax, 1
  06b7e	89 45 f4	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 2243 : 				break;

  06b81	eb 46		 jmp	 SHORT $LN17@GetRemainT
$LN3@GetRemainT:

; 2244 : 			case 2:
; 2245 : 				iREMAIN_MINUTE = ((((iMIN_HOUR + 24) * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond)) ) / 60 + 1;

  06b83	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_HOUR$238467[ebp]
  06b86	83 c0 18	 add	 eax, 24			; 00000018H
  06b89	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06b8c	6b c0 3c	 imul	 eax, 60			; 0000003cH
  06b8f	8b 4d dc	 mov	 ecx, DWORD PTR _iMIN_MINUTE$238468[ebp]
  06b92	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  06b95	03 c1		 add	 eax, ecx
  06b97	0f b7 55 ec	 movzx	 edx, WORD PTR _sysTime$238466[ebp+8]
  06b9b	6b d2 3c	 imul	 edx, 60			; 0000003cH
  06b9e	6b d2 3c	 imul	 edx, 60			; 0000003cH
  06ba1	0f b7 4d ee	 movzx	 ecx, WORD PTR _sysTime$238466[ebp+10]
  06ba5	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  06ba8	03 d1		 add	 edx, ecx
  06baa	0f b7 4d f0	 movzx	 ecx, WORD PTR _sysTime$238466[ebp+12]
  06bae	03 d1		 add	 edx, ecx
  06bb0	2b c2		 sub	 eax, edx
  06bb2	99		 cdq
  06bb3	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  06bb8	f7 f9		 idiv	 ecx
  06bba	83 c0 01	 add	 eax, 1
  06bbd	89 45 f4	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 2246 : 				break;

  06bc0	eb 07		 jmp	 SHORT $LN17@GetRemainT
$LN2@GetRemainT:

; 2247 : 			default:
; 2248 : 				iREMAIN_MINUTE = -1;

  06bc2	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], -1
$LN17@GetRemainT:

; 2249 : 				break;
; 2250 : 		}
; 2251 : 	}
; 2252 : 
; 2253 : 	if ( iREMAIN_MINUTE < 0 )

  06bc9	83 7d f4 00	 cmp	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0
  06bcd	7d 07		 jge	 SHORT $LN1@GetRemainT

; 2254 : 	{
; 2255 : 		iREMAIN_MINUTE = 0;

  06bcf	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0
$LN1@GetRemainT:

; 2256 : 	}
; 2257 : 
; 2258 : 	return iREMAIN_MINUTE;

  06bd6	8b 45 f4	 mov	 eax, DWORD PTR _iREMAIN_MINUTE$[ebp]

; 2259 : }

  06bd9	5f		 pop	 edi
  06bda	5e		 pop	 esi
  06bdb	5b		 pop	 ebx
  06bdc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06bdf	33 cd		 xor	 ecx, ebp
  06be1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06be6	8b e5		 mov	 esp, ebp
  06be8	5d		 pop	 ebp
  06be9	c2 04 00	 ret	 4
?GetRemainTime@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetRemainTime
_TEXT	ENDS
PUBLIC	?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurrentRemainSec
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentRemainSec
; _this$ = ecx

; 2262 : {

  06bf0	55		 push	 ebp
  06bf1	8b ec		 mov	 ebp, esp
  06bf3	83 ec 44	 sub	 esp, 68			; 00000044H
  06bf6	53		 push	 ebx
  06bf7	56		 push	 esi
  06bf8	57		 push	 edi
  06bf9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2263 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 1000;

  06bfc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  06bff	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  06c05	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06c08	8b 44 01 40	 mov	 eax, DWORD PTR [ecx+eax+64]
  06c0c	99		 cdq
  06c0d	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  06c12	f7 f9		 idiv	 ecx

; 2264 : }

  06c14	5f		 pop	 edi
  06c15	5e		 pop	 esi
  06c16	5b		 pop	 ebx
  06c17	8b e5		 mov	 esp, ebp
  06c19	5d		 pop	 ebp
  06c1a	c2 04 00	 ret	 4
?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentRemainSec
_TEXT	ENDS
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv81 = -100						; size = 4
tv82 = -96						; size = 4
tv67 = -96						; size = 4
_pMove2$ = -28						; size = 7
_pMove$ = -20						; size = 5
_btMapAttr$ = -9					; size = 1
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?ObjSetPosition@CChaosCastle@@QAEHHHH@Z PROC		; CChaosCastle::ObjSetPosition
; _this$ = ecx

; 2267 : {

  06c20	55		 push	 ebp
  06c21	8b ec		 mov	 ebp, esp
  06c23	83 ec 64	 sub	 esp, 100		; 00000064H
  06c26	53		 push	 ebx
  06c27	56		 push	 esi
  06c28	57		 push	 edi
  06c29	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2268 : 	if ( !OBJMAX_RANGE(iIndex))

  06c2c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  06c30	7d 09		 jge	 SHORT $LN9@ObjSetPosi
  06c32	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06c39	eb 0f		 jmp	 SHORT $LN10@ObjSetPosi
$LN9@ObjSetPosi:
  06c3b	33 c0		 xor	 eax, eax
  06c3d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  06c44	0f 9e c0	 setle	 al
  06c47	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@ObjSetPosi:
  06c4a	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  06c4e	75 0a		 jne	 SHORT $LN6@ObjSetPosi

; 2269 : 		return TRUE;

  06c50	b8 01 00 00 00	 mov	 eax, 1
  06c55	e9 b2 02 00 00	 jmp	 $LN7@ObjSetPosi
$LN6@ObjSetPosi:

; 2270 : 
; 2271 : 	LPOBJ lpObj = &gObj[iIndex];

  06c5a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06c5d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06c63	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06c69	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2272 : 
; 2273 : 	if ( !CC_MAP_RANGE(lpObj->MapNumber))

  06c6c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06c6f	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  06c76	83 f9 35	 cmp	 ecx, 53			; 00000035H
  06c79	75 09		 jne	 SHORT $LN13@ObjSetPosi
  06c7b	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  06c82	eb 33		 jmp	 SHORT $LN14@ObjSetPosi
$LN13@ObjSetPosi:
  06c84	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  06c87	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  06c8e	83 f8 12	 cmp	 eax, 18			; 00000012H
  06c91	7d 09		 jge	 SHORT $LN11@ObjSetPosi
  06c93	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  06c9a	eb 15		 jmp	 SHORT $LN12@ObjSetPosi
$LN11@ObjSetPosi:
  06c9c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06c9f	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  06ca6	33 c0		 xor	 eax, eax
  06ca8	83 fa 17	 cmp	 edx, 23			; 00000017H
  06cab	0f 9e c0	 setle	 al
  06cae	89 45 9c	 mov	 DWORD PTR tv81[ebp], eax
$LN12@ObjSetPosi:
  06cb1	8b 4d 9c	 mov	 ecx, DWORD PTR tv81[ebp]
  06cb4	89 4d a0	 mov	 DWORD PTR tv82[ebp], ecx
$LN14@ObjSetPosi:
  06cb7	83 7d a0 00	 cmp	 DWORD PTR tv82[ebp], 0
  06cbb	75 07		 jne	 SHORT $LN5@ObjSetPosi

; 2274 : 		return FALSE;

  06cbd	33 c0		 xor	 eax, eax
  06cbf	e9 48 02 00 00	 jmp	 $LN7@ObjSetPosi
$LN5@ObjSetPosi:

; 2275 : 
; 2276 : 	if ( lpObj->Teleport )

  06cc4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06cc7	0f be 88 a0 03
	00 00		 movsx	 ecx, BYTE PTR [eax+928]
  06cce	85 c9		 test	 ecx, ecx
  06cd0	74 0a		 je	 SHORT $LN4@ObjSetPosi

; 2277 : 		return TRUE;

  06cd2	b8 01 00 00 00	 mov	 eax, 1
  06cd7	e9 30 02 00 00	 jmp	 $LN7@ObjSetPosi
$LN4@ObjSetPosi:

; 2278 : 
; 2279 : 	BYTE btMapAttr = MapC[lpObj->MapNumber].GetAttr(iX, iY);

  06cdc	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  06cdf	50		 push	 eax
  06ce0	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  06ce3	51		 push	 ecx
  06ce4	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  06ce7	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  06cee	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06cf4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  06cfa	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  06cff	88 45 f7	 mov	 BYTE PTR _btMapAttr$[ebp], al

; 2280 : 
; 2281 : 	if ( (btMapAttr&2) == 2 || (btMapAttr&4) == 4 )

  06d02	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  06d06	83 e0 02	 and	 eax, 2
  06d09	75 09		 jne	 SHORT $LN2@ObjSetPosi
  06d0b	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  06d0f	83 e0 04	 and	 eax, 4
  06d12	74 07		 je	 SHORT $LN3@ObjSetPosi
$LN2@ObjSetPosi:

; 2282 : 		return FALSE;

  06d14	33 c0		 xor	 eax, eax
  06d16	e9 f1 01 00 00	 jmp	 $LN7@ObjSetPosi
$LN3@ObjSetPosi:

; 2283 : 
; 2284 : 	PMSG_POSISTION_SET pMove;
; 2285 : 
; 2286 : 	pMove.h.c = 0xC1;

  06d1b	c6 45 ec c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H

; 2287 : 	pMove.h.headcode = PROTOCOL_POSITION;

  06d1f	c6 45 ee 15	 mov	 BYTE PTR _pMove$[ebp+2], 21 ; 00000015H

; 2288 : 	pMove.h.size = sizeof(pMove);

  06d23	c6 45 ed 05	 mov	 BYTE PTR _pMove$[ebp+1], 5

; 2289 : 	pMove.X = iX;

  06d27	8a 45 0c	 mov	 al, BYTE PTR _iX$[ebp]
  06d2a	88 45 ef	 mov	 BYTE PTR _pMove$[ebp+3], al

; 2290 : 	pMove.Y = iY;

  06d2d	8a 45 10	 mov	 al, BYTE PTR _iY$[ebp]
  06d30	88 45 f0	 mov	 BYTE PTR _pMove$[ebp+4], al

; 2291 : 
; 2292 : 	lpObj->m_Rest = 0;

  06d33	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06d36	c6 80 25 02 00
	00 00		 mov	 BYTE PTR [eax+549], 0

; 2293 : 
; 2294 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX,lpObj->m_OldY);

  06d3d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06d40	0f bf 88 7a 01
	00 00		 movsx	 ecx, WORD PTR [eax+378]
  06d47	51		 push	 ecx
  06d48	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  06d4b	0f bf 82 78 01
	00 00		 movsx	 eax, WORD PTR [edx+376]
  06d52	50		 push	 eax
  06d53	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06d56	0f b6 89 49 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+329]
  06d5d	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06d63	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  06d69	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2295 : 	MapC[lpObj->MapNumber].SetStandAttr(iX,iY);

  06d6e	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  06d71	50		 push	 eax
  06d72	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  06d75	51		 push	 ecx
  06d76	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  06d79	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  06d80	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06d86	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  06d8c	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2296 : 
; 2297 : 	lpObj->m_OldX = iX;

  06d91	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06d94	66 8b 4d 0c	 mov	 cx, WORD PTR _iX$[ebp]
  06d98	66 89 88 78 01
	00 00		 mov	 WORD PTR [eax+376], cx

; 2298 : 	lpObj->m_OldY = iY;

  06d9f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06da2	66 8b 4d 10	 mov	 cx, WORD PTR _iY$[ebp]
  06da6	66 89 88 7a 01
	00 00		 mov	 WORD PTR [eax+378], cx

; 2299 : 
; 2300 : 	lpObj->X = pMove.X;

  06dad	66 0f b6 45 ef	 movzx	 ax, BYTE PTR _pMove$[ebp+3]
  06db2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06db5	66 89 81 44 01
	00 00		 mov	 WORD PTR [ecx+324], ax

; 2301 : 	lpObj->Y = pMove.Y;

  06dbc	66 0f b6 45 f0	 movzx	 ax, BYTE PTR _pMove$[ebp+4]
  06dc1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06dc4	66 89 81 46 01
	00 00		 mov	 WORD PTR [ecx+326], ax

; 2302 : 
; 2303 : 	PMSG_RECV_POSISTION_SET pMove2;
; 2304 : 
; 2305 : 	PHeadSetB((LPBYTE)&pMove2, PROTOCOL_POSITION, sizeof(pMove2));

  06dcb	6a 07		 push	 7
  06dcd	6a 15		 push	 21			; 00000015H
  06dcf	8d 45 e4	 lea	 eax, DWORD PTR _pMove2$[ebp]
  06dd2	50		 push	 eax
  06dd3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  06dd8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2306 : 	pMove2.NumberH = SET_NUMBERH(iIndex);

  06ddb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06dde	c1 e8 08	 shr	 eax, 8
  06de1	88 45 e7	 mov	 BYTE PTR _pMove2$[ebp+3], al

; 2307 : 	pMove2.NumberL = SET_NUMBERL(iIndex);

  06de4	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06de7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  06dec	88 45 e8	 mov	 BYTE PTR _pMove2$[ebp+4], al

; 2308 : 	pMove2.X = pMove.X;

  06def	8a 45 ef	 mov	 al, BYTE PTR _pMove$[ebp+3]
  06df2	88 45 e9	 mov	 BYTE PTR _pMove2$[ebp+5], al

; 2309 : 	pMove2.Y = pMove.Y;

  06df5	8a 45 f0	 mov	 al, BYTE PTR _pMove$[ebp+4]
  06df8	88 45 ea	 mov	 BYTE PTR _pMove2$[ebp+6], al

; 2310 : 	lpObj->TX = pMove.X;

  06dfb	66 0f b6 45 ef	 movzx	 ax, BYTE PTR _pMove$[ebp+3]
  06e00	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06e03	66 89 81 7c 01
	00 00		 mov	 WORD PTR [ecx+380], ax

; 2311 : 	lpObj->TY = pMove.Y;

  06e0a	66 0f b6 45 f0	 movzx	 ax, BYTE PTR _pMove$[ebp+4]
  06e0f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06e12	66 89 81 7e 01
	00 00		 mov	 WORD PTR [ecx+382], ax

; 2312 : 
; 2313 : 	CreateFrustrum(lpObj->X, lpObj->Y, iIndex);

  06e19	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06e1c	50		 push	 eax
  06e1d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06e20	0f bf 91 46 01
	00 00		 movsx	 edx, WORD PTR [ecx+326]
  06e27	52		 push	 edx
  06e28	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06e2b	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  06e32	51		 push	 ecx
  06e33	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  06e38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2314 : 
; 2315 : 	if ( lpObj->Type == OBJ_USER )

  06e3b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06e3e	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  06e42	83 f9 01	 cmp	 ecx, 1
  06e45	75 15		 jne	 SHORT $LN1@ObjSetPosi

; 2316 : 	{
; 2317 : 		DataSend(iIndex, (LPBYTE)&pMove2, pMove2.h.size);

  06e47	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMove2$[ebp+1]
  06e4b	50		 push	 eax
  06e4c	8d 4d e4	 lea	 ecx, DWORD PTR _pMove2$[ebp]
  06e4f	51		 push	 ecx
  06e50	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  06e53	52		 push	 edx
  06e54	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  06e59	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ObjSetPosi:

; 2318 : 	}
; 2319 : 
; 2320 : 	MsgSendV2(&gObj[iIndex], (LPBYTE)&pMove2, pMove2.h.size);

  06e5c	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMove2$[ebp+1]
  06e60	50		 push	 eax
  06e61	8d 4d e4	 lea	 ecx, DWORD PTR _pMove2$[ebp]
  06e64	51		 push	 ecx
  06e65	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  06e68	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  06e6e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06e74	52		 push	 edx
  06e75	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  06e7a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2321 : 
; 2322 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  06e7d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06e80	0f bf 88 7a 01
	00 00		 movsx	 ecx, WORD PTR [eax+378]
  06e87	51		 push	 ecx
  06e88	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  06e8b	0f bf 82 78 01
	00 00		 movsx	 eax, WORD PTR [edx+376]
  06e92	50		 push	 eax
  06e93	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06e96	0f b6 89 49 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+329]
  06e9d	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06ea3	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  06ea9	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2323 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  06eae	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06eb1	0f bf 88 7e 01
	00 00		 movsx	 ecx, WORD PTR [eax+382]
  06eb8	51		 push	 ecx
  06eb9	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  06ebc	0f bf 82 7c 01
	00 00		 movsx	 eax, WORD PTR [edx+380]
  06ec3	50		 push	 eax
  06ec4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06ec7	0f b6 89 49 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+329]
  06ece	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06ed4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  06eda	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2324 : 
; 2325 : 	lpObj->m_OldX = lpObj->TX;

  06edf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06ee2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06ee5	66 8b 91 7c 01
	00 00		 mov	 dx, WORD PTR [ecx+380]
  06eec	66 89 90 78 01
	00 00		 mov	 WORD PTR [eax+376], dx

; 2326 : 	lpObj->m_OldY = lpObj->TY;

  06ef3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06ef6	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  06ef9	66 8b 91 7e 01
	00 00		 mov	 dx, WORD PTR [ecx+382]
  06f00	66 89 90 7a 01
	00 00		 mov	 WORD PTR [eax+378], dx

; 2327 : 
; 2328 : 	return TRUE;

  06f07	b8 01 00 00 00	 mov	 eax, 1
$LN7@ObjSetPosi:

; 2329 : }

  06f0c	5f		 pop	 edi
  06f0d	5e		 pop	 esi
  06f0e	5b		 pop	 ebx
  06f0f	8b e5		 mov	 esp, ebp
  06f11	5d		 pop	 ebp
  06f12	c2 0c 00	 ret	 12			; 0000000cH
?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ENDP		; CChaosCastle::ObjSetPosition
_TEXT	ENDS
PUBLIC	??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ ; `string'
PUBLIC	?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z	; CChaosCastle::BlowObjsFromPoint
PUBLIC	?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z	; CChaosCastle::SearchNBlowObjs
;	COMDAT ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
CONST	SEGMENT
??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall '
	DB	'from Castle (X:%d, Y:%d)', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv68 = -108						; size = 4
tv79 = -104						; size = 4
tv74 = -104						; size = 4
tv69 = -104						; size = 4
_btMapAttr$238555 = -33					; size = 1
_iIndex$238552 = -32					; size = 4
_iChaosCastleIndex$238550 = -28				; size = 4
_i$238546 = -24						; size = 4
_iMAX_Y$ = -20						; size = 4
_iMIN_Y$ = -16						; size = 4
_iMAX_X$ = -12						; size = 4
_iMIN_X$ = -8						; size = 4
_this$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z PROC		; CChaosCastle::SearchNBlowObjs
; _this$ = ecx

; 2332 : {

  06f20	55		 push	 ebp
  06f21	8b ec		 mov	 ebp, esp
  06f23	83 ec 6c	 sub	 esp, 108		; 0000006cH
  06f26	53		 push	 ebx
  06f27	56		 push	 esi
  06f28	57		 push	 edi
  06f29	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2333 : 	if ( !CC_MAP_RANGE(iMapNumber))

  06f2c	83 7d 08 35	 cmp	 DWORD PTR _iMapNumber$[ebp], 53 ; 00000035H
  06f30	75 09		 jne	 SHORT $LN19@SearchNBlo
  06f32	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  06f39	eb 21		 jmp	 SHORT $LN20@SearchNBlo
$LN19@SearchNBlo:
  06f3b	83 7d 08 12	 cmp	 DWORD PTR _iMapNumber$[ebp], 18 ; 00000012H
  06f3f	7d 09		 jge	 SHORT $LN17@SearchNBlo
  06f41	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  06f48	eb 0c		 jmp	 SHORT $LN18@SearchNBlo
$LN17@SearchNBlo:
  06f4a	33 c0		 xor	 eax, eax
  06f4c	83 7d 08 17	 cmp	 DWORD PTR _iMapNumber$[ebp], 23 ; 00000017H
  06f50	0f 9e c0	 setle	 al
  06f53	89 45 94	 mov	 DWORD PTR tv68[ebp], eax
$LN18@SearchNBlo:
  06f56	8b 4d 94	 mov	 ecx, DWORD PTR tv68[ebp]
  06f59	89 4d 98	 mov	 DWORD PTR tv69[ebp], ecx
$LN20@SearchNBlo:
  06f5c	83 7d 98 00	 cmp	 DWORD PTR tv69[ebp], 0
  06f60	75 05		 jne	 SHORT $LN14@SearchNBlo

; 2334 : 		return;

  06f62	e9 76 02 00 00	 jmp	 $LN15@SearchNBlo
$LN14@SearchNBlo:

; 2335 : 
; 2336 : 	if ( !CHECK_LIMIT(iX, 256) || !CHECK_LIMIT(iY, 256))

  06f67	83 7d 0c 00	 cmp	 DWORD PTR _iX$[ebp], 0
  06f6b	7d 09		 jge	 SHORT $LN21@SearchNBlo
  06f6d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  06f74	eb 0f		 jmp	 SHORT $LN22@SearchNBlo
$LN21@SearchNBlo:
  06f76	33 c0		 xor	 eax, eax
  06f78	81 7d 0c ff 00
	00 00		 cmp	 DWORD PTR _iX$[ebp], 255 ; 000000ffH
  06f7f	0f 9e c0	 setle	 al
  06f82	89 45 98	 mov	 DWORD PTR tv74[ebp], eax
$LN22@SearchNBlo:
  06f85	83 7d 98 00	 cmp	 DWORD PTR tv74[ebp], 0
  06f89	74 24		 je	 SHORT $LN12@SearchNBlo
  06f8b	83 7d 10 00	 cmp	 DWORD PTR _iY$[ebp], 0
  06f8f	7d 09		 jge	 SHORT $LN23@SearchNBlo
  06f91	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  06f98	eb 0f		 jmp	 SHORT $LN24@SearchNBlo
$LN23@SearchNBlo:
  06f9a	33 c0		 xor	 eax, eax
  06f9c	81 7d 10 ff 00
	00 00		 cmp	 DWORD PTR _iY$[ebp], 255 ; 000000ffH
  06fa3	0f 9e c0	 setle	 al
  06fa6	89 45 98	 mov	 DWORD PTR tv79[ebp], eax
$LN24@SearchNBlo:
  06fa9	83 7d 98 00	 cmp	 DWORD PTR tv79[ebp], 0
  06fad	75 05		 jne	 SHORT $LN13@SearchNBlo
$LN12@SearchNBlo:

; 2337 : 		return;

  06faf	e9 29 02 00 00	 jmp	 $LN15@SearchNBlo
$LN13@SearchNBlo:

; 2338 : 
; 2339 : 	int iMIN_X = iX-3;

  06fb4	8b 45 0c	 mov	 eax, DWORD PTR _iX$[ebp]
  06fb7	83 e8 03	 sub	 eax, 3
  06fba	89 45 f8	 mov	 DWORD PTR _iMIN_X$[ebp], eax

; 2340 : 	int iMAX_X = iX+3;

  06fbd	8b 45 0c	 mov	 eax, DWORD PTR _iX$[ebp]
  06fc0	83 c0 03	 add	 eax, 3
  06fc3	89 45 f4	 mov	 DWORD PTR _iMAX_X$[ebp], eax

; 2341 : 	int iMIN_Y = iY-3;

  06fc6	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  06fc9	83 e8 03	 sub	 eax, 3
  06fcc	89 45 f0	 mov	 DWORD PTR _iMIN_Y$[ebp], eax

; 2342 : 	int iMAX_Y = iY+3;

  06fcf	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  06fd2	83 c0 03	 add	 eax, 3
  06fd5	89 45 ec	 mov	 DWORD PTR _iMAX_Y$[ebp], eax

; 2343 : 
; 2344 : 	if ( iMIN_X < 0 ) iMIN_X = 0;

  06fd8	83 7d f8 00	 cmp	 DWORD PTR _iMIN_X$[ebp], 0
  06fdc	7d 07		 jge	 SHORT $LN11@SearchNBlo
  06fde	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMIN_X$[ebp], 0
$LN11@SearchNBlo:

; 2345 : 	if ( iMIN_Y < 0 ) iMIN_Y = 0;

  06fe5	83 7d f0 00	 cmp	 DWORD PTR _iMIN_Y$[ebp], 0
  06fe9	7d 07		 jge	 SHORT $LN10@SearchNBlo
  06feb	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iMIN_Y$[ebp], 0
$LN10@SearchNBlo:

; 2346 : 	if ( iMIN_X > 255 ) iMIN_X = 255;

  06ff2	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _iMIN_X$[ebp], 255 ; 000000ffH
  06ff9	7e 07		 jle	 SHORT $LN9@SearchNBlo
  06ffb	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR _iMIN_X$[ebp], 255 ; 000000ffH
$LN9@SearchNBlo:

; 2347 : 	if ( iMIN_Y > 255 ) iMIN_Y = 255;

  07002	81 7d f0 ff 00
	00 00		 cmp	 DWORD PTR _iMIN_Y$[ebp], 255 ; 000000ffH
  07009	7e 07		 jle	 SHORT $LN8@SearchNBlo
  0700b	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR _iMIN_Y$[ebp], 255 ; 000000ffH
$LN8@SearchNBlo:

; 2348 : 	
; 2349 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  07012	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$238546[ebp], 0
  07019	eb 09		 jmp	 SHORT $LN7@SearchNBlo
$LN6@SearchNBlo:
  0701b	8b 45 e8	 mov	 eax, DWORD PTR _i$238546[ebp]
  0701e	83 c0 01	 add	 eax, 1
  07021	89 45 e8	 mov	 DWORD PTR _i$238546[ebp], eax
$LN7@SearchNBlo:
  07024	83 7d e8 46	 cmp	 DWORD PTR _i$238546[ebp], 70 ; 00000046H
  07028	0f 8d af 01 00
	00		 jge	 $LN15@SearchNBlo

; 2350 : 	{
; 2351 : 		int iChaosCastleIndex = this->GetChaosCastleIndex(iMapNumber);

  0702e	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  07031	50		 push	 eax
  07032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07035	e8 00 00 00 00	 call	 ?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleIndex
  0703a	89 45 e4	 mov	 DWORD PTR _iChaosCastleIndex$238550[ebp], eax

; 2352 : 
; 2353 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == -1 )

  0703d	8b 45 e4	 mov	 eax, DWORD PTR _iChaosCastleIndex$238550[ebp]
  07040	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  07046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07049	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0704d	8b 45 e8	 mov	 eax, DWORD PTR _i$238546[ebp]
  07050	6b c0 14	 imul	 eax, 20			; 00000014H
  07053	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  07058	75 02		 jne	 SHORT $LN4@SearchNBlo

; 2354 : 		{
; 2355 : 			continue;

  0705a	eb bf		 jmp	 SHORT $LN6@SearchNBlo
$LN4@SearchNBlo:

; 2356 : 		}
; 2357 : 
; 2358 : 		int iIndex = this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex;

  0705c	8b 45 e4	 mov	 eax, DWORD PTR _iChaosCastleIndex$238550[ebp]
  0705f	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  07065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07068	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0706c	8b 45 e8	 mov	 eax, DWORD PTR _i$238546[ebp]
  0706f	6b c0 14	 imul	 eax, 20			; 00000014H
  07072	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  07076	89 4d e0	 mov	 DWORD PTR _iIndex$238552[ebp], ecx

; 2359 : 
; 2360 : 		if ( gObj[iIndex].MapNumber == iMapNumber && gObj[iIndex].Connected > PLAYER_LOGGED )

  07079	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  0707c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07088	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  07090	3b 55 08	 cmp	 edx, DWORD PTR _iMapNumber$[ebp]
  07093	0f 85 3f 01 00
	00		 jne	 $LN3@SearchNBlo
  07099	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  0709c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  070a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  070a8	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  070ad	0f 8e 25 01 00
	00		 jle	 $LN3@SearchNBlo

; 2361 : 		{
; 2362 : 			if ( gObj[iIndex].X >= iMIN_X && gObj[iIndex].X <= iMAX_X && gObj[iIndex].Y >= iMIN_Y && gObj[iIndex].Y <= iMAX_Y )

  070b3	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  070b6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  070bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  070c2	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  070ca	3b 55 f8	 cmp	 edx, DWORD PTR _iMIN_X$[ebp]
  070cd	0f 8c 05 01 00
	00		 jl	 $LN3@SearchNBlo
  070d3	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  070d6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  070dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  070e2	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  070ea	3b 55 f4	 cmp	 edx, DWORD PTR _iMAX_X$[ebp]
  070ed	0f 8f e5 00 00
	00		 jg	 $LN3@SearchNBlo
  070f3	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  070f6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  070fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07102	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  0710a	3b 55 f0	 cmp	 edx, DWORD PTR _iMIN_Y$[ebp]
  0710d	0f 8c c5 00 00
	00		 jl	 $LN3@SearchNBlo
  07113	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  07116	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0711c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07122	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  0712a	3b 55 ec	 cmp	 edx, DWORD PTR _iMAX_Y$[ebp]
  0712d	0f 8f a5 00 00
	00		 jg	 $LN3@SearchNBlo

; 2363 : 			{
; 2364 : 				this->BlowObjsFromPoint(gObj[iIndex].m_Index, iMapNumber, iX, iY);

  07133	8d 45 10	 lea	 eax, DWORD PTR _iY$[ebp]
  07136	50		 push	 eax
  07137	8d 4d 0c	 lea	 ecx, DWORD PTR _iX$[ebp]
  0713a	51		 push	 ecx
  0713b	8b 55 08	 mov	 edx, DWORD PTR _iMapNumber$[ebp]
  0713e	52		 push	 edx
  0713f	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  07142	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0714e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  07151	52		 push	 edx
  07152	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07155	e8 00 00 00 00	 call	 ?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z ; CChaosCastle::BlowObjsFromPoint

; 2365 : 
; 2366 : 				BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iY * 256 + iX]&0x08;

  0715a	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  0715d	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  07163	8b 4d 10	 mov	 ecx, DWORD PTR _iY$[ebp]
  07166	c1 e1 08	 shl	 ecx, 8
  07169	03 4d 0c	 add	 ecx, DWORD PTR _iX$[ebp]
  0716c	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  07172	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  07176	83 e0 08	 and	 eax, 8
  07179	88 45 df	 mov	 BYTE PTR _btMapAttr$238555[ebp], al

; 2367 : 
; 2368 : 				if ( btMapAttr == 8 )

  0717c	0f b6 45 df	 movzx	 eax, BYTE PTR _btMapAttr$238555[ebp]
  07180	83 f8 08	 cmp	 eax, 8
  07183	75 53		 jne	 SHORT $LN3@SearchNBlo

; 2369 : 				{
; 2370 : 					this->AddFallUser(iChaosCastleIndex, iIndex);

  07185	8b 45 e0	 mov	 eax, DWORD PTR _iIndex$238552[ebp]
  07188	50		 push	 eax
  07189	8b 4d e4	 mov	 ecx, DWORD PTR _iChaosCastleIndex$238550[ebp]
  0718c	51		 push	 ecx
  0718d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07190	e8 00 00 00 00	 call	 ?AddFallUser@CChaosCastle@@QAEXHH@Z ; CChaosCastle::AddFallUser

; 2371 : 					LogAddTD("[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall from Castle (X:%d, Y:%d)", iMapNumber-17, gObj[iIndex].AccountID, gObj[iIndex].Name, iX, iY);

  07195	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  07198	50		 push	 eax
  07199	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  0719c	51		 push	 ecx
  0719d	8b 55 e0	 mov	 edx, DWORD PTR _iIndex$238552[ebp]
  071a0	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  071a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  071ab	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  071af	51		 push	 ecx
  071b0	8b 55 e0	 mov	 edx, DWORD PTR _iIndex$238552[ebp]
  071b3	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  071b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  071be	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  071c2	51		 push	 ecx
  071c3	8b 55 08	 mov	 edx, DWORD PTR _iMapNumber$[ebp]
  071c6	83 ea 11	 sub	 edx, 17			; 00000011H
  071c9	52		 push	 edx
  071ca	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  071cf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  071d5	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@SearchNBlo:

; 2372 : 				}
; 2373 : 			}
; 2374 : 		}
; 2375 : 	}

  071d8	e9 3e fe ff ff	 jmp	 $LN6@SearchNBlo
$LN15@SearchNBlo:

; 2376 : }

  071dd	5f		 pop	 edi
  071de	5e		 pop	 esi
  071df	5b		 pop	 ebx
  071e0	8b e5		 mov	 esp, ebp
  071e2	5d		 pop	 ebp
  071e3	c2 0c 00	 ret	 12			; 0000000cH
?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z ENDP		; CChaosCastle::SearchNBlowObjs
_TEXT	ENDS
PUBLIC	?CalDistance@CChaosCastle@@QAEHHHHH@Z		; CChaosCastle::CalDistance
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv150 = -140						; size = 4
tv144 = -140						; size = 4
tv133 = -140						; size = 4
tv75 = -140						; size = 4
tv70 = -140						; size = 4
_iTY$238605 = -72					; size = 4
_iTX$238604 = -68					; size = 4
_iRND$238597 = -64					; size = 4
_iBLOW_Y$238596 = -60					; size = 4
_iBLOW_X$238595 = -56					; size = 4
_iBLOW_MAX$238594 = -52					; size = 4
_iBLOW_MIN$238593 = -48					; size = 4
_iBLOWOUT_COUNT$238589 = -44				; size = 4
_bSuccessBlowOut$ = -40					; size = 4
_iRND$238587 = -36					; size = 4
_iRND$238582 = -32					; size = 4
_iUY$ = -28						; size = 4
_iUX$ = -24						; size = 4
_iSIGN_Y$ = -20						; size = 4
_iSIGN_X$ = -16						; size = 4
_iOBJ_DIST$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iMapNumber$ = 12					; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z PROC	; CChaosCastle::BlowObjsFromPoint
; _this$ = ecx

; 2379 : {

  071f0	55		 push	 ebp
  071f1	8b ec		 mov	 ebp, esp
  071f3	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  071f9	53		 push	 ebx
  071fa	56		 push	 esi
  071fb	57		 push	 edi
  071fc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2380 : 	if ( !gObjIsConnected(iIndex))

  071ff	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07202	50		 push	 eax
  07203	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  07208	83 c4 04	 add	 esp, 4
  0720b	85 c0		 test	 eax, eax
  0720d	75 07		 jne	 SHORT $LN29@BlowObjsFr

; 2381 : 	{
; 2382 : 		return FALSE;

  0720f	33 c0		 xor	 eax, eax
  07211	e9 cb 03 00 00	 jmp	 $LN30@BlowObjsFr
$LN29@BlowObjsFr:

; 2383 : 	}
; 2384 : 
; 2385 : 	if ( !CHECK_LIMIT(iX, 256) || !CHECK_LIMIT(iY, 256))

  07216	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  07219	83 38 00	 cmp	 DWORD PTR [eax], 0
  0721c	7d 0c		 jge	 SHORT $LN32@BlowObjsFr
  0721e	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
  07228	eb 14		 jmp	 SHORT $LN33@BlowObjsFr
$LN32@BlowObjsFr:
  0722a	8b 4d 10	 mov	 ecx, DWORD PTR _iX$[ebp]
  0722d	33 d2		 xor	 edx, edx
  0722f	81 39 ff 00 00
	00		 cmp	 DWORD PTR [ecx], 255	; 000000ffH
  07235	0f 9e c2	 setle	 dl
  07238	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
$LN33@BlowObjsFr:
  0723e	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  07245	74 31		 je	 SHORT $LN27@BlowObjsFr
  07247	8b 45 14	 mov	 eax, DWORD PTR _iY$[ebp]
  0724a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0724d	7d 0c		 jge	 SHORT $LN34@BlowObjsFr
  0724f	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
  07259	eb 14		 jmp	 SHORT $LN35@BlowObjsFr
$LN34@BlowObjsFr:
  0725b	8b 4d 14	 mov	 ecx, DWORD PTR _iY$[ebp]
  0725e	33 d2		 xor	 edx, edx
  07260	81 39 ff 00 00
	00		 cmp	 DWORD PTR [ecx], 255	; 000000ffH
  07266	0f 9e c2	 setle	 dl
  07269	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], edx
$LN35@BlowObjsFr:
  0726f	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv75[ebp], 0
  07276	75 07		 jne	 SHORT $LN28@BlowObjsFr
$LN27@BlowObjsFr:

; 2386 : 	{
; 2387 : 		return FALSE;

  07278	33 c0		 xor	 eax, eax
  0727a	e9 62 03 00 00	 jmp	 $LN30@BlowObjsFr
$LN28@BlowObjsFr:

; 2388 : 	}
; 2389 : 
; 2390 : 	LPOBJ lpObj = &gObj[iIndex];

  0727f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07282	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07288	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0728e	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2391 : 
; 2392 : 	if ( lpObj->DieRegen )

  07291	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07294	0f be 88 a2 03
	00 00		 movsx	 ecx, BYTE PTR [eax+930]
  0729b	85 c9		 test	 ecx, ecx
  0729d	74 07		 je	 SHORT $LN26@BlowObjsFr

; 2393 : 	{
; 2394 : 		return FALSE;

  0729f	33 c0		 xor	 eax, eax
  072a1	e9 3b 03 00 00	 jmp	 $LN30@BlowObjsFr
$LN26@BlowObjsFr:

; 2395 : 	}
; 2396 : 
; 2397 : 	if ( lpObj->Teleport )

  072a6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  072a9	0f be 88 a0 03
	00 00		 movsx	 ecx, BYTE PTR [eax+928]
  072b0	85 c9		 test	 ecx, ecx
  072b2	74 07		 je	 SHORT $LN25@BlowObjsFr

; 2398 : 	{
; 2399 : 		return FALSE;

  072b4	33 c0		 xor	 eax, eax
  072b6	e9 26 03 00 00	 jmp	 $LN30@BlowObjsFr
$LN25@BlowObjsFr:

; 2400 : 	}
; 2401 : 
; 2402 : 	if ( lpObj->MapNumber != iMapNumber )

  072bb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  072be	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  072c5	3b 4d 0c	 cmp	 ecx, DWORD PTR _iMapNumber$[ebp]
  072c8	74 07		 je	 SHORT $LN24@BlowObjsFr

; 2403 : 	{
; 2404 : 		return FALSE;

  072ca	33 c0		 xor	 eax, eax
  072cc	e9 10 03 00 00	 jmp	 $LN30@BlowObjsFr
$LN24@BlowObjsFr:

; 2405 : 	}
; 2406 : 
; 2407 : 	int iOBJ_DIST = this->CalDistance(lpObj->X, lpObj->Y, iX, iY);

  072d1	8b 45 14	 mov	 eax, DWORD PTR _iY$[ebp]
  072d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  072d6	51		 push	 ecx
  072d7	8b 55 10	 mov	 edx, DWORD PTR _iX$[ebp]
  072da	8b 02		 mov	 eax, DWORD PTR [edx]
  072dc	50		 push	 eax
  072dd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  072e0	0f bf 91 46 01
	00 00		 movsx	 edx, WORD PTR [ecx+326]
  072e7	52		 push	 edx
  072e8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  072eb	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  072f2	51		 push	 ecx
  072f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  072f6	e8 00 00 00 00	 call	 ?CalDistance@CChaosCastle@@QAEHHHHH@Z ; CChaosCastle::CalDistance
  072fb	89 45 f4	 mov	 DWORD PTR _iOBJ_DIST$[ebp], eax

; 2408 : 
; 2409 : 	if ( !CHECK_LIMIT(iOBJ_DIST, 4))

  072fe	83 7d f4 00	 cmp	 DWORD PTR _iOBJ_DIST$[ebp], 0
  07302	7d 0c		 jge	 SHORT $LN36@BlowObjsFr
  07304	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
  0730e	eb 0f		 jmp	 SHORT $LN37@BlowObjsFr
$LN36@BlowObjsFr:
  07310	33 c0		 xor	 eax, eax
  07312	83 7d f4 03	 cmp	 DWORD PTR _iOBJ_DIST$[ebp], 3
  07316	0f 9e c0	 setle	 al
  07319	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
$LN37@BlowObjsFr:
  0731f	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv133[ebp], 0
  07326	75 07		 jne	 SHORT $LN23@BlowObjsFr

; 2410 : 	{
; 2411 : 		return FALSE;

  07328	33 c0		 xor	 eax, eax
  0732a	e9 b2 02 00 00	 jmp	 $LN30@BlowObjsFr
$LN23@BlowObjsFr:

; 2412 : 	}
; 2413 : 
; 2414 : 	int iSIGN_X = 1;

  0732f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iSIGN_X$[ebp], 1

; 2415 : 	int iSIGN_Y = 1;

  07336	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iSIGN_Y$[ebp], 1

; 2416 : 	int iUX = lpObj->X;

  0733d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07340	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  07347	89 4d e8	 mov	 DWORD PTR _iUX$[ebp], ecx

; 2417 : 	int iUY = lpObj->Y;

  0734a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0734d	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  07354	89 4d e4	 mov	 DWORD PTR _iUY$[ebp], ecx

; 2418 : 
; 2419 : 	if ( iUX > iX )

  07357	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  0735a	8b 4d e8	 mov	 ecx, DWORD PTR _iUX$[ebp]
  0735d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0735f	7e 09		 jle	 SHORT $LN22@BlowObjsFr

; 2420 : 	{
; 2421 : 		iSIGN_X = 1;

  07361	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iSIGN_X$[ebp], 1
  07368	eb 4f		 jmp	 SHORT $LN21@BlowObjsFr
$LN22@BlowObjsFr:

; 2422 : 	}
; 2423 : 	else if ( iUX < iX )

  0736a	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  0736d	8b 4d e8	 mov	 ecx, DWORD PTR _iUX$[ebp]
  07370	3b 08		 cmp	 ecx, DWORD PTR [eax]
  07372	7d 09		 jge	 SHORT $LN20@BlowObjsFr

; 2424 : 	{
; 2425 : 		iSIGN_X = -1;

  07374	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_X$[ebp], -1

; 2426 : 	}
; 2427 : 	else

  0737b	eb 3c		 jmp	 SHORT $LN21@BlowObjsFr
$LN20@BlowObjsFr:

; 2428 : 	{
; 2429 : 		int iRND = rand() % 2;

  0737d	e8 00 00 00 00	 call	 _rand
  07382	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  07387	79 05		 jns	 SHORT $LN42@BlowObjsFr
  07389	48		 dec	 eax
  0738a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0738d	40		 inc	 eax
$LN42@BlowObjsFr:
  0738e	89 45 e0	 mov	 DWORD PTR _iRND$238582[ebp], eax

; 2430 : 		(!iRND)?iSIGN_X = 1:iSIGN_X = -1;

  07391	83 7d e0 00	 cmp	 DWORD PTR _iRND$238582[ebp], 0
  07395	75 12		 jne	 SHORT $LN38@BlowObjsFr
  07397	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iSIGN_X$[ebp], 1
  0739e	8b 45 f0	 mov	 eax, DWORD PTR _iSIGN_X$[ebp]
  073a1	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv144[ebp], eax
  073a7	eb 10		 jmp	 SHORT $LN21@BlowObjsFr
$LN38@BlowObjsFr:
  073a9	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_X$[ebp], -1
  073b0	8b 4d f0	 mov	 ecx, DWORD PTR _iSIGN_X$[ebp]
  073b3	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv144[ebp], ecx
$LN21@BlowObjsFr:

; 2431 : 	}
; 2432 : 		
; 2433 : 	if ( iUY > iY )

  073b9	8b 45 14	 mov	 eax, DWORD PTR _iY$[ebp]
  073bc	8b 4d e4	 mov	 ecx, DWORD PTR _iUY$[ebp]
  073bf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  073c1	7e 09		 jle	 SHORT $LN18@BlowObjsFr

; 2434 : 	{
; 2435 : 		iSIGN_Y = 1;

  073c3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iSIGN_Y$[ebp], 1
  073ca	eb 4f		 jmp	 SHORT $LN17@BlowObjsFr
$LN18@BlowObjsFr:

; 2436 : 	}
; 2437 : 	else if ( iUY < iY )

  073cc	8b 45 14	 mov	 eax, DWORD PTR _iY$[ebp]
  073cf	8b 4d e4	 mov	 ecx, DWORD PTR _iUY$[ebp]
  073d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  073d4	7d 09		 jge	 SHORT $LN16@BlowObjsFr

; 2438 : 	{
; 2439 : 		iSIGN_Y = -1;

  073d6	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_Y$[ebp], -1

; 2440 : 	}
; 2441 : 	else

  073dd	eb 3c		 jmp	 SHORT $LN17@BlowObjsFr
$LN16@BlowObjsFr:

; 2442 : 	{
; 2443 : 		int iRND = rand() % 2;

  073df	e8 00 00 00 00	 call	 _rand
  073e4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  073e9	79 05		 jns	 SHORT $LN43@BlowObjsFr
  073eb	48		 dec	 eax
  073ec	83 c8 fe	 or	 eax, -2			; fffffffeH
  073ef	40		 inc	 eax
$LN43@BlowObjsFr:
  073f0	89 45 dc	 mov	 DWORD PTR _iRND$238587[ebp], eax

; 2444 : 		(!iRND)?iSIGN_Y = 1:iSIGN_Y = -1;

  073f3	83 7d dc 00	 cmp	 DWORD PTR _iRND$238587[ebp], 0
  073f7	75 12		 jne	 SHORT $LN40@BlowObjsFr
  073f9	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iSIGN_Y$[ebp], 1
  07400	8b 45 ec	 mov	 eax, DWORD PTR _iSIGN_Y$[ebp]
  07403	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv150[ebp], eax
  07409	eb 10		 jmp	 SHORT $LN17@BlowObjsFr
$LN40@BlowObjsFr:
  0740b	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_Y$[ebp], -1
  07412	8b 4d ec	 mov	 ecx, DWORD PTR _iSIGN_Y$[ebp]
  07415	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv150[ebp], ecx
$LN17@BlowObjsFr:

; 2445 : 	}
; 2446 : 
; 2447 : 	BOOL bSuccessBlowOut = FALSE;

  0741b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _bSuccessBlowOut$[ebp], 0

; 2448 : 
; 2449 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  07422	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$238589[ebp], 0
  07429	eb 09		 jmp	 SHORT $LN14@BlowObjsFr
$LN13@BlowObjsFr:
  0742b	8b 45 d4	 mov	 eax, DWORD PTR _iBLOWOUT_COUNT$238589[ebp]
  0742e	83 c0 01	 add	 eax, 1
  07431	89 45 d4	 mov	 DWORD PTR _iBLOWOUT_COUNT$238589[ebp], eax
$LN14@BlowObjsFr:
  07434	83 7d d4 05	 cmp	 DWORD PTR _iBLOWOUT_COUNT$238589[ebp], 5
  07438	0f 8d 9e 01 00
	00		 jge	 $LN12@BlowObjsFr

; 2450 : 	{
; 2451 : 		int iBLOW_MIN = g_iChaosCastle_BlowOutDistance[iOBJ_DIST][0];

  0743e	8b 45 f4	 mov	 eax, DWORD PTR _iOBJ_DIST$[ebp]
  07441	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iChaosCastle_BlowOutDistance[eax*8]
  07448	89 4d d0	 mov	 DWORD PTR _iBLOW_MIN$238593[ebp], ecx

; 2452 : 		int iBLOW_MAX = g_iChaosCastle_BlowOutDistance[iOBJ_DIST][1];

  0744b	8b 45 f4	 mov	 eax, DWORD PTR _iOBJ_DIST$[ebp]
  0744e	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _g_iChaosCastle_BlowOutDistance[eax*8+4]
  07455	89 4d cc	 mov	 DWORD PTR _iBLOW_MAX$238594[ebp], ecx

; 2453 : 		int iBLOW_X = rand() % (iBLOW_MAX - iBLOW_MIN + 1) + iBLOW_MIN;

  07458	e8 00 00 00 00	 call	 _rand
  0745d	8b 4d cc	 mov	 ecx, DWORD PTR _iBLOW_MAX$238594[ebp]
  07460	2b 4d d0	 sub	 ecx, DWORD PTR _iBLOW_MIN$238593[ebp]
  07463	83 c1 01	 add	 ecx, 1
  07466	99		 cdq
  07467	f7 f9		 idiv	 ecx
  07469	03 55 d0	 add	 edx, DWORD PTR _iBLOW_MIN$238593[ebp]
  0746c	89 55 c8	 mov	 DWORD PTR _iBLOW_X$238595[ebp], edx

; 2454 : 		int iBLOW_Y = rand() % (iBLOW_MAX - iBLOW_MIN + 1) + iBLOW_MIN;

  0746f	e8 00 00 00 00	 call	 _rand
  07474	8b 4d cc	 mov	 ecx, DWORD PTR _iBLOW_MAX$238594[ebp]
  07477	2b 4d d0	 sub	 ecx, DWORD PTR _iBLOW_MIN$238593[ebp]
  0747a	83 c1 01	 add	 ecx, 1
  0747d	99		 cdq
  0747e	f7 f9		 idiv	 ecx
  07480	03 55 d0	 add	 edx, DWORD PTR _iBLOW_MIN$238593[ebp]
  07483	89 55 c4	 mov	 DWORD PTR _iBLOW_Y$238596[ebp], edx

; 2455 : 		int iRND = rand() % 2;

  07486	e8 00 00 00 00	 call	 _rand
  0748b	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  07490	79 05		 jns	 SHORT $LN44@BlowObjsFr
  07492	48		 dec	 eax
  07493	83 c8 fe	 or	 eax, -2			; fffffffeH
  07496	40		 inc	 eax
$LN44@BlowObjsFr:
  07497	89 45 c0	 mov	 DWORD PTR _iRND$238597[ebp], eax

; 2456 : 
; 2457 : 		if ( iRND )

  0749a	83 7d c0 00	 cmp	 DWORD PTR _iRND$238597[ebp], 0
  0749e	74 38		 je	 SHORT $LN11@BlowObjsFr

; 2458 : 		{
; 2459 : 			if ( iBLOW_X >= iBLOW_MAX )

  074a0	8b 45 c8	 mov	 eax, DWORD PTR _iBLOW_X$238595[ebp]
  074a3	3b 45 cc	 cmp	 eax, DWORD PTR _iBLOW_MAX$238594[ebp]
  074a6	7c 2e		 jl	 SHORT $LN10@BlowObjsFr

; 2460 : 			{
; 2461 : 				iBLOW_X = iBLOW_MAX;

  074a8	8b 45 cc	 mov	 eax, DWORD PTR _iBLOW_MAX$238594[ebp]
  074ab	89 45 c8	 mov	 DWORD PTR _iBLOW_X$238595[ebp], eax

; 2462 : 				iBLOW_Y = iBLOW_MIN + (rand() % 2 -1);

  074ae	e8 00 00 00 00	 call	 _rand
  074b3	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  074b8	79 05		 jns	 SHORT $LN45@BlowObjsFr
  074ba	48		 dec	 eax
  074bb	83 c8 fe	 or	 eax, -2			; fffffffeH
  074be	40		 inc	 eax
$LN45@BlowObjsFr:
  074bf	8b 4d d0	 mov	 ecx, DWORD PTR _iBLOW_MIN$238593[ebp]
  074c2	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  074c6	89 55 c4	 mov	 DWORD PTR _iBLOW_Y$238596[ebp], edx

; 2463 : 
; 2464 : 				if ( iBLOW_Y < 0 )

  074c9	83 7d c4 00	 cmp	 DWORD PTR _iBLOW_Y$238596[ebp], 0
  074cd	7d 07		 jge	 SHORT $LN10@BlowObjsFr

; 2465 : 				{
; 2466 : 					iBLOW_Y = 0;

  074cf	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _iBLOW_Y$238596[ebp], 0
$LN10@BlowObjsFr:

; 2467 : 				}
; 2468 : 			}
; 2469 : 		}

  074d6	eb 36		 jmp	 SHORT $LN8@BlowObjsFr
$LN11@BlowObjsFr:

; 2470 : 		else if ( iBLOW_Y >= iBLOW_MAX )

  074d8	8b 45 c4	 mov	 eax, DWORD PTR _iBLOW_Y$238596[ebp]
  074db	3b 45 cc	 cmp	 eax, DWORD PTR _iBLOW_MAX$238594[ebp]
  074de	7c 2e		 jl	 SHORT $LN8@BlowObjsFr

; 2471 : 		{
; 2472 : 			iBLOW_Y = iBLOW_MAX;

  074e0	8b 45 cc	 mov	 eax, DWORD PTR _iBLOW_MAX$238594[ebp]
  074e3	89 45 c4	 mov	 DWORD PTR _iBLOW_Y$238596[ebp], eax

; 2473 : 			iBLOW_X = iBLOW_MIN + (rand() % 2 -1);

  074e6	e8 00 00 00 00	 call	 _rand
  074eb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  074f0	79 05		 jns	 SHORT $LN46@BlowObjsFr
  074f2	48		 dec	 eax
  074f3	83 c8 fe	 or	 eax, -2			; fffffffeH
  074f6	40		 inc	 eax
$LN46@BlowObjsFr:
  074f7	8b 4d d0	 mov	 ecx, DWORD PTR _iBLOW_MIN$238593[ebp]
  074fa	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  074fe	89 55 c8	 mov	 DWORD PTR _iBLOW_X$238595[ebp], edx

; 2474 : 
; 2475 : 			if ( iBLOW_X < 0 )

  07501	83 7d c8 00	 cmp	 DWORD PTR _iBLOW_X$238595[ebp], 0
  07505	7d 07		 jge	 SHORT $LN8@BlowObjsFr

; 2476 : 			{
; 2477 : 				iBLOW_X = 0;

  07507	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _iBLOW_X$238595[ebp], 0
$LN8@BlowObjsFr:

; 2478 : 			}
; 2479 : 		}
; 2480 : 
; 2481 : 		int iTX = lpObj->X  + iBLOW_X * iSIGN_X;

  0750e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07511	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  07518	8b 55 c8	 mov	 edx, DWORD PTR _iBLOW_X$238595[ebp]
  0751b	0f af 55 f0	 imul	 edx, DWORD PTR _iSIGN_X$[ebp]
  0751f	03 ca		 add	 ecx, edx
  07521	89 4d bc	 mov	 DWORD PTR _iTX$238604[ebp], ecx

; 2482 : 		int iTY = lpObj->Y  + iBLOW_Y * iSIGN_Y;

  07524	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07527	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  0752e	8b 55 c4	 mov	 edx, DWORD PTR _iBLOW_Y$238596[ebp]
  07531	0f af 55 ec	 imul	 edx, DWORD PTR _iSIGN_Y$[ebp]
  07535	03 ca		 add	 ecx, edx
  07537	89 4d b8	 mov	 DWORD PTR _iTY$238605[ebp], ecx

; 2483 : 
; 2484 : 		if ( iTX < 0 ) iTX = 0;

  0753a	83 7d bc 00	 cmp	 DWORD PTR _iTX$238604[ebp], 0
  0753e	7d 07		 jge	 SHORT $LN5@BlowObjsFr
  07540	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _iTX$238604[ebp], 0
$LN5@BlowObjsFr:

; 2485 : 		if ( iTY < 0 ) iTY = 0;

  07547	83 7d b8 00	 cmp	 DWORD PTR _iTY$238605[ebp], 0
  0754b	7d 07		 jge	 SHORT $LN4@BlowObjsFr
  0754d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _iTY$238605[ebp], 0
$LN4@BlowObjsFr:

; 2486 : 		if ( iTX > 255 ) iTX = 255;

  07554	81 7d bc ff 00
	00 00		 cmp	 DWORD PTR _iTX$238604[ebp], 255 ; 000000ffH
  0755b	7e 07		 jle	 SHORT $LN3@BlowObjsFr
  0755d	c7 45 bc ff 00
	00 00		 mov	 DWORD PTR _iTX$238604[ebp], 255 ; 000000ffH
$LN3@BlowObjsFr:

; 2487 : 		if ( iTY > 255 ) iTY = 255;

  07564	81 7d b8 ff 00
	00 00		 cmp	 DWORD PTR _iTY$238605[ebp], 255 ; 000000ffH
  0756b	7e 07		 jle	 SHORT $LN2@BlowObjsFr
  0756d	c7 45 b8 ff 00
	00 00		 mov	 DWORD PTR _iTY$238605[ebp], 255 ; 000000ffH
$LN2@BlowObjsFr:

; 2488 : 
; 2489 : 		bSuccessBlowOut = this->ObjSetPosition(iIndex, iTX, iTY);

  07574	8b 45 b8	 mov	 eax, DWORD PTR _iTY$238605[ebp]
  07577	50		 push	 eax
  07578	8b 4d bc	 mov	 ecx, DWORD PTR _iTX$238604[ebp]
  0757b	51		 push	 ecx
  0757c	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0757f	52		 push	 edx
  07580	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07583	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  07588	89 45 d8	 mov	 DWORD PTR _bSuccessBlowOut$[ebp], eax

; 2490 : 		
; 2491 : 		if ( bSuccessBlowOut )

  0758b	83 7d d8 00	 cmp	 DWORD PTR _bSuccessBlowOut$[ebp], 0
  0758f	74 46		 je	 SHORT $LN1@BlowObjsFr

; 2492 : 		{
; 2493 : 			lpObj->m_iChaosCastleBlowTime = GetTickCount();

  07591	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  07597	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0759a	89 81 a8 0e 00
	00		 mov	 DWORD PTR [ecx+3752], eax

; 2494 : 			iX = iTX;

  075a0	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  075a3	8b 4d bc	 mov	 ecx, DWORD PTR _iTX$238604[ebp]
  075a6	89 08		 mov	 DWORD PTR [eax], ecx

; 2495 : 			iY = iTY;

  075a8	8b 45 14	 mov	 eax, DWORD PTR _iY$[ebp]
  075ab	8b 4d b8	 mov	 ecx, DWORD PTR _iTY$238605[ebp]
  075ae	89 08		 mov	 DWORD PTR [eax], ecx

; 2496 : 
; 2497 : 			this->GiveUserDamage(lpObj->m_Index, g_iChaosCastle_BlowOutDamage[iOBJ_DIST % 4]);

  075b0	8b 45 f4	 mov	 eax, DWORD PTR _iOBJ_DIST$[ebp]
  075b3	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  075b8	79 05		 jns	 SHORT $LN47@BlowObjsFr
  075ba	48		 dec	 eax
  075bb	83 c8 fc	 or	 eax, -4			; fffffffcH
  075be	40		 inc	 eax
$LN47@BlowObjsFr:
  075bf	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iChaosCastle_BlowOutDamage[eax*4]
  075c6	51		 push	 ecx
  075c7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  075ca	8b 02		 mov	 eax, DWORD PTR [edx]
  075cc	50		 push	 eax
  075cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  075d0	e8 00 00 00 00	 call	 ?GiveUserDamage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveUserDamage

; 2498 : 			break;

  075d5	eb 05		 jmp	 SHORT $LN12@BlowObjsFr
$LN1@BlowObjsFr:

; 2499 : 		}
; 2500 : 	}

  075d7	e9 4f fe ff ff	 jmp	 $LN13@BlowObjsFr
$LN12@BlowObjsFr:

; 2501 : 
; 2502 : 	return TRUE;

  075dc	b8 01 00 00 00	 mov	 eax, 1
$LN30@BlowObjsFr:

; 2503 : }

  075e1	5f		 pop	 edi
  075e2	5e		 pop	 esi
  075e3	5b		 pop	 ebx
  075e4	8b e5		 mov	 esp, ebp
  075e6	5d		 pop	 ebp
  075e7	c2 10 00	 ret	 16			; 00000010H
?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z ENDP	; CChaosCastle::BlowObjsFromPoint
_TEXT	ENDS
PUBLIC	?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z	; CChaosCastle::BlowObjsToPoint
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iMapNumber$ = 12					; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z PROC		; CChaosCastle::BlowObjsToPoint
; _this$ = ecx

; 2506 : {

  075f0	55		 push	 ebp
  075f1	8b ec		 mov	 ebp, esp
  075f3	83 ec 44	 sub	 esp, 68			; 00000044H
  075f6	53		 push	 ebx
  075f7	56		 push	 esi
  075f8	57		 push	 edi
  075f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2507 : 	return TRUE;

  075fc	b8 01 00 00 00	 mov	 eax, 1

; 2508 : }

  07601	5f		 pop	 edi
  07602	5e		 pop	 esi
  07603	5b		 pop	 ebx
  07604	8b e5		 mov	 esp, ebp
  07606	5d		 pop	 ebp
  07607	c2 10 00	 ret	 16			; 00000010H
?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z ENDP		; CChaosCastle::BlowObjsToPoint
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv92 = -80						; size = 4
tv89 = -80						; size = 4
tv87 = -80						; size = 4
_fTY$ = -12						; size = 4
_fTX$ = -8						; size = 4
_this$ = -4						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?CalDistance@CChaosCastle@@QAEHHHHH@Z PROC		; CChaosCastle::CalDistance
; _this$ = ecx

; 2511 : {

  07610	55		 push	 ebp
  07611	8b ec		 mov	 ebp, esp
  07613	83 ec 50	 sub	 esp, 80			; 00000050H
  07616	53		 push	 ebx
  07617	56		 push	 esi
  07618	57		 push	 edi
  07619	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2512 : 	if ( iX1 == iX2 && iY1 == iY2 )

  0761c	8b 45 08	 mov	 eax, DWORD PTR _iX1$[ebp]
  0761f	3b 45 10	 cmp	 eax, DWORD PTR _iX2$[ebp]
  07622	75 0c		 jne	 SHORT $LN1@CalDistanc
  07624	8b 45 0c	 mov	 eax, DWORD PTR _iY1$[ebp]
  07627	3b 45 14	 cmp	 eax, DWORD PTR _iY2$[ebp]
  0762a	75 04		 jne	 SHORT $LN1@CalDistanc

; 2513 : 	{
; 2514 : 		return 0;

  0762c	33 c0		 xor	 eax, eax
  0762e	eb 43		 jmp	 SHORT $LN2@CalDistanc
$LN1@CalDistanc:

; 2515 : 	}
; 2516 : 
; 2517 : 	float fTX = (float)(iX1 - iX2);

  07630	8b 45 08	 mov	 eax, DWORD PTR _iX1$[ebp]
  07633	2b 45 10	 sub	 eax, DWORD PTR _iX2$[ebp]
  07636	89 45 b0	 mov	 DWORD PTR tv87[ebp], eax
  07639	db 45 b0	 fild	 DWORD PTR tv87[ebp]
  0763c	d9 5d f8	 fstp	 DWORD PTR _fTX$[ebp]

; 2518 : 	float fTY = (float)(iY1 - iY2);

  0763f	8b 45 0c	 mov	 eax, DWORD PTR _iY1$[ebp]
  07642	2b 45 14	 sub	 eax, DWORD PTR _iY2$[ebp]
  07645	89 45 b0	 mov	 DWORD PTR tv89[ebp], eax
  07648	db 45 b0	 fild	 DWORD PTR tv89[ebp]
  0764b	d9 5d f4	 fstp	 DWORD PTR _fTY$[ebp]

; 2519 : 
; 2520 : 	return (int)sqrt( (fTX * fTX) + (fTY * fTY) );

  0764e	d9 45 f8	 fld	 DWORD PTR _fTX$[ebp]
  07651	d8 4d f8	 fmul	 DWORD PTR _fTX$[ebp]
  07654	d9 45 f4	 fld	 DWORD PTR _fTY$[ebp]
  07657	d8 4d f4	 fmul	 DWORD PTR _fTY$[ebp]
  0765a	de c1		 faddp	 ST(1), ST(0)
  0765c	d9 5d b0	 fstp	 DWORD PTR tv92[ebp]
  0765f	d9 45 b0	 fld	 DWORD PTR tv92[ebp]
  07662	51		 push	 ecx
  07663	d9 1c 24	 fstp	 DWORD PTR [esp]
  07666	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  0766b	83 c4 04	 add	 esp, 4
  0766e	e8 00 00 00 00	 call	 __ftol2_sse
$LN2@CalDistanc:

; 2521 : }

  07673	5f		 pop	 edi
  07674	5e		 pop	 esi
  07675	5b		 pop	 ebx
  07676	8b e5		 mov	 esp, ebp
  07678	5d		 pop	 ebp
  07679	c2 10 00	 ret	 16			; 00000010H
?CalDistance@CChaosCastle@@QAEHHHHH@Z ENDP		; CChaosCastle::CalDistance
; Function compile flags: /Odtp /ZI
tv67 = -96						; size = 4
_j$238655 = -28						; size = 4
_i$238651 = -24						; size = 4
_iHOLE_NUM$238647 = -20					; size = 4
_j$238643 = -16						; size = 4
_i$238639 = -12						; size = 4
_iMapNumber$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SafetyCastleZone@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SafetyCastleZone
; _this$ = ecx

; 2546 : {

  07680	55		 push	 ebp
  07681	8b ec		 mov	 ebp, esp
  07683	83 ec 60	 sub	 esp, 96			; 00000060H
  07686	53		 push	 ebx
  07687	56		 push	 esi
  07688	57		 push	 edi
  07689	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2547 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0768c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  07690	7d 09		 jge	 SHORT $LN19@SafetyCast
  07692	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  07699	eb 0c		 jmp	 SHORT $LN20@SafetyCast
$LN19@SafetyCast:
  0769b	33 c0		 xor	 eax, eax
  0769d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  076a1	0f 9e c0	 setle	 al
  076a4	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN20@SafetyCast:
  076a7	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  076ab	75 05		 jne	 SHORT $LN16@SafetyCast

; 2548 : 	{
; 2549 : 		return;

  076ad	e9 6b 01 00 00	 jmp	 $LN17@SafetyCast
$LN16@SafetyCast:

; 2550 : 	}
; 2551 : 
; 2552 : 	int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  076b2	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  076b5	50		 push	 eax
  076b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  076b9	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  076be	89 45 f8	 mov	 DWORD PTR _iMapNumber$[ebp], eax

; 2553 : 
; 2554 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  076c1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  076c4	0f b6 0c 85 00
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4]
  076cc	89 4d f4	 mov	 DWORD PTR _i$238639[ebp], ecx
  076cf	eb 09		 jmp	 SHORT $LN15@SafetyCast
$LN14@SafetyCast:
  076d1	8b 45 f4	 mov	 eax, DWORD PTR _i$238639[ebp]
  076d4	83 c0 01	 add	 eax, 1
  076d7	89 45 f4	 mov	 DWORD PTR _i$238639[ebp], eax
$LN15@SafetyCast:
  076da	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  076dd	0f b6 0c 85 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4+2]
  076e5	39 4d f4	 cmp	 DWORD PTR _i$238639[ebp], ecx
  076e8	7f 67		 jg	 SHORT $LN13@SafetyCast

; 2555 : 	{
; 2556 : 		for(int j=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1] ; j <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3] ; j++ )

  076ea	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  076ed	0f b6 0c 85 01
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4+1]
  076f5	89 4d f0	 mov	 DWORD PTR _j$238643[ebp], ecx
  076f8	eb 09		 jmp	 SHORT $LN12@SafetyCast
$LN11@SafetyCast:
  076fa	8b 45 f0	 mov	 eax, DWORD PTR _j$238643[ebp]
  076fd	83 c0 01	 add	 eax, 1
  07700	89 45 f0	 mov	 DWORD PTR _j$238643[ebp], eax
$LN12@SafetyCast:
  07703	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07706	0f b6 0c 85 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4+3]
  0770e	39 4d f0	 cmp	 DWORD PTR _j$238643[ebp], ecx
  07711	7f 3c		 jg	 SHORT $LN10@SafetyCast

; 2557 : 		{
; 2558 : 			MapC[iMapNumber].m_attrbuf[ j * 256 + i] |= 1;

  07713	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  07716	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  0771c	8b 4d f0	 mov	 ecx, DWORD PTR _j$238643[ebp]
  0771f	c1 e1 08	 shl	 ecx, 8
  07722	03 4d f4	 add	 ecx, DWORD PTR _i$238639[ebp]
  07725	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0772b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0772f	83 c8 01	 or	 eax, 1
  07732	8b 4d f8	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  07735	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0773b	8b 55 f0	 mov	 edx, DWORD PTR _j$238643[ebp]
  0773e	c1 e2 08	 shl	 edx, 8
  07741	03 55 f4	 add	 edx, DWORD PTR _i$238639[ebp]
  07744	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  0774a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2559 : 		}

  0774d	eb ab		 jmp	 SHORT $LN11@SafetyCast
$LN10@SafetyCast:

; 2560 : 	}

  0774f	eb 80		 jmp	 SHORT $LN14@SafetyCast
$LN13@SafetyCast:

; 2561 : 
; 2562 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  07751	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iHOLE_NUM$238647[ebp], 0
  07758	eb 09		 jmp	 SHORT $LN9@SafetyCast
$LN8@SafetyCast:
  0775a	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238647[ebp]
  0775d	83 c0 01	 add	 eax, 1
  07760	89 45 ec	 mov	 DWORD PTR _iHOLE_NUM$238647[ebp], eax
$LN9@SafetyCast:
  07763	83 7d ec 02	 cmp	 DWORD PTR _iHOLE_NUM$238647[ebp], 2
  07767	0f 8d b0 00 00
	00		 jge	 $LN17@SafetyCast

; 2563 : 	{
; 2564 : 		for(int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  0776d	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238647[ebp]
  07770	c1 e0 02	 shl	 eax, 2
  07773	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07776	0f b6 94 c8 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8]
  0777e	89 55 e8	 mov	 DWORD PTR _i$238651[ebp], edx
  07781	eb 09		 jmp	 SHORT $LN6@SafetyCast
$LN5@SafetyCast:
  07783	8b 45 e8	 mov	 eax, DWORD PTR _i$238651[ebp]
  07786	83 c0 01	 add	 eax, 1
  07789	89 45 e8	 mov	 DWORD PTR _i$238651[ebp], eax
$LN6@SafetyCast:
  0778c	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238647[ebp]
  0778f	c1 e0 02	 shl	 eax, 2
  07792	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07795	0f b6 94 c8 02
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8+2]
  0779d	39 55 e8	 cmp	 DWORD PTR _i$238651[ebp], edx
  077a0	7f 76		 jg	 SHORT $LN4@SafetyCast

; 2565 : 		{
; 2566 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  077a2	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238647[ebp]
  077a5	c1 e0 02	 shl	 eax, 2
  077a8	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  077ab	0f b6 94 c8 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8+1]
  077b3	89 55 e4	 mov	 DWORD PTR _j$238655[ebp], edx
  077b6	eb 09		 jmp	 SHORT $LN3@SafetyCast
$LN2@SafetyCast:
  077b8	8b 45 e4	 mov	 eax, DWORD PTR _j$238655[ebp]
  077bb	83 c0 01	 add	 eax, 1
  077be	89 45 e4	 mov	 DWORD PTR _j$238655[ebp], eax
$LN3@SafetyCast:
  077c1	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238647[ebp]
  077c4	c1 e0 02	 shl	 eax, 2
  077c7	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  077ca	0f b6 94 c8 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8+3]
  077d2	39 55 e4	 cmp	 DWORD PTR _j$238655[ebp], edx
  077d5	7f 3c		 jg	 SHORT $LN1@SafetyCast

; 2567 : 			{
; 2568 : 				MapC[iMapNumber].m_attrbuf[ j * 256 + i] |= 8;

  077d7	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  077da	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  077e0	8b 4d e4	 mov	 ecx, DWORD PTR _j$238655[ebp]
  077e3	c1 e1 08	 shl	 ecx, 8
  077e6	03 4d e8	 add	 ecx, DWORD PTR _i$238651[ebp]
  077e9	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  077ef	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  077f3	83 c8 08	 or	 eax, 8
  077f6	8b 4d f8	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  077f9	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  077ff	8b 55 e4	 mov	 edx, DWORD PTR _j$238655[ebp]
  07802	c1 e2 08	 shl	 edx, 8
  07805	03 55 e8	 add	 edx, DWORD PTR _i$238651[ebp]
  07808	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  0780e	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2569 : 			}

  07811	eb a5		 jmp	 SHORT $LN2@SafetyCast
$LN1@SafetyCast:

; 2570 : 		}

  07813	e9 6b ff ff ff	 jmp	 $LN5@SafetyCast
$LN4@SafetyCast:

; 2571 : 	}

  07818	e9 3d ff ff ff	 jmp	 $LN8@SafetyCast
$LN17@SafetyCast:

; 2572 : }

  0781d	5f		 pop	 edi
  0781e	5e		 pop	 esi
  0781f	5b		 pop	 ebx
  07820	8b e5		 mov	 esp, ebp
  07822	5d		 pop	 ebp
  07823	c2 04 00	 ret	 4
?SafetyCastleZone@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SafetyCastleZone
; Function compile flags: /Odtp /ZI
tv67 = -96						; size = 4
_j$238681 = -28						; size = 4
_i$238677 = -24						; size = 4
_iHOLE_NUM$238673 = -20					; size = 4
_j$238669 = -16						; size = 4
_i$238665 = -12						; size = 4
_iMapNumber$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::UnSafetyCastleZone
; _this$ = ecx

; 2575 : {

  07830	55		 push	 ebp
  07831	8b ec		 mov	 ebp, esp
  07833	83 ec 60	 sub	 esp, 96			; 00000060H
  07836	53		 push	 ebx
  07837	56		 push	 esi
  07838	57		 push	 edi
  07839	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2576 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0783c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  07840	7d 09		 jge	 SHORT $LN19@UnSafetyCa
  07842	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  07849	eb 0c		 jmp	 SHORT $LN20@UnSafetyCa
$LN19@UnSafetyCa:
  0784b	33 c0		 xor	 eax, eax
  0784d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  07851	0f 9e c0	 setle	 al
  07854	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN20@UnSafetyCa:
  07857	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0785b	75 05		 jne	 SHORT $LN16@UnSafetyCa

; 2577 : 	{
; 2578 : 		return;

  0785d	e9 6b 01 00 00	 jmp	 $LN17@UnSafetyCa
$LN16@UnSafetyCa:

; 2579 : 	}
; 2580 : 
; 2581 : 	int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  07862	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07865	50		 push	 eax
  07866	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07869	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  0786e	89 45 f8	 mov	 DWORD PTR _iMapNumber$[ebp], eax

; 2582 : 
; 2583 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  07871	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07874	0f b6 0c 85 00
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4]
  0787c	89 4d f4	 mov	 DWORD PTR _i$238665[ebp], ecx
  0787f	eb 09		 jmp	 SHORT $LN15@UnSafetyCa
$LN14@UnSafetyCa:
  07881	8b 45 f4	 mov	 eax, DWORD PTR _i$238665[ebp]
  07884	83 c0 01	 add	 eax, 1
  07887	89 45 f4	 mov	 DWORD PTR _i$238665[ebp], eax
$LN15@UnSafetyCa:
  0788a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0788d	0f b6 0c 85 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4+2]
  07895	39 4d f4	 cmp	 DWORD PTR _i$238665[ebp], ecx
  07898	7f 67		 jg	 SHORT $LN13@UnSafetyCa

; 2584 : 	{
; 2585 : 		for(int j=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1] ; j <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3] ; j++ )

  0789a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0789d	0f b6 0c 85 01
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4+1]
  078a5	89 4d f0	 mov	 DWORD PTR _j$238669[ebp], ecx
  078a8	eb 09		 jmp	 SHORT $LN12@UnSafetyCa
$LN11@UnSafetyCa:
  078aa	8b 45 f0	 mov	 eax, DWORD PTR _j$238669[ebp]
  078ad	83 c0 01	 add	 eax, 1
  078b0	89 45 f0	 mov	 DWORD PTR _j$238669[ebp], eax
$LN12@UnSafetyCa:
  078b3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  078b6	0f b6 0c 85 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[eax*4+3]
  078be	39 4d f0	 cmp	 DWORD PTR _j$238669[ebp], ecx
  078c1	7f 3c		 jg	 SHORT $LN10@UnSafetyCa

; 2586 : 		{
; 2587 : 			MapC[iMapNumber].m_attrbuf[ j * 256 + i] &= ~1;

  078c3	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  078c6	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  078cc	8b 4d f0	 mov	 ecx, DWORD PTR _j$238669[ebp]
  078cf	c1 e1 08	 shl	 ecx, 8
  078d2	03 4d f4	 add	 ecx, DWORD PTR _i$238665[ebp]
  078d5	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  078db	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  078df	83 e0 fe	 and	 eax, -2			; fffffffeH
  078e2	8b 4d f8	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  078e5	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  078eb	8b 55 f0	 mov	 edx, DWORD PTR _j$238669[ebp]
  078ee	c1 e2 08	 shl	 edx, 8
  078f1	03 55 f4	 add	 edx, DWORD PTR _i$238665[ebp]
  078f4	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  078fa	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2588 : 		}

  078fd	eb ab		 jmp	 SHORT $LN11@UnSafetyCa
$LN10@UnSafetyCa:

; 2589 : 	}

  078ff	eb 80		 jmp	 SHORT $LN14@UnSafetyCa
$LN13@UnSafetyCa:

; 2590 : 
; 2591 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  07901	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iHOLE_NUM$238673[ebp], 0
  07908	eb 09		 jmp	 SHORT $LN9@UnSafetyCa
$LN8@UnSafetyCa:
  0790a	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238673[ebp]
  0790d	83 c0 01	 add	 eax, 1
  07910	89 45 ec	 mov	 DWORD PTR _iHOLE_NUM$238673[ebp], eax
$LN9@UnSafetyCa:
  07913	83 7d ec 02	 cmp	 DWORD PTR _iHOLE_NUM$238673[ebp], 2
  07917	0f 8d b0 00 00
	00		 jge	 $LN17@UnSafetyCa

; 2592 : 	{
; 2593 : 		for(int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  0791d	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238673[ebp]
  07920	c1 e0 02	 shl	 eax, 2
  07923	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07926	0f b6 94 c8 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8]
  0792e	89 55 e8	 mov	 DWORD PTR _i$238677[ebp], edx
  07931	eb 09		 jmp	 SHORT $LN6@UnSafetyCa
$LN5@UnSafetyCa:
  07933	8b 45 e8	 mov	 eax, DWORD PTR _i$238677[ebp]
  07936	83 c0 01	 add	 eax, 1
  07939	89 45 e8	 mov	 DWORD PTR _i$238677[ebp], eax
$LN6@UnSafetyCa:
  0793c	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238673[ebp]
  0793f	c1 e0 02	 shl	 eax, 2
  07942	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07945	0f b6 94 c8 02
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8+2]
  0794d	39 55 e8	 cmp	 DWORD PTR _i$238677[ebp], edx
  07950	7f 76		 jg	 SHORT $LN4@UnSafetyCa

; 2594 : 		{
; 2595 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  07952	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238673[ebp]
  07955	c1 e0 02	 shl	 eax, 2
  07958	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0795b	0f b6 94 c8 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8+1]
  07963	89 55 e4	 mov	 DWORD PTR _j$238681[ebp], edx
  07966	eb 09		 jmp	 SHORT $LN3@UnSafetyCa
$LN2@UnSafetyCa:
  07968	8b 45 e4	 mov	 eax, DWORD PTR _j$238681[ebp]
  0796b	83 c0 01	 add	 eax, 1
  0796e	89 45 e4	 mov	 DWORD PTR _j$238681[ebp], eax
$LN3@UnSafetyCa:
  07971	8b 45 ec	 mov	 eax, DWORD PTR _iHOLE_NUM$238673[ebp]
  07974	c1 e0 02	 shl	 eax, 2
  07977	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0797a	0f b6 94 c8 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleCenterHollowZoneMapXY[eax+ecx*8+3]
  07982	39 55 e4	 cmp	 DWORD PTR _j$238681[ebp], edx
  07985	7f 3c		 jg	 SHORT $LN1@UnSafetyCa

; 2596 : 			{
; 2597 : 				MapC[iMapNumber].m_attrbuf[ j * 256 + i] |= 8;

  07987	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  0798a	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  07990	8b 4d e4	 mov	 ecx, DWORD PTR _j$238681[ebp]
  07993	c1 e1 08	 shl	 ecx, 8
  07996	03 4d e8	 add	 ecx, DWORD PTR _i$238677[ebp]
  07999	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0799f	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  079a3	83 c8 08	 or	 eax, 8
  079a6	8b 4d f8	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  079a9	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  079af	8b 55 e4	 mov	 edx, DWORD PTR _j$238681[ebp]
  079b2	c1 e2 08	 shl	 edx, 8
  079b5	03 55 e8	 add	 edx, DWORD PTR _i$238677[ebp]
  079b8	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  079be	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2598 : 			}

  079c1	eb a5		 jmp	 SHORT $LN2@UnSafetyCa
$LN1@UnSafetyCa:

; 2599 : 		}

  079c3	e9 6b ff ff ff	 jmp	 $LN5@UnSafetyCa
$LN4@UnSafetyCa:

; 2600 : 	}

  079c8	e9 3d ff ff ff	 jmp	 $LN8@UnSafetyCa
$LN17@UnSafetyCa:

; 2601 : }

  079cd	5f		 pop	 edi
  079ce	5e		 pop	 esi
  079cf	5b		 pop	 ebx
  079d0	8b e5		 mov	 esp, ebp
  079d2	5d		 pop	 ebp
  079d3	c2 04 00	 ret	 4
?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::UnSafetyCastleZone
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -344						; size = 4
tv80 = -341						; size = 1
_i$238699 = -276					; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_bDoSet$ = 12						; size = 1
?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z PROC	; CChaosCastle::SendCastleZoneSafetyInfo
; _this$ = ecx

; 2604 : {

  079e0	55		 push	 ebp
  079e1	8b ec		 mov	 ebp, esp
  079e3	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  079e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  079ee	33 c5		 xor	 eax, ebp
  079f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  079f3	53		 push	 ebx
  079f4	56		 push	 esi
  079f5	57		 push	 edi
  079f6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2605 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  079f9	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  079fd	7d 0c		 jge	 SHORT $LN9@SendCastle
  079ff	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  07a09	eb 0f		 jmp	 SHORT $LN10@SendCastle
$LN9@SendCastle:
  07a0b	33 c0		 xor	 eax, eax
  07a0d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  07a11	0f 9e c0	 setle	 al
  07a14	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@SendCastle:
  07a1a	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  07a21	75 05		 jne	 SHORT $LN6@SendCastle

; 2606 : 	{
; 2607 : 		return ;

  07a23	e9 50 01 00 00	 jmp	 $LN7@SendCastle
$LN6@SendCastle:

; 2608 : 	}
; 2609 : 
; 2610 : 	char cTEMP_BUF[256];
; 2611 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;

  07a28	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  07a2e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2612 : 
; 2613 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  07a34	6a 13		 push	 19			; 00000013H
  07a36	6a 46		 push	 70			; 00000046H
  07a38	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07a3e	50		 push	 eax
  07a3f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  07a44	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2614 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];

  07a47	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  07a4d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2615 : 
; 2616 : 	lpMsg->btType = 0;

  07a53	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07a59	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2617 : 	lpMsg->btCount = 1;

  07a5d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07a63	c6 40 06 01	 mov	 BYTE PTR [eax+6], 1

; 2618 : 	lpMsg->btMapAttr = 1;

  07a67	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07a6d	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 2619 : 
; 2620 : 	(bDoSet)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);

  07a71	0f b6 45 0c	 movzx	 eax, BYTE PTR _bDoSet$[ebp]
  07a75	85 c0		 test	 eax, eax
  07a77	74 13		 je	 SHORT $LN11@SendCastle
  07a79	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  07a7f	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  07a83	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  07a8a	eb 11		 jmp	 SHORT $LN12@SendCastle
$LN11@SendCastle:
  07a8c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  07a92	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  07a96	c6 85 ab fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN12@SendCastle:

; 2621 : 
; 2622 : 	lpMsgBody[0].btX = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0];

  07a9d	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  07aa3	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07aa6	8a 14 8d 00 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleSafetyZoneMapXY[ecx*4]
  07aad	88 10		 mov	 BYTE PTR [eax], dl

; 2623 : 	lpMsgBody[0].btY = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1];

  07aaf	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  07ab5	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07ab8	8a 14 8d 01 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleSafetyZoneMapXY[ecx*4+1]
  07abf	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 2624 : 	lpMsgBody[1].btX   = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2];

  07ac2	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  07ac8	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07acb	8a 14 8d 02 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleSafetyZoneMapXY[ecx*4+2]
  07ad2	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 2625 : 	lpMsgBody[1].btY   = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3];

  07ad5	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  07adb	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  07ade	8a 14 8d 03 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleSafetyZoneMapXY[ecx*4+3]
  07ae5	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 2626 : 
; 2627 : 	for (int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  07ae8	c7 85 ec fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$238699[ebp], 14000 ; 000036b0H
  07af2	eb 0f		 jmp	 SHORT $LN5@SendCastle
$LN4@SendCastle:
  07af4	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$238699[ebp]
  07afa	83 c0 01	 add	 eax, 1
  07afd	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$238699[ebp], eax
$LN5@SendCastle:
  07b03	81 bd ec fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$238699[ebp], 15000 ; 00003a98H
  07b0d	7d 69		 jge	 SHORT $LN7@SendCastle

; 2628 : 	{
; 2629 : 		if ( gObj[i].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  07b0f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$238699[ebp]
  07b15	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07b1b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07b21	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  07b29	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  07b2c	52		 push	 edx
  07b2d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07b30	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  07b35	3b f0		 cmp	 esi, eax
  07b37	75 3a		 jne	 SHORT $LN2@SendCastle

; 2630 : 		{
; 2631 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  07b39	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$238699[ebp]
  07b3f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07b45	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07b4b	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  07b50	7e 21		 jle	 SHORT $LN2@SendCastle

; 2632 : 			{
; 2633 : 				DataSend(i, (LPBYTE)lpMsg, lpMsg->h.size);

  07b52	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07b58	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  07b5c	51		 push	 ecx
  07b5d	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  07b63	52		 push	 edx
  07b64	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$238699[ebp]
  07b6a	50		 push	 eax
  07b6b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  07b70	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendCastle:

; 2634 : 			}
; 2635 : 		}
; 2636 : 	}

  07b73	e9 7c ff ff ff	 jmp	 $LN4@SendCastle
$LN7@SendCastle:

; 2637 : }

  07b78	5f		 pop	 edi
  07b79	5e		 pop	 esi
  07b7a	5b		 pop	 ebx
  07b7b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07b7e	33 cd		 xor	 ecx, ebp
  07b80	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07b85	8b e5		 mov	 esp, ebp
  07b87	5d		 pop	 ebp
  07b88	c2 08 00	 ret	 8
?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ENDP	; CChaosCastle::SendCastleZoneSafetyInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
xdata$x	SEGMENT
__unwindtable$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z$0
__ehfuncinfo$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv196 = -224						; size = 4
tv197 = -220						; size = 4
tv167 = -220						; size = 4
tv67 = -220						; size = 4
_ptEMPTY$238756 = -152					; size = 8
_n$238749 = -144					; size = 4
_btMapAttr$238747 = -137				; size = 1
_iMapNumber$238746 = -136				; size = 4
_iSY$238745 = -132					; size = 4
_iSX$238744 = -128					; size = 4
_iMON_INDEX$238741 = -124				; size = 4
_iMON$238736 = -120					; size = 4
_iPT$238735 = -116					; size = 8
_btMapAttr$238733 = -105				; size = 1
_iMapNumber$238732 = -104				; size = 4
_iMAPY$238728 = -100					; size = 4
_iMAPX$238724 = -96					; size = 4
_iAXIS$238720 = -92					; size = 4
_vtMAP_UNTRAP$ = -88					; size = 64
_iUSER_AXIS$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z PROC	; CChaosCastle::CheckMonsterInDieTile
; _this$ = ecx

; 2640 : {

  07b90	55		 push	 ebp
  07b91	8b ec		 mov	 ebp, esp
  07b93	6a ff		 push	 -1
  07b95	68 00 00 00 00	 push	 __ehhandler$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
  07b9a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  07ba0	50		 push	 eax
  07ba1	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  07ba7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07bac	33 c5		 xor	 eax, ebp
  07bae	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07bb1	53		 push	 ebx
  07bb2	56		 push	 esi
  07bb3	57		 push	 edi
  07bb4	50		 push	 eax
  07bb5	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  07bb8	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  07bbe	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2641 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  07bc1	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  07bc5	7d 0c		 jge	 SHORT $LN28@CheckMonst
  07bc7	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  07bd1	eb 0f		 jmp	 SHORT $LN29@CheckMonst
$LN28@CheckMonst:
  07bd3	33 c0		 xor	 eax, eax
  07bd5	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  07bd9	0f 9e c0	 setle	 al
  07bdc	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN29@CheckMonst:
  07be2	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  07be9	75 05		 jne	 SHORT $LN25@CheckMonst

; 2642 : 	{
; 2643 : 		return;

  07beb	e9 4a 04 00 00	 jmp	 $LN26@CheckMonst
$LN25@CheckMonst:

; 2644 : 	}
; 2645 : 
; 2646 : 	int iUSER_AXIS = 0;

  07bf0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iUSER_AXIS$[ebp], 0

; 2647 : 	std::vector<POINT> vtMAP_UNTRAP[4];

  07bf7	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  07bfc	68 00 00 00 00	 push	 OFFSET ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
  07c01	6a 04		 push	 4
  07c03	6a 10		 push	 16			; 00000010H
  07c05	8d 45 a8	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  07c08	50		 push	 eax
  07c09	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  07c0e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2648 : 
; 2649 : 	for ( int iAXIS =0;iAXIS < 4 ; iAXIS++)

  07c15	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _iAXIS$238720[ebp], 0
  07c1c	eb 09		 jmp	 SHORT $LN24@CheckMonst
$LN23@CheckMonst:
  07c1e	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$238720[ebp]
  07c21	83 c0 01	 add	 eax, 1
  07c24	89 45 a4	 mov	 DWORD PTR _iAXIS$238720[ebp], eax
$LN24@CheckMonst:
  07c27	83 7d a4 04	 cmp	 DWORD PTR _iAXIS$238720[ebp], 4
  07c2b	0f 8d d1 00 00
	00		 jge	 $LN22@CheckMonst

; 2650 : 	{
; 2651 : 		for(int iMAPX = g_rtPOINT_TRAP[iAXIS].left; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX++)

  07c31	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$238720[ebp]
  07c34	c1 e0 04	 shl	 eax, 4
  07c37	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax]
  07c3d	89 4d a0	 mov	 DWORD PTR _iMAPX$238724[ebp], ecx
  07c40	eb 09		 jmp	 SHORT $LN21@CheckMonst
$LN20@CheckMonst:
  07c42	8b 45 a0	 mov	 eax, DWORD PTR _iMAPX$238724[ebp]
  07c45	83 c0 01	 add	 eax, 1
  07c48	89 45 a0	 mov	 DWORD PTR _iMAPX$238724[ebp], eax
$LN21@CheckMonst:
  07c4b	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$238720[ebp]
  07c4e	c1 e0 04	 shl	 eax, 4
  07c51	8b 4d a0	 mov	 ecx, DWORD PTR _iMAPX$238724[ebp]
  07c54	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax+8]
  07c5a	0f 8f 9d 00 00
	00		 jg	 $LN19@CheckMonst

; 2652 : 		{
; 2653 : 			for(int iMAPY = g_rtPOINT_TRAP[iAXIS].top; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++)

  07c60	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$238720[ebp]
  07c63	c1 e0 04	 shl	 eax, 4
  07c66	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax+4]
  07c6c	89 4d 9c	 mov	 DWORD PTR _iMAPY$238728[ebp], ecx
  07c6f	eb 09		 jmp	 SHORT $LN18@CheckMonst
$LN17@CheckMonst:
  07c71	8b 45 9c	 mov	 eax, DWORD PTR _iMAPY$238728[ebp]
  07c74	83 c0 01	 add	 eax, 1
  07c77	89 45 9c	 mov	 DWORD PTR _iMAPY$238728[ebp], eax
$LN18@CheckMonst:
  07c7a	8b 45 a4	 mov	 eax, DWORD PTR _iAXIS$238720[ebp]
  07c7d	c1 e0 04	 shl	 eax, 4
  07c80	8b 4d 9c	 mov	 ecx, DWORD PTR _iMAPY$238728[ebp]
  07c83	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_TRAP[eax+12]
  07c89	7f 6d		 jg	 SHORT $LN16@CheckMonst

; 2654 : 			{
; 2655 : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  07c8b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07c8e	50		 push	 eax
  07c8f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  07c92	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  07c97	89 45 98	 mov	 DWORD PTR _iMapNumber$238732[ebp], eax

; 2656 : 
; 2657 : 				BYTE btMapAttr = MapC[iMapNumber].GetAttr(iMAPX, iMAPY);

  07c9a	8b 45 9c	 mov	 eax, DWORD PTR _iMAPY$238728[ebp]
  07c9d	50		 push	 eax
  07c9e	8b 4d a0	 mov	 ecx, DWORD PTR _iMAPX$238724[ebp]
  07ca1	51		 push	 ecx
  07ca2	8b 4d 98	 mov	 ecx, DWORD PTR _iMapNumber$238732[ebp]
  07ca5	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  07cab	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  07cb1	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  07cb6	88 45 97	 mov	 BYTE PTR _btMapAttr$238733[ebp], al

; 2658 : 
; 2659 : 				if ( (btMapAttr&2)!= 2 && (btMapAttr&4)!= 4 && (btMapAttr&8)!= 8 )

  07cb9	0f b6 45 97	 movzx	 eax, BYTE PTR _btMapAttr$238733[ebp]
  07cbd	83 e0 02	 and	 eax, 2
  07cc0	75 31		 jne	 SHORT $LN15@CheckMonst
  07cc2	0f b6 45 97	 movzx	 eax, BYTE PTR _btMapAttr$238733[ebp]
  07cc6	83 e0 04	 and	 eax, 4
  07cc9	75 28		 jne	 SHORT $LN15@CheckMonst
  07ccb	0f b6 45 97	 movzx	 eax, BYTE PTR _btMapAttr$238733[ebp]
  07ccf	83 e0 08	 and	 eax, 8
  07cd2	75 1f		 jne	 SHORT $LN15@CheckMonst

; 2660 : 				{
; 2661 : 					POINT iPT = {iMAPX, iMAPY};

  07cd4	8b 45 a0	 mov	 eax, DWORD PTR _iMAPX$238724[ebp]
  07cd7	89 45 8c	 mov	 DWORD PTR _iPT$238735[ebp], eax
  07cda	8b 45 9c	 mov	 eax, DWORD PTR _iMAPY$238728[ebp]
  07cdd	89 45 90	 mov	 DWORD PTR _iPT$238735[ebp+4], eax

; 2662 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  07ce0	8d 45 8c	 lea	 eax, DWORD PTR _iPT$238735[ebp]
  07ce3	50		 push	 eax
  07ce4	8b 4d a4	 mov	 ecx, DWORD PTR _iAXIS$238720[ebp]
  07ce7	c1 e1 04	 shl	 ecx, 4
  07cea	8d 4c 0d a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx]
  07cee	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
$LN15@CheckMonst:

; 2663 : 				}
; 2664 : 			}

  07cf3	e9 79 ff ff ff	 jmp	 $LN17@CheckMonst
$LN16@CheckMonst:

; 2665 : 		}

  07cf8	e9 45 ff ff ff	 jmp	 $LN20@CheckMonst
$LN19@CheckMonst:

; 2666 : 	}

  07cfd	e9 1c ff ff ff	 jmp	 $LN23@CheckMonst
$LN22@CheckMonst:

; 2667 : 
; 2668 : 	for(int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON ++ )

  07d02	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _iMON$238736[ebp], 0
  07d09	eb 09		 jmp	 SHORT $LN14@CheckMonst
$LN13@CheckMonst:
  07d0b	8b 45 88	 mov	 eax, DWORD PTR _iMON$238736[ebp]
  07d0e	83 c0 01	 add	 eax, 1
  07d11	89 45 88	 mov	 DWORD PTR _iMON$238736[ebp], eax
$LN14@CheckMonst:
  07d14	83 7d 88 64	 cmp	 DWORD PTR _iMON$238736[ebp], 100 ; 00000064H
  07d18	0f 8d 03 03 00
	00		 jge	 $LN12@CheckMonst

; 2669 : 	{
; 2670 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  07d1e	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07d21	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  07d27	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  07d2a	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  07d2e	8b 45 88	 mov	 eax, DWORD PTR _iMON$238736[ebp]
  07d31	83 bc 82 b4 05
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+1460], -1
  07d39	75 02		 jne	 SHORT $LN11@CheckMonst

; 2671 : 		{
; 2672 : 			continue;

  07d3b	eb ce		 jmp	 SHORT $LN13@CheckMonst
$LN11@CheckMonst:

; 2673 : 		}
; 2674 : 
; 2675 : 		int iMON_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON];

  07d3d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07d40	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  07d46	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  07d49	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  07d4d	8b 45 88	 mov	 eax, DWORD PTR _iMON$238736[ebp]
  07d50	8b 8c 82 b4 05
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+1460]
  07d57	89 4d 84	 mov	 DWORD PTR _iMON_INDEX$238741[ebp], ecx

; 2676 : 
; 2677 : 		if ( !CHECK_LIMIT(iMON_INDEX, OBJ_MAXMONSTER))

  07d5a	83 7d 84 00	 cmp	 DWORD PTR _iMON_INDEX$238741[ebp], 0
  07d5e	7d 0c		 jge	 SHORT $LN30@CheckMonst
  07d60	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv167[ebp], 0
  07d6a	eb 12		 jmp	 SHORT $LN31@CheckMonst
$LN30@CheckMonst:
  07d6c	33 c0		 xor	 eax, eax
  07d6e	81 7d 84 c7 32
	00 00		 cmp	 DWORD PTR _iMON_INDEX$238741[ebp], 12999 ; 000032c7H
  07d75	0f 9e c0	 setle	 al
  07d78	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
$LN31@CheckMonst:
  07d7e	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv167[ebp], 0
  07d85	75 23		 jne	 SHORT $LN10@CheckMonst

; 2678 : 		{
; 2679 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] = -1;

  07d87	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07d8a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  07d90	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  07d93	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  07d97	8b 45 88	 mov	 eax, DWORD PTR _iMON$238736[ebp]
  07d9a	c7 84 82 b4 05
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax*4+1460], -1

; 2680 : 			continue;

  07da5	e9 61 ff ff ff	 jmp	 $LN13@CheckMonst
$LN10@CheckMonst:

; 2681 : 		}
; 2682 : 
; 2683 : 		if ( gObj[iMON_INDEX].Life > 0.0f && CC_MAP_RANGE(gObj[iMON_INDEX].MapNumber) != FALSE && gObj[iMON_INDEX].Connected > PLAYER_EMPTY )

  07daa	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07dad	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07db3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07db9	d9 84 01 fc 00
	00 00		 fld	 DWORD PTR [ecx+eax+252]
  07dc0	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  07dc6	df e0		 fnstsw	 ax
  07dc8	f6 c4 41	 test	 ah, 65			; 00000041H
  07dcb	0f 85 4b 02 00
	00		 jne	 $LN1@CheckMonst
  07dd1	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07dd4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07dda	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07de0	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  07de8	83 fa 35	 cmp	 edx, 53			; 00000035H
  07deb	75 0c		 jne	 SHORT $LN34@CheckMonst
  07ded	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv197[ebp], 1
  07df7	eb 59		 jmp	 SHORT $LN35@CheckMonst
$LN34@CheckMonst:
  07df9	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07dfc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07e02	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07e08	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  07e10	83 fa 12	 cmp	 edx, 18			; 00000012H
  07e13	7d 0c		 jge	 SHORT $LN32@CheckMonst
  07e15	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
  07e1f	eb 25		 jmp	 SHORT $LN33@CheckMonst
$LN32@CheckMonst:
  07e21	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07e24	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07e2a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07e30	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  07e38	33 c0		 xor	 eax, eax
  07e3a	83 fa 17	 cmp	 edx, 23			; 00000017H
  07e3d	0f 9e c0	 setle	 al
  07e40	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], eax
$LN33@CheckMonst:
  07e46	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv196[ebp]
  07e4c	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], ecx
$LN35@CheckMonst:
  07e52	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv197[ebp], 0
  07e59	0f 84 bd 01 00
	00		 je	 $LN1@CheckMonst
  07e5f	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07e62	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07e68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07e6e	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  07e73	0f 8e a3 01 00
	00		 jle	 $LN1@CheckMonst

; 2684 : 		{
; 2685 : 			int iSX = gObj[iMON_INDEX].X;

  07e79	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07e7c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07e82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07e88	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  07e90	89 55 80	 mov	 DWORD PTR _iSX$238744[ebp], edx

; 2686 : 			int iSY = gObj[iMON_INDEX].Y;

  07e93	8b 45 84	 mov	 eax, DWORD PTR _iMON_INDEX$238741[ebp]
  07e96	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07e9c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07ea2	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  07eaa	89 95 7c ff ff
	ff		 mov	 DWORD PTR _iSY$238745[ebp], edx

; 2687 : 
; 2688 : 			int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  07eb0	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  07eb3	50		 push	 eax
  07eb4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  07eb7	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  07ebc	89 85 78 ff ff
	ff		 mov	 DWORD PTR _iMapNumber$238746[ebp], eax

; 2689 : 
; 2690 : 			BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  07ec2	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$238746[ebp]
  07ec8	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  07ece	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iSY$238745[ebp]
  07ed4	c1 e1 08	 shl	 ecx, 8
  07ed7	03 4d 80	 add	 ecx, DWORD PTR _iSX$238744[ebp]
  07eda	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  07ee0	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  07ee4	83 e0 08	 and	 eax, 8
  07ee7	88 85 77 ff ff
	ff		 mov	 BYTE PTR _btMapAttr$238747[ebp], al

; 2691 : 
; 2692 : 			if ( btMapAttr == 8 )

  07eed	0f b6 85 77 ff
	ff ff		 movzx	 eax, BYTE PTR _btMapAttr$238747[ebp]
  07ef4	83 f8 08	 cmp	 eax, 8
  07ef7	0f 85 1f 01 00
	00		 jne	 $LN1@CheckMonst

; 2693 : 			{
; 2694 : 				 int n=0;

  07efd	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$238749[ebp], 0

; 2695 : 				for ( n=0;n<MAX_CC_TRAP_STEP;n++)

  07f07	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$238749[ebp], 0
  07f11	eb 0f		 jmp	 SHORT $LN7@CheckMonst
$LN6@CheckMonst:
  07f13	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _n$238749[ebp]
  07f19	83 c0 01	 add	 eax, 1
  07f1c	89 85 70 ff ff
	ff		 mov	 DWORD PTR _n$238749[ebp], eax
$LN7@CheckMonst:
  07f22	83 bd 70 ff ff
	ff 04		 cmp	 DWORD PTR _n$238749[ebp], 4
  07f29	7d 63		 jge	 SHORT $LN5@CheckMonst

; 2696 : 				{
; 2697 : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right && iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  07f2b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _n$238749[ebp]
  07f31	c1 e0 04	 shl	 eax, 4
  07f34	8b 4d 80	 mov	 ecx, DWORD PTR _iSX$238744[ebp]
  07f37	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax]
  07f3d	7c 4d		 jl	 SHORT $LN4@CheckMonst
  07f3f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _n$238749[ebp]
  07f45	c1 e0 04	 shl	 eax, 4
  07f48	8b 4d 80	 mov	 ecx, DWORD PTR _iSX$238744[ebp]
  07f4b	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+8]
  07f51	7f 39		 jg	 SHORT $LN4@CheckMonst
  07f53	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _n$238749[ebp]
  07f59	c1 e0 04	 shl	 eax, 4
  07f5c	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iSY$238745[ebp]
  07f62	3b 88 04 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+4]
  07f68	7c 22		 jl	 SHORT $LN4@CheckMonst
  07f6a	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _n$238749[ebp]
  07f70	c1 e0 04	 shl	 eax, 4
  07f73	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iSY$238745[ebp]
  07f79	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_rtPOINT_FRAME[eax+12]
  07f7f	7f 0b		 jg	 SHORT $LN4@CheckMonst

; 2698 : 					{
; 2699 : 						iUSER_AXIS = n;

  07f81	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _n$238749[ebp]
  07f87	89 45 e8	 mov	 DWORD PTR _iUSER_AXIS$[ebp], eax

; 2700 : 						break;

  07f8a	eb 02		 jmp	 SHORT $LN5@CheckMonst
$LN4@CheckMonst:

; 2701 : 					}
; 2702 : 				}

  07f8c	eb 85		 jmp	 SHORT $LN6@CheckMonst
$LN5@CheckMonst:

; 2703 : 
; 2704 : 				if (n == MAX_CC_TRAP_STEP )

  07f8e	83 bd 70 ff ff
	ff 04		 cmp	 DWORD PTR _n$238749[ebp], 4
  07f95	75 05		 jne	 SHORT $LN3@CheckMonst

; 2705 : 				{
; 2706 : 					continue;

  07f97	e9 6f fd ff ff	 jmp	 $LN13@CheckMonst
$LN3@CheckMonst:

; 2707 : 				}
; 2708 : 
; 2709 : 				if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  07f9c	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  07f9f	c1 e0 04	 shl	 eax, 4
  07fa2	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  07fa6	e8 00 00 00 00	 call	 ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
  07fab	0f b6 c8	 movzx	 ecx, al
  07fae	85 c9		 test	 ecx, ecx
  07fb0	75 6a		 jne	 SHORT $LN1@CheckMonst

; 2710 : 				{
; 2711 : 					POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  07fb2	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  07fb5	c1 e0 04	 shl	 eax, 4
  07fb8	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  07fbc	e8 00 00 00 00	 call	 ?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
  07fc1	8b 08		 mov	 ecx, DWORD PTR [eax]
  07fc3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  07fc6	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _ptEMPTY$238756[ebp], ecx
  07fcc	89 95 6c ff ff
	ff		 mov	 DWORD PTR _ptEMPTY$238756[ebp+4], edx

; 2712 : 					vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  07fd2	8b 45 e8	 mov	 eax, DWORD PTR _iUSER_AXIS$[ebp]
  07fd5	c1 e0 04	 shl	 eax, 4
  07fd8	8d 4c 05 a8	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+eax]
  07fdc	e8 00 00 00 00	 call	 ?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back

; 2713 : 
; 2714 : 					if ( this->ObjSetPosition(iMON_INDEX, ptEMPTY.x, ptEMPTY.y) == TRUE )

  07fe1	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _ptEMPTY$238756[ebp+4]
  07fe7	50		 push	 eax
  07fe8	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _ptEMPTY$238756[ebp]
  07fee	51		 push	 ecx
  07fef	8b 55 84	 mov	 edx, DWORD PTR _iMON_INDEX$238741[ebp]
  07ff2	52		 push	 edx
  07ff3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  07ff6	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  07ffb	83 f8 01	 cmp	 eax, 1
  07ffe	75 1c		 jne	 SHORT $LN1@CheckMonst

; 2715 : 					{
; 2716 : 						gObj[iMON_INDEX].m_iChaosCastleBlowTime = GetTickCount();

  08000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  08006	8b 4d 84	 mov	 ecx, DWORD PTR _iMON_INDEX$238741[ebp]
  08009	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0800f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08015	89 84 0a a8 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3752], eax
$LN1@CheckMonst:

; 2717 : 					}
; 2718 : 				}
; 2719 : 			}
; 2720 : 		}
; 2721 : 	}

  0801c	e9 ea fc ff ff	 jmp	 $LN13@CheckMonst
$LN12@CheckMonst:

; 2722 : }

  08021	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  08028	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  0802d	6a 04		 push	 4
  0802f	6a 10		 push	 16			; 00000010H
  08031	8d 45 a8	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  08034	50		 push	 eax
  08035	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN26@CheckMonst:
  0803a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0803d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  08044	59		 pop	 ecx
  08045	5f		 pop	 edi
  08046	5e		 pop	 esi
  08047	5b		 pop	 ebx
  08048	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0804b	33 cd		 xor	 ecx, ebp
  0804d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08052	8b e5		 mov	 esp, ebp
  08054	5d		 pop	 ebp
  08055	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z$0:
  000a0	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  000a5	6a 04		 push	 4
  000a7	6a 10		 push	 16			; 00000010H
  000a9	8d 45 a8	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  000b2	c3		 ret	 0
__ehhandler$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z:
  000b3	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000b7	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ba	8b 8a 1c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-228]
  000c0	33 c8		 xor	 ecx, eax
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000ca	33 c8		 xor	 ecx, eax
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
  000d6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z ENDP	; CChaosCastle::CheckMonsterInDieTile
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -92						; size = 4
_btMapAttr$238773 = -21					; size = 1
_iMapNumber$238772 = -20				; size = 4
_iSY$238771 = -16					; size = 4
_iSX$238770 = -12					; size = 4
_i$238763 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckUserInDieTile@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::CheckUserInDieTile
; _this$ = ecx

; 2725 : {

  08060	55		 push	 ebp
  08061	8b ec		 mov	 ebp, esp
  08063	83 ec 5c	 sub	 esp, 92			; 0000005cH
  08066	53		 push	 ebx
  08067	56		 push	 esi
  08068	57		 push	 edi
  08069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2726 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0806c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  08070	7d 09		 jge	 SHORT $LN11@CheckUserI
  08072	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  08079	eb 0c		 jmp	 SHORT $LN12@CheckUserI
$LN11@CheckUserI:
  0807b	33 c0		 xor	 eax, eax
  0807d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  08081	0f 9e c0	 setle	 al
  08084	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckUserI:
  08087	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0808b	75 05		 jne	 SHORT $LN8@CheckUserI

; 2727 : 		return;

  0808d	e9 96 03 00 00	 jmp	 $LN9@CheckUserI
$LN8@CheckUserI:

; 2728 : 
; 2729 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  08092	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$238763[ebp], 0
  08099	eb 09		 jmp	 SHORT $LN7@CheckUserI
$LN6@CheckUserI:
  0809b	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0809e	83 c0 01	 add	 eax, 1
  080a1	89 45 f8	 mov	 DWORD PTR _i$238763[ebp], eax
$LN7@CheckUserI:
  080a4	83 7d f8 46	 cmp	 DWORD PTR _i$238763[ebp], 70 ; 00000046H
  080a8	0f 8d 7a 03 00
	00		 jge	 $LN5@CheckUserI

; 2730 : 	{
; 2731 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  080ae	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  080b1	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  080b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  080ba	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  080be	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  080c1	6b c0 14	 imul	 eax, 20			; 00000014H
  080c4	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  080c9	0f 84 54 03 00
	00		 je	 $LN1@CheckUserI

; 2732 : 		{
; 2733 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2734 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  080cf	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  080d2	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  080d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  080db	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  080df	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  080e2	6b c0 14	 imul	 eax, 20			; 00000014H
  080e5	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  080e9	51		 push	 ecx
  080ea	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  080ef	83 c4 04	 add	 esp, 4
  080f2	83 f8 01	 cmp	 eax, 1
  080f5	0f 85 28 03 00
	00		 jne	 $LN1@CheckUserI
  080fb	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  080fe	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08107	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0810b	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0810e	6b c0 14	 imul	 eax, 20			; 00000014H
  08111	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08115	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0811b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08121	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  08129	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0812c	50		 push	 eax
  0812d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08130	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  08135	3b f0		 cmp	 esi, eax
  08137	0f 85 e6 02 00
	00		 jne	 $LN1@CheckUserI

; 2735 : 			{
; 2736 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Life > 0.0 )

  0813d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08140	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08146	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08149	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0814d	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  08150	6b c0 14	 imul	 eax, 20			; 00000014H
  08153	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08157	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0815d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08163	d9 84 0a fc 00
	00 00		 fld	 DWORD PTR [edx+ecx+252]
  0816a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  08170	df e0		 fnstsw	 ax
  08172	f6 c4 41	 test	 ah, 65			; 00000041H
  08175	0f 85 a8 02 00
	00		 jne	 $LN1@CheckUserI

; 2737 : 				{
; 2738 : 					int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  0817b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0817e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08184	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08187	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0818b	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0818e	6b c0 14	 imul	 eax, 20			; 00000014H
  08191	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08195	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0819b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  081a1	0f bf 84 0a 44
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+324]
  081a9	89 45 f4	 mov	 DWORD PTR _iSX$238770[ebp], eax

; 2739 : 					int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;

  081ac	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  081af	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  081b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  081b8	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  081bc	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  081bf	6b c0 14	 imul	 eax, 20			; 00000014H
  081c2	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  081c6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  081cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  081d2	0f bf 84 0a 46
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+326]
  081da	89 45 f0	 mov	 DWORD PTR _iSY$238771[ebp], eax

; 2740 : 
; 2741 : 					int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  081dd	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  081e0	50		 push	 eax
  081e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  081e4	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  081e9	89 45 ec	 mov	 DWORD PTR _iMapNumber$238772[ebp], eax

; 2742 : 
; 2743 : 					BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  081ec	8b 45 ec	 mov	 eax, DWORD PTR _iMapNumber$238772[ebp]
  081ef	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  081f5	8b 4d f0	 mov	 ecx, DWORD PTR _iSY$238771[ebp]
  081f8	c1 e1 08	 shl	 ecx, 8
  081fb	03 4d f4	 add	 ecx, DWORD PTR _iSX$238770[ebp]
  081fe	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  08204	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  08208	83 e0 08	 and	 eax, 8
  0820b	88 45 eb	 mov	 BYTE PTR _btMapAttr$238773[ebp], al

; 2744 : 
; 2745 : 					if ( btMapAttr == 8 )

  0820e	0f b6 45 eb	 movzx	 eax, BYTE PTR _btMapAttr$238773[ebp]
  08212	83 f8 08	 cmp	 eax, 8
  08215	0f 85 08 02 00
	00		 jne	 $LN1@CheckUserI

; 2746 : 					{
; 2747 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Life = 0;

  0821b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0821e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08224	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08227	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0822b	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0822e	6b c0 14	 imul	 eax, 20			; 00000014H
  08231	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08235	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0823b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08241	d9 ee		 fldz
  08243	d9 9c 0a fc 00
	00 00		 fstp	 DWORD PTR [edx+ecx+252]

; 2748 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_State = 4;

  0824a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0824d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08253	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08256	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0825a	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0825d	6b c0 14	 imul	 eax, 20			; 00000014H
  08260	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08264	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0826a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08270	c7 84 0a 20 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [edx+ecx+544], 4

; 2749 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].KillerType = 1;

  0827b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0827e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08284	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08287	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0828b	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0828e	6b c0 14	 imul	 eax, 20			; 00000014H
  08291	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08295	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0829b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  082a1	c6 84 0a a1 03
	00 00 01	 mov	 BYTE PTR [edx+ecx+929], 1

; 2750 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].RegenTime = GetTickCount();

  082a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  082af	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  082b2	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  082b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  082bb	8d 4c 0a 30	 lea	 ecx, DWORD PTR [edx+ecx+48]
  082bf	8b 55 f8	 mov	 edx, DWORD PTR _i$238763[ebp]
  082c2	6b d2 14	 imul	 edx, 20			; 00000014H
  082c5	8b 4c 11 3c	 mov	 ecx, DWORD PTR [ecx+edx+60]
  082c9	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  082cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  082d5	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 2751 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].DieRegen = 1;

  082dc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  082df	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  082e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  082e8	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  082ec	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  082ef	6b c0 14	 imul	 eax, 20			; 00000014H
  082f2	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  082f6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  082fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08302	c6 84 0a a2 03
	00 00 01	 mov	 BYTE PTR [edx+ecx+930], 1

; 2752 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].PathCount = 0;

  0830a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0830d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08313	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08316	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0831a	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0831d	6b c0 14	 imul	 eax, 20			; 00000014H
  08320	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08324	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0832a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08330	c7 84 0a 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+388], 0

; 2753 : 
; 2754 : 						GCDiePlayerSend(&gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex],
; 2755 : 							this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 0, 0);

  0833b	6a 00		 push	 0
  0833d	6a 00		 push	 0
  0833f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08342	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08348	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0834b	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0834f	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  08352	6b c0 14	 imul	 eax, 20			; 00000014H
  08355	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08359	51		 push	 ecx
  0835a	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0835d	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  08363	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  08366	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  0836a	8b 55 f8	 mov	 edx, DWORD PTR _i$238763[ebp]
  0836d	6b d2 14	 imul	 edx, 20			; 00000014H
  08370	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  08374	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0837a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08380	50		 push	 eax
  08381	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  08386	83 c4 10	 add	 esp, 16			; 00000010H

; 2756 : 
; 2757 : 						LogAddTD("[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall from Castle (X:%d, Y:%d)",
; 2758 : 							iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2759 : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2760 : 							iSX, iSY);

  08389	8b 45 f0	 mov	 eax, DWORD PTR _iSY$238771[ebp]
  0838c	50		 push	 eax
  0838d	8b 4d f4	 mov	 ecx, DWORD PTR _iSX$238770[ebp]
  08390	51		 push	 ecx
  08391	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  08394	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  0839a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0839d	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  083a1	8b 55 f8	 mov	 edx, DWORD PTR _i$238763[ebp]
  083a4	6b d2 14	 imul	 edx, 20			; 00000014H
  083a7	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  083ab	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  083b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  083b7	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  083bb	52		 push	 edx
  083bc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  083bf	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  083c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  083c8	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  083cc	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  083cf	6b c0 14	 imul	 eax, 20			; 00000014H
  083d2	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  083d6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  083dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  083e2	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  083e6	50		 push	 eax
  083e7	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  083ea	83 c1 01	 add	 ecx, 1
  083ed	51		 push	 ecx
  083ee	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  083f3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  083f9	83 c4 18	 add	 esp, 24			; 00000018H

; 2761 : 
; 2762 : 						this->SendFailMessage(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex);

  083fc	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  083ff	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08408	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0840c	8b 45 f8	 mov	 eax, DWORD PTR _i$238763[ebp]
  0840f	6b c0 14	 imul	 eax, 20			; 00000014H
  08412	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08416	51		 push	 ecx
  08417	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0841a	52		 push	 edx
  0841b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0841e	e8 00 00 00 00	 call	 ?SendFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendFailMessage
$LN1@CheckUserI:

; 2763 : 
; 2764 : 					}
; 2765 : 				}
; 2766 : 			}
; 2767 : 		}
; 2768 : 	}

  08423	e9 73 fc ff ff	 jmp	 $LN6@CheckUserI
$LN5@CheckUserI:
$LN9@CheckUserI:

; 2769 : }

  08428	5f		 pop	 edi
  08429	5e		 pop	 esi
  0842a	5b		 pop	 ebx
  0842b	8b e5		 mov	 esp, ebp
  0842d	5d		 pop	 ebp
  0842e	c2 04 00	 ret	 4
?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::CheckUserInDieTile
_TEXT	ENDS
PUBLIC	??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@
CONST	SEGMENT
??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Payback to User ChaosCastle Money'
	DB	' (FIRST:%d, PAYBACK:%d, FINAL:%d)', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -364						; size = 4
_Notice$238789 = -296					; size = 272
_iNOW_MONEY$238788 = -24				; size = 4
_iPAYBACK_MONEY$238787 = -20				; size = 4
_iFIRST_MONEY$238786 = -16				; size = 4
_i$238780 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?PlayFailedRollBack@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::PlayFailedRollBack
; _this$ = ecx

; 2772 : {

  08440	55		 push	 ebp
  08441	8b ec		 mov	 ebp, esp
  08443	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  08449	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0844e	33 c5		 xor	 eax, ebp
  08450	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08453	53		 push	 ebx
  08454	56		 push	 esi
  08455	57		 push	 edi
  08456	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2773 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  08459	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  0845d	7d 0c		 jge	 SHORT $LN9@PlayFailed
  0845f	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  08469	eb 0f		 jmp	 SHORT $LN10@PlayFailed
$LN9@PlayFailed:
  0846b	33 c0		 xor	 eax, eax
  0846d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  08471	0f 9e c0	 setle	 al
  08474	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@PlayFailed:
  0847a	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  08481	75 05		 jne	 SHORT $LN6@PlayFailed

; 2774 : 	{
; 2775 : 		return;

  08483	e9 d4 02 00 00	 jmp	 $LN7@PlayFailed
$LN6@PlayFailed:

; 2776 : 	}
; 2777 : 
; 2778 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  08488	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238780[ebp], 0
  0848f	eb 09		 jmp	 SHORT $LN5@PlayFailed
$LN4@PlayFailed:
  08491	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  08494	83 c0 01	 add	 eax, 1
  08497	89 45 f4	 mov	 DWORD PTR _i$238780[ebp], eax
$LN5@PlayFailed:
  0849a	83 7d f4 46	 cmp	 DWORD PTR _i$238780[ebp], 70 ; 00000046H
  0849e	0f 8d b8 02 00
	00		 jge	 $LN7@PlayFailed

; 2779 : 	{
; 2780 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  084a4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  084a7	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  084ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  084b0	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  084b4	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  084b7	6b c0 14	 imul	 eax, 20			; 00000014H
  084ba	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  084bf	0f 84 92 02 00
	00		 je	 $LN2@PlayFailed

; 2781 : 		{
; 2782 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2783 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  084c5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  084c8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  084ce	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  084d1	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  084d5	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  084d8	6b c0 14	 imul	 eax, 20			; 00000014H
  084db	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  084df	51		 push	 ecx
  084e0	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  084e5	83 c4 04	 add	 esp, 4
  084e8	83 f8 01	 cmp	 eax, 1
  084eb	0f 85 66 02 00
	00		 jne	 $LN2@PlayFailed
  084f1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  084f4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  084fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  084fd	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08501	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  08504	6b c0 14	 imul	 eax, 20			; 00000014H
  08507	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0850b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08511	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08517	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  0851f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08522	50		 push	 eax
  08523	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08526	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  0852b	3b f0		 cmp	 esi, eax
  0852d	0f 85 24 02 00
	00		 jne	 $LN2@PlayFailed

; 2784 : 			{
; 2785 : 				int iFIRST_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  08533	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08536	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0853c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0853f	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08543	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  08546	6b c0 14	 imul	 eax, 20			; 00000014H
  08549	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0854d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08553	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08559	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  08560	89 45 f0	 mov	 DWORD PTR _iFIRST_MONEY$238786[ebp], eax

; 2786 : 				int iPAYBACK_MONEY = g_iChaosCastle_EnterCost[iChaosCastleIndex] + g_iChaosCastle_GuardSetValue[iChaosCastleIndex];

  08563	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08566	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iChaosCastle_EnterCost[eax*4]
  0856d	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  08570	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _g_iChaosCastle_GuardSetValue[edx*4]
  08577	89 4d ec	 mov	 DWORD PTR _iPAYBACK_MONEY$238787[ebp], ecx

; 2787 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money += g_iChaosCastle_EnterCost[iChaosCastleIndex] + g_iChaosCastle_GuardSetValue[iChaosCastleIndex];

  0857a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0857d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08583	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08586	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0858a	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  0858d	6b c0 14	 imul	 eax, 20			; 00000014H
  08590	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08594	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0859a	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0859d	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_iChaosCastle_EnterCost[edx*4]
  085a4	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  085a7	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR _g_iChaosCastle_GuardSetValue[edx*4]
  085ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  085b4	03 84 0a f0 00
	00 00		 add	 eax, DWORD PTR [edx+ecx+240]
  085bb	8b 4d f4	 mov	 ecx, DWORD PTR _i$238780[ebp]
  085be	6b c9 14	 imul	 ecx, 20			; 00000014H
  085c1	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  085c4	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  085ca	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  085cd	8d 54 16 30	 lea	 edx, DWORD PTR [esi+edx+48]
  085d1	8b 4c 0a 3c	 mov	 ecx, DWORD PTR [edx+ecx+60]
  085d5	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  085db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  085e1	89 84 0a f0 00
	00 00		 mov	 DWORD PTR [edx+ecx+240], eax

; 2788 : 				int iNOW_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  085e8	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  085eb	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  085f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  085f4	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  085f8	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  085fb	6b c0 14	 imul	 eax, 20			; 00000014H
  085fe	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08602	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08608	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0860e	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  08615	89 45 e8	 mov	 DWORD PTR _iNOW_MONEY$238788[ebp], eax

; 2789 : 
; 2790 : 				GCMoneySend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money);

  08618	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0861b	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08621	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08624	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08628	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  0862b	6b c0 14	 imul	 eax, 20			; 00000014H
  0862e	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08632	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08638	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0863e	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  08645	50		 push	 eax
  08646	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  08649	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  0864f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08652	8d 44 0a 30	 lea	 eax, DWORD PTR [edx+ecx+48]
  08656	8b 4d f4	 mov	 ecx, DWORD PTR _i$238780[ebp]
  08659	6b c9 14	 imul	 ecx, 20			; 00000014H
  0865c	8b 54 08 3c	 mov	 edx, DWORD PTR [eax+ecx+60]
  08660	52		 push	 edx
  08661	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  08666	83 c4 08	 add	 esp, 8

; 2791 : 				gObjMoveGate(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 22);

  08669	6a 16		 push	 22			; 00000016H
  0866b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0866e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08674	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08677	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0867b	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  0867e	6b c0 14	 imul	 eax, 20			; 00000014H
  08681	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08685	51		 push	 ecx
  08686	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0868b	83 c4 08	 add	 esp, 8

; 2792 : 
; 2793 : 				PMSG_NOTICE Notice;
; 2794 : 
; 2795 : 				TNotice::MakeNoticeMsgEx(&Notice, 1, lMsg.Get(MSGGET(4,212)));

  0868e	68 d4 04 00 00	 push	 1236			; 000004d4H
  08693	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  08698	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0869d	50		 push	 eax
  0869e	6a 01		 push	 1
  086a0	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _Notice$238789[ebp]
  086a6	50		 push	 eax
  086a7	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  086ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2796 : 
; 2797 : 				DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&Notice, Notice.h.size);

  086af	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _Notice$238789[ebp+1]
  086b6	50		 push	 eax
  086b7	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _Notice$238789[ebp]
  086bd	51		 push	 ecx
  086be	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  086c1	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  086c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  086ca	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  086ce	8b 55 f4	 mov	 edx, DWORD PTR _i$238780[ebp]
  086d1	6b d2 14	 imul	 edx, 20			; 00000014H
  086d4	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  086d8	50		 push	 eax
  086d9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  086de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2798 : 
; 2799 : 				LogAddTD("[Chaos Castle] (%d) [%s][%s] Payback to User ChaosCastle Money (FIRST:%d, PAYBACK:%d, FINAL:%d)",
; 2800 : 					iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2801 : 					gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2802 : 					iFIRST_MONEY, iPAYBACK_MONEY, iNOW_MONEY);

  086e1	8b 45 e8	 mov	 eax, DWORD PTR _iNOW_MONEY$238788[ebp]
  086e4	50		 push	 eax
  086e5	8b 4d ec	 mov	 ecx, DWORD PTR _iPAYBACK_MONEY$238787[ebp]
  086e8	51		 push	 ecx
  086e9	8b 55 f0	 mov	 edx, DWORD PTR _iFIRST_MONEY$238786[ebp]
  086ec	52		 push	 edx
  086ed	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  086f0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  086f6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  086f9	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  086fd	8b 45 f4	 mov	 eax, DWORD PTR _i$238780[ebp]
  08700	6b c0 14	 imul	 eax, 20			; 00000014H
  08703	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08707	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0870d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08713	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  08717	50		 push	 eax
  08718	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0871b	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  08721	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08724	8d 44 0a 30	 lea	 eax, DWORD PTR [edx+ecx+48]
  08728	8b 4d f4	 mov	 ecx, DWORD PTR _i$238780[ebp]
  0872b	6b c9 14	 imul	 ecx, 20			; 00000014H
  0872e	8b 54 08 3c	 mov	 edx, DWORD PTR [eax+ecx+60]
  08732	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08738	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0873d	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  08741	51		 push	 ecx
  08742	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  08745	83 c2 01	 add	 edx, 1
  08748	52		 push	 edx
  08749	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@
  0874e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08754	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@PlayFailed:

; 2803 : 
; 2804 : 			}
; 2805 : 		}
; 2806 : 	}

  08757	e9 35 fd ff ff	 jmp	 $LN4@PlayFailed
$LN7@PlayFailed:

; 2807 : }

  0875c	5f		 pop	 edi
  0875d	5e		 pop	 esi
  0875e	5b		 pop	 ebx
  0875f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08762	33 cd		 xor	 ecx, ebp
  08764	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08769	8b e5		 mov	 esp, ebp
  0876b	5d		 pop	 ebp
  0876c	c2 04 00	 ret	 4
?PlayFailedRollBack@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::PlayFailedRollBack
_TEXT	ENDS
PUBLIC	??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@
CONST	SEGMENT
??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Reward User EXP (USER_KILL:%d, MO'
	DB	'N_KILL:%d, TOT_EXP:%d, TOT_REWARD_EXP:%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv72 = -364						; size = 4
tv67 = -364						; size = 4
_pMsg$238809 = -296					; size = 269
_iREWARD_EXP$238808 = -24				; size = 4
_iTOT_EXP$238807 = -20					; size = 4
_iKILLCOUNT_MONSTER$238806 = -16			; size = 4
_iKILLCOUNT_USER$238805 = -12				; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iChaosCastleSubIndex$ = 12				; size = 4
_bWinner$ = 16						; size = 4
?RewardUserEXP@CChaosCastle@@QAEXHHH@Z PROC		; CChaosCastle::RewardUserEXP
; _this$ = ecx

; 2821 : {

  08770	55		 push	 ebp
  08771	8b ec		 mov	 ebp, esp
  08773	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  08779	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0877e	33 c5		 xor	 eax, ebp
  08780	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08783	53		 push	 ebx
  08784	56		 push	 esi
  08785	57		 push	 edi
  08786	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2822 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  08789	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  0878d	7d 0c		 jge	 SHORT $LN9@RewardUser
  0878f	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  08799	eb 0f		 jmp	 SHORT $LN10@RewardUser
$LN9@RewardUser:
  0879b	33 c0		 xor	 eax, eax
  0879d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  087a1	0f 9e c0	 setle	 al
  087a4	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@RewardUser:
  087aa	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  087b1	75 05		 jne	 SHORT $LN6@RewardUser

; 2823 : 	{
; 2824 : 		return;

  087b3	e9 c5 02 00 00	 jmp	 $LN7@RewardUser
$LN6@RewardUser:

; 2825 : 	}
; 2826 : 
; 2827 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  087b8	83 7d 0c 00	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 0
  087bc	7d 0c		 jge	 SHORT $LN11@RewardUser
  087be	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
  087c8	eb 0f		 jmp	 SHORT $LN12@RewardUser
$LN11@RewardUser:
  087ca	33 c0		 xor	 eax, eax
  087cc	83 7d 0c 45	 cmp	 DWORD PTR _iChaosCastleSubIndex$[ebp], 69 ; 00000045H
  087d0	0f 9e c0	 setle	 al
  087d3	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN12@RewardUser:
  087d9	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv72[ebp], 0
  087e0	75 05		 jne	 SHORT $LN5@RewardUser

; 2828 : 	{
; 2829 : 		return;

  087e2	e9 96 02 00 00	 jmp	 $LN7@RewardUser
$LN5@RewardUser:

; 2830 : 	}
; 2831 : 
; 2832 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex != -1 )

  087e7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  087ea	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  087f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  087f3	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  087f7	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  087fa	6b c0 14	 imul	 eax, 20			; 00000014H
  087fd	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  08802	0f 84 75 02 00
	00		 je	 $LN7@RewardUser

; 2833 : 	{
; 2834 : 		if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex) ==TRUE )

  08808	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0880b	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08811	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08814	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08818	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  0881b	6b c0 14	 imul	 eax, 20			; 00000014H
  0881e	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08822	51		 push	 ecx
  08823	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  08828	83 c4 04	 add	 esp, 4
  0882b	83 f8 01	 cmp	 eax, 1
  0882e	0f 85 49 02 00
	00		 jne	 $LN7@RewardUser

; 2835 : 		{
; 2836 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleIndex == -1 ||
; 2837 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleSubIndex == -1 )

  08834	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08837	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0883d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08840	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08844	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  08847	6b c0 14	 imul	 eax, 20			; 00000014H
  0884a	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0884e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08854	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0885a	0f be 84 0a a5
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3749]
  08862	83 f8 ff	 cmp	 eax, -1
  08865	74 33		 je	 SHORT $LN1@RewardUser
  08867	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0886a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08870	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08873	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08877	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  0887a	6b c0 14	 imul	 eax, 20			; 00000014H
  0887d	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08881	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08887	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0888d	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  08895	83 f8 ff	 cmp	 eax, -1
  08898	75 05		 jne	 SHORT $LN2@RewardUser
$LN1@RewardUser:

; 2838 : 			{
; 2839 : 				return;

  0889a	e9 de 01 00 00	 jmp	 $LN7@RewardUser
$LN2@RewardUser:

; 2840 : 			}
; 2841 : 
; 2842 : 			int iKILLCOUNT_USER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillUserCount;

  0889f	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  088a2	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  088a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  088ab	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  088af	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  088b2	6b c0 14	 imul	 eax, 20			; 00000014H
  088b5	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  088b9	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  088bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  088c5	0f be 84 0a ac
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3756]
  088cd	89 45 f4	 mov	 DWORD PTR _iKILLCOUNT_USER$238805[ebp], eax

; 2843 : 			int iKILLCOUNT_MONSTER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillMonsterCount;

  088d0	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  088d3	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  088d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  088dc	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  088e0	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  088e3	6b c0 14	 imul	 eax, 20			; 00000014H
  088e6	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  088ea	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  088f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  088f6	0f be 84 0a ad
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3757]
  088fe	89 45 f0	 mov	 DWORD PTR _iKILLCOUNT_MONSTER$238806[ebp], eax

; 2844 : 			int iTOT_EXP = iKILLCOUNT_USER * g_iChaosCastle_ExpTable[iChaosCastleIndex][0] + iKILLCOUNT_MONSTER * g_iChaosCastle_ExpTable[iChaosCastleIndex][1];

  08901	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08904	8b 4d f4	 mov	 ecx, DWORD PTR _iKILLCOUNT_USER$238805[ebp]
  08907	0f af 0c c5 00
	00 00 00	 imul	 ecx, DWORD PTR _g_iChaosCastle_ExpTable[eax*8]
  0890f	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  08912	8b 45 f0	 mov	 eax, DWORD PTR _iKILLCOUNT_MONSTER$238806[ebp]
  08915	0f af 04 d5 04
	00 00 00	 imul	 eax, DWORD PTR _g_iChaosCastle_ExpTable[edx*8+4]
  0891d	03 c8		 add	 ecx, eax
  0891f	89 4d ec	 mov	 DWORD PTR _iTOT_EXP$238807[ebp], ecx

; 2845 : 
; 2846 : 			int iREWARD_EXP = this->CalcSendRewardEXP(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex, iTOT_EXP, iKILLCOUNT_USER, iKILLCOUNT_MONSTER);

  08922	8b 45 f0	 mov	 eax, DWORD PTR _iKILLCOUNT_MONSTER$238806[ebp]
  08925	50		 push	 eax
  08926	8b 4d f4	 mov	 ecx, DWORD PTR _iKILLCOUNT_USER$238805[ebp]
  08929	51		 push	 ecx
  0892a	8b 55 ec	 mov	 edx, DWORD PTR _iTOT_EXP$238807[ebp]
  0892d	52		 push	 edx
  0892e	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08931	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08937	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0893a	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0893e	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  08941	6b c0 14	 imul	 eax, 20			; 00000014H
  08944	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08948	51		 push	 ecx
  08949	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0894c	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z ; CChaosCastle::CalcSendRewardEXP
  08951	89 45 e8	 mov	 DWORD PTR _iREWARD_EXP$238808[ebp], eax

; 2847 : 
; 2848 : 			PMSG_DEVILSQUARERESULT pMsg;
; 2849 : 
; 2850 : 			pMsg.MyRank = bWinner;

  08954	8a 45 10	 mov	 al, BYTE PTR _bWinner$[ebp]
  08957	88 85 db fe ff
	ff		 mov	 BYTE PTR _pMsg$238809[ebp+3], al

; 2851 : 			pMsg.Count = 0xFE;

  0895d	c6 85 dc fe ff
	ff fe		 mov	 BYTE PTR _pMsg$238809[ebp+4], 254 ; 000000feH

; 2852 : 			memcpy(pMsg.Score[0].Name, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].Name, 10);

  08964	6a 0a		 push	 10			; 0000000aH
  08966	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08969	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0896f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08972	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08976	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  08979	6b c0 14	 imul	 eax, 20			; 00000014H
  0897c	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08980	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08986	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0898c	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  08990	50		 push	 eax
  08991	8d 8d dd fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$238809[ebp+5]
  08997	51		 push	 ecx
  08998	e8 00 00 00 00	 call	 _memcpy
  0899d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2853 : 			pMsg.Score[0].BonusExp = iTOT_EXP;

  089a0	8b 45 ec	 mov	 eax, DWORD PTR _iTOT_EXP$238807[ebp]
  089a3	89 85 ed fe ff
	ff		 mov	 DWORD PTR _pMsg$238809[ebp+21], eax

; 2854 : 			pMsg.Score[0].BonusZen = iKILLCOUNT_USER;

  089a9	8b 45 f4	 mov	 eax, DWORD PTR _iKILLCOUNT_USER$238805[ebp]
  089ac	89 85 f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$238809[ebp+25], eax

; 2855 : 			pMsg.Score[0].TotalScore = iKILLCOUNT_MONSTER;

  089b2	8b 45 f0	 mov	 eax, DWORD PTR _iKILLCOUNT_MONSTER$238806[ebp]
  089b5	89 85 e9 fe ff
	ff		 mov	 DWORD PTR _pMsg$238809[ebp+17], eax

; 2856 : 			PHeadSetB((LPBYTE)&pMsg, 0x93, 0x35);

  089bb	6a 35		 push	 53			; 00000035H
  089bd	68 93 00 00 00	 push	 147			; 00000093H
  089c2	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$238809[ebp]
  089c8	50		 push	 eax
  089c9	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  089ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2857 : 
; 2858 : 			DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  089d1	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$238809[ebp+1]
  089d8	50		 push	 eax
  089d9	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$238809[ebp]
  089df	51		 push	 ecx
  089e0	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  089e3	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  089e9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  089ec	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  089f0	8b 55 0c	 mov	 edx, DWORD PTR _iChaosCastleSubIndex$[ebp]
  089f3	6b d2 14	 imul	 edx, 20			; 00000014H
  089f6	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  089fa	50		 push	 eax
  089fb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  08a00	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2859 : 
; 2860 : 			LogAddTD("[Chaos Castle] (%d) [%s][%s] Reward User EXP (USER_KILL:%d, MON_KILL:%d, TOT_EXP:%d, TOT_REWARD_EXP:%d)",
; 2861 : 				iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].AccountID,
; 2862 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].Name,
; 2863 : 				iKILLCOUNT_USER, iKILLCOUNT_MONSTER, iTOT_EXP, iREWARD_EXP);

  08a03	8b 45 e8	 mov	 eax, DWORD PTR _iREWARD_EXP$238808[ebp]
  08a06	50		 push	 eax
  08a07	8b 4d ec	 mov	 ecx, DWORD PTR _iTOT_EXP$238807[ebp]
  08a0a	51		 push	 ecx
  08a0b	8b 55 f0	 mov	 edx, DWORD PTR _iKILLCOUNT_MONSTER$238806[ebp]
  08a0e	52		 push	 edx
  08a0f	8b 45 f4	 mov	 eax, DWORD PTR _iKILLCOUNT_USER$238805[ebp]
  08a12	50		 push	 eax
  08a13	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  08a16	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  08a1c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08a1f	8d 44 0a 30	 lea	 eax, DWORD PTR [edx+ecx+48]
  08a23	8b 4d 0c	 mov	 ecx, DWORD PTR _iChaosCastleSubIndex$[ebp]
  08a26	6b c9 14	 imul	 ecx, 20			; 00000014H
  08a29	8b 54 08 3c	 mov	 edx, DWORD PTR [eax+ecx+60]
  08a2d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08a33	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08a38	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  08a3c	51		 push	 ecx
  08a3d	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  08a40	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  08a46	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  08a49	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  08a4d	8b 55 0c	 mov	 edx, DWORD PTR _iChaosCastleSubIndex$[ebp]
  08a50	6b d2 14	 imul	 edx, 20			; 00000014H
  08a53	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  08a57	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08a5d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08a63	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  08a67	52		 push	 edx
  08a68	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08a6b	83 c0 01	 add	 eax, 1
  08a6e	50		 push	 eax
  08a6f	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@
  08a74	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08a7a	83 c4 20	 add	 esp, 32			; 00000020H
$LN7@RewardUser:

; 2864 : 		}
; 2865 : 	}
; 2866 : }

  08a7d	5f		 pop	 edi
  08a7e	5e		 pop	 esi
  08a7f	5b		 pop	 ebx
  08a80	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08a83	33 cd		 xor	 ecx, ebp
  08a85	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08a8a	8b e5		 mov	 esp, ebp
  08a8c	5d		 pop	 ebp
  08a8d	c2 0c 00	 ret	 12			; 0000000cH
?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ENDP		; CChaosCastle::RewardUserEXP
; Function compile flags: /Odtp /ZI
tv67 = -76						; size = 4
_iCUR_LIVES$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcessTrapStatus@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ProcessTrapStatus
; _this$ = ecx

; 2869 : {

  08a90	55		 push	 ebp
  08a91	8b ec		 mov	 ebp, esp
  08a93	83 ec 4c	 sub	 esp, 76			; 0000004cH
  08a96	53		 push	 ebx
  08a97	56		 push	 esi
  08a98	57		 push	 edi
  08a99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2870 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  08a9c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  08aa0	7d 09		 jge	 SHORT $LN10@ProcessTra
  08aa2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  08aa9	eb 0c		 jmp	 SHORT $LN11@ProcessTra
$LN10@ProcessTra:
  08aab	33 c0		 xor	 eax, eax
  08aad	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  08ab1	0f 9e c0	 setle	 al
  08ab4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@ProcessTra:
  08ab7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  08abb	75 05		 jne	 SHORT $LN7@ProcessTra

; 2871 : 		return;

  08abd	e9 b1 00 00 00	 jmp	 $LN8@ProcessTra
$LN7@ProcessTra:

; 2872 : 
; 2873 : 	int iCUR_LIVES = this->GetCurPlayUser(iChaosCastleIndex) + this->GetMonsterListCount(iChaosCastleIndex);

  08ac2	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08ac5	50		 push	 eax
  08ac6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08ac9	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  08ace	8b f0		 mov	 esi, eax
  08ad0	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  08ad3	51		 push	 ecx
  08ad4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08ad7	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  08adc	03 f0		 add	 esi, eax
  08ade	89 75 f8	 mov	 DWORD PTR _iCUR_LIVES$[ebp], esi

; 2874 : 
; 2875 : 	if ( iCUR_LIVES > 40 )

  08ae1	83 7d f8 28	 cmp	 DWORD PTR _iCUR_LIVES$[ebp], 40 ; 00000028H
  08ae5	7e 16		 jle	 SHORT $LN6@ProcessTra

; 2876 : 	{
; 2877 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 0;

  08ae7	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08aea	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08af0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08af3	c7 44 01 64 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+100], 0
  08afb	eb 76		 jmp	 SHORT $LN8@ProcessTra
$LN6@ProcessTra:

; 2878 : 	}
; 2879 : 	else if ( iCUR_LIVES > 30 )

  08afd	83 7d f8 1e	 cmp	 DWORD PTR _iCUR_LIVES$[ebp], 30 ; 0000001eH
  08b01	7e 24		 jle	 SHORT $LN4@ProcessTra

; 2880 : 	{
; 2881 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 1;

  08b03	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08b06	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08b0c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08b0f	c7 44 01 64 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+100], 1

; 2882 : 		this->SendNoticeState(iChaosCastleIndex, 8);

  08b17	6a 08		 push	 8
  08b19	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08b1c	50		 push	 eax
  08b1d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08b20	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  08b25	eb 4c		 jmp	 SHORT $LN8@ProcessTra
$LN4@ProcessTra:

; 2883 : 	}
; 2884 : 	else if ( iCUR_LIVES > 20 )

  08b27	83 7d f8 14	 cmp	 DWORD PTR _iCUR_LIVES$[ebp], 20 ; 00000014H
  08b2b	7e 24		 jle	 SHORT $LN2@ProcessTra

; 2885 : 	{
; 2886 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 2;

  08b2d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08b30	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08b36	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08b39	c7 44 01 64 02
	00 00 00	 mov	 DWORD PTR [ecx+eax+100], 2

; 2887 : 		this->SendNoticeState(iChaosCastleIndex, 9);

  08b41	6a 09		 push	 9
  08b43	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08b46	50		 push	 eax
  08b47	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08b4a	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 2888 : 	}
; 2889 : 	else

  08b4f	eb 22		 jmp	 SHORT $LN8@ProcessTra
$LN2@ProcessTra:

; 2890 : 	{
; 2891 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 3;

  08b51	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08b54	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08b5a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08b5d	c7 44 01 64 03
	00 00 00	 mov	 DWORD PTR [ecx+eax+100], 3

; 2892 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  08b65	6a 0a		 push	 10			; 0000000aH
  08b67	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08b6a	50		 push	 eax
  08b6b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08b6e	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
$LN8@ProcessTra:

; 2893 : 	}
; 2894 : }

  08b73	5f		 pop	 edi
  08b74	5e		 pop	 esi
  08b75	5b		 pop	 ebx
  08b76	8b e5		 mov	 esp, ebp
  08b78	5d		 pop	 ebp
  08b79	c2 04 00	 ret	 4
?ProcessTrapStatus@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ProcessTrapStatus
_TEXT	ENDS
PUBLIC	?CalUsersInTrap@CChaosCastle@@QAEXH@Z		; CChaosCastle::CalUsersInTrap
EXTRN	?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjApplyBuffEffectDuration
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv85 = -92						; size = 4
tv67 = -92						; size = 4
_lpObj$238843 = -24					; size = 4
_iSY$238840 = -20					; size = 4
_iSX$238839 = -16					; size = 4
_i$238833 = -12						; size = 4
_iTRAP_STEP$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CalUsersInTrap@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::CalUsersInTrap
; _this$ = ecx

; 2897 : {

  08b80	55		 push	 ebp
  08b81	8b ec		 mov	 ebp, esp
  08b83	83 ec 5c	 sub	 esp, 92			; 0000005cH
  08b86	53		 push	 ebx
  08b87	56		 push	 esi
  08b88	57		 push	 edi
  08b89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2898 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  08b8c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  08b90	7d 09		 jge	 SHORT $LN14@CalUsersIn
  08b92	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  08b99	eb 0c		 jmp	 SHORT $LN15@CalUsersIn
$LN14@CalUsersIn:
  08b9b	33 c0		 xor	 eax, eax
  08b9d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  08ba1	0f 9e c0	 setle	 al
  08ba4	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@CalUsersIn:
  08ba7	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  08bab	75 05		 jne	 SHORT $LN11@CalUsersIn

; 2899 : 		return;

  08bad	e9 a0 02 00 00	 jmp	 $LN12@CalUsersIn
$LN11@CalUsersIn:

; 2900 : 
; 2901 : 	if (this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS== 0 )

  08bb2	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08bb5	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08bbb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08bbe	83 7c 01 64 00	 cmp	 DWORD PTR [ecx+eax+100], 0
  08bc3	75 05		 jne	 SHORT $LN10@CalUsersIn

; 2902 : 		return;

  08bc5	e9 88 02 00 00	 jmp	 $LN12@CalUsersIn
$LN10@CalUsersIn:

; 2903 : 
; 2904 : 	if ( !CHECK_LIMIT(this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS, 4))

  08bca	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08bcd	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08bd3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08bd6	83 7c 01 64 00	 cmp	 DWORD PTR [ecx+eax+100], 0
  08bdb	7d 09		 jge	 SHORT $LN16@CalUsersIn
  08bdd	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  08be4	eb 19		 jmp	 SHORT $LN17@CalUsersIn
$LN16@CalUsersIn:
  08be6	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  08be9	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  08bef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  08bf2	33 c9		 xor	 ecx, ecx
  08bf4	83 7c 10 64 03	 cmp	 DWORD PTR [eax+edx+100], 3
  08bf9	0f 9e c1	 setle	 cl
  08bfc	89 4d a4	 mov	 DWORD PTR tv85[ebp], ecx
$LN17@CalUsersIn:
  08bff	83 7d a4 00	 cmp	 DWORD PTR tv85[ebp], 0
  08c03	75 05		 jne	 SHORT $LN9@CalUsersIn

; 2905 : 		return;

  08c05	e9 48 02 00 00	 jmp	 $LN12@CalUsersIn
$LN9@CalUsersIn:

; 2906 : 
; 2907 : 	int iTRAP_STEP = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS;

  08c0a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08c0d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08c13	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08c16	8b 54 01 64	 mov	 edx, DWORD PTR [ecx+eax+100]
  08c1a	89 55 f8	 mov	 DWORD PTR _iTRAP_STEP$[ebp], edx

; 2908 : 
; 2909 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  08c1d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238833[ebp], 0
  08c24	eb 09		 jmp	 SHORT $LN8@CalUsersIn
$LN7@CalUsersIn:
  08c26	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08c29	83 c0 01	 add	 eax, 1
  08c2c	89 45 f4	 mov	 DWORD PTR _i$238833[ebp], eax
$LN8@CalUsersIn:
  08c2f	83 7d f4 46	 cmp	 DWORD PTR _i$238833[ebp], 70 ; 00000046H
  08c33	0f 8d 19 02 00
	00		 jge	 $LN12@CalUsersIn

; 2910 : 	{
; 2911 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  08c39	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08c3c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08c42	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08c45	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08c49	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08c4c	6b c0 14	 imul	 eax, 20			; 00000014H
  08c4f	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  08c54	0f 84 f3 01 00
	00		 je	 $LN5@CalUsersIn

; 2912 : 		{
; 2913 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 2914 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  08c5a	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08c5d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08c63	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08c66	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08c6a	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08c6d	6b c0 14	 imul	 eax, 20			; 00000014H
  08c70	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08c74	51		 push	 ecx
  08c75	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  08c7a	83 c4 04	 add	 esp, 4
  08c7d	83 f8 01	 cmp	 eax, 1
  08c80	0f 85 c7 01 00
	00		 jne	 $LN5@CalUsersIn
  08c86	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08c89	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08c8f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08c92	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08c96	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08c99	6b c0 14	 imul	 eax, 20			; 00000014H
  08c9c	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08ca0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08ca6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08cac	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  08cb4	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08cb7	50		 push	 eax
  08cb8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08cbb	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  08cc0	3b f0		 cmp	 esi, eax
  08cc2	0f 85 85 01 00
	00		 jne	 $LN5@CalUsersIn

; 2915 : 			{
; 2916 : 				int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  08cc8	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08ccb	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08cd1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08cd4	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08cd8	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08cdb	6b c0 14	 imul	 eax, 20			; 00000014H
  08cde	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08ce2	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08ce8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08cee	0f bf 84 0a 44
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+324]
  08cf6	89 45 f0	 mov	 DWORD PTR _iSX$238839[ebp], eax

; 2917 : 				int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;

  08cf9	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08cfc	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08d02	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08d05	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08d09	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08d0c	6b c0 14	 imul	 eax, 20			; 00000014H
  08d0f	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08d13	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08d19	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d1f	0f bf 84 0a 46
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+326]
  08d27	89 45 ec	 mov	 DWORD PTR _iSY$238840[ebp], eax

; 2918 : 				
; 2919 : 				if ( iSX >= g_iChaosCastle_GroundAxis[0] &&
; 2920 : 					 iSX <= g_iChaosCastle_GroundAxis[2] &&
; 2921 : 					 iSY >= g_iChaosCastle_GroundAxis[1] &&
; 2922 : 					 iSY <= g_iChaosCastle_GroundAxis[3] &&
; 2923 : 					 ( iSX < g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ||
; 2924 : 					   iSX > g_iChaosCastle_DamageAxis[iTRAP_STEP][2] ||
; 2925 : 					   iSY < g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ||
; 2926 : 					   iSY > g_iChaosCastle_DamageAxis[iTRAP_STEP][3] ) )

  08d2a	8b 45 f0	 mov	 eax, DWORD PTR _iSX$238839[ebp]
  08d2d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_GroundAxis
  08d33	0f 8c 14 01 00
	00		 jl	 $LN5@CalUsersIn
  08d39	8b 45 f0	 mov	 eax, DWORD PTR _iSX$238839[ebp]
  08d3c	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+8
  08d42	0f 8f 05 01 00
	00		 jg	 $LN5@CalUsersIn
  08d48	8b 45 ec	 mov	 eax, DWORD PTR _iSY$238840[ebp]
  08d4b	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  08d51	0f 8c f6 00 00
	00		 jl	 $LN5@CalUsersIn
  08d57	8b 45 ec	 mov	 eax, DWORD PTR _iSY$238840[ebp]
  08d5a	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  08d60	0f 8f e7 00 00
	00		 jg	 $LN5@CalUsersIn
  08d66	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  08d69	c1 e0 04	 shl	 eax, 4
  08d6c	8b 4d f0	 mov	 ecx, DWORD PTR _iSX$238839[ebp]
  08d6f	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  08d75	7c 37		 jl	 SHORT $LN2@CalUsersIn
  08d77	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  08d7a	c1 e0 04	 shl	 eax, 4
  08d7d	8b 4d f0	 mov	 ecx, DWORD PTR _iSX$238839[ebp]
  08d80	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  08d86	7f 26		 jg	 SHORT $LN2@CalUsersIn
  08d88	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  08d8b	c1 e0 04	 shl	 eax, 4
  08d8e	8b 4d ec	 mov	 ecx, DWORD PTR _iSY$238840[ebp]
  08d91	3b 88 04 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  08d97	7c 15		 jl	 SHORT $LN2@CalUsersIn
  08d99	8b 45 f8	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  08d9c	c1 e0 04	 shl	 eax, 4
  08d9f	8b 4d ec	 mov	 ecx, DWORD PTR _iSY$238840[ebp]
  08da2	3b 88 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  08da8	0f 8e 9f 00 00
	00		 jle	 $LN5@CalUsersIn
$LN2@CalUsersIn:

; 2927 : 				{
; 2928 : 					this->GiveUserDamage(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 10);

  08dae	6a 0a		 push	 10			; 0000000aH
  08db0	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08db3	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08db9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08dbc	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08dc0	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08dc3	6b c0 14	 imul	 eax, 20			; 00000014H
  08dc6	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08dca	51		 push	 ecx
  08dcb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08dce	e8 00 00 00 00	 call	 ?GiveUserDamage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveUserDamage

; 2929 : 
; 2930 : 					LPOBJ lpObj = &gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex];

  08dd3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  08dd6	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  08ddc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  08ddf	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  08de3	8b 45 f4	 mov	 eax, DWORD PTR _i$238833[ebp]
  08de6	6b c0 14	 imul	 eax, 20			; 00000014H
  08de9	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  08ded	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08df3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08df9	89 4d e8	 mov	 DWORD PTR _lpObj$238843[ebp], ecx

; 2931 : 
; 2932 : 					if(gObjSearchActiveEffect(lpObj, AT_ICE) == FALSE)

  08dfc	6a 38		 push	 56			; 00000038H
  08dfe	8b 45 e8	 mov	 eax, DWORD PTR _lpObj$238843[ebp]
  08e01	50		 push	 eax
  08e02	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  08e07	83 c4 08	 add	 esp, 8
  08e0a	0f b6 c8	 movzx	 ecx, al
  08e0d	85 c9		 test	 ecx, ecx
  08e0f	75 3c		 jne	 SHORT $LN5@CalUsersIn

; 2933 : 					{
; 2934 : 						lpObj->DelayActionTime = 800;

  08e11	8b 45 e8	 mov	 eax, DWORD PTR _lpObj$238843[ebp]
  08e14	c7 80 c0 03 00
	00 20 03 00 00	 mov	 DWORD PTR [eax+960], 800 ; 00000320H

; 2935 : 						lpObj->DelayLevel = 1;

  08e1e	8b 45 e8	 mov	 eax, DWORD PTR _lpObj$238843[ebp]
  08e21	c6 80 c4 03 00
	00 01		 mov	 BYTE PTR [eax+964], 1

; 2936 : 						lpObj->lpAttackObj = NULL;

  08e28	8b 45 e8	 mov	 eax, DWORD PTR _lpObj$238843[ebp]
  08e2b	c7 80 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+980], 0

; 2937 : 						gObjApplyBuffEffectDuration(lpObj, AT_ICE, 0, 0, 0, 0, 3);

  08e35	6a 03		 push	 3
  08e37	6a 00		 push	 0
  08e39	6a 00		 push	 0
  08e3b	6a 00		 push	 0
  08e3d	6a 00		 push	 0
  08e3f	6a 38		 push	 56			; 00000038H
  08e41	8b 45 e8	 mov	 eax, DWORD PTR _lpObj$238843[ebp]
  08e44	50		 push	 eax
  08e45	e8 00 00 00 00	 call	 ?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjApplyBuffEffectDuration
  08e4a	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@CalUsersIn:

; 2938 : 					}
; 2939 : 				}
; 2940 : 			}
; 2941 : 		}
; 2942 : 	}

  08e4d	e9 d4 fd ff ff	 jmp	 $LN7@CalUsersIn
$LN12@CalUsersIn:

; 2943 : }

  08e52	5f		 pop	 edi
  08e53	5e		 pop	 esi
  08e54	5b		 pop	 ebx
  08e55	8b e5		 mov	 esp, ebp
  08e57	5d		 pop	 ebp
  08e58	c2 04 00	 ret	 4
?CalUsersInTrap@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::CalUsersInTrap
_TEXT	ENDS
PUBLIC	?CheckWearingMOPH@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckWearingMOPH
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
?CheckWearingMOPH@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckWearingMOPH
; _this$ = ecx

; 2946 : {

  08e60	55		 push	 ebp
  08e61	8b ec		 mov	 ebp, esp
  08e63	83 ec 44	 sub	 esp, 68			; 00000044H
  08e66	53		 push	 ebx
  08e67	56		 push	 esi
  08e68	57		 push	 edi
  08e69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2947 : 	if (  gObjIsConnected(iUserIndex) == FALSE )

  08e6c	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08e6f	50		 push	 eax
  08e70	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  08e75	83 c4 04	 add	 esp, 4
  08e78	85 c0		 test	 eax, eax
  08e7a	75 07		 jne	 SHORT $LN13@CheckWeari

; 2948 : 	{
; 2949 : 		return FALSE;

  08e7c	33 c0		 xor	 eax, eax
  08e7e	e9 17 02 00 00	 jmp	 $LN14@CheckWeari
$LN13@CheckWeari:

; 2950 : 	}
; 2951 : 
; 2952 : 	if ( gObj[iUserIndex].pInventory[10].IsItem()  )

  08e83	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08e86	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08e8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08e92	8b 8c 01 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+3620]
  08e99	81 c1 48 08 00
	00		 add	 ecx, 2120		; 00000848H
  08e9f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  08ea4	85 c0		 test	 eax, eax
  08ea6	0f 84 e6 00 00
	00		 je	 $LN12@CheckWeari

; 2953 : 	{
; 2954 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,10) ) // Tranformation Ring

  08eac	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08eaf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08eb5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08ebb	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08ec2	0f bf 82 4e 08
	00 00		 movsx	 eax, WORD PTR [edx+2126]
  08ec9	3d 0a 1a 00 00	 cmp	 eax, 6666		; 00001a0aH
  08ece	75 0a		 jne	 SHORT $LN11@CheckWeari

; 2955 : 		{
; 2956 : 			return TRUE;

  08ed0	b8 01 00 00 00	 mov	 eax, 1
  08ed5	e9 c0 01 00 00	 jmp	 $LN14@CheckWeari
$LN11@CheckWeari:

; 2957 : 		}
; 2958 : 
; 2959 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,39) ) 

  08eda	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08edd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08ee3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08ee9	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08ef0	0f bf 82 4e 08
	00 00		 movsx	 eax, WORD PTR [edx+2126]
  08ef7	3d 27 1a 00 00	 cmp	 eax, 6695		; 00001a27H
  08efc	75 0a		 jne	 SHORT $LN10@CheckWeari

; 2960 : 		{
; 2961 : 			return TRUE;

  08efe	b8 01 00 00 00	 mov	 eax, 1
  08f03	e9 92 01 00 00	 jmp	 $LN14@CheckWeari
$LN10@CheckWeari:

; 2962 : 		}
; 2963 : 
; 2964 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,40) ) //Second Edition

  08f08	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08f0b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08f11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08f17	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08f1e	0f bf 82 4e 08
	00 00		 movsx	 eax, WORD PTR [edx+2126]
  08f25	3d 28 1a 00 00	 cmp	 eax, 6696		; 00001a28H
  08f2a	75 0a		 jne	 SHORT $LN9@CheckWeari

; 2965 : 		{
; 2966 : 			return TRUE;

  08f2c	b8 01 00 00 00	 mov	 eax, 1
  08f31	e9 64 01 00 00	 jmp	 $LN14@CheckWeari
$LN9@CheckWeari:

; 2967 : 		}
; 2968 : 
; 2969 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,41) ) //season 2.5 add-on

  08f36	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08f39	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08f3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08f45	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08f4c	0f bf 82 4e 08
	00 00		 movsx	 eax, WORD PTR [edx+2126]
  08f53	3d 29 1a 00 00	 cmp	 eax, 6697		; 00001a29H
  08f58	75 0a		 jne	 SHORT $LN8@CheckWeari

; 2970 : 		{
; 2971 : 			return TRUE;

  08f5a	b8 01 00 00 00	 mov	 eax, 1
  08f5f	e9 36 01 00 00	 jmp	 $LN14@CheckWeari
$LN8@CheckWeari:

; 2972 : 		}
; 2973 : 
; 2974 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,68) ) //season 4.0 add-on

  08f64	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08f67	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08f6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08f73	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08f7a	0f bf 82 4e 08
	00 00		 movsx	 eax, WORD PTR [edx+2126]
  08f81	3d 44 1a 00 00	 cmp	 eax, 6724		; 00001a44H
  08f86	75 0a		 jne	 SHORT $LN12@CheckWeari

; 2975 : 		{
; 2976 : 			return TRUE;

  08f88	b8 01 00 00 00	 mov	 eax, 1
  08f8d	e9 08 01 00 00	 jmp	 $LN14@CheckWeari
$LN12@CheckWeari:

; 2977 : 		}
; 2978 : 	}
; 2979 : 
; 2980 : 	if ( gObj[iUserIndex].pInventory[11].IsItem() )

  08f92	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08f95	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08f9b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08fa1	8b 8c 01 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+3620]
  08fa8	81 c1 1c 09 00
	00		 add	 ecx, 2332		; 0000091cH
  08fae	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  08fb3	85 c0		 test	 eax, eax
  08fb5	0f 84 dd 00 00
	00		 je	 $LN6@CheckWeari

; 2981 : 	{
; 2982 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,10) ) // Tranformation Ring

  08fbb	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08fbe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08fc4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08fca	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08fd1	0f bf 82 22 09
	00 00		 movsx	 eax, WORD PTR [edx+2338]
  08fd8	3d 0a 1a 00 00	 cmp	 eax, 6666		; 00001a0aH
  08fdd	75 0a		 jne	 SHORT $LN5@CheckWeari

; 2983 : 		{
; 2984 : 			return TRUE;

  08fdf	b8 01 00 00 00	 mov	 eax, 1
  08fe4	e9 b1 00 00 00	 jmp	 $LN14@CheckWeari
$LN5@CheckWeari:

; 2985 : 		}
; 2986 : 
; 2987 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,39) ) 

  08fe9	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  08fec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08ff2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08ff8	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  08fff	0f bf 82 22 09
	00 00		 movsx	 eax, WORD PTR [edx+2338]
  09006	3d 27 1a 00 00	 cmp	 eax, 6695		; 00001a27H
  0900b	75 0a		 jne	 SHORT $LN4@CheckWeari

; 2988 : 		{
; 2989 : 			return TRUE;

  0900d	b8 01 00 00 00	 mov	 eax, 1
  09012	e9 83 00 00 00	 jmp	 $LN14@CheckWeari
$LN4@CheckWeari:

; 2990 : 		}
; 2991 : 
; 2992 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,40) ) //Second Edition

  09017	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0901a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09026	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  0902d	0f bf 82 22 09
	00 00		 movsx	 eax, WORD PTR [edx+2338]
  09034	3d 28 1a 00 00	 cmp	 eax, 6696		; 00001a28H
  09039	75 07		 jne	 SHORT $LN3@CheckWeari

; 2993 : 		{
; 2994 : 			return TRUE;

  0903b	b8 01 00 00 00	 mov	 eax, 1
  09040	eb 58		 jmp	 SHORT $LN14@CheckWeari
$LN3@CheckWeari:

; 2995 : 		}
; 2996 : 
; 2997 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,41) ) //season 2.5 add-on

  09042	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  09045	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0904b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09051	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  09058	0f bf 82 22 09
	00 00		 movsx	 eax, WORD PTR [edx+2338]
  0905f	3d 29 1a 00 00	 cmp	 eax, 6697		; 00001a29H
  09064	75 07		 jne	 SHORT $LN2@CheckWeari

; 2998 : 		{
; 2999 : 			return TRUE;

  09066	b8 01 00 00 00	 mov	 eax, 1
  0906b	eb 2d		 jmp	 SHORT $LN14@CheckWeari
$LN2@CheckWeari:

; 3000 : 		}
; 3001 : 
; 3002 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,68) ) //season 4.0 add-on

  0906d	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  09070	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0907c	8b 94 01 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3620]
  09083	0f bf 82 22 09
	00 00		 movsx	 eax, WORD PTR [edx+2338]
  0908a	3d 44 1a 00 00	 cmp	 eax, 6724		; 00001a44H
  0908f	75 07		 jne	 SHORT $LN6@CheckWeari

; 3003 : 		{
; 3004 : 			return TRUE;

  09091	b8 01 00 00 00	 mov	 eax, 1
  09096	eb 02		 jmp	 SHORT $LN14@CheckWeari
$LN6@CheckWeari:

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return FALSE;

  09098	33 c0		 xor	 eax, eax
$LN14@CheckWeari:

; 3009 : }

  0909a	5f		 pop	 edi
  0909b	5e		 pop	 esi
  0909c	5b		 pop	 ebx
  0909d	8b e5		 mov	 esp, ebp
  0909f	5d		 pop	 ebp
  090a0	c2 04 00	 ret	 4
?CheckWearingMOPH@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckWearingMOPH
_TEXT	ENDS
PUBLIC	??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
EXTRN	?Main@CChaosCastleRewardItem@@QAE_NHH@Z:PROC	; CChaosCastleRewardItem::Main
EXTRN	?gChaosCastleRewardItem@@3VCChaosCastleRewardItem@@A:BYTE ; gChaosCastleRewardItem
EXTRN	?MakeRandomSetItem@@YAXH@Z:PROC			; MakeRandomSetItem
EXTRN	?WinCC@CAchievements@@QAEXH@Z:PROC		; CAchievements::WinCC
;	COMDAT ??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Set Item', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -80						; size = 4
_i$238877 = -12						; size = 4
_i$238870 = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?GiveWinnerItem@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::GiveWinnerItem
; _this$ = ecx

; 3014 : {

  090b0	55		 push	 ebp
  090b1	8b ec		 mov	 ebp, esp
  090b3	83 ec 50	 sub	 esp, 80			; 00000050H
  090b6	53		 push	 ebx
  090b7	56		 push	 esi
  090b8	57		 push	 edi
  090b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3015 : 	if( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  090bc	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  090c0	7d 09		 jge	 SHORT $LN14@GiveWinner
  090c2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  090c9	eb 0c		 jmp	 SHORT $LN15@GiveWinner
$LN14@GiveWinner:
  090cb	33 c0		 xor	 eax, eax
  090cd	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  090d1	0f 9e c0	 setle	 al
  090d4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN15@GiveWinner:
  090d7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  090db	75 05		 jne	 SHORT $LN11@GiveWinner

; 3016 : 	{
; 3017 : 		return;

  090dd	e9 3b 02 00 00	 jmp	 $LN12@GiveWinner
$LN11@GiveWinner:

; 3018 : 	}
; 3019 : 	// ----
; 3020 : 	if( !gObjIsConnected(iWinnerIndex) )

  090e2	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  090e5	50		 push	 eax
  090e6	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  090eb	83 c4 04	 add	 esp, 4
  090ee	85 c0		 test	 eax, eax
  090f0	75 05		 jne	 SHORT $LN10@GiveWinner

; 3021 : 	{
; 3022 : 		return;

  090f2	e9 26 02 00 00	 jmp	 $LN12@GiveWinner
$LN10@GiveWinner:

; 3023 : 	}
; 3024 : 
; 3025 : #if(SYSTEM_ACHIEVEMENTS)
; 3026 : 	g_Achievements.WinCC(iWinnerIndex);

  090f7	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  090fa	50		 push	 eax
  090fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  09100	e8 00 00 00 00	 call	 ?WinCC@CAchievements@@QAEXH@Z ; CAchievements::WinCC

; 3027 : #endif
; 3028 : 
; 3029 : 	if( this->m_RewardData[iChaosCastleIndex].AncientCount > 0 )

  09105	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09108	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0910b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0910e	0f b6 94 01 44
	3b 00 00	 movzx	 edx, BYTE PTR [ecx+eax+15172]
  09116	85 d2		 test	 edx, edx
  09118	0f 8e 95 00 00
	00		 jle	 $LN9@GiveWinner

; 3030 : 	{
; 3031 : 		for( int i = 0; i < this->m_RewardData[iChaosCastleIndex].AncientCount; i++ )

  0911e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$238870[ebp], 0
  09125	eb 09		 jmp	 SHORT $LN8@GiveWinner
$LN7@GiveWinner:
  09127	8b 45 f8	 mov	 eax, DWORD PTR _i$238870[ebp]
  0912a	83 c0 01	 add	 eax, 1
  0912d	89 45 f8	 mov	 DWORD PTR _i$238870[ebp], eax
$LN8@GiveWinner:
  09130	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09133	6b c0 0c	 imul	 eax, 12			; 0000000cH
  09136	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09139	0f b6 94 01 44
	3b 00 00	 movzx	 edx, BYTE PTR [ecx+eax+15172]
  09141	39 55 f8	 cmp	 DWORD PTR _i$238870[ebp], edx
  09144	7d 6d		 jge	 SHORT $LN9@GiveWinner

; 3032 : 		{
; 3033 : 			if( rand()%100 < this->m_RewardData[iChaosCastleIndex].AncientRate )

  09146	e8 00 00 00 00	 call	 _rand
  0914b	99		 cdq
  0914c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  09151	f7 f9		 idiv	 ecx
  09153	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09156	6b c0 0c	 imul	 eax, 12			; 0000000cH
  09159	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0915c	3b 94 01 40 3b
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+15168]
  09163	7d 49		 jge	 SHORT $LN5@GiveWinner

; 3034 : 			{
; 3035 : 				MakeRandomSetItem(iWinnerIndex);

  09165	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  09168	50		 push	 eax
  09169	e8 00 00 00 00	 call	 ?MakeRandomSetItem@@YAXH@Z ; MakeRandomSetItem
  0916e	83 c4 04	 add	 esp, 4

; 3036 : 				LogAddTD("[Chaos Castle] (%d) [%s][%s] Winner Item - Set Item", 
; 3037 : 					iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  09171	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  09174	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0917a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09180	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  09184	52		 push	 edx
  09185	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  09188	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0918e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09194	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  09198	52		 push	 edx
  09199	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0919c	83 c0 01	 add	 eax, 1
  0919f	50		 push	 eax
  091a0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  091a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  091ab	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@GiveWinner:

; 3038 : 			}
; 3039 : 		}

  091ae	e9 74 ff ff ff	 jmp	 $LN7@GiveWinner
$LN9@GiveWinner:

; 3040 : 	}
; 3041 : 	// ----
; 3042 : 	if( this->m_RewardData[iChaosCastleIndex].ItemCount > 0 )

  091b3	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  091b6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  091b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  091bc	0f b6 94 01 45
	3b 00 00	 movzx	 edx, BYTE PTR [ecx+eax+15173]
  091c4	85 d2		 test	 edx, edx
  091c6	0f 8e 3f 01 00
	00		 jle	 $LN4@GiveWinner

; 3043 : 	{
; 3044 : 		for( int i = 0; i < this->m_RewardData[iChaosCastleIndex].ItemCount; i++ )

  091cc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238877[ebp], 0
  091d3	eb 09		 jmp	 SHORT $LN3@GiveWinner
$LN2@GiveWinner:
  091d5	8b 45 f4	 mov	 eax, DWORD PTR _i$238877[ebp]
  091d8	83 c0 01	 add	 eax, 1
  091db	89 45 f4	 mov	 DWORD PTR _i$238877[ebp], eax
$LN3@GiveWinner:
  091de	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  091e1	6b c0 0c	 imul	 eax, 12			; 0000000cH
  091e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  091e7	0f b6 94 01 45
	3b 00 00	 movzx	 edx, BYTE PTR [ecx+eax+15173]
  091ef	39 55 f4	 cmp	 DWORD PTR _i$238877[ebp], edx
  091f2	0f 8d 13 01 00
	00		 jge	 $LN4@GiveWinner

; 3045 : 		{
; 3046 : 			ItemSerialCreateSend(gObj[iWinnerIndex].m_Index, gObj[iWinnerIndex].MapNumber, 
; 3047 : 				gObj[iWinnerIndex].X, gObj[iWinnerIndex].Y, 
; 3048 : 				ITEMGET(this->m_RewardData[iChaosCastleIndex].ItemID, this->m_RewardData[iChaosCastleIndex].ItemIndex), 
; 3049 : 				this->m_RewardData[iChaosCastleIndex].ItemLevel, 0, 0, 0, 0, iWinnerIndex, 0, 0);

  091f8	6a 00		 push	 0
  091fa	6a 00		 push	 0
  091fc	8b 45 0c	 mov	 eax, DWORD PTR _iWinnerIndex$[ebp]
  091ff	50		 push	 eax
  09200	6a 00		 push	 0
  09202	6a 00		 push	 0
  09204	6a 00		 push	 0
  09206	6a 00		 push	 0
  09208	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0920b	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0920e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09211	0f b6 84 0a 4a
	3b 00 00	 movzx	 eax, BYTE PTR [edx+ecx+15178]
  09219	50		 push	 eax
  0921a	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0921d	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  09220	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09223	0f b7 84 0a 46
	3b 00 00	 movzx	 eax, WORD PTR [edx+ecx+15174]
  0922b	c1 e0 09	 shl	 eax, 9
  0922e	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  09231	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  09234	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09237	0f b7 8c 0a 48
	3b 00 00	 movzx	 ecx, WORD PTR [edx+ecx+15176]
  0923f	03 c1		 add	 eax, ecx
  09241	50		 push	 eax
  09242	8b 55 0c	 mov	 edx, DWORD PTR _iWinnerIndex$[ebp]
  09245	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0924b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09250	0f b6 8c 10 46
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+326]
  09258	51		 push	 ecx
  09259	8b 55 0c	 mov	 edx, DWORD PTR _iWinnerIndex$[ebp]
  0925c	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  09262	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09267	0f b6 8c 10 44
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+324]
  0926f	51		 push	 ecx
  09270	8b 55 0c	 mov	 edx, DWORD PTR _iWinnerIndex$[ebp]
  09273	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  09279	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0927e	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  09286	51		 push	 ecx
  09287	8b 55 0c	 mov	 edx, DWORD PTR _iWinnerIndex$[ebp]
  0928a	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  09290	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09295	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  09298	51		 push	 ecx
  09299	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0929e	83 c4 34	 add	 esp, 52			; 00000034H

; 3050 : 			LogAddTD("[Chaos Castle] (%d) [%s][%s] Winner Item - %d", 
; 3051 : 				iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name, 
; 3052 : 				ITEMGET(this->m_RewardData[iChaosCastleIndex].ItemID, this->m_RewardData[iChaosCastleIndex].ItemIndex));

  092a1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  092a4	6b c0 0c	 imul	 eax, 12			; 0000000cH
  092a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  092aa	0f b7 94 01 46
	3b 00 00	 movzx	 edx, WORD PTR [ecx+eax+15174]
  092b2	c1 e2 09	 shl	 edx, 9
  092b5	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  092b8	6b c0 0c	 imul	 eax, 12			; 0000000cH
  092bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  092be	0f b7 84 01 48
	3b 00 00	 movzx	 eax, WORD PTR [ecx+eax+15176]
  092c6	03 d0		 add	 edx, eax
  092c8	52		 push	 edx
  092c9	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  092cc	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  092d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  092d8	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  092dc	50		 push	 eax
  092dd	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  092e0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  092e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  092ec	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  092f0	50		 push	 eax
  092f1	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  092f4	83 c1 01	 add	 ecx, 1
  092f7	51		 push	 ecx
  092f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  092fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09303	83 c4 14	 add	 esp, 20			; 00000014H

; 3053 : 		}

  09306	e9 ca fe ff ff	 jmp	 $LN2@GiveWinner
$LN4@GiveWinner:

; 3054 : 	}
; 3055 : 
; 3056 : 	// -> Chaos castle win
; 3057 : 	gChaosCastleRewardItem.Main(iWinnerIndex, iChaosCastleIndex);

  0930b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0930e	50		 push	 eax
  0930f	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  09312	51		 push	 ecx
  09313	b9 00 00 00 00	 mov	 ecx, OFFSET ?gChaosCastleRewardItem@@3VCChaosCastleRewardItem@@A ; gChaosCastleRewardItem
  09318	e8 00 00 00 00	 call	 ?Main@CChaosCastleRewardItem@@QAE_NHH@Z ; CChaosCastleRewardItem::Main
$LN12@GiveWinner:

; 3058 : 
; 3059 : }

  0931d	5f		 pop	 edi
  0931e	5e		 pop	 esi
  0931f	5b		 pop	 ebx
  09320	8b e5		 mov	 esp, ebp
  09322	5d		 pop	 ebp
  09323	c2 08 00	 ret	 8
?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::GiveWinnerItem
; Function compile flags: /Odtp /ZI
tv67 = -80						; size = 4
_iPlayUser$ = -12					; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ReCalcUserCount@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::ReCalcUserCount
; _this$ = ecx

; 3170 : {

  09330	55		 push	 ebp
  09331	8b ec		 mov	 ebp, esp
  09333	83 ec 50	 sub	 esp, 80			; 00000050H
  09336	53		 push	 ebx
  09337	56		 push	 esi
  09338	57		 push	 edi
  09339	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3171 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0933c	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  09340	7d 09		 jge	 SHORT $LN6@ReCalcUser
  09342	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09349	eb 0c		 jmp	 SHORT $LN7@ReCalcUser
$LN6@ReCalcUser:
  0934b	33 c0		 xor	 eax, eax
  0934d	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  09351	0f 9e c0	 setle	 al
  09354	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN7@ReCalcUser:
  09357	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0935b	75 07		 jne	 SHORT $LN3@ReCalcUser

; 3172 : 		return -1;

  0935d	b8 ff ff ff ff	 mov	 eax, -1
  09362	eb 55		 jmp	 SHORT $LN4@ReCalcUser
$LN3@ReCalcUser:

; 3173 : 
; 3174 : 	int iRET_VAL = 0;

  09364	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_VAL$[ebp], 0

; 3175 : 	int iPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  0936b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0936e	50		 push	 eax
  0936f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09372	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  09377	89 45 f4	 mov	 DWORD PTR _iPlayUser$[ebp], eax

; 3176 : 
; 3177 : 	if ( iPlayUser > 0 )

  0937a	83 7d f4 00	 cmp	 DWORD PTR _iPlayUser$[ebp], 0
  0937e	7e 1b		 jle	 SHORT $LN2@ReCalcUser

; 3178 : 	{
; 3179 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = iPlayUser;

  09380	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09383	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  09389	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0938c	8b 55 f4	 mov	 edx, DWORD PTR _iPlayUser$[ebp]
  0938f	89 54 01 54	 mov	 DWORD PTR [ecx+eax+84], edx

; 3180 : 		iRET_VAL = iPlayUser;

  09393	8b 45 f4	 mov	 eax, DWORD PTR _iPlayUser$[ebp]
  09396	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 3181 : 	}
; 3182 : 	else

  09399	eb 1b		 jmp	 SHORT $LN1@ReCalcUser
$LN2@ReCalcUser:

; 3183 : 	{
; 3184 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = 0;

  0939b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0939e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  093a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  093a7	c7 44 01 54 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+84], 0

; 3185 : 		iRET_VAL = 0;

  093af	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_VAL$[ebp], 0
$LN1@ReCalcUser:

; 3186 : 	}
; 3187 : 	return iRET_VAL;

  093b6	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN4@ReCalcUser:

; 3188 : }

  093b9	5f		 pop	 edi
  093ba	5e		 pop	 esi
  093bb	5b		 pop	 ebx
  093bc	8b e5		 mov	 esp, ebp
  093be	5d		 pop	 ebp
  093bf	c2 04 00	 ret	 4
?ReCalcUserCount@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::ReCalcUserCount
_TEXT	ENDS
PUBLIC	??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?RewardZettoMoney@CChaosCastle@@QAEHH@Z		; CChaosCastle::RewardZettoMoney
;	COMDAT ??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Win Zen Lotto (RewardZen:%d, User'
	DB	'Zen:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Chaos Castle][Bug Tracer] (%d) [%s][%s] Reword ZettoMoney(Map'
	DB	':%d) Send Message', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@
CONST	SEGMENT
??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@ DB '['
	DB	'Chaos Castle] (%d) ERROR : REWARD ZEN <= 0 (%d)', 00H ; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?RewardZettoMoney@CChaosCastle@@QAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RewardZettoMoney@CChaosCastle@@QAEHH@Z$0
__ehfuncinfo$?RewardZettoMoney@CChaosCastle@@QAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv286 = -416						; size = 4
tv67 = -416						; size = 4
$T242334 = -412						; size = 4
$T242337 = -408						; size = 4
_i$238918 = -340					; size = 4
_pNotice$ = -336					; size = 272
_szZettoWinnerName$ = -64				; size = 11
_iZettoWinnerIndex$ = -52				; size = 4
_i$238906 = -48						; size = 4
_vtZettoWinner$ = -44					; size = 16
_iZettoMoney$ = -28					; size = 4
_iPlayUser$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
?RewardZettoMoney@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::RewardZettoMoney
; _this$ = ecx

; 3191 : {

  093d0	55		 push	 ebp
  093d1	8b ec		 mov	 ebp, esp
  093d3	6a ff		 push	 -1
  093d5	68 00 00 00 00	 push	 __ehhandler$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
  093da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  093e0	50		 push	 eax
  093e1	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  093e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  093ec	33 c5		 xor	 eax, ebp
  093ee	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  093f1	53		 push	 ebx
  093f2	56		 push	 esi
  093f3	57		 push	 edi
  093f4	50		 push	 eax
  093f5	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  093f8	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  093fe	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3192 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  09401	83 7d 08 00	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 0
  09405	7d 0c		 jge	 SHORT $LN20@RewardZett
  09407	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  09411	eb 0f		 jmp	 SHORT $LN21@RewardZett
$LN20@RewardZett:
  09413	33 c0		 xor	 eax, eax
  09415	83 7d 08 06	 cmp	 DWORD PTR _iChaosCastleIndex$[ebp], 6
  09419	0f 9e c0	 setle	 al
  0941c	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN21@RewardZett:
  09422	83 bd 60 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  09429	75 0a		 jne	 SHORT $LN17@RewardZett

; 3193 : 	{
; 3194 : 		return -1;

  0942b	b8 ff ff ff ff	 mov	 eax, -1
  09430	e9 c1 04 00 00	 jmp	 $LN18@RewardZett
$LN17@RewardZett:

; 3195 : 	}
; 3196 : 
; 3197 : 	int iPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  09435	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09438	50		 push	 eax
  09439	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0943c	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  09441	89 45 e8	 mov	 DWORD PTR _iPlayUser$[ebp], eax

; 3198 : 
; 3199 : 	if ( iPlayUser <= 0 )

  09444	83 7d e8 00	 cmp	 DWORD PTR _iPlayUser$[ebp], 0
  09448	7f 08		 jg	 SHORT $LN16@RewardZett

; 3200 : 	{
; 3201 : 		return -1;

  0944a	83 c8 ff	 or	 eax, -1
  0944d	e9 a4 04 00 00	 jmp	 $LN18@RewardZett
$LN16@RewardZett:

; 3202 : 	}
; 3203 : 
; 3204 : 	int iZettoMoney = iPlayUser * (g_iChaosCastle_EnterCost[iChaosCastleIndex] * 80 / 100);

  09452	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09455	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _g_iChaosCastle_EnterCost[eax*4]
  0945c	6b c0 50	 imul	 eax, 80			; 00000050H
  0945f	99		 cdq
  09460	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  09465	f7 f9		 idiv	 ecx
  09467	0f af 45 e8	 imul	 eax, DWORD PTR _iPlayUser$[ebp]
  0946b	89 45 e4	 mov	 DWORD PTR _iZettoMoney$[ebp], eax

; 3205 : 
; 3206 : 	if ( iZettoMoney <= 0 )

  0946e	83 7d e4 00	 cmp	 DWORD PTR _iZettoMoney$[ebp], 0
  09472	7f 21		 jg	 SHORT $LN15@RewardZett

; 3207 : 	{
; 3208 : 		LogAddTD("[Chaos Castle] (%d) ERROR : REWARD ZEN <= 0 (%d)", iChaosCastleIndex+1, iZettoMoney);

  09474	8b 45 e4	 mov	 eax, DWORD PTR _iZettoMoney$[ebp]
  09477	50		 push	 eax
  09478	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0947b	83 c1 01	 add	 ecx, 1
  0947e	51		 push	 ecx
  0947f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@
  09484	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0948a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3209 : 		return -1;

  0948d	83 c8 ff	 or	 eax, -1
  09490	e9 61 04 00 00	 jmp	 $LN18@RewardZett
$LN15@RewardZett:

; 3210 : 	}
; 3211 : 
; 3212 : 	std::vector<int> vtZettoWinner;

  09495	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  09498	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0949d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3213 : 
; 3214 : 	for(int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  094a4	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$238906[ebp], 0
  094ab	eb 09		 jmp	 SHORT $LN14@RewardZett
$LN13@RewardZett:
  094ad	8b 45 d0	 mov	 eax, DWORD PTR _i$238906[ebp]
  094b0	83 c0 01	 add	 eax, 1
  094b3	89 45 d0	 mov	 DWORD PTR _i$238906[ebp], eax
$LN14@RewardZett:
  094b6	83 7d d0 46	 cmp	 DWORD PTR _i$238906[ebp], 70 ; 00000046H
  094ba	0f 8d af 00 00
	00		 jge	 $LN12@RewardZett

; 3215 : 	{
; 3216 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  094c0	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  094c3	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  094c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  094cc	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  094d0	8b 45 d0	 mov	 eax, DWORD PTR _i$238906[ebp]
  094d3	6b c0 14	 imul	 eax, 20			; 00000014H
  094d6	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  094db	0f 84 89 00 00
	00		 je	 $LN11@RewardZett

; 3217 : 		{
; 3218 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE && 
; 3219 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  094e1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  094e4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  094ea	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  094ed	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  094f1	8b 45 d0	 mov	 eax, DWORD PTR _i$238906[ebp]
  094f4	6b c0 14	 imul	 eax, 20			; 00000014H
  094f7	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  094fb	51		 push	 ecx
  094fc	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  09501	83 c4 04	 add	 esp, 4
  09504	83 f8 01	 cmp	 eax, 1
  09507	75 61		 jne	 SHORT $LN11@RewardZett
  09509	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0950c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  09512	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  09515	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  09519	8b 45 d0	 mov	 eax, DWORD PTR _i$238906[ebp]
  0951c	6b c0 14	 imul	 eax, 20			; 00000014H
  0951f	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  09523	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09529	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0952f	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  09537	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0953a	50		 push	 eax
  0953b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0953e	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  09543	3b f0		 cmp	 esi, eax
  09545	75 23		 jne	 SHORT $LN11@RewardZett

; 3220 : 			{
; 3221 : 				vtZettoWinner.push_back(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex);

  09547	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0954a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  09550	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  09553	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  09557	8b 45 d0	 mov	 eax, DWORD PTR _i$238906[ebp]
  0955a	6b c0 14	 imul	 eax, 20			; 00000014H
  0955d	8d 4c 02 3c	 lea	 ecx, DWORD PTR [edx+eax+60]
  09561	51		 push	 ecx
  09562	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  09565	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN11@RewardZett:

; 3222 : 			}
; 3223 : 		}
; 3224 : 	}

  0956a	e9 3e ff ff ff	 jmp	 $LN13@RewardZett
$LN12@RewardZett:

; 3225 : 
; 3226 : 	iPlayUser = vtZettoWinner.size();

  0956f	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  09572	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  09577	89 45 e8	 mov	 DWORD PTR _iPlayUser$[ebp], eax

; 3227 : 
; 3228 : 	if ( iPlayUser <= 0 )

  0957a	83 7d e8 00	 cmp	 DWORD PTR _iPlayUser$[ebp], 0
  0957e	7f 24		 jg	 SHORT $LN9@RewardZett

; 3229 : 	{
; 3230 : 		return -1;

  09580	c7 85 64 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR $T242334[ebp], -1
  0958a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  09591	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  09594	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  09599	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR $T242334[ebp]
  0959f	e9 52 03 00 00	 jmp	 $LN18@RewardZett
$LN9@RewardZett:

; 3231 : 	}
; 3232 : 
; 3233 : 	int iZettoWinnerIndex = vtZettoWinner[rand()%iPlayUser];

  095a4	e8 00 00 00 00	 call	 _rand
  095a9	99		 cdq
  095aa	f7 7d e8	 idiv	 DWORD PTR _iPlayUser$[ebp]
  095ad	52		 push	 edx
  095ae	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  095b1	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  095b6	8b 00		 mov	 eax, DWORD PTR [eax]
  095b8	89 45 cc	 mov	 DWORD PTR _iZettoWinnerIndex$[ebp], eax

; 3234 : 	char szZettoWinnerName[11] ={0};

  095bb	c6 45 c0 00	 mov	 BYTE PTR _szZettoWinnerName$[ebp], 0
  095bf	33 c0		 xor	 eax, eax
  095c1	89 45 c1	 mov	 DWORD PTR _szZettoWinnerName$[ebp+1], eax
  095c4	89 45 c5	 mov	 DWORD PTR _szZettoWinnerName$[ebp+5], eax
  095c7	66 89 45 c9	 mov	 WORD PTR _szZettoWinnerName$[ebp+9], ax

; 3235 : 	memcpy(szZettoWinnerName, gObj[iZettoWinnerIndex].Name, 10);

  095cb	6a 0a		 push	 10			; 0000000aH
  095cd	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  095d0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  095d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  095dc	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  095e0	52		 push	 edx
  095e1	8d 45 c0	 lea	 eax, DWORD PTR _szZettoWinnerName$[ebp]
  095e4	50		 push	 eax
  095e5	e8 00 00 00 00	 call	 _memcpy
  095ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3236 : 	gObj[iZettoWinnerIndex].Money += iZettoMoney;

  095ed	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  095f0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  095f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  095fc	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  09603	03 55 e4	 add	 edx, DWORD PTR _iZettoMoney$[ebp]
  09606	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  09609	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0960f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09615	89 94 01 f0 00
	00 00		 mov	 DWORD PTR [ecx+eax+240], edx

; 3237 : 
; 3238 : 	if ( gObj[iZettoWinnerIndex].Money > MAX_ZEN )

  0961c	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  0961f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09625	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0962b	81 bc 01 f0 00
	00 00 00 94 35
	77		 cmp	 DWORD PTR [ecx+eax+240], 2000000000 ; 77359400H
  09636	7e 1a		 jle	 SHORT $LN8@RewardZett

; 3239 : 	{
; 3240 : 		gObj[iZettoWinnerIndex].Money = MAX_ZEN;

  09638	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  0963b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09641	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09647	c7 84 01 f0 00
	00 00 00 94 35
	77		 mov	 DWORD PTR [ecx+eax+240], 2000000000 ; 77359400H
$LN8@RewardZett:

; 3241 : 	}
; 3242 : 
; 3243 : 	GCMoneySend(iZettoWinnerIndex, gObj[iZettoWinnerIndex].Money);

  09652	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  09655	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0965b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09661	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  09668	52		 push	 edx
  09669	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  0966c	50		 push	 eax
  0966d	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  09672	83 c4 08	 add	 esp, 8

; 3244 : 
; 3245 : 	PMSG_NOTICE pNotice;
; 3246 : 	TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4,213)), iChaosCastleIndex+1, szZettoWinnerName, iZettoMoney);

  09675	8b 45 e4	 mov	 eax, DWORD PTR _iZettoMoney$[ebp]
  09678	50		 push	 eax
  09679	8d 4d c0	 lea	 ecx, DWORD PTR _szZettoWinnerName$[ebp]
  0967c	51		 push	 ecx
  0967d	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  09680	83 c2 01	 add	 edx, 1
  09683	52		 push	 edx
  09684	68 d5 04 00 00	 push	 1237			; 000004d5H
  09689	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0968e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  09693	50		 push	 eax
  09694	6a 00		 push	 0
  09696	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0969c	50		 push	 eax
  0969d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  096a2	83 c4 18	 add	 esp, 24			; 00000018H

; 3247 : 
; 3248 : 	for(int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  096a5	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$238918[ebp], 0
  096af	eb 0f		 jmp	 SHORT $LN7@RewardZett
$LN6@RewardZett:
  096b1	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _i$238918[ebp]
  096b7	83 c0 01	 add	 eax, 1
  096ba	89 85 ac fe ff
	ff		 mov	 DWORD PTR _i$238918[ebp], eax
$LN7@RewardZett:
  096c0	83 bd ac fe ff
	ff 46		 cmp	 DWORD PTR _i$238918[ebp], 70 ; 00000046H
  096c7	0f 8d 86 01 00
	00		 jge	 $LN5@RewardZett

; 3249 : 	{
; 3250 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  096cd	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  096d0	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  096d6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  096d9	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  096dd	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _i$238918[ebp]
  096e3	6b c0 14	 imul	 eax, 20			; 00000014H
  096e6	83 7c 02 3c ff	 cmp	 DWORD PTR [edx+eax+60], -1
  096eb	0f 84 5d 01 00
	00		 je	 $LN4@RewardZett

; 3251 : 		{
; 3252 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected == PLAYER_PLAYING )

  096f1	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  096f4	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  096fa	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  096fd	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  09701	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _i$238918[ebp]
  09707	6b c0 14	 imul	 eax, 20			; 00000014H
  0970a	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  0970e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09714	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0971a	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0971f	0f 85 29 01 00
	00		 jne	 $LN4@RewardZett

; 3253 : 			{
; 3254 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && 
; 3255 : 					 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex!= -1)

  09725	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09728	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0972e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  09731	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  09735	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _i$238918[ebp]
  0973b	6b c0 14	 imul	 eax, 20			; 00000014H
  0973e	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  09742	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09748	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0974e	0f be 84 0a a5
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3749]
  09756	83 f8 ff	 cmp	 eax, -1
  09759	74 6b		 je	 SHORT $LN2@RewardZett
  0975b	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  0975e	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  09764	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  09767	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0976b	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _i$238918[ebp]
  09771	6b c0 14	 imul	 eax, 20			; 00000014H
  09774	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  09778	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0977e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09784	0f be 84 0a a6
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3750]
  0978c	83 f8 ff	 cmp	 eax, -1
  0978f	74 35		 je	 SHORT $LN2@RewardZett

; 3256 : 				{
; 3257 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  09791	0f b6 85 b1 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  09798	50		 push	 eax
  09799	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0979f	51		 push	 ecx
  097a0	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  097a3	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  097a9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  097ac	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  097b0	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _i$238918[ebp]
  097b6	6b d2 14	 imul	 edx, 20			; 00000014H
  097b9	8b 44 11 3c	 mov	 eax, DWORD PTR [ecx+edx+60]
  097bd	50		 push	 eax
  097be	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  097c3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@RewardZett:

; 3258 : 				}
; 3259 : 
; 3260 : 				LogAddTD("[Chaos Castle][Bug Tracer] (%d) [%s][%s] Reword ZettoMoney(Map:%d) Send Message",
; 3261 : 					iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 3262 : 					gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,	gObj[iZettoWinnerIndex].MapNumber);

  097c6	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  097c9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  097cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  097d5	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  097dd	52		 push	 edx
  097de	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  097e1	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  097e7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  097ea	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  097ee	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _i$238918[ebp]
  097f4	6b c0 14	 imul	 eax, 20			; 00000014H
  097f7	8b 4c 02 3c	 mov	 ecx, DWORD PTR [edx+eax+60]
  097fb	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09801	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09807	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  0980b	50		 push	 eax
  0980c	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0980f	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  09815	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  09818	8d 44 0a 30	 lea	 eax, DWORD PTR [edx+ecx+48]
  0981c	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _i$238918[ebp]
  09822	6b c9 14	 imul	 ecx, 20			; 00000014H
  09825	8b 54 08 3c	 mov	 edx, DWORD PTR [eax+ecx+60]
  09829	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0982f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09834	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  09838	51		 push	 ecx
  09839	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  0983c	83 c2 01	 add	 edx, 1
  0983f	52		 push	 edx
  09840	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  09845	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0984b	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@RewardZett:

; 3263 : 			}
; 3264 : 		}
; 3265 : 	}

  0984e	e9 5e fe ff ff	 jmp	 $LN6@RewardZett
$LN5@RewardZett:

; 3266 : 
; 3267 : 	if ( OBJMAX_RANGE(iZettoWinnerIndex))

  09853	83 7d cc 00	 cmp	 DWORD PTR _iZettoWinnerIndex$[ebp], 0
  09857	7d 0c		 jge	 SHORT $LN22@RewardZett
  09859	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv286[ebp], 0
  09863	eb 12		 jmp	 SHORT $LN23@RewardZett
$LN22@RewardZett:
  09865	33 c0		 xor	 eax, eax
  09867	81 7d cc 97 3a
	00 00		 cmp	 DWORD PTR _iZettoWinnerIndex$[ebp], 14999 ; 00003a97H
  0986e	0f 9e c0	 setle	 al
  09871	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv286[ebp], eax
$LN23@RewardZett:
  09877	83 bd 60 fe ff
	ff 00		 cmp	 DWORD PTR tv286[ebp], 0
  0987e	74 58		 je	 SHORT $LN1@RewardZett

; 3268 : 	{
; 3269 : 		LogAddTD("[Chaos Castle] (%d) [%s][%s] Win Zen Lotto (RewardZen:%d, UserZen:%d)", iChaosCastleIndex+1, gObj[iZettoWinnerIndex].AccountID, gObj[iZettoWinnerIndex].Name, iZettoMoney, gObj[iZettoWinnerIndex].Money);

  09880	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  09883	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09889	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0988f	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  09896	52		 push	 edx
  09897	8b 45 e4	 mov	 eax, DWORD PTR _iZettoMoney$[ebp]
  0989a	50		 push	 eax
  0989b	8b 4d cc	 mov	 ecx, DWORD PTR _iZettoWinnerIndex$[ebp]
  0989e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  098a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  098aa	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  098ae	50		 push	 eax
  098af	8b 4d cc	 mov	 ecx, DWORD PTR _iZettoWinnerIndex$[ebp]
  098b2	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  098b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  098be	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  098c2	50		 push	 eax
  098c3	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  098c6	83 c1 01	 add	 ecx, 1
  098c9	51		 push	 ecx
  098ca	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  098cf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  098d5	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@RewardZett:

; 3270 : 	}
; 3271 : 
; 3272 : 	return iZettoWinnerIndex;

  098d8	8b 45 cc	 mov	 eax, DWORD PTR _iZettoWinnerIndex$[ebp]
  098db	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T242337[ebp], eax
  098e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  098e8	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  098eb	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  098f0	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR $T242337[ebp]
$LN18@RewardZett:

; 3273 : }

  098f6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  098f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  09900	59		 pop	 ecx
  09901	5f		 pop	 edi
  09902	5e		 pop	 esi
  09903	5b		 pop	 ebx
  09904	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  09907	33 cd		 xor	 ecx, ebp
  09909	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0990e	8b e5		 mov	 esp, ebp
  09910	5d		 pop	 ebp
  09911	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RewardZettoMoney@CChaosCastle@@QAEHH@Z$0:
  000db	8d 4d d4	 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  000de	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?RewardZettoMoney@CChaosCastle@@QAEHH@Z:
  000e3	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000e7	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ea	8b 8a 5c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-420]
  000f0	33 c8		 xor	 ecx, eax
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000fa	33 c8		 xor	 ecx, eax
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
  00106	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RewardZettoMoney@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::RewardZettoMoney
PUBLIC	?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckRegisterOfflineGift
EXTRN	?EGReqRegCCOfflineGift@@YAXH@Z:PROC		; EGReqRegCCOfflineGift
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iGiftRate$ = -8					; size = 4
_this$ = -4						; size = 4
_iUserIndex$ = 8					; size = 4
?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z PROC	; CChaosCastle::CheckRegisterOfflineGift
; _this$ = ecx

; 3276 : {

  09920	55		 push	 ebp
  09921	8b ec		 mov	 ebp, esp
  09923	83 ec 48	 sub	 esp, 72			; 00000048H
  09926	53		 push	 ebx
  09927	56		 push	 esi
  09928	57		 push	 edi
  09929	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3277 : 	if ( gObjIsConnected(iUserIndex) == FALSE )

  0992c	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0992f	50		 push	 eax
  09930	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  09935	83 c4 04	 add	 esp, 4
  09938	85 c0		 test	 eax, eax
  0993a	75 02		 jne	 SHORT $LN2@CheckRegis

; 3278 : 	{
; 3279 : 		return;

  0993c	eb 27		 jmp	 SHORT $LN3@CheckRegis
$LN2@CheckRegis:

; 3280 : 	}
; 3281 : 
; 3282 : 	int iGiftRate = rand() % 10000;

  0993e	e8 00 00 00 00	 call	 _rand
  09943	99		 cdq
  09944	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  09949	f7 f9		 idiv	 ecx
  0994b	89 55 f8	 mov	 DWORD PTR _iGiftRate$[ebp], edx

; 3283 : 
; 3284 : 	if ( iGiftRate < ::g_iChaosCastle_OffLineGiftRate )

  0994e	8b 45 f8	 mov	 eax, DWORD PTR _iGiftRate$[ebp]
  09951	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA ; g_iChaosCastle_OffLineGiftRate
  09957	7d 0c		 jge	 SHORT $LN3@CheckRegis

; 3285 : 	{
; 3286 : 		EGReqRegCCOfflineGift(iUserIndex);

  09959	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0995c	50		 push	 eax
  0995d	e8 00 00 00 00	 call	 ?EGReqRegCCOfflineGift@@YAXH@Z ; EGReqRegCCOfflineGift
  09962	83 c4 04	 add	 esp, 4
$LN3@CheckRegis:

; 3287 : 	}
; 3288 : }

  09965	5f		 pop	 edi
  09966	5e		 pop	 esi
  09967	5b		 pop	 ebx
  09968	8b e5		 mov	 esp, ebp
  0996a	5d		 pop	 ebp
  0996b	c2 04 00	 ret	 4
?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z ENDP	; CChaosCastle::CheckRegisterOfflineGift
; Function compile flags: /Odtp /ZI
tv64 = -76						; size = 4
_iMapNumber$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z PROC	; CChaosCastle::GetChaosCastleMapNumber
; _this$ = ecx

; 3291 : {

  09970	55		 push	 ebp
  09971	8b ec		 mov	 ebp, esp
  09973	83 ec 4c	 sub	 esp, 76			; 0000004cH
  09976	53		 push	 ebx
  09977	56		 push	 esi
  09978	57		 push	 edi
  09979	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3292 : 	int iMapNumber = 0;

  0997c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 0

; 3293 : 
; 3294 : 	switch(iChaosCastleIndex)

  09983	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  09986	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  09989	83 7d b4 06	 cmp	 DWORD PTR tv64[ebp], 6
  0998d	77 47		 ja	 SHORT $LN8@GetChaosCa
  0998f	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  09992	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN12@GetChaosCa[ecx*4]
$LN7@GetChaosCa:

; 3295 : 	{
; 3296 : 	case 0:
; 3297 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE1;

  09999	c7 45 f8 12 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 18 ; 00000012H

; 3298 : 		break;

  099a0	eb 34		 jmp	 SHORT $LN8@GetChaosCa
$LN6@GetChaosCa:

; 3299 : 	case 1:
; 3300 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE2;

  099a2	c7 45 f8 13 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 19 ; 00000013H

; 3301 : 		break;

  099a9	eb 2b		 jmp	 SHORT $LN8@GetChaosCa
$LN5@GetChaosCa:

; 3302 : 	case 2:
; 3303 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE3;

  099ab	c7 45 f8 14 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 20 ; 00000014H

; 3304 : 		break;

  099b2	eb 22		 jmp	 SHORT $LN8@GetChaosCa
$LN4@GetChaosCa:

; 3305 : 	case 3:
; 3306 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE4;

  099b4	c7 45 f8 15 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 21 ; 00000015H

; 3307 : 		break;

  099bb	eb 19		 jmp	 SHORT $LN8@GetChaosCa
$LN3@GetChaosCa:

; 3308 : 	case 4:
; 3309 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE5;

  099bd	c7 45 f8 16 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 22 ; 00000016H

; 3310 : 		break;

  099c4	eb 10		 jmp	 SHORT $LN8@GetChaosCa
$LN2@GetChaosCa:

; 3311 : 	case 5:
; 3312 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE6;

  099c6	c7 45 f8 17 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 23 ; 00000017H

; 3313 : 		break;

  099cd	eb 07		 jmp	 SHORT $LN8@GetChaosCa
$LN1@GetChaosCa:

; 3314 : 	case 6:
; 3315 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE7;

  099cf	c7 45 f8 35 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 53 ; 00000035H
$LN8@GetChaosCa:

; 3316 : 		break;
; 3317 : 	}
; 3318 : 
; 3319 : 	return iMapNumber;

  099d6	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]

; 3320 : }

  099d9	5f		 pop	 edi
  099da	5e		 pop	 esi
  099db	5b		 pop	 ebx
  099dc	8b e5		 mov	 esp, ebp
  099de	5d		 pop	 ebp
  099df	c2 04 00	 ret	 4
  099e2	8b ff		 npad	 2
$LN12@GetChaosCa:
  099e4	00 00 00 00	 DD	 $LN7@GetChaosCa
  099e8	00 00 00 00	 DD	 $LN6@GetChaosCa
  099ec	00 00 00 00	 DD	 $LN5@GetChaosCa
  099f0	00 00 00 00	 DD	 $LN4@GetChaosCa
  099f4	00 00 00 00	 DD	 $LN3@GetChaosCa
  099f8	00 00 00 00	 DD	 $LN2@GetChaosCa
  099fc	00 00 00 00	 DD	 $LN1@GetChaosCa
?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ENDP	; CChaosCastle::GetChaosCastleMapNumber
; Function compile flags: /Odtp /ZI
tv64 = -76						; size = 4
_iChaosCastleIndex$ = -8				; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetChaosCastleIndex
; _this$ = ecx

; 3323 : {

  09a00	55		 push	 ebp
  09a01	8b ec		 mov	 ebp, esp
  09a03	83 ec 4c	 sub	 esp, 76			; 0000004cH
  09a06	53		 push	 ebx
  09a07	56		 push	 esi
  09a08	57		 push	 edi
  09a09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3324 : 	int iChaosCastleIndex = -1;

  09a0c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], -1

; 3325 : 
; 3326 : 	switch(iMAP_NUM)

  09a13	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  09a16	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  09a19	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  09a1c	83 e9 12	 sub	 ecx, 18			; 00000012H
  09a1f	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  09a22	83 7d b4 23	 cmp	 DWORD PTR tv64[ebp], 35	; 00000023H
  09a26	77 4e		 ja	 SHORT $LN8@GetChaosCa@2
  09a28	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  09a2b	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN12@GetChaosCa@2[edx]
  09a32	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetChaosCa@2[eax*4]
$LN7@GetChaosCa@2:

; 3327 : 	{
; 3328 : 	case MAP_INDEX_CHAOSCASTLE1:
; 3329 : 		iChaosCastleIndex = 0;

  09a39	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 0

; 3330 : 		break;

  09a40	eb 34		 jmp	 SHORT $LN8@GetChaosCa@2
$LN6@GetChaosCa@2:

; 3331 : 	case MAP_INDEX_CHAOSCASTLE2:
; 3332 : 		iChaosCastleIndex = 1;

  09a42	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 1

; 3333 : 		break;

  09a49	eb 2b		 jmp	 SHORT $LN8@GetChaosCa@2
$LN5@GetChaosCa@2:

; 3334 : 	case MAP_INDEX_CHAOSCASTLE3:
; 3335 : 		iChaosCastleIndex = 2;

  09a4b	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 2

; 3336 : 		break;

  09a52	eb 22		 jmp	 SHORT $LN8@GetChaosCa@2
$LN4@GetChaosCa@2:

; 3337 : 	case MAP_INDEX_CHAOSCASTLE4:
; 3338 : 		iChaosCastleIndex = 3;

  09a54	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 3

; 3339 : 		break;

  09a5b	eb 19		 jmp	 SHORT $LN8@GetChaosCa@2
$LN3@GetChaosCa@2:

; 3340 : 	case MAP_INDEX_CHAOSCASTLE5:
; 3341 : 		iChaosCastleIndex = 4;

  09a5d	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 4

; 3342 : 		break;

  09a64	eb 10		 jmp	 SHORT $LN8@GetChaosCa@2
$LN2@GetChaosCa@2:

; 3343 : 	case MAP_INDEX_CHAOSCASTLE6:
; 3344 : 		iChaosCastleIndex = 5;

  09a66	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 5

; 3345 : 		break;

  09a6d	eb 07		 jmp	 SHORT $LN8@GetChaosCa@2
$LN1@GetChaosCa@2:

; 3346 : 	case MAP_INDEX_CHAOSCASTLE7:
; 3347 : 		iChaosCastleIndex = 6;

  09a6f	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _iChaosCastleIndex$[ebp], 6
$LN8@GetChaosCa@2:

; 3348 : 		break;
; 3349 : 	}
; 3350 : 
; 3351 : 	return iChaosCastleIndex;

  09a76	8b 45 f8	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]

; 3352 : }

  09a79	5f		 pop	 edi
  09a7a	5e		 pop	 esi
  09a7b	5b		 pop	 ebx
  09a7c	8b e5		 mov	 esp, ebp
  09a7e	5d		 pop	 ebp
  09a7f	c2 04 00	 ret	 4
  09a82	8b ff		 npad	 2
$LN13@GetChaosCa@2:
  09a84	00 00 00 00	 DD	 $LN7@GetChaosCa@2
  09a88	00 00 00 00	 DD	 $LN6@GetChaosCa@2
  09a8c	00 00 00 00	 DD	 $LN5@GetChaosCa@2
  09a90	00 00 00 00	 DD	 $LN4@GetChaosCa@2
  09a94	00 00 00 00	 DD	 $LN3@GetChaosCa@2
  09a98	00 00 00 00	 DD	 $LN2@GetChaosCa@2
  09a9c	00 00 00 00	 DD	 $LN1@GetChaosCa@2
  09aa0	00 00 00 00	 DD	 $LN8@GetChaosCa@2
$LN12@GetChaosCa@2:
  09aa4	00		 DB	 0
  09aa5	01		 DB	 1
  09aa6	02		 DB	 2
  09aa7	03		 DB	 3
  09aa8	04		 DB	 4
  09aa9	05		 DB	 5
  09aaa	07		 DB	 7
  09aab	07		 DB	 7
  09aac	07		 DB	 7
  09aad	07		 DB	 7
  09aae	07		 DB	 7
  09aaf	07		 DB	 7
  09ab0	07		 DB	 7
  09ab1	07		 DB	 7
  09ab2	07		 DB	 7
  09ab3	07		 DB	 7
  09ab4	07		 DB	 7
  09ab5	07		 DB	 7
  09ab6	07		 DB	 7
  09ab7	07		 DB	 7
  09ab8	07		 DB	 7
  09ab9	07		 DB	 7
  09aba	07		 DB	 7
  09abb	07		 DB	 7
  09abc	07		 DB	 7
  09abd	07		 DB	 7
  09abe	07		 DB	 7
  09abf	07		 DB	 7
  09ac0	07		 DB	 7
  09ac1	07		 DB	 7
  09ac2	07		 DB	 7
  09ac3	07		 DB	 7
  09ac4	07		 DB	 7
  09ac5	07		 DB	 7
  09ac6	07		 DB	 7
  09ac7	06		 DB	 6
?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetChaosCastleIndex
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T242350 = -70						; size = 1
$T242351 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T242350[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T242351[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
tv137 = -88						; size = 4
$T242368 = -84						; size = 4
$T242369 = -80						; size = 4
$T242371 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0001c	8d 45 b0	 lea	 eax, DWORD PTR $T242369[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 2d		 jne	 SHORT $LN3@find
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN3@find
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00060	89 4d a8	 mov	 DWORD PTR tv137[ebp], ecx
  00063	eb 0f		 jmp	 SHORT $LN4@find
$LN3@find:
  00065	8d 55 b4	 lea	 edx, DWORD PTR $T242371[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  00071	89 45 a8	 mov	 DWORD PTR tv137[ebp], eax
$LN4@find:
  00074	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  00077	89 45 ac	 mov	 DWORD PTR $T242368[ebp], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T242368[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00082	89 10		 mov	 DWORD PTR [eax], edx
  00084	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : 		}

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
PUBLIC	??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T242375 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T242375[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
PUBLIC	?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__ehhandler$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
PUBLIC	?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
PUBLIC	?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
PUBLIC	??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::addressof<CHAOSCASTLE_START_TIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Idx$239018 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::addressof<CHAOSCASTLE_START_TIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::addressof<CHAOSCASTLE_START_TIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$239018[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$239018[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy
PUBLIC	??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
PUBLIC	?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T242396 = -84						; size = 4
__Ptr$239046 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$239046[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$239046[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$239046[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T242396[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T242396[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T242399 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T242399[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
PUBLIC	?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
PUBLIC	??$addressof@$$CBH@std@@YAPBHABH@Z		; std::addressof<int const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Idx$239085 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$239085[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$239085[ebp]
  00075	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 04	 add	 ecx, 4
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 04	 add	 ecx, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >
PUBLIC	??0?$allocator@UtagPOINT@@@std@@QAE@XZ		; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T242426 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T242426[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UtagPOINT@@@std@@QAE@XZ ; std::allocator<tagPOINT>::allocator<tagPOINT>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
PUBLIC	?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
__ehhandler$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
PUBLIC	?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ
_TEXT	SEGMENT
$T242441 = -76						; size = 4
$T242442 = -72						; size = 4
_this$ = -4						; size = 4
?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back, COMDAT
; _this$ = ecx

; 966  : 		{	// return last element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 967  : 		return (*(end() - 1));

  0000c	6a 01		 push	 1
  0000e	8d 45 b8	 lea	 eax, DWORD PTR $T242442[ebp]
  00011	50		 push	 eax
  00012	8d 4d b4	 lea	 ecx, DWORD PTR $T242441[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 ??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*

; 968  : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
PUBLIC	?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
PUBLIC	?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
PUBLIC	??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ; std::addressof<tagPOINT const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z
_TEXT	SEGMENT
__Idx$239284 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ; std::addressof<tagPOINT const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ; std::addressof<tagPOINT const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$239284[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$239284[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back@3
$LN4@push_back@3:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@3:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Odtp /ZI
;	COMDAT ?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back, COMDAT
; _this$ = ecx

; 1016 : 		{	// erase element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1017 : 		if (!empty())

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
  00014	0f b6 c0	 movzx	 eax, al
  00017	85 c0		 test	 eax, eax
  00019	75 28		 jne	 SHORT $LN2@pop_back

; 1018 : 			{	// erase last element
; 1019 : 			_Dest_val(this->_Alval,
; 1020 : 				this->_Mylast - 1);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	83 e9 08	 sub	 ecx, 8
  00024	51		 push	 ecx
  00025	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00028	83 c2 0c	 add	 edx, 12			; 0000000cH
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
  00031	83 c4 08	 add	 esp, 8

; 1021 : 			--this->_Mylast;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	83 e9 08	 sub	 ecx, 8
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN2@pop_back:

; 1022 : 			}
; 1023 : 		}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 372  : 	_Tree_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >

; 373  : 		{	// construct with null node
; 374  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		return (_Left < _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 9c c0	 setl	 al

; 126  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
$T242457 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T242457[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1451 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
PUBLIC	??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$239335 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$239335[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase
$LN2@Erase:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$239335[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$239335[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$239335[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$239335[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$239335[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase
$LN4@Erase:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T242471 = -88						; size = 4
$T242472 = -84						; size = 4
$T242473 = -80						; size = 4
$T242474 = -76						; size = 4
$T242475 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T242472[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T242471[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T242474[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T242473[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T242471[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T242473[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T242475[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
PUBLIC	?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
PUBLIC	?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
PUBLIC	?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
PUBLIC	?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
PUBLIC	?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z PROC ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ENDP ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z PROC ; std::vector<int,std::allocator<int> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
PUBLIC	?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 02	 sar	 edx, 2
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@3
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@3
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@3
$LN3@Inside@3:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@3:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
PUBLIC	?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
PUBLIC	?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
PUBLIC	?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
PUBLIC	?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
PUBLIC	?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@3
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@3

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@3
$LN2@Reserve@3:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
$LN6@Reserve@3:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::deallocate
PUBLIC	?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::deallocate
$LN1@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z	; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z PROC ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z ; std::allocator<tagPOINT>::allocator<tagPOINT>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ENDP ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UtagPOINT@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UtagPOINT@@@std@@QAE@XZ PROC		; std::allocator<tagPOINT>::allocator<tagPOINT>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UtagPOINT@@@std@@QAE@XZ ENDP		; std::allocator<tagPOINT>::allocator<tagPOINT>
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>

; 209  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
; Function compile flags: /Odtp /ZI
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-, COMDAT
; _this$ = ecx

; 374  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 375  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 376  : 		return (_Tmp -= _Off);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00017	50		 push	 eax
  00018	8d 4d f8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0001b	e8 00 00 00 00	 call	 ??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 377  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T242562 = -84						; size = 4
$T242563 = -80						; size = 4
$T242564 = -76						; size = 4
$T242565 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T242562[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase@2
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T242563[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase@2

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase@2

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase@2
$LN2@erase@2:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase@2

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T242564[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T242565[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase@2
$LN1@erase@2:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@2:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Wherenode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1742 : 		_Nodeptr _Pnode = _Root();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Wherenode$[ebp], ecx
$LN4@Lbound:

; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0002b	83 c4 04	 add	 esp, 4
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	85 c9		 test	 ecx, ecx
  00033	75 4c		 jne	 SHORT $LN3@Lbound

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 13		 je	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1748 : 			else

  00066	eb 17		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1752 : 				}

  0007f	eb a1		 jmp	 SHORT $LN4@Lbound
$LN3@Lbound:

; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1755 : 		}

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 19	 add	 eax, 25			; 00000019H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
PUBLIC	?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$239566 = -28					; size = 4
__Ptr$239559 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$239559[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$239559[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239559[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$239566[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239559[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$239566[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239559[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239559[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<CHAOSCASTLE_START_TIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<CHAOSCASTLE_START_TIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$239597 = -28					; size = 4
__Ptr$239590 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$239590[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$239590[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239590[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$239597[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239590[ebp]
  00114	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$239597[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239590[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239590[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z PROC ; std::vector<int,std::allocator<int> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
PUBLIC	?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$239639 = -28					; size = 4
__Ptr$239632 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@3
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$239632[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$239632[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@3
__catch$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239632[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@3:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$239639[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::deallocate
$LN1@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239632[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$239639[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239632[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$239632[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@3:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ	; std::allocator<tagPOINT>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ ; std::allocator<tagPOINT>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@3
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@3:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@3

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@3:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@3:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z PROC	; std::allocator<tagPOINT>::allocator<tagPOINT>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z PROC ; std::allocator<tagPOINT>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ENDP ; std::allocator<tagPOINT>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Odtp /ZI
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=, COMDAT
; _this$ = ecx

; 369  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 		return (*this += -_Off);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000f	f7 d8		 neg	 eax
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=

; 371  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@2:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@2

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase@3

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase@3:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase@3

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase@3
$LN39@erase@3:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase@3

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase@3
$LN37@erase@3:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@3:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase@3

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase@3

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase@3:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase@3

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase@3
$LN33@erase@3:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase@3

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase@3
$LN31@erase@3:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase@3:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase@3

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase@3
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase@3
$LN43@erase@3:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase@3:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@3:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase@3

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase@3
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase@3
$LN45@erase@3:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase@3:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase@3:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase@3
$LN35@erase@3:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase@3

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase@3
$LN26@erase@3:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase@3

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase@3:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase@3:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase@3

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase@3
$LN23@erase@3:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase@3

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase@3
$LN21@erase@3:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase@3:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase@3:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase@3
  00392	eb 11		 jmp	 SHORT $LN18@erase@3
$LN17@erase@3:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@3:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase@3
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase@3

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase@3

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase@3

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@3:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase@3

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase@3
$LN13@erase@3:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase@3
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase@3

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase@3
$LN11@erase@3:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase@3

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase@3:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase@3
$LN12@erase@3:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase@3
$LN15@erase@3:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase@3

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase@3:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase@3

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase@3
$LN6@erase@3:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase@3
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase@3

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase@3
$LN4@erase@3:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase@3

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@3:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase@3
$LN8@erase@3:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase@3
$LN16@erase@3:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase@3:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase@3

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase@3:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@3:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 18	 add	 eax, 24			; 00000018H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
PUBLIC	??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ; std::_Allocate<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ; std::_Allocate<CHAOSCASTLE_START_TIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<CHAOSCASTLE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ; std::_Allocate<tagPOINT>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z PROC ; std::allocator<tagPOINT>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ; std::_Allocate<tagPOINT>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ENDP ; std::allocator<tagPOINT>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ PROC	; std::allocator<tagPOINT>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@3
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@3
$LN3@max_size@3:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ ENDP	; std::allocator<tagPOINT>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=, COMDAT
; _this$ = ecx

; 357  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 358  : 		*(_Mybase *)this += _Off;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=

; 359  : 		return (*this);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 360  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max
$LN1@Max:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min
$LN1@Min:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=, COMDAT
; _this$ = ecx

; 151  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 		if (this->_Getcont() == 0
; 154  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 155  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 156  : 			{	// report error
; 157  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 158  : 			_SCL_SECURE_OUT_OF_RANGE;
; 159  : 			}
; 160  : 
; 161  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 162  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 163  : 		_SCL_SECURE_VALIDATE_RANGE(
; 164  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 165  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 166  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 167  : 
; 168  : 		_Ptr += _Off;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	89 01		 mov	 DWORD PTR [ecx], eax

; 169  : 		return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 170  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$239856 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator@3
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator@3
$LN6@operator@3:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator@3

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator@3
$LN2@operator@3:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$239856[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$239856[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator@3
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$239856[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator@3

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$239856[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator@3
$LN1@operator@3:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$239856[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@3:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z PROC ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
PUBLIC	??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
PUBLIC	??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  0000c	6a 00		 push	 0
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::addressof<CHAOSCASTLE_START_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::addressof<CHAOSCASTLE_START_TIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>
PUBLIC	??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct
PUBLIC	??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::forward<CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::forward<CHAOSCASTLE_START_TIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
PUBLIC	??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z
_TEXT	SEGMENT
$T242767 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z PROC ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242767[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242767[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ENDP ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBH@std@@YAPBHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBH@std@@YAPBHABH@Z PROC			; std::addressof<int const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBH@std@@YAPBHABH@Z ENDP			; std::addressof<int const >
_TEXT	ENDS
PUBLIC	??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@H@std@@QAEXPAHABH@Z ; std::allocator<int>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z PROC ; std::addressof<tagPOINT const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ENDP ; std::addressof<tagPOINT const >
_TEXT	ENDS
PUBLIC	??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ; std::allocator<tagPOINT>::construct<tagPOINT &>
PUBLIC	??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ; std::allocator<tagPOINT>::construct<tagPOINT &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ; std::allocator<tagPOINT>::construct
PUBLIC	??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ; std::forward<tagPOINT const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ; std::forward<tagPOINT const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ; std::allocator<tagPOINT>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ; std::allocator<tagPOINT>::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z PROC ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ; std::allocator<tagPOINT>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ENDP ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z
_TEXT	SEGMENT
$T242790 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242790[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242790[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T242797 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242797[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242797[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
PUBLIC	??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ; std::_Ptr_cat<tagPOINT,tagPOINT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z
_TEXT	SEGMENT
$T242802 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<tagPOINT> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ; std::_Ptr_cat<tagPOINT,tagPOINT>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242802[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242802[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00012	83 c4 04	 add	 esp, 4
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	88 11		 mov	 BYTE PTR [ecx], dl

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	88 11		 mov	 BYTE PTR [ecx], dl

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T242809 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 49 92
	24 09		 cmp	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T242809[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T242809[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T242812 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z PROC ; std::_Allocate<CHAOSCASTLE_START_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T242812[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T242812[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ENDP ; std::_Allocate<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T242815 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@3

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@3
$LN4@Allocate@3:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@3
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T242815[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T242815[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@3:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@3:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z
_TEXT	SEGMENT
$T242818 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z PROC ; std::_Allocate<tagPOINT>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@4

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@4
$LN4@Allocate@4:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@4
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T242818[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T242818[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@4:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@4:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ENDP ; std::_Allocate<tagPOINT>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T242823 = -117						; size = 1
$T242824 = -116						; size = 4
$T242825 = -112						; size = 4
$T242826 = -105						; size = 1
$T242827 = -104						; size = 4
$T242828 = -97						; size = 1
$T242829 = -96						; size = 4
$T242830 = -89						; size = 1
__Where$240867 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert
$LN11@Linsert:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T242823[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T242823[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T242824[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert
$LN8@Linsert:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$240867[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert
$LN6@Linsert:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T242825[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$240867[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T242826[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T242826[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T242827[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert
$LN4@Linsert:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$240867[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
$LN5@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$240867[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T242828[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T242828[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T242829[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert
$LN2@Linsert:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T242830[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T242830[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$240867[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@HABH@std@@YAXPAHABH@Z ; std::_Construct<int,int const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ; std::_Construct<tagPOINT,tagPOINT const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z PROC ; std::allocator<tagPOINT>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ; std::_Construct<tagPOINT,tagPOINT const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ENDP ; std::allocator<tagPOINT>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z	; std::_Destroy<tagPOINT>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z PROC ; std::allocator<tagPOINT>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z ; std::_Destroy<tagPOINT>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ENDP ; std::allocator<tagPOINT>::destroy
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$240936 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$240936[ebp], eax
$LN10@Insert:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$240936[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$240936[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$240936[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$240936[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
$LN5@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
$LN6@Insert:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$240936[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$240936[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$240936[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
$LN1@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$240936[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
$LN4@Insert:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert
$LN9@Insert:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 55 55
	55 15		 mov	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@4
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@4
$LN3@max_size@4:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$241005 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@4

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@4
$LN8@operator@4:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@4
$LN4@operator@4:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$241005[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$241005[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@4
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$241005[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@4

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$241005[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@4
$LN3@operator@4:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@4

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@4
$LN2@operator@4:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$241005[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@4:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z PROC ; std::forward<_MONSTER_ITEM_DROP &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ENDP ; std::forward<_MONSTER_ITEM_DROP &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z PROC ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00036	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 164  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode
__catch$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T242886 = -88						; size = 4
$T242887 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T242887[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T242887[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T242887[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T242887[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T242886[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T242887[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::move<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::move<CHAOSCASTLE_START_TIME &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z$0
__ehfuncinfo$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T242909 = -88						; size = 4
$T242910 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z PROC	; std::allocator<int>::construct<int &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T242910[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T242910[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T242910[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 02		 mov	 DWORD PTR [edx], eax
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T242910[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct@2:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T242909[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T242910[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ENDP	; std::allocator<int>::construct<int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z PROC ; std::forward<tagPOINT &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ENDP ; std::forward<tagPOINT &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T242926 = -88						; size = 4
$T242927 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z PROC ; std::allocator<tagPOINT>::construct<tagPOINT &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T242927[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T242927[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T242927[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T242927[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@3:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T242926[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T242927[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ENDP ; std::allocator<tagPOINT>::construct<tagPOINT &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z PROC ; std::forward<tagPOINT const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ENDP ; std::forward<tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
PUBLIC	??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ; std::_Val_type<CHAOSCASTLE_START_TIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z
_TEXT	SEGMENT
$T242943 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z PROC ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242943[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242943[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ; std::_Val_type<CHAOSCASTLE_START_TIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
PUBLIC	??$_Val_type@PAH@std@@YAPAHPAH@Z		; std::_Val_type<int *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T242946 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242946[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242946[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 104  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 105  : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
PUBLIC	??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ; std::_Val_type<tagPOINT *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z
_TEXT	SEGMENT
$T242953 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z PROC ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ; std::_Ptr_cat<tagPOINT,tagPOINT>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T242953[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T242953[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ; std::_Val_type<tagPOINT *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ENDP ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z PROC ; std::_Ptr_cat<tagPOINT,tagPOINT>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ENDP ; std::_Ptr_cat<tagPOINT,tagPOINT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<tagPOINT> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagPOINT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T242966 = -88						; size = 4
$T242967 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T242967[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T242967[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::forward<CHAOSCASTLE_START_TIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T242967[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T242967[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T242966[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T242967[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@HABH@std@@YAXPAHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@HABH@std@@YAXPAHABH@Z$0
__ehfuncinfo$??$_Construct@HABH@std@@YAXPAHABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@HABH@std@@YAXPAHABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T242979 = -88						; size = 4
$T242980 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@HABH@std@@YAXPAHABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T242980[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T242980[ebp], 0
  0004a	74 1b		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T242980[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 02		 mov	 DWORD PTR [edx], eax
  0005f	8b 4d ac	 mov	 ecx, DWORD PTR $T242980[ebp]
  00062	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00065	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  00067	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@Construct@2:
  0006e	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  00071	89 55 a8	 mov	 DWORD PTR $T242979[ebp], edx
  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@HABH@std@@YAXPAHABH@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T242980[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@HABH@std@@YAXPAHABH@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@HABH@std@@YAXPAHABH@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T242992 = -88						; size = 4
$T242993 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z PROC ; std::_Construct<tagPOINT,tagPOINT const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T242993[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T242993[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct@3
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ; std::forward<tagPOINT const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T242993[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T242993[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct@3
$LN3@Construct@3:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@3:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T242992[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T242993[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ENDP ; std::_Construct<tagPOINT,tagPOINT const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z PROC	; std::_Destroy<tagPOINT>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z ENDP	; std::_Destroy<tagPOINT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::move<CHAOSCASTLE_START_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::move<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z PROC ; std::_Val_type<CHAOSCASTLE_START_TIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ENDP ; std::_Val_type<CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Val_type<int *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Val_type<int *>
_TEXT	ENDS
EXTRN	_memmove:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<int,int,int>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002f	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 462  : 	}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int,int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z PROC ; std::_Val_type<tagPOINT *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ENDP ; std::_Val_type<tagPOINT *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ; std::_Destroy<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ; std::_Destroy<CHAOSCASTLE_START_TIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::destroy
_TEXT	ENDS
PUBLIC	??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T243065 = -88						; size = 4
$T243066 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T243066[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T243066[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T243066[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@4:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T243065[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T243066[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >
PUBLIC	?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct
PUBLIC	??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ; std::allocator<tagPOINT>::construct
PUBLIC	??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ; std::allocator<tagPOINT>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::_Destroy<CHAOSCASTLE_START_TIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::_Destroy<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T243084 = -88						; size = 4
$T243085 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T243085[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T243085[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@5
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T243085[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T243085[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@5
$LN3@construct@5:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@5:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T243084[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T243085[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T243097 = -88						; size = 4
$T243098 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z PROC ; std::allocator<tagPOINT>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T243098[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T243098[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@6
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T243098[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T243098[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@6
$LN3@construct@6:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@6:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T243097[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T243098[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ENDP ; std::allocator<tagPOINT>::construct
PUBLIC	??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z PROC ; std::forward<tagPOINT>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ENDP ; std::forward<tagPOINT>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z PROC ; std::forward<_MONSTER_ITEM_DROP>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ENDP ; std::forward<_MONSTER_ITEM_DROP>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z PROC ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00036	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 164  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	51		 push	 ecx
  0000a	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  0000d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00010	e8 00 00 00 00	 call	 _sqrtf
  00015	83 c4 04	 add	 esp, 4
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  0000c	83 ec 08	 sub	 esp, 8
  0000f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00012	e8 00 00 00 00	 call	 _sqrt
  00017	83 c4 08	 add	 esp, 8
  0001a	d9 5d bc	 fstp	 DWORD PTR tv73[ebp]
  0001d	d9 45 bc	 fld	 DWORD PTR tv73[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaoscastle.cpp
;	COMDAT ??__Eg_ChaosCastle@@YAXXZ
text$yc	SEGMENT
??__Eg_ChaosCastle@@YAXXZ PROC				; `dynamic initializer for 'g_ChaosCastle'', COMDAT

; 28   : CChaosCastle g_ChaosCastle;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0000e	e8 00 00 00 00	 call	 ??0CChaosCastle@@QAE@XZ	; CChaosCastle::CChaosCastle
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_ChaosCastle@@YAXXZ ; `dynamic atexit destructor for 'g_ChaosCastle''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_ChaosCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_ChaosCastle''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_ChaosCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_ChaosCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ChaosCastle'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0000e	e8 00 00 00 00	 call	 ??1CChaosCastle@@UAE@XZ	; CChaosCastle::~CChaosCastle
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_ChaosCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ChaosCastle''
text$yd	ENDS
PUBLIC	?g_ChaosCastle@@3VCChaosCastle@@A		; g_ChaosCastle
_BSS	SEGMENT
?g_ChaosCastle@@3VCChaosCastle@@A DB 03b94H DUP (?)	; g_ChaosCastle
_BSS	ENDS
CRT$XCU	SEGMENT
_g_ChaosCastle$initializer$ DD FLAT:??__Eg_ChaosCastle@@YAXXZ
CRT$XCU	ENDS
END
