; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\XMasAttackEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ErrorType@@3FA					; ErrorType
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
?ErrorType@@3FA DW 0168H				; ErrorType
	ORG $+6
_g_XMasMapDestPosition DD 085H
	DD	04fH
	DD	057H
	DD	07eH
	DD	085H
	DD	0b2H
	DD	0b4H
	DD	07eH
	DD	0a4H
	DD	02aH
	DD	0ddH
	DD	055H
	DD	0a4H
	DD	02aH
	DD	0ddH
	DD	055H
	DD	0a0H
	DD	04bH
	DD	0a0H
	DD	04bH
	DD	098H
	DD	075H
	DD	0d1H
	DD	085H
?s_iTIME_REMAIN@?7??ProcState_Playing@CXMasAttackEvent@@QAEXXZ@4HA DD 0ffffffffH ; `CXMasAttackEvent::ProcState_Playing'::`8'::s_iTIME_REMAIN
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CXMasMonsterHerd@@6B@			; CXMasMonsterHerd::`vftable'
PUBLIC	??0CXMasMonsterHerd@@QAE@XZ			; CXMasMonsterHerd::CXMasMonsterHerd
PUBLIC	??_R4CXMasMonsterHerd@@6B@			; CXMasMonsterHerd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCXMasMonsterHerd@@@8			; CXMasMonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3CXMasMonsterHerd@@8			; CXMasMonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXMasMonsterHerd@@8			; CXMasMonsterHerd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CXMasMonsterHerd@@8		; CXMasMonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@MonsterHerd@@8			; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMonsterHerd@@@8				; MonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3MonsterHerd@@8				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MonsterHerd@@8				; MonsterHerd::`RTTI Base Class Array'
PUBLIC	?Start@CXMasMonsterHerd@@UAEHXZ			; CXMasMonsterHerd::Start
PUBLIC	?MonsterHerdItemDrop@CXMasMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ; CXMasMonsterHerd::MonsterHerdItemDrop
EXTRN	??0MonsterHerd@@QAE@XZ:PROC			; MonsterHerd::MonsterHerd
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECXMasMonsterHerd@@UAEPAXI@Z:PROC		; CXMasMonsterHerd::`vector deleting destructor'
EXTRN	?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z:PROC	; MonsterHerd::SetTotalInfo
EXTRN	?AddMonster@MonsterHerd@@UAEHHHH@Z:PROC		; MonsterHerd::AddMonster
EXTRN	?SetRadius@MonsterHerd@@UAEXH@Z:PROC		; MonsterHerd::SetRadius
EXTRN	?SetPosition@MonsterHerd@@UAEXEE@Z:PROC		; MonsterHerd::SetPosition
EXTRN	?Stop@MonsterHerd@@UAEXXZ:PROC			; MonsterHerd::Stop
EXTRN	?CheckInRadius@MonsterHerd@@UAEHH@Z:PROC	; MonsterHerd::CheckInRadius
EXTRN	?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z:PROC ; MonsterHerd::GetCurrentLocation
EXTRN	?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z:PROC	; MonsterHerd::GetRandomLocation
EXTRN	?CheckLocation@MonsterHerd@@UAEHAAE0@Z:PROC	; MonsterHerd::CheckLocation
EXTRN	?MoveHerd@MonsterHerd@@UAEHEE@Z:PROC		; MonsterHerd::MoveHerd
EXTRN	?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z:PROC ; MonsterHerd::GetMonsterData
EXTRN	?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z:PROC ; MonsterHerd::BeenAttacked
EXTRN	?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z:PROC ; MonsterHerd::OrderAttack
EXTRN	?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterBaseAct
EXTRN	?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterMoveAction
EXTRN	?MonsterAttackAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z:PROC ; MonsterHerd::MonsterAttackAction
EXTRN	?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterDieAction
EXTRN	?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterRegenAction
;	COMDAT ??_R2MonsterHerd@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\xmasattackevent.cpp
rdata$r	SEGMENT
??_R2MonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@MonsterHerd@@8 ; MonsterHerd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MonsterHerd@@8
rdata$r	SEGMENT
??_R3MonsterHerd@@8 DD 00H				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMonsterHerd@@@8
_DATA	SEGMENT
??_R0?AVMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; MonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMonsterHerd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@MonsterHerd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MonsterHerd@@8 DD FLAT:??_R0?AVMonsterHerd@@@8 ; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CXMasMonsterHerd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CXMasMonsterHerd@@8 DD FLAT:??_R0?AVCXMasMonsterHerd@@@8 ; CXMasMonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXMasMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R2CXMasMonsterHerd@@8
rdata$r	SEGMENT
??_R2CXMasMonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@CXMasMonsterHerd@@8 ; CXMasMonsterHerd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R3CXMasMonsterHerd@@8
rdata$r	SEGMENT
??_R3CXMasMonsterHerd@@8 DD 00H				; CXMasMonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CXMasMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXMasMonsterHerd@@@8
_DATA	SEGMENT
??_R0?AVCXMasMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; CXMasMonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXMasMonsterHerd@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CXMasMonsterHerd@@6B@
rdata$r	SEGMENT
??_R4CXMasMonsterHerd@@6B@ DD 00H			; CXMasMonsterHerd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCXMasMonsterHerd@@@8
	DD	FLAT:??_R3CXMasMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_7CXMasMonsterHerd@@6B@
CONST	SEGMENT
??_7CXMasMonsterHerd@@6B@ DD FLAT:??_R4CXMasMonsterHerd@@6B@ ; CXMasMonsterHerd::`vftable'
	DD	FLAT:??_ECXMasMonsterHerd@@UAEPAXI@Z
	DD	FLAT:?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z
	DD	FLAT:?AddMonster@MonsterHerd@@UAEHHHH@Z
	DD	FLAT:?SetRadius@MonsterHerd@@UAEXH@Z
	DD	FLAT:?SetPosition@MonsterHerd@@UAEXEE@Z
	DD	FLAT:?Start@CXMasMonsterHerd@@UAEHXZ
	DD	FLAT:?Stop@MonsterHerd@@UAEXXZ
	DD	FLAT:?CheckInRadius@MonsterHerd@@UAEHH@Z
	DD	FLAT:?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?CheckLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?MoveHerd@MonsterHerd@@UAEHEE@Z
	DD	FLAT:?MonsterHerdItemDrop@CXMasMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z
	DD	FLAT:?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z
	DD	FLAT:?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z
	DD	FLAT:?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterAttackAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z
	DD	FLAT:?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CXMasMonsterHerd@@QAE@XZ PROC			; CXMasMonsterHerd::CXMasMonsterHerd
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MonsterHerd@@QAE@XZ	; MonsterHerd::MonsterHerd
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CXMasMonsterHerd@@6B@

; 18   : 	return;
; 19   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0CXMasMonsterHerd@@QAE@XZ ENDP			; CXMasMonsterHerd::CXMasMonsterHerd
_TEXT	ENDS
PUBLIC	??1CXMasMonsterHerd@@UAE@XZ			; CXMasMonsterHerd::~CXMasMonsterHerd
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCXMasMonsterHerd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCXMasMonsterHerd@@UAEPAXI@Z PROC			; CXMasMonsterHerd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CXMasMonsterHerd@@UAE@XZ ; CXMasMonsterHerd::~CXMasMonsterHerd
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCXMasMonsterHerd@@UAEPAXI@Z ENDP			; CXMasMonsterHerd::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1MonsterHerd@@UAE@XZ:PROC			; MonsterHerd::~MonsterHerd
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CXMasMonsterHerd@@UAE@XZ PROC			; CXMasMonsterHerd::~CXMasMonsterHerd
; _this$ = ecx

; 22   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CXMasMonsterHerd@@6B@

; 23   : 	return;
; 24   : }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??1MonsterHerd@@UAE@XZ	; MonsterHerd::~MonsterHerd
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??1CXMasMonsterHerd@@UAE@XZ ENDP			; CXMasMonsterHerd::~CXMasMonsterHerd
_TEXT	ENDS
EXTRN	?Start@MonsterHerd@@UAEHXZ:PROC			; MonsterHerd::Start
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Start@CXMasMonsterHerd@@UAEHXZ PROC			; CXMasMonsterHerd::Start
; _this$ = ecx

; 27   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	83 ec 44	 sub	 esp, 68			; 00000044H
  00066	53		 push	 ebx
  00067	56		 push	 esi
  00068	57		 push	 edi
  00069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 	return this->MonsterHerd::Start();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?Start@MonsterHerd@@UAEHXZ ; MonsterHerd::Start

; 29   : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?Start@CXMasMonsterHerd@@UAEHXZ ENDP			; CXMasMonsterHerd::Start
_TEXT	ENDS
PUBLIC	??_C@_0DE@HBJLJHOD@?$FLXMasAttackEvent?$FN?5White?5Wizard?5K@ ; `string'
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?g_iXMasAttackEventDropZen@@3HA:DWORD		; g_iXMasAttackEventDropZen
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	?g_iXMasAttackEventDropRate@@3HA:DWORD		; g_iXMasAttackEventDropRate
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjGiveRewardBuff@@YAHPAUOBJECTSTRUCT@@HPAHHEHEHH@Z:PROC ; gObjGiveRewardBuff
EXTRN	_rand:PROC
;	COMDAT ??_C@_0DE@HBJLJHOD@?$FLXMasAttackEvent?$FN?5White?5Wizard?5K@
CONST	SEGMENT
??_C@_0DE@HBJLJHOD@?$FLXMasAttackEvent?$FN?5White?5Wizard?5K@ DB '[XMasAt'
	DB	'tackEvent] White Wizard Killed, MapNumber:%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv75 = -96						; size = 4
_itemnumber$231333 = -28				; size = 4
_iIndex$231332 = -24					; size = 4
_iDefense$231324 = -20					; size = 4
_iAttack$231323 = -16					; size = 4
_irandreward$231317 = -12				; size = 4
_count$231316 = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterHerdItemDrop@CXMasMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z PROC ; CXMasMonsterHerd::MonsterHerdItemDrop
; _this$ = ecx

; 32   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 60	 sub	 esp, 96			; 00000060H
  00086	53		 push	 ebx
  00087	56		 push	 esi
  00088	57		 push	 edi
  00089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	if ( lpObj->Class != 476 && lpObj->Class != 466 )

  0008c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00096	81 f9 dc 01 00
	00		 cmp	 ecx, 476		; 000001dcH
  0009c	74 19		 je	 SHORT $LN11@MonsterHer
  0009e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a1	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  000a8	81 f9 d2 01 00
	00		 cmp	 ecx, 466		; 000001d2H
  000ae	74 07		 je	 SHORT $LN11@MonsterHer

; 34   : 	{
; 35   : 		return FALSE;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 1c 02 00 00	 jmp	 $LN12@MonsterHer
$LN11@MonsterHer:

; 36   : 	}
; 37   : 
; 38   : 	if ( lpObj->Class == 476 )

  000b7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  000c1	81 f9 dc 01 00
	00		 cmp	 ecx, 476		; 000001dcH
  000c7	0f 85 30 01 00
	00		 jne	 $LN10@MonsterHer

; 39   : 	{
; 40   : 		int count = 0;

  000cd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$231316[ebp], 0

; 41   : 
; 42   : 		int irandreward = rand()%3; //loc3

  000d4	e8 00 00 00 00	 call	 _rand
  000d9	99		 cdq
  000da	b9 03 00 00 00	 mov	 ecx, 3
  000df	f7 f9		 idiv	 ecx
  000e1	89 55 f4	 mov	 DWORD PTR _irandreward$231317[ebp], edx

; 43   : 
; 44   : 		switch(irandreward)

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _irandreward$231317[ebp]
  000e7	89 45 a0	 mov	 DWORD PTR tv75[ebp], eax
  000ea	83 7d a0 00	 cmp	 DWORD PTR tv75[ebp], 0
  000ee	74 19		 je	 SHORT $LN7@MonsterHer
  000f0	83 7d a0 01	 cmp	 DWORD PTR tv75[ebp], 1
  000f4	0f 84 96 00 00
	00		 je	 $LN4@MonsterHer
  000fa	83 7d a0 02	 cmp	 DWORD PTR tv75[ebp], 2
  000fe	0f 84 b2 00 00
	00		 je	 $LN3@MonsterHer
  00104	e9 d1 00 00 00	 jmp	 $LN8@MonsterHer
$LN7@MonsterHer:

; 45   : 		{
; 46   : 		case 0:
; 47   : 			{
; 48   : 				int iAttack = 0; //4

  00109	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iAttack$231323[ebp], 0

; 49   : 				int iDefense = 0; //5

  00110	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iDefense$231324[ebp], 0

; 50   : 
; 51   : 				if(lpObj->Level <= 180)

  00117	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011a	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00121	81 f9 b4 00 00
	00		 cmp	 ecx, 180		; 000000b4H
  00127	7f 32		 jg	 SHORT $LN6@MonsterHer

; 52   : 				{
; 53   : 					iAttack = lpObj->Level / 3 + 45;

  00129	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012c	0f bf 80 be 00
	00 00		 movsx	 eax, WORD PTR [eax+190]
  00133	99		 cdq
  00134	b9 03 00 00 00	 mov	 ecx, 3
  00139	f7 f9		 idiv	 ecx
  0013b	83 c0 2d	 add	 eax, 45			; 0000002dH
  0013e	89 45 f0	 mov	 DWORD PTR _iAttack$231323[ebp], eax

; 54   : 					iDefense = lpObj->Level / 5 + 50;

  00141	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00144	0f bf 80 be 00
	00 00		 movsx	 eax, WORD PTR [eax+190]
  0014b	99		 cdq
  0014c	b9 05 00 00 00	 mov	 ecx, 5
  00151	f7 f9		 idiv	 ecx
  00153	83 c0 32	 add	 eax, 50			; 00000032H
  00156	89 45 ec	 mov	 DWORD PTR _iDefense$231324[ebp], eax

; 55   : 				}
; 56   : 				else

  00159	eb 0e		 jmp	 SHORT $LN5@MonsterHer
$LN6@MonsterHer:

; 57   : 				{
; 58   : 					iAttack = 105;

  0015b	c7 45 f0 69 00
	00 00		 mov	 DWORD PTR _iAttack$231323[ebp], 105 ; 00000069H

; 59   : 					iDefense = 86;

  00162	c7 45 ec 56 00
	00 00		 mov	 DWORD PTR _iDefense$231324[ebp], 86 ; 00000056H
$LN5@MonsterHer:

; 60   : 				}
; 61   : 
; 62   : 				gObjGiveRewardBuff(lpObj, 10, &count, AT_XMASS_REWARD, 2, iAttack, 3, iDefense, 1800);

  00169	68 08 07 00 00	 push	 1800			; 00000708H
  0016e	8b 45 ec	 mov	 eax, DWORD PTR _iDefense$231324[ebp]
  00171	50		 push	 eax
  00172	6a 03		 push	 3
  00174	8b 4d f0	 mov	 ecx, DWORD PTR _iAttack$231323[ebp]
  00177	51		 push	 ecx
  00178	6a 02		 push	 2
  0017a	6a 5b		 push	 91			; 0000005bH
  0017c	8d 55 f8	 lea	 edx, DWORD PTR _count$231316[ebp]
  0017f	52		 push	 edx
  00180	6a 0a		 push	 10			; 0000000aH
  00182	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?gObjGiveRewardBuff@@YAHPAUOBJECTSTRUCT@@HPAHHEHEHH@Z ; gObjGiveRewardBuff
  0018b	83 c4 24	 add	 esp, 36			; 00000024H

; 63   : 			}
; 64   : 			break;

  0018e	eb 4a		 jmp	 SHORT $LN8@MonsterHer
$LN4@MonsterHer:

; 65   : 		case 1:
; 66   : 			gObjGiveRewardBuff(lpObj, 10, &count, AT_XMASS_HEALTH, 4, 500, 0, 0, 1800);

  00190	68 08 07 00 00	 push	 1800			; 00000708H
  00195	6a 00		 push	 0
  00197	6a 00		 push	 0
  00199	68 f4 01 00 00	 push	 500			; 000001f4H
  0019e	6a 04		 push	 4
  001a0	6a 5c		 push	 92			; 0000005cH
  001a2	8d 45 f8	 lea	 eax, DWORD PTR _count$231316[ebp]
  001a5	50		 push	 eax
  001a6	6a 0a		 push	 10			; 0000000aH
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 ?gObjGiveRewardBuff@@YAHPAUOBJECTSTRUCT@@HPAHHEHEHH@Z ; gObjGiveRewardBuff
  001b1	83 c4 24	 add	 esp, 36			; 00000024H

; 67   : 			break;

  001b4	eb 24		 jmp	 SHORT $LN8@MonsterHer
$LN3@MonsterHer:

; 68   : 		case 2:
; 69   : 			gObjGiveRewardBuff(lpObj, 10, &count, AT_XMASS_MANA, 5, 500, 0, 0, 1800);

  001b6	68 08 07 00 00	 push	 1800			; 00000708H
  001bb	6a 00		 push	 0
  001bd	6a 00		 push	 0
  001bf	68 f4 01 00 00	 push	 500			; 000001f4H
  001c4	6a 05		 push	 5
  001c6	6a 5d		 push	 93			; 0000005dH
  001c8	8d 45 f8	 lea	 eax, DWORD PTR _count$231316[ebp]
  001cb	50		 push	 eax
  001cc	6a 0a		 push	 10			; 0000000aH
  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d1	51		 push	 ecx
  001d2	e8 00 00 00 00	 call	 ?gObjGiveRewardBuff@@YAHPAUOBJECTSTRUCT@@HPAHHEHEHH@Z ; gObjGiveRewardBuff
  001d7	83 c4 24	 add	 esp, 36			; 00000024H
$LN8@MonsterHer:

; 70   : 			break;
; 71   : 		};
; 72   : 
; 73   : 		LogAddTD("[XMasAttackEvent] White Wizard Killed, MapNumber:%d", lpObj->MapNumber);

  001da	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001dd	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  001e4	51		 push	 ecx
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HBJLJHOD@?$FLXMasAttackEvent?$FN?5White?5Wizard?5K@
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001f0	83 c4 08	 add	 esp, 8

; 74   : 		return TRUE;

  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	e9 d6 00 00 00	 jmp	 $LN12@MonsterHer
$LN10@MonsterHer:

; 75   : 	}
; 76   : 	
; 77   : 	if ( lpObj->Class == 466 )

  001fd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00200	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00207	81 f9 d2 01 00
	00		 cmp	 ecx, 466		; 000001d2H
  0020d	0f 85 be 00 00
	00		 jne	 $LN2@MonsterHer

; 78   : 	{
; 79   : 		if ( (rand()%100) < g_iXMasAttackEventDropRate )

  00213	e8 00 00 00 00	 call	 _rand
  00218	99		 cdq
  00219	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021e	f7 f9		 idiv	 ecx
  00220	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iXMasAttackEventDropRate@@3HA ; g_iXMasAttackEventDropRate
  00226	7d 6a		 jge	 SHORT $LN1@MonsterHer

; 80   : 		{
; 81   : 			int iIndex = gObjMonsterTopHitDamageUser(lpObj);

  00228	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00231	83 c4 04	 add	 esp, 4
  00234	89 45 e8	 mov	 DWORD PTR _iIndex$231332[ebp], eax

; 82   : 			int itemnumber = ItemGetNumberMake(13, 66);

  00237	6a 42		 push	 66			; 00000042H
  00239	6a 0d		 push	 13			; 0000000dH
  0023b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00240	83 c4 08	 add	 esp, 8
  00243	89 45 e4	 mov	 DWORD PTR _itemnumber$231333[ebp], eax

; 83   : 
; 84   : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, itemnumber, 0, 10, 0, 0, 0, iIndex, 0, 0);

  00246	6a 00		 push	 0
  00248	6a 00		 push	 0
  0024a	8b 45 e8	 mov	 eax, DWORD PTR _iIndex$231332[ebp]
  0024d	50		 push	 eax
  0024e	6a 00		 push	 0
  00250	6a 00		 push	 0
  00252	6a 00		 push	 0
  00254	6a 0a		 push	 10			; 0000000aH
  00256	6a 00		 push	 0
  00258	8b 4d e4	 mov	 ecx, DWORD PTR _itemnumber$231333[ebp]
  0025b	51		 push	 ecx
  0025c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0025f	0f b6 82 46 01
	00 00		 movzx	 eax, BYTE PTR [edx+326]
  00266	50		 push	 eax
  00267	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026a	0f b6 91 44 01
	00 00		 movzx	 edx, BYTE PTR [ecx+324]
  00271	52		 push	 edx
  00272	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00275	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0027c	51		 push	 ecx
  0027d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00280	8b 02		 mov	 eax, DWORD PTR [edx]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00288	83 c4 34	 add	 esp, 52			; 00000034H

; 85   : 			return TRUE;

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	eb 41		 jmp	 SHORT $LN12@MonsterHer
$LN1@MonsterHer:

; 86   : 		}
; 87   : 
; 88   : 		MapC[lpObj->MapNumber].MoneyItemDrop(g_iXMasAttackEventDropZen, (BYTE)lpObj->X, (BYTE)lpObj->Y);

  00292	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00295	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  0029c	51		 push	 ecx
  0029d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002a0	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  002a7	50		 push	 eax
  002a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iXMasAttackEventDropZen@@3HA ; g_iXMasAttackEventDropZen
  002ae	51		 push	 ecx
  002af	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b2	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  002b9	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  002bf	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  002c5	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 89   : 		return TRUE;

  002ca	b8 01 00 00 00	 mov	 eax, 1
  002cf	eb 02		 jmp	 SHORT $LN12@MonsterHer
$LN2@MonsterHer:

; 90   : 	}
; 91   : 
; 92   : 	return FALSE;

  002d1	33 c0		 xor	 eax, eax
$LN12@MonsterHer:

; 93   : 
; 94   : }

  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx
  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c2 04 00	 ret	 4
?MonsterHerdItemDrop@CXMasMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ENDP ; CXMasMonsterHerd::MonsterHerdItemDrop
_TEXT	ENDS
PUBLIC	??0?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
PUBLIC	??_7CXMasAttackEvent@@6B@			; CXMasAttackEvent::`vftable'
PUBLIC	??0CXMasAttackEvent@@QAE@XZ			; CXMasAttackEvent::CXMasAttackEvent
PUBLIC	??_R4CXMasAttackEvent@@6B@			; CXMasAttackEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCXMasAttackEvent@@@8			; CXMasAttackEvent `RTTI Type Descriptor'
PUBLIC	??_R3CXMasAttackEvent@@8			; CXMasAttackEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXMasAttackEvent@@8			; CXMasAttackEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CXMasAttackEvent@@8		; CXMasAttackEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CXMasAttackEventData@@8		; CXMasAttackEventData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCXMasAttackEventData@@@8		; CXMasAttackEventData `RTTI Type Descriptor'
PUBLIC	??_R3CXMasAttackEventData@@8			; CXMasAttackEventData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXMasAttackEventData@@8			; CXMasAttackEventData::`RTTI Base Class Array'
PUBLIC	?Load@CXMasAttackEvent@@UAEHPAD@Z		; CXMasAttackEvent::Load
PUBLIC	?StartEvent@CXMasAttackEvent@@UAEXXZ		; CXMasAttackEvent::StartEvent
PUBLIC	?StopEvent@CXMasAttackEvent@@UAEXXZ		; CXMasAttackEvent::StopEvent
PUBLIC	?End_Menual@CXMasAttackEvent@@UAEXXZ		; CXMasAttackEvent::End_Menual
PUBLIC	?Start_Menual@CXMasAttackEvent@@UAEXXZ		; CXMasAttackEvent::Start_Menual
EXTRN	??1CXMasAttackEventData@@UAE@XZ:PROC		; CXMasAttackEventData::~CXMasAttackEventData
EXTRN	??0CXMasAttackEventData@@QAE@XZ:PROC		; CXMasAttackEventData::CXMasAttackEventData
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_ECXMasAttackEvent@@UAEPAXI@Z:PROC		; CXMasAttackEvent::`vector deleting destructor'
EXTRN	?SetMenualStart@CXMasAttackEvent@@UAEXH@Z:PROC	; CXMasAttackEvent::SetMenualStart
;	COMDAT ??_R2CXMasAttackEventData@@8
rdata$r	SEGMENT
??_R2CXMasAttackEventData@@8 DD FLAT:??_R1A@?0A@EA@CXMasAttackEventData@@8 ; CXMasAttackEventData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CXMasAttackEventData@@8
rdata$r	SEGMENT
??_R3CXMasAttackEventData@@8 DD 00H			; CXMasAttackEventData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CXMasAttackEventData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXMasAttackEventData@@@8
_DATA	SEGMENT
??_R0?AVCXMasAttackEventData@@@8 DD FLAT:??_7type_info@@6B@ ; CXMasAttackEventData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXMasAttackEventData@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CXMasAttackEventData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CXMasAttackEventData@@8 DD FLAT:??_R0?AVCXMasAttackEventData@@@8 ; CXMasAttackEventData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXMasAttackEventData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CXMasAttackEvent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CXMasAttackEvent@@8 DD FLAT:??_R0?AVCXMasAttackEvent@@@8 ; CXMasAttackEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXMasAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CXMasAttackEvent@@8
rdata$r	SEGMENT
??_R2CXMasAttackEvent@@8 DD FLAT:??_R1A@?0A@EA@CXMasAttackEvent@@8 ; CXMasAttackEvent::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CXMasAttackEventData@@8
rdata$r	ENDS
;	COMDAT ??_R3CXMasAttackEvent@@8
rdata$r	SEGMENT
??_R3CXMasAttackEvent@@8 DD 00H				; CXMasAttackEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CXMasAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXMasAttackEvent@@@8
_DATA	SEGMENT
??_R0?AVCXMasAttackEvent@@@8 DD FLAT:??_7type_info@@6B@	; CXMasAttackEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXMasAttackEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CXMasAttackEvent@@6B@
rdata$r	SEGMENT
??_R4CXMasAttackEvent@@6B@ DD 00H			; CXMasAttackEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCXMasAttackEvent@@@8
	DD	FLAT:??_R3CXMasAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_7CXMasAttackEvent@@6B@
CONST	SEGMENT
??_7CXMasAttackEvent@@6B@ DD FLAT:??_R4CXMasAttackEvent@@6B@ ; CXMasAttackEvent::`vftable'
	DD	FLAT:??_ECXMasAttackEvent@@UAEPAXI@Z
	DD	FLAT:?Load@CXMasAttackEvent@@UAEHPAD@Z
	DD	FLAT:?StartEvent@CXMasAttackEvent@@UAEXXZ
	DD	FLAT:?StopEvent@CXMasAttackEvent@@UAEXXZ
	DD	FLAT:?End_Menual@CXMasAttackEvent@@UAEXXZ
	DD	FLAT:?SetMenualStart@CXMasAttackEvent@@UAEXH@Z
	DD	FLAT:?Start_Menual@CXMasAttackEvent@@UAEXXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CXMasAttackEvent@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CXMasAttackEvent@@QAE@XZ$0
__ehfuncinfo$??0CXMasAttackEvent@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CXMasAttackEvent@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CXMasAttackEvent@@QAE@XZ PROC			; CXMasAttackEvent::CXMasAttackEvent
; _this$ = ecx

; 107  : {

  002e0	55		 push	 ebp
  002e1	8b ec		 mov	 ebp, esp
  002e3	6a ff		 push	 -1
  002e5	68 00 00 00 00	 push	 __ehhandler$??0CXMasAttackEvent@@QAE@XZ
  002ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  002f0	50		 push	 eax
  002f1	83 ec 44	 sub	 esp, 68			; 00000044H
  002f4	53		 push	 ebx
  002f5	56		 push	 esi
  002f6	57		 push	 edi
  002f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  002fc	33 c5		 xor	 eax, ebp
  002fe	50		 push	 eax
  002ff	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00302	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00308	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0030b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0030e	e8 00 00 00 00	 call	 ??0CXMasAttackEventData@@QAE@XZ ; CXMasAttackEventData::CXMasAttackEventData
  00313	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0031a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0031d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CXMasAttackEvent@@6B@
  00323	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00329	e8 00 00 00 00	 call	 ??0?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
  0032e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00331	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
  00338	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0033b	c7 40 74 0f 00
	00 00		 mov	 DWORD PTR [eax+116], 15	; 0000000fH
  00342	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00345	c7 40 78 03 00
	00 00		 mov	 DWORD PTR [eax+120], 3
  0034c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0034f	c7 40 7c 06 00
	00 00		 mov	 DWORD PTR [eax+124], 6
  00356	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00359	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+128], 0
  00363	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00366	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], 0
  00370	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00373	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], 0
  0037d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00380	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], 0
  0038a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0038d	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0

; 108  : }

  00397	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0039e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  003a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003ab	59		 pop	 ecx
  003ac	5f		 pop	 edi
  003ad	5e		 pop	 esi
  003ae	5b		 pop	 ebx
  003af	8b e5		 mov	 esp, ebp
  003b1	5d		 pop	 ebp
  003b2	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CXMasAttackEvent@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CXMasAttackEventData@@UAE@XZ ; CXMasAttackEventData::~CXMasAttackEventData
__ehhandler$??0CXMasAttackEvent@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CXMasAttackEvent@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CXMasAttackEvent@@QAE@XZ ENDP			; CXMasAttackEvent::CXMasAttackEvent
PUBLIC	??1CXMasAttackEvent@@UAE@XZ			; CXMasAttackEvent::~CXMasAttackEvent
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCXMasAttackEvent@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCXMasAttackEvent@@UAEPAXI@Z PROC			; CXMasAttackEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CXMasAttackEvent@@UAE@XZ ; CXMasAttackEvent::~CXMasAttackEvent
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCXMasAttackEvent@@UAEPAXI@Z ENDP			; CXMasAttackEvent::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
PUBLIC	?ClearMonsterHerd@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::ClearMonsterHerd
xdata$x	SEGMENT
__unwindtable$??1CXMasAttackEvent@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CXMasAttackEvent@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CXMasAttackEvent@@UAE@XZ$1
__ehfuncinfo$??1CXMasAttackEvent@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CXMasAttackEvent@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CXMasAttackEvent@@UAE@XZ PROC			; CXMasAttackEvent::~CXMasAttackEvent
; _this$ = ecx

; 112  : {

  003c0	55		 push	 ebp
  003c1	8b ec		 mov	 ebp, esp
  003c3	6a ff		 push	 -1
  003c5	68 00 00 00 00	 push	 __ehhandler$??1CXMasAttackEvent@@UAE@XZ
  003ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  003d0	50		 push	 eax
  003d1	83 ec 44	 sub	 esp, 68			; 00000044H
  003d4	53		 push	 ebx
  003d5	56		 push	 esi
  003d6	57		 push	 edi
  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  003dc	33 c5		 xor	 eax, ebp
  003de	50		 push	 eax
  003df	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  003e2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  003e8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  003eb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  003ee	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CXMasAttackEvent@@6B@
  003f4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 113  : 	this->ClearMonsterHerd();

  003fb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003fe	e8 00 00 00 00	 call	 ?ClearMonsterHerd@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::ClearMonsterHerd

; 114  : }

  00403	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00407	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0040a	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0040d	e8 00 00 00 00	 call	 ??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
  00412	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00419	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0041c	e8 00 00 00 00	 call	 ??1CXMasAttackEventData@@UAE@XZ ; CXMasAttackEventData::~CXMasAttackEventData
  00421	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00424	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0042b	59		 pop	 ecx
  0042c	5f		 pop	 edi
  0042d	5e		 pop	 esi
  0042e	5b		 pop	 ebx
  0042f	8b e5		 mov	 esp, ebp
  00431	5d		 pop	 ebp
  00432	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CXMasAttackEvent@@UAE@XZ$0:
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1CXMasAttackEventData@@UAE@XZ ; CXMasAttackEventData::~CXMasAttackEventData
__unwindfunclet$??1CXMasAttackEvent@@UAE@XZ$1:
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00031	e9 00 00 00 00	 jmp	 ??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
__ehhandler$??1CXMasAttackEvent@@UAE@XZ:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CXMasAttackEvent@@UAE@XZ
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CXMasAttackEvent@@UAE@XZ ENDP			; CXMasAttackEvent::~CXMasAttackEvent
PUBLIC	??_C@_0CC@PEGBMCF@?$FLXMasAttackEvent?$FN?5?9?5?$CFs?5file?5load@ ; `string'
PUBLIC	?push_back@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXABUXMASMONSTER_MAP_INFO@@@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::push_back
PUBLIC	?push_back@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXABUXMASMONSTER_EVENT_TIME@@@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::push_back
PUBLIC	?push_back@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXABUXMASMONSTER_DATA@@@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::push_back
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CL@CKPDAKHI@?$FLXMasAttackEvent?$FN?5Info?5file?5Load@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	_strcmp:PROC
EXTRN	?Clear@CXMasAttackEventData@@QAEXXZ:PROC	; CXMasAttackEventData::Clear
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CC@PEGBMCF@?$FLXMasAttackEvent?$FN?5?9?5?$CFs?5file?5load@
CONST	SEGMENT
??_C@_0CC@PEGBMCF@?$FLXMasAttackEvent?$FN?5?9?5?$CFs?5file?5load@ DB '[XM'
	DB	'asAttackEvent] - %s file load!', 00H	; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CKPDAKHI@?$FLXMasAttackEvent?$FN?5Info?5file?5Load@
CONST	SEGMENT
??_C@_0CL@CKPDAKHI@?$FLXMasAttackEvent?$FN?5Info?5file?5Load@ DB '[XMasAt'
	DB	'tackEvent] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv321 = -132						; size = 4
tv319 = -128						; size = 4
tv316 = -122						; size = 2
tv158 = -121						; size = 1
tv153 = -121						; size = 1
_pXMP$231394 = -56					; size = 20
_pXET$231388 = -36					; size = 8
_pXMD$231381 = -28					; size = 12
_type$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszFileName$ = 8					; size = 4
?Load@CXMasAttackEvent@@UAEHPAD@Z PROC			; CXMasAttackEvent::Load
; _this$ = ecx

; 117  : {

  00440	55		 push	 ebp
  00441	8b ec		 mov	 ebp, esp
  00443	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00449	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0044e	33 c5		 xor	 eax, ebp
  00450	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00453	53		 push	 ebx
  00454	56		 push	 esi
  00455	57		 push	 edi
  00456	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	SMDFile = fopen(lpszFileName, "r");

  00459	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0045e	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00461	50		 push	 eax
  00462	e8 00 00 00 00	 call	 _fopen
  00467	83 c4 08	 add	 esp, 8
  0046a	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 119  : 
; 120  : 	if ( SMDFile == NULL )

  0046f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00476	75 18		 jne	 SHORT $LN20@Load

; 121  : 	{
; 122  : 		MsgBox("[XMasAttackEvent] Info file Load Fail [%s]", lpszFileName);

  00478	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0047b	50		 push	 eax
  0047c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CKPDAKHI@?$FLXMasAttackEvent?$FN?5Info?5file?5Load@
  00481	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00486	83 c4 08	 add	 esp, 8

; 123  : 		return FALSE;

  00489	33 c0		 xor	 eax, eax
  0048b	e9 60 03 00 00	 jmp	 $LN21@Load
$LN20@Load:

; 124  : 	}
; 125  : 
; 126  : 	this->Clear();

  00490	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00493	e8 00 00 00 00	 call	 ?Clear@CXMasAttackEventData@@QAEXXZ ; CXMasAttackEventData::Clear

; 127  : 
; 128  : 	int Token;
; 129  : 	int type = -1;

  00498	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN19@Load:

; 130  : 
; 131  : 	while ( true )

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	85 c0		 test	 eax, eax
  004a6	0f 84 15 03 00
	00		 je	 $LN18@Load

; 132  : 	{
; 133  : 		Token = GetToken();

  004ac	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004b1	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 134  : 
; 135  : 		if ( Token == 2 )

  004b4	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  004b8	75 05		 jne	 SHORT $LN17@Load

; 136  : 		{
; 137  : 			break;

  004ba	e9 02 03 00 00	 jmp	 $LN18@Load
$LN17@Load:

; 138  : 		}
; 139  : 
; 140  : 		type = (int)TokenNumber;

  004bf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004c5	e8 00 00 00 00	 call	 __ftol2_sse
  004ca	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax
$LN16@Load:

; 141  : 
; 142  : 		while ( true )

  004cd	b8 01 00 00 00	 mov	 eax, 1
  004d2	85 c0		 test	 eax, eax
  004d4	0f 84 e2 02 00
	00		 je	 $LN15@Load

; 143  : 		{
; 144  : 			if ( type == 0 )

  004da	83 7d f0 00	 cmp	 DWORD PTR _type$[ebp], 0
  004de	0f 85 86 00 00
	00		 jne	 $LN14@Load

; 145  : 			{
; 146  : 				Token = GetToken();

  004e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004e9	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 147  : 
; 148  : 				if ( strcmp("end", TokenString) == 0 )

  004ec	68 00 00 00 00	 push	 OFFSET _TokenString
  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  004f6	e8 00 00 00 00	 call	 _strcmp
  004fb	83 c4 08	 add	 esp, 8
  004fe	85 c0		 test	 eax, eax
  00500	75 05		 jne	 SHORT $LN13@Load

; 149  : 				{
; 150  : 					break;

  00502	e9 b5 02 00 00	 jmp	 $LN15@Load
$LN13@Load:

; 151  : 				}
; 152  : 
; 153  : 				this->m_iTIME_MIN_OPEN = (int)TokenNumber * 60000; //80

  00507	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0050d	e8 00 00 00 00	 call	 __ftol2_sse
  00512	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00518	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0051b	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 154  : 
; 155  : 				Token = GetToken();

  00521	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00526	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 156  : 				this->m_iTIME_MIN_PLAY = (int)TokenNumber * 60000; //84

  00529	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0052f	e8 00 00 00 00	 call	 __ftol2_sse
  00534	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  0053a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0053d	89 81 84 00 00
	00		 mov	 DWORD PTR [ecx+132], eax

; 157  : 
; 158  : 				Token = GetToken();

  00543	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00548	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 159  : 				this->m_iTIME_MONSTER_TO_DEST = (int)TokenNumber * 60000; //88

  0054b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00551	e8 00 00 00 00	 call	 __ftol2_sse
  00556	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  0055c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0055f	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax
  00565	e9 4d 02 00 00	 jmp	 $LN2@Load
$LN14@Load:

; 160  : 			}
; 161  : 			else if ( type == 1 )

  0056a	83 7d f0 01	 cmp	 DWORD PTR _type$[ebp], 1
  0056e	75 6b		 jne	 SHORT $LN11@Load

; 162  : 			{
; 163  : 				Token = GetToken();

  00570	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00575	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 164  : 
; 165  : 				if ( strcmp("end", TokenString) == 0 )

  00578	68 00 00 00 00	 push	 OFFSET _TokenString
  0057d	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00582	e8 00 00 00 00	 call	 _strcmp
  00587	83 c4 08	 add	 esp, 8
  0058a	85 c0		 test	 eax, eax
  0058c	75 05		 jne	 SHORT $LN10@Load

; 166  : 				{
; 167  : 					break;

  0058e	e9 29 02 00 00	 jmp	 $LN15@Load
$LN10@Load:

; 168  : 				}
; 169  : 
; 170  : 				this->m_iMOVE_RAND_SIZE = (int)TokenNumber;

  00593	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00599	e8 00 00 00 00	 call	 __ftol2_sse
  0059e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005a1	89 41 74	 mov	 DWORD PTR [ecx+116], eax

; 171  : 
; 172  : 				Token = GetToken();

  005a4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005a9	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 173  : 				this->m_iRADIUS_MIN = (int)TokenNumber;

  005ac	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005b2	e8 00 00 00 00	 call	 __ftol2_sse
  005b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005ba	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 174  : 
; 175  : 				Token = GetToken();

  005bd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005c2	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 176  : 				this->m_iRADIUS_MAX = (int)TokenNumber;

  005c5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005cb	e8 00 00 00 00	 call	 __ftol2_sse
  005d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005d3	89 41 7c	 mov	 DWORD PTR [ecx+124], eax
  005d6	e9 dc 01 00 00	 jmp	 $LN2@Load
$LN11@Load:

; 177  : 			}
; 178  : 			else if ( type == 2 )

  005db	83 7d f0 02	 cmp	 DWORD PTR _type$[ebp], 2
  005df	0f 85 b3 00 00
	00		 jne	 $LN8@Load

; 179  : 			{
; 180  : 				Token = GetToken();

  005e5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005ea	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 181  : 
; 182  : 				if ( strcmp("end", TokenString) == 0 )

  005ed	68 00 00 00 00	 push	 OFFSET _TokenString
  005f2	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  005f7	e8 00 00 00 00	 call	 _strcmp
  005fc	83 c4 08	 add	 esp, 8
  005ff	85 c0		 test	 eax, eax
  00601	75 05		 jne	 SHORT $LN7@Load

; 183  : 				{
; 184  : 					break;

  00603	e9 b4 01 00 00	 jmp	 $LN15@Load
$LN7@Load:

; 185  : 				}
; 186  : 
; 187  : 				XMASMONSTER_DATA pXMD;
; 188  : 
; 189  : 				pXMD.m_iType = (int)TokenNumber;

  00608	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0060e	e8 00 00 00 00	 call	 __ftol2_sse
  00613	89 45 e4	 mov	 DWORD PTR _pXMD$231381[ebp], eax

; 190  : 
; 191  : 				Token = GetToken();

  00616	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0061b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 192  : 				pXMD.m_bDoRegen = (bool)TokenNumber;

  0061e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00624	d9 ee		 fldz
  00626	da e9		 fucompp
  00628	df e0		 fnstsw	 ax
  0062a	f6 c4 44	 test	 ah, 68			; 00000044H
  0062d	7b 06		 jnp	 SHORT $LN23@Load
  0062f	c6 45 87 01	 mov	 BYTE PTR tv153[ebp], 1
  00633	eb 04		 jmp	 SHORT $LN24@Load
$LN23@Load:
  00635	c6 45 87 00	 mov	 BYTE PTR tv153[ebp], 0
$LN24@Load:
  00639	0f b6 45 87	 movzx	 eax, BYTE PTR tv153[ebp]
  0063d	89 45 e8	 mov	 DWORD PTR _pXMD$231381[ebp+4], eax

; 193  : 
; 194  : 				Token= GetToken();

  00640	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00645	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 195  : 				pXMD.m_bDoAttackFirst = (bool)TokenNumber;

  00648	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0064e	d9 ee		 fldz
  00650	da e9		 fucompp
  00652	df e0		 fnstsw	 ax
  00654	f6 c4 44	 test	 ah, 68			; 00000044H
  00657	7b 06		 jnp	 SHORT $LN25@Load
  00659	c6 45 87 01	 mov	 BYTE PTR tv158[ebp], 1
  0065d	eb 04		 jmp	 SHORT $LN26@Load
$LN25@Load:
  0065f	c6 45 87 00	 mov	 BYTE PTR tv158[ebp], 0
$LN26@Load:
  00663	0f b6 45 87	 movzx	 eax, BYTE PTR tv158[ebp]
  00667	89 45 ec	 mov	 DWORD PTR _pXMD$231381[ebp+8], eax

; 196  : 
; 197  : 				EnterCriticalSection(&this->m_critMonsterAddData);

  0066a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0066d	83 c0 10	 add	 eax, 16			; 00000010H
  00670	50		 push	 eax
  00671	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 198  : 				this->m_vtMonsterAddData.push_back(pXMD);

  00677	8d 45 e4	 lea	 eax, DWORD PTR _pXMD$231381[ebp]
  0067a	50		 push	 eax
  0067b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0067e	83 c1 38	 add	 ecx, 56			; 00000038H
  00681	e8 00 00 00 00	 call	 ?push_back@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXABUXMASMONSTER_DATA@@@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::push_back

; 199  : 				LeaveCriticalSection(&this->m_critMonsterAddData);

  00686	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00689	83 c0 10	 add	 eax, 16			; 00000010H
  0068c	50		 push	 eax
  0068d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00693	e9 1f 01 00 00	 jmp	 $LN2@Load
$LN8@Load:

; 200  : 			}
; 201  : 			else if ( type == 3 )

  00698	83 7d f0 03	 cmp	 DWORD PTR _type$[ebp], 3
  0069c	75 5b		 jne	 SHORT $LN5@Load

; 202  : 			{
; 203  : 				Token = GetToken();

  0069e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006a3	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 204  : 
; 205  : 				if ( strcmp("end", TokenString) == 0 )

  006a6	68 00 00 00 00	 push	 OFFSET _TokenString
  006ab	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  006b0	e8 00 00 00 00	 call	 _strcmp
  006b5	83 c4 08	 add	 esp, 8
  006b8	85 c0		 test	 eax, eax
  006ba	75 05		 jne	 SHORT $LN4@Load

; 206  : 				{
; 207  : 					break;

  006bc	e9 fb 00 00 00	 jmp	 $LN15@Load
$LN4@Load:

; 208  : 				}
; 209  : 
; 210  : 				XMASMONSTER_EVENT_TIME pXET;
; 211  : 
; 212  : 				pXET.m_iHour = (int)TokenNumber;

  006c1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006c7	e8 00 00 00 00	 call	 __ftol2_sse
  006cc	89 45 dc	 mov	 DWORD PTR _pXET$231388[ebp], eax

; 213  : 
; 214  : 				Token = GetToken();

  006cf	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006d4	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 215  : 				pXET.m_iMinute = (int)TokenNumber;

  006d7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006dd	e8 00 00 00 00	 call	 __ftol2_sse
  006e2	89 45 e0	 mov	 DWORD PTR _pXET$231388[ebp+4], eax

; 216  : 
; 217  : 				this->m_vtEventTime.push_back(pXET);

  006e5	8d 45 dc	 lea	 eax, DWORD PTR _pXET$231388[ebp]
  006e8	50		 push	 eax
  006e9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006ec	83 c1 28	 add	 ecx, 40			; 00000028H
  006ef	e8 00 00 00 00	 call	 ?push_back@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXABUXMASMONSTER_EVENT_TIME@@@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::push_back
  006f4	e9 be 00 00 00	 jmp	 $LN2@Load
$LN5@Load:

; 218  : 			}
; 219  : 			else if ( type == 4 )

  006f9	83 7d f0 04	 cmp	 DWORD PTR _type$[ebp], 4
  006fd	0f 85 b4 00 00
	00		 jne	 $LN2@Load

; 220  : 			{
; 221  : 				Token = GetToken();

  00703	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00708	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 222  : 
; 223  : 				if ( strcmp("end", TokenString) == 0 )

  0070b	68 00 00 00 00	 push	 OFFSET _TokenString
  00710	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00715	e8 00 00 00 00	 call	 _strcmp
  0071a	83 c4 08	 add	 esp, 8
  0071d	85 c0		 test	 eax, eax
  0071f	75 05		 jne	 SHORT $LN1@Load

; 224  : 				{
; 225  : 					break;

  00721	e9 96 00 00 00	 jmp	 $LN15@Load
$LN1@Load:

; 226  : 				}
; 227  : 
; 228  : 				XMASMONSTER_MAP_INFO pXMP;
; 229  : 
; 230  : 				pXMP.m_btMapNumber = (BYTE)TokenNumber;

  00726	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0072c	d9 7d 86	 fnstcw	 WORD PTR tv316[ebp]
  0072f	0f b7 45 86	 movzx	 eax, WORD PTR tv316[ebp]
  00733	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00738	89 45 80	 mov	 DWORD PTR tv319[ebp], eax
  0073b	d9 6d 80	 fldcw	 WORD PTR tv319[ebp]
  0073e	db 9d 7c ff ff
	ff		 fistp	 DWORD PTR tv321[ebp]
  00744	d9 6d 86	 fldcw	 WORD PTR tv316[ebp]
  00747	8a 85 7c ff ff
	ff		 mov	 al, BYTE PTR tv321[ebp]
  0074d	88 45 c8	 mov	 BYTE PTR _pXMP$231394[ebp], al

; 231  : 
; 232  : 				Token = GetToken();

  00750	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00755	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 233  : 				pXMP.m_iMinX = (int)TokenNumber;

  00758	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0075e	e8 00 00 00 00	 call	 __ftol2_sse
  00763	89 45 cc	 mov	 DWORD PTR _pXMP$231394[ebp+4], eax

; 234  : 
; 235  : 				Token = GetToken();

  00766	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0076b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 236  : 				pXMP.m_iMinY = (int)TokenNumber;

  0076e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00774	e8 00 00 00 00	 call	 __ftol2_sse
  00779	89 45 d0	 mov	 DWORD PTR _pXMP$231394[ebp+8], eax

; 237  : 
; 238  : 				Token = GetToken();

  0077c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00781	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 239  : 				pXMP.m_iMaxX = (int)TokenNumber;

  00784	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0078a	e8 00 00 00 00	 call	 __ftol2_sse
  0078f	89 45 d4	 mov	 DWORD PTR _pXMP$231394[ebp+12], eax

; 240  : 
; 241  : 				Token = GetToken();

  00792	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00797	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 242  : 				pXMP.m_iMaxY = (int)TokenNumber;

  0079a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007a0	e8 00 00 00 00	 call	 __ftol2_sse
  007a5	89 45 d8	 mov	 DWORD PTR _pXMP$231394[ebp+16], eax

; 243  : 
; 244  : 				this->m_vtXMasMonsterMapInfo.push_back(pXMP);

  007a8	8d 45 c8	 lea	 eax, DWORD PTR _pXMP$231394[ebp]
  007ab	50		 push	 eax
  007ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007af	83 c1 5c	 add	 ecx, 92			; 0000005cH
  007b2	e8 00 00 00 00	 call	 ?push_back@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXABUXMASMONSTER_MAP_INFO@@@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::push_back
$LN2@Load:

; 245  : 			}
; 246  : 		}

  007b7	e9 11 fd ff ff	 jmp	 $LN16@Load
$LN15@Load:

; 247  : 	}

  007bc	e9 de fc ff ff	 jmp	 $LN19@Load
$LN18@Load:

; 248  : 
; 249  : 	fclose(SMDFile);

  007c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007c6	50		 push	 eax
  007c7	e8 00 00 00 00	 call	 _fclose
  007cc	83 c4 04	 add	 esp, 4

; 250  : 	LogAdd("[XMasAttackEvent] - %s file load!", lpszFileName);

  007cf	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  007d2	50		 push	 eax
  007d3	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PEGBMCF@?$FLXMasAttackEvent?$FN?5?9?5?$CFs?5file?5load@
  007d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  007de	83 c4 08	 add	 esp, 8

; 251  : 	this->m_bHasData = TRUE;

  007e1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007e4	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 252  : 
; 253  : 	return TRUE;

  007eb	b8 01 00 00 00	 mov	 eax, 1
$LN21@Load:

; 254  : }

  007f0	5f		 pop	 edi
  007f1	5e		 pop	 esi
  007f2	5b		 pop	 ebx
  007f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007f6	33 cd		 xor	 ecx, ebp
  007f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007fd	8b e5		 mov	 esp, ebp
  007ff	5d		 pop	 ebp
  00800	c2 04 00	 ret	 4
?Load@CXMasAttackEvent@@UAEHPAD@Z ENDP			; CXMasAttackEvent::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00810	55		 push	 ebp
  00811	8b ec		 mov	 ebp, esp
  00813	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00819	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0081e	33 c5		 xor	 eax, ebp
  00820	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00823	53		 push	 ebx
  00824	56		 push	 esi
  00825	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00826	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0082d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00832	50		 push	 eax
  00833	e8 00 00 00 00	 call	 _fgetc
  00838	83 c4 04	 add	 esp, 4
  0083b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0083e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00842	83 f9 ff	 cmp	 ecx, -1
  00845	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00847	b8 02 00 00 00	 mov	 eax, 2
  0084c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00851	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00853	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00857	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0085a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0085c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00861	50		 push	 eax
  00862	e8 00 00 00 00	 call	 _fgetc
  00867	83 c4 04	 add	 esp, 4
  0086a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0086d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00871	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00874	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00876	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0087a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0087d	74 1c		 je	 SHORT $LN23@GetToken
  0087f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00883	83 f8 ff	 cmp	 eax, -1
  00886	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00888	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 _fgetc
  00893	83 c4 04	 add	 esp, 4
  00896	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00899	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0089b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0089f	83 f8 ff	 cmp	 eax, -1
  008a2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  008a4	b8 02 00 00 00	 mov	 eax, 2
  008a9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  008ae	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008b2	50		 push	 eax
  008b3	e8 00 00 00 00	 call	 _isspace
  008b8	83 c4 04	 add	 esp, 4
  008bb	85 c0		 test	 eax, eax
  008bd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  008c3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008c7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  008cd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  008d3	83 e9 22	 sub	 ecx, 34			; 00000022H
  008d6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  008dc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  008e3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  008e9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  008ef	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  008f6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  008fd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00907	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0090c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00911	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00916	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00920	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00925	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0092a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0092f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00939	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0093e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00943	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00948	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00952	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00957	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0095c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00961	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0096b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00970	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00975	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0097a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0097f	50		 push	 eax
  00980	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00984	51		 push	 ecx
  00985	e8 00 00 00 00	 call	 _ungetc
  0098a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0098d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00990	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00993	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00998	50		 push	 eax
  00999	e8 00 00 00 00	 call	 _getc
  0099e	83 c4 04	 add	 esp, 4
  009a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  009a4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  009a8	83 f9 ff	 cmp	 ecx, -1
  009ab	74 36		 je	 SHORT $LN12@GetToken
  009ad	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009b1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  009b4	74 1a		 je	 SHORT $LN11@GetToken
  009b6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009ba	50		 push	 eax
  009bb	e8 00 00 00 00	 call	 _isdigit
  009c0	83 c4 04	 add	 esp, 4
  009c3	85 c0		 test	 eax, eax
  009c5	75 09		 jne	 SHORT $LN11@GetToken
  009c7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009cb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  009ce	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  009d0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009d3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  009d6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  009d8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009db	83 c0 01	 add	 eax, 1
  009de	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  009e1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  009e3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009e6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  009e9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  009ec	50		 push	 eax
  009ed	e8 00 00 00 00	 call	 _atof
  009f2	83 c4 04	 add	 esp, 4
  009f5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  009fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00a05	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a0a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00a0f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00a14	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00a1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00a20	50		 push	 eax
  00a21	e8 00 00 00 00	 call	 _getc
  00a26	83 c4 04	 add	 esp, 4
  00a29	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00a2c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00a30	83 f9 ff	 cmp	 ecx, -1
  00a33	74 1c		 je	 SHORT $LN8@GetToken
  00a35	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a39	83 f8 22	 cmp	 eax, 34			; 00000022H
  00a3c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00a3e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00a41	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00a44	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00a46	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00a49	83 c0 01	 add	 eax, 1
  00a4c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00a4f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00a51	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a55	83 f8 22	 cmp	 eax, 34			; 00000022H
  00a58	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00a5a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00a5f	50		 push	 eax
  00a60	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00a64	51		 push	 ecx
  00a65	e8 00 00 00 00	 call	 _ungetc
  00a6a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00a6d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00a70	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00a73	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00a7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a82	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00a87	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00a8c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a90	50		 push	 eax
  00a91	e8 00 00 00 00	 call	 _isalpha
  00a96	83 c4 04	 add	 esp, 4
  00a99	85 c0		 test	 eax, eax
  00a9b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00aa1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00aa8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00aab	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00aae	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00ab0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ab3	83 c0 01	 add	 eax, 1
  00ab6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00ab9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00abe	50		 push	 eax
  00abf	e8 00 00 00 00	 call	 _getc
  00ac4	83 c4 04	 add	 esp, 4
  00ac7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00aca	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ace	83 f9 ff	 cmp	 ecx, -1
  00ad1	74 36		 je	 SHORT $LN3@GetToken
  00ad3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ad7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00ada	74 1a		 je	 SHORT $LN2@GetToken
  00adc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ae0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00ae3	74 11		 je	 SHORT $LN2@GetToken
  00ae5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ae9	50		 push	 eax
  00aea	e8 00 00 00 00	 call	 _isalnum
  00aef	83 c4 04	 add	 esp, 4
  00af2	85 c0		 test	 eax, eax
  00af4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00af6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00af9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00afc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00afe	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b01	83 c0 01	 add	 eax, 1
  00b04	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00b07	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00b09	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00b0e	50		 push	 eax
  00b0f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00b13	51		 push	 ecx
  00b14	e8 00 00 00 00	 call	 _ungetc
  00b19	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  00b1c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b1f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00b22	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  00b2c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00b31	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00b33	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00b35	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00b3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00b44	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00b46	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00b48	5f		 pop	 edi
  00b49	5e		 pop	 esi
  00b4a	5b		 pop	 ebx
  00b4b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b4e	33 cd		 xor	 ecx, ebp
  00b50	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b55	8b e5		 mov	 esp, ebp
  00b57	5d		 pop	 ebp
  00b58	c3		 ret	 0
  00b59	8d 49 00	 npad	 3
$LN35@GetToken:
  00b5c	00 00 00 00	 DD	 $LN10@GetToken
  00b60	00 00 00 00	 DD	 $LN19@GetToken
  00b64	00 00 00 00	 DD	 $LN17@GetToken
  00b68	00 00 00 00	 DD	 $LN14@GetToken
  00b6c	00 00 00 00	 DD	 $LN18@GetToken
  00b70	00 00 00 00	 DD	 $LN16@GetToken
  00b74	00 00 00 00	 DD	 $LN15@GetToken
  00b78	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00b7c	00		 DB	 0
  00b7d	01		 DB	 1
  00b7e	07		 DB	 7
  00b7f	07		 DB	 7
  00b80	07		 DB	 7
  00b81	07		 DB	 7
  00b82	07		 DB	 7
  00b83	07		 DB	 7
  00b84	07		 DB	 7
  00b85	07		 DB	 7
  00b86	02		 DB	 2
  00b87	03		 DB	 3
  00b88	03		 DB	 3
  00b89	07		 DB	 7
  00b8a	03		 DB	 3
  00b8b	03		 DB	 3
  00b8c	03		 DB	 3
  00b8d	03		 DB	 3
  00b8e	03		 DB	 3
  00b8f	03		 DB	 3
  00b90	03		 DB	 3
  00b91	03		 DB	 3
  00b92	03		 DB	 3
  00b93	03		 DB	 3
  00b94	07		 DB	 7
  00b95	04		 DB	 4
  00b96	07		 DB	 7
  00b97	07		 DB	 7
  00b98	07		 DB	 7
  00b99	07		 DB	 7
  00b9a	07		 DB	 7
  00b9b	07		 DB	 7
  00b9c	07		 DB	 7
  00b9d	07		 DB	 7
  00b9e	07		 DB	 7
  00b9f	07		 DB	 7
  00ba0	07		 DB	 7
  00ba1	07		 DB	 7
  00ba2	07		 DB	 7
  00ba3	07		 DB	 7
  00ba4	07		 DB	 7
  00ba5	07		 DB	 7
  00ba6	07		 DB	 7
  00ba7	07		 DB	 7
  00ba8	07		 DB	 7
  00ba9	07		 DB	 7
  00baa	07		 DB	 7
  00bab	07		 DB	 7
  00bac	07		 DB	 7
  00bad	07		 DB	 7
  00bae	07		 DB	 7
  00baf	07		 DB	 7
  00bb0	07		 DB	 7
  00bb1	07		 DB	 7
  00bb2	07		 DB	 7
  00bb3	07		 DB	 7
  00bb4	07		 DB	 7
  00bb5	07		 DB	 7
  00bb6	07		 DB	 7
  00bb7	07		 DB	 7
  00bb8	07		 DB	 7
  00bb9	07		 DB	 7
  00bba	07		 DB	 7
  00bbb	07		 DB	 7
  00bbc	07		 DB	 7
  00bbd	07		 DB	 7
  00bbe	07		 DB	 7
  00bbf	07		 DB	 7
  00bc0	07		 DB	 7
  00bc1	07		 DB	 7
  00bc2	07		 DB	 7
  00bc3	07		 DB	 7
  00bc4	07		 DB	 7
  00bc5	07		 DB	 7
  00bc6	07		 DB	 7
  00bc7	07		 DB	 7
  00bc8	07		 DB	 7
  00bc9	07		 DB	 7
  00bca	07		 DB	 7
  00bcb	07		 DB	 7
  00bcc	07		 DB	 7
  00bcd	07		 DB	 7
  00bce	07		 DB	 7
  00bcf	07		 DB	 7
  00bd0	07		 DB	 7
  00bd1	07		 DB	 7
  00bd2	07		 DB	 7
  00bd3	07		 DB	 7
  00bd4	07		 DB	 7
  00bd5	05		 DB	 5
  00bd6	07		 DB	 7
  00bd7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?AddMonsterToHerd@CXMasAttackEvent@@QAEXPAVCXMasMonsterHerd@@@Z ; CXMasAttackEvent::AddMonsterToHerd
PUBLIC	??_C@_0EE@INOOIIFJ@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Star@ ; `string'
PUBLIC	??_C@_0DC@KONBBJGO@?$FLXMasAttackEvent?$FN?5?9?5Error?5?3?5No?5M@ ; `string'
PUBLIC	??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[]
PUBLIC	??A?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEAAUXMASMONSTER_MAP_INFO@@I@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::operator[]
PUBLIC	?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::size
PUBLIC	?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::CreateMonsterHerd
PUBLIC	?SendMessageA@CXMasAttackEvent@@QAEXPADH@Z	; CXMasAttackEvent::SendMessageA
PUBLIC	?empty@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::empty
PUBLIC	__$ArrayPad$
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0EE@INOOIIFJ@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Star@
; File d:\projects\exteam6.3\source\gameserver\gameserver\xmasattackevent.cpp
CONST	SEGMENT
??_C@_0EE@INOOIIFJ@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Star@ DB '[XMasA'
	DB	'ttackEvent] - Monster Start Position MapNumber:%d, X:%d, Y:%d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KONBBJGO@?$FLXMasAttackEvent?$FN?5?9?5Error?5?3?5No?5M@
CONST	SEGMENT
??_C@_0DC@KONBBJGO@?$FLXMasAttackEvent?$FN?5?9?5Error?5?3?5No?5M@ DB '[XM'
	DB	'asAttackEvent] - Error : No Monster Data Exist', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iRandY$231415 = -48					; size = 4
_iRandX$231414 = -44					; size = 4
_iCount$231413 = -40					; size = 4
_vtHerdInfo$231412 = -36				; size = 4
_MonsterMapInfo$231411 = -32				; size = 20
_i$231407 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?StartEvent@CXMasAttackEvent@@UAEXXZ PROC		; CXMasAttackEvent::StartEvent
; _this$ = ecx

; 257  : {

  00be0	55		 push	 ebp
  00be1	8b ec		 mov	 ebp, esp
  00be3	83 ec 70	 sub	 esp, 112		; 00000070H
  00be6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00beb	33 c5		 xor	 eax, ebp
  00bed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00bf0	53		 push	 ebx
  00bf1	56		 push	 esi
  00bf2	57		 push	 edi
  00bf3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 258  : 	if ( this->m_bDoEvent == FALSE )

  00bf6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00bf9	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00bfd	75 05		 jne	 SHORT $LN12@StartEvent

; 259  : 	{
; 260  : 		return;

  00bff	e9 8d 01 00 00	 jmp	 $LN13@StartEvent
$LN12@StartEvent:

; 261  : 	}
; 262  : 
; 263  : 	if ( this->m_bHasData == FALSE )

  00c04	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c07	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00c0b	75 05		 jne	 SHORT $LN11@StartEvent

; 264  : 	{
; 265  : 		return;

  00c0d	e9 7f 01 00 00	 jmp	 $LN13@StartEvent
$LN11@StartEvent:

; 266  : 	}
; 267  : 
; 268  : 	if( this->m_vtMonsterAddData.empty() != FALSE )

  00c12	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c15	83 c1 38	 add	 ecx, 56			; 00000038H
  00c18	e8 00 00 00 00	 call	 ?empty@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::empty
  00c1d	0f b6 c0	 movzx	 eax, al
  00c20	85 c0		 test	 eax, eax
  00c22	74 05		 je	 SHORT $LN10@StartEvent

; 269  : 	{
; 270  : 		return;

  00c24	e9 68 01 00 00	 jmp	 $LN13@StartEvent
$LN10@StartEvent:

; 271  : 	}
; 272  : 
; 273  : 	this->SendMessage(lMsg.Get(2583), 1);

  00c29	6a 01		 push	 1
  00c2b	68 17 0a 00 00	 push	 2583			; 00000a17H
  00c30	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00c35	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00c3a	50		 push	 eax
  00c3b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c3e	e8 00 00 00 00	 call	 ?SendMessageA@CXMasAttackEvent@@QAEXPADH@Z ; CXMasAttackEvent::SendMessageA

; 274  : 
; 275  : 	this->ClearMonsterHerd();

  00c43	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c46	e8 00 00 00 00	 call	 ?ClearMonsterHerd@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::ClearMonsterHerd

; 276  : 	this->CreateMonsterHerd();

  00c4b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c4e	e8 00 00 00 00	 call	 ?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::CreateMonsterHerd

; 277  : 
; 278  : 	for (int i = 0; i < this->m_vtXMasMonsterMapInfo.size(); i++)

  00c53	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231407[ebp], 0
  00c5a	eb 09		 jmp	 SHORT $LN9@StartEvent
$LN8@StartEvent:
  00c5c	8b 45 f4	 mov	 eax, DWORD PTR _i$231407[ebp]
  00c5f	83 c0 01	 add	 eax, 1
  00c62	89 45 f4	 mov	 DWORD PTR _i$231407[ebp], eax
$LN9@StartEvent:
  00c65	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c68	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00c6b	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::size
  00c70	39 45 f4	 cmp	 DWORD PTR _i$231407[ebp], eax
  00c73	0f 83 18 01 00
	00		 jae	 $LN13@StartEvent

; 279  : 	{
; 280  : 		XMASMONSTER_MAP_INFO MonsterMapInfo = this->m_vtXMasMonsterMapInfo[i]; //perfect

  00c79	8b 45 f4	 mov	 eax, DWORD PTR _i$231407[ebp]
  00c7c	50		 push	 eax
  00c7d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c80	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00c83	e8 00 00 00 00	 call	 ??A?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEAAUXMASMONSTER_MAP_INFO@@I@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::operator[]
  00c88	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c8a	89 4d e0	 mov	 DWORD PTR _MonsterMapInfo$231411[ebp], ecx
  00c8d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00c90	89 55 e4	 mov	 DWORD PTR _MonsterMapInfo$231411[ebp+4], edx
  00c93	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c96	89 4d e8	 mov	 DWORD PTR _MonsterMapInfo$231411[ebp+8], ecx
  00c99	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00c9c	89 55 ec	 mov	 DWORD PTR _MonsterMapInfo$231411[ebp+12], edx
  00c9f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00ca2	89 45 f0	 mov	 DWORD PTR _MonsterMapInfo$231411[ebp+16], eax

; 281  : 		
; 282  : 		CXMasMonsterHerd * vtHerdInfo = this->m_vtXMasMonsterHerd[i]; //perfect

  00ca5	8b 45 f4	 mov	 eax, DWORD PTR _i$231407[ebp]
  00ca8	50		 push	 eax
  00ca9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cac	83 c1 48	 add	 ecx, 72			; 00000048H
  00caf	e8 00 00 00 00	 call	 ??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[]
  00cb4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cb6	89 4d dc	 mov	 DWORD PTR _vtHerdInfo$231412[ebp], ecx

; 283  : 
; 284  : 		int iCount = 1000;

  00cb9	c7 45 d8 e8 03
	00 00		 mov	 DWORD PTR _iCount$231413[ebp], 1000 ; 000003e8H

; 285  : 		int iRandX = 0;

  00cc0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iRandX$231414[ebp], 0

; 286  : 		int iRandY = 0;

  00cc7	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _iRandY$231415[ebp], 0
$LN6@StartEvent:

; 287  : 
; 288  : 		while ( iCount-- != 0 )

  00cce	8b 45 d8	 mov	 eax, DWORD PTR _iCount$231413[ebp]
  00cd1	8b 4d d8	 mov	 ecx, DWORD PTR _iCount$231413[ebp]
  00cd4	83 e9 01	 sub	 ecx, 1
  00cd7	89 4d d8	 mov	 DWORD PTR _iCount$231413[ebp], ecx
  00cda	85 c0		 test	 eax, eax
  00cdc	74 4d		 je	 SHORT $LN5@StartEvent

; 289  : 		{
; 290  : 			iRandX = rand() % (MonsterMapInfo.m_iMaxX - MonsterMapInfo.m_iMinX) + MonsterMapInfo.m_iMinX; //perfect

  00cde	e8 00 00 00 00	 call	 _rand
  00ce3	8b 4d ec	 mov	 ecx, DWORD PTR _MonsterMapInfo$231411[ebp+12]
  00ce6	2b 4d e4	 sub	 ecx, DWORD PTR _MonsterMapInfo$231411[ebp+4]
  00ce9	99		 cdq
  00cea	f7 f9		 idiv	 ecx
  00cec	03 55 e4	 add	 edx, DWORD PTR _MonsterMapInfo$231411[ebp+4]
  00cef	89 55 d4	 mov	 DWORD PTR _iRandX$231414[ebp], edx

; 291  : 			iRandY = rand() % (MonsterMapInfo.m_iMaxY - MonsterMapInfo.m_iMinX) + MonsterMapInfo.m_iMinY; //perfect + wz bug

  00cf2	e8 00 00 00 00	 call	 _rand
  00cf7	8b 4d f0	 mov	 ecx, DWORD PTR _MonsterMapInfo$231411[ebp+16]
  00cfa	2b 4d e4	 sub	 ecx, DWORD PTR _MonsterMapInfo$231411[ebp+4]
  00cfd	99		 cdq
  00cfe	f7 f9		 idiv	 ecx
  00d00	03 55 e8	 add	 edx, DWORD PTR _MonsterMapInfo$231411[ebp+8]
  00d03	89 55 d0	 mov	 DWORD PTR _iRandY$231415[ebp], edx

; 292  : 
; 293  : 			if ( vtHerdInfo->SetTotalInfo(MonsterMapInfo.m_btMapNumber, 3, iRandX, iRandY ) == TRUE )

  00d06	8b 45 d0	 mov	 eax, DWORD PTR _iRandY$231415[ebp]
  00d09	50		 push	 eax
  00d0a	8b 4d d4	 mov	 ecx, DWORD PTR _iRandX$231414[ebp]
  00d0d	51		 push	 ecx
  00d0e	6a 03		 push	 3
  00d10	0f b6 55 e0	 movzx	 edx, BYTE PTR _MonsterMapInfo$231411[ebp]
  00d14	52		 push	 edx
  00d15	8b 45 dc	 mov	 eax, DWORD PTR _vtHerdInfo$231412[ebp]
  00d18	8b 10		 mov	 edx, DWORD PTR [eax]
  00d1a	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231412[ebp]
  00d1d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00d20	ff d0		 call	 eax
  00d22	83 f8 01	 cmp	 eax, 1
  00d25	75 02		 jne	 SHORT $LN4@StartEvent

; 294  : 			{
; 295  : 				break;

  00d27	eb 02		 jmp	 SHORT $LN5@StartEvent
$LN4@StartEvent:

; 296  : 			}
; 297  : 		}

  00d29	eb a3		 jmp	 SHORT $LN6@StartEvent
$LN5@StartEvent:

; 298  : 
; 299  : 		if ( iCount == 0 )

  00d2b	83 7d d8 00	 cmp	 DWORD PTR _iCount$231413[ebp], 0
  00d2f	75 02		 jne	 SHORT $LN3@StartEvent

; 300  : 		{
; 301  : 
; 302  : 		}
; 303  : 		else

  00d31	eb 40		 jmp	 SHORT $LN2@StartEvent
$LN3@StartEvent:

; 304  : 		{
; 305  : 			if ( this->m_vtMonsterAddData.empty() != FALSE )

  00d33	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d36	83 c1 38	 add	 ecx, 56			; 00000038H
  00d39	e8 00 00 00 00	 call	 ?empty@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::empty
  00d3e	0f b6 c0	 movzx	 eax, al
  00d41	85 c0		 test	 eax, eax
  00d43	74 13		 je	 SHORT $LN1@StartEvent

; 306  : 			{
; 307  : 				LogAddTD("[XMasAttackEvent] - Error : No Monster Data Exist");

  00d45	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KONBBJGO@?$FLXMasAttackEvent?$FN?5?9?5Error?5?3?5No?5M@
  00d4a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d50	83 c4 04	 add	 esp, 4

; 308  : 				continue;

  00d53	e9 04 ff ff ff	 jmp	 $LN8@StartEvent
$LN1@StartEvent:

; 309  : 			}
; 310  : 			LogAddTD("[XMasAttackEvent] - Monster Start Position MapNumber:%d, X:%d, Y:%d", MonsterMapInfo.m_btMapNumber, iRandX, iRandY);

  00d58	8b 45 d0	 mov	 eax, DWORD PTR _iRandY$231415[ebp]
  00d5b	50		 push	 eax
  00d5c	8b 4d d4	 mov	 ecx, DWORD PTR _iRandX$231414[ebp]
  00d5f	51		 push	 ecx
  00d60	0f b6 55 e0	 movzx	 edx, BYTE PTR _MonsterMapInfo$231411[ebp]
  00d64	52		 push	 edx
  00d65	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@INOOIIFJ@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Star@
  00d6a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d70	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@StartEvent:

; 311  : 		}
; 312  : 		this->AddMonsterToHerd(vtHerdInfo);

  00d73	8b 45 dc	 mov	 eax, DWORD PTR _vtHerdInfo$231412[ebp]
  00d76	50		 push	 eax
  00d77	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d7a	e8 00 00 00 00	 call	 ?AddMonsterToHerd@CXMasAttackEvent@@QAEXPAVCXMasMonsterHerd@@@Z ; CXMasAttackEvent::AddMonsterToHerd

; 313  : 		vtHerdInfo->Start();

  00d7f	8b 45 dc	 mov	 eax, DWORD PTR _vtHerdInfo$231412[ebp]
  00d82	8b 10		 mov	 edx, DWORD PTR [eax]
  00d84	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231412[ebp]
  00d87	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00d8a	ff d0		 call	 eax

; 314  : 	}

  00d8c	e9 cb fe ff ff	 jmp	 $LN8@StartEvent
$LN13@StartEvent:

; 315  : }

  00d91	5f		 pop	 edi
  00d92	5e		 pop	 esi
  00d93	5b		 pop	 ebx
  00d94	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d97	33 cd		 xor	 ecx, ebp
  00d99	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d9e	8b e5		 mov	 esp, ebp
  00da0	5d		 pop	 ebp
  00da1	c3		 ret	 0
?StartEvent@CXMasAttackEvent@@UAEXXZ ENDP		; CXMasAttackEvent::StartEvent
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEAAPAVCXMasMonsterHerd@@XZ ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator!=
PUBLIC	?end@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++
PUBLIC	?begin@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T234990 = -80						; size = 4
_vtHerdInfo$231580 = -12				; size = 4
_it$ = -8						; size = 4
_this$ = -4						; size = 4
?StopEvent@CXMasAttackEvent@@UAEXXZ PROC		; CXMasAttackEvent::StopEvent
; _this$ = ecx

; 318  : {

  00db0	55		 push	 ebp
  00db1	8b ec		 mov	 ebp, esp
  00db3	83 ec 50	 sub	 esp, 80			; 00000050H
  00db6	53		 push	 ebx
  00db7	56		 push	 esi
  00db8	57		 push	 edi
  00db9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 	std::vector<CXMasMonsterHerd*>::iterator it = this->m_vtXMasMonsterHerd.begin();

  00dbc	8d 45 f8	 lea	 eax, DWORD PTR _it$[ebp]
  00dbf	50		 push	 eax
  00dc0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dc3	83 c1 48	 add	 ecx, 72			; 00000048H
  00dc6	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::begin
  00dcb	eb 08		 jmp	 SHORT $LN3@StopEvent
$LN2@StopEvent:

; 320  : 
; 321  : 	for (; it != this->m_vtXMasMonsterHerd.end(); ++it)

  00dcd	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00dd0	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++
$LN3@StopEvent:
  00dd5	8d 45 b0	 lea	 eax, DWORD PTR $T234990[ebp]
  00dd8	50		 push	 eax
  00dd9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ddc	83 c1 48	 add	 ecx, 72			; 00000048H
  00ddf	e8 00 00 00 00	 call	 ?end@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::end
  00de4	50		 push	 eax
  00de5	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00de8	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator!=
  00ded	0f b6 c8	 movzx	 ecx, al
  00df0	85 c9		 test	 ecx, ecx
  00df2	74 1c		 je	 SHORT $LN1@StopEvent

; 322  : 	{
; 323  : 		CXMasMonsterHerd * vtHerdInfo = *it; //perfect

  00df4	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00df7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEAAPAVCXMasMonsterHerd@@XZ ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*
  00dfc	8b 00		 mov	 eax, DWORD PTR [eax]
  00dfe	89 45 f4	 mov	 DWORD PTR _vtHerdInfo$231580[ebp], eax

; 324  : 
; 325  : 		vtHerdInfo->Stop();

  00e01	8b 45 f4	 mov	 eax, DWORD PTR _vtHerdInfo$231580[ebp]
  00e04	8b 10		 mov	 edx, DWORD PTR [eax]
  00e06	8b 4d f4	 mov	 ecx, DWORD PTR _vtHerdInfo$231580[ebp]
  00e09	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00e0c	ff d0		 call	 eax

; 326  : 	}

  00e0e	eb bd		 jmp	 SHORT $LN2@StopEvent
$LN1@StopEvent:

; 327  : 
; 328  : 	this->m_bMonsterToDest = FALSE;

  00e10	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e13	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 329  : }

  00e1a	5f		 pop	 edi
  00e1b	5e		 pop	 esi
  00e1c	5b		 pop	 ebx
  00e1d	8b e5		 mov	 esp, ebp
  00e1f	5d		 pop	 ebp
  00e20	c3		 ret	 0
?StopEvent@CXMasAttackEvent@@UAEXXZ ENDP		; CXMasAttackEvent::StopEvent
_TEXT	ENDS
PUBLIC	?SetState@CXMasAttackEvent@@QAEXH@Z		; CXMasAttackEvent::SetState
PUBLIC	?EnableEvent@CXMasAttackEvent@@QAEXH@Z		; CXMasAttackEvent::EnableEvent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDoEvent$ = 8						; size = 4
?EnableEvent@CXMasAttackEvent@@QAEXH@Z PROC		; CXMasAttackEvent::EnableEvent
; _this$ = ecx

; 332  : {

  00e30	55		 push	 ebp
  00e31	8b ec		 mov	 ebp, esp
  00e33	83 ec 44	 sub	 esp, 68			; 00000044H
  00e36	53		 push	 ebx
  00e37	56		 push	 esi
  00e38	57		 push	 edi
  00e39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 	this->m_bDoEvent = bDoEvent;

  00e3c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e3f	8b 4d 08	 mov	 ecx, DWORD PTR _bDoEvent$[ebp]
  00e42	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 334  : 
; 335  : 	if ( this->m_bDoEvent )

  00e45	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e48	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00e4c	74 0c		 je	 SHORT $LN2@EnableEven

; 336  : 	{
; 337  : 		this->SetState(ATTACKEVENT_STATE_CLOSED);

  00e4e	6a 01		 push	 1
  00e50	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e53	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 338  : 	}
; 339  : 	else

  00e58	eb 0a		 jmp	 SHORT $LN3@EnableEven
$LN2@EnableEven:

; 340  : 	{
; 341  : 		this->SetState(ATTACKEVENT_STATE_NONE);

  00e5a	6a 00		 push	 0
  00e5c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e5f	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState
$LN3@EnableEven:

; 342  : 	}
; 343  : }

  00e64	5f		 pop	 edi
  00e65	5e		 pop	 esi
  00e66	5b		 pop	 ebx
  00e67	8b e5		 mov	 esp, ebp
  00e69	5d		 pop	 ebp
  00e6a	c2 04 00	 ret	 4
?EnableEvent@CXMasAttackEvent@@QAEXH@Z ENDP		; CXMasAttackEvent::EnableEvent
_TEXT	ENDS
PUBLIC	?SetState_Playing@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::SetState_Playing
PUBLIC	?SetState_Closed@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::SetState_Closed
PUBLIC	?SetState_None@CXMasAttackEvent@@QAEXXZ		; CXMasAttackEvent::SetState_None
PUBLIC	??_C@_0FK@CCACGPIP@?$CIm_nEventState?5?$DO?$DN?5ATTACKEVENT_ST@ ; `string'
PUBLIC	??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EK@EFLFLJND@?$CInSate?5?$DO?$DN?5ATTACKEVENT_STATE_NONE@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
PUBLIC	??_C@_0EH@PDFEFGLI@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
;	COMDAT ??_C@_0FK@CCACGPIP@?$CIm_nEventState?5?$DO?$DN?5ATTACKEVENT_ST@
CONST	SEGMENT
??_C@_0FK@CCACGPIP@?$CIm_nEventState?5?$DO?$DN?5ATTACKEVENT_ST@ DB '(m_nE'
	DB	'ventState >= ATTACKEVENT_STATE_NONE) || (m_nEventState <= ATT'
	DB	'ACKEVENT_STATE_PLAYING)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@ DB '%s', 09H, '%'
	DB	's', 09H, '%s', 09H, '%s', 09H, '%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@EFLFLJND@?$CInSate?5?$DO?$DN?5ATTACKEVENT_STATE_NONE@
CONST	SEGMENT
??_C@_0EK@EFLFLJND@?$CInSate?5?$DO?$DN?5ATTACKEVENT_STATE_NONE@ DB '(nSat'
	DB	'e >= ATTACKEVENT_STATE_NONE) || (nSate <= ATTACKEVENT_STATE_P'
	DB	'LAYING)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@PDFEFGLI@d?3?2projects?2exteam6?43?2source?2gam@
CONST	SEGMENT
??_C@_0EH@PDFEFGLI@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\xmasattackevent.cpp', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv88 = -72						; size = 4
_this$ = -4						; size = 4
_nSate$ = 8						; size = 4
?SetState@CXMasAttackEvent@@QAEXH@Z PROC		; CXMasAttackEvent::SetState
; _this$ = ecx

; 347  : {

  00e70	55		 push	 ebp
  00e71	8b ec		 mov	 ebp, esp
  00e73	83 ec 48	 sub	 esp, 72			; 00000048H
  00e76	53		 push	 ebx
  00e77	56		 push	 esi
  00e78	57		 push	 edi
  00e79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 348  : 	if ( !(nSate >= ATTACKEVENT_STATE_NONE || nSate <= ATTACKEVENT_STATE_PLAYING) )

  00e7c	83 7d 08 00	 cmp	 DWORD PTR _nSate$[ebp], 0
  00e80	7d 38		 jge	 SHORT $LN7@SetState
  00e82	83 7d 08 02	 cmp	 DWORD PTR _nSate$[ebp], 2
  00e86	7e 32		 jle	 SHORT $LN7@SetState

; 349  : 	{
; 350  : 		LogAddTD("%s	%s	%s	%s	%d","(nSate >= ATTACKEVENT_STATE_NONE) || (nSate <= ATTACKEVENT_STATE_PLAYING)", "", "NULL", __FILE__, ErrorType+1);

  00e88	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?ErrorType@@3FA ; ErrorType
  00e8f	83 c0 01	 add	 eax, 1
  00e92	50		 push	 eax
  00e93	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@PDFEFGLI@d?3?2projects?2exteam6?43?2source?2gam@
  00e98	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00e9d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00ea2	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@EFLFLJND@?$CInSate?5?$DO?$DN?5ATTACKEVENT_STATE_NONE@
  00ea7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00eac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00eb2	83 c4 18	 add	 esp, 24			; 00000018H

; 351  : 		return;

  00eb5	e9 83 00 00 00	 jmp	 $LN8@SetState
$LN7@SetState:

; 352  : 	}
; 353  : 
; 354  : 	if ( !(this->m_nEvent_State >= ATTACKEVENT_STATE_NONE || this->m_nEvent_State <= ATTACKEVENT_STATE_PLAYING) )

  00eba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ebd	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  00ec1	7d 38		 jge	 SHORT $LN6@SetState
  00ec3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ec6	83 78 6c 02	 cmp	 DWORD PTR [eax+108], 2
  00eca	7e 2f		 jle	 SHORT $LN6@SetState

; 355  : 	{
; 356  : 		LogAddTD("%s	%s	%s	%s	%d","(m_nEventState >= ATTACKEVENT_STATE_NONE) || (m_nEventState <= ATTACKEVENT_STATE_PLAYING)", "", "NULL", __FILE__, ErrorType+2);

  00ecc	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?ErrorType@@3FA ; ErrorType
  00ed3	83 c0 02	 add	 eax, 2
  00ed6	50		 push	 eax
  00ed7	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@PDFEFGLI@d?3?2projects?2exteam6?43?2source?2gam@
  00edc	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00ee1	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00ee6	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@CCACGPIP@?$CIm_nEventState?5?$DO?$DN?5ATTACKEVENT_ST@
  00eeb	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00ef0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ef6	83 c4 18	 add	 esp, 24			; 00000018H

; 357  : 		return;

  00ef9	eb 42		 jmp	 SHORT $LN8@SetState
$LN6@SetState:

; 358  : 	}
; 359  : 
; 360  : 	this->m_nEvent_State = nSate;

  00efb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00efe	8b 4d 08	 mov	 ecx, DWORD PTR _nSate$[ebp]
  00f01	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 361  : 
; 362  : 	switch ( this->m_nEvent_State )

  00f04	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f07	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00f0a	89 4d b8	 mov	 DWORD PTR tv88[ebp], ecx
  00f0d	83 7d b8 00	 cmp	 DWORD PTR tv88[ebp], 0
  00f11	74 0e		 je	 SHORT $LN3@SetState
  00f13	83 7d b8 01	 cmp	 DWORD PTR tv88[ebp], 1
  00f17	74 12		 je	 SHORT $LN2@SetState
  00f19	83 7d b8 02	 cmp	 DWORD PTR tv88[ebp], 2
  00f1d	74 16		 je	 SHORT $LN1@SetState
  00f1f	eb 1c		 jmp	 SHORT $LN8@SetState
$LN3@SetState:

; 363  : 	{
; 364  : 		case ATTACKEVENT_STATE_NONE:
; 365  : 			this->SetState_None();

  00f21	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f24	e8 00 00 00 00	 call	 ?SetState_None@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::SetState_None

; 366  : 			break;

  00f29	eb 12		 jmp	 SHORT $LN8@SetState
$LN2@SetState:

; 367  : 		case ATTACKEVENT_STATE_CLOSED:
; 368  : 			this->SetState_Closed();

  00f2b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f2e	e8 00 00 00 00	 call	 ?SetState_Closed@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::SetState_Closed

; 369  : 			break;

  00f33	eb 08		 jmp	 SHORT $LN8@SetState
$LN1@SetState:

; 370  : 		case ATTACKEVENT_STATE_PLAYING:
; 371  : 			this->SetState_Playing();

  00f35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f38	e8 00 00 00 00	 call	 ?SetState_Playing@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::SetState_Playing
$LN8@SetState:

; 372  : 			break;
; 373  : 	}
; 374  : }

  00f3d	5f		 pop	 edi
  00f3e	5e		 pop	 esi
  00f3f	5b		 pop	 ebx
  00f40	8b e5		 mov	 esp, ebp
  00f42	5d		 pop	 ebp
  00f43	c2 04 00	 ret	 4
?SetState@CXMasAttackEvent@@QAEXH@Z ENDP		; CXMasAttackEvent::SetState
_TEXT	ENDS
PUBLIC	?ProcState_None@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::ProcState_None
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ProcState_None@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::ProcState_None
; _this$ = ecx

; 377  : {

  00f50	55		 push	 ebp
  00f51	8b ec		 mov	 ebp, esp
  00f53	83 ec 44	 sub	 esp, 68			; 00000044H
  00f56	53		 push	 ebx
  00f57	56		 push	 esi
  00f58	57		 push	 edi
  00f59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : 	return;
; 379  : }

  00f5c	5f		 pop	 edi
  00f5d	5e		 pop	 esi
  00f5e	5b		 pop	 ebx
  00f5f	8b e5		 mov	 esp, ebp
  00f61	5d		 pop	 ebp
  00f62	c3		 ret	 0
?ProcState_None@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::ProcState_None
_TEXT	ENDS
PUBLIC	??_C@_0CC@DNJMFKJI@?$FLXMasAttackEvent?$FN?5?9?5Event?5Starte@ ; `string'
PUBLIC	??_C@_0DC@FLOKLKPF@?$FLXMasAttackEvent?$FN?5?9?5Before?5?$CFd?5mi@ ; `string'
PUBLIC	??_C@_0L@MJHOMCIJ@m_bDoEvent?$AA@		; `string'
PUBLIC	??_C@_0CB@GNAONFCI@SetState?$CIATTACKEVENT_STATE_NONE?$CJ@ ; `string'
PUBLIC	?ProcState_Closed@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::ProcState_Closed
EXTRN	?GetMiliSeconds@CEventTimer@@QAEHXZ:PROC	; CEventTimer::GetMiliSeconds
;	COMDAT ??_C@_0CC@DNJMFKJI@?$FLXMasAttackEvent?$FN?5?9?5Event?5Starte@
CONST	SEGMENT
??_C@_0CC@DNJMFKJI@?$FLXMasAttackEvent?$FN?5?9?5Event?5Starte@ DB '[XMasA'
	DB	'ttackEvent] - Event Started', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FLOKLKPF@?$FLXMasAttackEvent?$FN?5?9?5Before?5?$CFd?5mi@
CONST	SEGMENT
??_C@_0DC@FLOKLKPF@?$FLXMasAttackEvent?$FN?5?9?5Before?5?$CFd?5mi@ DB '[X'
	DB	'MasAttackEvent] - Before %d minutes - Advertise', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJHOMCIJ@m_bDoEvent?$AA@
CONST	SEGMENT
??_C@_0L@MJHOMCIJ@m_bDoEvent?$AA@ DB 'm_bDoEvent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GNAONFCI@SetState?$CIATTACKEVENT_STATE_NONE?$CJ@
CONST	SEGMENT
??_C@_0CB@GNAONFCI@SetState?$CIATTACKEVENT_STATE_NONE?$CJ@ DB 'SetState(A'
	DB	'TTACKEVENT_STATE_NONE)', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iTICK_MSEC$ = -8					; size = 4
_this$ = -4						; size = 4
?ProcState_Closed@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::ProcState_Closed
; _this$ = ecx

; 382  : {

  00f70	55		 push	 ebp
  00f71	8b ec		 mov	 ebp, esp
  00f73	83 ec 48	 sub	 esp, 72			; 00000048H
  00f76	53		 push	 ebx
  00f77	56		 push	 esi
  00f78	57		 push	 edi
  00f79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 383  : 	if(this->m_bDoEvent == FALSE)

  00f7c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f7f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00f83	75 3c		 jne	 SHORT $LN7@ProcState_

; 384  : 	{
; 385  : 		this->SetState(ATTACKEVENT_STATE_NONE);

  00f85	6a 00		 push	 0
  00f87	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f8a	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 386  : 		LogAddTD("%s	%s	%s	%s	%d","m_bDoEvent","","SetState(ATTACKEVENT_STATE_NONE)",__FILE__, ErrorType+1);

  00f8f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?ErrorType@@3FA ; ErrorType
  00f96	83 c0 01	 add	 eax, 1
  00f99	50		 push	 eax
  00f9a	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@PDFEFGLI@d?3?2projects?2exteam6?43?2source?2gam@
  00f9f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GNAONFCI@SetState?$CIATTACKEVENT_STATE_NONE?$CJ@
  00fa4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00fa9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MJHOMCIJ@m_bDoEvent?$AA@
  00fae	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00fb3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00fb9	83 c4 18	 add	 esp, 24			; 00000018H

; 387  : 		return;

  00fbc	e9 ca 00 00 00	 jmp	 $LN8@ProcState_
$LN7@ProcState_:

; 388  : 	}
; 389  : 
; 390  : 	int iTICK_MSEC = this->m_EventTimer.GetMiliSeconds();

  00fc1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc4	83 c1 58	 add	 ecx, 88			; 00000058H
  00fc7	e8 00 00 00 00	 call	 ?GetMiliSeconds@CEventTimer@@QAEHXZ ; CEventTimer::GetMiliSeconds
  00fcc	89 45 f8	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 391  : 
; 392  : 	if ( iTICK_MSEC >= 1000 )

  00fcf	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  00fd6	7c 66		 jl	 SHORT $LN6@ProcState_

; 393  : 	{
; 394  : 		if(iTICK_MSEC/60000 != this->m_iTIME_NOTIFY_COUNT)

  00fd8	8b 45 f8	 mov	 eax, DWORD PTR _iTICK_MSEC$[ebp]
  00fdb	99		 cdq
  00fdc	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00fe1	f7 f9		 idiv	 ecx
  00fe3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00fe6	3b 82 8c 00 00
	00		 cmp	 eax, DWORD PTR [edx+140]
  00fec	74 50		 je	 SHORT $LN6@ProcState_

; 395  : 		{
; 396  : 			this->m_iTIME_NOTIFY_COUNT = iTICK_MSEC/60000;

  00fee	8b 45 f8	 mov	 eax, DWORD PTR _iTICK_MSEC$[ebp]
  00ff1	99		 cdq
  00ff2	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00ff7	f7 f9		 idiv	 ecx
  00ff9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ffc	89 82 8c 00 00
	00		 mov	 DWORD PTR [edx+140], eax

; 397  : 
; 398  : 			if(this->m_iTIME_NOTIFY_COUNT + 1 == m_iTIME_MIN_OPEN/60000)

  01002	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01005	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0100b	83 c1 01	 add	 ecx, 1
  0100e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01011	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  01017	99		 cdq
  01018	be 60 ea 00 00	 mov	 esi, 60000		; 0000ea60H
  0101d	f7 fe		 idiv	 esi
  0101f	3b c8		 cmp	 ecx, eax
  01021	75 1b		 jne	 SHORT $LN6@ProcState_

; 399  : 			{
; 400  : 				LogAddTD("[XMasAttackEvent] - Before %d minutes - Advertise",this->m_iTIME_NOTIFY_COUNT+1);

  01023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01026	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0102c	83 c1 01	 add	 ecx, 1
  0102f	51		 push	 ecx
  01030	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@FLOKLKPF@?$FLXMasAttackEvent?$FN?5?9?5Before?5?$CFd?5mi@
  01035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0103b	83 c4 08	 add	 esp, 8
$LN6@ProcState_:

; 401  : 			}
; 402  : 		}
; 403  : 	}
; 404  : 
; 405  : 	if ( iTICK_MSEC == 0 )

  0103e	83 7d f8 00	 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 0
  01042	75 47		 jne	 SHORT $LN8@ProcState_

; 406  : 	{
; 407  : 		this->SendMessage(lMsg.Get(2583), 1);

  01044	6a 01		 push	 1
  01046	68 17 0a 00 00	 push	 2583			; 00000a17H
  0104b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01050	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01055	50		 push	 eax
  01056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01059	e8 00 00 00 00	 call	 ?SendMessageA@CXMasAttackEvent@@QAEXPADH@Z ; CXMasAttackEvent::SendMessageA

; 408  : 
; 409  : 		if ( this->m_bDoEvent != FALSE )

  0105e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01061	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  01065	74 0c		 je	 SHORT $LN2@ProcState_

; 410  : 		{
; 411  : 			this->SetState(ATTACKEVENT_STATE_PLAYING);

  01067	6a 02		 push	 2
  01069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0106c	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 412  : 		}
; 413  : 		else

  01071	eb 0a		 jmp	 SHORT $LN1@ProcState_
$LN2@ProcState_:

; 414  : 		{
; 415  : 			this->SetState(ATTACKEVENT_STATE_NONE);

  01073	6a 00		 push	 0
  01075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01078	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState
$LN1@ProcState_:

; 416  : 		}
; 417  : 
; 418  : 		LogAddTD("[XMasAttackEvent] - Event Started");

  0107d	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DNJMFKJI@?$FLXMasAttackEvent?$FN?5?9?5Event?5Starte@
  01082	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01088	83 c4 04	 add	 esp, 4
$LN8@ProcState_:

; 419  : 	}
; 420  : }

  0108b	5f		 pop	 edi
  0108c	5e		 pop	 esi
  0108d	5b		 pop	 ebx
  0108e	8b e5		 mov	 esp, ebp
  01090	5d		 pop	 ebp
  01091	c3		 ret	 0
?ProcState_Closed@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::ProcState_Closed
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?DataSendAll@@YAXPAEH@Z:PROC			; DataSendAll
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	__imp__wsprintfA:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -272						; size = 6
_szTemp$ = -264						; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_Effect$ = 12						; size = 4
?SendMessageA@CXMasAttackEvent@@QAEXPADH@Z PROC		; CXMasAttackEvent::SendMessageA
; _this$ = ecx

; 423  : {

  010a0	55		 push	 ebp
  010a1	8b ec		 mov	 ebp, esp
  010a3	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  010a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  010ae	33 c5		 xor	 eax, ebp
  010b0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  010b3	53		 push	 ebx
  010b4	56		 push	 esi
  010b5	57		 push	 edi
  010b6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 424  : 	char szTemp[256];
; 425  : 
; 426  : 	wsprintf(szTemp, lpMsg);

  010b9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  010bc	50		 push	 eax
  010bd	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  010c3	51		 push	 ecx
  010c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  010ca	83 c4 08	 add	 esp, 8

; 427  : 	AllSendServerMsg(szTemp);

  010cd	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  010d3	50		 push	 eax
  010d4	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  010d9	83 c4 04	 add	 esp, 4

; 428  : 
; 429  : 	PMSG_ANS_CL_EFFECT pMsg;
; 430  : 
; 431  : 	PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  010dc	6a 06		 push	 6
  010de	68 9e 00 00 00	 push	 158			; 0000009eH
  010e3	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  010e9	50		 push	 eax
  010ea	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  010ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 	pMsg.wEffectNum = Effect;

  010f2	66 8b 45 0c	 mov	 ax, WORD PTR _Effect$[ebp]
  010f6	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], ax

; 433  : 
; 434  : 	DataSendAll((LPBYTE)&pMsg, pMsg.h.size);

  010fd	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  01104	50		 push	 eax
  01105	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0110b	51		 push	 ecx
  0110c	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  01111	83 c4 08	 add	 esp, 8

; 435  : }

  01114	5f		 pop	 edi
  01115	5e		 pop	 esi
  01116	5b		 pop	 ebx
  01117	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0111a	33 cd		 xor	 ecx, ebp
  0111c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01121	8b e5		 mov	 esp, ebp
  01123	5d		 pop	 ebp
  01124	c2 08 00	 ret	 8
?SendMessageA@CXMasAttackEvent@@QAEXPADH@Z ENDP		; CXMasAttackEvent::SendMessageA
_TEXT	ENDS
PUBLIC	??_C@_0CA@GNBALKOM@?$FLXMasAttackEvent?$FN?5?9?5Event?5Ended?$AA@ ; `string'
PUBLIC	??_C@_0DP@COOJAPLA@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Herd@ ; `string'
PUBLIC	??_C@_0CC@NCANOPGD@?$FLXMasAttackEvent?$FN?5?9?5NotifySec?3?5?$CF@ ; `string'
PUBLIC	?EventLog@CXMasAttackEvent@@QAEXPADHEE@Z	; CXMasAttackEvent::EventLog
PUBLIC	??_C@_0BK@HADDAGD@?$LB?$LK?$LE?$NM?$LI?q?$MA?$PL?A?v?$FL?$CFs?$FN?5X?3?$CFd?0?5Y?3?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EL@CAFMAFGG@?$FLXMasAttackEvent?$FN?5?9?5per?530?8S?5Inf@ ; `string'
PUBLIC	?GetX@CXMasMonsterHerd@@QAEEXZ			; CXMasMonsterHerd::GetX
PUBLIC	?GetY@CXMasMonsterHerd@@QAEEXZ			; CXMasMonsterHerd::GetY
PUBLIC	?GetMapNumber@CXMasMonsterHerd@@QAEHXZ		; CXMasMonsterHerd::GetMapNumber
PUBLIC	?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
PUBLIC	?Move@CXMasAttackEvent@@QAEXXZ			; CXMasAttackEvent::Move
PUBLIC	?ProcState_Playing@CXMasAttackEvent@@QAEXXZ	; CXMasAttackEvent::ProcState_Playing
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0CA@GNBALKOM@?$FLXMasAttackEvent?$FN?5?9?5Event?5Ended?$AA@
CONST	SEGMENT
??_C@_0CA@GNBALKOM@?$FLXMasAttackEvent?$FN?5?9?5Event?5Ended?$AA@ DB '[XM'
	DB	'asAttackEvent] - Event Ended', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@COOJAPLA@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Herd@
CONST	SEGMENT
??_C@_0DP@COOJAPLA@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Herd@ DB '[XMasA'
	DB	'ttackEvent] - Monster Herd Move MapNumber:%d, X:%d, Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NCANOPGD@?$FLXMasAttackEvent?$FN?5?9?5NotifySec?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@NCANOPGD@?$FLXMasAttackEvent?$FN?5?9?5NotifySec?3?5?$CF@ DB '[X'
	DB	'MasAttackEvent] - NotifySec: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HADDAGD@?$LB?$LK?$LE?$NM?$LI?q?$MA?$PL?A?v?$FL?$CFs?$FN?5X?3?$CFd?0?5Y?3?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@HADDAGD@?$LB?$LK?$LE?$NM?$LI?q?$MA?$PL?A?v?$FL?$CFs?$FN?5X?3?$CFd?0?5Y?3?$CFd?$AA@ DB 0b1H
	DB	0baH, 0b4H, 0dcH, 0b8H, 0f1H, 0c0H, 0fbH, 0c1H, 0f6H, '[%s] X:'
	DB	'%d, Y:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CAFMAFGG@?$FLXMasAttackEvent?$FN?5?9?5per?530?8S?5Inf@
CONST	SEGMENT
??_C@_0EL@CAFMAFGG@?$FLXMasAttackEvent?$FN?5?9?5per?530?8S?5Inf@ DB '[XMa'
	DB	'sAttackEvent] - per 30''S Inform MapNumber:%d, X:%d, Y:%d, Bo'
	DB	'ss Live:%d', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iRandY$231666 = -39					; size = 1
_iRandX$231665 = -38					; size = 1
_ucRAND$231664 = -37					; size = 1
_vtHerdInfo$231663 = -36				; size = 4
_i$231659 = -32						; size = 4
_n$231648 = -28						; size = 4
_bLive$231647 = -24					; size = 4
_vtHerdInfo$231646 = -20				; size = 4
_i$231642 = -16						; size = 4
_loc3$ = -12						; size = 4
_iTICK_MSEC$ = -8					; size = 4
_this$ = -4						; size = 4
?ProcState_Playing@CXMasAttackEvent@@QAEXXZ PROC	; CXMasAttackEvent::ProcState_Playing
; _this$ = ecx

; 439  : {

  01130	55		 push	 ebp
  01131	8b ec		 mov	 ebp, esp
  01133	83 ec 68	 sub	 esp, 104		; 00000068H
  01136	53		 push	 ebx
  01137	56		 push	 esi
  01138	57		 push	 edi
  01139	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 440  : 	int iTICK_MSEC = this->m_EventTimer.GetMiliSeconds();

  0113c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0113f	83 c1 58	 add	 ecx, 88			; 00000058H
  01142	e8 00 00 00 00	 call	 ?GetMiliSeconds@CEventTimer@@QAEHXZ ; CEventTimer::GetMiliSeconds
  01147	89 45 f8	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 441  : 
; 442  : 	int loc3 = iTICK_MSEC / 1000;

  0114a	8b 45 f8	 mov	 eax, DWORD PTR _iTICK_MSEC$[ebp]
  0114d	99		 cdq
  0114e	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  01153	f7 f9		 idiv	 ecx
  01155	89 45 f4	 mov	 DWORD PTR _loc3$[ebp], eax

; 443  : 
; 444  : 	if ( iTICK_MSEC >= 1000 )

  01158	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  0115f	7c 19		 jl	 SHORT $LN20@ProcState_@2

; 445  : 	{
; 446  : 		if ( (rand()%20) == 0 )

  01161	e8 00 00 00 00	 call	 _rand
  01166	99		 cdq
  01167	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0116c	f7 f9		 idiv	 ecx
  0116e	85 d2		 test	 edx, edx
  01170	75 08		 jne	 SHORT $LN20@ProcState_@2

; 447  : 		{
; 448  : 			this->Move();

  01172	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01175	e8 00 00 00 00	 call	 ?Move@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::Move
$LN20@ProcState_@2:

; 449  : 		}
; 450  : 	}
; 451  : 
; 452  : 	static int s_iTIME_REMAIN = -1;
; 453  : 
; 454  : 	if ( (loc3 / 30 ) != s_iTIME_REMAIN && (loc3 % 30) == 0  )

  0117a	8b 45 f4	 mov	 eax, DWORD PTR _loc3$[ebp]
  0117d	99		 cdq
  0117e	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  01183	f7 f9		 idiv	 ecx
  01185	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_iTIME_REMAIN@?7??ProcState_Playing@CXMasAttackEvent@@QAEXXZ@4HA
  0118b	0f 84 7e 01 00
	00		 je	 $LN18@ProcState_@2
  01191	8b 45 f4	 mov	 eax, DWORD PTR _loc3$[ebp]
  01194	99		 cdq
  01195	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  0119a	f7 f9		 idiv	 ecx
  0119c	85 d2		 test	 edx, edx
  0119e	0f 85 6b 01 00
	00		 jne	 $LN18@ProcState_@2

; 455  : 	{
; 456  : 		s_iTIME_REMAIN = loc3 / 30;

  011a4	8b 45 f4	 mov	 eax, DWORD PTR _loc3$[ebp]
  011a7	99		 cdq
  011a8	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  011ad	f7 f9		 idiv	 ecx
  011af	a3 00 00 00 00	 mov	 DWORD PTR ?s_iTIME_REMAIN@?7??ProcState_Playing@CXMasAttackEvent@@QAEXXZ@4HA, eax

; 457  : 
; 458  : 		for ( int i=0;i<this->m_vtXMasMonsterHerd.size();i++) //loc4

  011b4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$231642[ebp], 0
  011bb	eb 09		 jmp	 SHORT $LN17@ProcState_@2
$LN16@ProcState_@2:
  011bd	8b 45 f0	 mov	 eax, DWORD PTR _i$231642[ebp]
  011c0	83 c0 01	 add	 eax, 1
  011c3	89 45 f0	 mov	 DWORD PTR _i$231642[ebp], eax
$LN17@ProcState_@2:
  011c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011c9	83 c1 48	 add	 ecx, 72			; 00000048H
  011cc	e8 00 00 00 00	 call	 ?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
  011d1	39 45 f0	 cmp	 DWORD PTR _i$231642[ebp], eax
  011d4	0f 83 21 01 00
	00		 jae	 $LN15@ProcState_@2

; 459  : 		{
; 460  : 			CXMasMonsterHerd * vtHerdInfo = this->m_vtXMasMonsterHerd[i]; //perfect loc5

  011da	8b 45 f0	 mov	 eax, DWORD PTR _i$231642[ebp]
  011dd	50		 push	 eax
  011de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011e1	83 c1 48	 add	 ecx, 72			; 00000048H
  011e4	e8 00 00 00 00	 call	 ??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[]
  011e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  011eb	89 4d ec	 mov	 DWORD PTR _vtHerdInfo$231646[ebp], ecx

; 461  : 
; 462  : 			BOOL bLive = FALSE; //lo6

  011ee	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bLive$231647[ebp], 0

; 463  : 
; 464  : 			for ( int n=0;n<OBJ_STARTUSERINDEX;n++) //loc7

  011f5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _n$231648[ebp], 0
  011fc	eb 09		 jmp	 SHORT $LN14@ProcState_@2
$LN13@ProcState_@2:
  011fe	8b 45 e4	 mov	 eax, DWORD PTR _n$231648[ebp]
  01201	83 c0 01	 add	 eax, 1
  01204	89 45 e4	 mov	 DWORD PTR _n$231648[ebp], eax
$LN14@ProcState_@2:
  01207	81 7d e4 b0 36
	00 00		 cmp	 DWORD PTR _n$231648[ebp], 14000 ; 000036b0H
  0120e	0f 8d 81 00 00
	00		 jge	 $LN12@ProcState_@2

; 465  : 			{
; 466  : 				if ( gObj[n].Class == 476 )

  01214	8b 45 e4	 mov	 eax, DWORD PTR _n$231648[ebp]
  01217	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0121d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01223	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0122b	81 fa dc 01 00
	00		 cmp	 edx, 476		; 000001dcH
  01231	75 5d		 jne	 SHORT $LN11@ProcState_@2

; 467  : 				{
; 468  : 					if ( gObj[n].m_bIsInMonsterHerd )

  01233	8b 45 e4	 mov	 eax, DWORD PTR _n$231648[ebp]
  01236	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0123c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01242	83 bc 01 e8 10
	00 00 00	 cmp	 DWORD PTR [ecx+eax+4328], 0
  0124a	74 44		 je	 SHORT $LN11@ProcState_@2

; 469  : 					{
; 470  : 						if ( gObj[n].Live && gObj[n].MapNumber == vtHerdInfo->GetMapNumber() )

  0124c	8b 45 e4	 mov	 eax, DWORD PTR _n$231648[ebp]
  0124f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01255	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0125b	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  01260	85 d2		 test	 edx, edx
  01262	74 2c		 je	 SHORT $LN11@ProcState_@2
  01264	8b 45 e4	 mov	 eax, DWORD PTR _n$231648[ebp]
  01267	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0126d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01273	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  0127b	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  0127e	e8 00 00 00 00	 call	 ?GetMapNumber@CXMasMonsterHerd@@QAEHXZ ; CXMasMonsterHerd::GetMapNumber
  01283	3b f0		 cmp	 esi, eax
  01285	75 09		 jne	 SHORT $LN11@ProcState_@2

; 471  : 						{
; 472  : 							bLive = TRUE;

  01287	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bLive$231647[ebp], 1

; 473  : 							break;

  0128e	eb 05		 jmp	 SHORT $LN12@ProcState_@2
$LN11@ProcState_@2:

; 474  : 						}
; 475  : 					}
; 476  : 				}
; 477  : 			}

  01290	e9 69 ff ff ff	 jmp	 $LN13@ProcState_@2
$LN12@ProcState_@2:

; 478  : 			LogAddTD("[XMasAttackEvent] - per 30'S Inform MapNumber:%d, X:%d, Y:%d, Boss Live:%d", vtHerdInfo->GetMapNumber(), vtHerdInfo->GetX(), vtHerdInfo->GetY(), bLive);

  01295	8b 45 e8	 mov	 eax, DWORD PTR _bLive$231647[ebp]
  01298	50		 push	 eax
  01299	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  0129c	e8 00 00 00 00	 call	 ?GetY@CXMasMonsterHerd@@QAEEXZ ; CXMasMonsterHerd::GetY
  012a1	0f b6 c8	 movzx	 ecx, al
  012a4	51		 push	 ecx
  012a5	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  012a8	e8 00 00 00 00	 call	 ?GetX@CXMasMonsterHerd@@QAEEXZ ; CXMasMonsterHerd::GetX
  012ad	0f b6 d0	 movzx	 edx, al
  012b0	52		 push	 edx
  012b1	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  012b4	e8 00 00 00 00	 call	 ?GetMapNumber@CXMasMonsterHerd@@QAEHXZ ; CXMasMonsterHerd::GetMapNumber
  012b9	50		 push	 eax
  012ba	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CAFMAFGG@?$FLXMasAttackEvent?$FN?5?9?5per?530?8S?5Inf@
  012bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  012c5	83 c4 14	 add	 esp, 20			; 00000014H

; 479  : 			this->EventLog("[%s] X:%d, Y:%d",vtHerdInfo->GetMapNumber(), vtHerdInfo->GetX(), vtHerdInfo->GetY());

  012c8	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  012cb	e8 00 00 00 00	 call	 ?GetY@CXMasMonsterHerd@@QAEEXZ ; CXMasMonsterHerd::GetY
  012d0	0f b6 c0	 movzx	 eax, al
  012d3	50		 push	 eax
  012d4	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  012d7	e8 00 00 00 00	 call	 ?GetX@CXMasMonsterHerd@@QAEEXZ ; CXMasMonsterHerd::GetX
  012dc	0f b6 c8	 movzx	 ecx, al
  012df	51		 push	 ecx
  012e0	8b 4d ec	 mov	 ecx, DWORD PTR _vtHerdInfo$231646[ebp]
  012e3	e8 00 00 00 00	 call	 ?GetMapNumber@CXMasMonsterHerd@@QAEHXZ ; CXMasMonsterHerd::GetMapNumber
  012e8	50		 push	 eax
  012e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HADDAGD@?$LB?$LK?$LE?$NM?$LI?q?$MA?$PL?A?v?$FL?$CFs?$FN?5X?3?$CFd?0?5Y?3?$CFd?$AA@
  012ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012f1	e8 00 00 00 00	 call	 ?EventLog@CXMasAttackEvent@@QAEXPADHEE@Z ; CXMasAttackEvent::EventLog

; 480  : 		}

  012f6	e9 c2 fe ff ff	 jmp	 $LN16@ProcState_@2
$LN15@ProcState_@2:

; 481  : 		LogAddTD("[XMasAttackEvent] - NotifySec: %d", s_iTIME_REMAIN);

  012fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_iTIME_REMAIN@?7??ProcState_Playing@CXMasAttackEvent@@QAEXXZ@4HA
  01300	50		 push	 eax
  01301	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NCANOPGD@?$FLXMasAttackEvent?$FN?5?9?5NotifySec?3?5?$CF@
  01306	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0130c	83 c4 08	 add	 esp, 8
$LN18@ProcState_@2:

; 482  : 	}
; 483  : 
; 484  : 	if (this->m_bMonsterToDest == FALSE && iTICK_MSEC <= this->m_iTIME_MONSTER_TO_DEST)

  0130f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01312	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  01316	0f 85 f7 00 00
	00		 jne	 $LN8@ProcState_@2
  0131c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0131f	8b 4d f8	 mov	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  01322	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  01328	0f 8f e5 00 00
	00		 jg	 $LN8@ProcState_@2

; 485  : 	{		
; 486  : 		for ( int i=0;i<this->m_vtXMasMonsterHerd.size();i++) //loc8

  0132e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$231659[ebp], 0
  01335	eb 09		 jmp	 SHORT $LN7@ProcState_@2
$LN6@ProcState_@2:
  01337	8b 45 e0	 mov	 eax, DWORD PTR _i$231659[ebp]
  0133a	83 c0 01	 add	 eax, 1
  0133d	89 45 e0	 mov	 DWORD PTR _i$231659[ebp], eax
$LN7@ProcState_@2:
  01340	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01343	83 c1 48	 add	 ecx, 72			; 00000048H
  01346	e8 00 00 00 00	 call	 ?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
  0134b	39 45 e0	 cmp	 DWORD PTR _i$231659[ebp], eax
  0134e	0f 83 b5 00 00
	00		 jae	 $LN5@ProcState_@2

; 487  : 		{
; 488  : 			CXMasMonsterHerd * vtHerdInfo = this->m_vtXMasMonsterHerd[i]; //perfect loc9

  01354	8b 45 e0	 mov	 eax, DWORD PTR _i$231659[ebp]
  01357	50		 push	 eax
  01358	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0135b	83 c1 48	 add	 ecx, 72			; 00000048H
  0135e	e8 00 00 00 00	 call	 ??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[]
  01363	8b 08		 mov	 ecx, DWORD PTR [eax]
  01365	89 4d dc	 mov	 DWORD PTR _vtHerdInfo$231663[ebp], ecx

; 489  : 
; 490  : 			BYTE ucRAND; //loc11
; 491  : 			BYTE iRandX; //loc12
; 492  : 			BYTE iRandY; //loc13			
; 493  : 
; 494  : 			ucRAND = rand()%4;

  01368	e8 00 00 00 00	 call	 _rand
  0136d	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  01372	79 05		 jns	 SHORT $LN23@ProcState_@2
  01374	48		 dec	 eax
  01375	83 c8 fc	 or	 eax, -4			; fffffffcH
  01378	40		 inc	 eax
$LN23@ProcState_@2:
  01379	88 45 db	 mov	 BYTE PTR _ucRAND$231664[ebp], al

; 495  : 			iRandX = g_XMasMapDestPosition[i][ucRAND*2];

  0137c	8b 45 e0	 mov	 eax, DWORD PTR _i$231659[ebp]
  0137f	c1 e0 05	 shl	 eax, 5
  01382	0f b6 4d db	 movzx	 ecx, BYTE PTR _ucRAND$231664[ebp]
  01386	d1 e1		 shl	 ecx, 1
  01388	8a 94 88 00 00
	00 00		 mov	 dl, BYTE PTR _g_XMasMapDestPosition[eax+ecx*4]
  0138f	88 55 da	 mov	 BYTE PTR _iRandX$231665[ebp], dl

; 496  : 			iRandY = g_XMasMapDestPosition[i][ucRAND*2+1];

  01392	8b 45 e0	 mov	 eax, DWORD PTR _i$231659[ebp]
  01395	c1 e0 05	 shl	 eax, 5
  01398	0f b6 4d db	 movzx	 ecx, BYTE PTR _ucRAND$231664[ebp]
  0139c	d1 e1		 shl	 ecx, 1
  0139e	8a 94 88 04 00
	00 00		 mov	 dl, BYTE PTR _g_XMasMapDestPosition[eax+ecx*4+4]
  013a5	88 55 d9	 mov	 BYTE PTR _iRandY$231666[ebp], dl

; 497  : 
; 498  : 			if ( vtHerdInfo->MoveHerd(iRandX, iRandY) != FALSE )

  013a8	0f b6 45 d9	 movzx	 eax, BYTE PTR _iRandY$231666[ebp]
  013ac	50		 push	 eax
  013ad	0f b6 4d da	 movzx	 ecx, BYTE PTR _iRandX$231665[ebp]
  013b1	51		 push	 ecx
  013b2	8b 55 dc	 mov	 edx, DWORD PTR _vtHerdInfo$231663[ebp]
  013b5	8b 02		 mov	 eax, DWORD PTR [edx]
  013b7	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231663[ebp]
  013ba	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  013bd	ff d2		 call	 edx
  013bf	85 c0		 test	 eax, eax
  013c1	74 41		 je	 SHORT $LN4@ProcState_@2

; 499  : 			{
; 500  : 				LogAddTD("[XMasAttackEvent] - Monster Herd Move MapNumber:%d, X:%d, Y:%d",
; 501  : 					vtHerdInfo->GetMapNumber(), iRandX, iRandY);

  013c3	0f b6 45 d9	 movzx	 eax, BYTE PTR _iRandY$231666[ebp]
  013c7	50		 push	 eax
  013c8	0f b6 4d da	 movzx	 ecx, BYTE PTR _iRandX$231665[ebp]
  013cc	51		 push	 ecx
  013cd	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231663[ebp]
  013d0	e8 00 00 00 00	 call	 ?GetMapNumber@CXMasMonsterHerd@@QAEHXZ ; CXMasMonsterHerd::GetMapNumber
  013d5	50		 push	 eax
  013d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@COOJAPLA@?$FLXMasAttackEvent?$FN?5?9?5Monster?5Herd@
  013db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  013e1	83 c4 10	 add	 esp, 16			; 00000010H

; 502  : 				this->EventLog("[%s] X:%d, Y:%d",vtHerdInfo->GetMapNumber(), iRandX, iRandY);

  013e4	0f b6 45 d9	 movzx	 eax, BYTE PTR _iRandY$231666[ebp]
  013e8	50		 push	 eax
  013e9	0f b6 4d da	 movzx	 ecx, BYTE PTR _iRandX$231665[ebp]
  013ed	51		 push	 ecx
  013ee	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231663[ebp]
  013f1	e8 00 00 00 00	 call	 ?GetMapNumber@CXMasMonsterHerd@@QAEHXZ ; CXMasMonsterHerd::GetMapNumber
  013f6	50		 push	 eax
  013f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HADDAGD@?$LB?$LK?$LE?$NM?$LI?q?$MA?$PL?A?v?$FL?$CFs?$FN?5X?3?$CFd?0?5Y?3?$CFd?$AA@
  013fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013ff	e8 00 00 00 00	 call	 ?EventLog@CXMasAttackEvent@@QAEXPADHEE@Z ; CXMasAttackEvent::EventLog
$LN4@ProcState_@2:

; 503  : 			}
; 504  : 		}

  01404	e9 2e ff ff ff	 jmp	 $LN6@ProcState_@2
$LN5@ProcState_@2:

; 505  : 
; 506  : 		this->m_bMonsterToDest = TRUE;

  01409	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0140c	c7 40 70 01 00
	00 00		 mov	 DWORD PTR [eax+112], 1
$LN8@ProcState_@2:

; 507  : 	}
; 508  : 
; 509  : 	if ( iTICK_MSEC == 0 )

  01413	83 7d f8 00	 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 0
  01417	75 2d		 jne	 SHORT $LN21@ProcState_@2

; 510  : 	{
; 511  : 		if ( this->m_bDoEvent != FALSE )

  01419	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0141c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  01420	74 0c		 je	 SHORT $LN2@ProcState_@2

; 512  : 		{
; 513  : 			this->SetState(ATTACKEVENT_STATE_CLOSED);

  01422	6a 01		 push	 1
  01424	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01427	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 514  : 		}
; 515  : 		else

  0142c	eb 0a		 jmp	 SHORT $LN1@ProcState_@2
$LN2@ProcState_@2:

; 516  : 		{
; 517  : 			this->SetState(ATTACKEVENT_STATE_NONE);

  0142e	6a 00		 push	 0
  01430	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01433	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState
$LN1@ProcState_@2:

; 518  : 		}
; 519  : 
; 520  : 		LogAddTD("[XMasAttackEvent] - Event Ended");

  01438	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GNBALKOM@?$FLXMasAttackEvent?$FN?5?9?5Event?5Ended?$AA@
  0143d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01443	83 c4 04	 add	 esp, 4
$LN21@ProcState_@2:

; 521  : 	}
; 522  : }

  01446	5f		 pop	 edi
  01447	5e		 pop	 esi
  01448	5b		 pop	 ebx
  01449	8b e5		 mov	 esp, ebp
  0144b	5d		 pop	 ebp
  0144c	c3		 ret	 0
?ProcState_Playing@CXMasAttackEvent@@QAEXXZ ENDP	; CXMasAttackEvent::ProcState_Playing
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?GetX@CXMasMonsterHerd@@QAEEXZ PROC			; CXMasMonsterHerd::GetX
; _this$ = ecx

; 525  : {

  01450	55		 push	 ebp
  01451	8b ec		 mov	 ebp, esp
  01453	83 ec 44	 sub	 esp, 68			; 00000044H
  01456	53		 push	 ebx
  01457	56		 push	 esi
  01458	57		 push	 edi
  01459	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 526  : 	return this->m_iCUR_X;

  0145c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0145f	8a 40 0c	 mov	 al, BYTE PTR [eax+12]

; 527  : }

  01462	5f		 pop	 edi
  01463	5e		 pop	 esi
  01464	5b		 pop	 ebx
  01465	8b e5		 mov	 esp, ebp
  01467	5d		 pop	 ebp
  01468	c3		 ret	 0
?GetX@CXMasMonsterHerd@@QAEEXZ ENDP			; CXMasMonsterHerd::GetX
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?GetY@CXMasMonsterHerd@@QAEEXZ PROC			; CXMasMonsterHerd::GetY
; _this$ = ecx

; 530  : {

  01470	55		 push	 ebp
  01471	8b ec		 mov	 ebp, esp
  01473	83 ec 44	 sub	 esp, 68			; 00000044H
  01476	53		 push	 ebx
  01477	56		 push	 esi
  01478	57		 push	 edi
  01479	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 531  : 	return this->m_iCUR_Y;

  0147c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0147f	8a 40 10	 mov	 al, BYTE PTR [eax+16]

; 532  : }

  01482	5f		 pop	 edi
  01483	5e		 pop	 esi
  01484	5b		 pop	 ebx
  01485	8b e5		 mov	 esp, ebp
  01487	5d		 pop	 ebp
  01488	c3		 ret	 0
?GetY@CXMasMonsterHerd@@QAEEXZ ENDP			; CXMasMonsterHerd::GetY
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?GetMapNumber@CXMasMonsterHerd@@QAEHXZ PROC		; CXMasMonsterHerd::GetMapNumber
; _this$ = ecx

; 535  : {

  01490	55		 push	 ebp
  01491	8b ec		 mov	 ebp, esp
  01493	83 ec 44	 sub	 esp, 68			; 00000044H
  01496	53		 push	 ebx
  01497	56		 push	 esi
  01498	57		 push	 edi
  01499	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 536  : 	return this->m_iMapNumber;

  0149c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0149f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 537  : }

  014a2	5f		 pop	 edi
  014a3	5e		 pop	 esi
  014a4	5b		 pop	 ebx
  014a5	8b e5		 mov	 esp, ebp
  014a7	5d		 pop	 ebp
  014a8	c3		 ret	 0
?GetMapNumber@CXMasMonsterHerd@@QAEHXZ ENDP		; CXMasMonsterHerd::GetMapNumber
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?SetState_None@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::SetState_None
; _this$ = ecx

; 540  : {

  014b0	55		 push	 ebp
  014b1	8b ec		 mov	 ebp, esp
  014b3	83 ec 44	 sub	 esp, 68			; 00000044H
  014b6	53		 push	 ebx
  014b7	56		 push	 esi
  014b8	57		 push	 edi
  014b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 541  : 	this->StopEvent();

  014bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014bf	8b 10		 mov	 edx, DWORD PTR [eax]
  014c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014c4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  014c7	ff d0		 call	 eax

; 542  : }

  014c9	5f		 pop	 edi
  014ca	5e		 pop	 esi
  014cb	5b		 pop	 ebx
  014cc	8b e5		 mov	 esp, ebp
  014ce	5d		 pop	 ebp
  014cf	c3		 ret	 0
?SetState_None@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::SetState_None
_TEXT	ENDS
PUBLIC	?CheckSync@CXMasAttackEvent@@QAEXXZ		; CXMasAttackEvent::CheckSync
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_Closed@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::SetState_Closed
; _this$ = ecx

; 545  : {

  014d0	55		 push	 ebp
  014d1	8b ec		 mov	 ebp, esp
  014d3	83 ec 44	 sub	 esp, 68			; 00000044H
  014d6	53		 push	 ebx
  014d7	56		 push	 esi
  014d8	57		 push	 edi
  014d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 546  : 	this->StopEvent();

  014dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014df	8b 10		 mov	 edx, DWORD PTR [eax]
  014e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014e4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  014e7	ff d0		 call	 eax

; 547  : 
; 548  : 	if ( this->m_bDoEvent )

  014e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014ec	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  014f0	74 0a		 je	 SHORT $LN2@SetState_C

; 549  : 	{
; 550  : 		this->CheckSync();

  014f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014f5	e8 00 00 00 00	 call	 ?CheckSync@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::CheckSync

; 551  : 	}
; 552  : 	else

  014fa	eb 0a		 jmp	 SHORT $LN3@SetState_C
$LN2@SetState_C:

; 553  : 	{
; 554  : 		this->SetState(ATTACKEVENT_STATE_NONE);

  014fc	6a 00		 push	 0
  014fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01501	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState
$LN3@SetState_C:

; 555  : 	}
; 556  : }

  01506	5f		 pop	 edi
  01507	5e		 pop	 esi
  01508	5b		 pop	 ebx
  01509	8b e5		 mov	 esp, ebp
  0150b	5d		 pop	 ebp
  0150c	c3		 ret	 0
?SetState_Closed@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::SetState_Closed
_TEXT	ENDS
EXTRN	?SetMiliSeconds@CEventTimer@@QAEXH@Z:PROC	; CEventTimer::SetMiliSeconds
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_Playing@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::SetState_Playing
; _this$ = ecx

; 559  : {

  01510	55		 push	 ebp
  01511	8b ec		 mov	 ebp, esp
  01513	83 ec 44	 sub	 esp, 68			; 00000044H
  01516	53		 push	 ebx
  01517	56		 push	 esi
  01518	57		 push	 edi
  01519	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 	this->m_EventTimer.SetMiliSeconds(this->m_iTIME_MIN_PLAY);

  0151c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0151f	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01525	51		 push	 ecx
  01526	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01529	83 c1 58	 add	 ecx, 88			; 00000058H
  0152c	e8 00 00 00 00	 call	 ?SetMiliSeconds@CEventTimer@@QAEXH@Z ; CEventTimer::SetMiliSeconds

; 561  : 	this->StartEvent();

  01531	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01534	8b 10		 mov	 edx, DWORD PTR [eax]
  01536	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01539	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0153c	ff d0		 call	 eax

; 562  : }

  0153e	5f		 pop	 edi
  0153f	5e		 pop	 esi
  01540	5b		 pop	 ebx
  01541	8b e5		 mov	 esp, ebp
  01543	5d		 pop	 ebp
  01544	c3		 ret	 0
?SetState_Playing@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::SetState_Playing
_TEXT	ENDS
PUBLIC	?MonsterHerdMoveCheck@CXMasAttackEvent@@QAEHPAVCXMasMonsterHerd@@PAUXMASMONSTER_MAP_INFO@@@Z ; CXMasAttackEvent::MonsterHerdMoveCheck
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iRADIUS$231707 = -44					; size = 4
_iDIVIDE$231705 = -40					; size = 4
_vtHerdInfo$231703 = -36				; size = 4
_MonsterMapInfo$231702 = -32				; size = 20
_i$231698 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Move@CXMasAttackEvent@@QAEXXZ PROC			; CXMasAttackEvent::Move
; _this$ = ecx

; 566  : {

  01550	55		 push	 ebp
  01551	8b ec		 mov	 ebp, esp
  01553	83 ec 6c	 sub	 esp, 108		; 0000006cH
  01556	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0155b	33 c5		 xor	 eax, ebp
  0155d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01560	53		 push	 ebx
  01561	56		 push	 esi
  01562	57		 push	 edi
  01563	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 567  : 	if(this->m_bDoEvent == FALSE)

  01566	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01569	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0156d	75 05		 jne	 SHORT $LN8@Move

; 568  : 	{
; 569  : 		return;

  0156f	e9 ec 00 00 00	 jmp	 $LN9@Move
$LN8@Move:

; 570  : 	}
; 571  : 
; 572  : 	if(this->m_bMonsterToDest != FALSE)

  01574	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01577	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  0157b	74 05		 je	 SHORT $LN7@Move

; 573  : 	{
; 574  : 		return;

  0157d	e9 de 00 00 00	 jmp	 $LN9@Move
$LN7@Move:

; 575  : 	}
; 576  : 
; 577  : 	for(int i = 0; i < this->m_vtXMasMonsterHerd.size(); i++)

  01582	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231698[ebp], 0
  01589	eb 09		 jmp	 SHORT $LN6@Move
$LN5@Move:
  0158b	8b 45 f4	 mov	 eax, DWORD PTR _i$231698[ebp]
  0158e	83 c0 01	 add	 eax, 1
  01591	89 45 f4	 mov	 DWORD PTR _i$231698[ebp], eax
$LN6@Move:
  01594	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01597	83 c1 48	 add	 ecx, 72			; 00000048H
  0159a	e8 00 00 00 00	 call	 ?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
  0159f	39 45 f4	 cmp	 DWORD PTR _i$231698[ebp], eax
  015a2	0f 83 b8 00 00
	00		 jae	 $LN9@Move

; 578  : 	{
; 579  : 		XMASMONSTER_MAP_INFO MonsterMapInfo = this->m_vtXMasMonsterMapInfo[i]; //perfect

  015a8	8b 45 f4	 mov	 eax, DWORD PTR _i$231698[ebp]
  015ab	50		 push	 eax
  015ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  015af	83 c1 5c	 add	 ecx, 92			; 0000005cH
  015b2	e8 00 00 00 00	 call	 ??A?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEAAUXMASMONSTER_MAP_INFO@@I@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::operator[]
  015b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  015b9	89 4d e0	 mov	 DWORD PTR _MonsterMapInfo$231702[ebp], ecx
  015bc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  015bf	89 55 e4	 mov	 DWORD PTR _MonsterMapInfo$231702[ebp+4], edx
  015c2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  015c5	89 4d e8	 mov	 DWORD PTR _MonsterMapInfo$231702[ebp+8], ecx
  015c8	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  015cb	89 55 ec	 mov	 DWORD PTR _MonsterMapInfo$231702[ebp+12], edx
  015ce	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  015d1	89 45 f0	 mov	 DWORD PTR _MonsterMapInfo$231702[ebp+16], eax

; 580  : 		
; 581  : 		CXMasMonsterHerd * vtHerdInfo = this->m_vtXMasMonsterHerd[i]; //perfect

  015d4	8b 45 f4	 mov	 eax, DWORD PTR _i$231698[ebp]
  015d7	50		 push	 eax
  015d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  015db	83 c1 48	 add	 ecx, 72			; 00000048H
  015de	e8 00 00 00 00	 call	 ??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[]
  015e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  015e5	89 4d dc	 mov	 DWORD PTR _vtHerdInfo$231703[ebp], ecx

; 582  : 
; 583  : 		if(this->MonsterHerdMoveCheck(vtHerdInfo, &MonsterMapInfo) == FALSE)

  015e8	8d 45 e0	 lea	 eax, DWORD PTR _MonsterMapInfo$231702[ebp]
  015eb	50		 push	 eax
  015ec	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231703[ebp]
  015ef	51		 push	 ecx
  015f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  015f3	e8 00 00 00 00	 call	 ?MonsterHerdMoveCheck@CXMasAttackEvent@@QAEHPAVCXMasMonsterHerd@@PAUXMASMONSTER_MAP_INFO@@@Z ; CXMasAttackEvent::MonsterHerdMoveCheck
  015f8	85 c0		 test	 eax, eax
  015fa	75 02		 jne	 SHORT $LN3@Move

; 584  : 		{
; 585  : 			break;

  015fc	eb 62		 jmp	 SHORT $LN9@Move
$LN3@Move:

; 586  : 		}
; 587  : 
; 588  : 		int iDIVIDE = this->m_iRADIUS_MAX - this->m_iRADIUS_MIN;

  015fe	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01601	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01604	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  01607	2b 51 78	 sub	 edx, DWORD PTR [ecx+120]
  0160a	89 55 d8	 mov	 DWORD PTR _iDIVIDE$231705[ebp], edx

; 589  : 
; 590  : 		if ( iDIVIDE <= 0 )

  0160d	83 7d d8 00	 cmp	 DWORD PTR _iDIVIDE$231705[ebp], 0
  01611	7f 07		 jg	 SHORT $LN2@Move

; 591  : 			iDIVIDE = 1;

  01613	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _iDIVIDE$231705[ebp], 1
$LN2@Move:

; 592  : 
; 593  : 		int iRADIUS = iDIVIDE + this->m_iRADIUS_MIN;

  0161a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0161d	8b 4d d8	 mov	 ecx, DWORD PTR _iDIVIDE$231705[ebp]
  01620	03 48 78	 add	 ecx, DWORD PTR [eax+120]
  01623	89 4d d4	 mov	 DWORD PTR _iRADIUS$231707[ebp], ecx

; 594  : 
; 595  : 		if ( iRADIUS <= 3 )

  01626	83 7d d4 03	 cmp	 DWORD PTR _iRADIUS$231707[ebp], 3
  0162a	7f 07		 jg	 SHORT $LN1@Move

; 596  : 			iRADIUS = 3;

  0162c	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR _iRADIUS$231707[ebp], 3
$LN1@Move:

; 597  : 
; 598  : 		vtHerdInfo->SetRadius((rand() % (this->m_iRADIUS_MAX - this->m_iRADIUS_MIN)) + this->m_iRADIUS_MIN);

  01633	e8 00 00 00 00	 call	 _rand
  01638	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0163b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0163e	8b 49 7c	 mov	 ecx, DWORD PTR [ecx+124]
  01641	2b 4a 78	 sub	 ecx, DWORD PTR [edx+120]
  01644	99		 cdq
  01645	f7 f9		 idiv	 ecx
  01647	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0164a	03 50 78	 add	 edx, DWORD PTR [eax+120]
  0164d	52		 push	 edx
  0164e	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231703[ebp]
  01651	8b 11		 mov	 edx, DWORD PTR [ecx]
  01653	8b 4d dc	 mov	 ecx, DWORD PTR _vtHerdInfo$231703[ebp]
  01656	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01659	ff d0		 call	 eax

; 599  : 	}

  0165b	e9 2b ff ff ff	 jmp	 $LN5@Move
$LN9@Move:

; 600  : }

  01660	5f		 pop	 edi
  01661	5e		 pop	 esi
  01662	5b		 pop	 ebx
  01663	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01666	33 cd		 xor	 ecx, ebp
  01668	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0166d	8b e5		 mov	 esp, ebp
  0166f	5d		 pop	 ebp
  01670	c3		 ret	 0
?Move@CXMasAttackEvent@@QAEXXZ ENDP			; CXMasAttackEvent::Move
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_Msg$ = 8						; size = 4
_MapNumber$ = 12					; size = 4
_cX$ = 16						; size = 1
_cY$ = 20						; size = 1
?EventLog@CXMasAttackEvent@@QAEXPADHEE@Z PROC		; CXMasAttackEvent::EventLog
; _this$ = ecx

; 603  : {

  01680	55		 push	 ebp
  01681	8b ec		 mov	 ebp, esp
  01683	83 ec 44	 sub	 esp, 68			; 00000044H
  01686	53		 push	 ebx
  01687	56		 push	 esi
  01688	57		 push	 edi
  01689	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 604  : }

  0168c	5f		 pop	 edi
  0168d	5e		 pop	 esi
  0168e	5b		 pop	 ebx
  0168f	8b e5		 mov	 esp, ebp
  01691	5d		 pop	 ebp
  01692	c2 10 00	 ret	 16			; 00000010H
?EventLog@CXMasAttackEvent@@QAEXPADHEE@Z ENDP		; CXMasAttackEvent::EventLog
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEX$$QAPAVCXMasMonsterHerd@@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::push_back
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator!=
PUBLIC	?end@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
PUBLIC	?begin@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::begin
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__unwindtable$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ$0
__ehfuncinfo$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv132 = -108						; size = 4
$T235009 = -104						; size = 4
$T235010 = -100						; size = 4
$T235011 = -96						; size = 4
$T235012 = -92						; size = 4
_vtHerdInfo$231872 = -24				; size = 4
_it$231849 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ PROC	; CXMasAttackEvent::CreateMonsterHerd
; _this$ = ecx

; 607  : {

  016a0	55		 push	 ebp
  016a1	8b ec		 mov	 ebp, esp
  016a3	6a ff		 push	 -1
  016a5	68 00 00 00 00	 push	 __ehhandler$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ
  016aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  016b0	50		 push	 eax
  016b1	83 ec 60	 sub	 esp, 96			; 00000060H
  016b4	53		 push	 ebx
  016b5	56		 push	 esi
  016b6	57		 push	 edi
  016b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  016bc	33 c5		 xor	 eax, ebp
  016be	50		 push	 eax
  016bf	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  016c2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  016c8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 608  : 	EnterCriticalSection(&this->m_critMonsterAddData);

  016cb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  016ce	83 c0 10	 add	 eax, 16			; 00000010H
  016d1	50		 push	 eax
  016d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 609  : 
; 610  : 	for ( std::vector<XMASMONSTER_MAP_INFO>::iterator it = this->m_vtXMasMonsterMapInfo.begin(); it != this->m_vtXMasMonsterMapInfo.end() ; it++ )

  016d8	8d 45 ec	 lea	 eax, DWORD PTR _it$231849[ebp]
  016db	50		 push	 eax
  016dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  016df	83 c1 5c	 add	 ecx, 92			; 0000005cH
  016e2	e8 00 00 00 00	 call	 ?begin@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::begin
  016e7	eb 0e		 jmp	 SHORT $LN3@CreateMons
$LN2@CreateMons:
  016e9	6a 00		 push	 0
  016eb	8d 45 98	 lea	 eax, DWORD PTR $T235009[ebp]
  016ee	50		 push	 eax
  016ef	8d 4d ec	 lea	 ecx, DWORD PTR _it$231849[ebp]
  016f2	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
$LN3@CreateMons:
  016f7	8d 45 9c	 lea	 eax, DWORD PTR $T235010[ebp]
  016fa	50		 push	 eax
  016fb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  016fe	83 c1 5c	 add	 ecx, 92			; 0000005cH
  01701	e8 00 00 00 00	 call	 ?end@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::end
  01706	50		 push	 eax
  01707	8d 4d ec	 lea	 ecx, DWORD PTR _it$231849[ebp]
  0170a	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator!=
  0170f	0f b6 c8	 movzx	 ecx, al
  01712	85 c9		 test	 ecx, ecx
  01714	74 52		 je	 SHORT $LN1@CreateMons

; 611  : 	{
; 612  : 		CXMasMonsterHerd & vtHerdInfo = *(new CXMasMonsterHerd);

  01716	6a 48		 push	 72			; 00000048H
  01718	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0171d	83 c4 04	 add	 esp, 4
  01720	89 45 a4	 mov	 DWORD PTR $T235012[ebp], eax
  01723	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0172a	83 7d a4 00	 cmp	 DWORD PTR $T235012[ebp], 0
  0172e	74 0d		 je	 SHORT $LN6@CreateMons
  01730	8b 4d a4	 mov	 ecx, DWORD PTR $T235012[ebp]
  01733	e8 00 00 00 00	 call	 ??0CXMasMonsterHerd@@QAE@XZ ; CXMasMonsterHerd::CXMasMonsterHerd
  01738	89 45 94	 mov	 DWORD PTR tv132[ebp], eax
  0173b	eb 07		 jmp	 SHORT $LN7@CreateMons
$LN6@CreateMons:
  0173d	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$LN7@CreateMons:
  01744	8b 45 94	 mov	 eax, DWORD PTR tv132[ebp]
  01747	89 45 a0	 mov	 DWORD PTR $T235011[ebp], eax
  0174a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01751	8b 4d a0	 mov	 ecx, DWORD PTR $T235011[ebp]
  01754	89 4d e8	 mov	 DWORD PTR _vtHerdInfo$231872[ebp], ecx

; 613  : 		this->m_vtXMasMonsterHerd.push_back(&vtHerdInfo);

  01757	8d 45 e8	 lea	 eax, DWORD PTR _vtHerdInfo$231872[ebp]
  0175a	50		 push	 eax
  0175b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0175e	83 c1 48	 add	 ecx, 72			; 00000048H
  01761	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEX$$QAPAVCXMasMonsterHerd@@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::push_back

; 614  : 	}

  01766	eb 81		 jmp	 SHORT $LN2@CreateMons
$LN1@CreateMons:

; 615  : 
; 616  : 	LeaveCriticalSection(&this->m_critMonsterAddData);		

  01768	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0176b	83 c0 10	 add	 eax, 16			; 00000010H
  0176e	50		 push	 eax
  0176f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 617  : }

  01775	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01778	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0177f	59		 pop	 ecx
  01780	5f		 pop	 edi
  01781	5e		 pop	 esi
  01782	5b		 pop	 ebx
  01783	8b e5		 mov	 esp, ebp
  01785	5d		 pop	 ebp
  01786	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ$0:
  00051	8b 45 a4	 mov	 eax, DWORD PTR $T235012[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005a	59		 pop	 ecx
  0005b	c3		 ret	 0
__ehhandler$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ:
  0005c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00060	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00063	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ
  00072	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateMonsterHerd@CXMasAttackEvent@@QAEXXZ ENDP	; CXMasAttackEvent::CreateMonsterHerd
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEAAUXMASMONSTER_DATA@@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=
PUBLIC	?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
PUBLIC	?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T235021 = -88						; size = 4
$T235022 = -84						; size = 4
_iCount$232035 = -16					; size = 4
_pXMD$232034 = -12					; size = 4
_it$232011 = -8						; size = 4
_this$ = -4						; size = 4
_vtHerdInfo$ = 8					; size = 4
?AddMonsterToHerd@CXMasAttackEvent@@QAEXPAVCXMasMonsterHerd@@@Z PROC ; CXMasAttackEvent::AddMonsterToHerd
; _this$ = ecx

; 620  : {

  01790	55		 push	 ebp
  01791	8b ec		 mov	 ebp, esp
  01793	83 ec 58	 sub	 esp, 88			; 00000058H
  01796	53		 push	 ebx
  01797	56		 push	 esi
  01798	57		 push	 edi
  01799	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		EnterCriticalSection(&this->m_critMonsterAddData);

  0179c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0179f	83 c0 10	 add	 eax, 16			; 00000010H
  017a2	50		 push	 eax
  017a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 622  : 
; 623  : 		for ( std::vector<XMASMONSTER_DATA>::iterator it = this->m_vtMonsterAddData.begin() ; it != this->m_vtMonsterAddData.end() ; it++)

  017a9	8d 45 f8	 lea	 eax, DWORD PTR _it$232011[ebp]
  017ac	50		 push	 eax
  017ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017b0	83 c1 38	 add	 ecx, 56			; 00000038H
  017b3	e8 00 00 00 00	 call	 ?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin
  017b8	eb 0e		 jmp	 SHORT $LN6@AddMonster
$LN5@AddMonster:
  017ba	6a 00		 push	 0
  017bc	8d 45 a8	 lea	 eax, DWORD PTR $T235021[ebp]
  017bf	50		 push	 eax
  017c0	8d 4d f8	 lea	 ecx, DWORD PTR _it$232011[ebp]
  017c3	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
$LN6@AddMonster:
  017c8	8d 45 ac	 lea	 eax, DWORD PTR $T235022[ebp]
  017cb	50		 push	 eax
  017cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017cf	83 c1 38	 add	 ecx, 56			; 00000038H
  017d2	e8 00 00 00 00	 call	 ?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end
  017d7	50		 push	 eax
  017d8	8d 4d f8	 lea	 ecx, DWORD PTR _it$232011[ebp]
  017db	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=
  017e0	0f b6 c8	 movzx	 ecx, al
  017e3	85 c9		 test	 ecx, ecx
  017e5	74 4d		 je	 SHORT $LN4@AddMonster

; 624  : 		{
; 625  : 			XMASMONSTER_DATA * pXMD = &(*it);

  017e7	8d 4d f8	 lea	 ecx, DWORD PTR _it$232011[ebp]
  017ea	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEAAUXMASMONSTER_DATA@@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*
  017ef	89 45 f4	 mov	 DWORD PTR _pXMD$232034[ebp], eax

; 626  : 			int iCount = 100;

  017f2	c7 45 f0 64 00
	00 00		 mov	 DWORD PTR _iCount$232035[ebp], 100 ; 00000064H
$LN3@AddMonster:

; 627  : 
; 628  : 			while ( iCount-- != 0 )

  017f9	8b 45 f0	 mov	 eax, DWORD PTR _iCount$232035[ebp]
  017fc	8b 4d f0	 mov	 ecx, DWORD PTR _iCount$232035[ebp]
  017ff	83 e9 01	 sub	 ecx, 1
  01802	89 4d f0	 mov	 DWORD PTR _iCount$232035[ebp], ecx
  01805	85 c0		 test	 eax, eax
  01807	74 29		 je	 SHORT $LN2@AddMonster

; 629  : 			{
; 630  : 				if ( vtHerdInfo->AddMonster(pXMD->m_iType, pXMD->m_bDoRegen, pXMD->m_bDoAttackFirst) != FALSE )

  01809	8b 45 f4	 mov	 eax, DWORD PTR _pXMD$232034[ebp]
  0180c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0180f	51		 push	 ecx
  01810	8b 55 f4	 mov	 edx, DWORD PTR _pXMD$232034[ebp]
  01813	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01816	50		 push	 eax
  01817	8b 4d f4	 mov	 ecx, DWORD PTR _pXMD$232034[ebp]
  0181a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0181c	52		 push	 edx
  0181d	8b 45 08	 mov	 eax, DWORD PTR _vtHerdInfo$[ebp]
  01820	8b 10		 mov	 edx, DWORD PTR [eax]
  01822	8b 4d 08	 mov	 ecx, DWORD PTR _vtHerdInfo$[ebp]
  01825	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01828	ff d0		 call	 eax
  0182a	85 c0		 test	 eax, eax
  0182c	74 02		 je	 SHORT $LN1@AddMonster

; 631  : 				{
; 632  : 					break;

  0182e	eb 02		 jmp	 SHORT $LN2@AddMonster
$LN1@AddMonster:

; 633  : 				}
; 634  : 			}

  01830	eb c7		 jmp	 SHORT $LN3@AddMonster
$LN2@AddMonster:

; 635  : 		}

  01832	eb 86		 jmp	 SHORT $LN5@AddMonster
$LN4@AddMonster:

; 636  : 
; 637  : 		LeaveCriticalSection(&this->m_critMonsterAddData);

  01834	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01837	83 c0 10	 add	 eax, 16			; 00000010H
  0183a	50		 push	 eax
  0183b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 638  : }

  01841	5f		 pop	 edi
  01842	5e		 pop	 esi
  01843	5b		 pop	 ebx
  01844	8b e5		 mov	 esp, ebp
  01846	5d		 pop	 ebp
  01847	c2 04 00	 ret	 4
?AddMonsterToHerd@CXMasAttackEvent@@QAEXPAVCXMasMonsterHerd@@@Z ENDP ; CXMasAttackEvent::AddMonsterToHerd
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv154 = -100						; size = 4
$T235024 = -96						; size = 4
$T235025 = -92						; size = 4
$T235026 = -88						; size = 4
$T235027 = -84						; size = 4
$T235028 = -80						; size = 4
_pXMH$232053 = -12					; size = 4
_it$ = -8						; size = 4
_this$ = -4						; size = 4
?ClearMonsterHerd@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::ClearMonsterHerd
; _this$ = ecx

; 641  : {

  01850	55		 push	 ebp
  01851	8b ec		 mov	 ebp, esp
  01853	83 ec 64	 sub	 esp, 100		; 00000064H
  01856	53		 push	 ebx
  01857	56		 push	 esi
  01858	57		 push	 edi
  01859	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 	EnterCriticalSection(&this->m_critMonsterAddData);

  0185c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0185f	83 c0 10	 add	 eax, 16			; 00000010H
  01862	50		 push	 eax
  01863	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 643  : 
; 644  : 	std::vector<CXMasMonsterHerd*>::iterator it = this->m_vtXMasMonsterHerd.begin();

  01869	8d 45 f8	 lea	 eax, DWORD PTR _it$[ebp]
  0186c	50		 push	 eax
  0186d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01870	83 c1 48	 add	 ecx, 72			; 00000048H
  01873	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::begin
$LN2@ClearMonst:

; 645  : 
; 646  : 	while (it != this->m_vtXMasMonsterHerd.end())

  01878	8d 45 a0	 lea	 eax, DWORD PTR $T235024[ebp]
  0187b	50		 push	 eax
  0187c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0187f	83 c1 48	 add	 ecx, 72			; 00000048H
  01882	e8 00 00 00 00	 call	 ?end@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::end
  01887	50		 push	 eax
  01888	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0188b	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator!=
  01890	0f b6 c8	 movzx	 ecx, al
  01893	85 c9		 test	 ecx, ecx
  01895	74 54		 je	 SHORT $LN1@ClearMonst

; 647  : 	{
; 648  : 		CXMasMonsterHerd * pXMH = *it;

  01897	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0189a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEAAPAVCXMasMonsterHerd@@XZ ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*
  0189f	8b 00		 mov	 eax, DWORD PTR [eax]
  018a1	89 45 f4	 mov	 DWORD PTR _pXMH$232053[ebp], eax

; 649  : 		this->m_vtXMasMonsterHerd.erase(it);

  018a4	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  018a7	89 45 a4	 mov	 DWORD PTR $T235025[ebp], eax
  018aa	8b 4d a4	 mov	 ecx, DWORD PTR $T235025[ebp]
  018ad	51		 push	 ecx
  018ae	8d 55 a8	 lea	 edx, DWORD PTR $T235026[ebp]
  018b1	52		 push	 edx
  018b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  018b5	83 c1 48	 add	 ecx, 72			; 00000048H
  018b8	e8 00 00 00 00	 call	 ?erase@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::erase

; 650  : 		delete pXMH;

  018bd	8b 45 f4	 mov	 eax, DWORD PTR _pXMH$232053[ebp]
  018c0	89 45 b0	 mov	 DWORD PTR $T235028[ebp], eax
  018c3	8b 4d b0	 mov	 ecx, DWORD PTR $T235028[ebp]
  018c6	89 4d ac	 mov	 DWORD PTR $T235027[ebp], ecx
  018c9	83 7d ac 00	 cmp	 DWORD PTR $T235027[ebp], 0
  018cd	74 13		 je	 SHORT $LN5@ClearMonst
  018cf	6a 01		 push	 1
  018d1	8b 55 ac	 mov	 edx, DWORD PTR $T235027[ebp]
  018d4	8b 02		 mov	 eax, DWORD PTR [edx]
  018d6	8b 4d ac	 mov	 ecx, DWORD PTR $T235027[ebp]
  018d9	8b 10		 mov	 edx, DWORD PTR [eax]
  018db	ff d2		 call	 edx
  018dd	89 45 9c	 mov	 DWORD PTR tv154[ebp], eax
  018e0	eb 07		 jmp	 SHORT $LN6@ClearMonst
$LN5@ClearMonst:
  018e2	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
$LN6@ClearMonst:

; 651  : 	}

  018e9	eb 8d		 jmp	 SHORT $LN2@ClearMonst
$LN1@ClearMonst:

; 652  : 
; 653  : 	LeaveCriticalSection(&this->m_critMonsterAddData);

  018eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018ee	83 c0 10	 add	 eax, 16			; 00000010H
  018f1	50		 push	 eax
  018f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 654  : }

  018f8	5f		 pop	 edi
  018f9	5e		 pop	 esi
  018fa	5b		 pop	 ebx
  018fb	8b e5		 mov	 esp, ebp
  018fd	5d		 pop	 ebp
  018fe	c3		 ret	 0
?ClearMonsterHerd@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::ClearMonsterHerd
; Function compile flags: /Odtp /ZI
_iCY$ = -12						; size = 1
_iCX$ = -11						; size = 1
_iRandY$ = -10						; size = 1
_iRandX$ = -9						; size = 1
_iCount$ = -8						; size = 4
_this$ = -4						; size = 4
_vtHerdInfo$ = 8					; size = 4
_MonsterMapInfo$ = 12					; size = 4
?MonsterHerdMoveCheck@CXMasAttackEvent@@QAEHPAVCXMasMonsterHerd@@PAUXMASMONSTER_MAP_INFO@@@Z PROC ; CXMasAttackEvent::MonsterHerdMoveCheck
; _this$ = ecx

; 657  : {

  01900	55		 push	 ebp
  01901	8b ec		 mov	 ebp, esp
  01903	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01906	53		 push	 ebx
  01907	56		 push	 esi
  01908	57		 push	 edi
  01909	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 658  : 	int iCount = 1000; //2

  0190c	c7 45 f8 e8 03
	00 00		 mov	 DWORD PTR _iCount$[ebp], 1000 ; 000003e8H

; 659  : 	BYTE iRandX; //3
; 660  : 	BYTE iRandY; //4
; 661  : 	BYTE iCX; //5
; 662  : 	BYTE iCY; //6
; 663  : 
; 664  : 	if(vtHerdInfo->GetCurrentLocation(iCX, iCY) == FALSE)

  01913	8d 45 f4	 lea	 eax, DWORD PTR _iCY$[ebp]
  01916	50		 push	 eax
  01917	8d 4d f5	 lea	 ecx, DWORD PTR _iCX$[ebp]
  0191a	51		 push	 ecx
  0191b	8b 55 08	 mov	 edx, DWORD PTR _vtHerdInfo$[ebp]
  0191e	8b 02		 mov	 eax, DWORD PTR [edx]
  01920	8b 4d 08	 mov	 ecx, DWORD PTR _vtHerdInfo$[ebp]
  01923	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  01926	ff d2		 call	 edx
  01928	85 c0		 test	 eax, eax
  0192a	75 07		 jne	 SHORT $LN7@MonsterHer@2

; 665  : 	{
; 666  : 		return FALSE;

  0192c	33 c0		 xor	 eax, eax
  0192e	e9 e4 00 00 00	 jmp	 $LN9@MonsterHer@2
$LN7@MonsterHer@2:

; 667  : 	}
; 668  : 
; 669  : 	while(iCount-- != 0)

  01933	8b 45 f8	 mov	 eax, DWORD PTR _iCount$[ebp]
  01936	8b 4d f8	 mov	 ecx, DWORD PTR _iCount$[ebp]
  01939	83 e9 01	 sub	 ecx, 1
  0193c	89 4d f8	 mov	 DWORD PTR _iCount$[ebp], ecx
  0193f	85 c0		 test	 eax, eax
  01941	0f 84 b4 00 00
	00		 je	 $LN6@MonsterHer@2

; 670  : 	{
; 671  : 		iRandX = (rand() % this->m_iMOVE_RAND_SIZE) * ( (rand() % 3 -1) * -1 ) + iCX;

  01947	e8 00 00 00 00	 call	 _rand
  0194c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0194f	99		 cdq
  01950	f7 79 74	 idiv	 DWORD PTR [ecx+116]
  01953	8b da		 mov	 ebx, edx
  01955	e8 00 00 00 00	 call	 _rand
  0195a	99		 cdq
  0195b	b9 03 00 00 00	 mov	 ecx, 3
  01960	f7 f9		 idiv	 ecx
  01962	83 ea 01	 sub	 edx, 1
  01965	6b d2 ff	 imul	 edx, -1
  01968	0f af da	 imul	 ebx, edx
  0196b	0f b6 55 f5	 movzx	 edx, BYTE PTR _iCX$[ebp]
  0196f	03 da		 add	 ebx, edx
  01971	88 5d f7	 mov	 BYTE PTR _iRandX$[ebp], bl

; 672  : 		iRandY = (rand() % this->m_iMOVE_RAND_SIZE) * ( (rand() % 3 -1) * -1 ) + iCY;

  01974	e8 00 00 00 00	 call	 _rand
  01979	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0197c	99		 cdq
  0197d	f7 79 74	 idiv	 DWORD PTR [ecx+116]
  01980	8b da		 mov	 ebx, edx
  01982	e8 00 00 00 00	 call	 _rand
  01987	99		 cdq
  01988	b9 03 00 00 00	 mov	 ecx, 3
  0198d	f7 f9		 idiv	 ecx
  0198f	83 ea 01	 sub	 edx, 1
  01992	6b d2 ff	 imul	 edx, -1
  01995	0f af da	 imul	 ebx, edx
  01998	0f b6 55 f4	 movzx	 edx, BYTE PTR _iCY$[ebp]
  0199c	03 da		 add	 ebx, edx
  0199e	88 5d f6	 mov	 BYTE PTR _iRandY$[ebp], bl

; 673  : 
; 674  : 		if ( iRandX < MonsterMapInfo->m_iMinX || iRandX > MonsterMapInfo->m_iMaxX )

  019a1	0f b6 45 f7	 movzx	 eax, BYTE PTR _iRandX$[ebp]
  019a5	8b 4d 0c	 mov	 ecx, DWORD PTR _MonsterMapInfo$[ebp]
  019a8	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  019ab	7c 0c		 jl	 SHORT $LN4@MonsterHer@2
  019ad	0f b6 45 f7	 movzx	 eax, BYTE PTR _iRandX$[ebp]
  019b1	8b 4d 0c	 mov	 ecx, DWORD PTR _MonsterMapInfo$[ebp]
  019b4	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  019b7	7e 05		 jle	 SHORT $LN5@MonsterHer@2
$LN4@MonsterHer@2:

; 675  : 			continue;

  019b9	e9 75 ff ff ff	 jmp	 $LN7@MonsterHer@2
$LN5@MonsterHer@2:

; 676  : 
; 677  : 		if ( iRandY < MonsterMapInfo->m_iMinY || iRandY > MonsterMapInfo->m_iMaxY )

  019be	0f b6 45 f6	 movzx	 eax, BYTE PTR _iRandY$[ebp]
  019c2	8b 4d 0c	 mov	 ecx, DWORD PTR _MonsterMapInfo$[ebp]
  019c5	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  019c8	7c 0c		 jl	 SHORT $LN2@MonsterHer@2
  019ca	0f b6 45 f6	 movzx	 eax, BYTE PTR _iRandY$[ebp]
  019ce	8b 4d 0c	 mov	 ecx, DWORD PTR _MonsterMapInfo$[ebp]
  019d1	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  019d4	7e 05		 jle	 SHORT $LN3@MonsterHer@2
$LN2@MonsterHer@2:

; 678  : 			continue;

  019d6	e9 58 ff ff ff	 jmp	 $LN7@MonsterHer@2
$LN3@MonsterHer@2:

; 679  : 
; 680  : 		if ( vtHerdInfo->CheckLocation(iRandX, iRandY) != FALSE )

  019db	8d 45 f6	 lea	 eax, DWORD PTR _iRandY$[ebp]
  019de	50		 push	 eax
  019df	8d 4d f7	 lea	 ecx, DWORD PTR _iRandX$[ebp]
  019e2	51		 push	 ecx
  019e3	8b 55 08	 mov	 edx, DWORD PTR _vtHerdInfo$[ebp]
  019e6	8b 02		 mov	 eax, DWORD PTR [edx]
  019e8	8b 4d 08	 mov	 ecx, DWORD PTR _vtHerdInfo$[ebp]
  019eb	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  019ee	ff d2		 call	 edx
  019f0	85 c0		 test	 eax, eax
  019f2	74 02		 je	 SHORT $LN1@MonsterHer@2

; 681  : 		{
; 682  : 			break;

  019f4	eb 05		 jmp	 SHORT $LN6@MonsterHer@2
$LN1@MonsterHer@2:

; 683  : 		}
; 684  : 	}

  019f6	e9 38 ff ff ff	 jmp	 $LN7@MonsterHer@2
$LN6@MonsterHer@2:

; 685  : 
; 686  : 	vtHerdInfo->MoveHerd(iRandX, iRandY);

  019fb	0f b6 45 f6	 movzx	 eax, BYTE PTR _iRandY$[ebp]
  019ff	50		 push	 eax
  01a00	0f b6 4d f7	 movzx	 ecx, BYTE PTR _iRandX$[ebp]
  01a04	51		 push	 ecx
  01a05	8b 55 08	 mov	 edx, DWORD PTR _vtHerdInfo$[ebp]
  01a08	8b 02		 mov	 eax, DWORD PTR [edx]
  01a0a	8b 4d 08	 mov	 ecx, DWORD PTR _vtHerdInfo$[ebp]
  01a0d	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  01a10	ff d2		 call	 edx

; 687  : 	return TRUE;

  01a12	b8 01 00 00 00	 mov	 eax, 1
$LN9@MonsterHer@2:

; 688  : }

  01a17	5f		 pop	 edi
  01a18	5e		 pop	 esi
  01a19	5b		 pop	 ebx
  01a1a	8b e5		 mov	 esp, ebp
  01a1c	5d		 pop	 ebp
  01a1d	c2 08 00	 ret	 8
?MonsterHerdMoveCheck@CXMasAttackEvent@@QAEHPAVCXMasMonsterHerd@@PAUXMASMONSTER_MAP_INFO@@@Z ENDP ; CXMasAttackEvent::MonsterHerdMoveCheck
_TEXT	ENDS
PUBLIC	?Run@CXMasAttackEvent@@QAEXXZ			; CXMasAttackEvent::Run
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv77 = -72						; size = 4
_this$ = -4						; size = 4
?Run@CXMasAttackEvent@@QAEXXZ PROC			; CXMasAttackEvent::Run
; _this$ = ecx

; 692  : {

  01a20	55		 push	 ebp
  01a21	8b ec		 mov	 ebp, esp
  01a23	83 ec 48	 sub	 esp, 72			; 00000048H
  01a26	53		 push	 ebx
  01a27	56		 push	 esi
  01a28	57		 push	 edi
  01a29	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 693  : 	if ( this->m_bMenualStart )

  01a2c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a2f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01a33	74 02		 je	 SHORT $LN7@Run

; 694  : 		return;

  01a35	eb 44		 jmp	 SHORT $LN8@Run
$LN7@Run:

; 695  : 
; 696  : 	if ( this->m_bDoEvent == FALSE)

  01a37	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a3a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  01a3e	75 02		 jne	 SHORT $LN6@Run

; 697  : 		return;

  01a40	eb 39		 jmp	 SHORT $LN8@Run
$LN6@Run:

; 698  : 
; 699  : 	switch ( this->m_nEvent_State )

  01a42	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a45	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  01a48	89 4d b8	 mov	 DWORD PTR tv77[ebp], ecx
  01a4b	83 7d b8 00	 cmp	 DWORD PTR tv77[ebp], 0
  01a4f	74 0e		 je	 SHORT $LN3@Run
  01a51	83 7d b8 01	 cmp	 DWORD PTR tv77[ebp], 1
  01a55	74 12		 je	 SHORT $LN2@Run
  01a57	83 7d b8 02	 cmp	 DWORD PTR tv77[ebp], 2
  01a5b	74 16		 je	 SHORT $LN1@Run
  01a5d	eb 1c		 jmp	 SHORT $LN8@Run
$LN3@Run:

; 700  : 	{
; 701  : 		case 0:
; 702  : 			this->ProcState_None();

  01a5f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a62	e8 00 00 00 00	 call	 ?ProcState_None@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::ProcState_None

; 703  : 			break;

  01a67	eb 12		 jmp	 SHORT $LN8@Run
$LN2@Run:

; 704  : 		case 1:
; 705  : 			this->ProcState_Closed();

  01a69	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a6c	e8 00 00 00 00	 call	 ?ProcState_Closed@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::ProcState_Closed

; 706  : 			break;

  01a71	eb 08		 jmp	 SHORT $LN8@Run
$LN1@Run:

; 707  : 		case 2:
; 708  : 			this->ProcState_Playing();

  01a73	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a76	e8 00 00 00 00	 call	 ?ProcState_Playing@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::ProcState_Playing
$LN8@Run:

; 709  : 	}
; 710  : }	

  01a7b	5f		 pop	 edi
  01a7c	5e		 pop	 esi
  01a7d	5b		 pop	 ebx
  01a7e	8b e5		 mov	 esp, ebp
  01a80	5d		 pop	 ebp
  01a81	c3		 ret	 0
?Run@CXMasAttackEvent@@QAEXXZ ENDP			; CXMasAttackEvent::Run
_TEXT	ENDS
PUBLIC	??_C@_0EL@EFNIAOHC@?$FLXMasAttackEvent?$FN?5Sync?5Start?5Tim@ ; `string'
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAUXMASMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=
PUBLIC	?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
PUBLIC	?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
PUBLIC	??_C@_0CI@LHGLLEGN@?$FLXMasAttackEvent?$FN?5No?5Schedule?5Ti@ ; `string'
PUBLIC	?empty@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::empty
PUBLIC	__$ArrayPad$
EXTRN	?GetMinutes@CEventTimer@@QAEHXZ:PROC		; CEventTimer::GetMinutes
EXTRN	?SetSeconds@CEventTimer@@QAEXH@Z:PROC		; CEventTimer::SetSeconds
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0EL@EFNIAOHC@?$FLXMasAttackEvent?$FN?5Sync?5Start?5Tim@
CONST	SEGMENT
??_C@_0EL@EFNIAOHC@?$FLXMasAttackEvent?$FN?5Sync?5Start?5Tim@ DB '[XMasAt'
	DB	'tackEvent] Sync Start Time. [%d] min remain (START HOUR:%d, M'
	DB	'IN:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LHGLLEGN@?$FLXMasAttackEvent?$FN?5No?5Schedule?5Ti@
CONST	SEGMENT
??_C@_0CI@LHGLLEGN@?$FLXMasAttackEvent?$FN?5No?5Schedule?5Ti@ DB '[XMasAt'
	DB	'tackEvent] No Schedule Time Data', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv204 = -148						; size = 4
$T235037 = -144						; size = 4
$T235038 = -140						; size = 4
$T235039 = -136						; size = 4
$T235040 = -132						; size = 4
$T235041 = -128						; size = 4
$T235042 = -124						; size = 4
_m_iTIME_MSEC_REMAIN$232270 = -56			; size = 4
_m_iTIME_MSEC_REMAIN$232268 = -52			; size = 4
_pRET$232261 = -48					; size = 4
_pRET$232251 = -44					; size = 4
_it$ = -40						; size = 4
_sysTime$ = -36						; size = 16
_iMIN_MINUTE$ = -20					; size = 4
_iMIN_HOUR$ = -16					; size = 4
_bTIME_CHANGED$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?CheckSync@CXMasAttackEvent@@QAEXXZ PROC		; CXMasAttackEvent::CheckSync
; _this$ = ecx

; 713  : {

  01a90	55		 push	 ebp
  01a91	8b ec		 mov	 ebp, esp
  01a93	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  01a99	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01a9e	33 c5		 xor	 eax, ebp
  01aa0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01aa3	53		 push	 ebx
  01aa4	56		 push	 esi
  01aa5	57		 push	 edi
  01aa6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 714  : 	if ( this->m_vtEventTime.empty() != 0 )

  01aa9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01aac	83 c1 28	 add	 ecx, 40			; 00000028H
  01aaf	e8 00 00 00 00	 call	 ?empty@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::empty
  01ab4	0f b6 c0	 movzx	 eax, al
  01ab7	85 c0		 test	 eax, eax
  01ab9	74 1f		 je	 SHORT $LN16@CheckSync

; 715  : 	{
; 716  : 		LogAddC(2, "[XMasAttackEvent] No Schedule Time Data");

  01abb	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@LHGLLEGN@?$FLXMasAttackEvent?$FN?5No?5Schedule?5Ti@
  01ac0	6a 02		 push	 2
  01ac2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01ac8	83 c4 08	 add	 esp, 8

; 717  : 		this->SetState(ATTACKEVENT_STATE_NONE);

  01acb	6a 00		 push	 0
  01acd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ad0	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 718  : 		return;

  01ad5	e9 66 02 00 00	 jmp	 $LN17@CheckSync
$LN16@CheckSync:

; 719  : 	}
; 720  : 
; 721  : 	BOOL bTIME_CHANGED = FALSE;

  01ada	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0

; 722  : 	int iMIN_HOUR = 24;

  01ae1	c7 45 f0 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 723  : 	int iMIN_MINUTE = 60;

  01ae8	c7 45 ec 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH

; 724  : 	
; 725  : 	SYSTEMTIME sysTime;
; 726  : 	GetLocalTime(&sysTime);

  01aef	8d 45 dc	 lea	 eax, DWORD PTR _sysTime$[ebp]
  01af2	50		 push	 eax
  01af3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 727  : 	std::vector<XMASMONSTER_EVENT_TIME>::iterator it;

  01af9	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01afc	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >

; 728  : 	for ( it = this->m_vtEventTime.begin(); it != this->m_vtEventTime.end() ; it++ )

  01b01	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T235037[ebp]
  01b07	50		 push	 eax
  01b08	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01b0b	83 c1 28	 add	 ecx, 40			; 00000028H
  01b0e	e8 00 00 00 00	 call	 ?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin
  01b13	8b 08		 mov	 ecx, DWORD PTR [eax]
  01b15	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx
  01b18	eb 11		 jmp	 SHORT $LN15@CheckSync
$LN14@CheckSync:
  01b1a	6a 00		 push	 0
  01b1c	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T235038[ebp]
  01b22	50		 push	 eax
  01b23	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01b26	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
$LN15@CheckSync:
  01b2b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T235039[ebp]
  01b31	50		 push	 eax
  01b32	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01b35	83 c1 28	 add	 ecx, 40			; 00000028H
  01b38	e8 00 00 00 00	 call	 ?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end
  01b3d	50		 push	 eax
  01b3e	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01b41	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=
  01b46	0f b6 c8	 movzx	 ecx, al
  01b49	85 c9		 test	 ecx, ecx
  01b4b	74 62		 je	 SHORT $LN13@CheckSync

; 729  : 	{
; 730  : 		XMASMONSTER_EVENT_TIME & pRET = *it;

  01b4d	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01b50	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAUXMASMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*
  01b55	89 45 d4	 mov	 DWORD PTR _pRET$232251[ebp], eax

; 731  : 
; 732  : 		if ( (sysTime.wHour * 60 + sysTime.wMinute) < (pRET.m_iHour * 60 + pRET.m_iMinute ))

  01b58	0f b7 45 e4	 movzx	 eax, WORD PTR _sysTime$[ebp+8]
  01b5c	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01b5f	0f b7 4d e6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  01b63	03 c1		 add	 eax, ecx
  01b65	8b 55 d4	 mov	 edx, DWORD PTR _pRET$232251[ebp]
  01b68	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01b6a	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01b6d	8b 55 d4	 mov	 edx, DWORD PTR _pRET$232251[ebp]
  01b70	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  01b73	3b c1		 cmp	 eax, ecx
  01b75	7d 33		 jge	 SHORT $LN12@CheckSync

; 733  : 		{
; 734  : 			if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute) )

  01b77	8b 45 f0	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01b7a	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01b7d	03 45 ec	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  01b80	8b 4d d4	 mov	 ecx, DWORD PTR _pRET$232251[ebp]
  01b83	8b 11		 mov	 edx, DWORD PTR [ecx]
  01b85	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01b88	8b 4d d4	 mov	 ecx, DWORD PTR _pRET$232251[ebp]
  01b8b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  01b8e	3b c2		 cmp	 eax, edx
  01b90	7e 18		 jle	 SHORT $LN12@CheckSync

; 735  : 			{
; 736  : 				bTIME_CHANGED = TRUE;

  01b92	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1

; 737  : 				iMIN_HOUR = pRET.m_iHour;

  01b99	8b 45 d4	 mov	 eax, DWORD PTR _pRET$232251[ebp]
  01b9c	8b 08		 mov	 ecx, DWORD PTR [eax]
  01b9e	89 4d f0	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 738  : 				iMIN_MINUTE = pRET.m_iMinute;

  01ba1	8b 45 d4	 mov	 eax, DWORD PTR _pRET$232251[ebp]
  01ba4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01ba7	89 4d ec	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN12@CheckSync:

; 739  : 			}
; 740  : 		}
; 741  : 	}

  01baa	e9 6b ff ff ff	 jmp	 $LN14@CheckSync
$LN13@CheckSync:

; 742  : 
; 743  : 	if ( bTIME_CHANGED == FALSE )

  01baf	83 7d f4 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  01bb3	0f 85 94 00 00
	00		 jne	 $LN10@CheckSync

; 744  : 	{
; 745  : 		iMIN_HOUR = 24;

  01bb9	c7 45 f0 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 746  : 		iMIN_MINUTE = 60;

  01bc0	c7 45 ec 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH

; 747  : 
; 748  : 		it = this->m_vtEventTime.begin();

  01bc7	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T235040[ebp]
  01bcd	50		 push	 eax
  01bce	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01bd1	83 c1 28	 add	 ecx, 40			; 00000028H
  01bd4	e8 00 00 00 00	 call	 ?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin
  01bd9	8b 08		 mov	 ecx, DWORD PTR [eax]
  01bdb	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx
  01bde	eb 0e		 jmp	 SHORT $LN9@CheckSync
$LN8@CheckSync:

; 749  : 
; 750  : 		for ( ; it != this->m_vtEventTime.end() ; it++ )

  01be0	6a 00		 push	 0
  01be2	8d 45 80	 lea	 eax, DWORD PTR $T235041[ebp]
  01be5	50		 push	 eax
  01be6	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01be9	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
$LN9@CheckSync:
  01bee	8d 45 84	 lea	 eax, DWORD PTR $T235042[ebp]
  01bf1	50		 push	 eax
  01bf2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01bf5	83 c1 28	 add	 ecx, 40			; 00000028H
  01bf8	e8 00 00 00 00	 call	 ?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end
  01bfd	50		 push	 eax
  01bfe	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01c01	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=
  01c06	0f b6 c8	 movzx	 ecx, al
  01c09	85 c9		 test	 ecx, ecx
  01c0b	74 40		 je	 SHORT $LN10@CheckSync

; 751  : 		{
; 752  : 			XMASMONSTER_EVENT_TIME & pRET = *it;

  01c0d	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01c10	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAUXMASMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*
  01c15	89 45 d0	 mov	 DWORD PTR _pRET$232261[ebp], eax

; 753  : 
; 754  : 			if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute) )

  01c18	8b 45 f0	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01c1b	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01c1e	03 45 ec	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  01c21	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$232261[ebp]
  01c24	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c26	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01c29	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$232261[ebp]
  01c2c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  01c2f	3b c2		 cmp	 eax, edx
  01c31	7e 18		 jle	 SHORT $LN6@CheckSync

; 755  : 			{
; 756  : 				bTIME_CHANGED = 2;

  01c33	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2

; 757  : 				iMIN_HOUR = pRET.m_iHour;

  01c3a	8b 45 d0	 mov	 eax, DWORD PTR _pRET$232261[ebp]
  01c3d	8b 08		 mov	 ecx, DWORD PTR [eax]
  01c3f	89 4d f0	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 758  : 				iMIN_MINUTE = pRET.m_iMinute;

  01c42	8b 45 d0	 mov	 eax, DWORD PTR _pRET$232261[ebp]
  01c45	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01c48	89 4d ec	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN6@CheckSync:

; 759  : 			}
; 760  : 		}

  01c4b	eb 93		 jmp	 SHORT $LN8@CheckSync
$LN10@CheckSync:

; 761  : 	}
; 762  : 
; 763  : 	switch ( bTIME_CHANGED )

  01c4d	8b 45 f4	 mov	 eax, DWORD PTR _bTIME_CHANGED$[ebp]
  01c50	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv204[ebp], eax
  01c56	83 bd 6c ff ff
	ff 01		 cmp	 DWORD PTR tv204[ebp], 1
  01c5d	74 0e		 je	 SHORT $LN3@CheckSync
  01c5f	83 bd 6c ff ff
	ff 02		 cmp	 DWORD PTR tv204[ebp], 2
  01c66	74 45		 je	 SHORT $LN2@CheckSync
  01c68	e9 83 00 00 00	 jmp	 $LN1@CheckSync
$LN3@CheckSync:

; 764  : 	{
; 765  : 		case 1:
; 766  : 			{
; 767  : 				int m_iTIME_MSEC_REMAIN = ((iMIN_HOUR * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond));

  01c6d	8b 45 f0	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01c70	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01c73	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01c76	8b 4d ec	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  01c79	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01c7c	03 c1		 add	 eax, ecx
  01c7e	0f b7 55 e4	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  01c82	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01c85	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01c88	0f b7 4d e6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  01c8c	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01c8f	03 d1		 add	 edx, ecx
  01c91	0f b7 4d e8	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  01c95	03 d1		 add	 edx, ecx
  01c97	2b c2		 sub	 eax, edx
  01c99	89 45 cc	 mov	 DWORD PTR _m_iTIME_MSEC_REMAIN$232268[ebp], eax

; 768  : 				this->m_EventTimer.SetSeconds(m_iTIME_MSEC_REMAIN);

  01c9c	8b 45 cc	 mov	 eax, DWORD PTR _m_iTIME_MSEC_REMAIN$232268[ebp]
  01c9f	50		 push	 eax
  01ca0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ca3	83 c1 58	 add	 ecx, 88			; 00000058H
  01ca6	e8 00 00 00 00	 call	 ?SetSeconds@CEventTimer@@QAEXH@Z ; CEventTimer::SetSeconds

; 769  : 			}
; 770  : 			break;

  01cab	eb 5f		 jmp	 SHORT $LN4@CheckSync
$LN2@CheckSync:

; 771  : 		case 2:
; 772  : 			{
; 773  : 				int m_iTIME_MSEC_REMAIN = (((iMIN_HOUR + 24) * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond));

  01cad	8b 45 f0	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01cb0	83 c0 18	 add	 eax, 24			; 00000018H
  01cb3	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01cb6	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01cb9	8b 4d ec	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  01cbc	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01cbf	03 c1		 add	 eax, ecx
  01cc1	0f b7 55 e4	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  01cc5	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01cc8	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01ccb	0f b7 4d e6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  01ccf	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01cd2	03 d1		 add	 edx, ecx
  01cd4	0f b7 4d e8	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  01cd8	03 d1		 add	 edx, ecx
  01cda	2b c2		 sub	 eax, edx
  01cdc	89 45 c8	 mov	 DWORD PTR _m_iTIME_MSEC_REMAIN$232270[ebp], eax

; 774  : 				this->m_EventTimer.SetSeconds(m_iTIME_MSEC_REMAIN);

  01cdf	8b 45 c8	 mov	 eax, DWORD PTR _m_iTIME_MSEC_REMAIN$232270[ebp]
  01ce2	50		 push	 eax
  01ce3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ce6	83 c1 58	 add	 ecx, 88			; 00000058H
  01ce9	e8 00 00 00 00	 call	 ?SetSeconds@CEventTimer@@QAEXH@Z ; CEventTimer::SetSeconds

; 775  : 			}
; 776  : 			break;

  01cee	eb 1c		 jmp	 SHORT $LN4@CheckSync
$LN1@CheckSync:

; 777  : 		default:
; 778  : 			LogAddC(2, "[XMasAttackEvent] No Schedule Time Data");

  01cf0	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@LHGLLEGN@?$FLXMasAttackEvent?$FN?5No?5Schedule?5Ti@
  01cf5	6a 02		 push	 2
  01cf7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01cfd	83 c4 08	 add	 esp, 8

; 779  : 			this->SetState(ATTACKEVENT_STATE_NONE);

  01d00	6a 00		 push	 0
  01d02	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d05	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 780  : 			return;

  01d0a	eb 34		 jmp	 SHORT $LN17@CheckSync
$LN4@CheckSync:

; 781  : 	}
; 782  : 
; 783  : 	LogAddTD("[XMasAttackEvent] Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)",
; 784  : 		this->m_EventTimer.GetMinutes(), iMIN_HOUR, iMIN_MINUTE);

  01d0c	8b 45 ec	 mov	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  01d0f	50		 push	 eax
  01d10	8b 4d f0	 mov	 ecx, DWORD PTR _iMIN_HOUR$[ebp]
  01d13	51		 push	 ecx
  01d14	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d17	83 c1 58	 add	 ecx, 88			; 00000058H
  01d1a	e8 00 00 00 00	 call	 ?GetMinutes@CEventTimer@@QAEHXZ ; CEventTimer::GetMinutes
  01d1f	50		 push	 eax
  01d20	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@EFNIAOHC@?$FLXMasAttackEvent?$FN?5Sync?5Start?5Tim@
  01d25	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01d2b	83 c4 10	 add	 esp, 16			; 00000010H

; 785  : 
; 786  : 	this->m_iTIME_NOTIFY_COUNT = this->m_iTIME_MIN_OPEN;

  01d2e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01d31	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d34	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  01d3a	89 90 8c 00 00
	00		 mov	 DWORD PTR [eax+140], edx
$LN17@CheckSync:

; 787  : }

  01d40	5f		 pop	 edi
  01d41	5e		 pop	 esi
  01d42	5b		 pop	 ebx
  01d43	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d46	33 cd		 xor	 ecx, ebp
  01d48	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d4d	8b e5		 mov	 esp, ebp
  01d4f	5d		 pop	 ebp
  01d50	c3		 ret	 0
?CheckSync@CXMasAttackEvent@@QAEXXZ ENDP		; CXMasAttackEvent::CheckSync
_TEXT	ENDS
PUBLIC	??_C@_0DA@JGNGNKPL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5X@ ; `string'
;	COMDAT ??_C@_0DA@JGNGNKPL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5X@
CONST	SEGMENT
??_C@_0DA@JGNGNKPL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5X@ DB 0a1H
	DB	0dbH, 0a1H, 0dcH, '[Event Management] [Start] XMasAttackEvent!'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Start_Menual@CXMasAttackEvent@@UAEXXZ PROC		; CXMasAttackEvent::Start_Menual
; _this$ = ecx

; 790  : {

  01d60	55		 push	 ebp
  01d61	8b ec		 mov	 ebp, esp
  01d63	83 ec 44	 sub	 esp, 68			; 00000044H
  01d66	53		 push	 ebx
  01d67	56		 push	 esi
  01d68	57		 push	 edi
  01d69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 791  : 	this->SetMenualStart(TRUE);

  01d6c	6a 01		 push	 1
  01d6e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d71	8b 10		 mov	 edx, DWORD PTR [eax]
  01d73	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d76	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01d79	ff d0		 call	 eax

; 792  : 	this->StopEvent();

  01d7b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d7e	8b 10		 mov	 edx, DWORD PTR [eax]
  01d80	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d83	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01d86	ff d0		 call	 eax

; 793  : 
; 794  : 	LogAddTD("[Event Management] [Start] XMasAttackEvent!");

  01d88	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JGNGNKPL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5X@
  01d8d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01d93	83 c4 04	 add	 esp, 4

; 795  : 	this->m_iTIME_MIN_PLAY = 30;

  01d96	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d99	c7 80 84 00 00
	00 1e 00 00 00	 mov	 DWORD PTR [eax+132], 30	; 0000001eH

; 796  : 
; 797  : 	//this->SendMessage(lMsg.Get(2583), 1);
; 798  : 	this->SetState(ATTACKEVENT_STATE_PLAYING);

  01da3	6a 02		 push	 2
  01da5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01da8	e8 00 00 00 00	 call	 ?SetState@CXMasAttackEvent@@QAEXH@Z ; CXMasAttackEvent::SetState

; 799  : }

  01dad	5f		 pop	 edi
  01dae	5e		 pop	 esi
  01daf	5b		 pop	 ebx
  01db0	8b e5		 mov	 esp, ebp
  01db2	5d		 pop	 ebp
  01db3	c3		 ret	 0
?Start_Menual@CXMasAttackEvent@@UAEXXZ ENDP		; CXMasAttackEvent::Start_Menual
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?End_Menual@CXMasAttackEvent@@UAEXXZ PROC		; CXMasAttackEvent::End_Menual
; _this$ = ecx

; 802  : {

  01dc0	55		 push	 ebp
  01dc1	8b ec		 mov	 ebp, esp
  01dc3	83 ec 44	 sub	 esp, 68			; 00000044H
  01dc6	53		 push	 ebx
  01dc7	56		 push	 esi
  01dc8	57		 push	 edi
  01dc9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 803  : 	this->SetMenualStart(FALSE);

  01dcc	6a 00		 push	 0
  01dce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dd1	8b 10		 mov	 edx, DWORD PTR [eax]
  01dd3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01dd6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01dd9	ff d0		 call	 eax

; 804  : }

  01ddb	5f		 pop	 edi
  01ddc	5e		 pop	 esi
  01ddd	5b		 pop	 ebx
  01dde	8b e5		 mov	 esp, ebp
  01de0	5d		 pop	 ebp
  01de1	c3		 ret	 0
?End_Menual@CXMasAttackEvent@@UAEXXZ ENDP		; CXMasAttackEvent::End_Menual
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME &>
PUBLIC	?_Orphan_range@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAUXMASMONSTER_EVENT_TIME@@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Reserve
PUBLIC	?_Inside@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBUXMASMONSTER_EVENT_TIME@@@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Inside
PUBLIC	??$addressof@$$CBUXMASMONSTER_EVENT_TIME@@@std@@YAPBUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::addressof<XMASMONSTER_EVENT_TIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXABUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Idx$232297 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXABUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUXMASMONSTER_EVENT_TIME@@@std@@YAPBUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::addressof<XMASMONSTER_EVENT_TIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBUXMASMONSTER_EVENT_TIME@@@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUXMASMONSTER_EVENT_TIME@@@std@@YAPBUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::addressof<XMASMONSTER_EVENT_TIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$232297[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAUXMASMONSTER_EVENT_TIME@@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$232297[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAUXMASMONSTER_EVENT_TIME@@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXABUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE_NXZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE_NXZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA &>
PUBLIC	?_Orphan_range@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXPAUXMASMONSTER_DATA@@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBE_NPBUXMASMONSTER_DATA@@@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUXMASMONSTER_DATA@@@std@@YAPBUXMASMONSTER_DATA@@ABU1@@Z ; std::addressof<XMASMONSTER_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXABUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Idx$232334 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXABUXMASMONSTER_DATA@@@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUXMASMONSTER_DATA@@@std@@YAPBUXMASMONSTER_DATA@@ABU1@@Z ; std::addressof<XMASMONSTER_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBE_NPBUXMASMONSTER_DATA@@@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUXMASMONSTER_DATA@@@std@@YAPBUXMASMONSTER_DATA@@ABU1@@Z ; std::addressof<XMASMONSTER_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$232334[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXPAUXMASMONSTER_DATA@@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$232334[ebp]
  00075	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXPAUXMASMONSTER_DATA@@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXABUXMASMONSTER_DATA@@@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::push_back
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAVCXMasMonsterHerd@@@std@@PAVCXMasMonsterHerd@@PAV3@@std@@YAXAAV?$allocator@PAVCXMasMonsterHerd@@@0@PAPAVCXMasMonsterHerd@@$$QAPAV2@@Z ; std::_Cons_val<std::allocator<CXMasMonsterHerd *>,CXMasMonsterHerd *,CXMasMonsterHerd *>
PUBLIC	??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::forward<CXMasMonsterHerd *>
PUBLIC	?_Orphan_range@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXI@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Reserve
PUBLIC	?_Inside@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBE_NPBQAVCXMasMonsterHerd@@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Inside
PUBLIC	??$addressof@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::addressof<CXMasMonsterHerd *>
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEX$$QAPAVCXMasMonsterHerd@@@Z
_TEXT	SEGMENT
__Idx$232361 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEX$$QAPAVCXMasMonsterHerd@@@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::addressof<CXMasMonsterHerd *>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBE_NPBQAVCXMasMonsterHerd@@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 81 00 00
	00		 je	 $LN4@push_back@3

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$addressof@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::addressof<CXMasMonsterHerd *>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	c1 f8 02	 sar	 eax, 2
  00040	89 45 f8	 mov	 DWORD PTR __Idx$232361[ebp], eax

; 635  : 			if (this->_Mylast == this->_Myend)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004f	75 0a		 jne	 SHORT $LN3@push_back@3

; 636  : 				_Reserve(1);

  00051	6a 01		 push	 1
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXI@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Reserve
$LN3@push_back@3:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Orphan_range

; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	8b 55 f8	 mov	 edx, DWORD PTR __Idx$232361[ebp]
  00079	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::forward<CXMasMonsterHerd *>
  00082	83 c4 04	 add	 esp, 4
  00085	50		 push	 eax
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008c	52		 push	 edx
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	83 c0 0c	 add	 eax, 12			; 0000000cH
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@PAVCXMasMonsterHerd@@@std@@PAVCXMasMonsterHerd@@PAV3@@std@@YAXAAV?$allocator@PAVCXMasMonsterHerd@@@0@PAPAVCXMasMonsterHerd@@$$QAPAV2@@Z ; std::_Cons_val<std::allocator<CXMasMonsterHerd *>,CXMasMonsterHerd *,CXMasMonsterHerd *>
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 			++this->_Mylast;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	83 c1 04	 add	 ecx, 4
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 642  : 			}
; 643  : 		else

  000ab	eb 60		 jmp	 SHORT $LN5@push_back@3
$LN4@push_back@3:

; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b9	75 0a		 jne	 SHORT $LN1@push_back@3

; 646  : 				_Reserve(1);

  000bb	6a 01		 push	 1
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXI@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Reserve
$LN1@push_back@3:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	51		 push	 ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Orphan_range

; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  000db	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::forward<CXMasMonsterHerd *>
  000e4	83 c4 04	 add	 esp, 4
  000e7	50		 push	 eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ee	52		 push	 edx
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	83 c0 0c	 add	 eax, 12			; 0000000cH
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@PAVCXMasMonsterHerd@@@std@@PAVCXMasMonsterHerd@@PAV3@@std@@YAXAAV?$allocator@PAVCXMasMonsterHerd@@@0@PAPAVCXMasMonsterHerd@@$$QAPAV2@@Z ; std::_Cons_val<std::allocator<CXMasMonsterHerd *>,CXMasMonsterHerd *,CXMasMonsterHerd *>
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00104	83 c1 04	 add	 ecx, 4
  00107	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@3:

; 652  : 			}
; 653  : 		}

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 04 00	 ret	 4
?push_back@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEX$$QAPAVCXMasMonsterHerd@@@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@XZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEAAPAVCXMasMonsterHerd@@I@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::operator[]
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Make_iter
PUBLIC	?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy
PUBLIC	??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00@Z ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::erase, COMDAT
; _this$ = ecx

; 1179 : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1180 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1181 : 			_VIPTR(_Where));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00@Z ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1182 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	51		 push	 ecx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00033	83 e8 04	 sub	 eax, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy

; 1183 : 		--this->_Mylast;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	83 e9 04	 sub	 ecx, 4
  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1184 : 		return (_Make_iter(_Where));

  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Make_iter
  0005e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1185 : 		}

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?erase@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_MAP_INFO@@@1@@Z ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
PUBLIC	??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@XZ ; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T235074 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T235074[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@XZ ; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_MAP_INFO@@@1@@Z ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
PUBLIC	?_Tidy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
__ehhandler$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEAAUXMASMONSTER_MAP_INFO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEAAUXMASMONSTER_MAP_INFO@@I@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 14	 imul	 eax, 20			; 00000014H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEAAUXMASMONSTER_MAP_INFO@@I@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@ABU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@AAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO &>
PUBLIC	?_Orphan_range@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXPAUXMASMONSTER_MAP_INFO@@0@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Reserve
PUBLIC	?_Inside@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBE_NPBUXMASMONSTER_MAP_INFO@@@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Inside
PUBLIC	??$addressof@$$CBUXMASMONSTER_MAP_INFO@@@std@@YAPBUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::addressof<XMASMONSTER_MAP_INFO const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXABUXMASMONSTER_MAP_INFO@@@Z
_TEXT	SEGMENT
__Idx$232445 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXABUXMASMONSTER_MAP_INFO@@@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUXMASMONSTER_MAP_INFO@@@std@@YAPBUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::addressof<XMASMONSTER_MAP_INFO const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBE_NPBUXMASMONSTER_MAP_INFO@@@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back@4

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUXMASMONSTER_MAP_INFO@@@std@@YAPBUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::addressof<XMASMONSTER_MAP_INFO const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$232445[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back@4

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Reserve
$LN3@push_back@4:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXPAUXMASMONSTER_MAP_INFO@@0@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$232445[ebp]
  00075	6b c0 14	 imul	 eax, 20			; 00000014H
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@AAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 14	 add	 ecx, 20			; 00000014H
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back@4
$LN4@push_back@4:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back@4

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXI@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Reserve
$LN1@push_back@4:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXPAUXMASMONSTER_MAP_INFO@@0@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@ABU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 14	 add	 ecx, 20			; 00000014H
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@4:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXABUXMASMONSTER_MAP_INFO@@@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::push_back
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEABQAVCXMasMonsterHerd@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEAAPAVCXMasMonsterHerd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEAAPAVCXMasMonsterHerd@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEABQAVCXMasMonsterHerd@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEAAPAVCXMasMonsterHerd@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEABUXMASMONSTER_DATA@@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEAAUXMASMONSTER_DATA@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEAAUXMASMONSTER_DATA@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEABUXMASMONSTER_DATA@@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEAAUXMASMONSTER_DATA@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABUXMASMONSTER_EVENT_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAUXMASMONSTER_EVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAUXMASMONSTER_EVENT_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABUXMASMONSTER_EVENT_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAUXMASMONSTER_EVENT_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::reserve
PUBLIC	?_Grow_to@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Grow_to
PUBLIC	?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::capacity
PUBLIC	?_Xlen@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Xlen
PUBLIC	?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::max_size
PUBLIC	?size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAUXMASMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAUXMASMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAUXMASMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Orphan_range
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBE_NPBUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBE_NPBUXMASMONSTER_DATA@@@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBE_NPBUXMASMONSTER_DATA@@@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEII@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::max_size
PUBLIC	?size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEII@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXPAUXMASMONSTER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXPAUXMASMONSTER_DATA@@0@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXPAUXMASMONSTER_DATA@@0@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Orphan_range
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@2@@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBE_NPBQAVCXMasMonsterHerd@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBE_NPBQAVCXMasMonsterHerd@@@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@3
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@3
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@3
$LN3@Inside@3:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@3:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBE_NPBQAVCXMasMonsterHerd@@@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::reserve
PUBLIC	?_Grow_to@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEII@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Grow_to
PUBLIC	?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::capacity
PUBLIC	?_Xlen@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXI@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@3
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@3

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@3
$LN2@Reserve@3:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEII@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::reserve
$LN6@Reserve@3:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXPAPAVCXMasMonsterHerd@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXPAPAVCXMasMonsterHerd@@0@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXPAPAVCXMasMonsterHerd@@0@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Orphan_range
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBE_NPBUXMASMONSTER_MAP_INFO@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBE_NPBUXMASMONSTER_MAP_INFO@@@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@4
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@4
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@4
$LN3@Inside@4:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@4:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBE_NPBUXMASMONSTER_MAP_INFO@@@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::reserve
PUBLIC	?_Grow_to@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEII@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Grow_to
PUBLIC	?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::capacity
PUBLIC	?_Xlen@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Xlen
PUBLIC	?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXI@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@4

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@4
$LN4@Reserve@4:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@4

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@4
$LN2@Reserve@4:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEII@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::reserve
$LN6@Reserve@4:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXI@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z ; std::allocator<XMASMONSTER_MAP_INFO>::deallocate
PUBLIC	?_Destroy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXPAUXMASMONSTER_MAP_INFO@@0@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Destroy
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXXZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXPAUXMASMONSTER_MAP_INFO@@0@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z ; std::allocator<XMASMONSTER_MAP_INFO>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXXZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXPAUXMASMONSTER_MAP_INFO@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXPAUXMASMONSTER_MAP_INFO@@0@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXPAUXMASMONSTER_MAP_INFO@@0@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@ABV01@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_MAP_INFO@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_MAP_INFO@@@1@@Z PROC ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@ABV01@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_MAP_INFO@@@1@@Z ENDP ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::~_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@XZ PROC	; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@XZ ENDP	; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEABQAVCXMasMonsterHerd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEABQAVCXMasMonsterHerd@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEABQAVCXMasMonsterHerd@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 04	 add	 ecx, 4
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEABUXMASMONSTER_DATA@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEABUXMASMONSTER_DATA@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@2:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@2

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEABUXMASMONSTER_DATA@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABUXMASMONSTER_EVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABUXMASMONSTER_EVENT_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@3:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@3

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABUXMASMONSTER_EVENT_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy
PUBLIC	?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate
PUBLIC	??$_Umove@PAUXMASMONSTER_EVENT_TIME@@@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEPAUXMASMONSTER_EVENT_TIME@@PAU2@00@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Umove<XMASMONSTER_EVENT_TIME *>
PUBLIC	?allocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEPAUXMASMONSTER_EVENT_TIME@@I@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232693 = -28					; size = 4
__Ptr$232686 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEPAUXMASMONSTER_EVENT_TIME@@I@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232686[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232686[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUXMASMONSTER_EVENT_TIME@@@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEPAUXMASMONSTER_EVENT_TIME@@PAU2@00@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Umove<XMASMONSTER_EVENT_TIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232686[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232693[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232686[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$232693[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232686[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232686[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QBEIXZ ; std::allocator<XMASMONSTER_EVENT_TIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QBEIXZ ; std::allocator<XMASMONSTER_EVENT_TIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Xlen
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy
PUBLIC	?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z ; std::allocator<XMASMONSTER_DATA>::deallocate
PUBLIC	??$_Umove@PAUXMASMONSTER_DATA@@@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEPAUXMASMONSTER_DATA@@PAU2@00@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Umove<XMASMONSTER_DATA *>
PUBLIC	?allocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEPAUXMASMONSTER_DATA@@I@Z ; std::allocator<XMASMONSTER_DATA>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232720 = -28					; size = 4
__Ptr$232713 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEPAUXMASMONSTER_DATA@@I@Z ; std::allocator<XMASMONSTER_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232713[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232713[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUXMASMONSTER_DATA@@@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEPAUXMASMONSTER_DATA@@PAU2@00@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Umove<XMASMONSTER_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232713[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z ; std::allocator<XMASMONSTER_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232720[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z ; std::allocator<XMASMONSTER_DATA>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$232713[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$232720[ebp]
  00125	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$232713[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232713[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UXMASMONSTER_DATA@@@std@@QBEIXZ ; std::allocator<XMASMONSTER_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UXMASMONSTER_DATA@@@std@@QBEIXZ ; std::allocator<XMASMONSTER_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Xlen
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z ; std::allocator<CXMasMonsterHerd *>::deallocate
PUBLIC	??$_Umove@PAPAVCXMasMonsterHerd@@@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEPAPAVCXMasMonsterHerd@@PAPAV2@00@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Umove<CXMasMonsterHerd * *>
PUBLIC	?allocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEPAPAVCXMasMonsterHerd@@I@Z ; std::allocator<CXMasMonsterHerd *>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232746 = -28					; size = 4
__Ptr$232739 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@3
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEPAPAVCXMasMonsterHerd@@I@Z ; std::allocator<CXMasMonsterHerd *>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232739[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232739[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAPAVCXMasMonsterHerd@@@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEPAPAVCXMasMonsterHerd@@PAPAV2@00@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Umove<CXMasMonsterHerd * *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@3
__catch$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232739[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z ; std::allocator<CXMasMonsterHerd *>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@3:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232746[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z ; std::allocator<CXMasMonsterHerd *>::deallocate
$LN1@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232739[ebp]
  00114	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$232746[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232739[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232739[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@3:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCXMasMonsterHerd@@@std@@QBEIXZ ; std::allocator<CXMasMonsterHerd *>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAVCXMasMonsterHerd@@@std@@QBEIXZ ; std::allocator<CXMasMonsterHerd *>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEII@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QBEIXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@3
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@3:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@3

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@3:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEII@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXXZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@3:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IBEXXZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Xlen
_TEXT	ENDS
PUBLIC	??$_Umove@PAUXMASMONSTER_MAP_INFO@@@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEPAUXMASMONSTER_MAP_INFO@@PAU2@00@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Umove<XMASMONSTER_MAP_INFO *>
PUBLIC	?allocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEPAUXMASMONSTER_MAP_INFO@@I@Z ; std::allocator<XMASMONSTER_MAP_INFO>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232770 = -28					; size = 4
__Ptr$232763 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@4

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve@4
$LN5@reserve@4:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve@4

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEPAUXMASMONSTER_MAP_INFO@@I@Z ; std::allocator<XMASMONSTER_MAP_INFO>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232763[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232763[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUXMASMONSTER_MAP_INFO@@@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEPAUXMASMONSTER_MAP_INFO@@PAU2@00@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Umove<XMASMONSTER_MAP_INFO *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@4
__catch$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232763[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z ; std::allocator<XMASMONSTER_MAP_INFO>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@4:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232770[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve@4

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXPAUXMASMONSTER_MAP_INFO@@0@Z ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z ; std::allocator<XMASMONSTER_MAP_INFO>::deallocate
$LN1@reserve@4:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 14	 imul	 eax, 20			; 00000014H
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$232763[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$232770[ebp]
  00125	6b c0 14	 imul	 eax, 20			; 00000014H
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$232763[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232763[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@4:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QAEXI@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QBEIXZ ; std::allocator<XMASMONSTER_MAP_INFO>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QBEIXZ ; std::allocator<XMASMONSTER_MAP_INFO>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXPAUXMASMONSTER_MAP_INFO@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXPAUXMASMONSTER_MAP_INFO@@0@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEXPAUXMASMONSTER_MAP_INFO@@0@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEII@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@QBEIXZ ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@4
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@4
$LN4@Grow_to@4:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@4:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@4

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@4:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEII@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXXZ PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@4:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IBEXXZ ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@ABV01@@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::allocator<XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@I@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QAE@PAPAVCXMasMonsterHerd@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_MAP_INFO@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 14	 add	 ecx, 20			; 00000014H
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@IPAU1@@Z ; std::_Allocate<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEPAUXMASMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEPAUXMASMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@IPAU1@@Z ; std::_Allocate<XMASMONSTER_EVENT_TIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEPAUXMASMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QBEIXZ PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QBEIXZ ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z PROC ; std::allocator<XMASMONSTER_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z ENDP ; std::allocator<XMASMONSTER_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@IPAU1@@Z ; std::_Allocate<XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEPAUXMASMONSTER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEPAUXMASMONSTER_DATA@@I@Z PROC ; std::allocator<XMASMONSTER_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@IPAU1@@Z ; std::_Allocate<XMASMONSTER_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEPAUXMASMONSTER_DATA@@I@Z ENDP ; std::allocator<XMASMONSTER_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UXMASMONSTER_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UXMASMONSTER_DATA@@@std@@QBEIXZ PROC ; std::allocator<XMASMONSTER_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 55 55
	55 15		 mov	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UXMASMONSTER_DATA@@@std@@QBEIXZ ENDP ; std::allocator<XMASMONSTER_DATA>::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z PROC ; std::allocator<CXMasMonsterHerd *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z ENDP ; std::allocator<CXMasMonsterHerd *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@IPAPAV1@@Z ; std::_Allocate<CXMasMonsterHerd *>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEPAPAVCXMasMonsterHerd@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEPAPAVCXMasMonsterHerd@@I@Z PROC ; std::allocator<CXMasMonsterHerd *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@IPAPAV1@@Z ; std::_Allocate<CXMasMonsterHerd *>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEPAPAVCXMasMonsterHerd@@I@Z ENDP ; std::allocator<CXMasMonsterHerd *>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVCXMasMonsterHerd@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAVCXMasMonsterHerd@@@std@@QBEIXZ PROC ; std::allocator<CXMasMonsterHerd *>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@3
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@3
$LN3@max_size@3:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@PAVCXMasMonsterHerd@@@std@@QBEIXZ ENDP ; std::allocator<CXMasMonsterHerd *>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@UXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@IPAU1@@Z ; std::_Allocate<XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEPAUXMASMONSTER_MAP_INFO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEPAUXMASMONSTER_MAP_INFO@@I@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@IPAU1@@Z ; std::_Allocate<XMASMONSTER_MAP_INFO>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEPAUXMASMONSTER_MAP_INFO@@I@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QBEIXZ PROC ; std::allocator<XMASMONSTER_MAP_INFO>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 cc cc
	cc 0c		 mov	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@4
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@4
$LN3@max_size@4:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QBEIXZ ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUXMASMONSTER_EVENT_TIME@@@std@@YAPBUXMASMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUXMASMONSTER_EVENT_TIME@@@std@@YAPBUXMASMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::addressof<XMASMONSTER_EVENT_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUXMASMONSTER_EVENT_TIME@@@std@@YAPBUXMASMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::addressof<XMASMONSTER_EVENT_TIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::construct<XMASMONSTER_EVENT_TIME &>
PUBLIC	??$forward@AAUXMASMONSTER_EVENT_TIME@@@std@@YAAAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUXMASMONSTER_EVENT_TIME@@@std@@YAAAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::construct<XMASMONSTER_EVENT_TIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@ABU3@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::construct
PUBLIC	??$forward@ABUXMASMONSTER_EVENT_TIME@@@std@@YAABUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUXMASMONSTER_EVENT_TIME@@@std@@YAABUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@ABU3@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUXMASMONSTER_DATA@@@std@@YAPBUXMASMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUXMASMONSTER_DATA@@@std@@YAPBUXMASMONSTER_DATA@@ABU1@@Z PROC ; std::addressof<XMASMONSTER_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUXMASMONSTER_DATA@@@std@@YAPBUXMASMONSTER_DATA@@ABU1@@Z ENDP ; std::addressof<XMASMONSTER_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z ; std::allocator<XMASMONSTER_DATA>::construct<XMASMONSTER_DATA &>
PUBLIC	??$forward@AAUXMASMONSTER_DATA@@@std@@YAAAUXMASMONSTER_DATA@@AAU1@@Z ; std::forward<XMASMONSTER_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUXMASMONSTER_DATA@@@std@@YAAAUXMASMONSTER_DATA@@AAU1@@Z ; std::forward<XMASMONSTER_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z ; std::allocator<XMASMONSTER_DATA>::construct<XMASMONSTER_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@ABU3@@Z ; std::allocator<XMASMONSTER_DATA>::construct
PUBLIC	??$forward@ABUXMASMONSTER_DATA@@@std@@YAABUXMASMONSTER_DATA@@ABU1@@Z ; std::forward<XMASMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUXMASMONSTER_DATA@@@std@@YAABUXMASMONSTER_DATA@@ABU1@@Z ; std::forward<XMASMONSTER_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@ABU3@@Z ; std::allocator<XMASMONSTER_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@AAPAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@AAPAV1@@Z PROC ; std::addressof<CXMasMonsterHerd *>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@AAPAV1@@Z ENDP ; std::addressof<CXMasMonsterHerd *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z PROC ; std::forward<CXMasMonsterHerd *>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z ENDP ; std::forward<CXMasMonsterHerd *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z ; std::allocator<CXMasMonsterHerd *>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@PAVCXMasMonsterHerd@@@std@@PAVCXMasMonsterHerd@@PAV3@@std@@YAXAAV?$allocator@PAVCXMasMonsterHerd@@@0@PAPAVCXMasMonsterHerd@@$$QAPAV2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAVCXMasMonsterHerd@@@std@@PAVCXMasMonsterHerd@@PAV3@@std@@YAXAAV?$allocator@PAVCXMasMonsterHerd@@@0@PAPAVCXMasMonsterHerd@@$$QAPAV2@@Z PROC ; std::_Cons_val<std::allocator<CXMasMonsterHerd *>,CXMasMonsterHerd *,CXMasMonsterHerd *>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::forward<CXMasMonsterHerd *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z ; std::allocator<CXMasMonsterHerd *>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@PAVCXMasMonsterHerd@@@std@@PAVCXMasMonsterHerd@@PAV3@@std@@YAXAAV?$allocator@PAVCXMasMonsterHerd@@@0@PAPAVCXMasMonsterHerd@@$$QAPAV2@@Z ENDP ; std::_Cons_val<std::allocator<CXMasMonsterHerd *>,CXMasMonsterHerd *,CXMasMonsterHerd *>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>
PUBLIC	??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00@Z
_TEXT	SEGMENT
$T235382 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00@Z PROC ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235382[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235382[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00@Z ENDP ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUXMASMONSTER_MAP_INFO@@@std@@YAPBUXMASMONSTER_MAP_INFO@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUXMASMONSTER_MAP_INFO@@@std@@YAPBUXMASMONSTER_MAP_INFO@@ABU1@@Z PROC ; std::addressof<XMASMONSTER_MAP_INFO const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUXMASMONSTER_MAP_INFO@@@std@@YAPBUXMASMONSTER_MAP_INFO@@ABU1@@Z ENDP ; std::addressof<XMASMONSTER_MAP_INFO const >
_TEXT	ENDS
PUBLIC	??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::construct<XMASMONSTER_MAP_INFO &>
PUBLIC	??$forward@AAUXMASMONSTER_MAP_INFO@@@std@@YAAAUXMASMONSTER_MAP_INFO@@AAU1@@Z ; std::forward<XMASMONSTER_MAP_INFO &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUXMASMONSTER_MAP_INFO@@@std@@YAAAUXMASMONSTER_MAP_INFO@@AAU1@@Z ; std::forward<XMASMONSTER_MAP_INFO &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::construct<XMASMONSTER_MAP_INFO &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@AAU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@ABU3@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::construct
PUBLIC	??$forward@ABUXMASMONSTER_MAP_INFO@@@std@@YAABUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::forward<XMASMONSTER_MAP_INFO const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUXMASMONSTER_MAP_INFO@@@std@@YAABUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::forward<XMASMONSTER_MAP_INFO const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@ABU3@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@ABU3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z
_TEXT	SEGMENT
$T235391 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235391[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235391[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUXMASMONSTER_EVENT_TIME@@@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEPAUXMASMONSTER_EVENT_TIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUXMASMONSTER_EVENT_TIME@@@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEPAUXMASMONSTER_EVENT_TIME@@PAU2@00@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Umove<XMASMONSTER_EVENT_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUXMASMONSTER_EVENT_TIME@@@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEPAUXMASMONSTER_EVENT_TIME@@PAU2@00@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Umove<XMASMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Umove@PAUXMASMONSTER_DATA@@@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEPAUXMASMONSTER_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUXMASMONSTER_DATA@@@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEPAUXMASMONSTER_DATA@@PAU2@00@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Umove<XMASMONSTER_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUXMASMONSTER_DATA@@@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEPAUXMASMONSTER_DATA@@PAU2@00@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Umove<XMASMONSTER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAPAVCXMasMonsterHerd@@PAPAV1@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ; std::_Uninitialized_move<CXMasMonsterHerd * *,CXMasMonsterHerd * *,std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Umove@PAPAVCXMasMonsterHerd@@@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEPAPAVCXMasMonsterHerd@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCXMasMonsterHerd@@@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEPAPAVCXMasMonsterHerd@@PAPAV2@00@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Umove<CXMasMonsterHerd * *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCXMasMonsterHerd@@PAPAV1@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ; std::_Uninitialized_move<CXMasMonsterHerd * *,CXMasMonsterHerd * *,std::allocator<CXMasMonsterHerd *> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCXMasMonsterHerd@@@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEPAPAVCXMasMonsterHerd@@PAPAV2@00@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Umove<CXMasMonsterHerd * *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z ; std::_Uninitialized_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Umove@PAUXMASMONSTER_MAP_INFO@@@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEPAUXMASMONSTER_MAP_INFO@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUXMASMONSTER_MAP_INFO@@@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEPAUXMASMONSTER_MAP_INFO@@PAU2@00@Z PROC ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Umove<XMASMONSTER_MAP_INFO *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z ; std::_Uninitialized_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUXMASMONSTER_MAP_INFO@@@?$vector@UXMASMONSTER_MAP_INFO@@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@IAEPAUXMASMONSTER_MAP_INFO@@PAU2@00@Z ENDP ; std::vector<XMASMONSTER_MAP_INFO,std::allocator<XMASMONSTER_MAP_INFO> >::_Umove<XMASMONSTER_MAP_INFO *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >
PUBLIC	??$_Ptr_cat@UXMASMONSTER_MAP_INFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_MAP_INFO@@0@Z ; std::_Ptr_cat<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z
_TEXT	SEGMENT
$T235402 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UXMASMONSTER_MAP_INFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_MAP_INFO@@0@Z ; std::_Ptr_cat<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235402[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235402[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
PUBLIC	??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
$T235405 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235405[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235405[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T235408 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@IPAU1@@Z PROC ; std::_Allocate<XMASMONSTER_EVENT_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T235408[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T235408[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@IPAU1@@Z ENDP ; std::_Allocate<XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
PUBLIC	??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
$T235411 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235411[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235411[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T235414 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@IPAU1@@Z PROC ; std::_Allocate<XMASMONSTER_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 55 55
	55 15		 cmp	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T235414[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T235414[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@IPAU1@@Z ENDP ; std::_Allocate<XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@IPAPAV1@@Z
_TEXT	SEGMENT
$T235417 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@IPAPAV1@@Z PROC ; std::_Allocate<CXMasMonsterHerd *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@3

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@3
$LN4@Allocate@3:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@3
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T235417[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T235417[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@3:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@3:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@PAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@IPAPAV1@@Z ENDP ; std::_Allocate<CXMasMonsterHerd *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@IPAU1@@Z
_TEXT	SEGMENT
$T235420 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@IPAU1@@Z PROC ; std::_Allocate<XMASMONSTER_MAP_INFO>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@4

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@4
$LN4@Allocate@4:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 cc cc
	cc 0c		 cmp	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH
  00026	77 18		 ja	 SHORT $LN1@Allocate@4
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 14	 imul	 eax, 20			; 00000014H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T235420[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T235420[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@4:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@4:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@IPAU1@@Z ENDP ; std::_Allocate<XMASMONSTER_MAP_INFO>
_TEXT	ENDS
PUBLIC	??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::_Construct<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@ABU3@@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::_Construct<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@ABU3@@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z ; std::_Construct<XMASMONSTER_DATA,XMASMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@ABU3@@Z PROC ; std::allocator<XMASMONSTER_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z ; std::_Construct<XMASMONSTER_DATA,XMASMONSTER_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@ABU3@@Z ENDP ; std::allocator<XMASMONSTER_DATA>::construct
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z$0
__ehfuncinfo$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T235427 = -88						; size = 4
$T235428 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z PROC ; std::allocator<CXMasMonsterHerd *>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235428[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235428[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@PAVCXMasMonsterHerd@@@std@@YA$$QAPAVCXMasMonsterHerd@@AAPAV1@@Z ; std::forward<CXMasMonsterHerd *>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T235428[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 02		 mov	 DWORD PTR [edx], eax
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T235428[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T235427[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235428[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@$$QAPAV3@@Z ENDP ; std::allocator<CXMasMonsterHerd *>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::_Construct<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@ABU3@@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::_Construct<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@ABU3@@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUXMASMONSTER_EVENT_TIME@@@std@@YAAAUXMASMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUXMASMONSTER_EVENT_TIME@@@std@@YAAAUXMASMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::forward<XMASMONSTER_EVENT_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUXMASMONSTER_EVENT_TIME@@@std@@YAAAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::forward<XMASMONSTER_EVENT_TIME &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235448 = -88						; size = 4
$T235449 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::construct<XMASMONSTER_EVENT_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235449[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235449[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUXMASMONSTER_EVENT_TIME@@@std@@YAAAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T235449[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T235449[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T235448[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235449[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUXMASMONSTER_EVENT_TIME@@@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@AAU2@@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::construct<XMASMONSTER_EVENT_TIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUXMASMONSTER_EVENT_TIME@@@std@@YAABUXMASMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUXMASMONSTER_EVENT_TIME@@@std@@YAABUXMASMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::forward<XMASMONSTER_EVENT_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUXMASMONSTER_EVENT_TIME@@@std@@YAABUXMASMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::forward<XMASMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUXMASMONSTER_DATA@@@std@@YAAAUXMASMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUXMASMONSTER_DATA@@@std@@YAAAUXMASMONSTER_DATA@@AAU1@@Z PROC ; std::forward<XMASMONSTER_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUXMASMONSTER_DATA@@@std@@YAAAUXMASMONSTER_DATA@@AAU1@@Z ENDP ; std::forward<XMASMONSTER_DATA &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235465 = -88						; size = 4
$T235466 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z PROC ; std::allocator<XMASMONSTER_DATA>::construct<XMASMONSTER_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235466[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235466[ebp], 0
  00047	74 27		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUXMASMONSTER_DATA@@@std@@YAAAUXMASMONSTER_DATA@@AAU1@@Z ; std::forward<XMASMONSTER_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T235466[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00065	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00068	8b 4d ac	 mov	 ecx, DWORD PTR $T235466[ebp]
  0006b	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0006e	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  00070	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@3:
  00077	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0007a	89 55 a8	 mov	 DWORD PTR $T235465[ebp], edx
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235466[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUXMASMONSTER_DATA@@@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@AAU2@@Z ENDP ; std::allocator<XMASMONSTER_DATA>::construct<XMASMONSTER_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUXMASMONSTER_DATA@@@std@@YAABUXMASMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUXMASMONSTER_DATA@@@std@@YAABUXMASMONSTER_DATA@@ABU1@@Z PROC ; std::forward<XMASMONSTER_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUXMASMONSTER_DATA@@@std@@YAABUXMASMONSTER_DATA@@ABU1@@Z ENDP ; std::forward<XMASMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z PROC ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ENDP ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
_TEXT	ENDS
EXTRN	_memmove:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 2527 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAPAVCXMasMonsterHerd@@PAPAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CXMasMonsterHerd * *,CXMasMonsterHerd * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUXMASMONSTER_MAP_INFO@@@std@@YAAAUXMASMONSTER_MAP_INFO@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUXMASMONSTER_MAP_INFO@@@std@@YAAAUXMASMONSTER_MAP_INFO@@AAU1@@Z PROC ; std::forward<XMASMONSTER_MAP_INFO &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUXMASMONSTER_MAP_INFO@@@std@@YAAAUXMASMONSTER_MAP_INFO@@AAU1@@Z ENDP ; std::forward<XMASMONSTER_MAP_INFO &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235486 = -88						; size = 4
$T235487 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::construct<XMASMONSTER_MAP_INFO &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 14		 push	 20			; 00000014H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235487[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235487[ebp], 0
  00047	74 33		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUXMASMONSTER_MAP_INFO@@@std@@YAAAUXMASMONSTER_MAP_INFO@@AAU1@@Z ; std::forward<XMASMONSTER_MAP_INFO &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T235487[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00068	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0006e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00071	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00074	8b 4d ac	 mov	 ecx, DWORD PTR $T235487[ebp]
  00077	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0007a	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  0007c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@4:
  00083	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00086	89 55 a8	 mov	 DWORD PTR $T235486[ebp], edx
  00089	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235487[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUXMASMONSTER_MAP_INFO@@@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@AAU2@@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::construct<XMASMONSTER_MAP_INFO &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUXMASMONSTER_MAP_INFO@@@std@@YAABUXMASMONSTER_MAP_INFO@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUXMASMONSTER_MAP_INFO@@@std@@YAABUXMASMONSTER_MAP_INFO@@ABU1@@Z PROC ; std::forward<XMASMONSTER_MAP_INFO const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUXMASMONSTER_MAP_INFO@@@std@@YAABUXMASMONSTER_MAP_INFO@@ABU1@@Z ENDP ; std::forward<XMASMONSTER_MAP_INFO const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >, COMDAT

; 104  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 105  : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
PUBLIC	??$_Val_type@PAUXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Val_type<XMASMONSTER_EVENT_TIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
$T235503 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Uninitialized_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235503[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235503[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Val_type<XMASMONSTER_EVENT_TIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
PUBLIC	??$_Val_type@PAUXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@@Z ; std::_Val_type<XMASMONSTER_DATA *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Uninitialized_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
$T235506 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z PROC ; std::_Uninitialized_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235506[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235506[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@@Z ; std::_Val_type<XMASMONSTER_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCXMasMonsterHerd@@PAV1@PAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CXMasMonsterHerd *,CXMasMonsterHerd *,CXMasMonsterHerd *>
PUBLIC	??$_Val_type@PAPAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@@Z ; std::_Val_type<CXMasMonsterHerd * *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Uninitialized_move@PAPAVCXMasMonsterHerd@@PAPAV1@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z
_TEXT	SEGMENT
$T235509 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCXMasMonsterHerd@@PAPAV1@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z PROC ; std::_Uninitialized_move<CXMasMonsterHerd * *,CXMasMonsterHerd * *,std::allocator<CXMasMonsterHerd *> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235509[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235509[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAPAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@@Z ; std::_Val_type<CXMasMonsterHerd * *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAVCXMasMonsterHerd@@PAV1@PAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CXMasMonsterHerd *,CXMasMonsterHerd *,CXMasMonsterHerd *>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAPAVCXMasMonsterHerd@@PAPAV1@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ENDP ; std::_Uninitialized_move<CXMasMonsterHerd * *,CXMasMonsterHerd * *,std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
PUBLIC	??$_Val_type@PAUXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@@Z ; std::_Val_type<XMASMONSTER_MAP_INFO *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Uninitialized_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z
_TEXT	SEGMENT
$T235512 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z PROC ; std::_Uninitialized_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UXMASMONSTER_MAP_INFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_MAP_INFO@@0@Z ; std::_Ptr_cat<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235512[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235512[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@@Z ; std::_Val_type<XMASMONSTER_MAP_INFO *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@@Z ENDP ; std::_Uninitialized_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UXMASMONSTER_MAP_INFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_MAP_INFO@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UXMASMONSTER_MAP_INFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_MAP_INFO@@0@Z PROC ; std::_Ptr_cat<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UXMASMONSTER_MAP_INFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_MAP_INFO@@0@Z ENDP ; std::_Ptr_cat<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 14	 add	 eax, 20			; 00000014H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@0AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_MAP_INFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z PROC ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z ENDP ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z PROC ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z ENDP ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@3
$LN2@Destroy_ra@3:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@3:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@3

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@3
$LN4@Destroy_ra@3:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235527 = -88						; size = 4
$T235528 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::_Construct<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T235528[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T235528[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUXMASMONSTER_EVENT_TIME@@@std@@YAABUXMASMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T235528[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T235528[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T235527[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235528[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UXMASMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::_Construct<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235540 = -88						; size = 4
$T235541 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z PROC ; std::_Construct<XMASMONSTER_DATA,XMASMONSTER_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 0c		 push	 12			; 0000000cH
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T235541[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T235541[ebp], 0
  0004a	74 27		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUXMASMONSTER_DATA@@@std@@YAABUXMASMONSTER_DATA@@ABU1@@Z ; std::forward<XMASMONSTER_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T235541[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00065	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00068	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0006b	8b 4d ac	 mov	 ecx, DWORD PTR $T235541[ebp]
  0006e	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00071	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  00073	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
  0007a	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0007d	89 55 a8	 mov	 DWORD PTR $T235540[ebp], edx
  00080	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235541[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UXMASMONSTER_DATA@@ABU1@@std@@YAXPAUXMASMONSTER_DATA@@ABU1@@Z ENDP ; std::_Construct<XMASMONSTER_DATA,XMASMONSTER_DATA const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235553 = -88						; size = 4
$T235554 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z PROC ; std::_Construct<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 14		 push	 20			; 00000014H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T235554[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T235554[ebp], 0
  0004a	74 33		 je	 SHORT $LN3@Construct@3
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUXMASMONSTER_MAP_INFO@@@std@@YAABUXMASMONSTER_MAP_INFO@@ABU1@@Z ; std::forward<XMASMONSTER_MAP_INFO const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T235554[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0006b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00071	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00074	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00077	8b 4d ac	 mov	 ecx, DWORD PTR $T235554[ebp]
  0007a	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0007d	eb 07		 jmp	 SHORT $LN4@Construct@3
$LN3@Construct@3:
  0007f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@3:
  00086	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00089	89 55 a8	 mov	 DWORD PTR $T235553[ebp], edx
  0008c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235554[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UXMASMONSTER_MAP_INFO@@ABU1@@std@@YAXPAUXMASMONSTER_MAP_INFO@@ABU1@@Z ENDP ; std::_Construct<XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@@Z PROC ; std::_Val_type<XMASMONSTER_EVENT_TIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUXMASMONSTER_EVENT_TIME@@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@@Z ENDP ; std::_Val_type<XMASMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUXMASMONSTER_EVENT_TIME@@PAU1@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *,std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@@Z PROC ; std::_Val_type<XMASMONSTER_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUXMASMONSTER_DATA@@@std@@YAPAUXMASMONSTER_DATA@@PAU1@@Z ENDP ; std::_Val_type<XMASMONSTER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 0c	 add	 eax, 12			; 0000000cH
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUXMASMONSTER_DATA@@PAU1@V?$allocator@UXMASMONSTER_DATA@@@std@@U1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00AAV?$allocator@UXMASMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<XMASMONSTER_DATA *,XMASMONSTER_DATA *,std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@@Z PROC ; std::_Val_type<CXMasMonsterHerd * *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAPAVCXMasMonsterHerd@@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@@Z ENDP ; std::_Val_type<CXMasMonsterHerd * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAVCXMasMonsterHerd@@PAV1@PAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCXMasMonsterHerd@@PAV1@PAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CXMasMonsterHerd *,CXMasMonsterHerd *,CXMasMonsterHerd *>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002f	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 462  : 	}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAVCXMasMonsterHerd@@PAV1@PAV1@@std@@YAPAPAVCXMasMonsterHerd@@PAPAV1@00AAV?$allocator@PAVCXMasMonsterHerd@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CXMasMonsterHerd *,CXMasMonsterHerd *,CXMasMonsterHerd *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@@Z PROC ; std::_Val_type<XMASMONSTER_MAP_INFO *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUXMASMONSTER_MAP_INFO@@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@@Z ENDP ; std::_Val_type<XMASMONSTER_MAP_INFO *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@$$QAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@3
$LN5@Uninit_mov@3:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 14	 add	 eax, 20			; 00000014H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 14	 add	 ecx, 20			; 00000014H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@3:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@3

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@$$QAU2@@Z ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@3
$LN4@Uninit_mov@3:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@3
__catch$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@3
$LN2@Uninit_mov@3:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 14	 add	 eax, 20			; 00000014H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@3:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@3

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@3
$LN1@Uninit_mov@3:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@3:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@3:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUXMASMONSTER_MAP_INFO@@PAU1@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@U1@@std@@YAPAUXMASMONSTER_MAP_INFO@@PAU1@00AAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<XMASMONSTER_MAP_INFO *,XMASMONSTER_MAP_INFO *,std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
PUBLIC	?destroy@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@@Z PROC ; std::_Dest_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@@Z ENDP ; std::_Dest_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z ; std::allocator<XMASMONSTER_DATA>::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z PROC ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z ; std::allocator<XMASMONSTER_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Destroy<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Destroy<XMASMONSTER_EVENT_TIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z ; std::_Destroy<XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z PROC ; std::allocator<XMASMONSTER_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z ; std::_Destroy<XMASMONSTER_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z ENDP ; std::allocator<XMASMONSTER_DATA>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UXMASMONSTER_MAP_INFO@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@@Z ; std::_Destroy<XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UXMASMONSTER_MAP_INFO@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@@Z ; std::_Destroy<XMASMONSTER_MAP_INFO>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::construct
PUBLIC	??$forward@UXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z ; std::allocator<XMASMONSTER_DATA>::construct
PUBLIC	??$forward@UXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z ; std::forward<XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z ; std::forward<XMASMONSTER_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z ; std::allocator<XMASMONSTER_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA,XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::construct
PUBLIC	??$forward@UXMASMONSTER_MAP_INFO@@@std@@YA$$QAUXMASMONSTER_MAP_INFO@@AAU1@@Z ; std::forward<XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UXMASMONSTER_MAP_INFO@@@std@@YA$$QAUXMASMONSTER_MAP_INFO@@AAU1@@Z ; std::forward<XMASMONSTER_MAP_INFO>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z ; std::allocator<XMASMONSTER_MAP_INFO>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UXMASMONSTER_MAP_INFO@@@std@@UXMASMONSTER_MAP_INFO@@U3@@std@@YAXAAV?$allocator@UXMASMONSTER_MAP_INFO@@@0@PAUXMASMONSTER_MAP_INFO@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<XMASMONSTER_MAP_INFO>,XMASMONSTER_MAP_INFO,XMASMONSTER_MAP_INFO>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::_Destroy<XMASMONSTER_EVENT_TIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::_Destroy<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z PROC ; std::_Destroy<XMASMONSTER_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z ENDP ; std::_Destroy<XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UXMASMONSTER_MAP_INFO@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UXMASMONSTER_MAP_INFO@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@@Z PROC ; std::_Destroy<XMASMONSTER_MAP_INFO>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UXMASMONSTER_MAP_INFO@@@std@@YAXPAUXMASMONSTER_MAP_INFO@@@Z ENDP ; std::_Destroy<XMASMONSTER_MAP_INFO>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235645 = -88						; size = 4
$T235646 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235646[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235646[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@5
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<XMASMONSTER_EVENT_TIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T235646[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T235646[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@5
$LN3@construct@5:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@5:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T235645[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235646[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@$$QAU3@@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235658 = -88						; size = 4
$T235659 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z PROC ; std::allocator<XMASMONSTER_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235659[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235659[ebp], 0
  00047	74 27		 je	 SHORT $LN3@construct@6
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z ; std::forward<XMASMONSTER_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T235659[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00065	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00068	8b 4d ac	 mov	 ecx, DWORD PTR $T235659[ebp]
  0006b	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0006e	eb 07		 jmp	 SHORT $LN4@construct@6
$LN3@construct@6:
  00070	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@6:
  00077	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0007a	89 55 a8	 mov	 DWORD PTR $T235658[ebp], edx
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235659[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@$$QAU3@@Z ENDP ; std::allocator<XMASMONSTER_DATA>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235671 = -88						; size = 4
$T235672 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z PROC ; std::allocator<XMASMONSTER_MAP_INFO>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 14		 push	 20			; 00000014H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235672[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235672[ebp], 0
  00047	74 33		 je	 SHORT $LN3@construct@7
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UXMASMONSTER_MAP_INFO@@@std@@YA$$QAUXMASMONSTER_MAP_INFO@@AAU1@@Z ; std::forward<XMASMONSTER_MAP_INFO>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T235672[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00068	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0006e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00071	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00074	8b 4d ac	 mov	 ecx, DWORD PTR $T235672[ebp]
  00077	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0007a	eb 07		 jmp	 SHORT $LN4@construct@7
$LN3@construct@7:
  0007c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@7:
  00083	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00086	89 55 a8	 mov	 DWORD PTR $T235671[ebp], edx
  00089	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235672[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UXMASMONSTER_MAP_INFO@@@std@@QAEXPAUXMASMONSTER_MAP_INFO@@$$QAU3@@Z ENDP ; std::allocator<XMASMONSTER_MAP_INFO>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::forward<XMASMONSTER_EVENT_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::forward<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z PROC ; std::forward<XMASMONSTER_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z ENDP ; std::forward<XMASMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UXMASMONSTER_MAP_INFO@@@std@@YA$$QAUXMASMONSTER_MAP_INFO@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UXMASMONSTER_MAP_INFO@@@std@@YA$$QAUXMASMONSTER_MAP_INFO@@AAU1@@Z PROC ; std::forward<XMASMONSTER_MAP_INFO>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UXMASMONSTER_MAP_INFO@@@std@@YA$$QAUXMASMONSTER_MAP_INFO@@AAU1@@Z ENDP ; std::forward<XMASMONSTER_MAP_INFO>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@3
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@3:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
