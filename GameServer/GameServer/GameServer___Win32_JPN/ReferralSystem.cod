; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\ReferralSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
PUBLIC	?clear@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::clear
PUBLIC	??0?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
PUBLIC	??0CReferralSystem@@QAE@XZ			; CReferralSystem::CReferralSystem
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0CReferralSystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CReferralSystem@@QAE@XZ$0
__ehfuncinfo$??0CReferralSystem@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CReferralSystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\referralsystem.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CReferralSystem@@QAE@XZ PROC				; CReferralSystem::CReferralSystem
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CReferralSystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 04	 add	 ecx, 4
  00031	e8 00 00 00 00	 call	 ??0?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 18   : 	this->m_bActive = true;

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c6 00 01	 mov	 BYTE PTR [eax], 1

; 19   : 
; 20   : 	this->m_Data.clear();

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 04	 add	 ecx, 4
  00049	e8 00 00 00 00	 call	 ?clear@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::clear

; 21   : }

  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CReferralSystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
__ehhandler$??0CReferralSystem@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CReferralSystem@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CReferralSystem@@QAE@XZ ENDP				; CReferralSystem::CReferralSystem
PUBLIC	??1CReferralSystem@@QAE@XZ			; CReferralSystem::~CReferralSystem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CReferralSystem@@QAE@XZ PROC				; CReferralSystem::~CReferralSystem
; _this$ = ecx

; 24   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	83 ec 44	 sub	 esp, 68			; 00000044H
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : }

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 04	 add	 ecx, 4
  00082	e8 00 00 00 00	 call	 ??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
??1CReferralSystem@@QAE@XZ ENDP				; CReferralSystem::~CReferralSystem
_TEXT	ENDS
PUBLIC	?Read@CReferralSystem@@QAEXPAD@Z		; CReferralSystem::Read
PUBLIC	??_C@_0BK@PEDMLKHA@ExData?2ReferralSystem?4ini?$AA@ ; `string'
PUBLIC	?Load@CReferralSystem@@QAEXXZ			; CReferralSystem::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0BK@PEDMLKHA@ExData?2ReferralSystem?4ini?$AA@
CONST	SEGMENT
??_C@_0BK@PEDMLKHA@ExData?2ReferralSystem?4ini?$AA@ DB 'ExData\ReferralSy'
	DB	'stem.ini', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CReferralSystem@@QAEXXZ PROC			; CReferralSystem::Load
; _this$ = ecx

; 28   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	83 ec 44	 sub	 esp, 68			; 00000044H
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	this->m_bActive = true;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	c6 00 01	 mov	 BYTE PTR [eax], 1

; 30   : 
; 31   : 	if(!g_ExLicense.user.ReferralSystem)

  000a2	0f b6 05 ee 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+238
  000a9	85 c0		 test	 eax, eax
  000ab	75 08		 jne	 SHORT $LN1@Load

; 32   : 	{
; 33   : 		this->m_bActive = false;

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 34   : 		return;

  000b3	eb 23		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 35   : 	}
; 36   : 
; 37   : 	this->m_Data.clear();

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	83 c1 04	 add	 ecx, 4
  000bb	e8 00 00 00 00	 call	 ?clear@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::clear

; 38   : 
; 39   : 	this->Read(gDirPath.GetNewPath("ExData\\ReferralSystem.ini"));

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PEDMLKHA@ExData?2ReferralSystem?4ini?$AA@
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000ca	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000cf	50		 push	 eax
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?Read@CReferralSystem@@QAEXPAD@Z ; CReferralSystem::Read
$LN2@Load:

; 40   : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?Load@CReferralSystem@@QAEXXZ ENDP			; CReferralSystem::Load
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXABUREFERRAL_DATA@@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CE@CDFOJCP@?$FLReferral?5System?$FN?5?$CFs?5file?5not?5fo@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CDFOJCP@?$FLReferral?5System?$FN?5?$CFs?5file?5not?5fo@
CONST	SEGMENT
??_C@_0CE@CDFOJCP@?$FLReferral?5System?$FN?5?$CFs?5file?5not?5fo@ DB '[Re'
	DB	'ferral System] %s file not found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Info$228999 = -84					; size = 68
_iGroup$228992 = -16					; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_FileName$ = 8						; size = 4
?Read@CReferralSystem@@QAEXPAD@Z PROC			; CReferralSystem::Read
; _this$ = ecx

; 43   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000ee	33 c5		 xor	 eax, ebp
  000f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000f3	53		 push	 ebx
  000f4	56		 push	 esi
  000f5	57		 push	 edi
  000f6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 44   : 	SMDToken Token;
; 45   : 
; 46   : 	SMDFile = fopen(FileName, "r");

  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000fe	8b 45 08	 mov	 eax, DWORD PTR _FileName$[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _fopen
  00107	83 c4 08	 add	 esp, 8
  0010a	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 47   : 
; 48   : 	if(!SMDFile)

  0010f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00116	75 16		 jne	 SHORT $LN7@Read

; 49   : 	{
; 50   : 		MsgBox("[Referral System] %s file not found", FileName);

  00118	8b 45 08	 mov	 eax, DWORD PTR _FileName$[ebp]
  0011b	50		 push	 eax
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CDFOJCP@?$FLReferral?5System?$FN?5?$CFs?5file?5not?5fo@
  00121	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00126	83 c4 08	 add	 esp, 8

; 51   : 		return;

  00129	e9 05 02 00 00	 jmp	 $LN8@Read
$LN7@Read:

; 52   : 	}
; 53   : 
; 54   : 	while(true)

  0012e	b8 01 00 00 00	 mov	 eax, 1
  00133	85 c0		 test	 eax, eax
  00135	0f 84 d8 01 00
	00		 je	 $LN5@Read

; 55   : 	{
; 56   : 		Token = GetToken();

  0013b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00140	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 57   : 
; 58   : 		if(Token == END)

  00143	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00147	75 05		 jne	 SHORT $LN4@Read

; 59   : 		{
; 60   : 			break;

  00149	e9 c5 01 00 00	 jmp	 $LN5@Read
$LN4@Read:

; 61   : 		}
; 62   : 
; 63   : 		int iGroup = (int)TokenNumber;

  0014e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00154	e8 00 00 00 00	 call	 __ftol2_sse
  00159	89 45 f0	 mov	 DWORD PTR _iGroup$228992[ebp], eax
$LN3@Read:

; 64   : 
; 65   : 		while(true)

  0015c	b8 01 00 00 00	 mov	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	0f 84 a5 01 00
	00		 je	 $LN2@Read

; 66   : 		{
; 67   : 			Token = GetToken();

  00169	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0016e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 68   : 
; 69   : 			if(!strcmp("end", TokenString))

  00171	68 00 00 00 00	 push	 OFFSET _TokenString
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0017b	e8 00 00 00 00	 call	 _strcmp
  00180	83 c4 08	 add	 esp, 8
  00183	85 c0		 test	 eax, eax
  00185	75 05		 jne	 SHORT $LN1@Read

; 70   : 			{
; 71   : 				break;

  00187	e9 82 01 00 00	 jmp	 $LN2@Read
$LN1@Read:

; 72   : 			}
; 73   : 
; 74   : 			REFERRAL_DATA Info;
; 75   : 
; 76   : 			Info.UserNeedLevel = (int)TokenNumber;

  0018c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00192	e8 00 00 00 00	 call	 __ftol2_sse
  00197	89 45 ac	 mov	 DWORD PTR _Info$228999[ebp], eax

; 77   : 
; 78   : 			Token = GetToken();

  0019a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0019f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 79   : 			Info.UserNeedReset = (int)TokenNumber;

  001a2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a8	e8 00 00 00 00	 call	 __ftol2_sse
  001ad	89 45 b0	 mov	 DWORD PTR _Info$228999[ebp+4], eax

; 80   : 
; 81   : 			Token = GetToken();

  001b0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001b5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 82   : 			Info.UserNeedGrand = (int)TokenNumber;

  001b8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001be	e8 00 00 00 00	 call	 __ftol2_sse
  001c3	89 45 b4	 mov	 DWORD PTR _Info$228999[ebp+8], eax

; 83   : 
; 84   : 			Token = GetToken();

  001c6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001cb	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 85   : 			Info.MasterRewardCredit = (int)TokenNumber;

  001ce	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d4	e8 00 00 00 00	 call	 __ftol2_sse
  001d9	89 45 b8	 mov	 DWORD PTR _Info$228999[ebp+12], eax

; 86   : 
; 87   : 			Token = GetToken();

  001dc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001e1	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 88   : 			Info.MasterRewardWCoinC = (int)TokenNumber;

  001e4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ea	e8 00 00 00 00	 call	 __ftol2_sse
  001ef	89 45 bc	 mov	 DWORD PTR _Info$228999[ebp+16], eax

; 89   : 
; 90   : 			Token = GetToken();

  001f2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001f7	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 91   : 			Info.MasterRewardWCoinP = (int)TokenNumber;

  001fa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00200	e8 00 00 00 00	 call	 __ftol2_sse
  00205	89 45 c0	 mov	 DWORD PTR _Info$228999[ebp+20], eax

; 92   : 
; 93   : 			Token = GetToken();

  00208	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0020d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 94   : 			Info.MasterRewardWCoinG = (int)TokenNumber;

  00210	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00216	e8 00 00 00 00	 call	 __ftol2_sse
  0021b	89 45 c4	 mov	 DWORD PTR _Info$228999[ebp+24], eax

; 95   : 
; 96   : 			Token = GetToken();

  0021e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00223	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 97   : 			Info.MasterRewardPremiumType = (int)TokenNumber;

  00226	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0022c	e8 00 00 00 00	 call	 __ftol2_sse
  00231	89 45 cc	 mov	 DWORD PTR _Info$228999[ebp+32], eax

; 98   : 
; 99   : 			Token = GetToken();

  00234	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00239	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 100  : 			Info.MasterRewardPremiumTime = (int)TokenNumber;

  0023c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00242	e8 00 00 00 00	 call	 __ftol2_sse
  00247	89 45 d0	 mov	 DWORD PTR _Info$228999[ebp+36], eax

; 101  : 
; 102  : 			Token = GetToken();

  0024a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0024f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 103  : 			Info.MasterRewardBonus = (int)TokenNumber;

  00252	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00258	e8 00 00 00 00	 call	 __ftol2_sse
  0025d	89 45 c8	 mov	 DWORD PTR _Info$228999[ebp+28], eax

; 104  : 
; 105  : 			Token = GetToken();

  00260	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00265	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 106  : 			Info.UserRewardCredit = (int)TokenNumber;

  00268	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0026e	e8 00 00 00 00	 call	 __ftol2_sse
  00273	89 45 d4	 mov	 DWORD PTR _Info$228999[ebp+40], eax

; 107  : 
; 108  : 			Token = GetToken();

  00276	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0027b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 109  : 			Info.UserRewardWCoinC = (int)TokenNumber;

  0027e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00284	e8 00 00 00 00	 call	 __ftol2_sse
  00289	89 45 d8	 mov	 DWORD PTR _Info$228999[ebp+44], eax

; 110  : 
; 111  : 			Token = GetToken();

  0028c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00291	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 112  : 			Info.UserRewardWCoinP = (int)TokenNumber;

  00294	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0029a	e8 00 00 00 00	 call	 __ftol2_sse
  0029f	89 45 dc	 mov	 DWORD PTR _Info$228999[ebp+48], eax

; 113  : 
; 114  : 			Token = GetToken();

  002a2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002a7	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 115  : 			Info.UserRewardWCoinG = (int)TokenNumber;

  002aa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002b0	e8 00 00 00 00	 call	 __ftol2_sse
  002b5	89 45 e0	 mov	 DWORD PTR _Info$228999[ebp+52], eax

; 116  : 
; 117  : 			Token = GetToken();

  002b8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002bd	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 118  : 			Info.UserRewardPremiumType = (int)TokenNumber;

  002c0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002c6	e8 00 00 00 00	 call	 __ftol2_sse
  002cb	89 45 e8	 mov	 DWORD PTR _Info$228999[ebp+60], eax

; 119  : 
; 120  : 			Token = GetToken();

  002ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d3	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 121  : 			Info.UserRewardPremiumTime = (int)TokenNumber;

  002d6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002dc	e8 00 00 00 00	 call	 __ftol2_sse
  002e1	89 45 ec	 mov	 DWORD PTR _Info$228999[ebp+64], eax

; 122  : 
; 123  : 			Token = GetToken();

  002e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002e9	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 124  : 			Info.UserRewardBonus = (int)TokenNumber;

  002ec	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002f2	e8 00 00 00 00	 call	 __ftol2_sse
  002f7	89 45 e4	 mov	 DWORD PTR _Info$228999[ebp+56], eax

; 125  : 
; 126  : 			this->m_Data.push_back(Info);

  002fa	8d 45 ac	 lea	 eax, DWORD PTR _Info$228999[ebp]
  002fd	50		 push	 eax
  002fe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00301	83 c1 04	 add	 ecx, 4
  00304	e8 00 00 00 00	 call	 ?push_back@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXABUREFERRAL_DATA@@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::push_back

; 127  : 		}

  00309	e9 4e fe ff ff	 jmp	 $LN3@Read
$LN2@Read:

; 128  : 	}

  0030e	e9 1b fe ff ff	 jmp	 $LN7@Read
$LN5@Read:

; 129  : 
; 130  : 	fclose(SMDFile);

  00313	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 _fclose
  0031e	83 c4 04	 add	 esp, 4

; 131  : 
; 132  : 	LogAdd("%s file load!", FileName);

  00321	8b 45 08	 mov	 eax, DWORD PTR _FileName$[ebp]
  00324	50		 push	 eax
  00325	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  0032a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00330	83 c4 08	 add	 esp, 8
$LN8@Read:

; 133  : }

  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00339	33 cd		 xor	 ecx, ebp
  0033b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00340	8b e5		 mov	 esp, ebp
  00342	5d		 pop	 ebp
  00343	c2 04 00	 ret	 4
?Read@CReferralSystem@@QAEXPAD@Z ENDP			; CReferralSystem::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00350	55		 push	 ebp
  00351	8b ec		 mov	 ebp, esp
  00353	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00359	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0035e	33 c5		 xor	 eax, ebp
  00360	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00363	53		 push	 ebx
  00364	56		 push	 esi
  00365	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00366	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0036d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 _fgetc
  00378	83 c4 04	 add	 esp, 4
  0037b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0037e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00382	83 f9 ff	 cmp	 ecx, -1
  00385	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00387	b8 02 00 00 00	 mov	 eax, 2
  0038c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00391	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00393	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00397	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0039a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0039c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 _fgetc
  003a7	83 c4 04	 add	 esp, 4
  003aa	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  003ad	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003b1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  003b4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  003b6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003ba	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  003bd	74 1c		 je	 SHORT $LN23@GetToken
  003bf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003c3	83 f8 ff	 cmp	 eax, -1
  003c6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  003c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003cd	50		 push	 eax
  003ce	e8 00 00 00 00	 call	 _fgetc
  003d3	83 c4 04	 add	 esp, 4
  003d6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  003d9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  003db	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003df	83 f8 ff	 cmp	 eax, -1
  003e2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  003e4	b8 02 00 00 00	 mov	 eax, 2
  003e9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  003ee	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003f2	50		 push	 eax
  003f3	e8 00 00 00 00	 call	 _isspace
  003f8	83 c4 04	 add	 esp, 4
  003fb	85 c0		 test	 eax, eax
  003fd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00403	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00407	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0040d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00413	83 e9 22	 sub	 ecx, 34			; 00000022H
  00416	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0041c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00423	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00429	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0042f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00436	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0043d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00447	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0044c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00451	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00456	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00460	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00465	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0046a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0046f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00479	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0047e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00483	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00488	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00492	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00497	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0049c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  004a1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  004ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004b0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  004b5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  004ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004bf	50		 push	 eax
  004c0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004c4	51		 push	 ecx
  004c5	e8 00 00 00 00	 call	 _ungetc
  004ca	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  004cd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  004d0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  004d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004d8	50		 push	 eax
  004d9	e8 00 00 00 00	 call	 _getc
  004de	83 c4 04	 add	 esp, 4
  004e1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004e4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004e8	83 f9 ff	 cmp	 ecx, -1
  004eb	74 36		 je	 SHORT $LN12@GetToken
  004ed	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004f1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  004f4	74 1a		 je	 SHORT $LN11@GetToken
  004f6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004fa	50		 push	 eax
  004fb	e8 00 00 00 00	 call	 _isdigit
  00500	83 c4 04	 add	 esp, 4
  00503	85 c0		 test	 eax, eax
  00505	75 09		 jne	 SHORT $LN11@GetToken
  00507	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0050b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0050e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00510	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00513	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00516	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00518	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0051b	83 c0 01	 add	 eax, 1
  0051e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00521	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00523	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00526	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00529	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0052c	50		 push	 eax
  0052d	e8 00 00 00 00	 call	 _atof
  00532	83 c4 04	 add	 esp, 4
  00535	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0053b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00545	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0054a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0054f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00554	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0055b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00560	50		 push	 eax
  00561	e8 00 00 00 00	 call	 _getc
  00566	83 c4 04	 add	 esp, 4
  00569	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0056c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00570	83 f9 ff	 cmp	 ecx, -1
  00573	74 1c		 je	 SHORT $LN8@GetToken
  00575	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00579	83 f8 22	 cmp	 eax, 34			; 00000022H
  0057c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0057e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00581	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00584	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00586	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00589	83 c0 01	 add	 eax, 1
  0058c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0058f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00591	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00595	83 f8 22	 cmp	 eax, 34			; 00000022H
  00598	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0059a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0059f	50		 push	 eax
  005a0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005a4	51		 push	 ecx
  005a5	e8 00 00 00 00	 call	 _ungetc
  005aa	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  005ad	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  005b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  005bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005c2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  005c7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  005cc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005d0	50		 push	 eax
  005d1	e8 00 00 00 00	 call	 _isalpha
  005d6	83 c4 04	 add	 esp, 4
  005d9	85 c0		 test	 eax, eax
  005db	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  005e1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  005e8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005eb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005ee	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  005f0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005f3	83 c0 01	 add	 eax, 1
  005f6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  005f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 _getc
  00604	83 c4 04	 add	 esp, 4
  00607	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0060a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0060e	83 f9 ff	 cmp	 ecx, -1
  00611	74 36		 je	 SHORT $LN3@GetToken
  00613	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00617	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0061a	74 1a		 je	 SHORT $LN2@GetToken
  0061c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00620	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00623	74 11		 je	 SHORT $LN2@GetToken
  00625	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00629	50		 push	 eax
  0062a	e8 00 00 00 00	 call	 _isalnum
  0062f	83 c4 04	 add	 esp, 4
  00632	85 c0		 test	 eax, eax
  00634	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00636	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00639	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0063c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0063e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00641	83 c0 01	 add	 eax, 1
  00644	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00647	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00649	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0064e	50		 push	 eax
  0064f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00653	51		 push	 ecx
  00654	e8 00 00 00 00	 call	 _ungetc
  00659	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0065c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0065f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00662	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0066c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00671	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00673	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00675	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0067f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00684	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00686	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00688	5f		 pop	 edi
  00689	5e		 pop	 esi
  0068a	5b		 pop	 ebx
  0068b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0068e	33 cd		 xor	 ecx, ebp
  00690	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00695	8b e5		 mov	 esp, ebp
  00697	5d		 pop	 ebp
  00698	c3		 ret	 0
  00699	8d 49 00	 npad	 3
$LN35@GetToken:
  0069c	00 00 00 00	 DD	 $LN10@GetToken
  006a0	00 00 00 00	 DD	 $LN19@GetToken
  006a4	00 00 00 00	 DD	 $LN17@GetToken
  006a8	00 00 00 00	 DD	 $LN14@GetToken
  006ac	00 00 00 00	 DD	 $LN18@GetToken
  006b0	00 00 00 00	 DD	 $LN16@GetToken
  006b4	00 00 00 00	 DD	 $LN15@GetToken
  006b8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  006bc	00		 DB	 0
  006bd	01		 DB	 1
  006be	07		 DB	 7
  006bf	07		 DB	 7
  006c0	07		 DB	 7
  006c1	07		 DB	 7
  006c2	07		 DB	 7
  006c3	07		 DB	 7
  006c4	07		 DB	 7
  006c5	07		 DB	 7
  006c6	02		 DB	 2
  006c7	03		 DB	 3
  006c8	03		 DB	 3
  006c9	07		 DB	 7
  006ca	03		 DB	 3
  006cb	03		 DB	 3
  006cc	03		 DB	 3
  006cd	03		 DB	 3
  006ce	03		 DB	 3
  006cf	03		 DB	 3
  006d0	03		 DB	 3
  006d1	03		 DB	 3
  006d2	03		 DB	 3
  006d3	03		 DB	 3
  006d4	07		 DB	 7
  006d5	04		 DB	 4
  006d6	07		 DB	 7
  006d7	07		 DB	 7
  006d8	07		 DB	 7
  006d9	07		 DB	 7
  006da	07		 DB	 7
  006db	07		 DB	 7
  006dc	07		 DB	 7
  006dd	07		 DB	 7
  006de	07		 DB	 7
  006df	07		 DB	 7
  006e0	07		 DB	 7
  006e1	07		 DB	 7
  006e2	07		 DB	 7
  006e3	07		 DB	 7
  006e4	07		 DB	 7
  006e5	07		 DB	 7
  006e6	07		 DB	 7
  006e7	07		 DB	 7
  006e8	07		 DB	 7
  006e9	07		 DB	 7
  006ea	07		 DB	 7
  006eb	07		 DB	 7
  006ec	07		 DB	 7
  006ed	07		 DB	 7
  006ee	07		 DB	 7
  006ef	07		 DB	 7
  006f0	07		 DB	 7
  006f1	07		 DB	 7
  006f2	07		 DB	 7
  006f3	07		 DB	 7
  006f4	07		 DB	 7
  006f5	07		 DB	 7
  006f6	07		 DB	 7
  006f7	07		 DB	 7
  006f8	07		 DB	 7
  006f9	07		 DB	 7
  006fa	07		 DB	 7
  006fb	07		 DB	 7
  006fc	07		 DB	 7
  006fd	07		 DB	 7
  006fe	07		 DB	 7
  006ff	07		 DB	 7
  00700	07		 DB	 7
  00701	07		 DB	 7
  00702	07		 DB	 7
  00703	07		 DB	 7
  00704	07		 DB	 7
  00705	07		 DB	 7
  00706	07		 DB	 7
  00707	07		 DB	 7
  00708	07		 DB	 7
  00709	07		 DB	 7
  0070a	07		 DB	 7
  0070b	07		 DB	 7
  0070c	07		 DB	 7
  0070d	07		 DB	 7
  0070e	07		 DB	 7
  0070f	07		 DB	 7
  00710	07		 DB	 7
  00711	07		 DB	 7
  00712	07		 DB	 7
  00713	07		 DB	 7
  00714	07		 DB	 7
  00715	05		 DB	 5
  00716	07		 DB	 7
  00717	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?GDReqMasterInfo@CReferralSystem@@QAEXHH@Z	; CReferralSystem::GDReqMasterInfo
PUBLIC	?CGReqMasterInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_MASTER_INFO@@H@Z ; CReferralSystem::CGReqMasterInfo
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\referralsystem.cpp
_TEXT	SEGMENT
tv69 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqMasterInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_MASTER_INFO@@H@Z PROC ; CReferralSystem::CGReqMasterInfo
; _this$ = ecx

; 136  : {

  00720	55		 push	 ebp
  00721	8b ec		 mov	 ebp, esp
  00723	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00726	53		 push	 ebx
  00727	56		 push	 esi
  00728	57		 push	 edi
  00729	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 	if(!this->m_bActive)

  0072c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0072f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00732	85 c9		 test	 ecx, ecx
  00734	75 02		 jne	 SHORT $LN3@CGReqMaste

; 138  : 	{
; 139  : 		return;

  00736	eb 56		 jmp	 SHORT $LN4@CGReqMaste
$LN3@CGReqMaste:

; 140  : 	}
; 141  : 
; 142  : 	if(!OBJMAX_RANGE(aIndex))

  00738	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0073c	7d 09		 jge	 SHORT $LN6@CGReqMaste
  0073e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00745	eb 0f		 jmp	 SHORT $LN7@CGReqMaste
$LN6@CGReqMaste:
  00747	33 c0		 xor	 eax, eax
  00749	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00750	0f 9e c0	 setle	 al
  00753	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN7@CGReqMaste:
  00756	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  0075a	75 02		 jne	 SHORT $LN2@CGReqMaste

; 143  : 	{
; 144  : 		return;

  0075c	eb 30		 jmp	 SHORT $LN4@CGReqMaste
$LN2@CGReqMaste:

; 145  : 	}
; 146  : 
; 147  : 	LPOBJ lpUser = &gObj[aIndex];

  0075e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00761	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00767	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0076d	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 148  : 
; 149  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00770	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00773	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00777	7d 02		 jge	 SHORT $LN1@CGReqMaste

; 150  : 	{
; 151  : 		return;

  00779	eb 13		 jmp	 SHORT $LN4@CGReqMaste
$LN1@CGReqMaste:

; 152  : 	}
; 153  : 
; 154  : 	this->GDReqMasterInfo(aIndex, lpMsg->PageNumber);

  0077b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0077e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00781	51		 push	 ecx
  00782	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00785	52		 push	 edx
  00786	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00789	e8 00 00 00 00	 call	 ?GDReqMasterInfo@CReferralSystem@@QAEXHH@Z ; CReferralSystem::GDReqMasterInfo
$LN4@CGReqMaste:

; 155  : }

  0078e	5f		 pop	 edi
  0078f	5e		 pop	 esi
  00790	5b		 pop	 ebx
  00791	8b e5		 mov	 esp, ebp
  00793	5d		 pop	 ebp
  00794	c2 08 00	 ret	 8
?CGReqMasterInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_MASTER_INFO@@H@Z ENDP ; CReferralSystem::CGReqMasterInfo
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	__$ArrayPad$
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -116						; size = 4
_szName$ = -48						; size = 11
_pMsg$ = -36						; size = 24
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Page$ = 12						; size = 4
?GDReqMasterInfo@CReferralSystem@@QAEXHH@Z PROC		; CReferralSystem::GDReqMasterInfo
; _this$ = ecx

; 158  : {

  007a0	55		 push	 ebp
  007a1	8b ec		 mov	 ebp, esp
  007a3	83 ec 74	 sub	 esp, 116		; 00000074H
  007a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  007ab	33 c5		 xor	 eax, ebp
  007ad	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  007b0	53		 push	 ebx
  007b1	56		 push	 esi
  007b2	57		 push	 edi
  007b3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 159  : 	if(!this->m_bActive)

  007b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007b9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  007bc	85 c9		 test	 ecx, ecx
  007be	75 05		 jne	 SHORT $LN2@GDReqMaste

; 160  : 	{
; 161  : 		return;

  007c0	e9 aa 00 00 00	 jmp	 $LN3@GDReqMaste
$LN2@GDReqMaste:

; 162  : 	}
; 163  : 
; 164  : 	if(!OBJMAX_RANGE(aIndex))

  007c5	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  007c9	7d 09		 jge	 SHORT $LN5@GDReqMaste
  007cb	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  007d2	eb 0f		 jmp	 SHORT $LN6@GDReqMaste
$LN5@GDReqMaste:
  007d4	33 c0		 xor	 eax, eax
  007d6	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  007dd	0f 9e c0	 setle	 al
  007e0	89 45 8c	 mov	 DWORD PTR tv69[ebp], eax
$LN6@GDReqMaste:
  007e3	83 7d 8c 00	 cmp	 DWORD PTR tv69[ebp], 0
  007e7	75 05		 jne	 SHORT $LN1@GDReqMaste

; 165  : 	{
; 166  : 		return;

  007e9	e9 81 00 00 00	 jmp	 $LN3@GDReqMaste
$LN1@GDReqMaste:

; 167  : 	}
; 168  : 
; 169  : 	LPOBJ lpUser = &gObj[aIndex];

  007ee	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007f1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  007f7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007fd	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 170  : 
; 171  : 	PMSG_GDREQ_REFERRAL_INFO pMsg;
; 172  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEB, 0x14, sizeof(pMsg));

  00800	6a 18		 push	 24			; 00000018H
  00802	6a 14		 push	 20			; 00000014H
  00804	68 eb 00 00 00	 push	 235			; 000000ebH
  00809	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0080c	50		 push	 eax
  0080d	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00810	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 173  : 	pMsg.aIndex = aIndex;

  00815	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00818	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 174  : 
; 175  : 	char szName[11] = { 0 };

  0081b	c6 45 d0 00	 mov	 BYTE PTR _szName$[ebp], 0
  0081f	33 c0		 xor	 eax, eax
  00821	89 45 d1	 mov	 DWORD PTR _szName$[ebp+1], eax
  00824	89 45 d5	 mov	 DWORD PTR _szName$[ebp+5], eax
  00827	66 89 45 d9	 mov	 WORD PTR _szName$[ebp+9], ax

; 176  : 	memcpy(szName, lpUser->Name, sizeof(szName));

  0082b	6a 0b		 push	 11			; 0000000bH
  0082d	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00830	83 c0 77	 add	 eax, 119		; 00000077H
  00833	50		 push	 eax
  00834	8d 4d d0	 lea	 ecx, DWORD PTR _szName$[ebp]
  00837	51		 push	 ecx
  00838	e8 00 00 00 00	 call	 _memcpy
  0083d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 	szName[10] = 0;

  00840	c6 45 da 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 178  : 
; 179  : 	memcpy(pMsg.Name, szName, sizeof(szName)-1);

  00844	6a 0a		 push	 10			; 0000000aH
  00846	8d 45 d0	 lea	 eax, DWORD PTR _szName$[ebp]
  00849	50		 push	 eax
  0084a	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp+8]
  0084d	51		 push	 ecx
  0084e	e8 00 00 00 00	 call	 _memcpy
  00853	83 c4 0c	 add	 esp, 12			; 0000000cH

; 180  : 	pMsg.PageNumber = Page;

  00856	8b 45 0c	 mov	 eax, DWORD PTR _Page$[ebp]
  00859	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 181  : 
; 182  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0085c	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00860	50		 push	 eax
  00861	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00864	51		 push	 ecx
  00865	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0086a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqMaste:

; 183  : }

  0086f	5f		 pop	 edi
  00870	5e		 pop	 esi
  00871	5b		 pop	 ebx
  00872	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00875	33 cd		 xor	 ecx, ebp
  00877	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0087c	8b e5		 mov	 esp, ebp
  0087e	5d		 pop	 ebp
  0087f	c2 08 00	 ret	 8
?GDReqMasterInfo@CReferralSystem@@QAEXHH@Z ENDP		; CReferralSystem::GDReqMasterInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
PUBLIC	?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
PUBLIC	?set@PWMSG_HEAD2@@QAEXPAEEEH@Z			; PWMSG_HEAD2::set
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsMasterInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_MASTER_INFO@@@Z ; CReferralSystem::DGAnsMasterInfo
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjGetIndex@@YAHPAD@Z:PROC			; gObjGetIndex
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\referralsystem.cpp
_TEXT	SEGMENT
tv172 = -844						; size = 4
tv68 = -844						; size = 4
_pData$229058 = -776					; size = 4
_iStage$229056 = -772					; size = 4
_lpReferral$229054 = -768				; size = 4
_ReferralIndex$229052 = -764				; size = 4
_i$229048 = -760					; size = 4
_pMsg$ = -756						; size = 740
_lpUser$ = -16						; size = 4
_aIndex$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsMasterInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_MASTER_INFO@@@Z PROC ; CReferralSystem::DGAnsMasterInfo
; _this$ = ecx

; 186  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	81 ec 4c 03 00
	00		 sub	 esp, 844		; 0000034cH
  00899	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0089e	33 c5		 xor	 eax, ebp
  008a0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  008a3	53		 push	 ebx
  008a4	56		 push	 esi
  008a5	57		 push	 edi
  008a6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 	int aIndex = lpMsg->aIndex;

  008a9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008af	89 4d f4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 188  : 
; 189  : 	if(!OBJMAX_RANGE(aIndex))

  008b2	83 7d f4 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  008b6	7d 0c		 jge	 SHORT $LN10@DGAnsMaste
  008b8	c7 85 b4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  008c2	eb 12		 jmp	 SHORT $LN11@DGAnsMaste
$LN10@DGAnsMaste:
  008c4	33 c0		 xor	 eax, eax
  008c6	81 7d f4 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  008cd	0f 9e c0	 setle	 al
  008d0	89 85 b4 fc ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN11@DGAnsMaste:
  008d6	83 bd b4 fc ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  008dd	75 05		 jne	 SHORT $LN7@DGAnsMaste

; 190  : 	{
; 191  : 		return;

  008df	e9 bb 03 00 00	 jmp	 $LN8@DGAnsMaste
$LN7@DGAnsMaste:

; 192  : 	}
; 193  : 
; 194  : 	LPOBJ lpUser = &gObj[aIndex];

  008e4	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008e7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  008ed	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008f3	89 45 f0	 mov	 DWORD PTR _lpUser$[ebp], eax

; 195  : 
; 196  : 	PMSG_ANS_REFERRAL_MASTER_INFO pMsg;
; 197  : 	memset(&pMsg, 0, sizeof(pMsg));

  008f6	68 e4 02 00 00	 push	 740			; 000002e4H
  008fb	6a 00		 push	 0
  008fd	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00903	50		 push	 eax
  00904	e8 00 00 00 00	 call	 _memset
  00909	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFA, 0xAE, sizeof(pMsg));

  0090c	68 e4 02 00 00	 push	 740			; 000002e4H
  00911	68 ae 00 00 00	 push	 174			; 000000aeH
  00916	68 fa 00 00 00	 push	 250			; 000000faH
  0091b	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00921	50		 push	 eax
  00922	8d 8d 0c fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00928	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD2@@QAEXPAEEEH@Z ; PWMSG_HEAD2::set

; 199  : 	pMsg.RefferalMaxStage = this->m_Data.size();

  0092d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00930	83 c1 04	 add	 ecx, 4
  00933	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  00938	89 85 14 fd ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 200  : 	pMsg.ReferralCount = lpMsg->Count;

  0093e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00941	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00944	89 8d 18 fd ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+12], ecx

; 201  : 	pMsg.ReferralTotal = lpMsg->TotalCount;

  0094a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0094d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00950	89 8d 1c fd ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 202  : 
; 203  : 	for(int i = 0; i < REFERRAL_MAXDATA; i++)

  00956	c7 85 08 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$229048[ebp], 0
  00960	eb 0f		 jmp	 SHORT $LN6@DGAnsMaste
$LN5@DGAnsMaste:
  00962	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00968	83 c0 01	 add	 eax, 1
  0096b	89 85 08 fd ff
	ff		 mov	 DWORD PTR _i$229048[ebp], eax
$LN6@DGAnsMaste:
  00971	83 bd 08 fd ff
	ff 0a		 cmp	 DWORD PTR _i$229048[ebp], 10 ; 0000000aH
  00978	0f 8d 09 03 00
	00		 jge	 $LN4@DGAnsMaste

; 204  : 	{
; 205  : 		lpUser->RefferalMaster[i] = lpMsg->Player[i].RefferalMaster;

  0097e	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00984	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00987	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  0098d	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00990	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00993	8b 44 06 20	 mov	 eax, DWORD PTR [esi+eax+32]
  00997	89 84 8a 34 2a
	00 00		 mov	 DWORD PTR [edx+ecx*4+10804], eax

; 206  : 		lpUser->RefferalUserLevel[i] = lpMsg->Player[i].RefferalUserLevel;

  0099e	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  009a4	6b c0 1c	 imul	 eax, 28			; 0000001cH
  009a7	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  009ad	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  009b0	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  009b3	8b 44 06 24	 mov	 eax, DWORD PTR [esi+eax+36]
  009b7	89 84 8a 5c 2a
	00 00		 mov	 DWORD PTR [edx+ecx*4+10844], eax

; 207  : 		lpUser->RefferalUserReset[i] = lpMsg->Player[i].RefferalUserReset;

  009be	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  009c4	6b c0 1c	 imul	 eax, 28			; 0000001cH
  009c7	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  009cd	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  009d0	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  009d3	8b 44 06 28	 mov	 eax, DWORD PTR [esi+eax+40]
  009d7	89 84 8a 84 2a
	00 00		 mov	 DWORD PTR [edx+ecx*4+10884], eax

; 208  : 		lpUser->RefferalUserGrand[i] = lpMsg->Player[i].RefferalUserGrand;

  009de	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  009e4	6b c0 1c	 imul	 eax, 28			; 0000001cH
  009e7	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  009ed	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  009f0	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  009f3	8b 44 06 2c	 mov	 eax, DWORD PTR [esi+eax+44]
  009f7	89 84 8a ac 2a
	00 00		 mov	 DWORD PTR [edx+ecx*4+10924], eax

; 209  : 
; 210  : 		memcpy(pMsg.Data[i].RefferalName, lpMsg->Player[i].RefferalName, sizeof(lpMsg->Player[i].RefferalName)-1);

  009fe	6a 0a		 push	 10			; 0000000aH
  00a00	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00a06	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00a09	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00a0c	8d 54 01 14	 lea	 edx, DWORD PTR [ecx+eax+20]
  00a10	52		 push	 edx
  00a11	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00a17	6b c0 48	 imul	 eax, 72			; 00000048H
  00a1a	8d 8c 05 20 fd
	ff ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+eax+20]
  00a21	51		 push	 ecx
  00a22	e8 00 00 00 00	 call	 _memcpy
  00a27	83 c4 0c	 add	 esp, 12			; 0000000cH

; 211  : 
; 212  : 		pMsg.Data[i].RefferalMaster = lpMsg->Player[i].RefferalMaster;

  00a2a	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00a30	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00a33	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  00a39	6b c9 48	 imul	 ecx, 72			; 00000048H
  00a3c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00a3f	8b 44 02 20	 mov	 eax, DWORD PTR [edx+eax+32]
  00a43	89 84 0d 2c fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+ecx+32], eax

; 213  : 		pMsg.Data[i].UserOnline = 0;

  00a4a	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00a50	6b c0 48	 imul	 eax, 72			; 00000048H
  00a53	c7 84 05 30 fd
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pMsg$[ebp+eax+36], 0

; 214  : 
; 215  : 		int ReferralIndex = gObjGetIndex(pMsg.Data[i].RefferalName);

  00a5e	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00a64	6b c0 48	 imul	 eax, 72			; 00000048H
  00a67	8d 8c 05 20 fd
	ff ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+eax+20]
  00a6e	51		 push	 ecx
  00a6f	e8 00 00 00 00	 call	 ?gObjGetIndex@@YAHPAD@Z	; gObjGetIndex
  00a74	83 c4 04	 add	 esp, 4
  00a77	89 85 04 fd ff
	ff		 mov	 DWORD PTR _ReferralIndex$229052[ebp], eax

; 216  : 
; 217  : 		if(OBJMAX_RANGE(ReferralIndex))

  00a7d	83 bd 04 fd ff
	ff 00		 cmp	 DWORD PTR _ReferralIndex$229052[ebp], 0
  00a84	7d 0c		 jge	 SHORT $LN12@DGAnsMaste
  00a86	c7 85 b4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
  00a90	eb 15		 jmp	 SHORT $LN13@DGAnsMaste
$LN12@DGAnsMaste:
  00a92	33 c0		 xor	 eax, eax
  00a94	81 bd 04 fd ff
	ff 97 3a 00 00	 cmp	 DWORD PTR _ReferralIndex$229052[ebp], 14999 ; 00003a97H
  00a9e	0f 9e c0	 setle	 al
  00aa1	89 85 b4 fc ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
$LN13@DGAnsMaste:
  00aa7	83 bd b4 fc ff
	ff 00		 cmp	 DWORD PTR tv172[ebp], 0
  00aae	74 38		 je	 SHORT $LN3@DGAnsMaste

; 218  : 		{
; 219  : 			LPOBJ lpReferral = &gObj[ReferralIndex];

  00ab0	8b 85 04 fd ff
	ff		 mov	 eax, DWORD PTR _ReferralIndex$229052[ebp]
  00ab6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00abc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ac2	89 85 00 fd ff
	ff		 mov	 DWORD PTR _lpReferral$229054[ebp], eax

; 220  : 
; 221  : 			if(lpReferral->Connected == PLAYER_PLAYING)

  00ac8	8b 85 00 fd ff
	ff		 mov	 eax, DWORD PTR _lpReferral$229054[ebp]
  00ace	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00ad2	75 14		 jne	 SHORT $LN3@DGAnsMaste

; 222  : 			{
; 223  : 				pMsg.Data[i].UserOnline = 1;

  00ad4	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00ada	6b c0 48	 imul	 eax, 72			; 00000048H
  00add	c7 84 05 30 fd
	ff ff 01 00 00
	00		 mov	 DWORD PTR _pMsg$[ebp+eax+36], 1
$LN3@DGAnsMaste:

; 224  : 			}
; 225  : 		}
; 226  : 
; 227  : 		pMsg.Data[i].UserLevel = lpMsg->Player[i].RefferalUserLevel;

  00ae8	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00aee	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00af1	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  00af7	6b c9 48	 imul	 ecx, 72			; 00000048H
  00afa	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00afd	8b 44 02 24	 mov	 eax, DWORD PTR [edx+eax+36]
  00b01	89 84 0d 34 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+ecx+40], eax

; 228  : 		pMsg.Data[i].UserReset = lpMsg->Player[i].RefferalUserReset;

  00b08	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00b0e	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00b11	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  00b17	6b c9 48	 imul	 ecx, 72			; 00000048H
  00b1a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00b1d	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00b21	89 84 0d 38 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+ecx+44], eax

; 229  : 		pMsg.Data[i].UserGrand = lpMsg->Player[i].RefferalUserGrand;

  00b28	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00b2e	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00b31	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _i$229048[ebp]
  00b37	6b c9 48	 imul	 ecx, 72			; 00000048H
  00b3a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00b3d	8b 44 02 2c	 mov	 eax, DWORD PTR [edx+eax+44]
  00b41	89 84 0d 3c fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+ecx+48], eax

; 230  : 
; 231  : 		int iStage = pMsg.Data[i].RefferalMaster;

  00b48	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00b4e	6b c0 48	 imul	 eax, 72			; 00000048H
  00b51	8b 8c 05 2c fd
	ff ff		 mov	 ecx, DWORD PTR _pMsg$[ebp+eax+32]
  00b58	89 8d fc fc ff
	ff		 mov	 DWORD PTR _iStage$229056[ebp], ecx

; 232  : 
; 233  : 		if(pMsg.RefferalMaxStage < iStage)

  00b5e	8b 85 14 fd ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp+8]
  00b64	3b 85 fc fc ff
	ff		 cmp	 eax, DWORD PTR _iStage$229056[ebp]
  00b6a	7d 05		 jge	 SHORT $LN1@DGAnsMaste

; 234  : 		{
; 235  : 			continue;

  00b6c	e9 f1 fd ff ff	 jmp	 $LN5@DGAnsMaste
$LN1@DGAnsMaste:

; 236  : 		}
; 237  : 
; 238  : 		REFERRAL_DATA * pData = &this->m_Data[iStage];

  00b71	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _iStage$229056[ebp]
  00b77	50		 push	 eax
  00b78	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7b	83 c1 04	 add	 ecx, 4
  00b7e	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  00b83	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _pData$229058[ebp], eax

; 239  : 
; 240  : 		pMsg.Data[i].UserNeedLevel = pData->UserNeedLevel;

  00b89	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00b8f	6b c0 48	 imul	 eax, 72			; 00000048H
  00b92	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00b98	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b9a	89 94 05 40 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+52], edx

; 241  : 		pMsg.Data[i].UserNeedReset = pData->UserNeedReset;

  00ba1	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00ba7	6b c0 48	 imul	 eax, 72			; 00000048H
  00baa	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00bb0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00bb3	89 94 05 44 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+56], edx

; 242  : 		pMsg.Data[i].UserNeedGrand = pData->UserNeedGrand;

  00bba	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00bc0	6b c0 48	 imul	 eax, 72			; 00000048H
  00bc3	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00bc9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00bcc	89 94 05 48 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+60], edx

; 243  : 		pMsg.Data[i].MasterRewardCredit = pData->MasterRewardCredit;

  00bd3	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00bd9	6b c0 48	 imul	 eax, 72			; 00000048H
  00bdc	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00be2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00be5	89 94 05 4c fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+64], edx

; 244  : 		pMsg.Data[i].MasterRewardWCoinC = pData->MasterRewardWCoinC;

  00bec	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00bf2	6b c0 48	 imul	 eax, 72			; 00000048H
  00bf5	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00bfb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00bfe	89 94 05 50 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+68], edx

; 245  : 		pMsg.Data[i].MasterRewardWCoinP = pData->MasterRewardWCoinP;

  00c05	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00c0b	6b c0 48	 imul	 eax, 72			; 00000048H
  00c0e	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00c14	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00c17	89 94 05 54 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+72], edx

; 246  : 		pMsg.Data[i].MasterRewardWcoinG = pData->MasterRewardWCoinG;

  00c1e	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00c24	6b c0 48	 imul	 eax, 72			; 00000048H
  00c27	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00c2d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00c30	89 94 05 58 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+76], edx

; 247  : 		pMsg.Data[i].MasterRewardBonus = pData->MasterRewardBonus;

  00c37	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00c3d	6b c0 48	 imul	 eax, 72			; 00000048H
  00c40	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00c46	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00c49	89 94 05 5c fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+80], edx

; 248  : 		pMsg.Data[i].MasterRewardPremiumType = pData->MasterRewardPremiumType;

  00c50	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00c56	6b c0 48	 imul	 eax, 72			; 00000048H
  00c59	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00c5f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00c62	89 94 05 60 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+84], edx

; 249  : 		pMsg.Data[i].MasterRewardPremiumTime = pData->MasterRewardPremiumTime;

  00c69	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _i$229048[ebp]
  00c6f	6b c0 48	 imul	 eax, 72			; 00000048H
  00c72	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _pData$229058[ebp]
  00c78	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00c7b	89 94 05 64 fd
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+eax+88], edx

; 250  : 	}

  00c82	e9 db fc ff ff	 jmp	 $LN5@DGAnsMaste
$LN4@DGAnsMaste:

; 251  : 
; 252  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00c87	68 e4 02 00 00	 push	 740			; 000002e4H
  00c8c	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00c92	50		 push	 eax
  00c93	8b 4d f4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00c96	51		 push	 ecx
  00c97	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00c9c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@DGAnsMaste:

; 253  : }

  00c9f	5f		 pop	 edi
  00ca0	5e		 pop	 esi
  00ca1	5b		 pop	 ebx
  00ca2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ca5	33 cd		 xor	 ecx, ebp
  00ca7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cac	8b e5		 mov	 esp, ebp
  00cae	5d		 pop	 ebp
  00caf	c2 04 00	 ret	 4
?DGAnsMasterInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_MASTER_INFO@@@Z ENDP ; CReferralSystem::DGAnsMasterInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PWMSG_HEAD2@@QAEXPAEEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 4
?set@PWMSG_HEAD2@@QAEXPAEEEH@Z PROC			; PWMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 149  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 150  : 		lpBuf[0] = 0xC2;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H

; 151  : 		lpBuf[1] = SET_NUMBERH(size);

  00012	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00015	c1 e8 08	 shr	 eax, 8
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  0001b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 152  : 		lpBuf[2] = SET_NUMBERL(size);

  0001e	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00021	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00029	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 153  : 		lpBuf[3] = head;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0002f	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00032	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 154  : 		lpBuf[4] = sub;

  00035	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00038	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0003b	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 155  : 	}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 10 00	 ret	 16			; 00000010H
?set@PWMSG_HEAD2@@QAEXPAEEEH@Z ENDP			; PWMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?GDReqMasterUpdate@CReferralSystem@@QAEXHPADH@Z	; CReferralSystem::GDReqMasterUpdate
PUBLIC	??_C@_0BO@FHOPBPJD@?$FLReferral?$FN?5Master?5Check?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BO@LOJGEHCH@?$FLReferral?$FN?5Master?5Stage?5Error?$AA@ ; `string'
PUBLIC	?CGMasterResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_MASTER_REWARD@@H@Z ; CReferralSystem::CGMasterResult
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
;	COMDAT ??_C@_0BO@FHOPBPJD@?$FLReferral?$FN?5Master?5Check?5Error?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\referralsystem.cpp
CONST	SEGMENT
??_C@_0BO@FHOPBPJD@?$FLReferral?$FN?5Master?5Check?5Error?$AA@ DB '[Refer'
	DB	'ral] Master Check Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LOJGEHCH@?$FLReferral?$FN?5Master?5Stage?5Error?$AA@
CONST	SEGMENT
??_C@_0BO@LOJGEHCH@?$FLReferral?$FN?5Master?5Stage?5Error?$AA@ DB '[Refer'
	DB	'ral] Master Stage Error', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv77 = -92						; size = 4
tv69 = -92						; size = 4
_pData$ = -24						; size = 4
_bResult$ = -17						; size = 1
_iStage$ = -16						; size = 4
_iNumber$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMasterResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_MASTER_REWARD@@H@Z PROC ; CReferralSystem::CGMasterResult
; _this$ = ecx

; 256  : {

  00cc0	55		 push	 ebp
  00cc1	8b ec		 mov	 ebp, esp
  00cc3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00cc6	53		 push	 ebx
  00cc7	56		 push	 esi
  00cc8	57		 push	 edi
  00cc9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 257  : 	if(!this->m_bActive)

  00ccc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ccf	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00cd2	85 c9		 test	 ecx, ecx
  00cd4	75 05		 jne	 SHORT $LN8@CGMasterRe

; 258  : 	{
; 259  : 		return;

  00cd6	e9 30 01 00 00	 jmp	 $LN9@CGMasterRe
$LN8@CGMasterRe:

; 260  : 	}
; 261  : 
; 262  : 	if(!OBJMAX_RANGE(aIndex))

  00cdb	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00cdf	7d 09		 jge	 SHORT $LN11@CGMasterRe
  00ce1	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00ce8	eb 0f		 jmp	 SHORT $LN12@CGMasterRe
$LN11@CGMasterRe:
  00cea	33 c0		 xor	 eax, eax
  00cec	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00cf3	0f 9e c0	 setle	 al
  00cf6	89 45 a4	 mov	 DWORD PTR tv69[ebp], eax
$LN12@CGMasterRe:
  00cf9	83 7d a4 00	 cmp	 DWORD PTR tv69[ebp], 0
  00cfd	75 05		 jne	 SHORT $LN7@CGMasterRe

; 263  : 	{
; 264  : 		return;

  00cff	e9 07 01 00 00	 jmp	 $LN9@CGMasterRe
$LN7@CGMasterRe:

; 265  : 	}
; 266  : 
; 267  : 	LPOBJ lpUser = &gObj[aIndex];

  00d04	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00d07	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00d0d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d13	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 268  : 
; 269  : 	int iNumber = lpMsg->ReferralNumber;

  00d16	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00d19	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00d1c	89 4d f4	 mov	 DWORD PTR _iNumber$[ebp], ecx

; 270  : 
; 271  : 	if(!CHECK_LIMIT(iNumber, REFERRAL_MAXDATA))

  00d1f	83 7d f4 00	 cmp	 DWORD PTR _iNumber$[ebp], 0
  00d23	7d 09		 jge	 SHORT $LN13@CGMasterRe
  00d25	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00d2c	eb 0c		 jmp	 SHORT $LN14@CGMasterRe
$LN13@CGMasterRe:
  00d2e	33 c0		 xor	 eax, eax
  00d30	83 7d f4 09	 cmp	 DWORD PTR _iNumber$[ebp], 9
  00d34	0f 9e c0	 setle	 al
  00d37	89 45 a4	 mov	 DWORD PTR tv77[ebp], eax
$LN14@CGMasterRe:
  00d3a	83 7d a4 00	 cmp	 DWORD PTR tv77[ebp], 0
  00d3e	75 05		 jne	 SHORT $LN6@CGMasterRe

; 272  : 	{
; 273  : 		return;

  00d40	e9 c6 00 00 00	 jmp	 $LN9@CGMasterRe
$LN6@CGMasterRe:

; 274  : 	}
; 275  : 
; 276  : 	int iStage = lpUser->RefferalMaster[iNumber];

  00d45	8b 45 f4	 mov	 eax, DWORD PTR _iNumber$[ebp]
  00d48	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00d4b	8b 94 81 34 2a
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+10804]
  00d52	89 55 f0	 mov	 DWORD PTR _iStage$[ebp], edx

; 277  : 
; 278  : 	bool bResult = true;

  00d55	c6 45 ef 01	 mov	 BYTE PTR _bResult$[ebp], 1

; 279  : 
; 280  : 	if(iStage >= this->m_Data.size())

  00d59	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d5c	83 c1 04	 add	 ecx, 4
  00d5f	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  00d64	39 45 f0	 cmp	 DWORD PTR _iStage$[ebp], eax
  00d67	72 16		 jb	 SHORT $LN5@CGMasterRe

; 281  : 	{
; 282  : 		MsgOutput(aIndex, "[Referral] Master Stage Error");

  00d69	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LOJGEHCH@?$FLReferral?$FN?5Master?5Stage?5Error?$AA@
  00d6e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00d71	50		 push	 eax
  00d72	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00d77	83 c4 08	 add	 esp, 8

; 283  : 		return;

  00d7a	e9 8c 00 00 00	 jmp	 $LN9@CGMasterRe
$LN5@CGMasterRe:

; 284  : 	}
; 285  : 
; 286  : 	REFERRAL_DATA * pData = &this->m_Data[iStage];

  00d7f	8b 45 f0	 mov	 eax, DWORD PTR _iStage$[ebp]
  00d82	50		 push	 eax
  00d83	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d86	83 c1 04	 add	 ecx, 4
  00d89	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  00d8e	89 45 e8	 mov	 DWORD PTR _pData$[ebp], eax

; 287  : 
; 288  : 	if(lpUser->RefferalUserLevel[iNumber] < pData->UserNeedLevel)

  00d91	8b 45 f4	 mov	 eax, DWORD PTR _iNumber$[ebp]
  00d94	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00d97	8b 55 e8	 mov	 edx, DWORD PTR _pData$[ebp]
  00d9a	8b 84 81 5c 2a
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+10844]
  00da1	3b 02		 cmp	 eax, DWORD PTR [edx]
  00da3	7d 04		 jge	 SHORT $LN4@CGMasterRe

; 289  : 	{
; 290  : 		bResult = false;

  00da5	c6 45 ef 00	 mov	 BYTE PTR _bResult$[ebp], 0
$LN4@CGMasterRe:

; 291  : 	}
; 292  : 
; 293  : 	if(lpUser->RefferalUserReset[iNumber] < pData->UserNeedReset)

  00da9	8b 45 f4	 mov	 eax, DWORD PTR _iNumber$[ebp]
  00dac	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00daf	8b 55 e8	 mov	 edx, DWORD PTR _pData$[ebp]
  00db2	8b 84 81 84 2a
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+10884]
  00db9	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00dbc	7d 04		 jge	 SHORT $LN3@CGMasterRe

; 294  : 	{
; 295  : 		bResult = false;

  00dbe	c6 45 ef 00	 mov	 BYTE PTR _bResult$[ebp], 0
$LN3@CGMasterRe:

; 296  : 	}
; 297  : 
; 298  : 	if(lpUser->RefferalUserGrand[iNumber] < pData->UserNeedGrand)

  00dc2	8b 45 f4	 mov	 eax, DWORD PTR _iNumber$[ebp]
  00dc5	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00dc8	8b 55 e8	 mov	 edx, DWORD PTR _pData$[ebp]
  00dcb	8b 84 81 ac 2a
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+10924]
  00dd2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00dd5	7d 04		 jge	 SHORT $LN2@CGMasterRe

; 299  : 	{
; 300  : 		bResult = false;

  00dd7	c6 45 ef 00	 mov	 BYTE PTR _bResult$[ebp], 0
$LN2@CGMasterRe:

; 301  : 	}
; 302  : 
; 303  : 	if(bResult == false)

  00ddb	0f b6 45 ef	 movzx	 eax, BYTE PTR _bResult$[ebp]
  00ddf	85 c0		 test	 eax, eax
  00de1	75 11		 jne	 SHORT $LN1@CGMasterRe

; 304  : 	{
; 305  : 		MsgOutput(aIndex, "[Referral] Master Check Error");

  00de3	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHOPBPJD@?$FLReferral?$FN?5Master?5Check?5Error?$AA@
  00de8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00deb	50		 push	 eax
  00dec	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00df1	83 c4 08	 add	 esp, 8
$LN1@CGMasterRe:

; 306  : 	}
; 307  : 
; 308  : 	this->GDReqMasterUpdate(aIndex, lpMsg->ReferalName, iNumber);

  00df4	8b 45 f4	 mov	 eax, DWORD PTR _iNumber$[ebp]
  00df7	50		 push	 eax
  00df8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00dfb	83 c1 08	 add	 ecx, 8
  00dfe	51		 push	 ecx
  00dff	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00e02	52		 push	 edx
  00e03	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e06	e8 00 00 00 00	 call	 ?GDReqMasterUpdate@CReferralSystem@@QAEXHPADH@Z ; CReferralSystem::GDReqMasterUpdate
$LN9@CGMasterRe:

; 309  : }

  00e0b	5f		 pop	 edi
  00e0c	5e		 pop	 esi
  00e0d	5b		 pop	 ebx
  00e0e	8b e5		 mov	 esp, ebp
  00e10	5d		 pop	 ebp
  00e11	c2 08 00	 ret	 8
?CGMasterResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_MASTER_REWARD@@H@Z ENDP ; CReferralSystem::CGMasterResult
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -140						; size = 4
_szAccount$ = -72					; size = 11
_szName$ = -60						; size = 11
_pMsg$ = -48						; size = 36
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Name$ = 12						; size = 4
_Num$ = 16						; size = 4
?GDReqMasterUpdate@CReferralSystem@@QAEXHPADH@Z PROC	; CReferralSystem::GDReqMasterUpdate
; _this$ = ecx

; 312  : {

  00e20	55		 push	 ebp
  00e21	8b ec		 mov	 ebp, esp
  00e23	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00e29	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00e2e	33 c5		 xor	 eax, ebp
  00e30	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00e33	53		 push	 ebx
  00e34	56		 push	 esi
  00e35	57		 push	 edi
  00e36	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 	if(!this->m_bActive)

  00e39	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00e3c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00e3f	85 c9		 test	 ecx, ecx
  00e41	75 05		 jne	 SHORT $LN2@GDReqMaste@2

; 314  : 	{
; 315  : 		return;

  00e43	e9 eb 00 00 00	 jmp	 $LN3@GDReqMaste@2
$LN2@GDReqMaste@2:

; 316  : 	}
; 317  : 
; 318  : 	if(!OBJMAX_RANGE(aIndex))

  00e48	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00e4c	7d 0c		 jge	 SHORT $LN5@GDReqMaste@2
  00e4e	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  00e58	eb 12		 jmp	 SHORT $LN6@GDReqMaste@2
$LN5@GDReqMaste@2:
  00e5a	33 c0		 xor	 eax, eax
  00e5c	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00e63	0f 9e c0	 setle	 al
  00e66	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN6@GDReqMaste@2:
  00e6c	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv69[ebp], 0
  00e73	75 05		 jne	 SHORT $LN1@GDReqMaste@2

; 319  : 	{
; 320  : 		return;

  00e75	e9 b9 00 00 00	 jmp	 $LN3@GDReqMaste@2
$LN1@GDReqMaste@2:

; 321  : 	}
; 322  : 
; 323  : 	LPOBJ lpUser = &gObj[aIndex];

  00e7a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00e7d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00e83	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e89	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 324  : 
; 325  : 	PMSG_GD_REFERRAL_MASTER_UPDATE pMsg;
; 326  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEB, 0x15, sizeof(pMsg));

  00e8c	6a 24		 push	 36			; 00000024H
  00e8e	6a 15		 push	 21			; 00000015H
  00e90	68 eb 00 00 00	 push	 235			; 000000ebH
  00e95	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00e98	50		 push	 eax
  00e99	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00e9c	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 327  : 	pMsg.aIndex = aIndex;

  00ea1	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ea4	89 45 d4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 328  : 	pMsg.Number = Num;

  00ea7	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00eaa	89 45 d8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 329  : 
; 330  : 	char szName[11] = { 0 };

  00ead	c6 45 c4 00	 mov	 BYTE PTR _szName$[ebp], 0
  00eb1	33 c0		 xor	 eax, eax
  00eb3	89 45 c5	 mov	 DWORD PTR _szName$[ebp+1], eax
  00eb6	89 45 c9	 mov	 DWORD PTR _szName$[ebp+5], eax
  00eb9	66 89 45 cd	 mov	 WORD PTR _szName$[ebp+9], ax

; 331  : 	memcpy(szName, lpUser->Name, sizeof(szName));

  00ebd	6a 0b		 push	 11			; 0000000bH
  00ebf	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ec2	83 c0 77	 add	 eax, 119		; 00000077H
  00ec5	50		 push	 eax
  00ec6	8d 4d c4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00ec9	51		 push	 ecx
  00eca	e8 00 00 00 00	 call	 _memcpy
  00ecf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 332  : 	szName[10] = 0;

  00ed2	c6 45 ce 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 333  : 	memcpy(pMsg.Name, szName, sizeof(szName)-1);

  00ed6	6a 0a		 push	 10			; 0000000aH
  00ed8	8d 45 c4	 lea	 eax, DWORD PTR _szName$[ebp]
  00edb	50		 push	 eax
  00edc	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp+12]
  00edf	51		 push	 ecx
  00ee0	e8 00 00 00 00	 call	 _memcpy
  00ee5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 334  : 
; 335  : 	char szAccount[11] = { 0 };

  00ee8	c6 45 b8 00	 mov	 BYTE PTR _szAccount$[ebp], 0
  00eec	33 c0		 xor	 eax, eax
  00eee	89 45 b9	 mov	 DWORD PTR _szAccount$[ebp+1], eax
  00ef1	89 45 bd	 mov	 DWORD PTR _szAccount$[ebp+5], eax
  00ef4	66 89 45 c1	 mov	 WORD PTR _szAccount$[ebp+9], ax

; 336  : 	memcpy(szAccount, Name, sizeof(szAccount));

  00ef8	6a 0b		 push	 11			; 0000000bH
  00efa	8b 45 0c	 mov	 eax, DWORD PTR _Name$[ebp]
  00efd	50		 push	 eax
  00efe	8d 4d b8	 lea	 ecx, DWORD PTR _szAccount$[ebp]
  00f01	51		 push	 ecx
  00f02	e8 00 00 00 00	 call	 _memcpy
  00f07	83 c4 0c	 add	 esp, 12			; 0000000cH

; 337  : 	szAccount[10] = 0;

  00f0a	c6 45 c2 00	 mov	 BYTE PTR _szAccount$[ebp+10], 0

; 338  : 	memcpy(pMsg.ReferalName, szAccount, sizeof(szAccount)-1);

  00f0e	6a 0a		 push	 10			; 0000000aH
  00f10	8d 45 b8	 lea	 eax, DWORD PTR _szAccount$[ebp]
  00f13	50		 push	 eax
  00f14	8d 4d e7	 lea	 ecx, DWORD PTR _pMsg$[ebp+23]
  00f17	51		 push	 ecx
  00f18	e8 00 00 00 00	 call	 _memcpy
  00f1d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 
; 340  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00f20	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00f24	50		 push	 eax
  00f25	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00f28	51		 push	 ecx
  00f29	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00f2e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqMaste@2:

; 341  : }

  00f33	5f		 pop	 edi
  00f34	5e		 pop	 esi
  00f35	5b		 pop	 ebx
  00f36	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f39	33 cd		 xor	 ecx, ebp
  00f3b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f40	8b e5		 mov	 esp, ebp
  00f42	5d		 pop	 ebp
  00f43	c2 0c 00	 ret	 12			; 0000000cH
?GDReqMasterUpdate@CReferralSystem@@QAEXHPADH@Z ENDP	; CReferralSystem::GDReqMasterUpdate
_TEXT	ENDS
PUBLIC	??_C@_0DA@IOKCCFHI@?$EA?$FLReferral?$FN?5Master?5Premium?5Type?3@ ; `string'
PUBLIC	??_C@_0BO@KNFFDLCI@?$EA?$FLReferral?$FN?5Master?5WCoinG?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BO@LDIGAJAL@?$EA?$FLReferral?$FN?5Master?5WCoinP?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BO@DGMEHJDO@?$EA?$FLReferral?$FN?5Master?5WCoinC?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BO@HHOMLILM@?$EA?$FLReferral?$FN?5Master?5Crecit?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BI@IHMJLPIA@?$FLReferral?5Update?5Error?$FN?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsMasterUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_MASTER_UPDATE@@@Z ; CReferralSystem::DGAnsMasterUpdate
EXTRN	?ExUserDataSend@@YAXH@Z:PROC			; ExUserDataSend
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?MessageChat@@YAXHPADZZ:PROC			; MessageChat
;	COMDAT ??_C@_0DA@IOKCCFHI@?$EA?$FLReferral?$FN?5Master?5Premium?5Type?3@
CONST	SEGMENT
??_C@_0DA@IOKCCFHI@?$EA?$FLReferral?$FN?5Master?5Premium?5Type?3@ DB '@[R'
	DB	'eferral] Master Premium Type: %d Time: +%d h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KNFFDLCI@?$EA?$FLReferral?$FN?5Master?5WCoinG?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KNFFDLCI@?$EA?$FLReferral?$FN?5Master?5WCoinG?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] Master WCoinG +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LDIGAJAL@?$EA?$FLReferral?$FN?5Master?5WCoinP?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@LDIGAJAL@?$EA?$FLReferral?$FN?5Master?5WCoinP?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] Master WCoinP +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DGMEHJDO@?$EA?$FLReferral?$FN?5Master?5WCoinC?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@DGMEHJDO@?$EA?$FLReferral?$FN?5Master?5WCoinC?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] Master WCoinC +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HHOMLILM@?$EA?$FLReferral?$FN?5Master?5Crecit?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@HHOMLILM@?$EA?$FLReferral?$FN?5Master?5Crecit?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] Master Crecit +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHMJLPIA@?$FLReferral?5Update?5Error?$FN?$AA@
CONST	SEGMENT
??_C@_0BI@IHMJLPIA@?$FLReferral?5Update?5Error?$FN?$AA@ DB '[Referral Upd'
	DB	'ate Error]', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv81 = -144						; size = 4
tv68 = -144						; size = 4
_pMsg$ = -76						; size = 48
_pData$ = -28						; size = 4
_iStage$ = -24						; size = 4
_iNumber$ = -20						; size = 4
_lpUser$ = -16						; size = 4
_aIndex$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsMasterUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_MASTER_UPDATE@@@Z PROC ; CReferralSystem::DGAnsMasterUpdate
; _this$ = ecx

; 344  : {

  00f50	55		 push	 ebp
  00f51	8b ec		 mov	 ebp, esp
  00f53	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00f59	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00f5e	33 c5		 xor	 eax, ebp
  00f60	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00f63	53		 push	 ebx
  00f64	56		 push	 esi
  00f65	57		 push	 edi
  00f66	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 345  : 	int aIndex = lpMsg->aIndex;

  00f69	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00f6c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f6f	89 4d f4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 346  : 
; 347  : 	if(!OBJMAX_RANGE(aIndex))

  00f72	83 7d f4 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00f76	7d 0c		 jge	 SHORT $LN11@DGAnsMaste@2
  00f78	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00f82	eb 12		 jmp	 SHORT $LN12@DGAnsMaste@2
$LN11@DGAnsMaste@2:
  00f84	33 c0		 xor	 eax, eax
  00f86	81 7d f4 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00f8d	0f 9e c0	 setle	 al
  00f90	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN12@DGAnsMaste@2:
  00f96	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  00f9d	75 05		 jne	 SHORT $LN8@DGAnsMaste@2

; 348  : 	{
; 349  : 		return;

  00f9f	e9 cd 02 00 00	 jmp	 $LN9@DGAnsMaste@2
$LN8@DGAnsMaste@2:

; 350  : 	}
; 351  : 
; 352  : 	if(!lpMsg->Result)

  00fa4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00fa7	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00fab	85 c9		 test	 ecx, ecx
  00fad	75 16		 jne	 SHORT $LN7@DGAnsMaste@2

; 353  : 	{
; 354  : 		MsgOutput(aIndex, "[Referral Update Error]");

  00faf	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IHMJLPIA@?$FLReferral?5Update?5Error?$FN?$AA@
  00fb4	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00fb7	50		 push	 eax
  00fb8	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00fbd	83 c4 08	 add	 esp, 8

; 355  : 		return;

  00fc0	e9 ac 02 00 00	 jmp	 $LN9@DGAnsMaste@2
$LN7@DGAnsMaste@2:

; 356  : 	}
; 357  : 
; 358  : 	LPOBJ lpUser = &gObj[aIndex];

  00fc5	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00fc8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00fce	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fd4	89 45 f0	 mov	 DWORD PTR _lpUser$[ebp], eax

; 359  : 
; 360  : 	int iNumber = lpMsg->Number;

  00fd7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00fda	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00fdd	89 4d ec	 mov	 DWORD PTR _iNumber$[ebp], ecx

; 361  : 
; 362  : 	if(!CHECK_LIMIT(iNumber, REFERRAL_MAXDATA))

  00fe0	83 7d ec 00	 cmp	 DWORD PTR _iNumber$[ebp], 0
  00fe4	7d 0c		 jge	 SHORT $LN13@DGAnsMaste@2
  00fe6	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv81[ebp], 0
  00ff0	eb 0f		 jmp	 SHORT $LN14@DGAnsMaste@2
$LN13@DGAnsMaste@2:
  00ff2	33 c0		 xor	 eax, eax
  00ff4	83 7d ec 09	 cmp	 DWORD PTR _iNumber$[ebp], 9
  00ff8	0f 9e c0	 setle	 al
  00ffb	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
$LN14@DGAnsMaste@2:
  01001	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv81[ebp], 0
  01008	75 05		 jne	 SHORT $LN6@DGAnsMaste@2

; 363  : 	{
; 364  : 		return;

  0100a	e9 62 02 00 00	 jmp	 $LN9@DGAnsMaste@2
$LN6@DGAnsMaste@2:

; 365  : 	}
; 366  : 
; 367  : 	int iStage = lpUser->RefferalMaster[iNumber];

  0100f	8b 45 ec	 mov	 eax, DWORD PTR _iNumber$[ebp]
  01012	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  01015	8b 94 81 34 2a
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+10804]
  0101c	89 55 e8	 mov	 DWORD PTR _iStage$[ebp], edx

; 368  : 
; 369  : 	REFERRAL_DATA * pData = &this->m_Data[iStage];

  0101f	8b 45 e8	 mov	 eax, DWORD PTR _iStage$[ebp]
  01022	50		 push	 eax
  01023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01026	83 c1 04	 add	 ecx, 4
  01029	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  0102e	89 45 e4	 mov	 DWORD PTR _pData$[ebp], eax

; 370  : 
; 371  : 	if(pData->MasterRewardCredit > 0)

  01031	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01034	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01038	7e 30		 jle	 SHORT $LN5@DGAnsMaste@2

; 372  : 	{
; 373  : 		lpUser->ExCred += pData->MasterRewardCredit;

  0103a	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0103d	db 40 0c	 fild	 DWORD PTR [eax+12]
  01040	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  01043	d8 81 a8 22 00
	00		 fadd	 DWORD PTR [ecx+8872]
  01049	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0104c	d9 9a a8 22 00
	00		 fstp	 DWORD PTR [edx+8872]

; 374  : 		MessageChat(aIndex, "@[Referral] Master Crecit +%d", pData->MasterRewardCredit);

  01052	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01055	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01058	51		 push	 ecx
  01059	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HHOMLILM@?$EA?$FLReferral?$FN?5Master?5Crecit?5?$CL?$CFd?$AA@
  0105e	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01061	52		 push	 edx
  01062	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  01067	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@DGAnsMaste@2:

; 375  : 	}
; 376  : 
; 377  : 	if(pData->MasterRewardWCoinC > 0)

  0106a	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0106d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01071	7e 3e		 jle	 SHORT $LN4@DGAnsMaste@2

; 378  : 	{
; 379  : 		lpUser->GameShop.WCoinC += pData->MasterRewardWCoinC;

  01073	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01076	db 40 10	 fild	 DWORD PTR [eax+16]
  01079	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0107c	dc 81 00 23 00
	00		 fadd	 QWORD PTR [ecx+8960]
  01082	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  01085	dd 9a 00 23 00
	00		 fstp	 QWORD PTR [edx+8960]

; 380  : 		gGameShop.GDSaveUserInfo(aIndex);

  0108b	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0108e	50		 push	 eax
  0108f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  01094	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 381  : 		MessageChat(aIndex, "@[Referral] Master WCoinC +%d", pData->MasterRewardWCoinC);

  01099	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0109c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0109f	51		 push	 ecx
  010a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DGMEHJDO@?$EA?$FLReferral?$FN?5Master?5WCoinC?5?$CL?$CFd?$AA@
  010a5	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  010a8	52		 push	 edx
  010a9	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  010ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DGAnsMaste@2:

; 382  : 	}
; 383  : 
; 384  : 	if(pData->MasterRewardWCoinP > 0)

  010b1	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  010b4	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  010b8	7e 3e		 jle	 SHORT $LN3@DGAnsMaste@2

; 385  : 	{
; 386  : 		lpUser->GameShop.WCoinP += pData->MasterRewardWCoinP;

  010ba	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  010bd	db 40 14	 fild	 DWORD PTR [eax+20]
  010c0	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  010c3	dc 81 f8 22 00
	00		 fadd	 QWORD PTR [ecx+8952]
  010c9	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  010cc	dd 9a f8 22 00
	00		 fstp	 QWORD PTR [edx+8952]

; 387  : 		gGameShop.GDSaveUserInfo(aIndex);

  010d2	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010d5	50		 push	 eax
  010d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  010db	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 388  : 		MessageChat(aIndex, "@[Referral] Master WCoinP +%d", pData->MasterRewardWCoinP);

  010e0	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  010e3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  010e6	51		 push	 ecx
  010e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LDIGAJAL@?$EA?$FLReferral?$FN?5Master?5WCoinP?5?$CL?$CFd?$AA@
  010ec	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  010ef	52		 push	 edx
  010f0	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  010f5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@DGAnsMaste@2:

; 389  : 	}
; 390  : 
; 391  : 	if(pData->MasterRewardWCoinG > 0)

  010f8	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  010fb	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  010ff	7e 3e		 jle	 SHORT $LN2@DGAnsMaste@2

; 392  : 	{
; 393  : 		lpUser->GameShop.GoblinPoint += pData->MasterRewardWCoinG;

  01101	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01104	db 40 18	 fild	 DWORD PTR [eax+24]
  01107	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0110a	dc 81 08 23 00
	00		 fadd	 QWORD PTR [ecx+8968]
  01110	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  01113	dd 9a 08 23 00
	00		 fstp	 QWORD PTR [edx+8968]

; 394  : 		gGameShop.GDSaveUserInfo(aIndex);

  01119	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0111c	50		 push	 eax
  0111d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  01122	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 395  : 		MessageChat(aIndex, "@[Referral] Master WCoinG +%d", pData->MasterRewardWCoinG);

  01127	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0112a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0112d	51		 push	 ecx
  0112e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KNFFDLCI@?$EA?$FLReferral?$FN?5Master?5WCoinG?5?$CL?$CFd?$AA@
  01133	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01136	52		 push	 edx
  01137	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  0113c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@DGAnsMaste@2:

; 396  : 	}
; 397  : 
; 398  : 	if(pData->MasterRewardPremiumType > 0 && pData->MasterRewardPremiumTime > 0)

  0113f	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01142	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  01146	7e 55		 jle	 SHORT $LN1@DGAnsMaste@2
  01148	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0114b	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0114f	7e 4c		 jle	 SHORT $LN1@DGAnsMaste@2

; 399  : 	{
; 400  : 		lpUser->PremiumTimeType = pData->MasterRewardPremiumType;

  01151	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01154	8b 4d e4	 mov	 ecx, DWORD PTR _pData$[ebp]
  01157	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0115a	89 90 bc 22 00
	00		 mov	 DWORD PTR [eax+8892], edx

; 401  : 		lpUser->PremiumTime += pData->MasterRewardPremiumTime * 3600;

  01160	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01163	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01166	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  0116c	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0116f	03 8a b8 22 00
	00		 add	 ecx, DWORD PTR [edx+8888]
  01175	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01178	89 88 b8 22 00
	00		 mov	 DWORD PTR [eax+8888], ecx

; 402  : 		MessageChat(aIndex, "@[Referral] Master Premium Type: %d Time: +%d h", pData->MasterRewardPremiumType, pData->MasterRewardPremiumTime);

  0117e	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01181	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01184	51		 push	 ecx
  01185	8b 55 e4	 mov	 edx, DWORD PTR _pData$[ebp]
  01188	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0118b	50		 push	 eax
  0118c	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IOKCCFHI@?$EA?$FLReferral?$FN?5Master?5Premium?5Type?3@
  01191	8b 4d f4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01194	51		 push	 ecx
  01195	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  0119a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@DGAnsMaste@2:

; 403  : 	}
; 404  : 
; 405  : 	ExUserDataSend(aIndex);

  0119d	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  011a0	50		 push	 eax
  011a1	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  011a6	83 c4 04	 add	 esp, 4

; 406  : 
; 407  : 	lpUser->RefferalMaster[iNumber]++;

  011a9	8b 45 ec	 mov	 eax, DWORD PTR _iNumber$[ebp]
  011ac	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  011af	8b 94 81 34 2a
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+10804]
  011b6	83 c2 01	 add	 edx, 1
  011b9	8b 45 ec	 mov	 eax, DWORD PTR _iNumber$[ebp]
  011bc	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  011bf	89 94 81 34 2a
	00 00		 mov	 DWORD PTR [ecx+eax*4+10804], edx

; 408  : 	iStage = lpUser->RefferalMaster[iNumber];

  011c6	8b 45 ec	 mov	 eax, DWORD PTR _iNumber$[ebp]
  011c9	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  011cc	8b 94 81 34 2a
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+10804]
  011d3	89 55 e8	 mov	 DWORD PTR _iStage$[ebp], edx

; 409  : 
; 410  : 	pData = &this->m_Data[iStage];

  011d6	8b 45 e8	 mov	 eax, DWORD PTR _iStage$[ebp]
  011d9	50		 push	 eax
  011da	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  011dd	83 c1 04	 add	 ecx, 4
  011e0	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  011e5	89 45 e4	 mov	 DWORD PTR _pData$[ebp], eax

; 411  : 
; 412  : 	PMSG_CGANS_REFERRAL_MASTER_REWARD pMsg;
; 413  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xAE, sizeof(pMsg));

  011e8	6a 30		 push	 48			; 00000030H
  011ea	68 ae 00 00 00	 push	 174			; 000000aeH
  011ef	68 fb 00 00 00	 push	 251			; 000000fbH
  011f4	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  011f7	50		 push	 eax
  011f8	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  011fb	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 414  : 	pMsg.ReferralNumber = iNumber;

  01200	8b 45 ec	 mov	 eax, DWORD PTR _iNumber$[ebp]
  01203	89 45 b8	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 415  : 	pMsg.UserNeedLevel = pData->UserNeedLevel;

  01206	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01209	8b 08		 mov	 ecx, DWORD PTR [eax]
  0120b	89 4d bc	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 416  : 	pMsg.UserNeedReset = pData->UserNeedReset;

  0120e	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01211	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01214	89 4d c0	 mov	 DWORD PTR _pMsg$[ebp+12], ecx

; 417  : 	pMsg.UserNeedGrand = pData->UserNeedGrand;

  01217	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0121a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0121d	89 4d c4	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 418  : 	pMsg.MasterRewardCredit = pData->MasterRewardCredit;

  01220	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01223	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01226	89 4d c8	 mov	 DWORD PTR _pMsg$[ebp+20], ecx

; 419  : 	pMsg.MasterRewardWCoinC = pData->MasterRewardWCoinC;

  01229	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0122c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0122f	89 4d cc	 mov	 DWORD PTR _pMsg$[ebp+24], ecx

; 420  : 	pMsg.MasterRewardWCoinP = pData->MasterRewardWCoinP;

  01232	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01235	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01238	89 4d d0	 mov	 DWORD PTR _pMsg$[ebp+28], ecx

; 421  : 	pMsg.MasterRewardWcoinG = pData->MasterRewardWCoinG;

  0123b	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  0123e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01241	89 4d d4	 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 422  : 	pMsg.MasterRewardBonus = pData->MasterRewardBonus;

  01244	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01247	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0124a	89 4d d8	 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 423  : 	pMsg.MasterRewardPremiumType = pData->MasterRewardPremiumType;

  0124d	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01250	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01253	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+40], ecx

; 424  : 	pMsg.MasterRewardPremiumTime = pData->MasterRewardPremiumTime;

  01256	8b 45 e4	 mov	 eax, DWORD PTR _pData$[ebp]
  01259	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0125c	89 4d e0	 mov	 DWORD PTR _pMsg$[ebp+44], ecx

; 425  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0125f	6a 30		 push	 48			; 00000030H
  01261	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01264	50		 push	 eax
  01265	8b 4d f4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01268	51		 push	 ecx
  01269	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0126e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@DGAnsMaste@2:

; 426  : }

  01271	5f		 pop	 edi
  01272	5e		 pop	 esi
  01273	5b		 pop	 ebx
  01274	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01277	33 cd		 xor	 ecx, ebp
  01279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0127e	8b e5		 mov	 esp, ebp
  01280	5d		 pop	 ebp
  01281	c2 04 00	 ret	 4
?DGAnsMasterUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_MASTER_UPDATE@@@Z ENDP ; CReferralSystem::DGAnsMasterUpdate
_TEXT	ENDS
PUBLIC	?GDReqUserInfo@CReferralSystem@@QAEXH@Z		; CReferralSystem::GDReqUserInfo
PUBLIC	?CGReqUserInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_USER_INFO@@H@Z ; CReferralSystem::CGReqUserInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqUserInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_USER_INFO@@H@Z PROC ; CReferralSystem::CGReqUserInfo
; _this$ = ecx

; 429  : {

  01290	55		 push	 ebp
  01291	8b ec		 mov	 ebp, esp
  01293	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01296	53		 push	 ebx
  01297	56		 push	 esi
  01298	57		 push	 edi
  01299	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 430  : 	if(!this->m_bActive)

  0129c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0129f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  012a2	85 c9		 test	 ecx, ecx
  012a4	75 02		 jne	 SHORT $LN3@CGReqUserI

; 431  : 	{
; 432  : 		return;

  012a6	eb 4f		 jmp	 SHORT $LN4@CGReqUserI
$LN3@CGReqUserI:

; 433  : 	}
; 434  : 
; 435  : 	if(!OBJMAX_RANGE(aIndex))

  012a8	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  012ac	7d 09		 jge	 SHORT $LN6@CGReqUserI
  012ae	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  012b5	eb 0f		 jmp	 SHORT $LN7@CGReqUserI
$LN6@CGReqUserI:
  012b7	33 c0		 xor	 eax, eax
  012b9	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  012c0	0f 9e c0	 setle	 al
  012c3	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN7@CGReqUserI:
  012c6	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  012ca	75 02		 jne	 SHORT $LN2@CGReqUserI

; 436  : 	{
; 437  : 		return;

  012cc	eb 29		 jmp	 SHORT $LN4@CGReqUserI
$LN2@CGReqUserI:

; 438  : 	}
; 439  : 
; 440  : 	LPOBJ lpUser = &gObj[aIndex];

  012ce	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  012d1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  012d7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012dd	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 441  : 
; 442  : 	if(lpUser->Connected < PLAYER_PLAYING)

  012e0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  012e3	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  012e7	7d 02		 jge	 SHORT $LN1@CGReqUserI

; 443  : 	{
; 444  : 		return;

  012e9	eb 0c		 jmp	 SHORT $LN4@CGReqUserI
$LN1@CGReqUserI:

; 445  : 	}
; 446  : 
; 447  : 	this->GDReqUserInfo(aIndex);

  012eb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  012ee	50		 push	 eax
  012ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012f2	e8 00 00 00 00	 call	 ?GDReqUserInfo@CReferralSystem@@QAEXH@Z ; CReferralSystem::GDReqUserInfo
$LN4@CGReqUserI:

; 448  : }

  012f7	5f		 pop	 edi
  012f8	5e		 pop	 esi
  012f9	5b		 pop	 ebx
  012fa	8b e5		 mov	 esp, ebp
  012fc	5d		 pop	 ebp
  012fd	c2 08 00	 ret	 8
?CGReqUserInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_USER_INFO@@H@Z ENDP ; CReferralSystem::CGReqUserInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -112						; size = 4
_szName$ = -44						; size = 11
_pMsg$ = -32						; size = 20
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqUserInfo@CReferralSystem@@QAEXH@Z PROC		; CReferralSystem::GDReqUserInfo
; _this$ = ecx

; 451  : {

  01300	55		 push	 ebp
  01301	8b ec		 mov	 ebp, esp
  01303	83 ec 70	 sub	 esp, 112		; 00000070H
  01306	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0130b	33 c5		 xor	 eax, ebp
  0130d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01310	53		 push	 ebx
  01311	56		 push	 esi
  01312	57		 push	 edi
  01313	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 452  : 	if(!this->m_bActive)

  01316	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01319	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0131c	85 c9		 test	 ecx, ecx
  0131e	75 05		 jne	 SHORT $LN2@GDReqUserI

; 453  : 	{
; 454  : 		return;

  01320	e9 a1 00 00 00	 jmp	 $LN3@GDReqUserI
$LN2@GDReqUserI:

; 455  : 	}
; 456  : 
; 457  : 	if(!OBJMAX_RANGE(aIndex))

  01325	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01329	7d 09		 jge	 SHORT $LN5@GDReqUserI
  0132b	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  01332	eb 0f		 jmp	 SHORT $LN6@GDReqUserI
$LN5@GDReqUserI:
  01334	33 c0		 xor	 eax, eax
  01336	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0133d	0f 9e c0	 setle	 al
  01340	89 45 90	 mov	 DWORD PTR tv69[ebp], eax
$LN6@GDReqUserI:
  01343	83 7d 90 00	 cmp	 DWORD PTR tv69[ebp], 0
  01347	75 02		 jne	 SHORT $LN1@GDReqUserI

; 458  : 	{
; 459  : 		return;

  01349	eb 7b		 jmp	 SHORT $LN3@GDReqUserI
$LN1@GDReqUserI:

; 460  : 	}
; 461  : 
; 462  : 	LPOBJ lpUser = &gObj[aIndex];

  0134b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0134e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01354	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0135a	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 463  : 
; 464  : 	PMSG_GDREQ_REFERRAL_USER_INFO pMsg;
; 465  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEB, 0x16, sizeof(pMsg));

  0135d	6a 14		 push	 20			; 00000014H
  0135f	6a 16		 push	 22			; 00000016H
  01361	68 eb 00 00 00	 push	 235			; 000000ebH
  01366	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01369	50		 push	 eax
  0136a	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0136d	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 466  : 	pMsg.aIndex = aIndex;

  01372	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01375	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 467  : 
; 468  : 	char szName[11] = { 0 };

  01378	c6 45 d4 00	 mov	 BYTE PTR _szName$[ebp], 0
  0137c	33 c0		 xor	 eax, eax
  0137e	89 45 d5	 mov	 DWORD PTR _szName$[ebp+1], eax
  01381	89 45 d9	 mov	 DWORD PTR _szName$[ebp+5], eax
  01384	66 89 45 dd	 mov	 WORD PTR _szName$[ebp+9], ax

; 469  : 	memcpy(szName, lpUser->AccountID, sizeof(szName));

  01388	6a 0b		 push	 11			; 0000000bH
  0138a	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0138d	83 c0 6c	 add	 eax, 108		; 0000006cH
  01390	50		 push	 eax
  01391	8d 4d d4	 lea	 ecx, DWORD PTR _szName$[ebp]
  01394	51		 push	 ecx
  01395	e8 00 00 00 00	 call	 _memcpy
  0139a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 470  : 	szName[10] = 0;

  0139d	c6 45 de 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 471  : 
; 472  : 	memcpy(pMsg.Name, szName, sizeof(szName)-1);

  013a1	6a 0a		 push	 10			; 0000000aH
  013a3	8d 45 d4	 lea	 eax, DWORD PTR _szName$[ebp]
  013a6	50		 push	 eax
  013a7	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp+8]
  013aa	51		 push	 ecx
  013ab	e8 00 00 00 00	 call	 _memcpy
  013b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 473  : 
; 474  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  013b3	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  013b7	50		 push	 eax
  013b8	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  013bb	51		 push	 ecx
  013bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  013c1	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqUserI:

; 475  : }

  013c6	5f		 pop	 edi
  013c7	5e		 pop	 esi
  013c8	5b		 pop	 ebx
  013c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013cc	33 cd		 xor	 ecx, ebp
  013ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013d3	8b e5		 mov	 esp, ebp
  013d5	5d		 pop	 ebp
  013d6	c2 04 00	 ret	 4
?GDReqUserInfo@CReferralSystem@@QAEXH@Z ENDP		; CReferralSystem::GDReqUserInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsUserInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_USER_INFO@@@Z ; CReferralSystem::DGAnsUserInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv71 = -144						; size = 4
_pData$229152 = -76					; size = 4
_pMsg$ = -72						; size = 52
_iStage$ = -20						; size = 4
_lpUser$ = -16						; size = 4
_aIndex$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsUserInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_USER_INFO@@@Z PROC ; CReferralSystem::DGAnsUserInfo
; _this$ = ecx

; 478  : {

  013e0	55		 push	 ebp
  013e1	8b ec		 mov	 ebp, esp
  013e3	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  013e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  013ee	33 c5		 xor	 eax, ebp
  013f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  013f3	53		 push	 ebx
  013f4	56		 push	 esi
  013f5	57		 push	 edi
  013f6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 	if(!lpMsg->Result)

  013f9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  013fc	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  01400	85 c9		 test	 ecx, ecx
  01402	75 05		 jne	 SHORT $LN3@DGAnsUserI

; 480  : 	{
; 481  : 		return;

  01404	e9 3b 01 00 00	 jmp	 $LN4@DGAnsUserI
$LN3@DGAnsUserI:

; 482  : 	}
; 483  : 
; 484  : 	int aIndex = lpMsg->aIndex;

  01409	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0140c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0140f	89 4d f4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 485  : 
; 486  : 	if(!OBJMAX_RANGE(aIndex))

  01412	83 7d f4 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01416	7d 0c		 jge	 SHORT $LN6@DGAnsUserI
  01418	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
  01422	eb 12		 jmp	 SHORT $LN7@DGAnsUserI
$LN6@DGAnsUserI:
  01424	33 c0		 xor	 eax, eax
  01426	81 7d f4 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0142d	0f 9e c0	 setle	 al
  01430	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
$LN7@DGAnsUserI:
  01436	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv71[ebp], 0
  0143d	75 05		 jne	 SHORT $LN2@DGAnsUserI

; 487  : 	{
; 488  : 		return;

  0143f	e9 00 01 00 00	 jmp	 $LN4@DGAnsUserI
$LN2@DGAnsUserI:

; 489  : 	}
; 490  : 
; 491  : 	LPOBJ lpUser = &gObj[aIndex];

  01444	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01447	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0144d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01453	89 45 f0	 mov	 DWORD PTR _lpUser$[ebp], eax

; 492  : 
; 493  : 	lpUser->RefferalUser = lpMsg->RefferalUser;

  01456	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01459	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0145c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0145f	89 90 30 2a 00
	00		 mov	 DWORD PTR [eax+10800], edx

; 494  : 
; 495  : 	int iStage = lpUser->RefferalUser;

  01465	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01468	8b 88 30 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10800]
  0146e	89 4d ec	 mov	 DWORD PTR _iStage$[ebp], ecx

; 496  : 
; 497  : 	PMSG_ANS_REFERRAL_USER_INFO pMsg;
; 498  : 	memset(&pMsg, 0, sizeof(pMsg));

  01471	6a 34		 push	 52			; 00000034H
  01473	6a 00		 push	 0
  01475	8d 45 b8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01478	50		 push	 eax
  01479	e8 00 00 00 00	 call	 _memset
  0147e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xAF, sizeof(pMsg));

  01481	6a 34		 push	 52			; 00000034H
  01483	68 af 00 00 00	 push	 175			; 000000afH
  01488	68 fb 00 00 00	 push	 251			; 000000fbH
  0148d	8d 45 b8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01490	50		 push	 eax
  01491	8d 4d b8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01494	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 500  : 
; 501  : 	if(iStage < this->m_Data.size())

  01499	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0149c	83 c1 04	 add	 ecx, 4
  0149f	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  014a4	39 45 ec	 cmp	 DWORD PTR _iStage$[ebp], eax
  014a7	0f 83 85 00 00
	00		 jae	 $LN1@DGAnsUserI

; 502  : 	{
; 503  : 		REFERRAL_DATA * pData = &this->m_Data[iStage];

  014ad	8b 45 ec	 mov	 eax, DWORD PTR _iStage$[ebp]
  014b0	50		 push	 eax
  014b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  014b4	83 c1 04	 add	 ecx, 4
  014b7	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  014bc	89 45 b4	 mov	 DWORD PTR _pData$229152[ebp], eax

; 504  : 		pMsg.RefferalMaxStage = this->m_Data.size();

  014bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  014c2	83 c1 04	 add	 ecx, 4
  014c5	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  014ca	89 45 bc	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 505  : 		pMsg.User.RefferalUser = lpUser->RefferalUser;

  014cd	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  014d0	8b 88 30 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10800]
  014d6	89 4d c0	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 506  : 		pMsg.User.ReferralNeedLevel = pData->UserNeedLevel;

  014d9	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  014dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  014de	89 4d c4	 mov	 DWORD PTR _pMsg$[ebp+12], ecx

; 507  : 		pMsg.User.ReferralNeedReset = pData->UserNeedReset;

  014e1	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  014e4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  014e7	89 4d c8	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 508  : 		pMsg.User.ReferralNeedGrand = pData->UserNeedGrand;

  014ea	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  014ed	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  014f0	89 4d cc	 mov	 DWORD PTR _pMsg$[ebp+20], ecx

; 509  : 		pMsg.User.ReferralRewardCredit = pData->UserRewardCredit;

  014f3	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  014f6	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  014f9	89 4d d0	 mov	 DWORD PTR _pMsg$[ebp+24], ecx

; 510  : 		pMsg.User.ReferralRewardWCoinC = pData->UserRewardWCoinC;

  014fc	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  014ff	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01502	89 4d d4	 mov	 DWORD PTR _pMsg$[ebp+28], ecx

; 511  : 		pMsg.User.ReferralRewardWCoinP = pData->UserRewardWCoinP;

  01505	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  01508	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0150b	89 4d d8	 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 512  : 		pMsg.User.ReferralRewardWcoinG = pData->UserRewardWCoinG;

  0150e	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  01511	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01514	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 513  : 		pMsg.User.ReferralRewardBonus = pData->UserRewardBonus;

  01517	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  0151a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0151d	89 4d e0	 mov	 DWORD PTR _pMsg$[ebp+40], ecx

; 514  : 		pMsg.User.ReferralRewardPremiumType = pData->UserRewardPremiumType;

  01520	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  01523	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  01526	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+44], ecx

; 515  : 		pMsg.User.ReferralRewardPremiumTime = pData->UserRewardPremiumTime;

  01529	8b 45 b4	 mov	 eax, DWORD PTR _pData$229152[ebp]
  0152c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0152f	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+48], ecx
$LN1@DGAnsUserI:

; 516  : 	}
; 517  : 
; 518  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  01532	6a 34		 push	 52			; 00000034H
  01534	8d 45 b8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01537	50		 push	 eax
  01538	8b 4d f4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0153b	51		 push	 ecx
  0153c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01541	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DGAnsUserI:

; 519  : }

  01544	5f		 pop	 edi
  01545	5e		 pop	 esi
  01546	5b		 pop	 ebx
  01547	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0154a	33 cd		 xor	 ecx, ebp
  0154c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01551	8b e5		 mov	 esp, ebp
  01553	5d		 pop	 ebp
  01554	c2 04 00	 ret	 4
?DGAnsUserInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_USER_INFO@@@Z ENDP ; CReferralSystem::DGAnsUserInfo
_TEXT	ENDS
PUBLIC	?GDReqUserUpdate@CReferralSystem@@QAEXH@Z	; CReferralSystem::GDReqUserUpdate
PUBLIC	??_C@_0BM@JECJCPAM@?$FLReferral?$FN?5User?5Check?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BM@HNFAHHLI@?$FLReferral?$FN?5User?5Stage?5Error?$AA@ ; `string'
PUBLIC	?CGUserResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_USER_REWARD@@H@Z ; CReferralSystem::CGUserResult
;	COMDAT ??_C@_0BM@JECJCPAM@?$FLReferral?$FN?5User?5Check?5Error?$AA@
CONST	SEGMENT
??_C@_0BM@JECJCPAM@?$FLReferral?$FN?5User?5Check?5Error?$AA@ DB '[Referra'
	DB	'l] User Check Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HNFAHHLI@?$FLReferral?$FN?5User?5Stage?5Error?$AA@
CONST	SEGMENT
??_C@_0BM@HNFAHHLI@?$FLReferral?$FN?5User?5Stage?5Error?$AA@ DB '[Referra'
	DB	'l] User Stage Error', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv69 = -88						; size = 4
_pData$ = -20						; size = 4
_iStage$ = -16						; size = 4
_bResult$ = -9						; size = 1
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUserResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_USER_REWARD@@H@Z PROC ; CReferralSystem::CGUserResult
; _this$ = ecx

; 522  : {

  01560	55		 push	 ebp
  01561	8b ec		 mov	 ebp, esp
  01563	83 ec 58	 sub	 esp, 88			; 00000058H
  01566	53		 push	 ebx
  01567	56		 push	 esi
  01568	57		 push	 edi
  01569	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 523  : 	if(!this->m_bActive)

  0156c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0156f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  01572	85 c9		 test	 ecx, ecx
  01574	75 05		 jne	 SHORT $LN7@CGUserResu

; 524  : 	{
; 525  : 		return;

  01576	e9 e4 00 00 00	 jmp	 $LN8@CGUserResu
$LN7@CGUserResu:

; 526  : 	}
; 527  : 
; 528  : 	if(!OBJMAX_RANGE(aIndex))

  0157b	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0157f	7d 09		 jge	 SHORT $LN10@CGUserResu
  01581	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  01588	eb 0f		 jmp	 SHORT $LN11@CGUserResu
$LN10@CGUserResu:
  0158a	33 c0		 xor	 eax, eax
  0158c	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  01593	0f 9e c0	 setle	 al
  01596	89 45 a8	 mov	 DWORD PTR tv69[ebp], eax
$LN11@CGUserResu:
  01599	83 7d a8 00	 cmp	 DWORD PTR tv69[ebp], 0
  0159d	75 05		 jne	 SHORT $LN6@CGUserResu

; 529  : 	{
; 530  : 		return;

  0159f	e9 bb 00 00 00	 jmp	 $LN8@CGUserResu
$LN6@CGUserResu:

; 531  : 	}
; 532  : 
; 533  : 	LPOBJ lpUser = &gObj[aIndex];

  015a4	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  015a7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  015ad	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015b3	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 534  : 
; 535  : 	bool bResult = true;

  015b6	c6 45 f7 01	 mov	 BYTE PTR _bResult$[ebp], 1

; 536  : 
; 537  : 	int iStage = lpUser->RefferalUser;

  015ba	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  015bd	8b 88 30 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10800]
  015c3	89 4d f0	 mov	 DWORD PTR _iStage$[ebp], ecx

; 538  : 
; 539  : 	if(iStage >= this->m_Data.size())

  015c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015c9	83 c1 04	 add	 ecx, 4
  015cc	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  015d1	39 45 f0	 cmp	 DWORD PTR _iStage$[ebp], eax
  015d4	72 13		 jb	 SHORT $LN5@CGUserResu

; 540  : 	{
; 541  : 		MsgOutput(aIndex, "[Referral] User Stage Error");

  015d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HNFAHHLI@?$FLReferral?$FN?5User?5Stage?5Error?$AA@
  015db	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  015de	50		 push	 eax
  015df	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  015e4	83 c4 08	 add	 esp, 8

; 542  : 		return;

  015e7	eb 76		 jmp	 SHORT $LN8@CGUserResu
$LN5@CGUserResu:

; 543  : 	}
; 544  : 
; 545  : 	REFERRAL_DATA * pData = &this->m_Data[iStage];

  015e9	8b 45 f0	 mov	 eax, DWORD PTR _iStage$[ebp]
  015ec	50		 push	 eax
  015ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015f0	83 c1 04	 add	 ecx, 4
  015f3	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  015f8	89 45 ec	 mov	 DWORD PTR _pData$[ebp], eax

; 546  : 
; 547  : 	if(lpUser->Level < pData->UserNeedLevel)

  015fb	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  015fe	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  01605	8b 55 ec	 mov	 edx, DWORD PTR _pData$[ebp]
  01608	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0160a	7d 04		 jge	 SHORT $LN4@CGUserResu

; 548  : 	{
; 549  : 		bResult = false;

  0160c	c6 45 f7 00	 mov	 BYTE PTR _bResult$[ebp], 0
$LN4@CGUserResu:

; 550  : 	}
; 551  : 
; 552  : 	if(lpUser->Reset < pData->UserNeedReset)

  01610	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01613	8b 4d ec	 mov	 ecx, DWORD PTR _pData$[ebp]
  01616	8b 90 90 22 00
	00		 mov	 edx, DWORD PTR [eax+8848]
  0161c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0161f	7d 04		 jge	 SHORT $LN3@CGUserResu

; 553  : 	{
; 554  : 		bResult = false;

  01621	c6 45 f7 00	 mov	 BYTE PTR _bResult$[ebp], 0
$LN3@CGUserResu:

; 555  : 	}
; 556  : 
; 557  : 	if(lpUser->GReset < pData->UserNeedGrand)

  01625	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01628	8b 4d ec	 mov	 ecx, DWORD PTR _pData$[ebp]
  0162b	8b 90 94 22 00
	00		 mov	 edx, DWORD PTR [eax+8852]
  01631	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  01634	7d 04		 jge	 SHORT $LN2@CGUserResu

; 558  : 	{
; 559  : 		bResult = false;

  01636	c6 45 f7 00	 mov	 BYTE PTR _bResult$[ebp], 0
$LN2@CGUserResu:

; 560  : 	}
; 561  : 
; 562  : 	if(bResult == false)

  0163a	0f b6 45 f7	 movzx	 eax, BYTE PTR _bResult$[ebp]
  0163e	85 c0		 test	 eax, eax
  01640	75 11		 jne	 SHORT $LN1@CGUserResu

; 563  : 	{
; 564  : 		MsgOutput(aIndex, "[Referral] User Check Error");

  01642	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JECJCPAM@?$FLReferral?$FN?5User?5Check?5Error?$AA@
  01647	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0164a	50		 push	 eax
  0164b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  01650	83 c4 08	 add	 esp, 8
$LN1@CGUserResu:

; 565  : 	}
; 566  : 
; 567  : 	this->GDReqUserUpdate(aIndex);

  01653	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01656	50		 push	 eax
  01657	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0165a	e8 00 00 00 00	 call	 ?GDReqUserUpdate@CReferralSystem@@QAEXH@Z ; CReferralSystem::GDReqUserUpdate
$LN8@CGUserResu:

; 568  : }

  0165f	5f		 pop	 edi
  01660	5e		 pop	 esi
  01661	5b		 pop	 ebx
  01662	8b e5		 mov	 esp, ebp
  01664	5d		 pop	 ebp
  01665	c2 08 00	 ret	 8
?CGUserResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_USER_REWARD@@H@Z ENDP ; CReferralSystem::CGUserResult
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -112						; size = 4
_szAccount$ = -44					; size = 11
_pMsg$ = -32						; size = 20
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqUserUpdate@CReferralSystem@@QAEXH@Z PROC		; CReferralSystem::GDReqUserUpdate
; _this$ = ecx

; 571  : {

  01670	55		 push	 ebp
  01671	8b ec		 mov	 ebp, esp
  01673	83 ec 70	 sub	 esp, 112		; 00000070H
  01676	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0167b	33 c5		 xor	 eax, ebp
  0167d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01680	53		 push	 ebx
  01681	56		 push	 esi
  01682	57		 push	 edi
  01683	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 572  : 	if(!this->m_bActive)

  01686	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01689	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0168c	85 c9		 test	 ecx, ecx
  0168e	75 05		 jne	 SHORT $LN2@GDReqUserU

; 573  : 	{
; 574  : 		return;

  01690	e9 a1 00 00 00	 jmp	 $LN3@GDReqUserU
$LN2@GDReqUserU:

; 575  : 	}
; 576  : 
; 577  : 	if(!OBJMAX_RANGE(aIndex))

  01695	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01699	7d 09		 jge	 SHORT $LN5@GDReqUserU
  0169b	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  016a2	eb 0f		 jmp	 SHORT $LN6@GDReqUserU
$LN5@GDReqUserU:
  016a4	33 c0		 xor	 eax, eax
  016a6	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  016ad	0f 9e c0	 setle	 al
  016b0	89 45 90	 mov	 DWORD PTR tv69[ebp], eax
$LN6@GDReqUserU:
  016b3	83 7d 90 00	 cmp	 DWORD PTR tv69[ebp], 0
  016b7	75 02		 jne	 SHORT $LN1@GDReqUserU

; 578  : 	{
; 579  : 		return;

  016b9	eb 7b		 jmp	 SHORT $LN3@GDReqUserU
$LN1@GDReqUserU:

; 580  : 	}
; 581  : 
; 582  : 	LPOBJ lpUser = &gObj[aIndex];

  016bb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  016be	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  016c4	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016ca	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 583  : 
; 584  : 	PMSG_GD_REFERRAL_USER_UPDATE pMsg;
; 585  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEB, 0x17, sizeof(pMsg));

  016cd	6a 14		 push	 20			; 00000014H
  016cf	6a 17		 push	 23			; 00000017H
  016d1	68 eb 00 00 00	 push	 235			; 000000ebH
  016d6	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  016d9	50		 push	 eax
  016da	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  016dd	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 586  : 	pMsg.aIndex = aIndex;

  016e2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  016e5	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 587  : 
; 588  : 	char szAccount[11] = { 0 };

  016e8	c6 45 d4 00	 mov	 BYTE PTR _szAccount$[ebp], 0
  016ec	33 c0		 xor	 eax, eax
  016ee	89 45 d5	 mov	 DWORD PTR _szAccount$[ebp+1], eax
  016f1	89 45 d9	 mov	 DWORD PTR _szAccount$[ebp+5], eax
  016f4	66 89 45 dd	 mov	 WORD PTR _szAccount$[ebp+9], ax

; 589  : 	memcpy(szAccount, lpUser->AccountID, sizeof(szAccount));

  016f8	6a 0b		 push	 11			; 0000000bH
  016fa	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  016fd	83 c0 6c	 add	 eax, 108		; 0000006cH
  01700	50		 push	 eax
  01701	8d 4d d4	 lea	 ecx, DWORD PTR _szAccount$[ebp]
  01704	51		 push	 ecx
  01705	e8 00 00 00 00	 call	 _memcpy
  0170a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  : 	szAccount[10] = 0;

  0170d	c6 45 de 00	 mov	 BYTE PTR _szAccount$[ebp+10], 0

; 591  : 	memcpy(pMsg.ReferalName, szAccount, sizeof(szAccount)-1);

  01711	6a 0a		 push	 10			; 0000000aH
  01713	8d 45 d4	 lea	 eax, DWORD PTR _szAccount$[ebp]
  01716	50		 push	 eax
  01717	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp+8]
  0171a	51		 push	 ecx
  0171b	e8 00 00 00 00	 call	 _memcpy
  01720	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  : 
; 593  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  01723	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  01727	50		 push	 eax
  01728	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0172b	51		 push	 ecx
  0172c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  01731	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqUserU:

; 594  : }

  01736	5f		 pop	 edi
  01737	5e		 pop	 esi
  01738	5b		 pop	 ebx
  01739	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0173c	33 cd		 xor	 ecx, ebp
  0173e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01743	8b e5		 mov	 esp, ebp
  01745	5d		 pop	 ebp
  01746	c2 04 00	 ret	 4
?GDReqUserUpdate@CReferralSystem@@QAEXH@Z ENDP		; CReferralSystem::GDReqUserUpdate
_TEXT	ENDS
PUBLIC	??_C@_0CO@JKABGNNC@?$EA?$FLReferral?$FN?5User?5Premium?5Type?3?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@IDAPGKBF@?$EA?$FLReferral?$FN?5User?5WCoinG?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BM@JNNMFIDG@?$EA?$FLReferral?$FN?5User?5WCoinP?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BM@BIJOCIAD@?$EA?$FLReferral?$FN?5User?5WCoinC?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BM@FJLGOJIB@?$EA?$FLReferral?$FN?5User?5Crecit?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BN@KLNODJJH@?$FLReferral?$FN?5User?5Update?5Error?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsUserUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_USER_UPDATE@@@Z ; CReferralSystem::DGAnsUserUpdate
;	COMDAT ??_C@_0CO@JKABGNNC@?$EA?$FLReferral?$FN?5User?5Premium?5Type?3?5?$CF@
CONST	SEGMENT
??_C@_0CO@JKABGNNC@?$EA?$FLReferral?$FN?5User?5Premium?5Type?3?5?$CF@ DB '@'
	DB	'[Referral] User Premium Type: %d Time: +%d h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IDAPGKBF@?$EA?$FLReferral?$FN?5User?5WCoinG?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@IDAPGKBF@?$EA?$FLReferral?$FN?5User?5WCoinG?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] User WCoinG +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JNNMFIDG@?$EA?$FLReferral?$FN?5User?5WCoinP?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@JNNMFIDG@?$EA?$FLReferral?$FN?5User?5WCoinP?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] User WCoinP +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BIJOCIAD@?$EA?$FLReferral?$FN?5User?5WCoinC?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@BIJOCIAD@?$EA?$FLReferral?$FN?5User?5WCoinC?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] User WCoinC +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJLGOJIB@?$EA?$FLReferral?$FN?5User?5Crecit?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@FJLGOJIB@?$EA?$FLReferral?$FN?5User?5Crecit?5?$CL?$CFd?$AA@ DB '@'
	DB	'[Referral] User Crecit +%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KLNODJJH@?$FLReferral?$FN?5User?5Update?5Error?$AA@
CONST	SEGMENT
??_C@_0BN@KLNODJJH@?$FLReferral?$FN?5User?5Update?5Error?$AA@ DB '[Referr'
	DB	'al] User Update Error', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv68 = -136						; size = 4
_pMsg$ = -68						; size = 44
_pData$ = -24						; size = 4
_iStage$ = -20						; size = 4
_lpUser$ = -16						; size = 4
_aIndex$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsUserUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_USER_UPDATE@@@Z PROC ; CReferralSystem::DGAnsUserUpdate
; _this$ = ecx

; 597  : {

  01750	55		 push	 ebp
  01751	8b ec		 mov	 ebp, esp
  01753	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  01759	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0175e	33 c5		 xor	 eax, ebp
  01760	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01763	53		 push	 ebx
  01764	56		 push	 esi
  01765	57		 push	 edi
  01766	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 598  : 	int aIndex = lpMsg->aIndex;

  01769	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0176c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0176f	89 4d f4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 599  : 
; 600  : 	if(!OBJMAX_RANGE(aIndex))

  01772	83 7d f4 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01776	7d 0c		 jge	 SHORT $LN12@DGAnsUserU
  01778	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  01782	eb 12		 jmp	 SHORT $LN13@DGAnsUserU
$LN12@DGAnsUserU:
  01784	33 c0		 xor	 eax, eax
  01786	81 7d f4 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0178d	0f 9e c0	 setle	 al
  01790	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN13@DGAnsUserU:
  01796	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  0179d	75 05		 jne	 SHORT $LN9@DGAnsUserU

; 601  : 	{
; 602  : 		return;

  0179f	e9 c2 02 00 00	 jmp	 $LN10@DGAnsUserU
$LN9@DGAnsUserU:

; 603  : 	}
; 604  : 
; 605  : 	if(!lpMsg->Result)

  017a4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  017a7	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  017ab	85 c9		 test	 ecx, ecx
  017ad	75 16		 jne	 SHORT $LN8@DGAnsUserU

; 606  : 	{
; 607  : 		MsgOutput(aIndex, "[Referral] User Update Error");

  017af	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KLNODJJH@?$FLReferral?$FN?5User?5Update?5Error?$AA@
  017b4	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  017b7	50		 push	 eax
  017b8	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  017bd	83 c4 08	 add	 esp, 8

; 608  : 		return;

  017c0	e9 a1 02 00 00	 jmp	 $LN10@DGAnsUserU
$LN8@DGAnsUserU:

; 609  : 	}
; 610  : 
; 611  : 	LPOBJ lpUser = &gObj[aIndex];

  017c5	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  017c8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  017ce	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017d4	89 45 f0	 mov	 DWORD PTR _lpUser$[ebp], eax

; 612  : 
; 613  : 	int iStage = lpUser->RefferalUser;

  017d7	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  017da	8b 88 30 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10800]
  017e0	89 4d ec	 mov	 DWORD PTR _iStage$[ebp], ecx

; 614  : 
; 615  : 	if(iStage >= this->m_Data.size())

  017e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017e6	83 c1 04	 add	 ecx, 4
  017e9	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  017ee	39 45 ec	 cmp	 DWORD PTR _iStage$[ebp], eax
  017f1	72 16		 jb	 SHORT $LN7@DGAnsUserU

; 616  : 	{
; 617  : 		MsgOutput(aIndex, "[Referral] User Stage Error");

  017f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HNFAHHLI@?$FLReferral?$FN?5User?5Stage?5Error?$AA@
  017f8	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  017fb	50		 push	 eax
  017fc	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  01801	83 c4 08	 add	 esp, 8

; 618  : 		return;

  01804	e9 5d 02 00 00	 jmp	 $LN10@DGAnsUserU
$LN7@DGAnsUserU:

; 619  : 	}
; 620  : 
; 621  : 	REFERRAL_DATA * pData = &this->m_Data[iStage];

  01809	8b 45 ec	 mov	 eax, DWORD PTR _iStage$[ebp]
  0180c	50		 push	 eax
  0180d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01810	83 c1 04	 add	 ecx, 4
  01813	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  01818	89 45 e8	 mov	 DWORD PTR _pData$[ebp], eax

; 622  : 
; 623  : 	if(pData->UserRewardCredit > 0)

  0181b	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0181e	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  01822	7e 30		 jle	 SHORT $LN6@DGAnsUserU

; 624  : 	{
; 625  : 		lpUser->ExCred += pData->UserRewardCredit;

  01824	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01827	db 40 28	 fild	 DWORD PTR [eax+40]
  0182a	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0182d	d8 81 a8 22 00
	00		 fadd	 DWORD PTR [ecx+8872]
  01833	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  01836	d9 9a a8 22 00
	00		 fstp	 DWORD PTR [edx+8872]

; 626  : 		MessageChat(aIndex, "@[Referral] User Crecit +%d", pData->UserRewardCredit);

  0183c	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0183f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  01842	51		 push	 ecx
  01843	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@FJLGOJIB@?$EA?$FLReferral?$FN?5User?5Crecit?5?$CL?$CFd?$AA@
  01848	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0184b	52		 push	 edx
  0184c	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  01851	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@DGAnsUserU:

; 627  : 	}
; 628  : 
; 629  : 	if(pData->UserRewardWCoinC > 0)

  01854	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01857	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0185b	7e 3e		 jle	 SHORT $LN5@DGAnsUserU

; 630  : 	{
; 631  : 		lpUser->GameShop.WCoinC += pData->UserRewardWCoinC;

  0185d	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01860	db 40 2c	 fild	 DWORD PTR [eax+44]
  01863	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  01866	dc 81 00 23 00
	00		 fadd	 QWORD PTR [ecx+8960]
  0186c	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0186f	dd 9a 00 23 00
	00		 fstp	 QWORD PTR [edx+8960]

; 632  : 		gGameShop.GDSaveUserInfo(aIndex);

  01875	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01878	50		 push	 eax
  01879	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0187e	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 633  : 		MessageChat(aIndex, "@[Referral] User WCoinC +%d", pData->UserRewardWCoinC);

  01883	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01886	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01889	51		 push	 ecx
  0188a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BIJOCIAD@?$EA?$FLReferral?$FN?5User?5WCoinC?5?$CL?$CFd?$AA@
  0188f	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01892	52		 push	 edx
  01893	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  01898	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@DGAnsUserU:

; 634  : 	}
; 635  : 
; 636  : 	if(pData->UserRewardWCoinP > 0)

  0189b	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0189e	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  018a2	7e 3e		 jle	 SHORT $LN4@DGAnsUserU

; 637  : 	{
; 638  : 		lpUser->GameShop.WCoinP += pData->UserRewardWCoinP;

  018a4	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  018a7	db 40 30	 fild	 DWORD PTR [eax+48]
  018aa	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  018ad	dc 81 f8 22 00
	00		 fadd	 QWORD PTR [ecx+8952]
  018b3	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  018b6	dd 9a f8 22 00
	00		 fstp	 QWORD PTR [edx+8952]

; 639  : 		gGameShop.GDSaveUserInfo(aIndex);

  018bc	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  018bf	50		 push	 eax
  018c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  018c5	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 640  : 		MessageChat(aIndex, "@[Referral] User WCoinP +%d", pData->UserRewardWCoinP);

  018ca	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  018cd	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  018d0	51		 push	 ecx
  018d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JNNMFIDG@?$EA?$FLReferral?$FN?5User?5WCoinP?5?$CL?$CFd?$AA@
  018d6	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  018d9	52		 push	 edx
  018da	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  018df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DGAnsUserU:

; 641  : 	}
; 642  : 
; 643  : 	if(pData->UserRewardWCoinG > 0)

  018e2	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  018e5	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  018e9	7e 3e		 jle	 SHORT $LN3@DGAnsUserU

; 644  : 	{
; 645  : 		lpUser->GameShop.GoblinPoint += pData->UserRewardWCoinG;

  018eb	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  018ee	db 40 34	 fild	 DWORD PTR [eax+52]
  018f1	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  018f4	dc 81 08 23 00
	00		 fadd	 QWORD PTR [ecx+8968]
  018fa	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  018fd	dd 9a 08 23 00
	00		 fstp	 QWORD PTR [edx+8968]

; 646  : 		gGameShop.GDSaveUserInfo(aIndex);

  01903	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01906	50		 push	 eax
  01907	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0190c	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 647  : 		MessageChat(aIndex, "@[Referral] User WCoinG +%d", pData->UserRewardWCoinG);

  01911	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01914	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01917	51		 push	 ecx
  01918	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IDAPGKBF@?$EA?$FLReferral?$FN?5User?5WCoinG?5?$CL?$CFd?$AA@
  0191d	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01920	52		 push	 edx
  01921	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  01926	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@DGAnsUserU:

; 648  : 	}
; 649  : 
; 650  : 	if(pData->UserRewardPremiumType > 0 && pData->UserRewardPremiumTime > 0)

  01929	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0192c	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  01930	7e 55		 jle	 SHORT $LN2@DGAnsUserU
  01932	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01935	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  01939	7e 4c		 jle	 SHORT $LN2@DGAnsUserU

; 651  : 	{
; 652  : 		lpUser->PremiumTimeType = pData->UserRewardPremiumType;

  0193b	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0193e	8b 4d e8	 mov	 ecx, DWORD PTR _pData$[ebp]
  01941	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  01944	89 90 bc 22 00
	00		 mov	 DWORD PTR [eax+8892], edx

; 653  : 		lpUser->PremiumTime += pData->UserRewardPremiumTime * 3600;

  0194a	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0194d	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01950	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  01956	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  01959	03 8a b8 22 00
	00		 add	 ecx, DWORD PTR [edx+8888]
  0195f	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01962	89 88 b8 22 00
	00		 mov	 DWORD PTR [eax+8888], ecx

; 654  : 		MessageChat(aIndex, "@[Referral] User Premium Type: %d Time: +%d h", pData->UserRewardPremiumType, pData->UserRewardPremiumTime);

  01968	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0196b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0196e	51		 push	 ecx
  0196f	8b 55 e8	 mov	 edx, DWORD PTR _pData$[ebp]
  01972	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  01975	50		 push	 eax
  01976	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JKABGNNC@?$EA?$FLReferral?$FN?5User?5Premium?5Type?3?5?$CF@
  0197b	8b 4d f4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0197e	51		 push	 ecx
  0197f	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  01984	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@DGAnsUserU:

; 655  : 	}
; 656  : 
; 657  : 	ExUserDataSend(aIndex);

  01987	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0198a	50		 push	 eax
  0198b	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  01990	83 c4 04	 add	 esp, 4

; 658  : 
; 659  : 	PMSG_GCANS_REFERRAL_USER_REWARD pMsg;
; 660  : 	memset(&pMsg, 0, sizeof(pMsg));

  01993	6a 2c		 push	 44			; 0000002cH
  01995	6a 00		 push	 0
  01997	8d 45 bc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0199a	50		 push	 eax
  0199b	e8 00 00 00 00	 call	 _memset
  019a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 661  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB3, sizeof(pMsg));

  019a3	6a 2c		 push	 44			; 0000002cH
  019a5	68 b3 00 00 00	 push	 179			; 000000b3H
  019aa	68 fb 00 00 00	 push	 251			; 000000fbH
  019af	8d 45 bc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  019b2	50		 push	 eax
  019b3	8d 4d bc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  019b6	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 662  : 
; 663  : 	if(iStage < this->m_Data.size())

  019bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019be	83 c1 04	 add	 ecx, 4
  019c1	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  019c6	39 45 ec	 cmp	 DWORD PTR _iStage$[ebp], eax
  019c9	73 1b		 jae	 SHORT $LN1@DGAnsUserU

; 664  : 	{
; 665  : 		iStage++;

  019cb	8b 45 ec	 mov	 eax, DWORD PTR _iStage$[ebp]
  019ce	83 c0 01	 add	 eax, 1
  019d1	89 45 ec	 mov	 DWORD PTR _iStage$[ebp], eax

; 666  : 		pData = &this->m_Data[iStage];

  019d4	8b 45 ec	 mov	 eax, DWORD PTR _iStage$[ebp]
  019d7	50		 push	 eax
  019d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019db	83 c1 04	 add	 ecx, 4
  019de	e8 00 00 00 00	 call	 ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
  019e3	89 45 e8	 mov	 DWORD PTR _pData$[ebp], eax
$LN1@DGAnsUserU:

; 667  : 	}
; 668  : 
; 669  : 	pMsg.UserNeedLevel = pData->UserNeedLevel;

  019e6	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  019e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  019eb	89 4d c0	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 670  : 	pMsg.UserNeedReset = pData->UserNeedReset;

  019ee	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  019f1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  019f4	89 4d c4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 671  : 	pMsg.UserNeedGrand = pData->UserNeedGrand;

  019f7	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  019fa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  019fd	89 4d c8	 mov	 DWORD PTR _pMsg$[ebp+12], ecx

; 672  : 	pMsg.UserRewardCredit = pData->UserRewardCredit;

  01a00	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a03	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  01a06	89 4d cc	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 673  : 	pMsg.UserRewardWCoinC = pData->UserRewardWCoinC;

  01a09	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a0c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01a0f	89 4d d0	 mov	 DWORD PTR _pMsg$[ebp+20], ecx

; 674  : 	pMsg.UserRewardWCoinP = pData->UserRewardWCoinP;

  01a12	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a15	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  01a18	89 4d d4	 mov	 DWORD PTR _pMsg$[ebp+24], ecx

; 675  : 	pMsg.UserRewardWcoinG = pData->UserRewardWCoinG;

  01a1b	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a1e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01a21	89 4d d8	 mov	 DWORD PTR _pMsg$[ebp+28], ecx

; 676  : 	pMsg.UserRewardBonus = pData->UserRewardBonus;

  01a24	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a27	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01a2a	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 677  : 	pMsg.UserRewardPremiumType = pData->UserRewardPremiumType;

  01a2d	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a30	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  01a33	89 4d e0	 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 678  : 	pMsg.UserRewardPremiumTime = pData->UserRewardPremiumTime;

  01a36	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  01a39	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01a3c	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+40], ecx

; 679  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  01a3f	6a 2c		 push	 44			; 0000002cH
  01a41	8d 45 bc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01a44	50		 push	 eax
  01a45	8b 4d f4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01a48	51		 push	 ecx
  01a49	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01a4e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 680  : 
; 681  : 	lpUser->RefferalUser++;

  01a51	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01a54	8b 88 30 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10800]
  01a5a	83 c1 01	 add	 ecx, 1
  01a5d	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  01a60	89 8a 30 2a 00
	00		 mov	 DWORD PTR [edx+10800], ecx
$LN10@DGAnsUserU:

; 682  : }

  01a66	5f		 pop	 edi
  01a67	5e		 pop	 esi
  01a68	5b		 pop	 ebx
  01a69	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a6c	33 cd		 xor	 ecx, ebp
  01a6e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a73	8b e5		 mov	 esp, ebp
  01a75	5d		 pop	 ebp
  01a76	c2 04 00	 ret	 4
?DGAnsUserUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_USER_UPDATE@@@Z ENDP ; CReferralSystem::DGAnsUserUpdate
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@V?$allocator@UREFERRAL_DATA@@@1@@Z ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
PUBLIC	??0?$allocator@UREFERRAL_DATA@@@std@@QAE@XZ	; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T230286 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T230286[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UREFERRAL_DATA@@@std@@QAE@XZ ; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@V?$allocator@UREFERRAL_DATA@@@1@@Z ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
PUBLIC	?_Tidy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
__ehhandler$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 44	 imul	 eax, 68			; 00000044H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEAAUREFERRAL_DATA@@I@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@ABU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@AAU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA &>
PUBLIC	?_Orphan_range@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXI@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBE_NPBUREFERRAL_DATA@@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUREFERRAL_DATA@@@std@@YAPBUREFERRAL_DATA@@ABU1@@Z ; std::addressof<REFERRAL_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXABUREFERRAL_DATA@@@Z
_TEXT	SEGMENT
__Idx$229232 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXABUREFERRAL_DATA@@@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUREFERRAL_DATA@@@std@@YAPBUREFERRAL_DATA@@ABU1@@Z ; std::addressof<REFERRAL_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBE_NPBUREFERRAL_DATA@@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUREFERRAL_DATA@@@std@@YAPBUREFERRAL_DATA@@ABU1@@Z ; std::addressof<REFERRAL_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$229232[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXI@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$229232[ebp]
  00075	6b c0 44	 imul	 eax, 68			; 00000044H
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@AAU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 44	 add	 ecx, 68			; 00000044H
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXI@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@ABU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 44	 add	 ecx, 68			; 00000044H
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXABUREFERRAL_DATA@@@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::erase
PUBLIC	?begin@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::begin
PUBLIC	?end@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T230305 = -88						; size = 4
$T230306 = -84						; size = 4
$T230307 = -80						; size = 4
$T230308 = -76						; size = 4
$T230309 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T230306[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T230305[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T230308[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T230307[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T230305[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T230307[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T230309[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Destroy
PUBLIC	??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00@Z ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T230316 = -84						; size = 4
__Ptr$229423 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00@Z ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$229423[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$229423[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$229423[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T230316[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T230316[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBE_NPBUREFERRAL_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBE_NPBUREFERRAL_DATA@@@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBE_NPBUREFERRAL_DATA@@@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEII@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEII@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z ; std::allocator<REFERRAL_DATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z ; std::allocator<REFERRAL_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXPAUREFERRAL_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXPAUREFERRAL_DATA@@0@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXPAUREFERRAL_DATA@@0@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UREFERRAL_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@V?$allocator@UREFERRAL_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@V?$allocator@UREFERRAL_DATA@@@1@@Z PROC ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UREFERRAL_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@V?$allocator@UREFERRAL_DATA@@@1@@Z ENDP ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::~_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UREFERRAL_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UREFERRAL_DATA@@@std@@QAE@XZ PROC	; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UREFERRAL_DATA@@@std@@QAE@XZ ENDP	; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUREFERRAL_DATA@@@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEPAUREFERRAL_DATA@@PAU2@00@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Umove<REFERRAL_DATA *>
PUBLIC	?allocate@?$allocator@UREFERRAL_DATA@@@std@@QAEPAUREFERRAL_DATA@@I@Z ; std::allocator<REFERRAL_DATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$229465 = -28					; size = 4
__Ptr$229458 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UREFERRAL_DATA@@@std@@QAEPAUREFERRAL_DATA@@I@Z ; std::allocator<REFERRAL_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$229458[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$229458[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUREFERRAL_DATA@@@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEPAUREFERRAL_DATA@@PAU2@00@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Umove<REFERRAL_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229458[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z ; std::allocator<REFERRAL_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$229465[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z ; std::allocator<REFERRAL_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 44	 imul	 eax, 68			; 00000044H
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$229458[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$229465[ebp]
  00125	6b c0 44	 imul	 eax, 68			; 00000044H
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$229458[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229458[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UREFERRAL_DATA@@@std@@QBEIXZ ; std::allocator<REFERRAL_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UREFERRAL_DATA@@@std@@QBEIXZ ; std::allocator<REFERRAL_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEXPAUREFERRAL_DATA@@0@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@QBEIXZ ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UREFERRAL_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UREFERRAL_DATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UREFERRAL_DATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<REFERRAL_DATA>::allocator<REFERRAL_DATA>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z PROC ; std::allocator<REFERRAL_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@I@Z ENDP ; std::allocator<REFERRAL_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@IPAU1@@Z ; std::_Allocate<REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UREFERRAL_DATA@@@std@@QAEPAUREFERRAL_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UREFERRAL_DATA@@@std@@QAEPAUREFERRAL_DATA@@I@Z PROC ; std::allocator<REFERRAL_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@IPAU1@@Z ; std::_Allocate<REFERRAL_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UREFERRAL_DATA@@@std@@QAEPAUREFERRAL_DATA@@I@Z ENDP ; std::allocator<REFERRAL_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UREFERRAL_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UREFERRAL_DATA@@@std@@QBEIXZ PROC	; std::allocator<REFERRAL_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 c3 c3
	c3 03		 mov	 DWORD PTR __Count$[ebp], 63161283 ; 03c3c3c3H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UREFERRAL_DATA@@@std@@QBEIXZ ENDP	; std::allocator<REFERRAL_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QAE@PAUREFERRAL_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<REFERRAL_DATA,std::allocator<REFERRAL_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUREFERRAL_DATA@@@std@@YAPBUREFERRAL_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUREFERRAL_DATA@@@std@@YAPBUREFERRAL_DATA@@ABU1@@Z PROC ; std::addressof<REFERRAL_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUREFERRAL_DATA@@@std@@YAPBUREFERRAL_DATA@@ABU1@@Z ENDP ; std::addressof<REFERRAL_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z ; std::allocator<REFERRAL_DATA>::construct<REFERRAL_DATA &>
PUBLIC	??$forward@AAUREFERRAL_DATA@@@std@@YAAAUREFERRAL_DATA@@AAU1@@Z ; std::forward<REFERRAL_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@AAU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@AAU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUREFERRAL_DATA@@@std@@YAAAUREFERRAL_DATA@@AAU1@@Z ; std::forward<REFERRAL_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z ; std::allocator<REFERRAL_DATA>::construct<REFERRAL_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@AAU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@ABU3@@Z ; std::allocator<REFERRAL_DATA>::construct
PUBLIC	??$forward@ABUREFERRAL_DATA@@@std@@YAABUREFERRAL_DATA@@ABU1@@Z ; std::forward<REFERRAL_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@ABU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@ABU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUREFERRAL_DATA@@@std@@YAABUREFERRAL_DATA@@ABU1@@Z ; std::forward<REFERRAL_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@ABU3@@Z ; std::allocator<REFERRAL_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@ABU3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>
PUBLIC	??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z ; std::_Ptr_cat<REFERRAL_DATA,REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T230391 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00@Z PROC ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z ; std::_Ptr_cat<REFERRAL_DATA,REFERRAL_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T230391[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T230391[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00@Z ENDP ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@@Z ; std::_Uninitialized_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUREFERRAL_DATA@@@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEPAUREFERRAL_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUREFERRAL_DATA@@@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEPAUREFERRAL_DATA@@PAU2@00@Z PROC ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Umove<REFERRAL_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@@Z ; std::_Uninitialized_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUREFERRAL_DATA@@@?$vector@UREFERRAL_DATA@@V?$allocator@UREFERRAL_DATA@@@std@@@std@@IAEPAUREFERRAL_DATA@@PAU2@00@Z ENDP ; std::vector<REFERRAL_DATA,std::allocator<REFERRAL_DATA> >::_Umove<REFERRAL_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@@Z
_TEXT	SEGMENT
$T230396 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z ; std::_Ptr_cat<REFERRAL_DATA,REFERRAL_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T230396[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T230396[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T230399 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@IPAU1@@Z PROC ; std::_Allocate<REFERRAL_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 c3 c3
	c3 03		 cmp	 DWORD PTR __Count$[ebp], 63161283 ; 03c3c3c3H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 44	 imul	 eax, 68			; 00000044H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T230399[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T230399[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@IPAU1@@Z ENDP ; std::_Allocate<REFERRAL_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z ; std::_Construct<REFERRAL_DATA,REFERRAL_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@ABU3@@Z PROC ; std::allocator<REFERRAL_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z ; std::_Construct<REFERRAL_DATA,REFERRAL_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@ABU3@@Z ENDP ; std::allocator<REFERRAL_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUREFERRAL_DATA@@@std@@YAAAUREFERRAL_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUREFERRAL_DATA@@@std@@YAAAUREFERRAL_DATA@@AAU1@@Z PROC ; std::forward<REFERRAL_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUREFERRAL_DATA@@@std@@YAAAUREFERRAL_DATA@@AAU1@@Z ENDP ; std::forward<REFERRAL_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T230406 = -88						; size = 4
$T230407 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z PROC ; std::allocator<REFERRAL_DATA>::construct<REFERRAL_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 44		 push	 68			; 00000044H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T230407[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T230407[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUREFERRAL_DATA@@@std@@YAAAUREFERRAL_DATA@@AAU1@@Z ; std::forward<REFERRAL_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T230407[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T230407[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T230406[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T230407[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUREFERRAL_DATA@@@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@AAU2@@Z ENDP ; std::allocator<REFERRAL_DATA>::construct<REFERRAL_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUREFERRAL_DATA@@@std@@YAABUREFERRAL_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUREFERRAL_DATA@@@std@@YAABUREFERRAL_DATA@@ABU1@@Z PROC ; std::forward<REFERRAL_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUREFERRAL_DATA@@@std@@YAABUREFERRAL_DATA@@ABU1@@Z ENDP ; std::forward<REFERRAL_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z PROC ; std::_Ptr_cat<REFERRAL_DATA,REFERRAL_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z ENDP ; std::_Ptr_cat<REFERRAL_DATA,REFERRAL_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAUREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ; std::move<REFERRAL_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 44	 add	 eax, 68			; 00000044H
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 44	 add	 ecx, 68			; 00000044H
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1a		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ; std::move<REFERRAL_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00036	8b f0		 mov	 esi, eax
  00038	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0003b	f3 a5		 rep movsd
  0003d	eb cc		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Move@PAUREFERRAL_DATA@@PAU1@@std@@YAPAUREFERRAL_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<REFERRAL_DATA *,REFERRAL_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
PUBLIC	??$_Val_type@PAUREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@PAU1@@Z ; std::_Val_type<REFERRAL_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@@Z
_TEXT	SEGMENT
$T230429 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@@Z PROC ; std::_Uninitialized_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UREFERRAL_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUREFERRAL_DATA@@0@Z ; std::_Ptr_cat<REFERRAL_DATA,REFERRAL_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T230429[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T230429[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@PAU1@@Z ; std::_Val_type<REFERRAL_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@@Z ; std::_Dest_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 44	 add	 eax, 68			; 00000044H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@@Z ; std::_Dest_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UREFERRAL_DATA@@@std@@@std@@YAXPAUREFERRAL_DATA@@0AAV?$allocator@UREFERRAL_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<REFERRAL_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T230434 = -88						; size = 4
$T230435 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z PROC ; std::_Construct<REFERRAL_DATA,REFERRAL_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 44		 push	 68			; 00000044H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T230435[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T230435[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUREFERRAL_DATA@@@std@@YAABUREFERRAL_DATA@@ABU1@@Z ; std::forward<REFERRAL_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T230435[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T230435[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T230434[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T230435[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UREFERRAL_DATA@@ABU1@@std@@YAXPAUREFERRAL_DATA@@ABU1@@Z ENDP ; std::_Construct<REFERRAL_DATA,REFERRAL_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z PROC ; std::move<REFERRAL_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ENDP ; std::move<REFERRAL_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@PAU1@@Z PROC ; std::_Val_type<REFERRAL_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUREFERRAL_DATA@@@std@@YAPAUREFERRAL_DATA@@PAU1@@Z ENDP ; std::_Val_type<REFERRAL_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@U3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA>,REFERRAL_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 44	 add	 eax, 68			; 00000044H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 44	 add	 ecx, 68			; 00000044H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@U3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 44	 add	 eax, 68			; 00000044H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@@Z ; std::_Dest_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUREFERRAL_DATA@@PAU1@V?$allocator@UREFERRAL_DATA@@@std@@U1@@std@@YAPAUREFERRAL_DATA@@PAU1@00AAV?$allocator@UREFERRAL_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<REFERRAL_DATA *,REFERRAL_DATA *,std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
PUBLIC	?destroy@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@@Z ; std::allocator<REFERRAL_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@@Z PROC ; std::_Dest_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@@Z ; std::allocator<REFERRAL_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UREFERRAL_DATA@@@std@@YAXPAUREFERRAL_DATA@@@Z ; std::_Destroy<REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@@Z PROC ; std::allocator<REFERRAL_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UREFERRAL_DATA@@@std@@YAXPAUREFERRAL_DATA@@@Z ; std::_Destroy<REFERRAL_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@@Z ENDP ; std::allocator<REFERRAL_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z ; std::allocator<REFERRAL_DATA>::construct
PUBLIC	??$forward@UREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ; std::forward<REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@U3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@U3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ; std::forward<REFERRAL_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z ; std::allocator<REFERRAL_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UREFERRAL_DATA@@@std@@UREFERRAL_DATA@@U3@@std@@YAXAAV?$allocator@UREFERRAL_DATA@@@0@PAUREFERRAL_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<REFERRAL_DATA>,REFERRAL_DATA,REFERRAL_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UREFERRAL_DATA@@@std@@YAXPAUREFERRAL_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UREFERRAL_DATA@@@std@@YAXPAUREFERRAL_DATA@@@Z PROC ; std::_Destroy<REFERRAL_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UREFERRAL_DATA@@@std@@YAXPAUREFERRAL_DATA@@@Z ENDP ; std::_Destroy<REFERRAL_DATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T230474 = -88						; size = 4
$T230475 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z PROC ; std::allocator<REFERRAL_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 44		 push	 68			; 00000044H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T230475[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T230475[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ; std::forward<REFERRAL_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T230475[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T230475[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T230474[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T230475[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UREFERRAL_DATA@@@std@@QAEXPAUREFERRAL_DATA@@$$QAU3@@Z ENDP ; std::allocator<REFERRAL_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z PROC ; std::forward<REFERRAL_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UREFERRAL_DATA@@@std@@YA$$QAUREFERRAL_DATA@@AAU1@@Z ENDP ; std::forward<REFERRAL_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\referralsystem.cpp
;	COMDAT ??__Eg_ReferralSystem@@YAXXZ
text$yc	SEGMENT
??__Eg_ReferralSystem@@YAXXZ PROC			; `dynamic initializer for 'g_ReferralSystem'', COMDAT

; 14   : CReferralSystem g_ReferralSystem;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  0000e	e8 00 00 00 00	 call	 ??0CReferralSystem@@QAE@XZ ; CReferralSystem::CReferralSystem
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_ReferralSystem@@YAXXZ ; `dynamic atexit destructor for 'g_ReferralSystem''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_ReferralSystem@@YAXXZ ENDP			; `dynamic initializer for 'g_ReferralSystem''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_ReferralSystem@@YAXXZ
text$yd	SEGMENT
??__Fg_ReferralSystem@@YAXXZ PROC			; `dynamic atexit destructor for 'g_ReferralSystem'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  0000e	e8 00 00 00 00	 call	 ??1CReferralSystem@@QAE@XZ ; CReferralSystem::~CReferralSystem
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_ReferralSystem@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_ReferralSystem''
text$yd	ENDS
PUBLIC	?g_ReferralSystem@@3VCReferralSystem@@A		; g_ReferralSystem
_BSS	SEGMENT
?g_ReferralSystem@@3VCReferralSystem@@A DB 014H DUP (?)	; g_ReferralSystem
_BSS	ENDS
CRT$XCU	SEGMENT
_g_ReferralSystem$initializer$ DD FLAT:??__Eg_ReferralSystem@@YAXXZ
CRT$XCU	ENDS
END
