; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MUHelper.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Init@MUHelper@@QAEXXZ				; MUHelper::Init
PUBLIC	??_7MUHelper@@6B@				; MUHelper::`vftable'
PUBLIC	??0MUHelper@@QAE@XZ				; MUHelper::MUHelper
PUBLIC	??_R4MUHelper@@6B@				; MUHelper::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMUHelper@@@8				; MUHelper `RTTI Type Descriptor'
PUBLIC	??_R3MUHelper@@8				; MUHelper::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MUHelper@@8				; MUHelper::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MUHelper@@8			; MUHelper::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EMUHelper@@UAEPAXI@Z:PROC			; MUHelper::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@MUHelper@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\muhelper.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@MUHelper@@8 DD FLAT:??_R0?AVMUHelper@@@8	; MUHelper::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MUHelper@@8
rdata$r	ENDS
;	COMDAT ??_R2MUHelper@@8
rdata$r	SEGMENT
??_R2MUHelper@@8 DD FLAT:??_R1A@?0A@EA@MUHelper@@8	; MUHelper::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MUHelper@@8
rdata$r	SEGMENT
??_R3MUHelper@@8 DD 00H					; MUHelper::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MUHelper@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMUHelper@@@8
_DATA	SEGMENT
??_R0?AVMUHelper@@@8 DD FLAT:??_7type_info@@6B@		; MUHelper `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMUHelper@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MUHelper@@6B@
rdata$r	SEGMENT
??_R4MUHelper@@6B@ DD 00H				; MUHelper::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMUHelper@@@8
	DD	FLAT:??_R3MUHelper@@8
rdata$r	ENDS
;	COMDAT ??_7MUHelper@@6B@
CONST	SEGMENT
??_7MUHelper@@6B@ DD FLAT:??_R4MUHelper@@6B@		; MUHelper::`vftable'
	DD	FLAT:??_EMUHelper@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MUHelper@@QAE@XZ PROC				; MUHelper::MUHelper
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MUHelper@@6B@

; 22   : 	this->Init();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Init@MUHelper@@QAEXXZ	; MUHelper::Init

; 23   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0MUHelper@@QAE@XZ ENDP				; MUHelper::MUHelper
_TEXT	ENDS
PUBLIC	??1MUHelper@@UAE@XZ				; MUHelper::~MUHelper
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GMUHelper@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMUHelper@@UAEPAXI@Z PROC				; MUHelper::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1MUHelper@@UAE@XZ	; MUHelper::~MUHelper
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GMUHelper@@UAEPAXI@Z ENDP				; MUHelper::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MUHelper@@UAE@XZ PROC				; MUHelper::~MUHelper
; _this$ = ecx

; 27   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MUHelper@@6B@

; 28   : 	// ----
; 29   : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??1MUHelper@@UAE@XZ ENDP				; MUHelper::~MUHelper
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@MUHelper@@QAEXXZ PROC				; MUHelper::Init
; _this$ = ecx

; 33   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 44	 sub	 esp, 68			; 00000044H
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 	ZeroMemory(this->StagePay, sizeof(this->StagePay));

  0005c	6a 14		 push	 20			; 00000014H
  0005e	6a 00		 push	 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	83 c0 04	 add	 eax, 4
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _memset
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : 	this->StageTime	= DEF_HELPER_STAGETIME;

  0006f	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	66 89 41 18	 mov	 WORD PTR [ecx+24], ax

; 36   : 	this->PayTime	= DEF_HELPER_PAYTIME;

  0007b	b8 05 00 00 00	 mov	 eax, 5
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	66 89 41 1a	 mov	 WORD PTR [ecx+26], ax

; 37   : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?Init@MUHelper@@QAEXXZ ENDP				; MUHelper::Init
_TEXT	ENDS
PUBLIC	??_C@_0BN@GMNJALND@?$FLMUHelper?$FN?5Data?5loaded?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?ReadData@MUHelper@@QAEXPAD@Z			; MUHelper::ReadData
EXTRN	_fclose:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BN@GMNJALND@?$FLMUHelper?$FN?5Data?5loaded?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@GMNJALND@?$FLMUHelper?$FN?5Data?5loaded?5?$CFd?5?$CFd?$AA@ DB '['
	DB	'MUHelper] Data loaded %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Type$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_File$ = 8						; size = 4
?ReadData@MUHelper@@QAEXPAD@Z PROC			; MUHelper::ReadData
; _this$ = ecx

; 41   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	int Token, Type = 0;

  0009c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Type$[ebp], 0

; 43   : 	this->Init();

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?Init@MUHelper@@QAEXXZ	; MUHelper::Init

; 44   : 	// ----
; 45   : 	SMDFile = fopen(File, "r");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000b0	8b 45 08	 mov	 eax, DWORD PTR _File$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _fopen
  000b9	83 c4 08	 add	 esp, 8
  000bc	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 46   : 	// ----
; 47   : 	if( SMDFile == 0 )

  000c1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  000c8	75 1e		 jne	 SHORT $LN11@ReadData

; 48   : 	{
; 49   : 		MsgBox(lMsg.Get(MSGGET(0, 112)), File);

  000ca	8b 45 08	 mov	 eax, DWORD PTR _File$[ebp]
  000cd	50		 push	 eax
  000ce	6a 70		 push	 112			; 00000070H
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000e0	83 c4 08	 add	 esp, 8

; 50   : 		return;

  000e3	e9 6a 01 00 00	 jmp	 $LN12@ReadData
$LN11@ReadData:

; 51   : 	}
; 52   : 	// ----
; 53   : 	while(true) 

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	0f 84 31 01 00
	00		 je	 $LN9@ReadData

; 54   : 	{
; 55   : 		Token = GetToken();

  000f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000fa	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 56   : 		// ----
; 57   : 		if( Token == END )

  000fd	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00101	75 05		 jne	 SHORT $LN8@ReadData

; 58   : 		{
; 59   : 			break;

  00103	e9 1e 01 00 00	 jmp	 $LN9@ReadData
$LN8@ReadData:

; 60   : 		}
; 61   : 		// ----
; 62   : 		Type = TokenNumber;

  00108	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0010e	e8 00 00 00 00	 call	 __ftol2_sse
  00113	89 45 f4	 mov	 DWORD PTR _Type$[ebp], eax
$LN7@ReadData:

; 63   : 		// ----
; 64   : 		while(true)

  00116	b8 01 00 00 00	 mov	 eax, 1
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 fe 00 00
	00		 je	 $LN6@ReadData

; 65   : 		{
; 66   : 			if( Type == 0 )	//-> Main

  00123	83 7d f4 00	 cmp	 DWORD PTR _Type$[ebp], 0
  00127	75 54		 jne	 SHORT $LN5@ReadData

; 67   : 			{
; 68   : 				Token = GetToken();

  00129	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0012e	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 69   : 				// ----
; 70   : 				if( !strcmp("end", TokenString) )

  00131	68 00 00 00 00	 push	 OFFSET _TokenString
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0013b	e8 00 00 00 00	 call	 _strcmp
  00140	83 c4 08	 add	 esp, 8
  00143	85 c0		 test	 eax, eax
  00145	75 05		 jne	 SHORT $LN4@ReadData

; 71   : 				{
; 72   : 					break;

  00147	e9 d5 00 00 00	 jmp	 $LN6@ReadData
$LN4@ReadData:

; 73   : 				}
; 74   : 				// ----
; 75   : 				this->StageTime	= TokenNumber;

  0014c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00152	e8 00 00 00 00	 call	 __ftol2_sse
  00157	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	66 89 41 18	 mov	 WORD PTR [ecx+24], ax

; 76   : 				Token = GetToken();

  0015e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00163	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 77   : 				this->PayTime	= TokenNumber;

  00166	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0016c	e8 00 00 00 00	 call	 __ftol2_sse
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	66 89 41 1a	 mov	 WORD PTR [ecx+26], ax
  00178	e9 9f 00 00 00	 jmp	 $LN2@ReadData
$LN5@ReadData:

; 78   : 			}
; 79   : 			else if( Type == 1 ) //-> Stage pay

  0017d	83 7d f4 01	 cmp	 DWORD PTR _Type$[ebp], 1
  00181	0f 85 95 00 00
	00		 jne	 $LN2@ReadData

; 80   : 			{
; 81   : 				Token = GetToken();

  00187	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0018c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 82   : 				// ----
; 83   : 				if( !strcmp("end", TokenString) )

  0018f	68 00 00 00 00	 push	 OFFSET _TokenString
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00199	e8 00 00 00 00	 call	 _strcmp
  0019e	83 c4 08	 add	 esp, 8
  001a1	85 c0		 test	 eax, eax
  001a3	75 02		 jne	 SHORT $LN1@ReadData

; 84   : 				{
; 85   : 					break;

  001a5	eb 7a		 jmp	 SHORT $LN6@ReadData
$LN1@ReadData:

; 86   : 				}
; 87   : 				// ----
; 88   : 				this->StagePay[0] = TokenNumber;

  001a7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ad	e8 00 00 00 00	 call	 __ftol2_sse
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 89   : 				Token = GetToken();

  001b8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001bd	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 90   : 				this->StagePay[1] = TokenNumber;

  001c0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001c6	e8 00 00 00 00	 call	 __ftol2_sse
  001cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ce	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 91   : 				Token = GetToken();

  001d1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001d6	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 92   : 				this->StagePay[2] = TokenNumber;

  001d9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001df	e8 00 00 00 00	 call	 __ftol2_sse
  001e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 93   : 				Token = GetToken();

  001ea	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001ef	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 94   : 				this->StagePay[3] = TokenNumber;

  001f2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f8	e8 00 00 00 00	 call	 __ftol2_sse
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 95   : 				Token = GetToken();

  00203	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00208	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 96   : 				this->StagePay[4] = TokenNumber;

  0020b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00211	e8 00 00 00 00	 call	 __ftol2_sse
  00216	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN2@ReadData:

; 97   : 			}
; 98   : 		}

  0021c	e9 f5 fe ff ff	 jmp	 $LN7@ReadData
$LN6@ReadData:

; 99   : 	}

  00221	e9 c2 fe ff ff	 jmp	 $LN11@ReadData
$LN9@ReadData:

; 100  : 	// ----
; 101  : 	LogAddTD("[MUHelper] Data loaded %d %d", this->StageTime, this->PayTime);

  00226	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00229	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  0022d	51		 push	 ecx
  0022e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00231	0f bf 42 18	 movsx	 eax, WORD PTR [edx+24]
  00235	50		 push	 eax
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GMNJALND@?$FLMUHelper?$FN?5Data?5loaded?5?$CFd?5?$CFd?$AA@
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00241	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  : 	fclose(SMDFile);

  00244	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 _fclose
  0024f	83 c4 04	 add	 esp, 4
$LN12@ReadData:

; 103  : }

  00252	5f		 pop	 edi
  00253	5e		 pop	 esi
  00254	5b		 pop	 ebx
  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c2 04 00	 ret	 4
?ReadData@MUHelper@@QAEXPAD@Z ENDP			; MUHelper::ReadData
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00260	55		 push	 ebp
  00261	8b ec		 mov	 ebp, esp
  00263	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00269	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0026e	33 c5		 xor	 eax, ebp
  00270	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00273	53		 push	 ebx
  00274	56		 push	 esi
  00275	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00276	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0027d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 _fgetc
  00288	83 c4 04	 add	 esp, 4
  0028b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0028e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00292	83 f9 ff	 cmp	 ecx, -1
  00295	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00297	b8 02 00 00 00	 mov	 eax, 2
  0029c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  002a1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  002a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002a7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  002aa	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  002ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 _fgetc
  002b7	83 c4 04	 add	 esp, 4
  002ba	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002bd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  002c1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  002c4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  002c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002ca	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002cd	74 1c		 je	 SHORT $LN23@GetToken
  002cf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002d3	83 f8 ff	 cmp	 eax, -1
  002d6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  002d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 _fgetc
  002e3	83 c4 04	 add	 esp, 4
  002e6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  002e9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  002eb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002ef	83 f8 ff	 cmp	 eax, -1
  002f2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  002f4	b8 02 00 00 00	 mov	 eax, 2
  002f9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  002fe	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 _isspace
  00308	83 c4 04	 add	 esp, 4
  0030b	85 c0		 test	 eax, eax
  0030d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00313	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00317	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0031d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00323	83 e9 22	 sub	 ecx, 34			; 00000022H
  00326	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0032c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00333	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00339	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0033f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00346	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0034d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0035c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00361	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00366	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00370	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00375	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0037a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0037f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00389	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0038e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00393	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00398	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  003a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  003a7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  003ac	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  003b1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  003bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  003c0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  003c5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  003ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003cf	50		 push	 eax
  003d0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003d4	51		 push	 ecx
  003d5	e8 00 00 00 00	 call	 _ungetc
  003da	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  003dd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  003e0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  003e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003e8	50		 push	 eax
  003e9	e8 00 00 00 00	 call	 _getc
  003ee	83 c4 04	 add	 esp, 4
  003f1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  003f4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003f8	83 f9 ff	 cmp	 ecx, -1
  003fb	74 36		 je	 SHORT $LN12@GetToken
  003fd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00401	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00404	74 1a		 je	 SHORT $LN11@GetToken
  00406	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0040a	50		 push	 eax
  0040b	e8 00 00 00 00	 call	 _isdigit
  00410	83 c4 04	 add	 esp, 4
  00413	85 c0		 test	 eax, eax
  00415	75 09		 jne	 SHORT $LN11@GetToken
  00417	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0041b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0041e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00420	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00423	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00426	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00428	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0042b	83 c0 01	 add	 eax, 1
  0042e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00431	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00433	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00436	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00439	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0043c	50		 push	 eax
  0043d	e8 00 00 00 00	 call	 _atof
  00442	83 c4 04	 add	 esp, 4
  00445	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0044b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00455	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0045a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0045f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00464	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0046b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00470	50		 push	 eax
  00471	e8 00 00 00 00	 call	 _getc
  00476	83 c4 04	 add	 esp, 4
  00479	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0047c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00480	83 f9 ff	 cmp	 ecx, -1
  00483	74 1c		 je	 SHORT $LN8@GetToken
  00485	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00489	83 f8 22	 cmp	 eax, 34			; 00000022H
  0048c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0048e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00491	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00494	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00496	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00499	83 c0 01	 add	 eax, 1
  0049c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0049f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  004a1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004a5	83 f8 22	 cmp	 eax, 34			; 00000022H
  004a8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  004aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004af	50		 push	 eax
  004b0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004b4	51		 push	 ecx
  004b5	e8 00 00 00 00	 call	 _ungetc
  004ba	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  004bd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  004c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  004cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004d2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  004d7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  004dc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004e0	50		 push	 eax
  004e1	e8 00 00 00 00	 call	 _isalpha
  004e6	83 c4 04	 add	 esp, 4
  004e9	85 c0		 test	 eax, eax
  004eb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  004f1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  004f8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004fb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  004fe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00500	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00503	83 c0 01	 add	 eax, 1
  00506	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00509	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0050e	50		 push	 eax
  0050f	e8 00 00 00 00	 call	 _getc
  00514	83 c4 04	 add	 esp, 4
  00517	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0051a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0051e	83 f9 ff	 cmp	 ecx, -1
  00521	74 36		 je	 SHORT $LN3@GetToken
  00523	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00527	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0052a	74 1a		 je	 SHORT $LN2@GetToken
  0052c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00530	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00533	74 11		 je	 SHORT $LN2@GetToken
  00535	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00539	50		 push	 eax
  0053a	e8 00 00 00 00	 call	 _isalnum
  0053f	83 c4 04	 add	 esp, 4
  00542	85 c0		 test	 eax, eax
  00544	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00546	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00549	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0054c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0054e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00551	83 c0 01	 add	 eax, 1
  00554	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00557	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00559	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0055e	50		 push	 eax
  0055f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00563	51		 push	 ecx
  00564	e8 00 00 00 00	 call	 _ungetc
  00569	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0056c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0056f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00572	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0057c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00581	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00583	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00585	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0058f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00594	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00596	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00598	5f		 pop	 edi
  00599	5e		 pop	 esi
  0059a	5b		 pop	 ebx
  0059b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0059e	33 cd		 xor	 ecx, ebp
  005a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a5	8b e5		 mov	 esp, ebp
  005a7	5d		 pop	 ebp
  005a8	c3		 ret	 0
  005a9	8d 49 00	 npad	 3
$LN35@GetToken:
  005ac	00 00 00 00	 DD	 $LN10@GetToken
  005b0	00 00 00 00	 DD	 $LN19@GetToken
  005b4	00 00 00 00	 DD	 $LN17@GetToken
  005b8	00 00 00 00	 DD	 $LN14@GetToken
  005bc	00 00 00 00	 DD	 $LN18@GetToken
  005c0	00 00 00 00	 DD	 $LN16@GetToken
  005c4	00 00 00 00	 DD	 $LN15@GetToken
  005c8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  005cc	00		 DB	 0
  005cd	01		 DB	 1
  005ce	07		 DB	 7
  005cf	07		 DB	 7
  005d0	07		 DB	 7
  005d1	07		 DB	 7
  005d2	07		 DB	 7
  005d3	07		 DB	 7
  005d4	07		 DB	 7
  005d5	07		 DB	 7
  005d6	02		 DB	 2
  005d7	03		 DB	 3
  005d8	03		 DB	 3
  005d9	07		 DB	 7
  005da	03		 DB	 3
  005db	03		 DB	 3
  005dc	03		 DB	 3
  005dd	03		 DB	 3
  005de	03		 DB	 3
  005df	03		 DB	 3
  005e0	03		 DB	 3
  005e1	03		 DB	 3
  005e2	03		 DB	 3
  005e3	03		 DB	 3
  005e4	07		 DB	 7
  005e5	04		 DB	 4
  005e6	07		 DB	 7
  005e7	07		 DB	 7
  005e8	07		 DB	 7
  005e9	07		 DB	 7
  005ea	07		 DB	 7
  005eb	07		 DB	 7
  005ec	07		 DB	 7
  005ed	07		 DB	 7
  005ee	07		 DB	 7
  005ef	07		 DB	 7
  005f0	07		 DB	 7
  005f1	07		 DB	 7
  005f2	07		 DB	 7
  005f3	07		 DB	 7
  005f4	07		 DB	 7
  005f5	07		 DB	 7
  005f6	07		 DB	 7
  005f7	07		 DB	 7
  005f8	07		 DB	 7
  005f9	07		 DB	 7
  005fa	07		 DB	 7
  005fb	07		 DB	 7
  005fc	07		 DB	 7
  005fd	07		 DB	 7
  005fe	07		 DB	 7
  005ff	07		 DB	 7
  00600	07		 DB	 7
  00601	07		 DB	 7
  00602	07		 DB	 7
  00603	07		 DB	 7
  00604	07		 DB	 7
  00605	07		 DB	 7
  00606	07		 DB	 7
  00607	07		 DB	 7
  00608	07		 DB	 7
  00609	07		 DB	 7
  0060a	07		 DB	 7
  0060b	07		 DB	 7
  0060c	07		 DB	 7
  0060d	07		 DB	 7
  0060e	07		 DB	 7
  0060f	07		 DB	 7
  00610	07		 DB	 7
  00611	07		 DB	 7
  00612	07		 DB	 7
  00613	07		 DB	 7
  00614	07		 DB	 7
  00615	07		 DB	 7
  00616	07		 DB	 7
  00617	07		 DB	 7
  00618	07		 DB	 7
  00619	07		 DB	 7
  0061a	07		 DB	 7
  0061b	07		 DB	 7
  0061c	07		 DB	 7
  0061d	07		 DB	 7
  0061e	07		 DB	 7
  0061f	07		 DB	 7
  00620	07		 DB	 7
  00621	07		 DB	 7
  00622	07		 DB	 7
  00623	07		 DB	 7
  00624	07		 DB	 7
  00625	05		 DB	 5
  00626	07		 DB	 7
  00627	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_C@_0N@LECHJCFG@MUHelper?4dat?$AA@		; `string'
PUBLIC	?Load@MUHelper@@QAEXXZ				; MUHelper::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0N@LECHJCFG@MUHelper?4dat?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\muhelper.cpp
CONST	SEGMENT
??_C@_0N@LECHJCFG@MUHelper?4dat?$AA@ DB 'MUHelper.dat', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@MUHelper@@QAEXXZ PROC				; MUHelper::Load
; _this$ = ecx

; 107  : {

  00630	55		 push	 ebp
  00631	8b ec		 mov	 ebp, esp
  00633	83 ec 44	 sub	 esp, 68			; 00000044H
  00636	53		 push	 ebx
  00637	56		 push	 esi
  00638	57		 push	 edi
  00639	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 108  : 	this->ReadData(gDirPath.GetNewPath("MUHelper.dat"));

  0063c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LECHJCFG@MUHelper?4dat?$AA@
  00641	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00646	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0064b	50		 push	 eax
  0064c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0064f	e8 00 00 00 00	 call	 ?ReadData@MUHelper@@QAEXPAD@Z ; MUHelper::ReadData

; 109  : }

  00654	5f		 pop	 edi
  00655	5e		 pop	 esi
  00656	5b		 pop	 ebx
  00657	8b e5		 mov	 esp, ebp
  00659	5d		 pop	 ebp
  0065a	c3		 ret	 0
?Load@MUHelper@@QAEXXZ ENDP				; MUHelper::Load
_TEXT	ENDS
PUBLIC	?Close@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z	; MUHelper::Close
PUBLIC	?Start@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z	; MUHelper::Start
PUBLIC	?Manager@MUHelper@@QAEXHPAUMUHELPER_REQ_ACTION@@@Z ; MUHelper::Manager
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv73 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
_lpRequest$ = 12					; size = 4
?Manager@MUHelper@@QAEXHPAUMUHELPER_REQ_ACTION@@@Z PROC	; MUHelper::Manager
; _this$ = ecx

; 113  : {

  00660	55		 push	 ebp
  00661	8b ec		 mov	 ebp, esp
  00663	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00666	53		 push	 ebx
  00667	56		 push	 esi
  00668	57		 push	 edi
  00669	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 114  : 	LPOBJ lpUser = &gObj[UserIndex];

  0066c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0066f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00675	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0067b	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 115  : 	// ----
; 116  : 	if( !gObjIsConnected(UserIndex) || lpUser->Connected != PLAYER_PLAYING )

  0067e	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00681	50		 push	 eax
  00682	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00687	83 c4 04	 add	 esp, 4
  0068a	85 c0		 test	 eax, eax
  0068c	74 09		 je	 SHORT $LN5@Manager
  0068e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00691	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00695	74 02		 je	 SHORT $LN6@Manager
$LN5@Manager:

; 117  : 	{
; 118  : 		return;

  00697	eb 31		 jmp	 SHORT $LN7@Manager
$LN6@Manager:

; 119  : 	}
; 120  : 	// ----
; 121  : 	switch(lpRequest->Mode)

  00699	8b 45 0c	 mov	 eax, DWORD PTR _lpRequest$[ebp]
  0069c	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0069f	88 4d b4	 mov	 BYTE PTR tv73[ebp], cl
  006a2	80 7d b4 00	 cmp	 BYTE PTR tv73[ebp], 0
  006a6	74 08		 je	 SHORT $LN2@Manager
  006a8	80 7d b4 01	 cmp	 BYTE PTR tv73[ebp], 1
  006ac	74 10		 je	 SHORT $LN1@Manager
  006ae	eb 1a		 jmp	 SHORT $LN7@Manager
$LN2@Manager:

; 122  : 	{
; 123  : 	case 0:
; 124  : 		{
; 125  : 			this->Start(lpUser);

  006b0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  006b3	50		 push	 eax
  006b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006b7	e8 00 00 00 00	 call	 ?Start@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z ; MUHelper::Start

; 126  : 		}
; 127  : 		break;

  006bc	eb 0c		 jmp	 SHORT $LN7@Manager
$LN1@Manager:

; 128  : 		// --
; 129  : 	case 1:
; 130  : 		{
; 131  : 			this->Close(lpUser);

  006be	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  006c1	50		 push	 eax
  006c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c5	e8 00 00 00 00	 call	 ?Close@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z ; MUHelper::Close
$LN7@Manager:

; 132  : 		}
; 133  : 		break;
; 134  : 	}
; 135  : }

  006ca	5f		 pop	 edi
  006cb	5e		 pop	 esi
  006cc	5b		 pop	 ebx
  006cd	8b e5		 mov	 esp, ebp
  006cf	5d		 pop	 ebp
  006d0	c2 08 00	 ret	 8
?Manager@MUHelper@@QAEXHPAUMUHELPER_REQ_ACTION@@@Z ENDP	; MUHelper::Manager
_TEXT	ENDS
PUBLIC	??_C@_0CG@NKJDGCHK@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5st@ ; `string'
PUBLIC	?CheckMoney@MUHelper@@QAE_NPAUOBJECTSTRUCT@@@Z	; MUHelper::CheckMoney
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
;	COMDAT ??_C@_0CG@NKJDGCHK@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5st@
CONST	SEGMENT
??_C@_0CG@NKJDGCHK@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5st@ DB '['
	DB	'MUHelper] [%s] [%s] has been started', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pAnswer$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
?Start@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z PROC		; MUHelper::Start
; _this$ = ecx

; 139  : {

  006e0	55		 push	 ebp
  006e1	8b ec		 mov	 ebp, esp
  006e3	83 ec 58	 sub	 esp, 88			; 00000058H
  006e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  006eb	33 c5		 xor	 eax, ebp
  006ed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  006f0	53		 push	 ebx
  006f1	56		 push	 esi
  006f2	57		 push	 edi
  006f3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	if( !gObjIsConnected(lpUser) || lpUser->Connected != PLAYER_PLAYING || !this->CheckMoney(lpUser) )

  006f6	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  006f9	50		 push	 eax
  006fa	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  006ff	83 c4 04	 add	 esp, 4
  00702	85 c0		 test	 eax, eax
  00704	74 1c		 je	 SHORT $LN1@Start
  00706	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00709	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0070d	75 13		 jne	 SHORT $LN1@Start
  0070f	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00712	50		 push	 eax
  00713	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00716	e8 00 00 00 00	 call	 ?CheckMoney@MUHelper@@QAE_NPAUOBJECTSTRUCT@@@Z ; MUHelper::CheckMoney
  0071b	0f b6 c8	 movzx	 ecx, al
  0071e	85 c9		 test	 ecx, ecx
  00720	75 05		 jne	 SHORT $LN2@Start
$LN1@Start:

; 141  : 	{
; 142  : 		return;

  00722	e9 8f 00 00 00	 jmp	 $LN3@Start
$LN2@Start:

; 143  : 	}
; 144  : 	// ----
; 145  : 	MUHELPER_ANS_DATA pAnswer = { 0 };

  00727	c6 45 e8 00	 mov	 BYTE PTR _pAnswer$[ebp], 0
  0072b	33 c0		 xor	 eax, eax
  0072d	89 45 e9	 mov	 DWORD PTR _pAnswer$[ebp+1], eax
  00730	89 45 ed	 mov	 DWORD PTR _pAnswer$[ebp+5], eax
  00733	89 45 f1	 mov	 DWORD PTR _pAnswer$[ebp+9], eax
  00736	66 89 45 f5	 mov	 WORD PTR _pAnswer$[ebp+13], ax
  0073a	88 45 f7	 mov	 BYTE PTR _pAnswer$[ebp+15], al

; 146  : 	PHeadSubSetB((LPBYTE)&pAnswer, 0xBF, 0x51, sizeof(pAnswer));

  0073d	6a 10		 push	 16			; 00000010H
  0073f	6a 51		 push	 81			; 00000051H
  00741	68 bf 00 00 00	 push	 191			; 000000bfH
  00746	8d 45 e8	 lea	 eax, DWORD PTR _pAnswer$[ebp]
  00749	50		 push	 eax
  0074a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0074f	83 c4 10	 add	 esp, 16			; 00000010H

; 147  : 	// ----
; 148  : 	pAnswer.Mode = 0;

  00752	c6 45 f4 00	 mov	 BYTE PTR _pAnswer$[ebp+12], 0

; 149  : 	// ----
; 150  : 	lpUser->m_MUHelperOn		= true;

  00756	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00759	c6 80 a3 27 00
	00 01		 mov	 BYTE PTR [eax+10147], 1

; 151  : 	lpUser->m_MUHelperReadyPay	= false;

  00760	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00763	c6 80 a4 27 00
	00 00		 mov	 BYTE PTR [eax+10148], 0

; 152  : 	lpUser->m_MUHelperStage		= 1;

  0076a	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0076d	c6 80 a5 27 00
	00 01		 mov	 BYTE PTR [eax+10149], 1

; 153  : 	lpUser->m_MUHelperTick		= GetTickCount();

  00774	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0077a	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0077d	89 81 a8 27 00
	00		 mov	 DWORD PTR [ecx+10152], eax

; 154  : 	// ----
; 155  : 	DataSend(lpUser->m_Index, (LPBYTE)&pAnswer, pAnswer.h.size);

  00783	0f b6 45 e9	 movzx	 eax, BYTE PTR _pAnswer$[ebp+1]
  00787	50		 push	 eax
  00788	8d 4d e8	 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  0078b	51		 push	 ecx
  0078c	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0078f	8b 02		 mov	 eax, DWORD PTR [edx]
  00791	50		 push	 eax
  00792	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00797	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 	LogAddTD("[MUHelper] [%s] [%s] has been started", lpUser->AccountID, lpUser->Name);

  0079a	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0079d	83 c0 77	 add	 eax, 119		; 00000077H
  007a0	50		 push	 eax
  007a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  007a4	83 c1 6c	 add	 ecx, 108		; 0000006cH
  007a7	51		 push	 ecx
  007a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NKJDGCHK@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5st@
  007ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Start:

; 157  : }

  007b6	5f		 pop	 edi
  007b7	5e		 pop	 esi
  007b8	5b		 pop	 ebx
  007b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007bc	33 cd		 xor	 ecx, ebp
  007be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007c3	8b e5		 mov	 esp, ebp
  007c5	5d		 pop	 ebp
  007c6	c2 04 00	 ret	 4
?Start@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z ENDP		; MUHelper::Start
_TEXT	ENDS
PUBLIC	?SendMoney@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z	; MUHelper::SendMoney
PUBLIC	?SetStage@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z	; MUHelper::SetStage
PUBLIC	__$ArrayPad$
PUBLIC	?Work@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z		; MUHelper::Work
EXTRN	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagicSearch
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	?ExUserInSafeZone@@YA_NH@Z:PROC			; ExUserInSafeZone
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv168 = -132						; size = 4
_j$228821 = -64						; size = 4
_lpPartyObj$228819 = -60				; size = 4
_number$228818 = -56					; size = 4
_partycount$228817 = -52				; size = 4
_partynum$228816 = -48					; size = 4
_time$ = -44						; size = 16
_lpMagic$ = -28						; size = 4
_SearchSkill$ = -24					; size = 4
_dis$ = -20						; size = 4
_WorkTime$ = -16					; size = 4
_CurrentTick$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
?Work@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z PROC		; MUHelper::Work
; _this$ = ecx

; 161  : {

  007d0	55		 push	 ebp
  007d1	8b ec		 mov	 ebp, esp
  007d3	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  007d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  007de	33 c5		 xor	 eax, ebp
  007e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  007e3	53		 push	 ebx
  007e4	56		 push	 esi
  007e5	57		 push	 edi
  007e6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	if( !lpUser->m_MUHelperOn )

  007e9	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  007ec	0f b6 88 a3 27
	00 00		 movzx	 ecx, BYTE PTR [eax+10147]
  007f3	85 c9		 test	 ecx, ecx
  007f5	75 05		 jne	 SHORT $LN40@Work

; 163  : 	{
; 164  : 		return;

  007f7	e9 3d 04 00 00	 jmp	 $LN41@Work
$LN40@Work:

; 165  : 	}
; 166  : 	// ----
; 167  : 	DWORD CurrentTick	= GetTickCount();

  007fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00802	89 45 f4	 mov	 DWORD PTR _CurrentTick$[ebp], eax

; 168  : 	DWORD WorkTime		= (CurrentTick - lpUser->m_MUHelperTick) / 60000;

  00805	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00808	8b 4d f4	 mov	 ecx, DWORD PTR _CurrentTick$[ebp]
  0080b	2b 88 a8 27 00
	00		 sub	 ecx, DWORD PTR [eax+10152]
  00811	8b c1		 mov	 eax, ecx
  00813	33 d2		 xor	 edx, edx
  00815	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0081a	f7 f1		 div	 ecx
  0081c	89 45 f0	 mov	 DWORD PTR _WorkTime$[ebp], eax

; 169  : 	// ----
; 170  : 	if( WorkTime > this->StageTime * MAX_HELPER_STAGE || !this->CheckMoney(lpUser) )

  0081f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00822	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00826	6b c9 05	 imul	 ecx, 5
  00829	39 4d f0	 cmp	 DWORD PTR _WorkTime$[ebp], ecx
  0082c	77 13		 ja	 SHORT $LN38@Work
  0082e	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00831	50		 push	 eax
  00832	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00835	e8 00 00 00 00	 call	 ?CheckMoney@MUHelper@@QAE_NPAUOBJECTSTRUCT@@@Z ; MUHelper::CheckMoney
  0083a	0f b6 c8	 movzx	 ecx, al
  0083d	85 c9		 test	 ecx, ecx
  0083f	75 11		 jne	 SHORT $LN39@Work
$LN38@Work:

; 171  : 	{
; 172  : 		this->Close(lpUser);

  00841	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00844	50		 push	 eax
  00845	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00848	e8 00 00 00 00	 call	 ?Close@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z ; MUHelper::Close

; 173  : 		return;

  0084d	e9 e7 03 00 00	 jmp	 $LN41@Work
$LN39@Work:

; 174  : 	}
; 175  : 	// ----
; 176  : 	this->SetStage(lpUser, WorkTime);

  00852	0f b7 45 f0	 movzx	 eax, WORD PTR _WorkTime$[ebp]
  00856	50		 push	 eax
  00857	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0085a	51		 push	 ecx
  0085b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0085e	e8 00 00 00 00	 call	 ?SetStage@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z ; MUHelper::SetStage

; 177  : 	// ----
; 178  : 	if( WorkTime > 0 && WorkTime % this->PayTime == this->PayTime - 1 )

  00863	83 7d f0 00	 cmp	 DWORD PTR _WorkTime$[ebp], 0
  00867	76 26		 jbe	 SHORT $LN37@Work
  00869	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0086c	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00870	8b 45 f0	 mov	 eax, DWORD PTR _WorkTime$[ebp]
  00873	33 d2		 xor	 edx, edx
  00875	f7 f1		 div	 ecx
  00877	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0087a	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  0087e	83 e9 01	 sub	 ecx, 1
  00881	3b d1		 cmp	 edx, ecx
  00883	75 0a		 jne	 SHORT $LN37@Work

; 179  : 	{
; 180  : 		lpUser->m_MUHelperReadyPay = true;

  00885	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00888	c6 80 a4 27 00
	00 01		 mov	 BYTE PTR [eax+10148], 1
$LN37@Work:

; 181  : 	}
; 182  : 	// ----
; 183  : 	if( WorkTime > 0 && WorkTime % this->PayTime == 0 && lpUser->m_MUHelperReadyPay )

  0088f	83 7d f0 00	 cmp	 DWORD PTR _WorkTime$[ebp], 0
  00893	76 31		 jbe	 SHORT $LN36@Work
  00895	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00898	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  0089c	8b 45 f0	 mov	 eax, DWORD PTR _WorkTime$[ebp]
  0089f	33 d2		 xor	 edx, edx
  008a1	f7 f1		 div	 ecx
  008a3	85 d2		 test	 edx, edx
  008a5	75 1f		 jne	 SHORT $LN36@Work
  008a7	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  008aa	0f b6 88 a4 27
	00 00		 movzx	 ecx, BYTE PTR [eax+10148]
  008b1	85 c9		 test	 ecx, ecx
  008b3	74 11		 je	 SHORT $LN36@Work

; 184  : 	{
; 185  : 		this->SendMoney(lpUser, WorkTime);

  008b5	0f b7 45 f0	 movzx	 eax, WORD PTR _WorkTime$[ebp]
  008b9	50		 push	 eax
  008ba	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  008bd	51		 push	 ecx
  008be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008c1	e8 00 00 00 00	 call	 ?SendMoney@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z ; MUHelper::SendMoney
$LN36@Work:

; 186  : 	}
; 187  : 
; 188  : #if(FIX_HELPER_EE_BUFF==TRUE)
; 189  : 	if(ExUserInSafeZone(lpUser->m_Index))

  008c6	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  008c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  008cb	51		 push	 ecx
  008cc	e8 00 00 00 00	 call	 ?ExUserInSafeZone@@YA_NH@Z ; ExUserInSafeZone
  008d1	83 c4 04	 add	 esp, 4
  008d4	0f b6 d0	 movzx	 edx, al
  008d7	85 d2		 test	 edx, edx
  008d9	74 05		 je	 SHORT $LN35@Work

; 190  : 	{
; 191  : 		return;

  008db	e9 59 03 00 00	 jmp	 $LN41@Work
$LN35@Work:

; 192  : 	}
; 193  : 
; 194  : 	int dis;
; 195  : 	int SearchSkill = 0;

  008e0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0

; 196  : 	CMagicInf * lpMagic;
; 197  : 	SYSTEMTIME time;
; 198  : 	GetLocalTime(&time);

  008e7	8d 45 d4	 lea	 eax, DWORD PTR _time$[ebp]
  008ea	50		 push	 eax
  008eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 199  : 	if( time.wSecond == 0  || 
; 200  : 	    time.wSecond == 10 ||
; 201  : 	    time.wSecond == 20 ||
; 202  : 	    time.wSecond == 30 ||
; 203  : 	    time.wSecond == 40 ||
; 204  : 	    time.wSecond == 50 )

  008f1	0f b7 45 e0	 movzx	 eax, WORD PTR _time$[ebp+12]
  008f5	85 c0		 test	 eax, eax
  008f7	74 31		 je	 SHORT $LN33@Work
  008f9	0f b7 45 e0	 movzx	 eax, WORD PTR _time$[ebp+12]
  008fd	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00900	74 28		 je	 SHORT $LN33@Work
  00902	0f b7 45 e0	 movzx	 eax, WORD PTR _time$[ebp+12]
  00906	83 f8 14	 cmp	 eax, 20			; 00000014H
  00909	74 1f		 je	 SHORT $LN33@Work
  0090b	0f b7 45 e0	 movzx	 eax, WORD PTR _time$[ebp+12]
  0090f	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00912	74 16		 je	 SHORT $LN33@Work
  00914	0f b7 45 e0	 movzx	 eax, WORD PTR _time$[ebp+12]
  00918	83 f8 28	 cmp	 eax, 40			; 00000028H
  0091b	74 0d		 je	 SHORT $LN33@Work
  0091d	0f b7 45 e0	 movzx	 eax, WORD PTR _time$[ebp+12]
  00921	83 f8 32	 cmp	 eax, 50			; 00000032H
  00924	0f 85 0f 03 00
	00		 jne	 $LN41@Work
$LN33@Work:

; 205  : 	{
; 206  : 		int partynum = -1;

  0092a	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR _partynum$228816[ebp], -1

; 207  : 		int partycount;
; 208  : 		int number;
; 209  : 
; 210  : 		LPOBJ lpPartyObj;
; 211  : 
; 212  : 		partynum = lpUser->PartyNumber;

  00931	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00934	8b 88 2c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1068]
  0093a	89 4d d0	 mov	 DWORD PTR _partynum$228816[ebp], ecx

; 213  : 
; 214  : 		if(partynum != -1)

  0093d	83 7d d0 ff	 cmp	 DWORD PTR _partynum$228816[ebp], -1
  00941	0f 84 e1 01 00
	00		 je	 $LN32@Work

; 215  : 		{
; 216  : 			partycount = gParty.m_PartyS[partynum].Count;

  00947	8b 45 d0	 mov	 eax, DWORD PTR _partynum$228816[ebp]
  0094a	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0094d	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+8]
  00953	89 4d cc	 mov	 DWORD PTR _partycount$228817[ebp], ecx

; 217  : 
; 218  : 			for(int j = 0; j < MAX_USER_IN_PARTY; j++)

  00956	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _j$228821[ebp], 0
  0095d	eb 09		 jmp	 SHORT $LN31@Work
$LN30@Work:
  0095f	8b 45 c0	 mov	 eax, DWORD PTR _j$228821[ebp]
  00962	83 c0 01	 add	 eax, 1
  00965	89 45 c0	 mov	 DWORD PTR _j$228821[ebp], eax
$LN31@Work:
  00968	83 7d c0 0a	 cmp	 DWORD PTR _j$228821[ebp], 10 ; 0000000aH
  0096c	0f 8d b1 01 00
	00		 jge	 $LN29@Work

; 219  : 			{
; 220  : 				number = gParty.m_PartyS[partynum].Number[j];

  00972	8b 45 d0	 mov	 eax, DWORD PTR _partynum$228816[ebp]
  00975	6b c0 6c	 imul	 eax, 108		; 0000006cH
  00978	8b 4d c0	 mov	 ecx, DWORD PTR _j$228821[ebp]
  0097b	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  00982	89 55 c8	 mov	 DWORD PTR _number$228818[ebp], edx

; 221  : 
; 222  : 				if ( OBJMAX_RANGE(number) == TRUE )

  00985	83 7d c8 00	 cmp	 DWORD PTR _number$228818[ebp], 0
  00989	7d 0c		 jge	 SHORT $LN43@Work
  0098b	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv168[ebp], 0
  00995	eb 12		 jmp	 SHORT $LN44@Work
$LN43@Work:
  00997	33 c0		 xor	 eax, eax
  00999	81 7d c8 97 3a
	00 00		 cmp	 DWORD PTR _number$228818[ebp], 14999 ; 00003a97H
  009a0	0f 9e c0	 setle	 al
  009a3	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
$LN44@Work:
  009a9	83 bd 7c ff ff
	ff 01		 cmp	 DWORD PTR tv168[ebp], 1
  009b0	0f 85 68 01 00
	00		 jne	 $LN28@Work

; 223  : 				{
; 224  : 					lpPartyObj = &gObj[number];

  009b6	8b 45 c8	 mov	 eax, DWORD PTR _number$228818[ebp]
  009b9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  009bf	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009c5	89 45 c4	 mov	 DWORD PTR _lpPartyObj$228819[ebp], eax

; 225  : 
; 226  : 					if(lpUser->MapNumber == lpPartyObj->MapNumber)

  009c8	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  009cb	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  009d2	8b 55 c4	 mov	 edx, DWORD PTR _lpPartyObj$228819[ebp]
  009d5	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  009dc	3b c8		 cmp	 ecx, eax
  009de	0f 85 3a 01 00
	00		 jne	 $LN28@Work

; 227  : 					{
; 228  : 						dis = gObjCalDistance(lpUser,&gObj[number]);

  009e4	8b 45 c8	 mov	 eax, DWORD PTR _number$228818[ebp]
  009e7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  009ed	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009f3	50		 push	 eax
  009f4	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  009f7	51		 push	 ecx
  009f8	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  009fd	83 c4 08	 add	 esp, 8
  00a00	89 45 ec	 mov	 DWORD PTR _dis$[ebp], eax

; 229  : 
; 230  : 						if(dis < 6)

  00a03	83 7d ec 06	 cmp	 DWORD PTR _dis$[ebp], 6
  00a07	0f 8d 11 01 00
	00		 jge	 $LN28@Work

; 231  : 						{
; 232  : 							//Defence Baf
; 233  : 							if(gObjGetMagicSearch( lpUser, 27) != NULL) SearchSkill = 27;

  00a0d	6a 1b		 push	 27			; 0000001bH
  00a0f	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00a12	50		 push	 eax
  00a13	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00a18	83 c4 08	 add	 esp, 8
  00a1b	85 c0		 test	 eax, eax
  00a1d	74 09		 je	 SHORT $LN25@Work
  00a1f	c7 45 e8 1b 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 27 ; 0000001bH
  00a26	eb 07		 jmp	 SHORT $LN24@Work
$LN25@Work:

; 234  : 							//else if(gObjGetMagicSearch( lpUser, 480) != NULL) SearchSkill = 480;
; 235  : 							//else if(gObjGetMagicSearch( lpUser, 481) != NULL) SearchSkill = 481;
; 236  : 							//else if(gObjGetMagicSearch( lpUser, 482) != NULL) SearchSkill = 482;
; 237  : 							//else if(gObjGetMagicSearch( lpUser, 483) != NULL) SearchSkill = 483;
; 238  : 							//else if(gObjGetMagicSearch( lpUser, 484) != NULL) SearchSkill = 484;
; 239  : 							else SearchSkill = 0;

  00a28	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0
$LN24@Work:

; 240  : 							if(SearchSkill != 0)

  00a2f	83 7d e8 00	 cmp	 DWORD PTR _SearchSkill$[ebp], 0
  00a33	74 33		 je	 SHORT $LN23@Work

; 241  : 							{
; 242  : 								lpMagic = gObjGetMagicSearch( lpUser, SearchSkill);

  00a35	8b 45 e8	 mov	 eax, DWORD PTR _SearchSkill$[ebp]
  00a38	50		 push	 eax
  00a39	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00a3c	51		 push	 ecx
  00a3d	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00a42	83 c4 08	 add	 esp, 8
  00a45	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 243  : 								if(lpMagic!=NULL) gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  00a48	83 7d e4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00a4c	74 1a		 je	 SHORT $LN23@Work
  00a4e	8b 45 e4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00a51	50		 push	 eax
  00a52	8b 4d c4	 mov	 ecx, DWORD PTR _lpPartyObj$228819[ebp]
  00a55	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a57	52		 push	 edx
  00a58	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00a5b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a5d	51		 push	 ecx
  00a5e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00a63	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN23@Work:

; 244  : 							}
; 245  : 							//Damage Baf
; 246  : 							if(gObjGetMagicSearch( lpUser, 28) != NULL) SearchSkill = 28;

  00a68	6a 1c		 push	 28			; 0000001cH
  00a6a	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00a6d	50		 push	 eax
  00a6e	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00a73	83 c4 08	 add	 esp, 8
  00a76	85 c0		 test	 eax, eax
  00a78	74 09		 je	 SHORT $LN21@Work
  00a7a	c7 45 e8 1c 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 28 ; 0000001cH
  00a81	eb 07		 jmp	 SHORT $LN20@Work
$LN21@Work:

; 247  : 							//else if(gObjGetMagicSearch( lpUser, 485) != NULL) SearchSkill = 485;
; 248  : 							//else if(gObjGetMagicSearch( lpUser, 486) != NULL) SearchSkill = 486;
; 249  : 							//else if(gObjGetMagicSearch( lpUser, 487) != NULL) SearchSkill = 487;
; 250  : 							//else if(gObjGetMagicSearch( lpUser, 488) != NULL) SearchSkill = 488;
; 251  : 							//else if(gObjGetMagicSearch( lpUser, 489) != NULL) SearchSkill = 489;
; 252  : 							else SearchSkill = 0;

  00a83	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0
$LN20@Work:

; 253  : 							if(SearchSkill != 0)

  00a8a	83 7d e8 00	 cmp	 DWORD PTR _SearchSkill$[ebp], 0
  00a8e	74 33		 je	 SHORT $LN19@Work

; 254  : 							{
; 255  : 								lpMagic = gObjGetMagicSearch( lpUser, SearchSkill);

  00a90	8b 45 e8	 mov	 eax, DWORD PTR _SearchSkill$[ebp]
  00a93	50		 push	 eax
  00a94	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00a97	51		 push	 ecx
  00a98	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00a9d	83 c4 08	 add	 esp, 8
  00aa0	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 256  : 								if(lpMagic!=NULL) gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  00aa3	83 7d e4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00aa7	74 1a		 je	 SHORT $LN19@Work
  00aa9	8b 45 e4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00aac	50		 push	 eax
  00aad	8b 4d c4	 mov	 ecx, DWORD PTR _lpPartyObj$228819[ebp]
  00ab0	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ab2	52		 push	 edx
  00ab3	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ab6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ab8	51		 push	 ecx
  00ab9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00abe	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN19@Work:

; 257  : 							}
; 258  : 							//Heal Baf
; 259  : 							if(gObjGetMagicSearch( lpUser, 26) != NULL) SearchSkill = 26;

  00ac3	6a 1a		 push	 26			; 0000001aH
  00ac5	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ac8	50		 push	 eax
  00ac9	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00ace	83 c4 08	 add	 esp, 8
  00ad1	85 c0		 test	 eax, eax
  00ad3	74 09		 je	 SHORT $LN17@Work
  00ad5	c7 45 e8 1a 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 26 ; 0000001aH
  00adc	eb 07		 jmp	 SHORT $LN16@Work
$LN17@Work:

; 260  : 							//else if(gObjGetMagicSearch( lpUser, 475) != NULL) SearchSkill = 475;
; 261  : 							//else if(gObjGetMagicSearch( lpUser, 476) != NULL) SearchSkill = 476;
; 262  : 							//else if(gObjGetMagicSearch( lpUser, 477) != NULL) SearchSkill = 477;
; 263  : 							//else if(gObjGetMagicSearch( lpUser, 478) != NULL) SearchSkill = 478;
; 264  : 							//else if(gObjGetMagicSearch( lpUser, 479) != NULL) SearchSkill = 479;
; 265  : 							else SearchSkill = 0;

  00ade	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0
$LN16@Work:

; 266  : 							if(SearchSkill != 0)

  00ae5	83 7d e8 00	 cmp	 DWORD PTR _SearchSkill$[ebp], 0
  00ae9	74 33		 je	 SHORT $LN28@Work

; 267  : 							{
; 268  : 								lpMagic = gObjGetMagicSearch( lpUser, SearchSkill);

  00aeb	8b 45 e8	 mov	 eax, DWORD PTR _SearchSkill$[ebp]
  00aee	50		 push	 eax
  00aef	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00af2	51		 push	 ecx
  00af3	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00af8	83 c4 08	 add	 esp, 8
  00afb	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 269  : 								if(lpMagic!=NULL) gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  00afe	83 7d e4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00b02	74 1a		 je	 SHORT $LN28@Work
  00b04	8b 45 e4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00b07	50		 push	 eax
  00b08	8b 4d c4	 mov	 ecx, DWORD PTR _lpPartyObj$228819[ebp]
  00b0b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b0d	52		 push	 edx
  00b0e	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00b11	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b13	51		 push	 ecx
  00b14	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00b19	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN28@Work:

; 270  : 							}
; 271  : 						}
; 272  : 					}
; 273  : 				}
; 274  : 			}

  00b1e	e9 3c fe ff ff	 jmp	 $LN30@Work
$LN29@Work:

; 275  : 		}
; 276  : 		else

  00b23	e9 11 01 00 00	 jmp	 $LN41@Work
$LN32@Work:

; 277  : 		{
; 278  : 			//Defence Baf
; 279  : 			if(gObjGetMagicSearch( lpUser, 27) != NULL) SearchSkill = 27;

  00b28	6a 1b		 push	 27			; 0000001bH
  00b2a	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00b2d	50		 push	 eax
  00b2e	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00b33	83 c4 08	 add	 esp, 8
  00b36	85 c0		 test	 eax, eax
  00b38	74 09		 je	 SHORT $LN12@Work
  00b3a	c7 45 e8 1b 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 27 ; 0000001bH
  00b41	eb 07		 jmp	 SHORT $LN11@Work
$LN12@Work:

; 280  : 			//else if(gObjGetMagicSearch( lpUser, 480) != NULL) SearchSkill = 480;
; 281  : 			//else if(gObjGetMagicSearch( lpUser, 481) != NULL) SearchSkill = 481;
; 282  : 			//else if(gObjGetMagicSearch( lpUser, 482) != NULL) SearchSkill = 482;
; 283  : 			//else if(gObjGetMagicSearch( lpUser, 483) != NULL) SearchSkill = 483;
; 284  : 			//else if(gObjGetMagicSearch( lpUser, 484) != NULL) SearchSkill = 484;
; 285  : 			else SearchSkill = 0;

  00b43	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0
$LN11@Work:

; 286  : 			if(SearchSkill != 0)

  00b4a	83 7d e8 00	 cmp	 DWORD PTR _SearchSkill$[ebp], 0
  00b4e	74 33		 je	 SHORT $LN10@Work

; 287  : 			{
; 288  : 				lpMagic = gObjGetMagicSearch( lpUser, SearchSkill);

  00b50	8b 45 e8	 mov	 eax, DWORD PTR _SearchSkill$[ebp]
  00b53	50		 push	 eax
  00b54	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00b57	51		 push	 ecx
  00b58	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00b5d	83 c4 08	 add	 esp, 8
  00b60	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 289  : 				if(lpMagic!=NULL) gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00b63	83 7d e4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00b67	74 1a		 je	 SHORT $LN10@Work
  00b69	8b 45 e4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00b6c	50		 push	 eax
  00b6d	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00b70	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b72	52		 push	 edx
  00b73	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00b76	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b78	51		 push	 ecx
  00b79	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00b7e	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN10@Work:

; 290  : 			}
; 291  : 			//Damage Baf
; 292  : 			if(gObjGetMagicSearch( lpUser, 28) != NULL) SearchSkill = 28;

  00b83	6a 1c		 push	 28			; 0000001cH
  00b85	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00b88	50		 push	 eax
  00b89	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00b8e	83 c4 08	 add	 esp, 8
  00b91	85 c0		 test	 eax, eax
  00b93	74 09		 je	 SHORT $LN8@Work
  00b95	c7 45 e8 1c 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 28 ; 0000001cH
  00b9c	eb 07		 jmp	 SHORT $LN7@Work
$LN8@Work:

; 293  : 			//else if(gObjGetMagicSearch( lpUser, 485) != NULL) SearchSkill = 485;
; 294  : 			//else if(gObjGetMagicSearch( lpUser, 486) != NULL) SearchSkill = 486;
; 295  : 			//else if(gObjGetMagicSearch( lpUser, 487) != NULL) SearchSkill = 487;
; 296  : 			//else if(gObjGetMagicSearch( lpUser, 488) != NULL) SearchSkill = 488;
; 297  : 			//else if(gObjGetMagicSearch( lpUser, 489) != NULL) SearchSkill = 489;
; 298  : 			else SearchSkill = 0;

  00b9e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0
$LN7@Work:

; 299  : 			if(SearchSkill != 0)

  00ba5	83 7d e8 00	 cmp	 DWORD PTR _SearchSkill$[ebp], 0
  00ba9	74 33		 je	 SHORT $LN6@Work

; 300  : 			{
; 301  : 				lpMagic = gObjGetMagicSearch( lpUser, SearchSkill);

  00bab	8b 45 e8	 mov	 eax, DWORD PTR _SearchSkill$[ebp]
  00bae	50		 push	 eax
  00baf	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00bb2	51		 push	 ecx
  00bb3	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00bb8	83 c4 08	 add	 esp, 8
  00bbb	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 302  : 				if(lpMagic!=NULL) gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00bbe	83 7d e4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00bc2	74 1a		 je	 SHORT $LN6@Work
  00bc4	8b 45 e4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00bc7	50		 push	 eax
  00bc8	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00bcb	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bcd	52		 push	 edx
  00bce	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00bd1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bd3	51		 push	 ecx
  00bd4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00bd9	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN6@Work:

; 303  : 			}
; 304  : 			//Heal Baf
; 305  : 			if(gObjGetMagicSearch( lpUser, 26) != NULL) SearchSkill = 26;

  00bde	6a 1a		 push	 26			; 0000001aH
  00be0	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00be3	50		 push	 eax
  00be4	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00be9	83 c4 08	 add	 esp, 8
  00bec	85 c0		 test	 eax, eax
  00bee	74 09		 je	 SHORT $LN4@Work
  00bf0	c7 45 e8 1a 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 26 ; 0000001aH
  00bf7	eb 07		 jmp	 SHORT $LN3@Work
$LN4@Work:

; 306  : 			//else if(gObjGetMagicSearch( lpUser, 475) != NULL) SearchSkill = 475;
; 307  : 			//else if(gObjGetMagicSearch( lpUser, 476) != NULL) SearchSkill = 476;
; 308  : 			//else if(gObjGetMagicSearch( lpUser, 477) != NULL) SearchSkill = 477;
; 309  : 			//else if(gObjGetMagicSearch( lpUser, 478) != NULL) SearchSkill = 478;
; 310  : 			//else if(gObjGetMagicSearch( lpUser, 479) != NULL) SearchSkill = 479;
; 311  : 			else SearchSkill = 0;

  00bf9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SearchSkill$[ebp], 0
$LN3@Work:

; 312  : 			if(SearchSkill != 0)

  00c00	83 7d e8 00	 cmp	 DWORD PTR _SearchSkill$[ebp], 0
  00c04	74 33		 je	 SHORT $LN41@Work

; 313  : 			{
; 314  : 				lpMagic = gObjGetMagicSearch( lpUser, SearchSkill);

  00c06	8b 45 e8	 mov	 eax, DWORD PTR _SearchSkill$[ebp]
  00c09	50		 push	 eax
  00c0a	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00c0d	51		 push	 ecx
  00c0e	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00c13	83 c4 08	 add	 esp, 8
  00c16	89 45 e4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 315  : 				if(lpMagic!=NULL) gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00c19	83 7d e4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00c1d	74 1a		 je	 SHORT $LN41@Work
  00c1f	8b 45 e4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00c22	50		 push	 eax
  00c23	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00c26	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c28	52		 push	 edx
  00c29	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00c2c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c2e	51		 push	 ecx
  00c2f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00c34	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN41@Work:

; 316  : 			}
; 317  : 		}
; 318  : 	}
; 319  : #endif
; 320  : }

  00c39	5f		 pop	 edi
  00c3a	5e		 pop	 esi
  00c3b	5b		 pop	 ebx
  00c3c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c3f	33 cd		 xor	 ecx, ebp
  00c41	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c46	8b e5		 mov	 esp, ebp
  00c48	5d		 pop	 ebp
  00c49	c2 04 00	 ret	 4
?Work@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z ENDP		; MUHelper::Work
_TEXT	ENDS
PUBLIC	??_C@_0CF@DCCNDCBA@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5cl@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CF@DCCNDCBA@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5cl@
CONST	SEGMENT
??_C@_0CF@DCCNDCBA@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5cl@ DB '['
	DB	'MUHelper] [%s] [%s] has been closed', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pAnswer$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
?Close@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z PROC		; MUHelper::Close
; _this$ = ecx

; 324  : {

  00c50	55		 push	 ebp
  00c51	8b ec		 mov	 ebp, esp
  00c53	83 ec 58	 sub	 esp, 88			; 00000058H
  00c56	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00c5b	33 c5		 xor	 eax, ebp
  00c5d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00c60	53		 push	 ebx
  00c61	56		 push	 esi
  00c62	57		 push	 edi
  00c63	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : #if(FIX_MUHELPER_TP == TRUE)
; 326  : 	if(lpUser->MuHelperTeleportFix)

  00c66	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00c69	0f b6 88 cd 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10445]
  00c70	85 c9		 test	 ecx, ecx
  00c72	74 0f		 je	 SHORT $LN1@Close

; 327  : 	{
; 328  : 		lpUser->MuHelperTeleportFix = false;

  00c74	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00c77	c6 80 cd 28 00
	00 00		 mov	 BYTE PTR [eax+10445], 0

; 329  : 		return;

  00c7e	e9 8d 00 00 00	 jmp	 $LN2@Close
$LN1@Close:

; 330  : 	}
; 331  : #endif
; 332  : 	MUHELPER_ANS_DATA pAnswer = { 0 };

  00c83	c6 45 e8 00	 mov	 BYTE PTR _pAnswer$[ebp], 0
  00c87	33 c0		 xor	 eax, eax
  00c89	89 45 e9	 mov	 DWORD PTR _pAnswer$[ebp+1], eax
  00c8c	89 45 ed	 mov	 DWORD PTR _pAnswer$[ebp+5], eax
  00c8f	89 45 f1	 mov	 DWORD PTR _pAnswer$[ebp+9], eax
  00c92	66 89 45 f5	 mov	 WORD PTR _pAnswer$[ebp+13], ax
  00c96	88 45 f7	 mov	 BYTE PTR _pAnswer$[ebp+15], al

; 333  : 	PHeadSubSetB((LPBYTE)&pAnswer, 0xBF, 0x51, sizeof(pAnswer));

  00c99	6a 10		 push	 16			; 00000010H
  00c9b	6a 51		 push	 81			; 00000051H
  00c9d	68 bf 00 00 00	 push	 191			; 000000bfH
  00ca2	8d 45 e8	 lea	 eax, DWORD PTR _pAnswer$[ebp]
  00ca5	50		 push	 eax
  00ca6	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00cab	83 c4 10	 add	 esp, 16			; 00000010H

; 334  : 	// ----
; 335  : 	pAnswer.Mode = 1;

  00cae	c6 45 f4 01	 mov	 BYTE PTR _pAnswer$[ebp+12], 1

; 336  : 	// ----
; 337  : 	lpUser->m_MUHelperOn		= false;

  00cb2	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00cb5	c6 80 a3 27 00
	00 00		 mov	 BYTE PTR [eax+10147], 0

; 338  : 	lpUser->m_MUHelperReadyPay	= false;

  00cbc	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00cbf	c6 80 a4 27 00
	00 00		 mov	 BYTE PTR [eax+10148], 0

; 339  : 	lpUser->m_MUHelperStage		= 1;

  00cc6	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00cc9	c6 80 a5 27 00
	00 01		 mov	 BYTE PTR [eax+10149], 1

; 340  : 	lpUser->m_MUHelperTick		= 0;

  00cd0	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00cd3	c7 80 a8 27 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+10152], 0

; 341  : 	// ----
; 342  : 	DataSend(lpUser->m_Index, (LPBYTE)&pAnswer, pAnswer.h.size);

  00cdd	0f b6 45 e9	 movzx	 eax, BYTE PTR _pAnswer$[ebp+1]
  00ce1	50		 push	 eax
  00ce2	8d 4d e8	 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  00ce5	51		 push	 ecx
  00ce6	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00ce9	8b 02		 mov	 eax, DWORD PTR [edx]
  00ceb	50		 push	 eax
  00cec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00cf1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 343  : 	// ----
; 344  : 	LogAddTD("[MUHelper] [%s] [%s] has been closed", lpUser->AccountID, lpUser->Name);

  00cf4	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00cf7	83 c0 77	 add	 eax, 119		; 00000077H
  00cfa	50		 push	 eax
  00cfb	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00cfe	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00d01	51		 push	 ecx
  00d02	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DCCNDCBA@?$FLMUHelper?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5has?5been?5cl@
  00d07	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d0d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Close:

; 345  : }

  00d10	5f		 pop	 edi
  00d11	5e		 pop	 esi
  00d12	5b		 pop	 ebx
  00d13	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d16	33 cd		 xor	 ecx, ebp
  00d18	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d1d	8b e5		 mov	 esp, ebp
  00d1f	5d		 pop	 ebp
  00d20	c2 04 00	 ret	 4
?Close@MUHelper@@QAEXPAUOBJECTSTRUCT@@@Z ENDP		; MUHelper::Close
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_lpUser$ = 8						; size = 4
_WorkTime$ = 12						; size = 2
?SetStage@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z PROC	; MUHelper::SetStage
; _this$ = ecx

; 349  : {

  00d30	55		 push	 ebp
  00d31	8b ec		 mov	 ebp, esp
  00d33	83 ec 44	 sub	 esp, 68			; 00000044H
  00d36	53		 push	 ebx
  00d37	56		 push	 esi
  00d38	57		 push	 edi
  00d39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 350  : 	if( lpUser->m_MUHelperStage < MAX_HELPER_STAGE )

  00d3c	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00d3f	0f b6 88 a5 27
	00 00		 movzx	 ecx, BYTE PTR [eax+10149]
  00d46	83 f9 05	 cmp	 ecx, 5
  00d49	7d 32		 jge	 SHORT $LN4@SetStage

; 351  : 	{
; 352  : 		lpUser->m_MUHelperStage = WorkTime / this->StageTime;	//-> 1 stage = 3.2h

  00d4b	0f b7 45 0c	 movzx	 eax, WORD PTR _WorkTime$[ebp]
  00d4f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d52	0f bf 49 18	 movsx	 ecx, WORD PTR [ecx+24]
  00d56	99		 cdq
  00d57	f7 f9		 idiv	 ecx
  00d59	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00d5c	88 82 a5 27 00
	00		 mov	 BYTE PTR [edx+10149], al

; 353  : 		// ----
; 354  : 		if( lpUser->m_MUHelperStage < 1 )

  00d62	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00d65	0f b6 88 a5 27
	00 00		 movzx	 ecx, BYTE PTR [eax+10149]
  00d6c	83 f9 01	 cmp	 ecx, 1
  00d6f	7d 0a		 jge	 SHORT $LN3@SetStage

; 355  : 		{
; 356  : 			lpUser->m_MUHelperStage = 1;

  00d71	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00d74	c6 80 a5 27 00
	00 01		 mov	 BYTE PTR [eax+10149], 1
$LN3@SetStage:

; 357  : 		}
; 358  : 	}

  00d7b	eb 19		 jmp	 SHORT $LN5@SetStage
$LN4@SetStage:

; 359  : 	else if( lpUser->m_MUHelperStage > MAX_HELPER_STAGE )

  00d7d	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00d80	0f b6 88 a5 27
	00 00		 movzx	 ecx, BYTE PTR [eax+10149]
  00d87	83 f9 05	 cmp	 ecx, 5
  00d8a	7e 0a		 jle	 SHORT $LN5@SetStage

; 360  : 	{
; 361  : 		lpUser->m_MUHelperStage = MAX_HELPER_STAGE;

  00d8c	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00d8f	c6 80 a5 27 00
	00 05		 mov	 BYTE PTR [eax+10149], 5
$LN5@SetStage:

; 362  : 	}
; 363  : }

  00d96	5f		 pop	 edi
  00d97	5e		 pop	 esi
  00d98	5b		 pop	 ebx
  00d99	8b e5		 mov	 esp, ebp
  00d9b	5d		 pop	 ebp
  00d9c	c2 08 00	 ret	 8
?SetStage@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z ENDP	; MUHelper::SetStage
_TEXT	ENDS
PUBLIC	?GetMoney@MUHelper@@QAEHPAUOBJECTSTRUCT@@@Z	; MUHelper::GetMoney
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_Level$ = -8						; size = 4
_this$ = -4						; size = 4
_lpUser$ = 8						; size = 4
?GetMoney@MUHelper@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; MUHelper::GetMoney
; _this$ = ecx

; 367  : {

  00da0	55		 push	 ebp
  00da1	8b ec		 mov	 ebp, esp
  00da3	83 ec 48	 sub	 esp, 72			; 00000048H
  00da6	53		 push	 ebx
  00da7	56		 push	 esi
  00da8	57		 push	 edi
  00da9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 	int Level = lpUser->Level + lpUser->MLevel;

  00dac	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00daf	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00db6	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00db9	0f bf 82 d0 00
	00 00		 movsx	 eax, WORD PTR [edx+208]
  00dc0	03 c8		 add	 ecx, eax
  00dc2	89 4d f8	 mov	 DWORD PTR _Level$[ebp], ecx

; 369  : 	return Level * this->StagePay[lpUser->m_MUHelperStage-1];

  00dc5	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00dc8	0f b6 88 a5 27
	00 00		 movzx	 ecx, BYTE PTR [eax+10149]
  00dcf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00dd2	8b 45 f8	 mov	 eax, DWORD PTR _Level$[ebp]
  00dd5	0f af 04 8a	 imul	 eax, DWORD PTR [edx+ecx*4]

; 370  : }

  00dd9	5f		 pop	 edi
  00dda	5e		 pop	 esi
  00ddb	5b		 pop	 ebx
  00ddc	8b e5		 mov	 esp, ebp
  00dde	5d		 pop	 ebp
  00ddf	c2 04 00	 ret	 4
?GetMoney@MUHelper@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; MUHelper::GetMoney
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pAnswer$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
?CheckMoney@MUHelper@@QAE_NPAUOBJECTSTRUCT@@@Z PROC	; MUHelper::CheckMoney
; _this$ = ecx

; 374  : {

  00df0	55		 push	 ebp
  00df1	8b ec		 mov	 ebp, esp
  00df3	83 ec 58	 sub	 esp, 88			; 00000058H
  00df6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00dfb	33 c5		 xor	 eax, ebp
  00dfd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00e00	53		 push	 ebx
  00e01	56		 push	 esi
  00e02	57		 push	 edi
  00e03	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 375  : 	MUHELPER_ANS_DATA pAnswer = { 0 };

  00e06	c6 45 e8 00	 mov	 BYTE PTR _pAnswer$[ebp], 0
  00e0a	33 c0		 xor	 eax, eax
  00e0c	89 45 e9	 mov	 DWORD PTR _pAnswer$[ebp+1], eax
  00e0f	89 45 ed	 mov	 DWORD PTR _pAnswer$[ebp+5], eax
  00e12	89 45 f1	 mov	 DWORD PTR _pAnswer$[ebp+9], eax
  00e15	66 89 45 f5	 mov	 WORD PTR _pAnswer$[ebp+13], ax
  00e19	88 45 f7	 mov	 BYTE PTR _pAnswer$[ebp+15], al

; 376  : 	PHeadSubSetB((LPBYTE)&pAnswer, 0xBF, 0x51, sizeof(pAnswer));

  00e1c	6a 10		 push	 16			; 00000010H
  00e1e	6a 51		 push	 81			; 00000051H
  00e20	68 bf 00 00 00	 push	 191			; 000000bfH
  00e25	8d 45 e8	 lea	 eax, DWORD PTR _pAnswer$[ebp]
  00e28	50		 push	 eax
  00e29	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00e2e	83 c4 10	 add	 esp, 16			; 00000010H

; 377  : 	// ----
; 378  : 	pAnswer.Mode = 2;

  00e31	c6 45 f4 02	 mov	 BYTE PTR _pAnswer$[ebp+12], 2

; 379  : 	// ----
; 380  : 	if( lpUser->Money < this->GetMoney(lpUser) )

  00e35	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00e38	50		 push	 eax
  00e39	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e3c	e8 00 00 00 00	 call	 ?GetMoney@MUHelper@@QAEHPAUOBJECTSTRUCT@@@Z ; MUHelper::GetMoney
  00e41	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00e44	39 81 f0 00 00
	00		 cmp	 DWORD PTR [ecx+240], eax
  00e4a	7d 1b		 jge	 SHORT $LN1@CheckMoney

; 381  : 	{
; 382  : 		DataSend(lpUser->m_Index, (LPBYTE)&pAnswer, pAnswer.h.size);

  00e4c	0f b6 45 e9	 movzx	 eax, BYTE PTR _pAnswer$[ebp+1]
  00e50	50		 push	 eax
  00e51	8d 4d e8	 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  00e54	51		 push	 ecx
  00e55	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00e58	8b 02		 mov	 eax, DWORD PTR [edx]
  00e5a	50		 push	 eax
  00e5b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00e60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 383  : 		return false;

  00e63	32 c0		 xor	 al, al
  00e65	eb 02		 jmp	 SHORT $LN2@CheckMoney
$LN1@CheckMoney:

; 384  : 	}
; 385  : 	// ----
; 386  : 	return true;

  00e67	b0 01		 mov	 al, 1
$LN2@CheckMoney:

; 387  : }

  00e69	5f		 pop	 edi
  00e6a	5e		 pop	 esi
  00e6b	5b		 pop	 ebx
  00e6c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e6f	33 cd		 xor	 ecx, ebp
  00e71	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e76	8b e5		 mov	 esp, ebp
  00e78	5d		 pop	 ebp
  00e79	c2 04 00	 ret	 4
?CheckMoney@MUHelper@@QAE_NPAUOBJECTSTRUCT@@@Z ENDP	; MUHelper::CheckMoney
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pAnswer$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
_WorkTime$ = 12						; size = 2
?SendMoney@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z PROC	; MUHelper::SendMoney
; _this$ = ecx

; 391  : {

  00e80	55		 push	 ebp
  00e81	8b ec		 mov	 ebp, esp
  00e83	83 ec 58	 sub	 esp, 88			; 00000058H
  00e86	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00e8b	33 c5		 xor	 eax, ebp
  00e8d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00e90	53		 push	 ebx
  00e91	56		 push	 esi
  00e92	57		 push	 edi
  00e93	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 	MUHELPER_ANS_DATA pAnswer = { 0 };

  00e96	c6 45 e8 00	 mov	 BYTE PTR _pAnswer$[ebp], 0
  00e9a	33 c0		 xor	 eax, eax
  00e9c	89 45 e9	 mov	 DWORD PTR _pAnswer$[ebp+1], eax
  00e9f	89 45 ed	 mov	 DWORD PTR _pAnswer$[ebp+5], eax
  00ea2	89 45 f1	 mov	 DWORD PTR _pAnswer$[ebp+9], eax
  00ea5	66 89 45 f5	 mov	 WORD PTR _pAnswer$[ebp+13], ax
  00ea9	88 45 f7	 mov	 BYTE PTR _pAnswer$[ebp+15], al

; 393  : 	PHeadSubSetB((LPBYTE)&pAnswer, 0xBF, 0x51, sizeof(pAnswer));

  00eac	6a 10		 push	 16			; 00000010H
  00eae	6a 51		 push	 81			; 00000051H
  00eb0	68 bf 00 00 00	 push	 191			; 000000bfH
  00eb5	8d 45 e8	 lea	 eax, DWORD PTR _pAnswer$[ebp]
  00eb8	50		 push	 eax
  00eb9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00ebe	83 c4 10	 add	 esp, 16			; 00000010H

; 394  : 	// ----
; 395  : 	pAnswer.Money	= this->GetMoney(lpUser);

  00ec1	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ec4	50		 push	 eax
  00ec5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ec8	e8 00 00 00 00	 call	 ?GetMoney@MUHelper@@QAEHPAUOBJECTSTRUCT@@@Z ; MUHelper::GetMoney
  00ecd	89 45 f0	 mov	 DWORD PTR _pAnswer$[ebp+8], eax

; 396  : 	pAnswer.Mode	= 0;

  00ed0	c6 45 f4 00	 mov	 BYTE PTR _pAnswer$[ebp+12], 0

; 397  : 	pAnswer.Time	= WorkTime;

  00ed4	66 8b 45 0c	 mov	 ax, WORD PTR _WorkTime$[ebp]
  00ed8	66 89 45 ec	 mov	 WORD PTR _pAnswer$[ebp+4], ax

; 398  : 	// ----
; 399  : 	lpUser->Money -= pAnswer.Money;

  00edc	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00edf	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00ee5	2b 4d f0	 sub	 ecx, DWORD PTR _pAnswer$[ebp+8]
  00ee8	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00eeb	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 400  : 	GCMoneySend(lpUser->m_Index, lpUser->Money);

  00ef1	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ef4	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00efa	51		 push	 ecx
  00efb	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00efe	8b 02		 mov	 eax, DWORD PTR [edx]
  00f00	50		 push	 eax
  00f01	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00f06	83 c4 08	 add	 esp, 8

; 401  : 	// ----
; 402  : 	lpUser->m_MUHelperReadyPay = false;

  00f09	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00f0c	c6 80 a4 27 00
	00 00		 mov	 BYTE PTR [eax+10148], 0

; 403  : 	DataSend(lpUser->m_Index, (LPBYTE)&pAnswer, pAnswer.h.size);

  00f13	0f b6 45 e9	 movzx	 eax, BYTE PTR _pAnswer$[ebp+1]
  00f17	50		 push	 eax
  00f18	8d 4d e8	 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  00f1b	51		 push	 ecx
  00f1c	8b 55 08	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00f1f	8b 02		 mov	 eax, DWORD PTR [edx]
  00f21	50		 push	 eax
  00f22	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00f27	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  : }

  00f2a	5f		 pop	 edi
  00f2b	5e		 pop	 esi
  00f2c	5b		 pop	 ebx
  00f2d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f30	33 cd		 xor	 ecx, ebp
  00f32	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f37	8b e5		 mov	 esp, ebp
  00f39	5d		 pop	 ebp
  00f3a	c2 08 00	 ret	 8
?SendMoney@MUHelper@@QAEXPAUOBJECTSTRUCT@@G@Z ENDP	; MUHelper::SendMoney
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SaveMacro@MUHelper@@QAEXHPAUMUHELPER_MACRO_CLIENT@@@Z ; MUHelper::SaveMacro
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	_memcpy:PROC
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pRequest$ = -300					; size = 288
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
_lpRequest$ = 12					; size = 4
?SaveMacro@MUHelper@@QAEXHPAUMUHELPER_MACRO_CLIENT@@@Z PROC ; MUHelper::SaveMacro
; _this$ = ecx

; 408  : {

  00f40	55		 push	 ebp
  00f41	8b ec		 mov	 ebp, esp
  00f43	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00f49	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00f4e	33 c5		 xor	 eax, ebp
  00f50	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00f53	53		 push	 ebx
  00f54	56		 push	 esi
  00f55	57		 push	 edi
  00f56	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 409  : 	LPOBJ lpUser = &gObj[UserIndex];

  00f59	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00f5c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00f62	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f68	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 410  : 	// ----
; 411  : 	MUHELPER_MACRO_DS	pRequest = { 0 };

  00f6b	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR _pRequest$[ebp], 0
  00f72	68 1f 01 00 00	 push	 287			; 0000011fH
  00f77	6a 00		 push	 0
  00f79	8d 85 d5 fe ff
	ff		 lea	 eax, DWORD PTR _pRequest$[ebp+1]
  00f7f	50		 push	 eax
  00f80	e8 00 00 00 00	 call	 _memset
  00f85	83 c4 0c	 add	 esp, 12			; 0000000cH

; 412  : 	PHeadSetW((LPBYTE)&pRequest, 0x18, sizeof(MUHELPER_MACRO_DS));

  00f88	68 20 01 00 00	 push	 288			; 00000120H
  00f8d	6a 18		 push	 24			; 00000018H
  00f8f	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pRequest$[ebp]
  00f95	50		 push	 eax
  00f96	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  00f9b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 413  : 	// ----
; 414  : 	memcpy(pRequest.AccountID, lpUser->AccountID, MAX_IDSTRING);

  00f9e	6a 0a		 push	 10			; 0000000aH
  00fa0	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00fa3	83 c0 6c	 add	 eax, 108		; 0000006cH
  00fa6	50		 push	 eax
  00fa7	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pRequest$[ebp+8]
  00fad	51		 push	 ecx
  00fae	e8 00 00 00 00	 call	 _memcpy
  00fb3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  : 	memcpy(pRequest.Name, lpUser->Name, MAX_IDSTRING);

  00fb6	6a 0a		 push	 10			; 0000000aH
  00fb8	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00fbb	83 c0 77	 add	 eax, 119		; 00000077H
  00fbe	50		 push	 eax
  00fbf	8d 8d e7 fe ff
	ff		 lea	 ecx, DWORD PTR _pRequest$[ebp+19]
  00fc5	51		 push	 ecx
  00fc6	e8 00 00 00 00	 call	 _memcpy
  00fcb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 	pRequest.aIndex = UserIndex;

  00fce	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00fd1	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _pRequest$[ebp+4], eax

; 417  : 	memcpy(pRequest.btMacroData, lpRequest->MacroBind, sizeof(pRequest.btMacroData));

  00fd7	68 00 01 00 00	 push	 256			; 00000100H
  00fdc	8b 45 0c	 mov	 eax, DWORD PTR _lpRequest$[ebp]
  00fdf	83 c0 04	 add	 eax, 4
  00fe2	50		 push	 eax
  00fe3	8d 8d f3 fe ff
	ff		 lea	 ecx, DWORD PTR _pRequest$[ebp+31]
  00fe9	51		 push	 ecx
  00fea	e8 00 00 00 00	 call	 _memcpy
  00fef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 418  : 	// ----
; 419  : 	cDBSMng.Send((char*)&pRequest, sizeof(MUHELPER_MACRO_DS));

  00ff2	68 20 01 00 00	 push	 288			; 00000120H
  00ff7	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pRequest$[ebp]
  00ffd	50		 push	 eax
  00ffe	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  01003	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 420  : }

  01008	5f		 pop	 edi
  01009	5e		 pop	 esi
  0100a	5b		 pop	 ebx
  0100b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0100e	33 cd		 xor	 ecx, ebp
  01010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01015	8b e5		 mov	 esp, ebp
  01017	5d		 pop	 ebp
  01018	c2 08 00	 ret	 8
?SaveMacro@MUHelper@@QAEXHPAUMUHELPER_MACRO_CLIENT@@@Z ENDP ; MUHelper::SaveMacro
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ReqMacro@MUHelper@@QAEXH@Z			; MUHelper::ReqMacro
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pRequest$ = -300					; size = 288
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?ReqMacro@MUHelper@@QAEXH@Z PROC			; MUHelper::ReqMacro
; _this$ = ecx

; 424  : {

  01020	55		 push	 ebp
  01021	8b ec		 mov	 ebp, esp
  01023	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  01029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0102e	33 c5		 xor	 eax, ebp
  01030	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01033	53		 push	 ebx
  01034	56		 push	 esi
  01035	57		 push	 edi
  01036	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 425  : 	LPOBJ lpUser = &gObj[UserIndex];

  01039	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0103c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01042	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01048	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 426  : 	// ----
; 427  : 	MUHELPER_MACRO_DS	pRequest = { 0 };

  0104b	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR _pRequest$[ebp], 0
  01052	68 1f 01 00 00	 push	 287			; 0000011fH
  01057	6a 00		 push	 0
  01059	8d 85 d5 fe ff
	ff		 lea	 eax, DWORD PTR _pRequest$[ebp+1]
  0105f	50		 push	 eax
  01060	e8 00 00 00 00	 call	 _memset
  01065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 	PHeadSetW((LPBYTE)&pRequest, 0x17, sizeof(MUHELPER_MACRO_DS));

  01068	68 20 01 00 00	 push	 288			; 00000120H
  0106d	6a 17		 push	 23			; 00000017H
  0106f	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pRequest$[ebp]
  01075	50		 push	 eax
  01076	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  0107b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 	// ----
; 430  : 	memcpy(pRequest.AccountID, lpUser->AccountID, MAX_IDSTRING);

  0107e	6a 0a		 push	 10			; 0000000aH
  01080	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01083	83 c0 6c	 add	 eax, 108		; 0000006cH
  01086	50		 push	 eax
  01087	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pRequest$[ebp+8]
  0108d	51		 push	 ecx
  0108e	e8 00 00 00 00	 call	 _memcpy
  01093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 	memcpy(pRequest.Name, lpUser->Name, MAX_IDSTRING);

  01096	6a 0a		 push	 10			; 0000000aH
  01098	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0109b	83 c0 77	 add	 eax, 119		; 00000077H
  0109e	50		 push	 eax
  0109f	8d 8d e7 fe ff
	ff		 lea	 ecx, DWORD PTR _pRequest$[ebp+19]
  010a5	51		 push	 ecx
  010a6	e8 00 00 00 00	 call	 _memcpy
  010ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 	pRequest.aIndex = UserIndex;

  010ae	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  010b1	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _pRequest$[ebp+4], eax

; 433  : 	// ----
; 434  : 	cDBSMng.Send((char*)&pRequest, sizeof(MUHELPER_MACRO_DS));

  010b7	68 20 01 00 00	 push	 288			; 00000120H
  010bc	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pRequest$[ebp]
  010c2	50		 push	 eax
  010c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  010c8	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 435  : }

  010cd	5f		 pop	 edi
  010ce	5e		 pop	 esi
  010cf	5b		 pop	 ebx
  010d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010d3	33 cd		 xor	 ecx, ebp
  010d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010da	8b e5		 mov	 esp, ebp
  010dc	5d		 pop	 ebp
  010dd	c2 04 00	 ret	 4
?ReqMacro@MUHelper@@QAEXH@Z ENDP			; MUHelper::ReqMacro
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendMacro@MUHelper@@QAEXPAUMUHELPER_MACRO_DS@@@Z ; MUHelper::SendMacro
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pAnswer$ = -272					; size = 261
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRequest$ = 8						; size = 4
?SendMacro@MUHelper@@QAEXPAUMUHELPER_MACRO_DS@@@Z PROC	; MUHelper::SendMacro
; _this$ = ecx

; 439  : {

  010e0	55		 push	 ebp
  010e1	8b ec		 mov	 ebp, esp
  010e3	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  010e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  010ee	33 c5		 xor	 eax, ebp
  010f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  010f3	53		 push	 ebx
  010f4	56		 push	 esi
  010f5	57		 push	 edi
  010f6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 440  : 	if( lpRequest->btResult || !gObjIsConnected(lpRequest->aIndex) )

  010f9	8b 45 08	 mov	 eax, DWORD PTR _lpRequest$[ebp]
  010fc	0f b6 48 1e	 movzx	 ecx, BYTE PTR [eax+30]
  01100	85 c9		 test	 ecx, ecx
  01102	75 13		 jne	 SHORT $LN1@SendMacro
  01104	8b 45 08	 mov	 eax, DWORD PTR _lpRequest$[ebp]
  01107	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0110a	51		 push	 ecx
  0110b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  01110	83 c4 04	 add	 esp, 4
  01113	85 c0		 test	 eax, eax
  01115	75 02		 jne	 SHORT $LN2@SendMacro
$LN1@SendMacro:

; 441  : 	{
; 442  : 		return;

  01117	eb 6c		 jmp	 SHORT $LN3@SendMacro
$LN2@SendMacro:

; 443  : 	}
; 444  : 	// ----
; 445  : 	MUHELPER_MACRO_CLIENT pAnswer = { 0 };

  01119	c6 85 f0 fe ff
	ff 00		 mov	 BYTE PTR _pAnswer$[ebp], 0
  01120	68 04 01 00 00	 push	 260			; 00000104H
  01125	6a 00		 push	 0
  01127	8d 85 f1 fe ff
	ff		 lea	 eax, DWORD PTR _pAnswer$[ebp+1]
  0112d	50		 push	 eax
  0112e	e8 00 00 00 00	 call	 _memset
  01133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 446  : 	PHeadSetW((LPBYTE)&pAnswer, 0xAE, sizeof(MUHELPER_MACRO_CLIENT));

  01136	68 05 01 00 00	 push	 261			; 00000105H
  0113b	68 ae 00 00 00	 push	 174			; 000000aeH
  01140	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pAnswer$[ebp]
  01146	50		 push	 eax
  01147	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  0114c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 447  : 	// ----
; 448  : 	memcpy(pAnswer.MacroBind, lpRequest->btMacroData, sizeof(lpRequest->btMacroData));

  0114f	68 00 01 00 00	 push	 256			; 00000100H
  01154	8b 45 08	 mov	 eax, DWORD PTR _lpRequest$[ebp]
  01157	83 c0 1f	 add	 eax, 31			; 0000001fH
  0115a	50		 push	 eax
  0115b	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pAnswer$[ebp+4]
  01161	51		 push	 ecx
  01162	e8 00 00 00 00	 call	 _memcpy
  01167	83 c4 0c	 add	 esp, 12			; 0000000cH

; 449  : 	// ----
; 450  : 	DataSend(lpRequest->aIndex, (LPBYTE)&pAnswer, sizeof(MUHELPER_MACRO_CLIENT));

  0116a	68 05 01 00 00	 push	 261			; 00000105H
  0116f	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pAnswer$[ebp]
  01175	50		 push	 eax
  01176	8b 4d 08	 mov	 ecx, DWORD PTR _lpRequest$[ebp]
  01179	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0117c	52		 push	 edx
  0117d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01182	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendMacro:

; 451  : }

  01185	5f		 pop	 edi
  01186	5e		 pop	 esi
  01187	5b		 pop	 ebx
  01188	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0118b	33 cd		 xor	 ecx, ebp
  0118d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01192	8b e5		 mov	 esp, ebp
  01194	5d		 pop	 ebp
  01195	c2 04 00	 ret	 4
?SendMacro@MUHelper@@QAEXPAUMUHELPER_MACRO_DS@@@Z ENDP	; MUHelper::SendMacro
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Eg_MUHelper@@YAXXZ
text$yc	SEGMENT
??__Eg_MUHelper@@YAXXZ PROC				; `dynamic initializer for 'g_MUHelper'', COMDAT

; 17   : MUHelper	g_MUHelper;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MUHelper@@3VMUHelper@@A ; g_MUHelper
  0000e	e8 00 00 00 00	 call	 ??0MUHelper@@QAE@XZ	; MUHelper::MUHelper
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MUHelper@@YAXXZ ; `dynamic atexit destructor for 'g_MUHelper''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MUHelper@@YAXXZ ENDP				; `dynamic initializer for 'g_MUHelper''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_MUHelper@@YAXXZ
text$yd	SEGMENT
??__Fg_MUHelper@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MUHelper'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MUHelper@@3VMUHelper@@A ; g_MUHelper
  0000e	e8 00 00 00 00	 call	 ??1MUHelper@@UAE@XZ	; MUHelper::~MUHelper
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MUHelper@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MUHelper''
text$yd	ENDS
PUBLIC	?g_MUHelper@@3VMUHelper@@A			; g_MUHelper
_BSS	SEGMENT
?g_MUHelper@@3VMUHelper@@A DB 01cH DUP (?)		; g_MUHelper
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MUHelper$initializer$ DD FLAT:??__Eg_MUHelper@@YAXXZ
CRT$XCU	ENDS
END
