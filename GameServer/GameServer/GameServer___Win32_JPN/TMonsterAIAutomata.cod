; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\TMonsterAIAutomata.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_bDataLoad@TMonsterAIAutomata@@2HA		; TMonsterAIAutomata::s_bDataLoad
_BSS	SEGMENT
?s_bDataLoad@TMonsterAIAutomata@@2HA DD 01H DUP (?)	; TMonsterAIAutomata::s_bDataLoad
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Reset@TMonsterAIAutomata@@QAEXXZ		; TMonsterAIAutomata::Reset
PUBLIC	??0TMonsterAIState@@QAE@XZ			; TMonsterAIState::TMonsterAIState
PUBLIC	??_7TMonsterAIAutomata@@6B@			; TMonsterAIAutomata::`vftable'
PUBLIC	??0TMonsterAIAutomata@@QAE@XZ			; TMonsterAIAutomata::TMonsterAIAutomata
PUBLIC	??_R4TMonsterAIAutomata@@6B@			; TMonsterAIAutomata::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIAutomata@@@8			; TMonsterAIAutomata `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIAutomata@@8			; TMonsterAIAutomata::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIAutomata@@8			; TMonsterAIAutomata::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIAutomata@@8		; TMonsterAIAutomata::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAIAutomata@@UAEPAXI@Z:PROC		; TMonsterAIAutomata::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAIAutomata@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraiautomata.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIAutomata@@8 DD FLAT:??_R0?AVTMonsterAIAutomata@@@8 ; TMonsterAIAutomata::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIAutomata@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIAutomata@@8
rdata$r	SEGMENT
??_R2TMonsterAIAutomata@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIAutomata@@8 ; TMonsterAIAutomata::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIAutomata@@8
rdata$r	SEGMENT
??_R3TMonsterAIAutomata@@8 DD 00H			; TMonsterAIAutomata::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIAutomata@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIAutomata@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAIAutomata@@@8 DD FLAT:??_7type_info@@6B@ ; TMonsterAIAutomata `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIAutomata@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAIAutomata@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIAutomata@@6B@ DD 00H			; TMonsterAIAutomata::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIAutomata@@@8
	DD	FLAT:??_R3TMonsterAIAutomata@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIAutomata@@6B@
CONST	SEGMENT
??_7TMonsterAIAutomata@@6B@ DD FLAT:??_R4TMonsterAIAutomata@@6B@ ; TMonsterAIAutomata::`vftable'
	DD	FLAT:??_ETMonsterAIAutomata@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIAutomata@@QAE@XZ PROC			; TMonsterAIAutomata::TMonsterAIAutomata
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIAutomata@@6B@
  00015	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIState@@QAE@XZ ; TMonsterAIState::TMonsterAIState
  0001a	68 f0 00 00 00	 push	 240			; 000000f0H
  0001f	68 84 00 00 00	 push	 132			; 00000084H
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c0 08	 add	 eax, 8
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z

; 23   : 	this->Reset();

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?Reset@TMonsterAIAutomata@@QAEXXZ ; TMonsterAIAutomata::Reset

; 24   : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0TMonsterAIAutomata@@QAE@XZ ENDP			; TMonsterAIAutomata::TMonsterAIAutomata
_TEXT	ENDS
PUBLIC	?Reset@TMonsterAIState@@QAEXXZ			; TMonsterAIState::Reset
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraistate.h
;	COMDAT ??0TMonsterAIState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIState@@QAE@XZ PROC				; TMonsterAIState::TMonsterAIState, COMDAT
; _this$ = ecx

; 41   : 	TMonsterAIState()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	{
; 43   : 		this->Reset();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Reset@TMonsterAIState@@QAEXXZ ; TMonsterAIState::Reset

; 44   : 	}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0TMonsterAIState@@QAE@XZ ENDP				; TMonsterAIState::TMonsterAIState
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?Reset@TMonsterAIState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@TMonsterAIState@@QAEXXZ PROC			; TMonsterAIState::Reset, COMDAT
; _this$ = ecx

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 		this->m_iPriority = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 49   : 		this->m_iCurrentState = -1;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 50   : 		this->m_iNextState = -1;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 51   : 		this->m_iTransitionType = -1;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 52   : 		this->m_iTransitionRate = -1;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1

; 53   : 		this->m_iTransitionValueType = -1;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1

; 54   : 		this->m_iTransitionValue = -1;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [eax+24], -1

; 55   : 		this->m_iDelayTime = -1;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [eax+28], -1

; 56   : 		memset(this->m_szStateTransitionDesc, 0, sizeof(this->m_szStateTransitionDesc));

  0005b	6a 64		 push	 100			; 00000064H
  0005d	6a 00		 push	 0
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 c0 20	 add	 eax, 32			; 00000020H
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _memset
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 57   : 	}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?Reset@TMonsterAIState@@QAEXXZ ENDP			; TMonsterAIState::Reset
_TEXT	ENDS
PUBLIC	??1TMonsterAIAutomata@@UAE@XZ			; TMonsterAIAutomata::~TMonsterAIAutomata
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GTMonsterAIAutomata@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTMonsterAIAutomata@@UAEPAXI@Z PROC			; TMonsterAIAutomata::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1TMonsterAIAutomata@@UAE@XZ ; TMonsterAIAutomata::~TMonsterAIAutomata
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GTMonsterAIAutomata@@UAEPAXI@Z ENDP			; TMonsterAIAutomata::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraiautomata.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TMonsterAIAutomata@@UAE@XZ PROC			; TMonsterAIAutomata::~TMonsterAIAutomata
; _this$ = ecx

; 27   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 44	 sub	 esp, 68			; 00000044H
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIAutomata@@6B@

; 28   : 	return;
; 29   : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??1TMonsterAIAutomata@@UAE@XZ ENDP			; TMonsterAIAutomata::~TMonsterAIAutomata
; Function compile flags: /Odtp /ZI
_k$219217 = -16					; size = 4
_j$219213 = -12						; size = 4
_i$219209 = -8						; size = 4
_this$ = -4						; size = 4
?Reset@TMonsterAIAutomata@@QAEXXZ PROC			; TMonsterAIAutomata::Reset
; _this$ = ecx

; 34   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	83 ec 50	 sub	 esp, 80			; 00000050H
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	for ( int i=0;i<MAX_AI_STATE;i++)

  0007c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$219209[ebp], 0
  00083	eb 09		 jmp	 SHORT $LN9@Reset
$LN8@Reset:
  00085	8b 45 f8	 mov	 eax, DWORD PTR _i$219209[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 45 f8	 mov	 DWORD PTR _i$219209[ebp], eax
$LN9@Reset:
  0008e	83 7d f8 08	 cmp	 DWORD PTR _i$219209[ebp], 8
  00092	7d 3c		 jge	 SHORT $LN7@Reset

; 36   : 	{
; 37   : 		for ( int j=0;j<MAX_AI_PRIORITY;j++)

  00094	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$219213[ebp], 0
  0009b	eb 09		 jmp	 SHORT $LN6@Reset
$LN5@Reset:
  0009d	8b 45 f4	 mov	 eax, DWORD PTR _j$219213[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f4	 mov	 DWORD PTR _j$219213[ebp], eax
$LN6@Reset:
  000a6	83 7d f4 1e	 cmp	 DWORD PTR _j$219213[ebp], 30 ; 0000001eH
  000aa	7d 22		 jge	 SHORT $LN4@Reset

; 38   : 		{
; 39   : 			this->m_AIState[i][j].Reset();

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _i$219209[ebp]
  000af	69 c0 78 0f 00
	00		 imul	 eax, 3960		; 00000f78H
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	8d 4c 01 08	 lea	 ecx, DWORD PTR [ecx+eax+8]
  000bc	8b 55 f4	 mov	 edx, DWORD PTR _j$219213[ebp]
  000bf	69 d2 84 00 00
	00		 imul	 edx, 132		; 00000084H
  000c5	03 ca		 add	 ecx, edx
  000c7	e8 00 00 00 00	 call	 ?Reset@TMonsterAIState@@QAEXXZ ; TMonsterAIState::Reset

; 40   : 		}

  000cc	eb cf		 jmp	 SHORT $LN5@Reset
$LN4@Reset:

; 41   : 	}

  000ce	eb b5		 jmp	 SHORT $LN8@Reset
$LN7@Reset:

; 42   : 
; 43   : 	for ( int k=0;k<MAX_AI_STATE;k++)

  000d0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _k$219217[ebp], 0
  000d7	eb 09		 jmp	 SHORT $LN3@Reset
$LN2@Reset:
  000d9	8b 45 f0	 mov	 eax, DWORD PTR _k$219217[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 f0	 mov	 DWORD PTR _k$219217[ebp], eax
$LN3@Reset:
  000e2	83 7d f0 08	 cmp	 DWORD PTR _k$219217[ebp], 8
  000e6	7d 13		 jge	 SHORT $LN1@Reset

; 44   : 	{
; 45   : 		this->m_AIStateTransCount[k] = 0;

  000e8	8b 45 f0	 mov	 eax, DWORD PTR _k$219217[ebp]
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	c7 84 81 c8 7b
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+31688], 0

; 46   : 	}

  000f9	eb de		 jmp	 SHORT $LN2@Reset
$LN1@Reset:

; 47   : 
; 48   : 	this->m_iAutomataNumber = -1;

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 49   : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
?Reset@TMonsterAIAutomata@@QAEXXZ ENDP			; TMonsterAIAutomata::Reset
_TEXT	ENDS
PUBLIC	??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@ ; `string'
PUBLIC	??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@ ; `string'
PUBLIC	??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@ ; `string'
PUBLIC	??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@ ; `string'
PUBLIC	??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@ ; `string'
PUBLIC	??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@ ; `string'
PUBLIC	??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?DelAllAutomata@TMonsterAIAutomata@@SAHXZ	; TMonsterAIAutomata::DelAllAutomata
PUBLIC	??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadData@TMonsterAIAutomata@@SAHPAD@Z		; TMonsterAIAutomata::LoadData
EXTRN	_fclose:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_memcpy:PROC
EXTRN	_fopen:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_strcmp:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@
CONST	SEGMENT
??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@ DB '[Mon'
	DB	'ster AI Automata] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@
CONST	SEGMENT
??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@ DB '['
	DB	'Monster AI Automata] - %s file is Loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@
CONST	SEGMENT
??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@ DB '[Monst'
	DB	'er AI Automata] Loaded Transition Desc . [ %s ]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@
CONST	SEGMENT
??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@ DB '[Mons'
	DB	'ter AI Automata] - Priority(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@
CONST	SEGMENT
??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@ DB '[Mons'
	DB	'ter AI Automata] - NextState(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@
CONST	SEGMENT
??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@ DB '[Mons'
	DB	'ter AI Automata] - CurrentState(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@
CONST	SEGMENT
??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@ DB '[Mons'
	DB	'ter AI Automata] - AutomataNumber(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@
CONST	SEGMENT
??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@ DB '[Mo'
	DB	'nster AI Automata] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@
CONST	SEGMENT
??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@ DB '[Mon'
	DB	'ster AI Automata] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterAIAutomata@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv221 = -236						; size = 4
tv220 = -236						; size = 4
tv219 = -236						; size = 4
tv218 = -236						; size = 4
tv217 = -236						; size = 4
tv216 = -236						; size = 4
tv215 = -236						; size = 4
tv214 = -236						; size = 4
tv213 = -236						; size = 4
tv212 = -236						; size = 4
tv211 = -236						; size = 4
_AIState$219286 = -168					; size = 4
_iDelayTime$219252 = -164				; size = 4
_iTransitionValue$219251 = -160				; size = 4
_iTransitionValueType$219250 = -156			; size = 4
_iTransitionRate$219249 = -152				; size = 4
_iTransitionType$219248 = -148				; size = 4
_iNextState$219247 = -144				; size = 4
_iCurrentState$219246 = -140				; size = 4
_iPriority$219245 = -136				; size = 4
_iAutomataNumber$219244 = -132				; size = 4
_szStateTransitionDesc$219243 = -128			; size = 100
_iType$219232 = -28					; size = 4
_Token$219228 = -24					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterAIAutomata@@SAHPAD@Z PROC		; TMonsterAIAutomata::LoadData

; 53   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	6a ff		 push	 -1
  00115	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
  0011a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00120	50		 push	 eax
  00121	51		 push	 ecx
  00122	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0012d	33 c5		 xor	 eax, ebp
  0012f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00132	53		 push	 ebx
  00133	56		 push	 esi
  00134	57		 push	 edi
  00135	50		 push	 eax
  00136	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00139	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0013f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 54   : 	TMonsterAIAutomata::s_bDataLoad = FALSE;

  00142	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIAutomata@@2HA, 0 ; TMonsterAIAutomata::s_bDataLoad

; 55   : 
; 56   : 	if ( lpszFileName == NULL || strcmp(lpszFileName, "") == 0 )

  0014c	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  00150	74 15		 je	 SHORT $LN18@LoadData
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00157	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _strcmp
  00160	83 c4 08	 add	 esp, 8
  00163	85 c0		 test	 eax, eax
  00165	75 14		 jne	 SHORT $LN19@LoadData
$LN18@LoadData:

; 57   : 	{
; 58   : 		MsgBox("[Monster AI Automata] - File load error : File Name Error");

  00167	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@
  0016c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00171	83 c4 04	 add	 esp, 4

; 59   : 		return FALSE;

  00174	33 c0		 xor	 eax, eax
  00176	e9 df 04 00 00	 jmp	 $LN20@LoadData
$LN19@LoadData:

; 60   : 	}
; 61   : 
; 62   : 	try
; 63   : 	{

  0017b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 64   : 		SMDToken Token;
; 65   : 		SMDFile = fopen(lpszFileName, "r");

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00187	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _fopen
  00190	83 c4 08	 add	 esp, 8
  00193	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 66   : 
; 67   : 		if ( SMDFile == NULL )

  00198	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  0019f	75 18		 jne	 SHORT $LN16@LoadData

; 68   : 		{
; 69   : 			MsgBox("[Monster AI Automata] - Can't Open %s ", lpszFileName);

  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  001a4	50		 push	 eax
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@
  001aa	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  001af	83 c4 08	 add	 esp, 8

; 70   : 			return FALSE;

  001b2	33 c0		 xor	 eax, eax
  001b4	e9 a1 04 00 00	 jmp	 $LN20@LoadData
$LN16@LoadData:

; 71   : 		}
; 72   : 
; 73   : 		TMonsterAIAutomata::DelAllAutomata();

  001b9	e8 00 00 00 00	 call	 ?DelAllAutomata@TMonsterAIAutomata@@SAHXZ ; TMonsterAIAutomata::DelAllAutomata

; 74   : 
; 75   : 		int iType = -1;

  001be	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _iType$219232[ebp], -1
$LN15@LoadData:

; 76   : 
; 77   : 		while ( true )

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 33 04 00
	00		 je	 $LN14@LoadData

; 78   : 		{
; 79   : 			Token = (SMDToken)GetToken();

  001d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001d7	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
  001dd	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv211[ebp]
  001e3	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 80   : 
; 81   : 			if ( Token == END )

  001e6	83 7d e8 02	 cmp	 DWORD PTR _Token$219228[ebp], 2
  001ea	75 05		 jne	 SHORT $LN13@LoadData

; 82   : 				break;

  001ec	e9 14 04 00 00	 jmp	 $LN14@LoadData
$LN13@LoadData:

; 83   : 
; 84   : 			iType = (int)TokenNumber;

  001f1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f7	e8 00 00 00 00	 call	 __ftol2_sse
  001fc	89 45 e4	 mov	 DWORD PTR _iType$219232[ebp], eax
$LN12@LoadData:

; 85   : 
; 86   : 			while ( true )

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	85 c0		 test	 eax, eax
  00206	0f 84 f4 03 00
	00		 je	 $LN11@LoadData

; 87   : 			{
; 88   : 				if ( iType == 0 )

  0020c	83 7d e4 00	 cmp	 DWORD PTR _iType$219232[ebp], 0
  00210	0f 85 e5 03 00
	00		 jne	 $LN10@LoadData

; 89   : 				{
; 90   : 					char szStateTransitionDesc[100] = {0};

  00216	c6 45 80 00	 mov	 BYTE PTR _szStateTransitionDesc$219243[ebp], 0
  0021a	6a 63		 push	 99			; 00000063H
  0021c	6a 00		 push	 0
  0021e	8d 45 81	 lea	 eax, DWORD PTR _szStateTransitionDesc$219243[ebp+1]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 _memset
  00227	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 					int iAutomataNumber = -1;

  0022a	c7 85 7c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iAutomataNumber$219244[ebp], -1

; 92   : 					int iPriority = -1;

  00234	c7 85 78 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iPriority$219245[ebp], -1

; 93   : 					int iCurrentState = -1;

  0023e	c7 85 74 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iCurrentState$219246[ebp], -1

; 94   : 					int iNextState = -1;

  00248	c7 85 70 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iNextState$219247[ebp], -1

; 95   : 					int iTransitionType = -1;

  00252	c7 85 6c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iTransitionType$219248[ebp], -1

; 96   : 					int iTransitionRate = -1;

  0025c	c7 85 68 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iTransitionRate$219249[ebp], -1

; 97   : 					int iTransitionValueType = -1;

  00266	c7 85 64 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iTransitionValueType$219250[ebp], -1

; 98   : 					int iTransitionValue = -1;

  00270	c7 85 60 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iTransitionValue$219251[ebp], -1

; 99   : 					int iDelayTime = -1;

  0027a	c7 85 5c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iDelayTime$219252[ebp], -1

; 100  : 
; 101  : 					Token = (SMDToken)GetToken();

  00284	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00289	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv212[ebp], eax
  0028f	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv212[ebp]
  00295	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 102  : 
; 103  : 					if ( strcmp("end", TokenString) == 0 )

  00298	68 00 00 00 00	 push	 OFFSET _TokenString
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  002a2	e8 00 00 00 00	 call	 _strcmp
  002a7	83 c4 08	 add	 esp, 8
  002aa	85 c0		 test	 eax, eax
  002ac	75 05		 jne	 SHORT $LN9@LoadData

; 104  : 						break;

  002ae	e9 4d 03 00 00	 jmp	 $LN11@LoadData
$LN9@LoadData:

; 105  : 
; 106  : 					iAutomataNumber = (int)TokenNumber;

  002b3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002b9	e8 00 00 00 00	 call	 __ftol2_sse
  002be	89 85 7c ff ff
	ff		 mov	 DWORD PTR _iAutomataNumber$219244[ebp], eax

; 107  : 
; 108  : 					Token = (SMDToken)GetToken();

  002c4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002c9	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], eax
  002cf	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv213[ebp]
  002d5	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 109  : 					memcpy(szStateTransitionDesc, TokenString, sizeof(szStateTransitionDesc));

  002d8	6a 64		 push	 100			; 00000064H
  002da	68 00 00 00 00	 push	 OFFSET _TokenString
  002df	8d 45 80	 lea	 eax, DWORD PTR _szStateTransitionDesc$219243[ebp]
  002e2	50		 push	 eax
  002e3	e8 00 00 00 00	 call	 _memcpy
  002e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 
; 111  : 					Token = (SMDToken)GetToken();

  002eb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002f0	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv214[ebp], eax
  002f6	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv214[ebp]
  002fc	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 112  : 					iPriority = (int)TokenNumber;

  002ff	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00305	e8 00 00 00 00	 call	 __ftol2_sse
  0030a	89 85 78 ff ff
	ff		 mov	 DWORD PTR _iPriority$219245[ebp], eax

; 113  : 
; 114  : 					Token = (SMDToken)GetToken();

  00310	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00315	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv215[ebp], eax
  0031b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv215[ebp]
  00321	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 115  : 					iCurrentState = (int)TokenNumber;

  00324	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0032a	e8 00 00 00 00	 call	 __ftol2_sse
  0032f	89 85 74 ff ff
	ff		 mov	 DWORD PTR _iCurrentState$219246[ebp], eax

; 116  : 
; 117  : 					Token = (SMDToken)GetToken();

  00335	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0033a	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  00340	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv216[ebp]
  00346	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 118  : 					iNextState = (int)TokenNumber;

  00349	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0034f	e8 00 00 00 00	 call	 __ftol2_sse
  00354	89 85 70 ff ff
	ff		 mov	 DWORD PTR _iNextState$219247[ebp], eax

; 119  : 
; 120  : 					Token = (SMDToken)GetToken();

  0035a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0035f	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv217[ebp], eax
  00365	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv217[ebp]
  0036b	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 121  : 					iTransitionType = (int)TokenNumber;

  0036e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00374	e8 00 00 00 00	 call	 __ftol2_sse
  00379	89 85 6c ff ff
	ff		 mov	 DWORD PTR _iTransitionType$219248[ebp], eax

; 122  : 
; 123  : 					Token = (SMDToken)GetToken();

  0037f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00384	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv218[ebp], eax
  0038a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv218[ebp]
  00390	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 124  : 					iTransitionRate = (int)TokenNumber;

  00393	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00399	e8 00 00 00 00	 call	 __ftol2_sse
  0039e	89 85 68 ff ff
	ff		 mov	 DWORD PTR _iTransitionRate$219249[ebp], eax

; 125  : 
; 126  : 					Token = (SMDToken)GetToken();

  003a4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a9	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv219[ebp], eax
  003af	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv219[ebp]
  003b5	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 127  : 					iTransitionValueType = (int)TokenNumber;

  003b8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003be	e8 00 00 00 00	 call	 __ftol2_sse
  003c3	89 85 64 ff ff
	ff		 mov	 DWORD PTR _iTransitionValueType$219250[ebp], eax

; 128  : 
; 129  : 					Token = (SMDToken)GetToken();

  003c9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003ce	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv220[ebp], eax
  003d4	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv220[ebp]
  003da	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 130  : 					iTransitionValue = (int)TokenNumber;

  003dd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003e3	e8 00 00 00 00	 call	 __ftol2_sse
  003e8	89 85 60 ff ff
	ff		 mov	 DWORD PTR _iTransitionValue$219251[ebp], eax

; 131  : 
; 132  : 					Token = (SMDToken)GetToken();

  003ee	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003f3	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  003f9	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  003ff	89 45 e8	 mov	 DWORD PTR _Token$219228[ebp], eax

; 133  : 					iDelayTime = (int)TokenNumber;

  00402	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00408	e8 00 00 00 00	 call	 __ftol2_sse
  0040d	89 85 5c ff ff
	ff		 mov	 DWORD PTR _iDelayTime$219252[ebp], eax

; 134  : 
; 135  : 					if ( iAutomataNumber < 0 || iAutomataNumber >= MAX_MONSTER_AI_AUTOMATA )

  00413	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _iAutomataNumber$219244[ebp], 0
  0041a	7c 0c		 jl	 SHORT $LN7@LoadData
  0041c	81 bd 7c ff ff
	ff 2c 01 00 00	 cmp	 DWORD PTR _iAutomataNumber$219244[ebp], 300 ; 0000012cH
  00426	7c 1d		 jl	 SHORT $LN8@LoadData
$LN7@LoadData:

; 136  : 					{
; 137  : 						MsgBox("[Monster AI Automata] - AutomataNumber(%d) Error (%s) File. ",iAutomataNumber, lpszFileName);

  00428	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0042b	50		 push	 eax
  0042c	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iAutomataNumber$219244[ebp]
  00432	51		 push	 ecx
  00433	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@
  00438	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0043d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 						continue;

  00440	e9 ba fd ff ff	 jmp	 $LN12@LoadData
$LN8@LoadData:

; 139  : 					}
; 140  : 
; 141  : 					if ( iCurrentState < 0 || iCurrentState >= MAX_AI_STATE )

  00445	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _iCurrentState$219246[ebp], 0
  0044c	7c 09		 jl	 SHORT $LN5@LoadData
  0044e	83 bd 74 ff ff
	ff 08		 cmp	 DWORD PTR _iCurrentState$219246[ebp], 8
  00455	7c 1d		 jl	 SHORT $LN6@LoadData
$LN5@LoadData:

; 142  : 					{
; 143  : 						MsgBox("[Monster AI Automata] - CurrentState(%d) Error (%s) File. ",iCurrentState, lpszFileName);

  00457	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0045a	50		 push	 eax
  0045b	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iCurrentState$219246[ebp]
  00461	51		 push	 ecx
  00462	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@
  00467	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0046c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 						continue;

  0046f	e9 8b fd ff ff	 jmp	 $LN12@LoadData
$LN6@LoadData:

; 145  : 					}
; 146  : 
; 147  : 					if ( iNextState < 0 || iNextState >= MAX_AI_STATE )

  00474	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _iNextState$219247[ebp], 0
  0047b	7c 09		 jl	 SHORT $LN3@LoadData
  0047d	83 bd 70 ff ff
	ff 08		 cmp	 DWORD PTR _iNextState$219247[ebp], 8
  00484	7c 1d		 jl	 SHORT $LN4@LoadData
$LN3@LoadData:

; 148  : 					{
; 149  : 						MsgBox("[Monster AI Automata] - NextState(%d) Error (%s) File. ",iNextState, lpszFileName);

  00486	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00489	50		 push	 eax
  0048a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _iNextState$219247[ebp]
  00490	51		 push	 ecx
  00491	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@
  00496	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0049b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 						continue;

  0049e	e9 5c fd ff ff	 jmp	 $LN12@LoadData
$LN4@LoadData:

; 151  : 					}
; 152  : 
; 153  : 					if ( iPriority < 0 || iPriority >= MAX_AI_PRIORITY )

  004a3	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _iPriority$219245[ebp], 0
  004aa	7c 09		 jl	 SHORT $LN1@LoadData
  004ac	83 bd 78 ff ff
	ff 1e		 cmp	 DWORD PTR _iPriority$219245[ebp], 30 ; 0000001eH
  004b3	7c 1d		 jl	 SHORT $LN2@LoadData
$LN1@LoadData:

; 154  : 					{
; 155  : 						MsgBox("[Monster AI Automata] - Priority(%d) Error (%s) File. ",iPriority, lpszFileName);

  004b5	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  004b8	50		 push	 eax
  004b9	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _iPriority$219245[ebp]
  004bf	51		 push	 ecx
  004c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@
  004c5	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  004ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 						continue;

  004cd	e9 2d fd ff ff	 jmp	 $LN12@LoadData
$LN2@LoadData:

; 157  : 					}
; 158  : 
; 159  : 
; 160  : 					TMonsterAIState * AIState = &TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_AIState[iCurrentState][iPriority];

  004d2	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _iPriority$219245[ebp]
  004d8	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  004de	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iCurrentState$219246[ebp]
  004e4	69 c9 78 0f 00
	00		 imul	 ecx, 3960		; 00000f78H
  004ea	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _iAutomataNumber$219244[ebp]
  004f0	69 d2 e8 7b 00
	00		 imul	 edx, 31720		; 00007be8H
  004f6	8d 8c 0a 08 00
	00 00		 lea	 ecx, DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[edx+ecx+8]
  004fd	03 c8		 add	 ecx, eax
  004ff	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _AIState$219286[ebp], ecx

; 161  : 
; 162  : 					AIState->m_iPriority = iPriority;

  00505	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  0050b	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _iPriority$219245[ebp]
  00511	89 08		 mov	 DWORD PTR [eax], ecx

; 163  : 					AIState->m_iCurrentState = iCurrentState;

  00513	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00519	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iCurrentState$219246[ebp]
  0051f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 164  : 					AIState->m_iNextState = iNextState;

  00522	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00528	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _iNextState$219247[ebp]
  0052e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 165  : 					AIState->m_iTransitionType = iTransitionType;

  00531	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00537	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _iTransitionType$219248[ebp]
  0053d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 166  : 					AIState->m_iTransitionRate = iTransitionRate;

  00540	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00546	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _iTransitionRate$219249[ebp]
  0054c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 167  : 					AIState->m_iTransitionValueType = iTransitionValueType;

  0054f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00555	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _iTransitionValueType$219250[ebp]
  0055b	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 168  : 					AIState->m_iTransitionValue = iTransitionValue;

  0055e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00564	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _iTransitionValue$219251[ebp]
  0056a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 169  : 					AIState->m_iDelayTime = iDelayTime;

  0056d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  00573	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iDelayTime$219252[ebp]
  00579	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 170  : 
; 171  : 					memcpy(AIState->m_szStateTransitionDesc, szStateTransitionDesc, sizeof(szStateTransitionDesc));

  0057c	6a 64		 push	 100			; 00000064H
  0057e	8d 45 80	 lea	 eax, DWORD PTR _szStateTransitionDesc$219243[ebp]
  00581	50		 push	 eax
  00582	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _AIState$219286[ebp]
  00588	83 c1 20	 add	 ecx, 32			; 00000020H
  0058b	51		 push	 ecx
  0058c	e8 00 00 00 00	 call	 _memcpy
  00591	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 
; 173  : 					LogAddC(2,"[Monster AI Automata] Loaded Transition Desc . [ %s ]", AIState->m_szStateTransitionDesc);

  00594	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _AIState$219286[ebp]
  0059a	83 c0 20	 add	 eax, 32			; 00000020H
  0059d	50		 push	 eax
  0059e	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@
  005a3	6a 02		 push	 2
  005a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  005ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 174  : 
; 175  : 					TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_iAutomataNumber = iAutomataNumber;

  005ae	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _iAutomataNumber$219244[ebp]
  005b4	69 c0 e8 7b 00
	00		 imul	 eax, 31720		; 00007be8H
  005ba	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iAutomataNumber$219244[ebp]
  005c0	89 88 04 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax+4], ecx

; 176  : 					TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_AIStateTransCount[iCurrentState]++;

  005c6	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _iAutomataNumber$219244[ebp]
  005cc	69 c0 e8 7b 00
	00		 imul	 eax, 31720		; 00007be8H
  005d2	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iAutomataNumber$219244[ebp]
  005d8	69 c9 e8 7b 00
	00		 imul	 ecx, 31720		; 00007be8H
  005de	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _iCurrentState$219246[ebp]
  005e4	8b 8c 91 c8 7b
	00 00		 mov	 ecx, DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[ecx+edx*4+31688]
  005eb	83 c1 01	 add	 ecx, 1
  005ee	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _iCurrentState$219246[ebp]
  005f4	89 8c 90 c8 7b
	00 00		 mov	 DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax+edx*4+31688], ecx
$LN10@LoadData:

; 177  : 				}
; 178  : 			}

  005fb	e9 ff fb ff ff	 jmp	 $LN12@LoadData
$LN11@LoadData:

; 179  : 		
; 180  : 		}

  00600	e9 c0 fb ff ff	 jmp	 $LN15@LoadData
$LN14@LoadData:

; 181  : 
; 182  : 		fclose(SMDFile);

  00605	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0060a	50		 push	 eax
  0060b	e8 00 00 00 00	 call	 _fclose
  00610	83 c4 04	 add	 esp, 4

; 183  : 		LogAddC(2,"[Monster AI Automata] - %s file is Loaded", lpszFileName);

  00613	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00616	50		 push	 eax
  00617	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@
  0061c	6a 02		 push	 2
  0061e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00624	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 		TMonsterAIAutomata::s_bDataLoad = TRUE;

  00627	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIAutomata@@2HA, 1 ; TMonsterAIAutomata::s_bDataLoad

; 185  : 	}

  00631	eb 1e		 jmp	 SHORT $LN22@LoadData
__catch$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$0:

; 186  : 	catch(...)
; 187  : 	{
; 188  : 		MsgBox("[Monster AI Automata] - Loading Exception Error (%s) File. ", lpszFileName);

  00633	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00636	50		 push	 eax
  00637	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@
  0063c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00641	83 c4 08	 add	 esp, 8

; 189  : 	}

  00644	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0064b	b8 00 00 00 00	 mov	 eax, $LN25@LoadData
  00650	c3		 ret	 0
$LN22@LoadData:
  00651	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN25@LoadData:

; 190  : 
; 191  : 	return FALSE;

  00658	33 c0		 xor	 eax, eax
$LN20@LoadData:

; 192  : }

  0065a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0065d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00664	59		 pop	 ecx
  00665	5f		 pop	 edi
  00666	5e		 pop	 esi
  00667	5b		 pop	 ebx
  00668	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0066b	33 cd		 xor	 ecx, ebp
  0066d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00672	8b e5		 mov	 esp, ebp
  00674	5d		 pop	 ebp
  00675	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterAIAutomata@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 10 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-240]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterAIAutomata@@SAHPAD@Z ENDP		; TMonsterAIAutomata::LoadData
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00680	55		 push	 ebp
  00681	8b ec		 mov	 ebp, esp
  00683	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00689	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0068e	33 c5		 xor	 eax, ebp
  00690	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00693	53		 push	 ebx
  00694	56		 push	 esi
  00695	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00696	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0069d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006a2	50		 push	 eax
  006a3	e8 00 00 00 00	 call	 _fgetc
  006a8	83 c4 04	 add	 esp, 4
  006ab	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  006ae	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006b2	83 f9 ff	 cmp	 ecx, -1
  006b5	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  006b7	b8 02 00 00 00	 mov	 eax, 2
  006bc	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  006c1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  006c3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006c7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  006ca	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  006cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006d1	50		 push	 eax
  006d2	e8 00 00 00 00	 call	 _fgetc
  006d7	83 c4 04	 add	 esp, 4
  006da	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  006dd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006e1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  006e4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  006e6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006ea	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  006ed	74 1c		 je	 SHORT $LN23@GetToken
  006ef	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006f3	83 f8 ff	 cmp	 eax, -1
  006f6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  006f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006fd	50		 push	 eax
  006fe	e8 00 00 00 00	 call	 _fgetc
  00703	83 c4 04	 add	 esp, 4
  00706	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00709	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0070b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0070f	83 f8 ff	 cmp	 eax, -1
  00712	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00714	b8 02 00 00 00	 mov	 eax, 2
  00719	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0071e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00722	50		 push	 eax
  00723	e8 00 00 00 00	 call	 _isspace
  00728	83 c4 04	 add	 esp, 4
  0072b	85 c0		 test	 eax, eax
  0072d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00733	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00737	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0073d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00743	83 e9 22	 sub	 ecx, 34			; 00000022H
  00746	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0074c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00753	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00759	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0075f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00766	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0076d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00777	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0077c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00781	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00786	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00790	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00795	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0079a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0079f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  007a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007ae	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  007b3	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  007b8	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  007c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007c7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  007cc	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  007d1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  007db	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007e0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  007e5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  007ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007ef	50		 push	 eax
  007f0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  007f4	51		 push	 ecx
  007f5	e8 00 00 00 00	 call	 _ungetc
  007fa	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  007fd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00800	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00803	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00808	50		 push	 eax
  00809	e8 00 00 00 00	 call	 _getc
  0080e	83 c4 04	 add	 esp, 4
  00811	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00814	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00818	83 f9 ff	 cmp	 ecx, -1
  0081b	74 36		 je	 SHORT $LN12@GetToken
  0081d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00821	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00824	74 1a		 je	 SHORT $LN11@GetToken
  00826	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0082a	50		 push	 eax
  0082b	e8 00 00 00 00	 call	 _isdigit
  00830	83 c4 04	 add	 esp, 4
  00833	85 c0		 test	 eax, eax
  00835	75 09		 jne	 SHORT $LN11@GetToken
  00837	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0083b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0083e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00840	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00843	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00846	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00848	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0084b	83 c0 01	 add	 eax, 1
  0084e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00851	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00853	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00856	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00859	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0085c	50		 push	 eax
  0085d	e8 00 00 00 00	 call	 _atof
  00862	83 c4 04	 add	 esp, 4
  00865	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0086b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00875	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0087a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0087f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00884	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0088b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00890	50		 push	 eax
  00891	e8 00 00 00 00	 call	 _getc
  00896	83 c4 04	 add	 esp, 4
  00899	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0089c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  008a0	83 f9 ff	 cmp	 ecx, -1
  008a3	74 1c		 je	 SHORT $LN8@GetToken
  008a5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008a9	83 f8 22	 cmp	 eax, 34			; 00000022H
  008ac	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  008ae	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  008b1	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  008b4	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  008b6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  008b9	83 c0 01	 add	 eax, 1
  008bc	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  008bf	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  008c1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008c5	83 f8 22	 cmp	 eax, 34			; 00000022H
  008c8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  008ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  008cf	50		 push	 eax
  008d0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  008d4	51		 push	 ecx
  008d5	e8 00 00 00 00	 call	 _ungetc
  008da	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  008dd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  008e0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  008e3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  008ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  008f2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  008f7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  008fc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00900	50		 push	 eax
  00901	e8 00 00 00 00	 call	 _isalpha
  00906	83 c4 04	 add	 esp, 4
  00909	85 c0		 test	 eax, eax
  0090b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00911	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00918	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0091b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0091e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00920	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00923	83 c0 01	 add	 eax, 1
  00926	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00929	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0092e	50		 push	 eax
  0092f	e8 00 00 00 00	 call	 _getc
  00934	83 c4 04	 add	 esp, 4
  00937	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0093a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0093e	83 f9 ff	 cmp	 ecx, -1
  00941	74 36		 je	 SHORT $LN3@GetToken
  00943	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00947	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0094a	74 1a		 je	 SHORT $LN2@GetToken
  0094c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00950	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00953	74 11		 je	 SHORT $LN2@GetToken
  00955	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00959	50		 push	 eax
  0095a	e8 00 00 00 00	 call	 _isalnum
  0095f	83 c4 04	 add	 esp, 4
  00962	85 c0		 test	 eax, eax
  00964	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00966	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00969	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0096c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0096e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00971	83 c0 01	 add	 eax, 1
  00974	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00977	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00979	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0097e	50		 push	 eax
  0097f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00983	51		 push	 ecx
  00984	e8 00 00 00 00	 call	 _ungetc
  00989	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0098c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0098f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00992	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0099c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  009a1	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  009a3	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  009a5	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  009af	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  009b4	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  009b6	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  009b8	5f		 pop	 edi
  009b9	5e		 pop	 esi
  009ba	5b		 pop	 ebx
  009bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009be	33 cd		 xor	 ecx, ebp
  009c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009c5	8b e5		 mov	 esp, ebp
  009c7	5d		 pop	 ebp
  009c8	c3		 ret	 0
  009c9	8d 49 00	 npad	 3
$LN35@GetToken:
  009cc	00 00 00 00	 DD	 $LN10@GetToken
  009d0	00 00 00 00	 DD	 $LN19@GetToken
  009d4	00 00 00 00	 DD	 $LN17@GetToken
  009d8	00 00 00 00	 DD	 $LN14@GetToken
  009dc	00 00 00 00	 DD	 $LN18@GetToken
  009e0	00 00 00 00	 DD	 $LN16@GetToken
  009e4	00 00 00 00	 DD	 $LN15@GetToken
  009e8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  009ec	00		 DB	 0
  009ed	01		 DB	 1
  009ee	07		 DB	 7
  009ef	07		 DB	 7
  009f0	07		 DB	 7
  009f1	07		 DB	 7
  009f2	07		 DB	 7
  009f3	07		 DB	 7
  009f4	07		 DB	 7
  009f5	07		 DB	 7
  009f6	02		 DB	 2
  009f7	03		 DB	 3
  009f8	03		 DB	 3
  009f9	07		 DB	 7
  009fa	03		 DB	 3
  009fb	03		 DB	 3
  009fc	03		 DB	 3
  009fd	03		 DB	 3
  009fe	03		 DB	 3
  009ff	03		 DB	 3
  00a00	03		 DB	 3
  00a01	03		 DB	 3
  00a02	03		 DB	 3
  00a03	03		 DB	 3
  00a04	07		 DB	 7
  00a05	04		 DB	 4
  00a06	07		 DB	 7
  00a07	07		 DB	 7
  00a08	07		 DB	 7
  00a09	07		 DB	 7
  00a0a	07		 DB	 7
  00a0b	07		 DB	 7
  00a0c	07		 DB	 7
  00a0d	07		 DB	 7
  00a0e	07		 DB	 7
  00a0f	07		 DB	 7
  00a10	07		 DB	 7
  00a11	07		 DB	 7
  00a12	07		 DB	 7
  00a13	07		 DB	 7
  00a14	07		 DB	 7
  00a15	07		 DB	 7
  00a16	07		 DB	 7
  00a17	07		 DB	 7
  00a18	07		 DB	 7
  00a19	07		 DB	 7
  00a1a	07		 DB	 7
  00a1b	07		 DB	 7
  00a1c	07		 DB	 7
  00a1d	07		 DB	 7
  00a1e	07		 DB	 7
  00a1f	07		 DB	 7
  00a20	07		 DB	 7
  00a21	07		 DB	 7
  00a22	07		 DB	 7
  00a23	07		 DB	 7
  00a24	07		 DB	 7
  00a25	07		 DB	 7
  00a26	07		 DB	 7
  00a27	07		 DB	 7
  00a28	07		 DB	 7
  00a29	07		 DB	 7
  00a2a	07		 DB	 7
  00a2b	07		 DB	 7
  00a2c	07		 DB	 7
  00a2d	07		 DB	 7
  00a2e	07		 DB	 7
  00a2f	07		 DB	 7
  00a30	07		 DB	 7
  00a31	07		 DB	 7
  00a32	07		 DB	 7
  00a33	07		 DB	 7
  00a34	07		 DB	 7
  00a35	07		 DB	 7
  00a36	07		 DB	 7
  00a37	07		 DB	 7
  00a38	07		 DB	 7
  00a39	07		 DB	 7
  00a3a	07		 DB	 7
  00a3b	07		 DB	 7
  00a3c	07		 DB	 7
  00a3d	07		 DB	 7
  00a3e	07		 DB	 7
  00a3f	07		 DB	 7
  00a40	07		 DB	 7
  00a41	07		 DB	 7
  00a42	07		 DB	 7
  00a43	07		 DB	 7
  00a44	07		 DB	 7
  00a45	05		 DB	 5
  00a46	07		 DB	 7
  00a47	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraiautomata.cpp
_i$219292 = -4						; size = 4
?DelAllAutomata@TMonsterAIAutomata@@SAHXZ PROC		; TMonsterAIAutomata::DelAllAutomata

; 199  : {

  00a50	55		 push	 ebp
  00a51	8b ec		 mov	 ebp, esp
  00a53	83 ec 44	 sub	 esp, 68			; 00000044H
  00a56	53		 push	 ebx
  00a57	56		 push	 esi
  00a58	57		 push	 edi

; 200  : 	for ( int i =0;i<MAX_MONSTER_AI_AUTOMATA;i++)

  00a59	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$219292[ebp], 0
  00a60	eb 09		 jmp	 SHORT $LN3@DelAllAuto
$LN2@DelAllAuto:
  00a62	8b 45 fc	 mov	 eax, DWORD PTR _i$219292[ebp]
  00a65	83 c0 01	 add	 eax, 1
  00a68	89 45 fc	 mov	 DWORD PTR _i$219292[ebp], eax
$LN3@DelAllAuto:
  00a6b	81 7d fc 2c 01
	00 00		 cmp	 DWORD PTR _i$219292[ebp], 300 ; 0000012cH
  00a72	7d 16		 jge	 SHORT $LN1@DelAllAuto

; 201  : 	{
; 202  : 		TMonsterAIAutomata::s_MonsterAIAutomataArray[i].Reset();

  00a74	8b 4d fc	 mov	 ecx, DWORD PTR _i$219292[ebp]
  00a77	69 c9 e8 7b 00
	00		 imul	 ecx, 31720		; 00007be8H
  00a7d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
  00a83	e8 00 00 00 00	 call	 ?Reset@TMonsterAIAutomata@@QAEXXZ ; TMonsterAIAutomata::Reset

; 203  : 	}

  00a88	eb d8		 jmp	 SHORT $LN2@DelAllAuto
$LN1@DelAllAuto:

; 204  : 
; 205  : 	return FALSE;

  00a8a	33 c0		 xor	 eax, eax

; 206  : }

  00a8c	5f		 pop	 edi
  00a8d	5e		 pop	 esi
  00a8e	5b		 pop	 ebx
  00a8f	8b e5		 mov	 esp, ebp
  00a91	5d		 pop	 ebp
  00a92	c3		 ret	 0
?DelAllAutomata@TMonsterAIAutomata@@SAHXZ ENDP		; TMonsterAIAutomata::DelAllAutomata
_TEXT	ENDS
PUBLIC	??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@ ; `string'
PUBLIC	?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z	; TMonsterAIAutomata::FindAutomata
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@
CONST	SEGMENT
??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@ DB '[Monste'
	DB	'r AI Automata] FindAutomata() Error - (AutomataNumber=%d) ', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iAutomataNumber$ = 8					; size = 4
?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z PROC	; TMonsterAIAutomata::FindAutomata

; 210  : {

  00aa0	55		 push	 ebp
  00aa1	8b ec		 mov	 ebp, esp
  00aa3	83 ec 40	 sub	 esp, 64			; 00000040H
  00aa6	53		 push	 ebx
  00aa7	56		 push	 esi
  00aa8	57		 push	 edi

; 211  : 	if ( iAutomataNumber < 0 || iAutomataNumber >= MAX_MONSTER_AI_AUTOMATA )

  00aa9	83 7d 08 00	 cmp	 DWORD PTR _iAutomataNumber$[ebp], 0
  00aad	7c 09		 jl	 SHORT $LN2@FindAutoma
  00aaf	81 7d 08 2c 01
	00 00		 cmp	 DWORD PTR _iAutomataNumber$[ebp], 300 ; 0000012cH
  00ab6	7c 16		 jl	 SHORT $LN3@FindAutoma
$LN2@FindAutoma:

; 212  : 	{
; 213  : 		LogAddTD("[Monster AI Automata] FindAutomata() Error - (AutomataNumber=%d) ", iAutomataNumber);

  00ab8	8b 45 08	 mov	 eax, DWORD PTR _iAutomataNumber$[ebp]
  00abb	50		 push	 eax
  00abc	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@
  00ac1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ac7	83 c4 08	 add	 esp, 8

; 214  : 		return NULL;

  00aca	33 c0		 xor	 eax, eax
  00acc	eb 38		 jmp	 SHORT $LN4@FindAutoma
$LN3@FindAutoma:

; 215  : 	}
; 216  : 
; 217  : 	if ( TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_iAutomataNumber == iAutomataNumber )

  00ace	8b 45 08	 mov	 eax, DWORD PTR _iAutomataNumber$[ebp]
  00ad1	69 c0 e8 7b 00
	00		 imul	 eax, 31720		; 00007be8H
  00ad7	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax+4]
  00add	3b 4d 08	 cmp	 ecx, DWORD PTR _iAutomataNumber$[ebp]
  00ae0	75 10		 jne	 SHORT $LN1@FindAutoma

; 218  : 	{
; 219  : 		return &TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber];

  00ae2	8b 45 08	 mov	 eax, DWORD PTR _iAutomataNumber$[ebp]
  00ae5	69 c0 e8 7b 00
	00		 imul	 eax, 31720		; 00007be8H
  00aeb	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
  00af0	eb 14		 jmp	 SHORT $LN4@FindAutoma
$LN1@FindAutoma:

; 220  : 	}
; 221  : 	
; 222  : 	LogAddTD("[Monster AI Automata] FindAutomata() Error - (AutomataNumber=%d) ", iAutomataNumber);

  00af2	8b 45 08	 mov	 eax, DWORD PTR _iAutomataNumber$[ebp]
  00af5	50		 push	 eax
  00af6	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@
  00afb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b01	83 c4 08	 add	 esp, 8

; 223  : 
; 224  : 	return NULL;

  00b04	33 c0		 xor	 eax, eax
$LN4@FindAutoma:

; 225  : }

  00b06	5f		 pop	 edi
  00b07	5e		 pop	 esi
  00b08	5b		 pop	 ebx
  00b09	8b e5		 mov	 esp, ebp
  00b0b	5d		 pop	 ebp
  00b0c	c3		 ret	 0
?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z ENDP	; TMonsterAIAutomata::FindAutomata
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z ; TMonsterAIAutomata::RunAutomata
EXTRN	_rand:PROC
EXTRN	?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z:PROC ; TMonsterAIGroup::FindGroupMemberToHeal
EXTRN	?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z:PROC ; TMonsterAIGroup::FindGroupMemberToSommon
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?GetAgro@TMonsterAIAgro@@QAEHH@Z:PROC		; TMonsterAIAgro::GetAgro
EXTRN	?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z:PROC ; TMonsterAIUtil::FindMonViewportObj
EXTRN	?GetMaxAgroUserIndex@TMonsterAIAgro@@QAEHH@Z:PROC ; TMonsterAIAgro::GetMaxAgroUserIndex
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv166 = -116						; size = 4
tv161 = -116						; size = 4
tv135 = -116						; size = 4
tv71 = -116						; size = 4
_iLife$219340 = -48					; size = 4
_bTransition$219323 = -44				; size = 4
_AIState$219322 = -40					; size = 4
_iPriority$219318 = -36					; size = 4
_iMaxStateTransCount$ = -32				; size = 4
_iCurrentState$ = -28					; size = 4
_bRateSuccess$ = -24					; size = 4
_iTargetIndex$ = -20					; size = 4
_iMaxAgro$ = -16					; size = 4
_lpTargetObj$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z PROC ; TMonsterAIAutomata::RunAutomata
; _this$ = ecx

; 230  : {

  00b10	55		 push	 ebp
  00b11	8b ec		 mov	 ebp, esp
  00b13	83 ec 74	 sub	 esp, 116		; 00000074H
  00b16	53		 push	 ebx
  00b17	56		 push	 esi
  00b18	57		 push	 edi
  00b19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  : 	LPOBJ lpObj = &gObj[iIndex];

  00b1c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00b1f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b25	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b2b	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 232  : 
; 233  : 	if ( MAX_AI_STATE_RANGE(lpObj->m_iCurrentAIState) == FALSE )

  00b2e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b31	83 b8 7c 1c 00
	00 00		 cmp	 DWORD PTR [eax+7292], 0
  00b38	7d 09		 jge	 SHORT $LN39@RunAutomat
  00b3a	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00b41	eb 12		 jmp	 SHORT $LN40@RunAutomat
$LN39@RunAutomat:
  00b43	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b46	33 d2		 xor	 edx, edx
  00b48	83 b9 7c 1c 00
	00 07		 cmp	 DWORD PTR [ecx+7292], 7
  00b4f	0f 9e c2	 setle	 dl
  00b52	89 55 8c	 mov	 DWORD PTR tv71[ebp], edx
$LN40@RunAutomat:
  00b55	83 7d 8c 00	 cmp	 DWORD PTR tv71[ebp], 0
  00b59	75 07		 jne	 SHORT $LN36@RunAutomat

; 234  : 		return NULL;

  00b5b	33 c0		 xor	 eax, eax
  00b5d	e9 49 03 00 00	 jmp	 $LN37@RunAutomat
$LN36@RunAutomat:

; 235  : 
; 236  : 	LPOBJ lpTargetObj = NULL;

  00b62	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lpTargetObj$[ebp], 0

; 237  : 	int iMaxAgro = -1;

  00b69	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _iMaxAgro$[ebp], -1

; 238  : 
; 239  : 	int iTargetIndex = lpObj->m_Agro.GetMaxAgroUserIndex(lpObj->m_Index);

  00b70	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b73	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b75	51		 push	 ecx
  00b76	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b79	81 c1 94 1c 00
	00		 add	 ecx, 7316		; 00001c94H
  00b7f	e8 00 00 00 00	 call	 ?GetMaxAgroUserIndex@TMonsterAIAgro@@QAEHH@Z ; TMonsterAIAgro::GetMaxAgroUserIndex
  00b84	89 45 ec	 mov	 DWORD PTR _iTargetIndex$[ebp], eax

; 240  : 
; 241  : 	// Search The user with Max Agro to make its enemy
; 242  : 	if ( iTargetIndex != -1 )

  00b87	83 7d ec ff	 cmp	 DWORD PTR _iTargetIndex$[ebp], -1
  00b8b	74 65		 je	 SHORT $LN33@RunAutomat

; 243  : 	{
; 244  : 		lpTargetObj = &gObj[iTargetIndex];

  00b8d	8b 45 ec	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  00b90	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b96	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b9c	89 45 f4	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 245  : 
; 246  : 		if ( MONSTER_UTIL.FindMonViewportObj(lpObj->m_Index, lpTargetObj->m_Index) )

  00b9f	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ba2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ba4	51		 push	 ecx
  00ba5	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ba8	8b 02		 mov	 eax, DWORD PTR [edx]
  00baa	50		 push	 eax
  00bab	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00bb0	e8 00 00 00 00	 call	 ?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z ; TMonsterAIUtil::FindMonViewportObj
  00bb5	85 c0		 test	 eax, eax
  00bb7	74 25		 je	 SHORT $LN34@RunAutomat

; 247  : 		{
; 248  : 			iMaxAgro = lpObj->m_Agro.GetAgro(iTargetIndex);

  00bb9	8b 45 ec	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  00bbc	50		 push	 eax
  00bbd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bc0	81 c1 94 1c 00
	00		 add	 ecx, 7316		; 00001c94H
  00bc6	e8 00 00 00 00	 call	 ?GetAgro@TMonsterAIAgro@@QAEHH@Z ; TMonsterAIAgro::GetAgro
  00bcb	89 45 f0	 mov	 DWORD PTR _iMaxAgro$[ebp], eax

; 249  : 			lpObj->TargetNumber = iTargetIndex;

  00bce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd1	66 8b 4d ec	 mov	 cx, WORD PTR _iTargetIndex$[ebp]
  00bd5	66 89 88 58 04
	00 00		 mov	 WORD PTR [eax+1112], cx

; 250  : 		}
; 251  : 		else

  00bdc	eb 14		 jmp	 SHORT $LN33@RunAutomat
$LN34@RunAutomat:

; 252  : 		{
; 253  : 			lpObj->TargetNumber = -1;

  00bde	83 c8 ff	 or	 eax, -1
  00be1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00be4	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 254  : 			lpTargetObj = NULL;

  00beb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lpTargetObj$[ebp], 0
$LN33@RunAutomat:

; 255  : 		}
; 256  : 	}
; 257  : 
; 258  : 	BOOL bRateSuccess = FALSE;

  00bf2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bRateSuccess$[ebp], 0

; 259  : 
; 260  : 	int iCurrentState = lpObj->m_iCurrentAIState;

  00bf9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfc	8b 88 7c 1c 00
	00		 mov	 ecx, DWORD PTR [eax+7292]
  00c02	89 4d e4	 mov	 DWORD PTR _iCurrentState$[ebp], ecx

; 261  : 	int iMaxStateTransCount = this->m_AIStateTransCount[iCurrentState];

  00c05	8b 45 e4	 mov	 eax, DWORD PTR _iCurrentState$[ebp]
  00c08	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c0b	8b 94 81 c8 7b
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+31688]
  00c12	89 55 e0	 mov	 DWORD PTR _iMaxStateTransCount$[ebp], edx

; 262  : 
; 263  : 	for ( int iPriority=0;iPriority<iMaxStateTransCount;iPriority++)

  00c15	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iPriority$219318[ebp], 0
  00c1c	eb 09		 jmp	 SHORT $LN32@RunAutomat
$LN31@RunAutomat:
  00c1e	8b 45 dc	 mov	 eax, DWORD PTR _iPriority$219318[ebp]
  00c21	83 c0 01	 add	 eax, 1
  00c24	89 45 dc	 mov	 DWORD PTR _iPriority$219318[ebp], eax
$LN32@RunAutomat:
  00c27	8b 45 dc	 mov	 eax, DWORD PTR _iPriority$219318[ebp]
  00c2a	3b 45 e0	 cmp	 eax, DWORD PTR _iMaxStateTransCount$[ebp]
  00c2d	0f 8d 76 02 00
	00		 jge	 $LN30@RunAutomat

; 264  : 	{
; 265  : 		TMonsterAIState * AIState = &this->m_AIState[iCurrentState][iPriority];

  00c33	8b 45 e4	 mov	 eax, DWORD PTR _iCurrentState$[ebp]
  00c36	69 c0 78 0f 00
	00		 imul	 eax, 3960		; 00000f78H
  00c3c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c3f	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00c43	8b 45 dc	 mov	 eax, DWORD PTR _iPriority$219318[ebp]
  00c46	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  00c4c	03 d0		 add	 edx, eax
  00c4e	89 55 d8	 mov	 DWORD PTR _AIState$219322[ebp], edx

; 266  : 		BOOL bTransition = MAI_STATE_TRANS_VALUE_;	// If there is an apropiate Value it is set to TRUE

  00c51	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 0

; 267  : 
; 268  : 		// Choose the right action according Transation Type 
; 269  : 		switch ( AIState->m_iTransitionType )

  00c58	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00c5b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c5e	89 4d 8c	 mov	 DWORD PTR tv135[ebp], ecx
  00c61	83 7d 8c 0b	 cmp	 DWORD PTR tv135[ebp], 11 ; 0000000bH
  00c65	0f 87 e6 01 00
	00		 ja	 $LN28@RunAutomat
  00c6b	8b 55 8c	 mov	 edx, DWORD PTR tv135[ebp]
  00c6e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN45@RunAutomat[edx*4]
$LN27@RunAutomat:

; 270  : 		{
; 271  : 			case MAI_STATE_TRANS_NO_ENEMY:
; 272  : 				if ( lpTargetObj == NULL )

  00c75	83 7d f4 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00c79	75 07		 jne	 SHORT $LN26@RunAutomat

; 273  : 				{
; 274  : 					bTransition = TRUE;

  00c7b	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN26@RunAutomat:

; 275  : 				}
; 276  : 				break;

  00c82	e9 ca 01 00 00	 jmp	 $LN28@RunAutomat
$LN25@RunAutomat:

; 277  : 
; 278  : 			case MAI_STATE_TRANS_IN_ENEMY:
; 279  : 				if ( lpTargetObj )

  00c87	83 7d f4 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00c8b	74 25		 je	 SHORT $LN23@RunAutomat

; 280  : 				{
; 281  : 					if ( gObjCalDistance(lpObj, lpTargetObj) <= lpObj->m_AttackRange )

  00c8d	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c90	50		 push	 eax
  00c91	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c94	51		 push	 ecx
  00c95	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00c9a	83 c4 08	 add	 esp, 8
  00c9d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ca0	0f bf 8a b0 04
	00 00		 movsx	 ecx, WORD PTR [edx+1200]
  00ca7	3b c1		 cmp	 eax, ecx
  00ca9	7f 07		 jg	 SHORT $LN23@RunAutomat

; 282  : 					{
; 283  : 						bTransition = TRUE;

  00cab	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN23@RunAutomat:

; 284  : 					}
; 285  : 				}
; 286  : 				break;

  00cb2	e9 9a 01 00 00	 jmp	 $LN28@RunAutomat
$LN22@RunAutomat:

; 287  : 
; 288  : 			case MAI_STATE_TRANS_OUT_ENEMY:
; 289  : 				if ( lpTargetObj )

  00cb7	83 7d f4 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00cbb	74 25		 je	 SHORT $LN20@RunAutomat

; 290  : 				{
; 291  : 					if ( gObjCalDistance(lpObj, lpTargetObj) > lpObj->m_AttackRange )

  00cbd	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cc0	50		 push	 eax
  00cc1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cc4	51		 push	 ecx
  00cc5	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00cca	83 c4 08	 add	 esp, 8
  00ccd	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cd0	0f bf 8a b0 04
	00 00		 movsx	 ecx, WORD PTR [edx+1200]
  00cd7	3b c1		 cmp	 eax, ecx
  00cd9	7e 07		 jle	 SHORT $LN20@RunAutomat

; 292  : 					{
; 293  : 						bTransition =  TRUE;

  00cdb	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN20@RunAutomat:

; 294  : 					}
; 295  : 				}
; 296  : 				break;

  00ce2	e9 6a 01 00 00	 jmp	 $LN28@RunAutomat
$LN19@RunAutomat:

; 297  : 
; 298  : 			//case MAI_STATE_TRANS_DIE_ENEMY:
; 299  : 
; 300  : 			case MAI_STATE_TRANS_DEC_HP:
; 301  : 				if ( AIState->m_iTransitionValue > lpObj->Life )

  00ce7	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00cea	db 40 18	 fild	 DWORD PTR [eax+24]
  00ced	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cf0	d9 81 fc 00 00
	00		 fld	 DWORD PTR [ecx+252]
  00cf6	de d9		 fcompp
  00cf8	df e0		 fnstsw	 ax
  00cfa	f6 c4 05	 test	 ah, 5
  00cfd	7a 07		 jp	 SHORT $LN18@RunAutomat

; 302  : 				{
; 303  : 					bTransition = TRUE;

  00cff	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN18@RunAutomat:

; 304  : 				}
; 305  : 				break;

  00d06	e9 46 01 00 00	 jmp	 $LN28@RunAutomat
$LN17@RunAutomat:

; 306  : 
; 307  : 			case MAI_STATE_TRANS_IMMEDIATELY:
; 308  : 				bTransition = TRUE;

  00d0b	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1

; 309  : 				break;

  00d12	e9 3a 01 00 00	 jmp	 $LN28@RunAutomat
$LN16@RunAutomat:

; 310  : 
; 311  : 			case MAI_STATE_TRANS_DEC_HP_PER:
; 312  : 				{
; 313  : 					AIState->m_iTransitionValue = (AIState->m_iTransitionValue > 0)? AIState->m_iTransitionValue : 0;

  00d17	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00d1a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00d1e	7e 0b		 jle	 SHORT $LN41@RunAutomat
  00d20	8b 4d d8	 mov	 ecx, DWORD PTR _AIState$219322[ebp]
  00d23	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00d26	89 55 8c	 mov	 DWORD PTR tv161[ebp], edx
  00d29	eb 07		 jmp	 SHORT $LN42@RunAutomat
$LN41@RunAutomat:
  00d2b	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv161[ebp], 0
$LN42@RunAutomat:
  00d32	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00d35	8b 4d 8c	 mov	 ecx, DWORD PTR tv161[ebp]
  00d38	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 314  : 					AIState->m_iTransitionValue = (AIState->m_iTransitionValue < 100 )? AIState->m_iTransitionValue : 100 ;

  00d3b	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00d3e	83 78 18 64	 cmp	 DWORD PTR [eax+24], 100	; 00000064H
  00d42	7d 0b		 jge	 SHORT $LN43@RunAutomat
  00d44	8b 4d d8	 mov	 ecx, DWORD PTR _AIState$219322[ebp]
  00d47	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00d4a	89 55 8c	 mov	 DWORD PTR tv166[ebp], edx
  00d4d	eb 07		 jmp	 SHORT $LN44@RunAutomat
$LN43@RunAutomat:
  00d4f	c7 45 8c 64 00
	00 00		 mov	 DWORD PTR tv166[ebp], 100 ; 00000064H
$LN44@RunAutomat:
  00d56	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00d59	8b 4d 8c	 mov	 ecx, DWORD PTR tv166[ebp]
  00d5c	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 315  : 					int iLife = (int)(((float)lpObj->AddLife + lpObj->MaxLife) * (float)AIState->m_iTransitionValue / 100.0f);

  00d5f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d62	db 80 4c 01 00
	00		 fild	 DWORD PTR [eax+332]
  00d68	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d6b	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  00d71	8b 55 d8	 mov	 edx, DWORD PTR _AIState$219322[ebp]
  00d74	da 4a 18	 fimul	 DWORD PTR [edx+24]
  00d77	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00d7d	e8 00 00 00 00	 call	 __ftol2_sse
  00d82	89 45 d0	 mov	 DWORD PTR _iLife$219340[ebp], eax

; 316  : 
; 317  : 					if ( iLife > lpObj->Life )

  00d85	db 45 d0	 fild	 DWORD PTR _iLife$219340[ebp]
  00d88	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d8b	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  00d91	de d9		 fcompp
  00d93	df e0		 fnstsw	 ax
  00d95	f6 c4 05	 test	 ah, 5
  00d98	7a 07		 jp	 SHORT $LN15@RunAutomat

; 318  : 					{
; 319  : 						bTransition = TRUE;

  00d9a	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN15@RunAutomat:

; 320  : 					}
; 321  : 				}
; 322  : 				break;

  00da1	e9 ab 00 00 00	 jmp	 $LN28@RunAutomat
$LN14@RunAutomat:

; 323  : 
; 324  : 			case MAI_STATE_TRANS_AGRO_UP:
; 325  : 				if ( lpTargetObj )

  00da6	83 7d f4 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00daa	74 12		 je	 SHORT $LN12@RunAutomat

; 326  : 				{
; 327  : 					if ( iMaxAgro >= AIState->m_iTransitionValue )

  00dac	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00daf	8b 4d f0	 mov	 ecx, DWORD PTR _iMaxAgro$[ebp]
  00db2	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00db5	7c 07		 jl	 SHORT $LN12@RunAutomat

; 328  : 					{
; 329  : 						bTransition = TRUE;

  00db7	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN12@RunAutomat:

; 330  : 					}
; 331  : 				}
; 332  : 				break;

  00dbe	e9 8e 00 00 00	 jmp	 $LN28@RunAutomat
$LN11@RunAutomat:

; 333  : 
; 334  : 			case MAI_STATE_TRANS_AGRO_DOWN:
; 335  : 				if ( lpTargetObj )

  00dc3	83 7d f4 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00dc7	74 12		 je	 SHORT $LN9@RunAutomat

; 336  : 				{
; 337  : 					if ( iMaxAgro <= AIState->m_iTransitionValue )

  00dc9	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00dcc	8b 4d f0	 mov	 ecx, DWORD PTR _iMaxAgro$[ebp]
  00dcf	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00dd2	7f 07		 jg	 SHORT $LN9@RunAutomat

; 338  : 					{
; 339  : 						bTransition = TRUE;

  00dd4	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN9@RunAutomat:

; 340  : 					}
; 341  : 				}
; 342  : 				break;

  00ddb	eb 74		 jmp	 SHORT $LN28@RunAutomat
$LN8@RunAutomat:

; 343  : 
; 344  : 			case MAI_STATE_TRANS_GROUP_SOMMON:
; 345  : 				if ( lpObj->m_iGroupNumber )

  00ddd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de0	83 b8 84 1c 00
	00 00		 cmp	 DWORD PTR [eax+7300], 0
  00de7	74 2d		 je	 SHORT $LN6@RunAutomat

; 346  : 				{
; 347  : 					if ( TMonsterAIGroup::FindGroupMemberToSommon(lpObj->m_Index, lpObj->m_iGroupNumber, lpObj->m_iGroupMemberGuid) )

  00de9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dec	8b 88 8c 1c 00
	00		 mov	 ecx, DWORD PTR [eax+7308]
  00df2	51		 push	 ecx
  00df3	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00df6	8b 82 84 1c 00
	00		 mov	 eax, DWORD PTR [edx+7300]
  00dfc	50		 push	 eax
  00dfd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e00	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e02	52		 push	 edx
  00e03	e8 00 00 00 00	 call	 ?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z ; TMonsterAIGroup::FindGroupMemberToSommon
  00e08	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e0b	85 c0		 test	 eax, eax
  00e0d	74 07		 je	 SHORT $LN6@RunAutomat

; 348  : 					{
; 349  : 						bTransition = TRUE;

  00e0f	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN6@RunAutomat:

; 350  : 					}
; 351  : 				}
; 352  : 
; 353  : 			case MAI_STATE_TRANS_GROUP_HEAL:
; 354  : 				if ( lpObj->m_iGroupNumber )

  00e16	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e19	83 b8 84 1c 00
	00 00		 cmp	 DWORD PTR [eax+7300], 0
  00e20	74 2f		 je	 SHORT $LN3@RunAutomat

; 355  : 				{
; 356  : 					if ( TMonsterAIGroup::FindGroupMemberToHeal(lpObj->m_Index, lpObj->m_iGroupNumber, lpObj->m_iGroupMemberGuid, 5) )

  00e22	6a 05		 push	 5
  00e24	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e27	8b 88 8c 1c 00
	00		 mov	 ecx, DWORD PTR [eax+7308]
  00e2d	51		 push	 ecx
  00e2e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00e31	8b 82 84 1c 00
	00		 mov	 eax, DWORD PTR [edx+7300]
  00e37	50		 push	 eax
  00e38	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e3b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e3d	52		 push	 edx
  00e3e	e8 00 00 00 00	 call	 ?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z ; TMonsterAIGroup::FindGroupMemberToHeal
  00e43	83 c4 10	 add	 esp, 16			; 00000010H
  00e46	85 c0		 test	 eax, eax
  00e48	74 07		 je	 SHORT $LN3@RunAutomat

; 357  : 					{
; 358  : 						bTransition = TRUE;

  00e4a	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bTransition$219323[ebp], 1
$LN3@RunAutomat:
$LN28@RunAutomat:

; 359  : 					}
; 360  : 				}
; 361  : 				break;
; 362  : 		}
; 363  : 
; 364  : 		// If is Wrong State
; 365  : 		if ( bTransition == FALSE )	

  00e51	83 7d d4 00	 cmp	 DWORD PTR _bTransition$219323[ebp], 0
  00e55	75 05		 jne	 SHORT $LN2@RunAutomat

; 366  : 			continue;

  00e57	e9 c2 fd ff ff	 jmp	 $LN31@RunAutomat
$LN2@RunAutomat:

; 367  : 
; 368  : 		if ( (rand()%100) < AIState->m_iTransitionRate )

  00e5c	e8 00 00 00 00	 call	 _rand
  00e61	99		 cdq
  00e62	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00e67	f7 f9		 idiv	 ecx
  00e69	8b 45 d8	 mov	 eax, DWORD PTR _AIState$219322[ebp]
  00e6c	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00e6f	7d 33		 jge	 SHORT $LN1@RunAutomat

; 369  : 		{
; 370  : 			bRateSuccess = TRUE;

  00e71	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bRateSuccess$[ebp], 1

; 371  : 			lpObj->m_iLastAutomataDelay = AIState->m_iDelayTime;

  00e78	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e7b	8b 4d d8	 mov	 ecx, DWORD PTR _AIState$219322[ebp]
  00e7e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00e81	89 90 bc 1f 00
	00		 mov	 DWORD PTR [eax+8124], edx

; 372  : 			return &this->m_AIState[iCurrentState][iPriority];

  00e87	8b 45 e4	 mov	 eax, DWORD PTR _iCurrentState$[ebp]
  00e8a	69 c0 78 0f 00
	00		 imul	 eax, 3960		; 00000f78H
  00e90	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e93	8d 44 01 08	 lea	 eax, DWORD PTR [ecx+eax+8]
  00e97	8b 55 dc	 mov	 edx, DWORD PTR _iPriority$219318[ebp]
  00e9a	69 d2 84 00 00
	00		 imul	 edx, 132		; 00000084H
  00ea0	03 c2		 add	 eax, edx
  00ea2	eb 07		 jmp	 SHORT $LN37@RunAutomat
$LN1@RunAutomat:

; 373  : 		}
; 374  : 	}

  00ea4	e9 75 fd ff ff	 jmp	 $LN31@RunAutomat
$LN30@RunAutomat:

; 375  : 
; 376  : 	return NULL;

  00ea9	33 c0		 xor	 eax, eax
$LN37@RunAutomat:

; 377  : }

  00eab	5f		 pop	 edi
  00eac	5e		 pop	 esi
  00ead	5b		 pop	 ebx
  00eae	8b e5		 mov	 esp, ebp
  00eb0	5d		 pop	 ebp
  00eb1	c2 04 00	 ret	 4
$LN45@RunAutomat:
  00eb4	00 00 00 00	 DD	 $LN27@RunAutomat
  00eb8	00 00 00 00	 DD	 $LN25@RunAutomat
  00ebc	00 00 00 00	 DD	 $LN22@RunAutomat
  00ec0	00 00 00 00	 DD	 $LN28@RunAutomat
  00ec4	00 00 00 00	 DD	 $LN19@RunAutomat
  00ec8	00 00 00 00	 DD	 $LN16@RunAutomat
  00ecc	00 00 00 00	 DD	 $LN17@RunAutomat
  00ed0	00 00 00 00	 DD	 $LN14@RunAutomat
  00ed4	00 00 00 00	 DD	 $LN11@RunAutomat
  00ed8	00 00 00 00	 DD	 $LN28@RunAutomat
  00edc	00 00 00 00	 DD	 $LN8@RunAutomat
  00ee0	00 00 00 00	 DD	 $LN6@RunAutomat
?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z ENDP ; TMonsterAIAutomata::RunAutomata
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ
text$yc	SEGMENT
??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterAIAutomata::s_MonsterAIAutomataArray'', COMDAT

; 14   : TMonsterAIAutomata TMonsterAIAutomata::s_MonsterAIAutomataArray[MAX_MONSTER_AI_AUTOMATA];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIAutomata@@UAE@XZ ; TMonsterAIAutomata::~TMonsterAIAutomata
  0000e	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIAutomata@@QAE@XZ ; TMonsterAIAutomata::TMonsterAIAutomata
  00013	68 2c 01 00 00	 push	 300			; 0000012cH
  00018	68 e8 7b 00 00	 push	 31720			; 00007be8H
  0001d	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
  00022	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00027	68 00 00 00 00	 push	 OFFSET ??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ; `dynamic atexit destructor for 'TMonsterAIAutomata::s_MonsterAIAutomataArray''
  0002c	e8 00 00 00 00	 call	 _atexit
  00031	83 c4 04	 add	 esp, 4
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterAIAutomata::s_MonsterAIAutomataArray''
text$yc	ENDS
EXTRN	??0TMonsterAIUtil@@QAE@XZ:PROC			; TMonsterAIUtil::TMonsterAIUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__EMONSTER_UTIL@@YAXXZ
text$yc	SEGMENT
??__EMONSTER_UTIL@@YAXXZ PROC				; `dynamic initializer for 'MONSTER_UTIL'', COMDAT

; 15   : static TMonsterAIUtil MONSTER_UTIL;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  0000e	e8 00 00 00 00	 call	 ??0TMonsterAIUtil@@QAE@XZ ; TMonsterAIUtil::TMonsterAIUtil
  00013	68 00 00 00 00	 push	 OFFSET ??__FMONSTER_UTIL@@YAXXZ ; `dynamic atexit destructor for 'MONSTER_UTIL''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EMONSTER_UTIL@@YAXXZ ENDP				; `dynamic initializer for 'MONSTER_UTIL''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ
text$yd	SEGMENT
??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ PROC ; `dynamic atexit destructor for 'TMonsterAIAutomata::s_MonsterAIAutomataArray'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIAutomata@@UAE@XZ ; TMonsterAIAutomata::~TMonsterAIAutomata
  0000e	68 2c 01 00 00	 push	 300			; 0000012cH
  00013	68 e8 7b 00 00	 push	 31720			; 00007be8H
  00018	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
  0001d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'TMonsterAIAutomata::s_MonsterAIAutomataArray''
text$yd	ENDS
EXTRN	??1TMonsterAIUtil@@UAE@XZ:PROC			; TMonsterAIUtil::~TMonsterAIUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FMONSTER_UTIL@@YAXXZ
text$yd	SEGMENT
??__FMONSTER_UTIL@@YAXXZ PROC				; `dynamic atexit destructor for 'MONSTER_UTIL'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  0000e	e8 00 00 00 00	 call	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FMONSTER_UTIL@@YAXXZ ENDP				; `dynamic atexit destructor for 'MONSTER_UTIL''
text$yd	ENDS
PUBLIC	?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
_BSS	SEGMENT
_MONSTER_UTIL DD 01H DUP (?)
?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A DB 09133e0H DUP (?) ; TMonsterAIAutomata::s_MonsterAIAutomataArray
_BSS	ENDS
CRT$XCU	SEGMENT
?s_MonsterAIAutomataArray$initializer$@TMonsterAIAutomata@@2P6AXXZA DD FLAT:??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ; TMonsterAIAutomata::s_MonsterAIAutomataArray$initializer$
_MONSTER_UTIL$initializer$ DD FLAT:??__EMONSTER_UTIL@@YAXXZ
CRT$XCU	ENDS
END
