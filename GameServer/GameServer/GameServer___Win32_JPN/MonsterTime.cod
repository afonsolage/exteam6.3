; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MonsterTime.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Init@CMonsterTime@@QAEXXZ			; CMonsterTime::Init
PUBLIC	??0CMonsterTime@@QAE@XZ				; CMonsterTime::CMonsterTime
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstertime.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMonsterTime@@QAE@XZ PROC				; CMonsterTime::CMonsterTime
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 18   : 	this->Init();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Init@CMonsterTime@@QAEXXZ ; CMonsterTime::Init

; 19   : }

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CMonsterTime@@QAE@XZ ENDP				; CMonsterTime::CMonsterTime
_TEXT	ENDS
PUBLIC	??1CMonsterTime@@QAE@XZ				; CMonsterTime::~CMonsterTime
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMonsterTime@@QAE@XZ PROC				; CMonsterTime::~CMonsterTime
; _this$ = ecx

; 22   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1CMonsterTime@@QAE@XZ ENDP				; CMonsterTime::~CMonsterTime
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CMonsterTime@@QAEXXZ PROC				; CMonsterTime::Init
; _this$ = ecx

; 26   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 	this->m_Enable = 0;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : 	this->m_LoadCount = 0;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 29   : 	this->m_LoadPos = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 30   : 
; 31   : 	this->m_Loaded = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 32   : 
; 33   : 	memset(this->m_Info, 0, sizeof(this->m_Info));

  00073	68 f0 0a 00 00	 push	 2800			; 00000af0H
  00078	6a 00		 push	 0
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 c0 10	 add	 eax, 16			; 00000010H
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _memset
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 34   : 	memset(this->m_Data, -1, sizeof(this->m_Data));

  00089	68 b0 04 00 00	 push	 1200			; 000004b0H
  0008e	6a ff		 push	 -1
  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	05 00 0b 00 00	 add	 eax, 2816		; 00000b00H
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memset
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?Init@CMonsterTime@@QAEXXZ ENDP				; CMonsterTime::Init
_TEXT	ENDS
PUBLIC	?Read@CMonsterTime@@QAEXPAD@Z			; CMonsterTime::Read
PUBLIC	??_C@_0BH@LCPGLKEB@ExData?2MonsterTime?4ini?$AA@ ; `string'
PUBLIC	?Load@CMonsterTime@@QAEXXZ			; CMonsterTime::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0BH@LCPGLKEB@ExData?2MonsterTime?4ini?$AA@
CONST	SEGMENT
??_C@_0BH@LCPGLKEB@ExData?2MonsterTime?4ini?$AA@ DB 'ExData\MonsterTime.i'
	DB	'ni', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CMonsterTime@@QAEXXZ PROC				; CMonsterTime::Load
; _this$ = ecx

; 38   : {

  000b0	55		 push	 ebp
  000b1	8b ec		 mov	 ebp, esp
  000b3	83 ec 44	 sub	 esp, 68			; 00000044H
  000b6	53		 push	 ebx
  000b7	56		 push	 esi
  000b8	57		 push	 edi
  000b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 	if(this->m_Loaded)

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000c3	74 02		 je	 SHORT $LN1@Load

; 40   : 	{
; 41   : 		return;

  000c5	eb 42		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 42   : 	}
; 43   : 
; 44   : 	this->m_LoadCount = 0;

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 45   : 
; 46   : 	this->m_Loaded = 0;

  000d1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 47   : 
; 48   : 	memset(this->m_Info, 0, sizeof(this->m_Info));

  000db	68 f0 0a 00 00	 push	 2800			; 00000af0H
  000e0	6a 00		 push	 0
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	83 c0 10	 add	 eax, 16			; 00000010H
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _memset
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 49   : 
; 50   : 	this->Read(gDirPath.GetNewPath("ExData\\MonsterTime.ini"));

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCPGLKEB@ExData?2MonsterTime?4ini?$AA@
  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000fb	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00100	50		 push	 eax
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?Read@CMonsterTime@@QAEXPAD@Z ; CMonsterTime::Read
$LN2@Load:

; 51   : }

  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
?Load@CMonsterTime@@QAEXXZ ENDP				; CMonsterTime::Load
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iType$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Read@CMonsterTime@@QAEXPAD@Z PROC			; CMonsterTime::Read
; _this$ = ecx

; 54   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00116	53		 push	 ebx
  00117	56		 push	 esi
  00118	57		 push	 edi
  00119	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   : 	SMDFile = fopen(filename, "r");

  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00121	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _fopen
  0012a	83 c4 08	 add	 esp, 8
  0012d	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 56   : 
; 57   : 	if(SMDFile == NULL)

  00132	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00139	75 22		 jne	 SHORT $LN13@Read

; 58   : 	{
; 59   : 		LogAdd(lMsg.Get(MSGGET(1, 198)), filename);

  0013b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0013e	50		 push	 eax
  0013f	68 c6 01 00 00	 push	 454			; 000001c6H
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00149	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00155	83 c4 08	 add	 esp, 8

; 60   : 		return;

  00158	e9 ee 01 00 00	 jmp	 $LN14@Read
$LN13@Read:

; 61   : 	}
; 62   : 
; 63   : 	SMDToken Token;
; 64   : 
; 65   : 	int iType = -1;

  0015d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iType$[ebp], -1
$LN12@Read:

; 66   : 
; 67   : 	while(true)

  00164	b8 01 00 00 00	 mov	 eax, 1
  00169	85 c0		 test	 eax, eax
  0016b	0f 84 b0 01 00
	00		 je	 $LN11@Read

; 68   : 	{
; 69   : 		Token = GetToken();

  00171	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00176	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 70   : 
; 71   :         if(Token == END)

  00179	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0017d	75 05		 jne	 SHORT $LN10@Read

; 72   : 		{
; 73   :             break;

  0017f	e9 9d 01 00 00	 jmp	 $LN11@Read
$LN10@Read:

; 74   : 		}
; 75   : 
; 76   : 		iType = (int)TokenNumber;

  00184	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0018a	e8 00 00 00 00	 call	 __ftol2_sse
  0018f	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 77   : 
; 78   : 		if(iType < 0 || iType > 1)

  00192	83 7d f4 00	 cmp	 DWORD PTR _iType$[ebp], 0
  00196	7c 06		 jl	 SHORT $LN8@Read
  00198	83 7d f4 01	 cmp	 DWORD PTR _iType$[ebp], 1
  0019c	7e 05		 jle	 SHORT $LN9@Read
$LN8@Read:

; 79   : 		{
; 80   : 			break;

  0019e	e9 7e 01 00 00	 jmp	 $LN11@Read
$LN9@Read:

; 81   : 		}
; 82   : 
; 83   : 		while(true)

  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	85 c0		 test	 eax, eax
  001aa	0f 84 6c 01 00
	00		 je	 $LN6@Read

; 84   : 		{
; 85   : 			if(iType == 0)

  001b0	83 7d f4 00	 cmp	 DWORD PTR _iType$[ebp], 0
  001b4	75 38		 jne	 SHORT $LN5@Read

; 86   : 			{
; 87   : 				Token = GetToken();

  001b6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001bb	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 88   : 
; 89   : 				if(!strcmp("end", TokenString))

  001be	68 00 00 00 00	 push	 OFFSET _TokenString
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  001c8	e8 00 00 00 00	 call	 _strcmp
  001cd	83 c4 08	 add	 esp, 8
  001d0	85 c0		 test	 eax, eax
  001d2	75 05		 jne	 SHORT $LN4@Read

; 90   : 				{
; 91   : 					break;

  001d4	e9 43 01 00 00	 jmp	 $LN6@Read
$LN4@Read:

; 92   : 				}
; 93   : 
; 94   : 				this->m_Enable = (int)TokenNumber;

  001d9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001df	e8 00 00 00 00	 call	 __ftol2_sse
  001e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	89 01		 mov	 DWORD PTR [ecx], eax
  001e9	e9 29 01 00 00	 jmp	 $LN2@Read
$LN5@Read:

; 95   : 			}
; 96   : 			else if(iType == 1)

  001ee	83 7d f4 01	 cmp	 DWORD PTR _iType$[ebp], 1
  001f2	0f 85 1f 01 00
	00		 jne	 $LN2@Read

; 97   : 			{
; 98   : 				Token = GetToken();

  001f8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001fd	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 99   : 
; 100  : 				if(!strcmp("end", TokenString))

  00200	68 00 00 00 00	 push	 OFFSET _TokenString
  00205	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0020a	e8 00 00 00 00	 call	 _strcmp
  0020f	83 c4 08	 add	 esp, 8
  00212	85 c0		 test	 eax, eax
  00214	75 05		 jne	 SHORT $LN1@Read

; 101  : 				{
; 102  : 					break;

  00216	e9 01 01 00 00	 jmp	 $LN6@Read
$LN1@Read:

; 103  : 				}
; 104  : 
; 105  : 				this->m_Info[this->m_LoadCount].Class = TokenNumber;

  0021b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00221	e8 00 00 00 00	 call	 __ftol2_sse
  00226	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0022c	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0022f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 106  : 
; 107  : 				Token = GetToken();

  00236	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0023b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 108  : 				this->m_Info[this->m_LoadCount].MapNumber = TokenNumber;

  0023e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00244	e8 00 00 00 00	 call	 __ftol2_sse
  00249	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0024f	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00252	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00255	89 44 11 14	 mov	 DWORD PTR [ecx+edx+20], eax

; 109  : 
; 110  : 				Token = GetToken();

  00259	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0025e	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 111  : 				this->m_Info[this->m_LoadCount].MapX = TokenNumber;

  00261	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00267	e8 00 00 00 00	 call	 __ftol2_sse
  0026c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00272	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00275	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00278	89 44 11 18	 mov	 DWORD PTR [ecx+edx+24], eax

; 112  : 
; 113  : 				Token = GetToken();

  0027c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00281	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 114  : 				this->m_Info[this->m_LoadCount].MapY = TokenNumber;

  00284	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0028a	e8 00 00 00 00	 call	 __ftol2_sse
  0028f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00292	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00295	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00298	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029b	89 44 11 1c	 mov	 DWORD PTR [ecx+edx+28], eax

; 115  : 
; 116  : 				Token = GetToken();

  0029f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002a4	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 117  : 				this->m_Info[this->m_LoadCount].Day = TokenNumber;

  002a7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002ad	e8 00 00 00 00	 call	 __ftol2_sse
  002b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b8	6b d2 1c	 imul	 edx, 28			; 0000001cH
  002bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002be	89 44 11 20	 mov	 DWORD PTR [ecx+edx+32], eax

; 118  : 
; 119  : 				Token = GetToken();

  002c2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002c7	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 120  : 				this->m_Info[this->m_LoadCount].Hour = TokenNumber;

  002ca	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002d0	e8 00 00 00 00	 call	 __ftol2_sse
  002d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002db	6b d2 1c	 imul	 edx, 28			; 0000001cH
  002de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e1	89 44 11 24	 mov	 DWORD PTR [ecx+edx+36], eax

; 121  : 
; 122  : 				Token = GetToken();

  002e5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002ea	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 123  : 				this->m_Info[this->m_LoadCount].Minute = TokenNumber;

  002ed	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002f3	e8 00 00 00 00	 call	 __ftol2_sse
  002f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002fb	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002fe	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00301	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00304	89 44 11 28	 mov	 DWORD PTR [ecx+edx+40], eax

; 124  : 
; 125  : 				this->m_LoadCount++;

  00308	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0030b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0030e	83 c1 01	 add	 ecx, 1
  00311	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00314	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN2@Read:

; 126  : 			}
; 127  : 		}

  00317	e9 87 fe ff ff	 jmp	 $LN9@Read
$LN6@Read:

; 128  : 	}

  0031c	e9 43 fe ff ff	 jmp	 $LN12@Read
$LN11@Read:

; 129  : 
; 130  : 	fclose(SMDFile);

  00321	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _fclose
  0032c	83 c4 04	 add	 esp, 4

; 131  : 
; 132  : 	LogAdd("%s file load!", filename);

  0032f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00332	50		 push	 eax
  00333	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00338	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0033e	83 c4 08	 add	 esp, 8

; 133  : 
; 134  : 	this->m_Loaded = 1;

  00341	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00344	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1
$LN14@Read:

; 135  : }

  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5b		 pop	 ebx
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c2 04 00	 ret	 4
?Read@CMonsterTime@@QAEXPAD@Z ENDP			; CMonsterTime::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00360	55		 push	 ebp
  00361	8b ec		 mov	 ebp, esp
  00363	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00369	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0036e	33 c5		 xor	 eax, ebp
  00370	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00373	53		 push	 ebx
  00374	56		 push	 esi
  00375	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00376	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0037d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00382	50		 push	 eax
  00383	e8 00 00 00 00	 call	 _fgetc
  00388	83 c4 04	 add	 esp, 4
  0038b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0038e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00392	83 f9 ff	 cmp	 ecx, -1
  00395	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00397	b8 02 00 00 00	 mov	 eax, 2
  0039c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  003a1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  003a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003a7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  003aa	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  003ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003b1	50		 push	 eax
  003b2	e8 00 00 00 00	 call	 _fgetc
  003b7	83 c4 04	 add	 esp, 4
  003ba	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  003bd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003c1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  003c4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  003c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003ca	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  003cd	74 1c		 je	 SHORT $LN23@GetToken
  003cf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003d3	83 f8 ff	 cmp	 eax, -1
  003d6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  003d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003dd	50		 push	 eax
  003de	e8 00 00 00 00	 call	 _fgetc
  003e3	83 c4 04	 add	 esp, 4
  003e6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  003e9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  003eb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003ef	83 f8 ff	 cmp	 eax, -1
  003f2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  003f4	b8 02 00 00 00	 mov	 eax, 2
  003f9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  003fe	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00402	50		 push	 eax
  00403	e8 00 00 00 00	 call	 _isspace
  00408	83 c4 04	 add	 esp, 4
  0040b	85 c0		 test	 eax, eax
  0040d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00413	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00417	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0041d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00423	83 e9 22	 sub	 ecx, 34			; 00000022H
  00426	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0042c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00433	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00439	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0043f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00446	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0044d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00457	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0045c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00461	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00466	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00470	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00475	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0047a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0047f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00489	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0048e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00493	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00498	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  004a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004a7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  004ac	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  004b1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  004bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004c0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  004c5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  004ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004cf	50		 push	 eax
  004d0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004d4	51		 push	 ecx
  004d5	e8 00 00 00 00	 call	 _ungetc
  004da	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  004dd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  004e0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  004e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004e8	50		 push	 eax
  004e9	e8 00 00 00 00	 call	 _getc
  004ee	83 c4 04	 add	 esp, 4
  004f1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004f4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004f8	83 f9 ff	 cmp	 ecx, -1
  004fb	74 36		 je	 SHORT $LN12@GetToken
  004fd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00501	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00504	74 1a		 je	 SHORT $LN11@GetToken
  00506	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0050a	50		 push	 eax
  0050b	e8 00 00 00 00	 call	 _isdigit
  00510	83 c4 04	 add	 esp, 4
  00513	85 c0		 test	 eax, eax
  00515	75 09		 jne	 SHORT $LN11@GetToken
  00517	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0051b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0051e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00520	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00523	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00526	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00528	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0052b	83 c0 01	 add	 eax, 1
  0052e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00531	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00533	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00536	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00539	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0053c	50		 push	 eax
  0053d	e8 00 00 00 00	 call	 _atof
  00542	83 c4 04	 add	 esp, 4
  00545	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0054b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00555	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0055a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0055f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00564	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0056b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00570	50		 push	 eax
  00571	e8 00 00 00 00	 call	 _getc
  00576	83 c4 04	 add	 esp, 4
  00579	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0057c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00580	83 f9 ff	 cmp	 ecx, -1
  00583	74 1c		 je	 SHORT $LN8@GetToken
  00585	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00589	83 f8 22	 cmp	 eax, 34			; 00000022H
  0058c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0058e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00591	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00594	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00596	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00599	83 c0 01	 add	 eax, 1
  0059c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0059f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  005a1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005a5	83 f8 22	 cmp	 eax, 34			; 00000022H
  005a8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  005aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005af	50		 push	 eax
  005b0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005b4	51		 push	 ecx
  005b5	e8 00 00 00 00	 call	 _ungetc
  005ba	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  005bd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  005c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  005cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005d2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  005d7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  005dc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 _isalpha
  005e6	83 c4 04	 add	 esp, 4
  005e9	85 c0		 test	 eax, eax
  005eb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  005f1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  005f8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005fb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005fe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00600	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00603	83 c0 01	 add	 eax, 1
  00606	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00609	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0060e	50		 push	 eax
  0060f	e8 00 00 00 00	 call	 _getc
  00614	83 c4 04	 add	 esp, 4
  00617	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0061a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0061e	83 f9 ff	 cmp	 ecx, -1
  00621	74 36		 je	 SHORT $LN3@GetToken
  00623	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00627	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0062a	74 1a		 je	 SHORT $LN2@GetToken
  0062c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00630	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00633	74 11		 je	 SHORT $LN2@GetToken
  00635	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00639	50		 push	 eax
  0063a	e8 00 00 00 00	 call	 _isalnum
  0063f	83 c4 04	 add	 esp, 4
  00642	85 c0		 test	 eax, eax
  00644	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00646	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00649	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0064c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0064e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00651	83 c0 01	 add	 eax, 1
  00654	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00657	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00659	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0065e	50		 push	 eax
  0065f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00663	51		 push	 ecx
  00664	e8 00 00 00 00	 call	 _ungetc
  00669	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0066c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0066f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00672	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0067c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00681	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00683	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00685	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0068f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00694	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00696	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00698	5f		 pop	 edi
  00699	5e		 pop	 esi
  0069a	5b		 pop	 ebx
  0069b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0069e	33 cd		 xor	 ecx, ebp
  006a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a5	8b e5		 mov	 esp, ebp
  006a7	5d		 pop	 ebp
  006a8	c3		 ret	 0
  006a9	8d 49 00	 npad	 3
$LN35@GetToken:
  006ac	00 00 00 00	 DD	 $LN10@GetToken
  006b0	00 00 00 00	 DD	 $LN19@GetToken
  006b4	00 00 00 00	 DD	 $LN17@GetToken
  006b8	00 00 00 00	 DD	 $LN14@GetToken
  006bc	00 00 00 00	 DD	 $LN18@GetToken
  006c0	00 00 00 00	 DD	 $LN16@GetToken
  006c4	00 00 00 00	 DD	 $LN15@GetToken
  006c8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  006cc	00		 DB	 0
  006cd	01		 DB	 1
  006ce	07		 DB	 7
  006cf	07		 DB	 7
  006d0	07		 DB	 7
  006d1	07		 DB	 7
  006d2	07		 DB	 7
  006d3	07		 DB	 7
  006d4	07		 DB	 7
  006d5	07		 DB	 7
  006d6	02		 DB	 2
  006d7	03		 DB	 3
  006d8	03		 DB	 3
  006d9	07		 DB	 7
  006da	03		 DB	 3
  006db	03		 DB	 3
  006dc	03		 DB	 3
  006dd	03		 DB	 3
  006de	03		 DB	 3
  006df	03		 DB	 3
  006e0	03		 DB	 3
  006e1	03		 DB	 3
  006e2	03		 DB	 3
  006e3	03		 DB	 3
  006e4	07		 DB	 7
  006e5	04		 DB	 4
  006e6	07		 DB	 7
  006e7	07		 DB	 7
  006e8	07		 DB	 7
  006e9	07		 DB	 7
  006ea	07		 DB	 7
  006eb	07		 DB	 7
  006ec	07		 DB	 7
  006ed	07		 DB	 7
  006ee	07		 DB	 7
  006ef	07		 DB	 7
  006f0	07		 DB	 7
  006f1	07		 DB	 7
  006f2	07		 DB	 7
  006f3	07		 DB	 7
  006f4	07		 DB	 7
  006f5	07		 DB	 7
  006f6	07		 DB	 7
  006f7	07		 DB	 7
  006f8	07		 DB	 7
  006f9	07		 DB	 7
  006fa	07		 DB	 7
  006fb	07		 DB	 7
  006fc	07		 DB	 7
  006fd	07		 DB	 7
  006fe	07		 DB	 7
  006ff	07		 DB	 7
  00700	07		 DB	 7
  00701	07		 DB	 7
  00702	07		 DB	 7
  00703	07		 DB	 7
  00704	07		 DB	 7
  00705	07		 DB	 7
  00706	07		 DB	 7
  00707	07		 DB	 7
  00708	07		 DB	 7
  00709	07		 DB	 7
  0070a	07		 DB	 7
  0070b	07		 DB	 7
  0070c	07		 DB	 7
  0070d	07		 DB	 7
  0070e	07		 DB	 7
  0070f	07		 DB	 7
  00710	07		 DB	 7
  00711	07		 DB	 7
  00712	07		 DB	 7
  00713	07		 DB	 7
  00714	07		 DB	 7
  00715	07		 DB	 7
  00716	07		 DB	 7
  00717	07		 DB	 7
  00718	07		 DB	 7
  00719	07		 DB	 7
  0071a	07		 DB	 7
  0071b	07		 DB	 7
  0071c	07		 DB	 7
  0071d	07		 DB	 7
  0071e	07		 DB	 7
  0071f	07		 DB	 7
  00720	07		 DB	 7
  00721	07		 DB	 7
  00722	07		 DB	 7
  00723	07		 DB	 7
  00724	07		 DB	 7
  00725	05		 DB	 5
  00726	07		 DB	 7
  00727	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?AddMonster@CMonsterTime@@QAEXHH@Z		; CMonsterTime::AddMonster
PUBLIC	__$ArrayPad$
PUBLIC	?Run@CMonsterTime@@QAEXXZ			; CMonsterTime::Run
EXTRN	?GetSecond@CTimerEx@@QAEHXZ:PROC		; CTimerEx::GetSecond
EXTRN	?g_TimerEx@@3VCTimerEx@@A:DWORD			; g_TimerEx
EXTRN	__imp__GetLocalTime@4:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstertime.cpp
_TEXT	SEGMENT
_i$228154 = -28						; size = 4
_systime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Run@CMonsterTime@@QAEXXZ PROC				; CMonsterTime::Run
; _this$ = ecx

; 138  : {

  00730	55		 push	 ebp
  00731	8b ec		 mov	 ebp, esp
  00733	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00736	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0073b	33 c5		 xor	 eax, ebp
  0073d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00740	53		 push	 ebx
  00741	56		 push	 esi
  00742	57		 push	 edi
  00743	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 	if(!this->m_Enable)

  00746	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00749	83 38 00	 cmp	 DWORD PTR [eax], 0
  0074c	75 05		 jne	 SHORT $LN9@Run

; 140  : 	{
; 141  : 		return;

  0074e	e9 b4 00 00 00	 jmp	 $LN10@Run
$LN9@Run:

; 142  : 	}
; 143  : 
; 144  : 	SYSTEMTIME systime;
; 145  : 	GetLocalTime(&systime);

  00753	8d 45 e8	 lea	 eax, DWORD PTR _systime$[ebp]
  00756	50		 push	 eax
  00757	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 146  : 
; 147  : 	for(int i = 0; i < this->m_LoadCount; i++)

  0075d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$228154[ebp], 0
  00764	eb 09		 jmp	 SHORT $LN8@Run
$LN7@Run:
  00766	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  00769	83 c0 01	 add	 eax, 1
  0076c	89 45 e4	 mov	 DWORD PTR _i$228154[ebp], eax
$LN8@Run:
  0076f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00772	8b 4d e4	 mov	 ecx, DWORD PTR _i$228154[ebp]
  00775	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00778	0f 8d 89 00 00
	00		 jge	 $LN10@Run

; 148  : 	{
; 149  : 		if(g_TimerEx.GetSecond() == 0)

  0077e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TimerEx@@3VCTimerEx@@A ; g_TimerEx
  00783	e8 00 00 00 00	 call	 ?GetSecond@CTimerEx@@QAEHXZ ; CTimerEx::GetSecond
  00788	85 c0		 test	 eax, eax
  0078a	75 76		 jne	 SHORT $LN5@Run

; 150  : 		{
; 151  : 			if(this->m_Info[i].Day == -1 || this->m_Info[i].Day == systime.wDay)

  0078c	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  0078f	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00792	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00795	83 7c 01 20 ff	 cmp	 DWORD PTR [ecx+eax+32], -1
  0079a	74 13		 je	 SHORT $LN3@Run
  0079c	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  0079f	6b c0 1c	 imul	 eax, 28			; 0000001cH
  007a2	0f b7 4d ee	 movzx	 ecx, WORD PTR _systime$[ebp+6]
  007a6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007a9	39 4c 02 20	 cmp	 DWORD PTR [edx+eax+32], ecx
  007ad	75 53		 jne	 SHORT $LN5@Run
$LN3@Run:

; 152  : 			{
; 153  : 				if(this->m_Info[i].Hour == systime.wHour && this->m_Info[i].Minute == systime.wMinute)

  007af	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  007b2	6b c0 1c	 imul	 eax, 28			; 0000001cH
  007b5	0f b7 4d f0	 movzx	 ecx, WORD PTR _systime$[ebp+8]
  007b9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007bc	39 4c 02 24	 cmp	 DWORD PTR [edx+eax+36], ecx
  007c0	75 40		 jne	 SHORT $LN5@Run
  007c2	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  007c5	6b c0 1c	 imul	 eax, 28			; 0000001cH
  007c8	0f b7 4d f2	 movzx	 ecx, WORD PTR _systime$[ebp+10]
  007cc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007cf	39 4c 02 28	 cmp	 DWORD PTR [edx+eax+40], ecx
  007d3	75 2d		 jne	 SHORT $LN5@Run

; 154  : 				{
; 155  : 					if(this->m_Data[i].Index == -1)

  007d5	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  007d8	6b c0 0c	 imul	 eax, 12			; 0000000cH
  007db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007de	83 bc 01 04 0b
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+2820], -1
  007e6	75 1a		 jne	 SHORT $LN5@Run

; 156  : 					{
; 157  : 						this->AddMonster(i, this->m_Info[i].MapNumber);

  007e8	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  007eb	6b c0 1c	 imul	 eax, 28			; 0000001cH
  007ee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007f1	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  007f5	52		 push	 edx
  007f6	8b 45 e4	 mov	 eax, DWORD PTR _i$228154[ebp]
  007f9	50		 push	 eax
  007fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007fd	e8 00 00 00 00	 call	 ?AddMonster@CMonsterTime@@QAEXHH@Z ; CMonsterTime::AddMonster
$LN5@Run:

; 158  : 					}
; 159  : 				}		
; 160  : 			}
; 161  : 		}
; 162  : 	}

  00802	e9 5f ff ff ff	 jmp	 $LN7@Run
$LN10@Run:

; 163  : }

  00807	5f		 pop	 edi
  00808	5e		 pop	 esi
  00809	5b		 pop	 ebx
  0080a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0080d	33 cd		 xor	 ecx, ebp
  0080f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00814	8b e5		 mov	 esp, ebp
  00816	5d		 pop	 ebp
  00817	c3		 ret	 0
?Run@CMonsterTime@@QAEXXZ ENDP				; CMonsterTime::Run
_TEXT	ENDS
PUBLIC	?GetMonsterPos@CMonsterTime@@QAEHGEEE@Z		; CMonsterTime::GetMonsterPos
PUBLIC	?LoadMonsterPos@CMonsterTime@@QAEXXZ		; CMonsterTime::LoadMonsterPos
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iPos$228172 = -12					; size = 4
_i$228167 = -8						; size = 4
_this$ = -4						; size = 4
?LoadMonsterPos@CMonsterTime@@QAEXXZ PROC		; CMonsterTime::LoadMonsterPos
; _this$ = ecx

; 166  : {

  00820	55		 push	 ebp
  00821	8b ec		 mov	 ebp, esp
  00823	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00826	53		 push	 ebx
  00827	56		 push	 esi
  00828	57		 push	 edi
  00829	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 167  : 	if(!this->m_Enable)

  0082c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0082f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00832	75 05		 jne	 SHORT $LN6@LoadMonste

; 168  : 	{
; 169  : 		return;

  00834	e9 d8 00 00 00	 jmp	 $LN7@LoadMonste
$LN6@LoadMonste:

; 170  : 	}
; 171  : 
; 172  : 	for(int i = 0; i < this->m_LoadCount; i++)

  00839	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$228167[ebp], 0
  00840	eb 09		 jmp	 SHORT $LN5@LoadMonste
$LN4@LoadMonste:
  00842	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  00845	83 c0 01	 add	 eax, 1
  00848	89 45 f8	 mov	 DWORD PTR _i$228167[ebp], eax
$LN5@LoadMonste:
  0084b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0084e	8b 4d f8	 mov	 ecx, DWORD PTR _i$228167[ebp]
  00851	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00854	0f 8d ad 00 00
	00		 jge	 $LN3@LoadMonste

; 173  : 	{
; 174  : 		if(this->m_Data[i].Index == -1)

  0085a	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  0085d	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00860	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00863	83 bc 01 04 0b
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+2820], -1
  0086b	0f 85 91 00 00
	00		 jne	 $LN2@LoadMonste

; 175  : 		{
; 176  : 			int iPos = this->GetMonsterPos(this->m_Info[i].Class, this->m_Info[i].MapNumber, this->m_Info[i].MapX, this->m_Info[i].MapY);

  00871	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  00874	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00877	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0087a	0f b6 54 01 1c	 movzx	 edx, BYTE PTR [ecx+eax+28]
  0087f	52		 push	 edx
  00880	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  00883	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00886	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00889	0f b6 54 01 18	 movzx	 edx, BYTE PTR [ecx+eax+24]
  0088e	52		 push	 edx
  0088f	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  00892	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00895	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00898	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  0089d	52		 push	 edx
  0089e	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  008a1	6b c0 1c	 imul	 eax, 28			; 0000001cH
  008a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008a7	0f b7 54 01 10	 movzx	 edx, WORD PTR [ecx+eax+16]
  008ac	52		 push	 edx
  008ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008b0	e8 00 00 00 00	 call	 ?GetMonsterPos@CMonsterTime@@QAEHGEEE@Z ; CMonsterTime::GetMonsterPos
  008b5	89 45 f4	 mov	 DWORD PTR _iPos$228172[ebp], eax

; 177  : 
; 178  : 			if(iPos >= 0)

  008b8	83 7d f4 00	 cmp	 DWORD PTR _iPos$228172[ebp], 0
  008bc	7c 44		 jl	 SHORT $LN2@LoadMonste

; 179  : 			{
; 180  : 				this->m_Data[i].Class = this->m_Info[i].Class;

  008be	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  008c1	6b c0 1c	 imul	 eax, 28			; 0000001cH
  008c4	8b 4d f8	 mov	 ecx, DWORD PTR _i$228167[ebp]
  008c7	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  008ca	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008cd	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  008d0	8b 44 06 10	 mov	 eax, DWORD PTR [esi+eax+16]
  008d4	89 84 0a 00 0b
	00 00		 mov	 DWORD PTR [edx+ecx+2816], eax

; 181  : 				this->m_Data[i].Index = -1;

  008db	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  008de	6b c0 0c	 imul	 eax, 12			; 0000000cH
  008e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008e4	c7 84 01 04 0b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+2820], -1

; 182  : 				this->m_Data[i].Pos = iPos;

  008ef	8b 45 f8	 mov	 eax, DWORD PTR _i$228167[ebp]
  008f2	6b c0 0c	 imul	 eax, 12			; 0000000cH
  008f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008f8	8b 55 f4	 mov	 edx, DWORD PTR _iPos$228172[ebp]
  008fb	89 94 01 08 0b
	00 00		 mov	 DWORD PTR [ecx+eax+2824], edx
$LN2@LoadMonste:

; 183  : 			}
; 184  : 		}
; 185  : 	}

  00902	e9 3b ff ff ff	 jmp	 $LN4@LoadMonste
$LN3@LoadMonste:

; 186  : 
; 187  : 	this->m_LoadPos = true;

  00907	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0090a	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$LN7@LoadMonste:

; 188  : }

  00911	5f		 pop	 edi
  00912	5e		 pop	 esi
  00913	5b		 pop	 ebx
  00914	8b e5		 mov	 esp, ebp
  00916	5d		 pop	 ebp
  00917	c3		 ret	 0
?LoadMonsterPos@CMonsterTime@@QAEXXZ ENDP		; CMonsterTime::LoadMonsterPos
_TEXT	ENDS
PUBLIC	??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@ ; `string'
PUBLIC	??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0ED@NJNOAHDD@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
PUBLIC	?__LINE__Var@?1??GetMonsterPos@CMonsterTime@@QAEHGEEE@Z@4JA ; `CMonsterTime::GetMonsterPos'::`2'::__LINE__Var
EXTRN	_rand:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?CheckMapCanMove@CMapServerManager@@QAEHH@Z:PROC ; CMapServerManager::CheckMapCanMove
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
;	COMDAT ??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@
CONST	SEGMENT
??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@ DB '[Atta'
	DB	'ckerAdd] No need to load monster for map %d [%d,%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ DB 'Monst'
	DB	'er attribute max over %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@NJNOAHDD@d?3?2projects?2exteam6?43?2source?2gam@
CONST	SEGMENT
??_C@_0ED@NJNOAHDD@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\monstertime.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetMonsterPos@CMonsterTime@@QAEHGEEE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetMonsterPos@CMonsterTime@@QAEHGEEE@Z@4JA DD 0bfH ; `CMonsterTime::GetMonsterPos'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Type$ = 8						; size = 2
_Map$ = 12						; size = 1
_X$ = 16						; size = 1
_Y$ = 20						; size = 1
?GetMonsterPos@CMonsterTime@@QAEHGEEE@Z PROC		; CMonsterTime::GetMonsterPos
; _this$ = ecx

; 191  : {

  00920	55		 push	 ebp
  00921	8b ec		 mov	 ebp, esp
  00923	83 ec 44	 sub	 esp, 68			; 00000044H
  00926	53		 push	 ebx
  00927	56		 push	 esi
  00928	57		 push	 edi
  00929	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  : 	if(gMSetBase.m_Count >= OBJ_MAXMONSTER-1)

  0092c	81 3d 84 2c 03
	00 c7 32 00 00	 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, 12999 ; 000032c7H
  00936	7c 23		 jl	 SHORT $LN2@GetMonster

; 193  : 	{
; 194  : 		MsgBox("Monster attribute max over %s %d", __FILE__, __LINE__);

  00938	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??GetMonsterPos@CMonsterTime@@QAEHGEEE@Z@4JA
  0093d	83 c0 03	 add	 eax, 3
  00940	50		 push	 eax
  00941	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@NJNOAHDD@d?3?2projects?2exteam6?43?2source?2gam@
  00946	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
  0094b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00950	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  : 		return -1;

  00953	83 c8 ff	 or	 eax, -1
  00956	e9 f7 00 00 00	 jmp	 $LN3@GetMonster
$LN2@GetMonster:

; 196  : 	}
; 197  : 
; 198  : 	if(g_MapServerManager.CheckMapCanMove(Map) == FALSE)

  0095b	0f b6 45 0c	 movzx	 eax, BYTE PTR _Map$[ebp]
  0095f	50		 push	 eax
  00960	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  00965	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  0096a	85 c0		 test	 eax, eax
  0096c	75 2c		 jne	 SHORT $LN1@GetMonster

; 199  : 	{
; 200  : 		LogAddC(3,"[AttackerAdd] No need to load monster for map %d [%d,%d,%d]",Map,Type,X,Y);

  0096e	0f b6 45 14	 movzx	 eax, BYTE PTR _Y$[ebp]
  00972	50		 push	 eax
  00973	0f b6 4d 10	 movzx	 ecx, BYTE PTR _X$[ebp]
  00977	51		 push	 ecx
  00978	0f b7 55 08	 movzx	 edx, WORD PTR _Type$[ebp]
  0097c	52		 push	 edx
  0097d	0f b6 45 0c	 movzx	 eax, BYTE PTR _Map$[ebp]
  00981	50		 push	 eax
  00982	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@
  00987	6a 03		 push	 3
  00989	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0098f	83 c4 18	 add	 esp, 24			; 00000018H

; 201  : 		return -1;

  00992	83 c8 ff	 or	 eax, -1
  00995	e9 b8 00 00 00	 jmp	 $LN3@GetMonster
$LN1@GetMonster:

; 202  : 	}
; 203  : 
; 204  : 	gMSetBase.m_Count++;

  0099a	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  0099f	83 c0 01	 add	 eax, 1
  009a2	a3 84 2c 03 00	 mov	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, eax

; 205  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Dis			= 5;

  009a7	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  009ac	c1 e0 04	 shl	 eax, 4
  009af	c6 80 09 00 00
	00 05		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+9], 5

; 206  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Type		= Type;

  009b6	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  009bb	c1 e0 04	 shl	 eax, 4
  009be	66 8b 4d 08	 mov	 cx, WORD PTR _Type$[ebp]
  009c2	66 89 88 06 00
	00 00		 mov	 WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6], cx

; 207  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_MapNumber	= Map;

  009c9	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  009ce	c1 e0 04	 shl	 eax, 4
  009d1	8a 4d 0c	 mov	 cl, BYTE PTR _Map$[ebp]
  009d4	88 88 08 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8], cl

; 208  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_W			= X;

  009da	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  009df	c1 e0 04	 shl	 eax, 4
  009e2	8a 4d 10	 mov	 cl, BYTE PTR _X$[ebp]
  009e5	88 88 0d 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+13], cl

; 209  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_H			= Y;

  009eb	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  009f0	c1 e0 04	 shl	 eax, 4
  009f3	8a 4d 14	 mov	 cl, BYTE PTR _Y$[ebp]
  009f6	88 88 0e 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+14], cl

; 210  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_X			= X;

  009fc	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  00a01	c1 e0 04	 shl	 eax, 4
  00a04	8a 4d 10	 mov	 cl, BYTE PTR _X$[ebp]
  00a07	88 88 0a 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10], cl

; 211  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Y			= Y;

  00a0d	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  00a12	c1 e0 04	 shl	 eax, 4
  00a15	8a 4d 14	 mov	 cl, BYTE PTR _Y$[ebp]
  00a18	88 88 0b 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+11], cl

; 212  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_ArrangeType = 0;

  00a1e	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  00a23	c1 e0 04	 shl	 eax, 4
  00a26	c6 80 04 00 00
	00 00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+4], 0

; 213  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Dir			= rand() % 8;

  00a2d	e8 00 00 00 00	 call	 _rand
  00a32	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00a37	79 05		 jns	 SHORT $LN5@GetMonster
  00a39	48		 dec	 eax
  00a3a	83 c8 f8	 or	 eax, -8			; fffffff8H
  00a3d	40		 inc	 eax
$LN5@GetMonster:
  00a3e	8b 0d 84 2c 03
	00		 mov	 ecx, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  00a44	c1 e1 04	 shl	 ecx, 4
  00a47	88 81 0c 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[ecx+12], al

; 214  : 
; 215  : 	return gMSetBase.m_Count;

  00a4d	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
$LN3@GetMonster:

; 216  : }

  00a52	5f		 pop	 edi
  00a53	5e		 pop	 esi
  00a54	5b		 pop	 ebx
  00a55	8b e5		 mov	 esp, ebp
  00a57	5d		 pop	 ebp
  00a58	c2 10 00	 ret	 16			; 00000010H
?GetMonsterPos@CMonsterTime@@QAEHGEEE@Z ENDP		; CMonsterTime::GetMonsterPos
_TEXT	ENDS
PUBLIC	??_C@_0BA@OKOLABGC@Attack?5?$CFs?5in?5?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	_sprintf:PROC
EXTRN	?exMapName@@YAPADH@Z:PROC			; exMapName
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
;	COMDAT ??_C@_0BA@OKOLABGC@Attack?5?$CFs?5in?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@OKOLABGC@Attack?5?$CFs?5in?5?$CFs?$AA@ DB 'Attack %s in %s', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szMsg$ = -144						; size = 128
_lpMonsterAttr$ = -16					; size = 4
_iMobIndex$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Num$ = 8						; size = 4
_Map$ = 12						; size = 4
?AddMonster@CMonsterTime@@QAEXHH@Z PROC			; CMonsterTime::AddMonster
; _this$ = ecx

; 219  : {

  00a60	55		 push	 ebp
  00a61	8b ec		 mov	 ebp, esp
  00a63	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00a69	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00a6e	33 c5		 xor	 eax, ebp
  00a70	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00a73	53		 push	 ebx
  00a74	56		 push	 esi
  00a75	57		 push	 edi
  00a76	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 	int iMobIndex = gObjAddMonster(Map);

  00a79	8b 45 0c	 mov	 eax, DWORD PTR _Map$[ebp]
  00a7c	50		 push	 eax
  00a7d	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00a82	83 c4 04	 add	 esp, 4
  00a85	0f bf c8	 movsx	 ecx, ax
  00a88	89 4d f4	 mov	 DWORD PTR _iMobIndex$[ebp], ecx

; 221  : 
; 222  : 	if(iMobIndex < 0 || iMobIndex > OBJ_MAXMONSTER)

  00a8b	83 7d f4 00	 cmp	 DWORD PTR _iMobIndex$[ebp], 0
  00a8f	7c 09		 jl	 SHORT $LN1@AddMonster
  00a91	81 7d f4 c8 32
	00 00		 cmp	 DWORD PTR _iMobIndex$[ebp], 13000 ; 000032c8H
  00a98	7e 05		 jle	 SHORT $LN2@AddMonster
$LN1@AddMonster:

; 223  : 	{
; 224  : 		return;

  00a9a	e9 bc 00 00 00	 jmp	 $LN3@AddMonster
$LN2@AddMonster:

; 225  : 	}
; 226  : 
; 227  : 	this->m_Data[Num].Index = iMobIndex;

  00a9f	8b 45 08	 mov	 eax, DWORD PTR _Num$[ebp]
  00aa2	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00aa5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa8	8b 55 f4	 mov	 edx, DWORD PTR _iMobIndex$[ebp]
  00aab	89 94 01 04 0b
	00 00		 mov	 DWORD PTR [ecx+eax+2820], edx

; 228  : 
; 229  : 	gObjSetPosMonster(this->m_Data[Num].Index, this->m_Data[Num].Pos);

  00ab2	8b 45 08	 mov	 eax, DWORD PTR _Num$[ebp]
  00ab5	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00ab8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00abb	8b 94 01 08 0b
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2824]
  00ac2	52		 push	 edx
  00ac3	8b 45 08	 mov	 eax, DWORD PTR _Num$[ebp]
  00ac6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00ac9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00acc	8b 94 01 04 0b
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2820]
  00ad3	52		 push	 edx
  00ad4	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  00ad9	83 c4 08	 add	 esp, 8

; 230  : 	gObjSetMonster(this->m_Data[Num].Index, this->m_Data[Num].Class);

  00adc	8b 45 08	 mov	 eax, DWORD PTR _Num$[ebp]
  00adf	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00ae2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae5	8b 94 01 00 0b
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2816]
  00aec	52		 push	 edx
  00aed	8b 45 08	 mov	 eax, DWORD PTR _Num$[ebp]
  00af0	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00af3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00af6	8b 94 01 04 0b
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2820]
  00afd	52		 push	 edx
  00afe	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00b03	83 c4 08	 add	 esp, 8

; 231  : 
; 232  : 	LPMONSTER_ATTRIBUTE lpMonsterAttr = gMAttr.GetAttr(this->m_Data[Num].Class);

  00b06	8b 45 08	 mov	 eax, DWORD PTR _Num$[ebp]
  00b09	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00b0c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0f	8b 94 01 00 0b
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2816]
  00b16	52		 push	 edx
  00b17	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00b1c	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00b21	89 45 f0	 mov	 DWORD PTR _lpMonsterAttr$[ebp], eax

; 233  : 
; 234  : 	char szMsg[128];
; 235  : 	sprintf(szMsg, "Attack %s in %s", lpMonsterAttr->m_Name, exMapName(Map));

  00b24	8b 45 0c	 mov	 eax, DWORD PTR _Map$[ebp]
  00b27	50		 push	 eax
  00b28	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  00b2d	83 c4 04	 add	 esp, 4
  00b30	50		 push	 eax
  00b31	8b 4d f0	 mov	 ecx, DWORD PTR _lpMonsterAttr$[ebp]
  00b34	83 c1 08	 add	 ecx, 8
  00b37	51		 push	 ecx
  00b38	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OKOLABGC@Attack?5?$CFs?5in?5?$CFs?$AA@
  00b3d	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  00b43	52		 push	 edx
  00b44	e8 00 00 00 00	 call	 _sprintf
  00b49	83 c4 10	 add	 esp, 16			; 00000010H

; 236  : 	AllSendServerMsg(szMsg);

  00b4c	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00b52	50		 push	 eax
  00b53	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00b58	83 c4 04	 add	 esp, 4
$LN3@AddMonster:

; 237  : }

  00b5b	5f		 pop	 edi
  00b5c	5e		 pop	 esi
  00b5d	5b		 pop	 ebx
  00b5e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b61	33 cd		 xor	 ecx, ebp
  00b63	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b68	8b e5		 mov	 esp, ebp
  00b6a	5d		 pop	 ebp
  00b6b	c2 08 00	 ret	 8
?AddMonster@CMonsterTime@@QAEXHH@Z ENDP			; CMonsterTime::AddMonster
_TEXT	ENDS
PUBLIC	??_C@_0BD@PMPJDMDG@?$CFs?5killed?5?$CFs?5in?5?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DieMonster@CMonsterTime@@QAEXHH@Z		; CMonsterTime::DieMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?ProccessItemDrop@cBossRewardItem@@QAE_NPAUOBJECTSTRUCT@@@Z:PROC ; cBossRewardItem::ProccessItemDrop
EXTRN	?gBossRewardItem@@3VcBossRewardItem@@A:BYTE	; gBossRewardItem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BD@PMPJDMDG@?$CFs?5killed?5?$CFs?5in?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@PMPJDMDG@?$CFs?5killed?5?$CFs?5in?5?$CFs?$AA@ DB '%s killed %s '
	DB	'in %s', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv73 = -220						; size = 4
tv68 = -220						; size = 4
_szMsg$228214 = -152					; size = 128
_lpMonsterAttr$228213 = -24				; size = 4
_i$228208 = -20						; size = 4
_lpMonster$ = -16					; size = 4
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aMonsterIndex$ = 12					; size = 4
?DieMonster@CMonsterTime@@QAEXHH@Z PROC			; CMonsterTime::DieMonster
; _this$ = ecx

; 240  : {

  00b70	55		 push	 ebp
  00b71	8b ec		 mov	 ebp, esp
  00b73	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00b79	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00b7e	33 c5		 xor	 eax, ebp
  00b80	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00b83	53		 push	 ebx
  00b84	56		 push	 esi
  00b85	57		 push	 edi
  00b86	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 241  : 	if(!this->m_Enable)

  00b89	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00b8c	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b8f	75 05		 jne	 SHORT $LN8@DieMonster

; 242  : 	{
; 243  : 		return;

  00b91	e9 60 01 00 00	 jmp	 $LN9@DieMonster
$LN8@DieMonster:

; 244  : 	}
; 245  : 
; 246  : 	if(!OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(aMonsterIndex))

  00b96	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00b9a	7d 0c		 jge	 SHORT $LN11@DieMonster
  00b9c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00ba6	eb 12		 jmp	 SHORT $LN12@DieMonster
$LN11@DieMonster:
  00ba8	33 c0		 xor	 eax, eax
  00baa	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00bb1	0f 9e c0	 setle	 al
  00bb4	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN12@DieMonster:
  00bba	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  00bc1	74 2d		 je	 SHORT $LN6@DieMonster
  00bc3	83 7d 0c 00	 cmp	 DWORD PTR _aMonsterIndex$[ebp], 0
  00bc7	7d 0c		 jge	 SHORT $LN13@DieMonster
  00bc9	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
  00bd3	eb 12		 jmp	 SHORT $LN14@DieMonster
$LN13@DieMonster:
  00bd5	33 c0		 xor	 eax, eax
  00bd7	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aMonsterIndex$[ebp], 14999 ; 00003a97H
  00bde	0f 9e c0	 setle	 al
  00be1	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
$LN14@DieMonster:
  00be7	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv73[ebp], 0
  00bee	75 05		 jne	 SHORT $LN7@DieMonster
$LN6@DieMonster:

; 247  : 	{
; 248  : 		return;

  00bf0	e9 01 01 00 00	 jmp	 $LN9@DieMonster
$LN7@DieMonster:

; 249  : 	}
; 250  : 
; 251  : 	LPOBJ lpUser = &gObj[aIndex];

  00bf5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bf8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00bfe	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c04	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 252  : 	LPOBJ lpMonster = &gObj[aMonsterIndex];

  00c07	8b 45 0c	 mov	 eax, DWORD PTR _aMonsterIndex$[ebp]
  00c0a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00c10	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c16	89 45 f0	 mov	 DWORD PTR _lpMonster$[ebp], eax

; 253  : 
; 254  : 	for(int i = 0; i < MAX_MONSTERTIME; i++)

  00c19	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$228208[ebp], 0
  00c20	eb 09		 jmp	 SHORT $LN5@DieMonster
$LN4@DieMonster:
  00c22	8b 45 ec	 mov	 eax, DWORD PTR _i$228208[ebp]
  00c25	83 c0 01	 add	 eax, 1
  00c28	89 45 ec	 mov	 DWORD PTR _i$228208[ebp], eax
$LN5@DieMonster:
  00c2b	83 7d ec 64	 cmp	 DWORD PTR _i$228208[ebp], 100 ; 00000064H
  00c2f	0f 8d c1 00 00
	00		 jge	 $LN9@DieMonster

; 255  : 	{
; 256  : 		if(aMonsterIndex == this->m_Data[i].Index)

  00c35	8b 45 ec	 mov	 eax, DWORD PTR _i$228208[ebp]
  00c38	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00c3b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c3e	8b 55 0c	 mov	 edx, DWORD PTR _aMonsterIndex$[ebp]
  00c41	3b 94 01 04 0b
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+2820]
  00c48	0f 85 a3 00 00
	00		 jne	 $LN2@DieMonster

; 257  : 		{
; 258  : 			LPMONSTER_ATTRIBUTE lpMonsterAttr = gMAttr.GetAttr(lpMonster->Class);

  00c4e	8b 45 f0	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00c51	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00c58	51		 push	 ecx
  00c59	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00c5e	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00c63	89 45 e8	 mov	 DWORD PTR _lpMonsterAttr$228213[ebp], eax

; 259  : 
; 260  : 			char szMsg[128];
; 261  : 			sprintf(szMsg, "%s killed %s in %s", lpMonsterAttr->m_Name, lpUser->Name, exMapName(lpMonster->MapNumber));

  00c66	8b 45 f0	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00c69	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00c70	51		 push	 ecx
  00c71	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  00c76	83 c4 04	 add	 esp, 4
  00c79	50		 push	 eax
  00c7a	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00c7d	83 c2 77	 add	 edx, 119		; 00000077H
  00c80	52		 push	 edx
  00c81	8b 45 e8	 mov	 eax, DWORD PTR _lpMonsterAttr$228213[ebp]
  00c84	83 c0 08	 add	 eax, 8
  00c87	50		 push	 eax
  00c88	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMPJDMDG@?$CFs?5killed?5?$CFs?5in?5?$CFs?$AA@
  00c8d	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$228214[ebp]
  00c93	51		 push	 ecx
  00c94	e8 00 00 00 00	 call	 _sprintf
  00c99	83 c4 14	 add	 esp, 20			; 00000014H

; 262  : 			AllSendServerMsg(szMsg);

  00c9c	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$228214[ebp]
  00ca2	50		 push	 eax
  00ca3	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00ca8	83 c4 04	 add	 esp, 4

; 263  : 
; 264  : #ifdef BOSS_REWARD_ITEM
; 265  : 			if(gBossRewardItem.ProccessItemDrop(lpMonster))

  00cab	8b 45 f0	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00cae	50		 push	 eax
  00caf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBossRewardItem@@3VcBossRewardItem@@A ; gBossRewardItem
  00cb4	e8 00 00 00 00	 call	 ?ProccessItemDrop@cBossRewardItem@@QAE_NPAUOBJECTSTRUCT@@@Z ; cBossRewardItem::ProccessItemDrop
  00cb9	0f b6 c8	 movzx	 ecx, al
  00cbc	85 c9		 test	 ecx, ecx
  00cbe	74 02		 je	 SHORT $LN1@DieMonster

; 266  : 				return;

  00cc0	eb 34		 jmp	 SHORT $LN9@DieMonster
$LN1@DieMonster:

; 267  : #endif
; 268  : 			gObjDel(this->m_Data[i].Index);

  00cc2	8b 45 ec	 mov	 eax, DWORD PTR _i$228208[ebp]
  00cc5	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00cc8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ccb	8b 94 01 04 0b
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2820]
  00cd2	52		 push	 edx
  00cd3	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00cd8	83 c4 04	 add	 esp, 4

; 269  : 			this->m_Data[i].Index = -1;

  00cdb	8b 45 ec	 mov	 eax, DWORD PTR _i$228208[ebp]
  00cde	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00ce1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce4	c7 84 01 04 0b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+2820], -1

; 270  : 			
; 271  : 			return;

  00cef	eb 05		 jmp	 SHORT $LN9@DieMonster
$LN2@DieMonster:

; 272  : 		}
; 273  : 	}

  00cf1	e9 2c ff ff ff	 jmp	 $LN4@DieMonster
$LN9@DieMonster:

; 274  : }

  00cf6	5f		 pop	 edi
  00cf7	5e		 pop	 esi
  00cf8	5b		 pop	 ebx
  00cf9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cfc	33 cd		 xor	 ecx, ebp
  00cfe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d03	8b e5		 mov	 esp, ebp
  00d05	5d		 pop	 ebp
  00d06	c2 08 00	 ret	 8
?DieMonster@CMonsterTime@@QAEXHH@Z ENDP			; CMonsterTime::DieMonster
_TEXT	ENDS
PUBLIC	?ReloadMonster@CMonsterTime@@QAEXXZ		; CMonsterTime::ReloadMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReloadMonster@CMonsterTime@@QAEXXZ PROC		; CMonsterTime::ReloadMonster
; _this$ = ecx

; 277  : {

  00d10	55		 push	 ebp
  00d11	8b ec		 mov	 ebp, esp
  00d13	83 ec 44	 sub	 esp, 68			; 00000044H
  00d16	53		 push	 ebx
  00d17	56		 push	 esi
  00d18	57		 push	 edi
  00d19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  : 	//if(!this->m_Enable)
; 279  : 	//{
; 280  : 	//	return;
; 281  : 	//}
; 282  : 
; 283  : 	//for(int i = 0; i < MAX_MONSTERTIME; i++)
; 284  : 	//{
; 285  : 	//	if(this->m_Data[i].Index == -1)
; 286  : 	//	{
; 287  : 	//		continue;
; 288  : 	//	}
; 289  : 
; 290  : 	//	this->AddMonster(i, false);
; 291  : 	//}
; 292  : }

  00d1c	5f		 pop	 edi
  00d1d	5e		 pop	 esi
  00d1e	5b		 pop	 ebx
  00d1f	8b e5		 mov	 esp, ebp
  00d21	5d		 pop	 ebp
  00d22	c3		 ret	 0
?ReloadMonster@CMonsterTime@@QAEXXZ ENDP		; CMonsterTime::ReloadMonster
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Eg_MonsterTime@@YAXXZ
text$yc	SEGMENT
??__Eg_MonsterTime@@YAXXZ PROC				; `dynamic initializer for 'g_MonsterTime'', COMDAT

; 14   : CMonsterTime g_MonsterTime;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterTime@@3VCMonsterTime@@A ; g_MonsterTime
  0000e	e8 00 00 00 00	 call	 ??0CMonsterTime@@QAE@XZ	; CMonsterTime::CMonsterTime
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MonsterTime@@YAXXZ ; `dynamic atexit destructor for 'g_MonsterTime''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MonsterTime@@YAXXZ ENDP				; `dynamic initializer for 'g_MonsterTime''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_MonsterTime@@YAXXZ
text$yd	SEGMENT
??__Fg_MonsterTime@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MonsterTime'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterTime@@3VCMonsterTime@@A ; g_MonsterTime
  0000e	e8 00 00 00 00	 call	 ??1CMonsterTime@@QAE@XZ	; CMonsterTime::~CMonsterTime
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MonsterTime@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MonsterTime''
text$yd	ENDS
PUBLIC	?g_MonsterTime@@3VCMonsterTime@@A		; g_MonsterTime
_BSS	SEGMENT
?g_MonsterTime@@3VCMonsterTime@@A DB 0fb0H DUP (?)	; g_MonsterTime
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MonsterTime$initializer$ DD FLAT:??__Eg_MonsterTime@@YAXXZ
CRT$XCU	ENDS
END
