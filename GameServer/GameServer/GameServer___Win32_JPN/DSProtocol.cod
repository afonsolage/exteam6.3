; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\DSProtocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?dwCrywolfSyncLogTickCount@@3KA			; dwCrywolfSyncLogTickCount
_BSS	SEGMENT
?dwCrywolfSyncLogTickCount@@3KA DD 01H DUP (?)		; dwCrywolfSyncLogTickCount
_BSS	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GDGetWarehouseNumber@@YAXPAULOADWAREHOUSENUMBER_SAVE@@@Z ; GDGetWarehouseNumber
PUBLIC	?DSBanSystem@@YAXPAUBAN_CHAR_DS@@@Z		; DSBanSystem
PUBLIC	?DGUpdateExtendedWarehouseResult@@YAXPAUSDHP_ANS_SET_EXTENDEDWAREHOUSE_COUNT@@@Z ; DGUpdateExtendedWarehouseResult
PUBLIC	?DGUpdateExtendedInvenCountResult@@YAXPAUSDHP_ANS_SET_EXTENDEDINVEN_COUNT@@@Z ; DGUpdateExtendedInvenCountResult
PUBLIC	??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@ ; `string'
PUBLIC	?DGSummonerStateRecv@@YAXPAUPMSG_ANS_SUMMONER_STATUS@@@Z ; DGSummonerStateRecv
PUBLIC	?DGSummonerStateUpdatedSend@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z ; DGSummonerStateUpdatedSend
PUBLIC	?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ; DGMoveOtherServer
PUBLIC	?DGAnsCrywolfInfoSave@@YAXPAE@Z			; DGAnsCrywolfInfoSave
PUBLIC	?DGAnsCrywolfInfoLoad@@YAXPAE@Z			; DGAnsCrywolfInfoLoad
PUBLIC	?DGAnsCrywolfSync@@YAXPAE@Z			; DGAnsCrywolfSync
PUBLIC	?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z		; GS_DGAnsCastleNpcUpdate
PUBLIC	?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z		; GS_DGAnsCsLoadTotalGuildInfo
PUBLIC	?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z		; GS_DGAnsCsSaveTotalGuildInfo
PUBLIC	?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z		; GS_DGAnsCsGulidUnionInfo
PUBLIC	?GS_DGAnsCalcREgGuildList@@YAXPAE@Z		; GS_DGAnsCalcREgGuildList
PUBLIC	?GS_DGAnsFirstCreateNPC@@YAXPAE@Z		; GS_DGAnsFirstCreateNPC
PUBLIC	?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z		; GS_DGAnsAllGuildMarkRegInfo
PUBLIC	?GS_DGAnsCastleNpcInfo@@YAXPAE@Z		; GS_DGAnsCastleNpcInfo
PUBLIC	?GS_DGAnsCastleInitData@@YAXPAE@Z		; GS_DGAnsCastleInitData
PUBLIC	?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z		; GS_DGAnsResetRegSiegeInfo
PUBLIC	?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z		; GS_DGAnsResetSiegeGuildInfo
PUBLIC	?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z		; GS_DGAnsResetCastleTaxInfo
PUBLIC	?GS_DGAnsCastleTributeMoney@@YAXPAE@Z		; GS_DGAnsCastleTributeMoney
PUBLIC	?GS_DGAnsCastleStateSync@@YAXPAE@Z		; GS_DGAnsCastleStateSync
PUBLIC	?GS_DGAnsNpcRemove@@YAXPAE@Z			; GS_DGAnsNpcRemove
PUBLIC	?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z		; GS_DGAnsGuildSetGiveUp
PUBLIC	?GS_DGAnsGuildMarkReset@@YAXPAE@Z		; GS_DGAnsGuildMarkReset
PUBLIC	?GS_DGAnsRegGuildMark@@YAXPAE@Z			; GS_DGAnsRegGuildMark
PUBLIC	?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z		; GS_DGAnsMapSvrMsgMultiCast
PUBLIC	?GS_DGAnsRestartCastleState@@YAXPAE@Z		; GS_DGAnsRestartCastleState
PUBLIC	?GS_DGAnsRegAttackGuild@@YAXPAE@Z		; GS_DGAnsRegAttackGuild
PUBLIC	?GS_DGAnsCastleOwnerChange@@YAXPAE@Z		; GS_DGAnsCastleOwnerChange
PUBLIC	?GS_DGAnsSiegeEndedChange@@YAXPAE@Z		; GS_DGAnsSiegeEndedChange
PUBLIC	?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z		; GS_DGAnsGuildMarkRegInfo
PUBLIC	?GS_DGAnsSiegeDateChange@@YAXPAE@Z		; GS_DGAnsSiegeDateChange
PUBLIC	?GS_DGAnsCastleMoneyChange@@YAXPAE@Z		; GS_DGAnsCastleMoneyChange
PUBLIC	?GS_DGAnsTaxRateChange@@YAXPAE@Z		; GS_DGAnsTaxRateChange
PUBLIC	?GS_DGAnsTaxInfo@@YAXPAE@Z			; GS_DGAnsTaxInfo
PUBLIC	?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z		; GS_DGAnsCastleNpcUpgrade
PUBLIC	?GS_DGAnsCastleNpcRepair@@YAXPAE@Z		; GS_DGAnsCastleNpcRepair
PUBLIC	?GS_DGAnsCastleNpcBuy@@YAXPAE@Z			; GS_DGAnsCastleNpcBuy
PUBLIC	?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z		; GS_DGAnsOwnerGuildMaster
PUBLIC	?GS_DGAnsCastleTotalInfo@@YAXPAE@Z		; GS_DGAnsCastleTotalInfo
PUBLIC	?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ; DGOptionDataRecv
PUBLIC	?DGRecvPetItemInfo@@YAXPAE@Z			; DGRecvPetItemInfo
PUBLIC	?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ; ItemSerialCreateRecv
PUBLIC	?DGChangeNameResult@@YAXPAUSDHP_CHANGENAME_RESULT@@@Z ; DGChangeNameResult
PUBLIC	?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem
PUBLIC	?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList
PUBLIC	?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ; JGGetCharacterInfo
PUBLIC	?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ; JGCharDelRequest
PUBLIC	?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ; JGCharacterCreateRequest
PUBLIC	?JGPGetCharList@@YAXPAE@Z			; JGPGetCharList
PUBLIC	?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z	; DataServerLoginResult
PUBLIC	?DataServerProtocolCore@@YAXEPAEH@Z		; DataServerProtocolCore
EXTRN	?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z:PROC ; CAccountSecurity::DGAnsSave
EXTRN	?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z:PROC ; CAccountSecurity::DGAnsLoad
EXTRN	?g_AccountSecurity@@3VCAccountSecurity@@A:BYTE	; g_AccountSecurity
EXTRN	?Protocol@CExWebManager@@QAEXEPAE@Z:PROC	; CExWebManager::Protocol
EXTRN	?g_ExWebManager@@3VCExWebManager@@A:BYTE	; g_ExWebManager
EXTRN	?DGPSelectData@OfflineMode@@QAEXPAUPMSG_GDLOAD_OFFMODE_DATA@@@Z:PROC ; OfflineMode::DGPSelectData
EXTRN	?DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z:PROC ; OfflineMode::DGAnsOffCharacter
EXTRN	?DGAnsMasterInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_MASTER_INFO@@@Z:PROC ; CReferralSystem::DGAnsMasterInfo
EXTRN	?DSAnsSelect@CBanSystem@@QAEXPAUPMSG_SELECT_BANSYSTEM@@@Z:PROC ; CBanSystem::DSAnsSelect
EXTRN	?g_BanSystem@@3VCBanSystem@@A:BYTE		; g_BanSystem
EXTRN	?DGAnsUserUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_USER_UPDATE@@@Z:PROC ; CReferralSystem::DGAnsUserUpdate
EXTRN	?DGAnsUserInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_USER_INFO@@@Z:PROC ; CReferralSystem::DGAnsUserInfo
EXTRN	?DGAnsMasterUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_MASTER_UPDATE@@@Z:PROC ; CReferralSystem::DGAnsMasterUpdate
EXTRN	?g_ReferralSystem@@3VCReferralSystem@@A:BYTE	; g_ReferralSystem
EXTRN	?DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z:PROC ; OfflineMode::DGAnsAccauntPassword
EXTRN	?g_OfflineMode@@3VOfflineMode@@A:BYTE		; g_OfflineMode
EXTRN	?DGSiegeOwner@CDungeonSiege@@QAEXPAUPMSG_DG_DUNGEON_SIEGE_SELECT_OENER@@@Z:PROC ; CDungeonSiege::DGSiegeOwner
EXTRN	?DGRegSiegeResult@CDungeonSiege@@QAEXPAUPMSG_GD_DUNGEON_SIEGE_GUILD_REG_RESULT@@@Z:PROC ; CDungeonSiege::DGRegSiegeResult
EXTRN	?DGRegSiegeList@CDungeonSiege@@QAEXPAUPMSG_DG_DUNGEON_SIEGE_REG_LIST@@@Z:PROC ; CDungeonSiege::DGRegSiegeList
EXTRN	?g_DungeonSiege@@3VCDungeonSiege@@A:BYTE	; g_DungeonSiege
EXTRN	?DGDelete@CMarriage@@QAEXPAUPMSG_ANS_MARRIAGE_DELETE@@@Z:PROC ; CMarriage::DGDelete
EXTRN	?DGInsert@CMarriage@@QAEXPAUPMSG_ANS_MARRIAGE_INSERT@@@Z:PROC ; CMarriage::DGInsert
EXTRN	?DGLoad@CMarriage@@QAEXPAUPMSG_ANS_MARRIAGE_LOAD@@@Z:PROC ; CMarriage::DGLoad
EXTRN	?g_Marriage@@3VCMarriage@@A:BYTE		; g_Marriage
EXTRN	?Protocol@CExGDManager@@QAEXEPAE@Z:PROC		; CExGDManager::Protocol
EXTRN	?g_ExGDManager@@3VCExGDManager@@A:BYTE		; g_ExGDManager
EXTRN	?DGStatus@SpotReturn@@QAEXPAUPMSG_DG_SPOTSTATUS@@@Z:PROC ; SpotReturn::DGStatus
EXTRN	?g_SpotReturn@@3VSpotReturn@@A:QWORD		; g_SpotReturn
EXTRN	?RecvDS@cRanking@@QAEXPAUDGCharTop@@@Z:PROC	; cRanking::RecvDS
EXTRN	?gRanking@@3VcRanking@@A:BYTE			; gRanking
EXTRN	?DG_RecvBrotherCount@Brotherhood@@QAEXPAUDG_CheckBrother@@@Z:PROC ; Brotherhood::DG_RecvBrotherCount
EXTRN	?gBrotherhood@@3VBrotherhood@@A:BYTE		; gBrotherhood
EXTRN	?RecvQuestInfo@cWinQuestSystem@@QAEXPAUDGQuestUserInfo@@@Z:PROC ; cWinQuestSystem::RecvQuestInfo
EXTRN	?gWinQuestSystem@@3VcWinQuestSystem@@A:BYTE	; gWinQuestSystem
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
EXTRN	?DGPeriodItemExList@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_LIST@@@Z:PROC ; CPeriodItemEx::DGPeriodItemExList
EXTRN	?DGPeriodItemExListCount@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_LIST_COUNT@@@Z:PROC ; CPeriodItemEx::DGPeriodItemExListCount
EXTRN	?DGPeriodItemExExpiredItemList@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_EXPIRED_ITEMLIST@@@Z:PROC ; CPeriodItemEx::DGPeriodItemExExpiredItemList
EXTRN	?DGPeriodItemExDelete@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_DELETE@@@Z:PROC ; CPeriodItemEx::DGPeriodItemExDelete
EXTRN	?DGPeriodItemExInsert@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_INSERT@@@Z:PROC ; CPeriodItemEx::DGPeriodItemExInsert
EXTRN	?g_PeriodItemEx@@3VCPeriodItemEx@@A:BYTE	; g_PeriodItemEx
EXTRN	?DGAnsLuckyItemList@LuckyItemManager@@QAEXPAUPMSG_ANS_LUCKYITEM_SELECT@@@Z:PROC ; LuckyItemManager::DGAnsLuckyItemList
EXTRN	?g_LuckyItemManager@@3ULuckyItemManager@@A:BYTE	; g_LuckyItemManager
EXTRN	?DGGetPoint@GameShop@@QAEXPAUGAMESHOP_DG_GET_POINT@@@Z:PROC ; GameShop::DGGetPoint
EXTRN	?DGGetStorage@GameShop@@QAEXPAUGAMESHOP_GD_STORAGE@@@Z:PROC ; GameShop::DGGetStorage
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?DGRewardAns@GensSystem@@QAEXPAUPMSG_GENS_REWARD_ANS@@@Z:PROC ; GensSystem::DGRewardAns
EXTRN	?gGensSystem@@3VGensSystem@@A:BYTE		; gGensSystem
EXTRN	?DGAnsSecedeGensMember@@YAXPAUPMSG_ANS_SECEDE_GENS_MEMBER_EXDB@@@Z:PROC ; DGAnsSecedeGensMember
EXTRN	?DGAnsRegGensMember@@YAXPAUPMSG_ANS_REG_GENS_MEMBER_EXDB@@@Z:PROC ; DGAnsRegGensMember
EXTRN	?DGAnsGensInfo@@YAXPAUPMSG_ANS_GENS_INFO_EXDB@@@Z:PROC ; DGAnsGensInfo
EXTRN	?gGENS@@3HA:DWORD				; gGENS
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?DGAnsPeriodItemUpdate@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_UPDATE@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemUpdate
EXTRN	?DGAnsPeriodItemList@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_LIST@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemList
EXTRN	?DGAnsPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INSERT@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemInsert
EXTRN	?DGAnsPeriodItemInquiry@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INQUIRY@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemInquiry
EXTRN	?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A:BYTE ; g_CashItemPeriodSystem
EXTRN	?DGRequestMasterLevelInfoLoad@CMasterLevelSystem@@QAEXPAE@Z:PROC ; CMasterLevelSystem::DGRequestMasterLevelInfoLoad
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
EXTRN	?SendMacro@MUHelper@@QAEXPAUMUHELPER_MACRO_DS@@@Z:PROC ; MUHelper::SendMacro
EXTRN	?g_MUHelper@@3VMUHelper@@A:BYTE			; g_MUHelper
EXTRN	?Quest3rdLoadInfo@CQuestUtil@@QAEXPAE@Z:PROC	; CQuestUtil::Quest3rdLoadInfo
EXTRN	?g_QuestUtil@@3VCQuestUtil@@A:DWORD		; g_QuestUtil
;	COMDAT ??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@ DB 'er'
	DB	'ror-L2DataServer RECV : %d (%d)', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv308 = -128						; size = 4
tv297 = -128						; size = 4
tv281 = -128						; size = 4
tv255 = -128						; size = 4
tv243 = -128						; size = 4
tv226 = -128						; size = 4
tv209 = -128						; size = 4
tv199 = -128						; size = 4
tv191 = -128						; size = 4
tv181 = -128						; size = 4
tv158 = -128						; size = 4
tv85 = -128						; size = 4
tv65 = -128						; size = 4
_lpMsg$245212 = -60					; size = 4
_lpMsg$245201 = -56					; size = 4
_lpDef$245198 = -52					; size = 4
_lpMsg$245185 = -48					; size = 4
_lpMsg$245155 = -44					; size = 4
_lpDef$245152 = -40					; size = 4
_lpMsg$245143 = -36					; size = 4
_lpMsg$245126 = -32					; size = 4
_lpMsg$245105 = -28					; size = 4
_lpMsg$245094 = -24					; size = 4
_lpMsg2$245085 = -20					; size = 4
_lpMsg$245070 = -16					; size = 4
_pMsg$245062 = -12					; size = 4
_lpMsg$245043 = -8					; size = 4
_lpDef1$244998 = -4					; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?DataServerProtocolCore@@YAXEPAEH@Z PROC		; DataServerProtocolCore

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 78   : 	switch ( protoNum )

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00010	89 45 80	 mov	 DWORD PTR tv65[ebp], eax
  00013	81 7d 80 cf 00
	00 00		 cmp	 DWORD PTR tv65[ebp], 207 ; 000000cfH
  0001a	7f 2b		 jg	 SHORT $LN146@DataServer
  0001c	81 7d 80 cf 00
	00 00		 cmp	 DWORD PTR tv65[ebp], 207 ; 000000cfH
  00023	0f 84 a5 03 00
	00		 je	 $LN88@DataServer
  00029	81 7d 80 c6 00
	00 00		 cmp	 DWORD PTR tv65[ebp], 198 ; 000000c6H
  00030	0f 87 6e 08 00
	00		 ja	 $LN144@DataServer
  00036	8b 4d 80	 mov	 ecx, DWORD PTR tv65[ebp]
  00039	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN147@DataServer[ecx]
  00040	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN150@DataServer[edx*4]
$LN146@DataServer:
  00047	8b 45 80	 mov	 eax, DWORD PTR tv65[ebp]
  0004a	2d d0 00 00 00	 sub	 eax, 208		; 000000d0H
  0004f	89 45 80	 mov	 DWORD PTR tv65[ebp], eax
  00052	83 7d 80 2f	 cmp	 DWORD PTR tv65[ebp], 47	; 0000002fH
  00056	0f 87 48 08 00
	00		 ja	 $LN144@DataServer
  0005c	8b 4d 80	 mov	 ecx, DWORD PTR tv65[ebp]
  0005f	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN148@DataServer[ecx]
  00066	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN151@DataServer[edx*4]
$LN141@DataServer:

; 79   : 	{
; 80   : 		case 0x00:
; 81   : 			DataServerLoginResult((SDHP_RESULT *)aRecv);

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ; DataServerLoginResult
  00076	83 c4 04	 add	 esp, 4

; 82   : 			break;

  00079	e9 26 08 00 00	 jmp	 $LN144@DataServer
$LN140@DataServer:

; 83   : 
; 84   : 		case 0x01:
; 85   : 			JGPGetCharList(aRecv);

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?JGPGetCharList@@YAXPAE@Z ; JGPGetCharList
  00087	83 c4 04	 add	 esp, 4

; 86   : 			break;

  0008a	e9 15 08 00 00	 jmp	 $LN144@DataServer
$LN139@DataServer:

; 87   : 
; 88   : 		case 0x04:
; 89   : 			JGCharacterCreateRequest((SDHP_CREATECHARRESULT *)aRecv);

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ; JGCharacterCreateRequest
  00098	83 c4 04	 add	 esp, 4

; 90   : 			break;

  0009b	e9 04 08 00 00	 jmp	 $LN144@DataServer
$LN138@DataServer:

; 91   : 
; 92   : 		case 0x05:
; 93   : 			JGCharDelRequest((SDHP_CHARDELETERESULT *)aRecv);

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ; JGCharDelRequest
  000a9	83 c4 04	 add	 esp, 4

; 94   : 			break;

  000ac	e9 f3 07 00 00	 jmp	 $LN144@DataServer
$LN137@DataServer:

; 95   : 
; 96   : 		case 0x06:
; 97   : 			JGGetCharacterInfo((SDHP_DBCHAR_INFORESULT *)aRecv);

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ; JGGetCharacterInfo
  000ba	83 c4 04	 add	 esp, 4

; 98   : 			break;

  000bd	e9 e2 07 00 00	 jmp	 $LN144@DataServer
$LN136@DataServer:

; 99   : 
; 100  : 		case 0x08:
; 101  : 			DGGetWarehouseList((SDHP_GETWAREHOUSEDB_SAVE *)aRecv);

  000c2	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList
  000cb	83 c4 04	 add	 esp, 4

; 102  : 			break;

  000ce	e9 d1 07 00 00	 jmp	 $LN144@DataServer
$LN135@DataServer:

; 103  : 
; 104  : 		case 0x10:
; 105  : 			GDGetWarehouseNoItem((SDHP_GETWAREHOUSEDB_RESULT *)aRecv);

  000d3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem
  000dc	83 c4 04	 add	 esp, 4

; 106  : 			break;

  000df	e9 c0 07 00 00	 jmp	 $LN144@DataServer
$LN134@DataServer:

; 107  : 
; 108  : 			//Season 2.5 Quest Load
; 109  : 		case 0x14:
; 110  : 			g_QuestUtil.Quest3rdLoadInfo(aRecv);

  000e4	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000e7	50		 push	 eax
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestUtil@@3VCQuestUtil@@A ; g_QuestUtil
  000ed	e8 00 00 00 00	 call	 ?Quest3rdLoadInfo@CQuestUtil@@QAEXPAE@Z ; CQuestUtil::Quest3rdLoadInfo

; 111  : 			break;

  000f2	e9 ad 07 00 00	 jmp	 $LN144@DataServer
$LN133@DataServer:

; 112  : 
; 113  : 		case 0x16://Season 4.5 ChangeCharacterName
; 114  : 			DGChangeNameResult((SDHP_CHANGENAME_RESULT *)aRecv);

  000f7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?DGChangeNameResult@@YAXPAUSDHP_CHANGENAME_RESULT@@@Z ; DGChangeNameResult
  00100	83 c4 04	 add	 esp, 4

; 115  : 			break;

  00103	e9 9c 07 00 00	 jmp	 $LN144@DataServer
$LN132@DataServer:

; 116  : 
; 117  : #ifdef MUHELPER
; 118  : 		case 0x17:
; 119  : 			g_MUHelper.SendMacro((MUHELPER_MACRO_DS*)aRecv);

  00108	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0010b	50		 push	 eax
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MUHelper@@3VMUHelper@@A ; g_MUHelper
  00111	e8 00 00 00 00	 call	 ?SendMacro@MUHelper@@QAEXPAUMUHELPER_MACRO_DS@@@Z ; MUHelper::SendMacro

; 120  : 			break;

  00116	e9 89 07 00 00	 jmp	 $LN144@DataServer
$LN131@DataServer:

; 121  : #endif
; 122  : 
; 123  : 		case 0x30:
; 124  : 			g_MasterLevelSystem.DGRequestMasterLevelInfoLoad(aRecv);

  0011b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0011e	50		 push	 eax
  0011f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00124	e8 00 00 00 00	 call	 ?DGRequestMasterLevelInfoLoad@CMasterLevelSystem@@QAEXPAE@Z ; CMasterLevelSystem::DGRequestMasterLevelInfoLoad

; 125  : 			break;

  00129	e9 76 07 00 00	 jmp	 $LN144@DataServer
$LN130@DataServer:

; 126  : 
; 127  : 		case 0x52:
; 128  : 			ItemSerialCreateRecv((SDHP_ITEMCREATERECV *)aRecv);

  0012e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ; ItemSerialCreateRecv
  00137	83 c4 04	 add	 esp, 4

; 129  : 			break;

  0013a	e9 65 07 00 00	 jmp	 $LN144@DataServer
$LN129@DataServer:

; 130  : 
; 131  : 		case 0x56:
; 132  : 			DGRecvPetItemInfo(aRecv);

  0013f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ?DGRecvPetItemInfo@@YAXPAE@Z ; DGRecvPetItemInfo
  00148	83 c4 04	 add	 esp, 4

; 133  : 			break;

  0014b	e9 54 07 00 00	 jmp	 $LN144@DataServer
$LN128@DataServer:

; 134  : 
; 135  : 		case 0x60:
; 136  : 			DGOptionDataRecv((SDHP_SKILLKEYDATA_SEND *)aRecv);

  00150	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ; DGOptionDataRecv
  00159	83 c4 04	 add	 esp, 4

; 137  : 			break;

  0015c	e9 43 07 00 00	 jmp	 $LN144@DataServer
$LN127@DataServer:

; 138  : 
; 139  : 		case 0x80:
; 140  : 			{
; 141  : 				PMSG_DEFAULT2 * lpDef1 = (PMSG_DEFAULT2 *)aRecv;

  00161	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00164	89 45 fc	 mov	 DWORD PTR _lpDef1$244998[ebp], eax

; 142  : 
; 143  : 				switch ( lpDef1->subcode )

  00167	8b 45 fc	 mov	 eax, DWORD PTR _lpDef1$244998[ebp]
  0016a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0016e	89 4d 80	 mov	 DWORD PTR tv85[ebp], ecx
  00171	83 7d 80 1b	 cmp	 DWORD PTR tv85[ebp], 27	; 0000001bH
  00175	0f 87 82 01 00
	00		 ja	 $LN125@DataServer
  0017b	8b 55 80	 mov	 edx, DWORD PTR tv85[ebp]
  0017e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN152@DataServer[edx*4]
$LN124@DataServer:

; 144  : 				{
; 145  : 					case 0x00:
; 146  : 						GS_DGAnsCastleTotalInfo(aRecv);

  00185	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?GS_DGAnsCastleTotalInfo@@YAXPAE@Z ; GS_DGAnsCastleTotalInfo
  0018e	83 c4 04	 add	 esp, 4

; 147  : 						break;

  00191	e9 67 01 00 00	 jmp	 $LN125@DataServer
$LN123@DataServer:

; 148  : 
; 149  : 					case 0x01:
; 150  : 						GS_DGAnsOwnerGuildMaster(aRecv);

  00196	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 ?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z ; GS_DGAnsOwnerGuildMaster
  0019f	83 c4 04	 add	 esp, 4

; 151  : 						break;

  001a2	e9 56 01 00 00	 jmp	 $LN125@DataServer
$LN122@DataServer:

; 152  : 
; 153  : 					case 0x03:
; 154  : 						GS_DGAnsCastleNpcBuy(aRecv);

  001a7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcBuy@@YAXPAE@Z ; GS_DGAnsCastleNpcBuy
  001b0	83 c4 04	 add	 esp, 4

; 155  : 						break;

  001b3	e9 45 01 00 00	 jmp	 $LN125@DataServer
$LN121@DataServer:

; 156  : 
; 157  : 					case 0x04:
; 158  : 						GS_DGAnsCastleNpcRepair(aRecv);

  001b8	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcRepair@@YAXPAE@Z ; GS_DGAnsCastleNpcRepair
  001c1	83 c4 04	 add	 esp, 4

; 159  : 						break;

  001c4	e9 34 01 00 00	 jmp	 $LN125@DataServer
$LN120@DataServer:

; 160  : 
; 161  : 					case 0x05:
; 162  : 						GS_DGAnsCastleNpcUpgrade(aRecv);

  001c9	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z ; GS_DGAnsCastleNpcUpgrade
  001d2	83 c4 04	 add	 esp, 4

; 163  : 						break;

  001d5	e9 23 01 00 00	 jmp	 $LN125@DataServer
$LN119@DataServer:

; 164  : 
; 165  : 					case 0x06:
; 166  : 						GS_DGAnsTaxInfo(aRecv);

  001da	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ?GS_DGAnsTaxInfo@@YAXPAE@Z ; GS_DGAnsTaxInfo
  001e3	83 c4 04	 add	 esp, 4

; 167  : 						break;

  001e6	e9 12 01 00 00	 jmp	 $LN125@DataServer
$LN118@DataServer:

; 168  : 
; 169  : 					case 0x07:
; 170  : 						GS_DGAnsTaxRateChange(aRecv);

  001eb	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 ?GS_DGAnsTaxRateChange@@YAXPAE@Z ; GS_DGAnsTaxRateChange
  001f4	83 c4 04	 add	 esp, 4

; 171  : 						break;

  001f7	e9 01 01 00 00	 jmp	 $LN125@DataServer
$LN117@DataServer:

; 172  : 
; 173  : 					case 0x08:
; 174  : 						GS_DGAnsCastleMoneyChange(aRecv);

  001fc	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 ?GS_DGAnsCastleMoneyChange@@YAXPAE@Z ; GS_DGAnsCastleMoneyChange
  00205	83 c4 04	 add	 esp, 4

; 175  : 						break;

  00208	e9 f0 00 00 00	 jmp	 $LN125@DataServer
$LN116@DataServer:

; 176  : 
; 177  : 					case 0x09:
; 178  : 						GS_DGAnsSiegeDateChange(aRecv);

  0020d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 ?GS_DGAnsSiegeDateChange@@YAXPAE@Z ; GS_DGAnsSiegeDateChange
  00216	83 c4 04	 add	 esp, 4

; 179  : 						break;

  00219	e9 df 00 00 00	 jmp	 $LN125@DataServer
$LN115@DataServer:

; 180  : 
; 181  : 					case 0x0A:
; 182  : 						GS_DGAnsGuildMarkRegInfo(aRecv);

  0021e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z ; GS_DGAnsGuildMarkRegInfo
  00227	83 c4 04	 add	 esp, 4

; 183  : 						break;

  0022a	e9 ce 00 00 00	 jmp	 $LN125@DataServer
$LN114@DataServer:

; 184  : 
; 185  : 					case 0x0B:
; 186  : 						GS_DGAnsSiegeEndedChange(aRecv);

  0022f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?GS_DGAnsSiegeEndedChange@@YAXPAE@Z ; GS_DGAnsSiegeEndedChange
  00238	83 c4 04	 add	 esp, 4

; 187  : 						break;

  0023b	e9 bd 00 00 00	 jmp	 $LN125@DataServer
$LN113@DataServer:

; 188  : 
; 189  : 					case 0x0C:
; 190  : 						GS_DGAnsCastleOwnerChange(aRecv);

  00240	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 ?GS_DGAnsCastleOwnerChange@@YAXPAE@Z ; GS_DGAnsCastleOwnerChange
  00249	83 c4 04	 add	 esp, 4

; 191  : 						break;

  0024c	e9 ac 00 00 00	 jmp	 $LN125@DataServer
$LN112@DataServer:

; 192  : 
; 193  : 					case 0x0D:
; 194  : 						GS_DGAnsRegAttackGuild(aRecv);

  00251	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ?GS_DGAnsRegAttackGuild@@YAXPAE@Z ; GS_DGAnsRegAttackGuild
  0025a	83 c4 04	 add	 esp, 4

; 195  : 						break;

  0025d	e9 9b 00 00 00	 jmp	 $LN125@DataServer
$LN111@DataServer:

; 196  : 
; 197  : 					case 0x0E:
; 198  : 						GS_DGAnsRestartCastleState(aRecv);

  00262	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 ?GS_DGAnsRestartCastleState@@YAXPAE@Z ; GS_DGAnsRestartCastleState
  0026b	83 c4 04	 add	 esp, 4

; 199  : 						break;

  0026e	e9 8a 00 00 00	 jmp	 $LN125@DataServer
$LN110@DataServer:

; 200  : 
; 201  : 					case 0x0F:
; 202  : 						GS_DGAnsMapSvrMsgMultiCast(aRecv);

  00273	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 ?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z ; GS_DGAnsMapSvrMsgMultiCast
  0027c	83 c4 04	 add	 esp, 4

; 203  : 						break;

  0027f	eb 7c		 jmp	 SHORT $LN125@DataServer
$LN109@DataServer:

; 204  : 
; 205  : 					case 0x10:
; 206  : 						GS_DGAnsRegGuildMark(aRecv);

  00281	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 ?GS_DGAnsRegGuildMark@@YAXPAE@Z ; GS_DGAnsRegGuildMark
  0028a	83 c4 04	 add	 esp, 4

; 207  : 						break;

  0028d	eb 6e		 jmp	 SHORT $LN125@DataServer
$LN108@DataServer:

; 208  : 
; 209  : 					case 0x11:
; 210  : 						GS_DGAnsGuildMarkReset(aRecv);

  0028f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 ?GS_DGAnsGuildMarkReset@@YAXPAE@Z ; GS_DGAnsGuildMarkReset
  00298	83 c4 04	 add	 esp, 4

; 211  : 						break;

  0029b	eb 60		 jmp	 SHORT $LN125@DataServer
$LN107@DataServer:

; 212  : 
; 213  : 					case 0x12:
; 214  : 						GS_DGAnsGuildSetGiveUp(aRecv);

  0029d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 ?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z ; GS_DGAnsGuildSetGiveUp
  002a6	83 c4 04	 add	 esp, 4

; 215  : 						break;

  002a9	eb 52		 jmp	 SHORT $LN125@DataServer
$LN106@DataServer:

; 216  : 
; 217  : 					case 0x16:
; 218  : 						GS_DGAnsNpcRemove(aRecv);

  002ab	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 ?GS_DGAnsNpcRemove@@YAXPAE@Z ; GS_DGAnsNpcRemove
  002b4	83 c4 04	 add	 esp, 4

; 219  : 						break;

  002b7	eb 44		 jmp	 SHORT $LN125@DataServer
$LN105@DataServer:

; 220  : 
; 221  : 					case 0x17:
; 222  : 						GS_DGAnsCastleStateSync(aRecv);

  002b9	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002bc	50		 push	 eax
  002bd	e8 00 00 00 00	 call	 ?GS_DGAnsCastleStateSync@@YAXPAE@Z ; GS_DGAnsCastleStateSync
  002c2	83 c4 04	 add	 esp, 4

; 223  : 						break;

  002c5	eb 36		 jmp	 SHORT $LN125@DataServer
$LN104@DataServer:

; 224  : 
; 225  : 					case 0x18:
; 226  : 						GS_DGAnsCastleTributeMoney(aRecv);

  002c7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ?GS_DGAnsCastleTributeMoney@@YAXPAE@Z ; GS_DGAnsCastleTributeMoney
  002d0	83 c4 04	 add	 esp, 4

; 227  : 						break;

  002d3	eb 28		 jmp	 SHORT $LN125@DataServer
$LN103@DataServer:

; 228  : 
; 229  : 					case 0x19:
; 230  : 						GS_DGAnsResetCastleTaxInfo(aRecv);

  002d5	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002d8	50		 push	 eax
  002d9	e8 00 00 00 00	 call	 ?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z ; GS_DGAnsResetCastleTaxInfo
  002de	83 c4 04	 add	 esp, 4

; 231  : 						break;

  002e1	eb 1a		 jmp	 SHORT $LN125@DataServer
$LN102@DataServer:

; 232  : 
; 233  : 					case 0x1A:
; 234  : 						GS_DGAnsResetSiegeGuildInfo(aRecv);

  002e3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 ?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z ; GS_DGAnsResetSiegeGuildInfo
  002ec	83 c4 04	 add	 esp, 4

; 235  : 						break;

  002ef	eb 0c		 jmp	 SHORT $LN125@DataServer
$LN101@DataServer:

; 236  : 
; 237  : 					case 0x1B:
; 238  : 						GS_DGAnsResetRegSiegeInfo(aRecv);

  002f1	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 ?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z ; GS_DGAnsResetRegSiegeInfo
  002fa	83 c4 04	 add	 esp, 4
$LN125@DataServer:

; 239  : 						break;
; 240  : 				}
; 241  : 			}
; 242  : 			break;

  002fd	e9 a2 05 00 00	 jmp	 $LN144@DataServer
$LN100@DataServer:

; 243  : 
; 244  : 		case 0x81:
; 245  : 			GS_DGAnsCastleInitData(aRecv);

  00302	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ?GS_DGAnsCastleInitData@@YAXPAE@Z ; GS_DGAnsCastleInitData
  0030b	83 c4 04	 add	 esp, 4

; 246  : 			break;

  0030e	e9 91 05 00 00	 jmp	 $LN144@DataServer
$LN99@DataServer:

; 247  : 
; 248  : 		case 0x82:
; 249  : 			GS_DGAnsCastleNpcInfo(aRecv);

  00313	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcInfo@@YAXPAE@Z ; GS_DGAnsCastleNpcInfo
  0031c	83 c4 04	 add	 esp, 4

; 250  : 			break;

  0031f	e9 80 05 00 00	 jmp	 $LN144@DataServer
$LN98@DataServer:

; 251  : 
; 252  : 		case 0x83:
; 253  : 			GS_DGAnsAllGuildMarkRegInfo(aRecv);

  00324	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z ; GS_DGAnsAllGuildMarkRegInfo
  0032d	83 c4 04	 add	 esp, 4

; 254  : 			break;

  00330	e9 6f 05 00 00	 jmp	 $LN144@DataServer
$LN97@DataServer:

; 255  : 
; 256  : 		case 0x84:
; 257  : 			GS_DGAnsFirstCreateNPC(aRecv);

  00335	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00338	50		 push	 eax
  00339	e8 00 00 00 00	 call	 ?GS_DGAnsFirstCreateNPC@@YAXPAE@Z ; GS_DGAnsFirstCreateNPC
  0033e	83 c4 04	 add	 esp, 4

; 258  : 			break;

  00341	e9 5e 05 00 00	 jmp	 $LN144@DataServer
$LN96@DataServer:

; 259  : 
; 260  : 		case 0x85:
; 261  : 			GS_DGAnsCalcREgGuildList(aRecv);

  00346	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 ?GS_DGAnsCalcREgGuildList@@YAXPAE@Z ; GS_DGAnsCalcREgGuildList
  0034f	83 c4 04	 add	 esp, 4

; 262  : 			break;

  00352	e9 4d 05 00 00	 jmp	 $LN144@DataServer
$LN95@DataServer:

; 263  : 
; 264  : 		case 0x86:
; 265  : 			GS_DGAnsCsGulidUnionInfo(aRecv);

  00357	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 ?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z ; GS_DGAnsCsGulidUnionInfo
  00360	83 c4 04	 add	 esp, 4

; 266  : 			break;

  00363	e9 3c 05 00 00	 jmp	 $LN144@DataServer
$LN94@DataServer:

; 267  : 
; 268  : 		case 0x87:
; 269  : 			GS_DGAnsCsSaveTotalGuildInfo(aRecv);

  00368	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 ?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z ; GS_DGAnsCsSaveTotalGuildInfo
  00371	83 c4 04	 add	 esp, 4

; 270  : 			break;

  00374	e9 2b 05 00 00	 jmp	 $LN144@DataServer
$LN93@DataServer:

; 271  : 
; 272  : 		case 0x88:
; 273  : 			GS_DGAnsCsLoadTotalGuildInfo(aRecv);

  00379	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 ?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z ; GS_DGAnsCsLoadTotalGuildInfo
  00382	83 c4 04	 add	 esp, 4

; 274  : 			break;

  00385	e9 1a 05 00 00	 jmp	 $LN144@DataServer
$LN92@DataServer:

; 275  : 
; 276  : 		case 0x89:
; 277  : 			GS_DGAnsCastleNpcUpdate(aRecv);

  0038a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0038d	50		 push	 eax
  0038e	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z ; GS_DGAnsCastleNpcUpdate
  00393	83 c4 04	 add	 esp, 4

; 278  : 			break;

  00396	e9 09 05 00 00	 jmp	 $LN144@DataServer
$LN91@DataServer:

; 279  : 
; 280  : 		case 0xB0:
; 281  : 			DGAnsCrywolfSync(aRecv);

  0039b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0039e	50		 push	 eax
  0039f	e8 00 00 00 00	 call	 ?DGAnsCrywolfSync@@YAXPAE@Z ; DGAnsCrywolfSync
  003a4	83 c4 04	 add	 esp, 4

; 282  : 			break;

  003a7	e9 f8 04 00 00	 jmp	 $LN144@DataServer
$LN90@DataServer:

; 283  : 
; 284  : 		case 0xB1:
; 285  : 			DGAnsCrywolfInfoLoad(aRecv);

  003ac	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 ?DGAnsCrywolfInfoLoad@@YAXPAE@Z ; DGAnsCrywolfInfoLoad
  003b5	83 c4 04	 add	 esp, 4

; 286  : 			break;

  003b8	e9 e7 04 00 00	 jmp	 $LN144@DataServer
$LN89@DataServer:

; 287  : 
; 288  : 		case 0xB2:
; 289  : 			DGAnsCrywolfInfoSave(aRecv);

  003bd	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003c0	50		 push	 eax
  003c1	e8 00 00 00 00	 call	 ?DGAnsCrywolfInfoSave@@YAXPAE@Z ; DGAnsCrywolfInfoSave
  003c6	83 c4 04	 add	 esp, 4

; 290  : 			break;

  003c9	e9 d6 04 00 00	 jmp	 $LN144@DataServer
$LN88@DataServer:

; 291  : 
; 292  : 		case 0xCF:
; 293  : 			DGMoveOtherServer((SDHP_CHARACTER_TRANSFER_RESULT *)aRecv);

  003ce	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003d1	50		 push	 eax
  003d2	e8 00 00 00 00	 call	 ?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ; DGMoveOtherServer
  003d7	83 c4 04	 add	 esp, 4

; 294  : 			break;

  003da	e9 c5 04 00 00	 jmp	 $LN144@DataServer
$LN87@DataServer:

; 295  : 
; 296  : 		case 0xD0:
; 297  : 			{
; 298  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  003df	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003e2	89 45 f8	 mov	 DWORD PTR _lpMsg$245043[ebp], eax

; 299  : 
; 300  : 				switch ( lpMsg->subcode )

  003e5	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$245043[ebp]
  003e8	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003ec	89 4d 80	 mov	 DWORD PTR tv158[ebp], ecx
  003ef	8b 55 80	 mov	 edx, DWORD PTR tv158[ebp]
  003f2	83 ea 02	 sub	 edx, 2
  003f5	89 55 80	 mov	 DWORD PTR tv158[ebp], edx
  003f8	83 7d 80 06	 cmp	 DWORD PTR tv158[ebp], 6
  003fc	77 48		 ja	 SHORT $LN85@DataServer
  003fe	8b 45 80	 mov	 eax, DWORD PTR tv158[ebp]
  00401	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN153@DataServer[eax*4]
$LN84@DataServer:

; 301  : 				{
; 302  : 					case 0x02:
; 303  : 						g_CashItemPeriodSystem.DGAnsPeriodItemInquiry((PMSG_ANS_PERIODITEM_INQUIRY *)aRecv);

  00408	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0040b	50		 push	 eax
  0040c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00411	e8 00 00 00 00	 call	 ?DGAnsPeriodItemInquiry@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INQUIRY@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemInquiry

; 304  : 						break;

  00416	eb 2e		 jmp	 SHORT $LN85@DataServer
$LN83@DataServer:

; 305  : 
; 306  : 					case 0x04:
; 307  : 						g_CashItemPeriodSystem.DGAnsPeriodItemInsert((PMSG_ANS_PERIODITEM_INSERT *)aRecv);

  00418	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0041b	50		 push	 eax
  0041c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00421	e8 00 00 00 00	 call	 ?DGAnsPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INSERT@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemInsert

; 308  : 						break;

  00426	eb 1e		 jmp	 SHORT $LN85@DataServer
$LN82@DataServer:

; 309  : 
; 310  : 					case 0x06:
; 311  : 						g_CashItemPeriodSystem.DGAnsPeriodItemList((PMSG_ANS_PERIODITEM_LIST *)aRecv);

  00428	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0042b	50		 push	 eax
  0042c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00431	e8 00 00 00 00	 call	 ?DGAnsPeriodItemList@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_LIST@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemList

; 312  : 						break;

  00436	eb 0e		 jmp	 SHORT $LN85@DataServer
$LN81@DataServer:

; 313  : 
; 314  : 					case 0x08:
; 315  : 						g_CashItemPeriodSystem.DGAnsPeriodItemUpdate((PMSG_ANS_PERIODITEM_UPDATE *)aRecv);

  00438	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0043b	50		 push	 eax
  0043c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00441	e8 00 00 00 00	 call	 ?DGAnsPeriodItemUpdate@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_UPDATE@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemUpdate
$LN85@DataServer:

; 316  : 						break;
; 317  : 				}
; 318  : 			}
; 319  : 			break;

  00446	e9 59 04 00 00	 jmp	 $LN144@DataServer
$LN80@DataServer:

; 320  : 
; 321  : 		//Season3
; 322  : 		case 0xA1:
; 323  : 			DGSummonerStateUpdatedSend((PMSG_ANS_SUMMONER_CREATE *)aRecv);

  0044b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0044e	50		 push	 eax
  0044f	e8 00 00 00 00	 call	 ?DGSummonerStateUpdatedSend@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z ; DGSummonerStateUpdatedSend
  00454	83 c4 04	 add	 esp, 4

; 324  : 			break;

  00457	e9 48 04 00 00	 jmp	 $LN144@DataServer
$LN79@DataServer:

; 325  : 		case 0xA2:
; 326  : 			DGSummonerStateRecv((PMSG_ANS_SUMMONER_STATUS *)aRecv);

  0045c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0045f	50		 push	 eax
  00460	e8 00 00 00 00	 call	 ?DGSummonerStateRecv@@YAXPAUPMSG_ANS_SUMMONER_STATUS@@@Z ; DGSummonerStateRecv
  00465	83 c4 04	 add	 esp, 4

; 327  : 			break;

  00468	e9 37 04 00 00	 jmp	 $LN144@DataServer
$LN78@DataServer:

; 328  : 
; 329  : 		case 0xFF:	// Test Packet
; 330  : 			{
; 331  : 				PMSG_TEST * pMsg = (PMSG_TEST *)aRecv;

  0046d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00470	89 45 f4	 mov	 DWORD PTR _pMsg$245062[ebp], eax

; 332  : 
; 333  : 				LogAddC(2, "error-L2DataServer RECV : %d (%d)", aLen, pMsg->count);

  00473	8b 45 f4	 mov	 eax, DWORD PTR _pMsg$245062[ebp]
  00476	8b 88 d0 07 00
	00		 mov	 ecx, DWORD PTR [eax+2000]
  0047c	51		 push	 ecx
  0047d	8b 55 10	 mov	 edx, DWORD PTR _aLen$[ebp]
  00480	52		 push	 edx
  00481	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@
  00486	6a 02		 push	 2
  00488	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0048e	83 c4 10	 add	 esp, 16			; 00000010H

; 334  : 			}
; 335  : 			break;

  00491	e9 0e 04 00 00	 jmp	 $LN144@DataServer

; 336  : 
; 337  : 		case 0xE6:
; 338  : #ifdef OLDCASHSHOP
; 339  : 			DGRequestWcoinInfoLoad(aRecv);
; 340  : #endif
; 341  : 			break;

  00496	e9 09 04 00 00	 jmp	 $LN144@DataServer
$LN75@DataServer:

; 342  : 
; 343  : 		case 0xE0:
; 344  : 			if(g_ExLicense.user.Rage)
; 345  : 			{
; 346  : 				//gSystemOfRage.RecvDSProtocol((DSRageUser *)aRecv);
; 347  : 			}
; 348  : 			break;

  0049b	e9 04 04 00 00	 jmp	 $LN144@DataServer
$LN74@DataServer:

; 349  : 
; 350  : 		case 0xF8: // Gens System
; 351  : 			{
; 352  : 				if(gGENS)

  004a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  004a7	74 61		 je	 SHORT $LN73@DataServer

; 353  : 				{
; 354  : 					PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  004a9	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004ac	89 45 f0	 mov	 DWORD PTR _lpMsg$245070[ebp], eax

; 355  : 					// ----
; 356  : 					switch(lpMsg->subcode)

  004af	8b 45 f0	 mov	 eax, DWORD PTR _lpMsg$245070[ebp]
  004b2	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  004b6	89 4d 80	 mov	 DWORD PTR tv181[ebp], ecx
  004b9	8b 55 80	 mov	 edx, DWORD PTR tv181[ebp]
  004bc	83 ea 01	 sub	 edx, 1
  004bf	89 55 80	 mov	 DWORD PTR tv181[ebp], edx
  004c2	83 7d 80 04	 cmp	 DWORD PTR tv181[ebp], 4
  004c6	77 42		 ja	 SHORT $LN73@DataServer
  004c8	8b 45 80	 mov	 eax, DWORD PTR tv181[ebp]
  004cb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN154@DataServer[eax*4]
$LN70@DataServer:

; 357  : 					{
; 358  : 					case 0x01: //-> Get member info
; 359  : 						{
; 360  : 							DGAnsGensInfo((PMSG_ANS_GENS_INFO_EXDB*)aRecv);

  004d2	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004d5	50		 push	 eax
  004d6	e8 00 00 00 00	 call	 ?DGAnsGensInfo@@YAXPAUPMSG_ANS_GENS_INFO_EXDB@@@Z ; DGAnsGensInfo
  004db	83 c4 04	 add	 esp, 4

; 361  : 						}
; 362  : 						break;

  004de	eb 2a		 jmp	 SHORT $LN73@DataServer
$LN69@DataServer:

; 363  : 						// --
; 364  : 					case 0x03: //-> Register new member
; 365  : 						{
; 366  : 							DGAnsRegGensMember((PMSG_ANS_REG_GENS_MEMBER_EXDB*)aRecv);

  004e0	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004e3	50		 push	 eax
  004e4	e8 00 00 00 00	 call	 ?DGAnsRegGensMember@@YAXPAUPMSG_ANS_REG_GENS_MEMBER_EXDB@@@Z ; DGAnsRegGensMember
  004e9	83 c4 04	 add	 esp, 4

; 367  : 						}
; 368  : 						break;

  004ec	eb 1c		 jmp	 SHORT $LN73@DataServer
$LN68@DataServer:

; 369  : 						// --
; 370  : 					case 0x04: //-> Delete member
; 371  : 						{
; 372  : 							 DGAnsSecedeGensMember((PMSG_ANS_SECEDE_GENS_MEMBER_EXDB*)aRecv);

  004ee	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004f1	50		 push	 eax
  004f2	e8 00 00 00 00	 call	 ?DGAnsSecedeGensMember@@YAXPAUPMSG_ANS_SECEDE_GENS_MEMBER_EXDB@@@Z ; DGAnsSecedeGensMember
  004f7	83 c4 04	 add	 esp, 4

; 373  : 						}
; 374  : 						break;

  004fa	eb 0e		 jmp	 SHORT $LN73@DataServer
$LN67@DataServer:

; 375  : 						// --
; 376  : 					case 0x05: //-> Reward answer
; 377  : 						{
; 378  : 							gGensSystem.DGRewardAns((PMSG_GENS_REWARD_ANS*)aRecv);

  004fc	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004ff	50		 push	 eax
  00500	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00505	e8 00 00 00 00	 call	 ?DGRewardAns@GensSystem@@QAEXPAUPMSG_GENS_REWARD_ANS@@@Z ; GensSystem::DGRewardAns
$LN73@DataServer:

; 379  : 						}
; 380  : 						break;
; 381  : 					}
; 382  : 				}
; 383  : 			}
; 384  : 			break;

  0050a	e9 95 03 00 00	 jmp	 $LN144@DataServer
$LN66@DataServer:

; 385  : 			// --
; 386  : #ifdef GAMESHOP
; 387  : 		case 0xD3:
; 388  : 			{
; 389  : 				PWMSG_HEAD2 * lpMsg2	= (PWMSG_HEAD2*)aRecv;

  0050f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00512	89 45 ec	 mov	 DWORD PTR _lpMsg2$245085[ebp], eax

; 390  : 				// ----
; 391  : 				switch(lpMsg2->subcode)

  00515	8b 45 ec	 mov	 eax, DWORD PTR _lpMsg2$245085[ebp]
  00518	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0051b	88 4d 80	 mov	 BYTE PTR tv191[ebp], cl
  0051e	80 7d 80 01	 cmp	 BYTE PTR tv191[ebp], 1
  00522	74 02		 je	 SHORT $LN63@DataServer
  00524	eb 0e		 jmp	 SHORT $LN64@DataServer
$LN63@DataServer:

; 392  : 				{
; 393  : 				case 1:
; 394  : 					{
; 395  : 						gGameShop.DGGetStorage((GAMESHOP_GD_STORAGE*)aRecv);

  00526	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00529	50		 push	 eax
  0052a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0052f	e8 00 00 00 00	 call	 ?DGGetStorage@GameShop@@QAEXPAUGAMESHOP_GD_STORAGE@@@Z ; GameShop::DGGetStorage
$LN64@DataServer:

; 396  : 					}
; 397  : 					break;
; 398  : 				}
; 399  : 			}
; 400  : 			break;

  00534	e9 6b 03 00 00	 jmp	 $LN144@DataServer
$LN62@DataServer:

; 401  : 			// --
; 402  : 
; 403  : 		case 0xD2:	//-> GameShop
; 404  : 			{
; 405  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  00539	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0053c	89 45 e8	 mov	 DWORD PTR _lpMsg$245094[ebp], eax

; 406  : 				// ----
; 407  : 				switch(lpMsg->subcode)

  0053f	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$245094[ebp]
  00542	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00545	88 4d 80	 mov	 BYTE PTR tv199[ebp], cl
  00548	80 7d 80 02	 cmp	 BYTE PTR tv199[ebp], 2
  0054c	74 02		 je	 SHORT $LN59@DataServer
  0054e	eb 0e		 jmp	 SHORT $LN60@DataServer
$LN59@DataServer:

; 408  : 				{
; 409  : 				case 2:	//-> Answer point
; 410  : 					{
; 411  : 						gGameShop.DGGetPoint((GAMESHOP_DG_GET_POINT*)aRecv);

  00550	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00553	50		 push	 eax
  00554	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00559	e8 00 00 00 00	 call	 ?DGGetPoint@GameShop@@QAEXPAUGAMESHOP_DG_GET_POINT@@@Z ; GameShop::DGGetPoint
$LN60@DataServer:

; 412  : 					}
; 413  : 					break;
; 414  : 				}
; 415  : 			}
; 416  : 			break;

  0055e	e9 41 03 00 00	 jmp	 $LN144@DataServer
$LN58@DataServer:

; 417  : #endif
; 418  : #ifdef LUCKYITEM
; 419  : 		case 0xD4:	//-> LuckyItem Select
; 420  : 			{
; 421  : 				g_LuckyItemManager.DGAnsLuckyItemList((PMSG_ANS_LUCKYITEM_SELECT*)aRecv);

  00563	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00566	50		 push	 eax
  00567	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  0056c	e8 00 00 00 00	 call	 ?DGAnsLuckyItemList@LuckyItemManager@@QAEXPAUPMSG_ANS_LUCKYITEM_SELECT@@@Z ; LuckyItemManager::DGAnsLuckyItemList

; 422  : 			}
; 423  : 			break;

  00571	e9 2e 03 00 00	 jmp	 $LN144@DataServer
$LN57@DataServer:

; 424  : #endif
; 425  : #ifdef PERIOD
; 426  : 		case 0xD1:	//-> PeriodItemEx Main
; 427  : 			{
; 428  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  00576	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00579	89 45 e4	 mov	 DWORD PTR _lpMsg$245105[ebp], eax

; 429  : 				// ----
; 430  : 				switch(lpMsg->subcode)

  0057c	8b 45 e4	 mov	 eax, DWORD PTR _lpMsg$245105[ebp]
  0057f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00583	89 4d 80	 mov	 DWORD PTR tv209[ebp], ecx
  00586	8b 55 80	 mov	 edx, DWORD PTR tv209[ebp]
  00589	83 ea 01	 sub	 edx, 1
  0058c	89 55 80	 mov	 DWORD PTR tv209[ebp], edx
  0058f	83 7d 80 04	 cmp	 DWORD PTR tv209[ebp], 4
  00593	77 58		 ja	 SHORT $LN55@DataServer
  00595	8b 45 80	 mov	 eax, DWORD PTR tv209[ebp]
  00598	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN155@DataServer[eax*4]
$LN54@DataServer:

; 431  : 				{
; 432  : 				case 1:
; 433  : 					g_PeriodItemEx.DGPeriodItemExInsert((PMSG_ANS_PERIODITEMEX_INSERT*)aRecv);

  0059f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005a2	50		 push	 eax
  005a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  005a8	e8 00 00 00 00	 call	 ?DGPeriodItemExInsert@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_INSERT@@@Z ; CPeriodItemEx::DGPeriodItemExInsert

; 434  : 					break;

  005ad	eb 3e		 jmp	 SHORT $LN55@DataServer
$LN53@DataServer:

; 435  : 				case 2:
; 436  : 					g_PeriodItemEx.DGPeriodItemExDelete((PMSG_ANS_PERIODITEMEX_DELETE*)aRecv);

  005af	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005b2	50		 push	 eax
  005b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  005b8	e8 00 00 00 00	 call	 ?DGPeriodItemExDelete@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_DELETE@@@Z ; CPeriodItemEx::DGPeriodItemExDelete

; 437  : 					break;

  005bd	eb 2e		 jmp	 SHORT $LN55@DataServer
$LN52@DataServer:

; 438  : 				case 3:
; 439  : 					g_PeriodItemEx.DGPeriodItemExExpiredItemList((PMSG_ANS_PERIODITEMEX_EXPIRED_ITEMLIST*)aRecv);

  005bf	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005c2	50		 push	 eax
  005c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  005c8	e8 00 00 00 00	 call	 ?DGPeriodItemExExpiredItemList@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_EXPIRED_ITEMLIST@@@Z ; CPeriodItemEx::DGPeriodItemExExpiredItemList

; 440  : 					break;

  005cd	eb 1e		 jmp	 SHORT $LN55@DataServer
$LN51@DataServer:

; 441  : 				case 4:
; 442  : 					g_PeriodItemEx.DGPeriodItemExListCount((PMSG_ANS_PERIODITEMEX_LIST_COUNT*)aRecv);

  005cf	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005d2	50		 push	 eax
  005d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  005d8	e8 00 00 00 00	 call	 ?DGPeriodItemExListCount@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_LIST_COUNT@@@Z ; CPeriodItemEx::DGPeriodItemExListCount

; 443  : 					break;

  005dd	eb 0e		 jmp	 SHORT $LN55@DataServer
$LN50@DataServer:

; 444  : 				case 5:
; 445  : 					g_PeriodItemEx.DGPeriodItemExList((PMSG_ANS_PERIODITEMEX_LIST*)aRecv);

  005df	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005e2	50		 push	 eax
  005e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  005e8	e8 00 00 00 00	 call	 ?DGPeriodItemExList@CPeriodItemEx@@QAEXPAUPMSG_ANS_PERIODITEMEX_LIST@@@Z ; CPeriodItemEx::DGPeriodItemExList
$LN55@DataServer:

; 446  : 					break;
; 447  : 				}
; 448  : 			}
; 449  : 			break;

  005ed	e9 b2 02 00 00	 jmp	 $LN144@DataServer
$LN49@DataServer:

; 450  : #endif
; 451  : #ifdef EXPINV
; 452  : 		case 0xD5:
; 453  : 			{
; 454  : 				DGUpdateExtendedInvenCountResult((SDHP_ANS_SET_EXTENDEDINVEN_COUNT*)aRecv);

  005f2	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005f5	50		 push	 eax
  005f6	e8 00 00 00 00	 call	 ?DGUpdateExtendedInvenCountResult@@YAXPAUSDHP_ANS_SET_EXTENDEDINVEN_COUNT@@@Z ; DGUpdateExtendedInvenCountResult
  005fb	83 c4 04	 add	 esp, 4

; 455  : 			}
; 456  : 			break;

  005fe	e9 a1 02 00 00	 jmp	 $LN144@DataServer
$LN48@DataServer:

; 457  : 			// --
; 458  : 		case 0xD6:
; 459  : 			{
; 460  : 				DGUpdateExtendedWarehouseResult((SDHP_ANS_SET_EXTENDEDWAREHOUSE_COUNT*)aRecv);

  00603	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ?DGUpdateExtendedWarehouseResult@@YAXPAUSDHP_ANS_SET_EXTENDEDWAREHOUSE_COUNT@@@Z ; DGUpdateExtendedWarehouseResult
  0060c	83 c4 04	 add	 esp, 4

; 461  : 			}
; 462  : 			break;

  0060f	e9 90 02 00 00	 jmp	 $LN144@DataServer
$LN47@DataServer:

; 463  : #endif
; 464  : 		case 0xE2:
; 465  : 			{
; 466  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  00614	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00617	89 45 e0	 mov	 DWORD PTR _lpMsg$245126[ebp], eax

; 467  : 				switch(lpMsg->subcode)

  0061a	8b 45 e0	 mov	 eax, DWORD PTR _lpMsg$245126[ebp]
  0061d	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00620	88 4d 80	 mov	 BYTE PTR tv226[ebp], cl
  00623	80 7d 80 00	 cmp	 BYTE PTR tv226[ebp], 0
  00627	74 0e		 je	 SHORT $LN44@DataServer
  00629	80 7d 80 01	 cmp	 BYTE PTR tv226[ebp], 1
  0062d	74 16		 je	 SHORT $LN43@DataServer
  0062f	80 7d 80 02	 cmp	 BYTE PTR tv226[ebp], 2
  00633	74 2b		 je	 SHORT $LN41@DataServer
  00635	eb 37		 jmp	 SHORT $LN45@DataServer
$LN44@DataServer:

; 468  : 				{
; 469  : 				case 0x00:
; 470  : 					{
; 471  : 						DSBanSystem((BAN_CHAR_DS *)aRecv);

  00637	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0063a	50		 push	 eax
  0063b	e8 00 00 00 00	 call	 ?DSBanSystem@@YAXPAUBAN_CHAR_DS@@@Z ; DSBanSystem
  00640	83 c4 04	 add	 esp, 4

; 472  : 					}
; 473  : 					break;

  00643	eb 29		 jmp	 SHORT $LN45@DataServer
$LN43@DataServer:

; 474  : 
; 475  : 				case 0x01:
; 476  : 					if(g_ExLicense.user.WinQuest)

  00645	0f b6 05 ca 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+202
  0064c	85 c0		 test	 eax, eax
  0064e	74 0e		 je	 SHORT $LN42@DataServer

; 477  : 					{
; 478  : 						gWinQuestSystem.RecvQuestInfo((DGQuestUserInfo*)aRecv);

  00650	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00653	50		 push	 eax
  00654	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWinQuestSystem@@3VcWinQuestSystem@@A ; gWinQuestSystem
  00659	e8 00 00 00 00	 call	 ?RecvQuestInfo@cWinQuestSystem@@QAEXPAUDGQuestUserInfo@@@Z ; cWinQuestSystem::RecvQuestInfo
$LN42@DataServer:

; 479  : 					}
; 480  : 					break;

  0065e	eb 0e		 jmp	 SHORT $LN45@DataServer
$LN41@DataServer:

; 481  : 				case 0x02:
; 482  : 					{
; 483  : 						gBrotherhood.DG_RecvBrotherCount((DG_CheckBrother*)aRecv);

  00660	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00663	50		 push	 eax
  00664	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBrotherhood@@3VBrotherhood@@A ; gBrotherhood
  00669	e8 00 00 00 00	 call	 ?DG_RecvBrotherCount@Brotherhood@@QAEXPAUDG_CheckBrother@@@Z ; Brotherhood::DG_RecvBrotherCount
$LN45@DataServer:

; 484  : 					}
; 485  : 					break;
; 486  : 
; 487  : 				}
; 488  : 			}
; 489  : 			break;

  0066e	e9 31 02 00 00	 jmp	 $LN144@DataServer
$LN40@DataServer:

; 490  : 		case 0xE3:
; 491  : 			{
; 492  : 				gRanking.RecvDS((DGCharTop*)aRecv);

  00673	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00676	50		 push	 eax
  00677	b9 00 00 00 00	 mov	 ecx, OFFSET ?gRanking@@3VcRanking@@A ; gRanking
  0067c	e8 00 00 00 00	 call	 ?RecvDS@cRanking@@QAEXPAUDGCharTop@@@Z ; cRanking::RecvDS

; 493  : 			}
; 494  : 			break;

  00681	e9 1e 02 00 00	 jmp	 $LN144@DataServer

; 495  : 		case 0xE4:
; 496  : 			{
; 497  : 				
; 498  : 			}
; 499  : 			break;

  00686	e9 19 02 00 00	 jmp	 $LN144@DataServer
$LN38@DataServer:

; 500  : 		case 0xE5:
; 501  : 			{
; 502  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  0068b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0068e	89 45 dc	 mov	 DWORD PTR _lpMsg$245143[ebp], eax

; 503  : 
; 504  : 				switch(lpMsg->subcode)

  00691	8b 45 dc	 mov	 eax, DWORD PTR _lpMsg$245143[ebp]
  00694	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00697	88 4d 80	 mov	 BYTE PTR tv243[ebp], cl
  0069a	80 7d 80 00	 cmp	 BYTE PTR tv243[ebp], 0
  0069e	74 02		 je	 SHORT $LN35@DataServer
  006a0	eb 0e		 jmp	 SHORT $LN36@DataServer
$LN35@DataServer:

; 505  : 				{
; 506  : #if(CUSTOM_RETURNSPOT==TRUE)
; 507  : 				case 0x00:
; 508  : 					g_SpotReturn.DGStatus((PMSG_DG_SPOTSTATUS*)aRecv);

  006a2	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  006a5	50		 push	 eax
  006a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SpotReturn@@3VSpotReturn@@A ; g_SpotReturn
  006ab	e8 00 00 00 00	 call	 ?DGStatus@SpotReturn@@QAEXPAUPMSG_DG_SPOTSTATUS@@@Z ; SpotReturn::DGStatus
$LN36@DataServer:

; 509  : 					break;
; 510  : #endif
; 511  : 				}
; 512  : 			};
; 513  : 			break;

  006b0	e9 ef 01 00 00	 jmp	 $LN144@DataServer
$LN34@DataServer:

; 514  : 		case 0xEA:
; 515  : 			{
; 516  : 				PMSG_DEFAULT2* lpDef = (PMSG_DEFAULT2*)aRecv;

  006b5	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  006b8	89 45 d8	 mov	 DWORD PTR _lpDef$245152[ebp], eax

; 517  : 				g_ExGDManager.Protocol(lpDef->subcode, aRecv);

  006bb	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  006be	50		 push	 eax
  006bf	8b 4d d8	 mov	 ecx, DWORD PTR _lpDef$245152[ebp]
  006c2	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  006c6	52		 push	 edx
  006c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExGDManager@@3VCExGDManager@@A ; g_ExGDManager
  006cc	e8 00 00 00 00	 call	 ?Protocol@CExGDManager@@QAEXEPAE@Z ; CExGDManager::Protocol

; 518  : 			}
; 519  : 			break;

  006d1	e9 ce 01 00 00	 jmp	 $LN144@DataServer
$LN33@DataServer:

; 520  : 		case 0xEB:
; 521  : 			{
; 522  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  006d6	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  006d9	89 45 d4	 mov	 DWORD PTR _lpMsg$245155[ebp], eax

; 523  : 
; 524  : 				switch(lpMsg->subcode)

  006dc	8b 45 d4	 mov	 eax, DWORD PTR _lpMsg$245155[ebp]
  006df	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  006e3	89 4d 80	 mov	 DWORD PTR tv255[ebp], ecx
  006e6	83 7d 80 20	 cmp	 DWORD PTR tv255[ebp], 32 ; 00000020H
  006ea	0f 87 c5 00 00
	00		 ja	 $LN31@DataServer
  006f0	8b 55 80	 mov	 edx, DWORD PTR tv255[ebp]
  006f3	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN149@DataServer[edx]
  006fa	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN156@DataServer[eax*4]
$LN30@DataServer:

; 525  : 				{
; 526  : #if(CUSTOM_MARRIAGE)
; 527  : 				case 0x00:
; 528  : 					g_Marriage.DGLoad((PMSG_ANS_MARRIAGE_LOAD*) aRecv);

  00701	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00704	50		 push	 eax
  00705	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Marriage@@3VCMarriage@@A ; g_Marriage
  0070a	e8 00 00 00 00	 call	 ?DGLoad@CMarriage@@QAEXPAUPMSG_ANS_MARRIAGE_LOAD@@@Z ; CMarriage::DGLoad

; 529  : 					break;

  0070f	e9 a1 00 00 00	 jmp	 $LN31@DataServer
$LN29@DataServer:

; 530  : 				case 0x01:
; 531  : 					g_Marriage.DGInsert((PMSG_ANS_MARRIAGE_INSERT*) aRecv);

  00714	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00717	50		 push	 eax
  00718	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Marriage@@3VCMarriage@@A ; g_Marriage
  0071d	e8 00 00 00 00	 call	 ?DGInsert@CMarriage@@QAEXPAUPMSG_ANS_MARRIAGE_INSERT@@@Z ; CMarriage::DGInsert

; 532  : 					break;

  00722	e9 8e 00 00 00	 jmp	 $LN31@DataServer
$LN28@DataServer:

; 533  : 				case 0x02:
; 534  : 					g_Marriage.DGDelete((PMSG_ANS_MARRIAGE_DELETE*) aRecv);

  00727	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0072a	50		 push	 eax
  0072b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Marriage@@3VCMarriage@@A ; g_Marriage
  00730	e8 00 00 00 00	 call	 ?DGDelete@CMarriage@@QAEXPAUPMSG_ANS_MARRIAGE_DELETE@@@Z ; CMarriage::DGDelete

; 535  : 					break;

  00735	eb 7e		 jmp	 SHORT $LN31@DataServer
$LN27@DataServer:

; 536  : #endif
; 537  : #if(EVENT_DUNGEON_SIEGE)
; 538  : 				case 0x03:
; 539  : 					g_DungeonSiege.DGRegSiegeList((PMSG_DG_DUNGEON_SIEGE_REG_LIST*)aRecv); 

  00737	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0073a	50		 push	 eax
  0073b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  00740	e8 00 00 00 00	 call	 ?DGRegSiegeList@CDungeonSiege@@QAEXPAUPMSG_DG_DUNGEON_SIEGE_REG_LIST@@@Z ; CDungeonSiege::DGRegSiegeList

; 540  : 					break;

  00745	eb 6e		 jmp	 SHORT $LN31@DataServer
$LN26@DataServer:

; 541  : 				case 0x04:
; 542  : 					g_DungeonSiege.DGRegSiegeResult((PMSG_GD_DUNGEON_SIEGE_GUILD_REG_RESULT*)aRecv); 

  00747	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0074a	50		 push	 eax
  0074b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  00750	e8 00 00 00 00	 call	 ?DGRegSiegeResult@CDungeonSiege@@QAEXPAUPMSG_GD_DUNGEON_SIEGE_GUILD_REG_RESULT@@@Z ; CDungeonSiege::DGRegSiegeResult

; 543  : 					break;

  00755	eb 5e		 jmp	 SHORT $LN31@DataServer
$LN25@DataServer:

; 544  : 				case 0x06:
; 545  : 					g_DungeonSiege.DGSiegeOwner((PMSG_DG_DUNGEON_SIEGE_SELECT_OENER*)aRecv); 

  00757	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0075a	50		 push	 eax
  0075b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  00760	e8 00 00 00 00	 call	 ?DGSiegeOwner@CDungeonSiege@@QAEXPAUPMSG_DG_DUNGEON_SIEGE_SELECT_OENER@@@Z ; CDungeonSiege::DGSiegeOwner

; 546  : 					break;

  00765	eb 4e		 jmp	 SHORT $LN31@DataServer
$LN24@DataServer:

; 547  : #endif
; 548  : 				case 0x11:
; 549  : 					#if(OFFLINE_MODE_RESTORE)
; 550  : 					g_OfflineMode.DGAnsAccauntPassword((PMSG_DGANS_OFFMODE_START*)aRecv);

  00767	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0076a	50		 push	 eax
  0076b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  00770	e8 00 00 00 00	 call	 ?DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z ; OfflineMode::DGAnsAccauntPassword

; 551  : 					#endif
; 552  : #if(CUSTOM_REFERAL_SYSTEM)
; 553  : 				case 0x14:
; 554  : 					//g_ReferralSystem.DGAnsMasterInfo((PMSG_DGANS_REFERRAL_MASTER_INFO*)aRecv);
; 555  : 					break;

  00775	eb 3e		 jmp	 SHORT $LN31@DataServer
$LN22@DataServer:

; 556  : 				case 0x15:
; 557  : 					g_ReferralSystem.DGAnsMasterUpdate((PMSG_GDANS_REFERRAL_MASTER_UPDATE*)aRecv);

  00777	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0077a	50		 push	 eax
  0077b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  00780	e8 00 00 00 00	 call	 ?DGAnsMasterUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_MASTER_UPDATE@@@Z ; CReferralSystem::DGAnsMasterUpdate

; 558  : 					break;

  00785	eb 2e		 jmp	 SHORT $LN31@DataServer
$LN21@DataServer:

; 559  : 				case 0x16:
; 560  : 					g_ReferralSystem.DGAnsUserInfo((PMSG_DGANS_REFERRAL_USER_INFO*)aRecv);

  00787	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0078a	50		 push	 eax
  0078b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  00790	e8 00 00 00 00	 call	 ?DGAnsUserInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_USER_INFO@@@Z ; CReferralSystem::DGAnsUserInfo

; 561  : 					break;

  00795	eb 1e		 jmp	 SHORT $LN31@DataServer
$LN20@DataServer:

; 562  : 				case 0x17:
; 563  : 					g_ReferralSystem.DGAnsUserUpdate((PMSG_GDANS_REFERRAL_USER_UPDATE*)aRecv);

  00797	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0079a	50		 push	 eax
  0079b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  007a0	e8 00 00 00 00	 call	 ?DGAnsUserUpdate@CReferralSystem@@QAEXPAUPMSG_GDANS_REFERRAL_USER_UPDATE@@@Z ; CReferralSystem::DGAnsUserUpdate

; 564  : 					break;

  007a5	eb 0e		 jmp	 SHORT $LN31@DataServer
$LN19@DataServer:

; 565  : #endif
; 566  : #if(DEV_BANSYSTEM)
; 567  : 				case 0x20:
; 568  : 					g_BanSystem.DSAnsSelect((PMSG_SELECT_BANSYSTEM*)aRecv);

  007a7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007aa	50		 push	 eax
  007ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BanSystem@@3VCBanSystem@@A ; g_BanSystem
  007b0	e8 00 00 00 00	 call	 ?DSAnsSelect@CBanSystem@@QAEXPAUPMSG_SELECT_BANSYSTEM@@@Z ; CBanSystem::DSAnsSelect
$LN31@DataServer:

; 569  : 					break;
; 570  : #endif
; 571  : 				}
; 572  : 			}
; 573  : 			break;

  007b5	e9 ea 00 00 00	 jmp	 $LN144@DataServer
$LN18@DataServer:

; 574  : 		case 0xE1:
; 575  : 			{
; 576  : 				PWMSG_HEAD2 * lpMsg = (PWMSG_HEAD2*)aRecv;

  007ba	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007bd	89 45 d0	 mov	 DWORD PTR _lpMsg$245185[ebp], eax

; 577  : 
; 578  : 				switch(lpMsg->subcode)

  007c0	8b 45 d0	 mov	 eax, DWORD PTR _lpMsg$245185[ebp]
  007c3	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  007c6	88 4d 80	 mov	 BYTE PTR tv281[ebp], cl
  007c9	80 7d 80 00	 cmp	 BYTE PTR tv281[ebp], 0
  007cd	74 02		 je	 SHORT $LN15@DataServer
  007cf	eb 0e		 jmp	 SHORT $LN16@DataServer
$LN15@DataServer:

; 579  : 				{
; 580  : #if(CUSTOM_REFERAL_SYSTEM)
; 581  : 				case 0x00:
; 582  : 					g_ReferralSystem.DGAnsMasterInfo((PMSG_DGANS_REFERRAL_MASTER_INFO*)aRecv);

  007d1	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007d4	50		 push	 eax
  007d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  007da	e8 00 00 00 00	 call	 ?DGAnsMasterInfo@CReferralSystem@@QAEXPAUPMSG_DGANS_REFERRAL_MASTER_INFO@@@Z ; CReferralSystem::DGAnsMasterInfo
$LN16@DataServer:

; 583  : 					break;
; 584  : #endif
; 585  : 				}
; 586  : 			}
; 587  : 			break;

  007df	e9 c0 00 00 00	 jmp	 $LN144@DataServer
$LN14@DataServer:

; 588  : 		case 0xEC:
; 589  : 			#if(OFFLINE_MODE_RESTORE)
; 590  : 			g_OfflineMode.DGAnsOffCharacter((SDHP_DBCHAR_INFORESULT*)aRecv);

  007e4	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007e7	50		 push	 eax
  007e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  007ed	e8 00 00 00 00	 call	 ?DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z ; OfflineMode::DGAnsOffCharacter

; 591  : 			#endif
; 592  : 			break;

  007f2	e9 ad 00 00 00	 jmp	 $LN144@DataServer
$LN13@DataServer:

; 593  : 		case 0xED:
; 594  : 			#if(OFFLINE_MODE_RESTORE)
; 595  : 			g_OfflineMode.DGPSelectData((PMSG_GDLOAD_OFFMODE_DATA*) aRecv);

  007f7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007fa	50		 push	 eax
  007fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  00800	e8 00 00 00 00	 call	 ?DGPSelectData@OfflineMode@@QAEXPAUPMSG_GDLOAD_OFFMODE_DATA@@@Z ; OfflineMode::DGPSelectData

; 596  : 			#endif
; 597  : 			break;

  00805	e9 9a 00 00 00	 jmp	 $LN144@DataServer
$LN12@DataServer:

; 598  : 		case 0xEE:
; 599  : 			{
; 600  : 				PMSG_DEFAULT2* lpDef = (PMSG_DEFAULT2*)aRecv;

  0080a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0080d	89 45 cc	 mov	 DWORD PTR _lpDef$245198[ebp], eax

; 601  : 				g_ExWebManager.Protocol(lpDef->subcode, aRecv);

  00810	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00813	50		 push	 eax
  00814	8b 4d cc	 mov	 ecx, DWORD PTR _lpDef$245198[ebp]
  00817	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0081b	52		 push	 edx
  0081c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExWebManager@@3VCExWebManager@@A ; g_ExWebManager
  00821	e8 00 00 00 00	 call	 ?Protocol@CExWebManager@@QAEXEPAE@Z ; CExWebManager::Protocol

; 602  : 			}
; 603  : 			break;

  00826	eb 7c		 jmp	 SHORT $LN144@DataServer
$LN11@DataServer:

; 604  : 		case 0xEF:
; 605  : 			{
; 606  : 				PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  00828	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0082b	89 45 c8	 mov	 DWORD PTR _lpMsg$245201[ebp], eax

; 607  : 
; 608  : 				switch(lpMsg->subcode)

  0082e	8b 45 c8	 mov	 eax, DWORD PTR _lpMsg$245201[ebp]
  00831	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00834	88 4d 80	 mov	 BYTE PTR tv297[ebp], cl
  00837	80 7d 80 00	 cmp	 BYTE PTR tv297[ebp], 0
  0083b	74 08		 je	 SHORT $LN8@DataServer
  0083d	80 7d 80 01	 cmp	 BYTE PTR tv297[ebp], 1
  00841	74 12		 je	 SHORT $LN7@DataServer
  00843	eb 1e		 jmp	 SHORT $LN9@DataServer
$LN8@DataServer:

; 609  : 				{
; 610  : 				case 0x00:
; 611  : 					g_AccountSecurity.DGAnsLoad((PMSG_ANS_ACC_DATABASE_LOAD*)aRecv);

  00845	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00848	50		 push	 eax
  00849	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  0084e	e8 00 00 00 00	 call	 ?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z ; CAccountSecurity::DGAnsLoad

; 612  : 					break;

  00853	eb 0e		 jmp	 SHORT $LN9@DataServer
$LN7@DataServer:

; 613  : 				case 0x01:
; 614  : 					g_AccountSecurity.DGAnsSave((PMSG_ANS_ACC_DATABASE_SAVE*)aRecv);

  00855	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00858	50		 push	 eax
  00859	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  0085e	e8 00 00 00 00	 call	 ?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z ; CAccountSecurity::DGAnsSave
$LN9@DataServer:

; 615  : 					break;
; 616  : 				}
; 617  : 			}
; 618  : 			break;

  00863	eb 3f		 jmp	 SHORT $LN144@DataServer
$LN6@DataServer:

; 619  : 		case 0xFD:
; 620  : 		{
; 621  : 			PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;

  00865	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00868	89 45 c4	 mov	 DWORD PTR _lpMsg$245212[ebp], eax

; 622  : 			switch (lpMsg->subcode)

  0086b	8b 45 c4	 mov	 eax, DWORD PTR _lpMsg$245212[ebp]
  0086e	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00871	88 4d 80	 mov	 BYTE PTR tv308[ebp], cl
  00874	80 7d 80 01	 cmp	 BYTE PTR tv308[ebp], 1
  00878	74 02		 je	 SHORT $LN3@DataServer
  0087a	eb 0c		 jmp	 SHORT $LN4@DataServer
$LN3@DataServer:

; 623  : 			{
; 624  : #if(CUSTOM_MULTIWAREHOUSE)
; 625  : 				case 0x01:
; 626  : 					GDGetWarehouseNumber((LOADWAREHOUSENUMBER_SAVE*)aRecv);

  0087c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0087f	50		 push	 eax
  00880	e8 00 00 00 00	 call	 ?GDGetWarehouseNumber@@YAXPAULOADWAREHOUSENUMBER_SAVE@@@Z ; GDGetWarehouseNumber
  00885	83 c4 04	 add	 esp, 4
$LN4@DataServer:

; 627  : 					break;
; 628  : #endif
; 629  : 			}
; 630  : 		}
; 631  : 		break;

  00888	eb 1a		 jmp	 SHORT $LN144@DataServer
$LN2@DataServer:

; 632  : 
; 633  : #if (DEV_GUILDBANK)
; 634  : 		//case Protocol_GSRecv_GetWarehouseList:
; 635  : 		//	DGGetWarehouseList((SDHP_GETWAREHOUSEDB_SAVE *)aRecv);
; 636  : 		//	break;
; 637  : 		case Protocol_GSRecv_GetWarehouseNoItem:
; 638  : 			GDGetWarehouseNoItem((SDHP_GETWAREHOUSEDB_RESULT *)aRecv);

  0088a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 ?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem
  00893	83 c4 04	 add	 esp, 4

; 639  : 			break;

  00896	eb 0c		 jmp	 SHORT $LN144@DataServer
$LN1@DataServer:

; 640  : 		//case Protocol_GSRecv_GetWarehouseList:
; 641  : 		//	DGGetWarehouseList((SDHP_GETWAREHOUSEDB_SAVE *)aRecv);
; 642  : 		//	break;
; 643  : 		case Protocol_GSRecv_GetGuildWarehouseList:
; 644  : 			DGGetWarehouseList((SDHP_GETWAREHOUSEDB_SAVE *)aRecv);

  00898	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0089b	50		 push	 eax
  0089c	e8 00 00 00 00	 call	 ?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList
  008a1	83 c4 04	 add	 esp, 4
$LN144@DataServer:

; 645  : 			break;
; 646  : #endif
; 647  : 
; 648  : 	}
; 649  : }

  008a4	5f		 pop	 edi
  008a5	5e		 pop	 esi
  008a6	5b		 pop	 ebx
  008a7	8b e5		 mov	 esp, ebp
  008a9	5d		 pop	 ebp
  008aa	c3		 ret	 0
  008ab	90		 npad	 1
$LN150@DataServer:
  008ac	00 00 00 00	 DD	 $LN141@DataServer
  008b0	00 00 00 00	 DD	 $LN140@DataServer
  008b4	00 00 00 00	 DD	 $LN139@DataServer
  008b8	00 00 00 00	 DD	 $LN138@DataServer
  008bc	00 00 00 00	 DD	 $LN137@DataServer
  008c0	00 00 00 00	 DD	 $LN136@DataServer
  008c4	00 00 00 00	 DD	 $LN135@DataServer
  008c8	00 00 00 00	 DD	 $LN134@DataServer
  008cc	00 00 00 00	 DD	 $LN133@DataServer
  008d0	00 00 00 00	 DD	 $LN132@DataServer
  008d4	00 00 00 00	 DD	 $LN131@DataServer
  008d8	00 00 00 00	 DD	 $LN130@DataServer
  008dc	00 00 00 00	 DD	 $LN129@DataServer
  008e0	00 00 00 00	 DD	 $LN128@DataServer
  008e4	00 00 00 00	 DD	 $LN127@DataServer
  008e8	00 00 00 00	 DD	 $LN100@DataServer
  008ec	00 00 00 00	 DD	 $LN99@DataServer
  008f0	00 00 00 00	 DD	 $LN98@DataServer
  008f4	00 00 00 00	 DD	 $LN97@DataServer
  008f8	00 00 00 00	 DD	 $LN96@DataServer
  008fc	00 00 00 00	 DD	 $LN95@DataServer
  00900	00 00 00 00	 DD	 $LN94@DataServer
  00904	00 00 00 00	 DD	 $LN93@DataServer
  00908	00 00 00 00	 DD	 $LN92@DataServer
  0090c	00 00 00 00	 DD	 $LN80@DataServer
  00910	00 00 00 00	 DD	 $LN79@DataServer
  00914	00 00 00 00	 DD	 $LN91@DataServer
  00918	00 00 00 00	 DD	 $LN90@DataServer
  0091c	00 00 00 00	 DD	 $LN89@DataServer
  00920	00 00 00 00	 DD	 $LN2@DataServer
  00924	00 00 00 00	 DD	 $LN144@DataServer
$LN147@DataServer:
  00928	00		 DB	 0
  00929	01		 DB	 1
  0092a	1e		 DB	 30			; 0000001eH
  0092b	1e		 DB	 30			; 0000001eH
  0092c	02		 DB	 2
  0092d	03		 DB	 3
  0092e	04		 DB	 4
  0092f	1e		 DB	 30			; 0000001eH
  00930	05		 DB	 5
  00931	1e		 DB	 30			; 0000001eH
  00932	1e		 DB	 30			; 0000001eH
  00933	1e		 DB	 30			; 0000001eH
  00934	1e		 DB	 30			; 0000001eH
  00935	1e		 DB	 30			; 0000001eH
  00936	1e		 DB	 30			; 0000001eH
  00937	1e		 DB	 30			; 0000001eH
  00938	06		 DB	 6
  00939	1e		 DB	 30			; 0000001eH
  0093a	1e		 DB	 30			; 0000001eH
  0093b	1e		 DB	 30			; 0000001eH
  0093c	07		 DB	 7
  0093d	1e		 DB	 30			; 0000001eH
  0093e	08		 DB	 8
  0093f	09		 DB	 9
  00940	1e		 DB	 30			; 0000001eH
  00941	1e		 DB	 30			; 0000001eH
  00942	1e		 DB	 30			; 0000001eH
  00943	1e		 DB	 30			; 0000001eH
  00944	1e		 DB	 30			; 0000001eH
  00945	1e		 DB	 30			; 0000001eH
  00946	1e		 DB	 30			; 0000001eH
  00947	1e		 DB	 30			; 0000001eH
  00948	1e		 DB	 30			; 0000001eH
  00949	1e		 DB	 30			; 0000001eH
  0094a	1e		 DB	 30			; 0000001eH
  0094b	1e		 DB	 30			; 0000001eH
  0094c	1e		 DB	 30			; 0000001eH
  0094d	1e		 DB	 30			; 0000001eH
  0094e	1e		 DB	 30			; 0000001eH
  0094f	1e		 DB	 30			; 0000001eH
  00950	1e		 DB	 30			; 0000001eH
  00951	1e		 DB	 30			; 0000001eH
  00952	1e		 DB	 30			; 0000001eH
  00953	1e		 DB	 30			; 0000001eH
  00954	1e		 DB	 30			; 0000001eH
  00955	1e		 DB	 30			; 0000001eH
  00956	1e		 DB	 30			; 0000001eH
  00957	1e		 DB	 30			; 0000001eH
  00958	0a		 DB	 10			; 0000000aH
  00959	1e		 DB	 30			; 0000001eH
  0095a	1e		 DB	 30			; 0000001eH
  0095b	1e		 DB	 30			; 0000001eH
  0095c	1e		 DB	 30			; 0000001eH
  0095d	1e		 DB	 30			; 0000001eH
  0095e	1e		 DB	 30			; 0000001eH
  0095f	1e		 DB	 30			; 0000001eH
  00960	1e		 DB	 30			; 0000001eH
  00961	1e		 DB	 30			; 0000001eH
  00962	1e		 DB	 30			; 0000001eH
  00963	1e		 DB	 30			; 0000001eH
  00964	1e		 DB	 30			; 0000001eH
  00965	1e		 DB	 30			; 0000001eH
  00966	1e		 DB	 30			; 0000001eH
  00967	1e		 DB	 30			; 0000001eH
  00968	1e		 DB	 30			; 0000001eH
  00969	1e		 DB	 30			; 0000001eH
  0096a	1e		 DB	 30			; 0000001eH
  0096b	1e		 DB	 30			; 0000001eH
  0096c	1e		 DB	 30			; 0000001eH
  0096d	1e		 DB	 30			; 0000001eH
  0096e	1e		 DB	 30			; 0000001eH
  0096f	1e		 DB	 30			; 0000001eH
  00970	1e		 DB	 30			; 0000001eH
  00971	1e		 DB	 30			; 0000001eH
  00972	1e		 DB	 30			; 0000001eH
  00973	1e		 DB	 30			; 0000001eH
  00974	1e		 DB	 30			; 0000001eH
  00975	1e		 DB	 30			; 0000001eH
  00976	1e		 DB	 30			; 0000001eH
  00977	1e		 DB	 30			; 0000001eH
  00978	1e		 DB	 30			; 0000001eH
  00979	1e		 DB	 30			; 0000001eH
  0097a	0b		 DB	 11			; 0000000bH
  0097b	1e		 DB	 30			; 0000001eH
  0097c	1e		 DB	 30			; 0000001eH
  0097d	1e		 DB	 30			; 0000001eH
  0097e	0c		 DB	 12			; 0000000cH
  0097f	1e		 DB	 30			; 0000001eH
  00980	1e		 DB	 30			; 0000001eH
  00981	1e		 DB	 30			; 0000001eH
  00982	1e		 DB	 30			; 0000001eH
  00983	1e		 DB	 30			; 0000001eH
  00984	1e		 DB	 30			; 0000001eH
  00985	1e		 DB	 30			; 0000001eH
  00986	1e		 DB	 30			; 0000001eH
  00987	1e		 DB	 30			; 0000001eH
  00988	0d		 DB	 13			; 0000000dH
  00989	1e		 DB	 30			; 0000001eH
  0098a	1e		 DB	 30			; 0000001eH
  0098b	1e		 DB	 30			; 0000001eH
  0098c	1e		 DB	 30			; 0000001eH
  0098d	1e		 DB	 30			; 0000001eH
  0098e	1e		 DB	 30			; 0000001eH
  0098f	1e		 DB	 30			; 0000001eH
  00990	1e		 DB	 30			; 0000001eH
  00991	1e		 DB	 30			; 0000001eH
  00992	1e		 DB	 30			; 0000001eH
  00993	1e		 DB	 30			; 0000001eH
  00994	1e		 DB	 30			; 0000001eH
  00995	1e		 DB	 30			; 0000001eH
  00996	1e		 DB	 30			; 0000001eH
  00997	1e		 DB	 30			; 0000001eH
  00998	1e		 DB	 30			; 0000001eH
  00999	1e		 DB	 30			; 0000001eH
  0099a	1e		 DB	 30			; 0000001eH
  0099b	1e		 DB	 30			; 0000001eH
  0099c	1e		 DB	 30			; 0000001eH
  0099d	1e		 DB	 30			; 0000001eH
  0099e	1e		 DB	 30			; 0000001eH
  0099f	1e		 DB	 30			; 0000001eH
  009a0	1e		 DB	 30			; 0000001eH
  009a1	1e		 DB	 30			; 0000001eH
  009a2	1e		 DB	 30			; 0000001eH
  009a3	1e		 DB	 30			; 0000001eH
  009a4	1e		 DB	 30			; 0000001eH
  009a5	1e		 DB	 30			; 0000001eH
  009a6	1e		 DB	 30			; 0000001eH
  009a7	1e		 DB	 30			; 0000001eH
  009a8	0e		 DB	 14			; 0000000eH
  009a9	0f		 DB	 15			; 0000000fH
  009aa	10		 DB	 16			; 00000010H
  009ab	11		 DB	 17			; 00000011H
  009ac	12		 DB	 18			; 00000012H
  009ad	13		 DB	 19			; 00000013H
  009ae	14		 DB	 20			; 00000014H
  009af	15		 DB	 21			; 00000015H
  009b0	16		 DB	 22			; 00000016H
  009b1	17		 DB	 23			; 00000017H
  009b2	1e		 DB	 30			; 0000001eH
  009b3	1e		 DB	 30			; 0000001eH
  009b4	1e		 DB	 30			; 0000001eH
  009b5	1e		 DB	 30			; 0000001eH
  009b6	1e		 DB	 30			; 0000001eH
  009b7	1e		 DB	 30			; 0000001eH
  009b8	1e		 DB	 30			; 0000001eH
  009b9	1e		 DB	 30			; 0000001eH
  009ba	1e		 DB	 30			; 0000001eH
  009bb	1e		 DB	 30			; 0000001eH
  009bc	1e		 DB	 30			; 0000001eH
  009bd	1e		 DB	 30			; 0000001eH
  009be	1e		 DB	 30			; 0000001eH
  009bf	1e		 DB	 30			; 0000001eH
  009c0	1e		 DB	 30			; 0000001eH
  009c1	1e		 DB	 30			; 0000001eH
  009c2	1e		 DB	 30			; 0000001eH
  009c3	1e		 DB	 30			; 0000001eH
  009c4	1e		 DB	 30			; 0000001eH
  009c5	1e		 DB	 30			; 0000001eH
  009c6	1e		 DB	 30			; 0000001eH
  009c7	1e		 DB	 30			; 0000001eH
  009c8	1e		 DB	 30			; 0000001eH
  009c9	18		 DB	 24			; 00000018H
  009ca	19		 DB	 25			; 00000019H
  009cb	1e		 DB	 30			; 0000001eH
  009cc	1e		 DB	 30			; 0000001eH
  009cd	1e		 DB	 30			; 0000001eH
  009ce	1e		 DB	 30			; 0000001eH
  009cf	1e		 DB	 30			; 0000001eH
  009d0	1e		 DB	 30			; 0000001eH
  009d1	1e		 DB	 30			; 0000001eH
  009d2	1e		 DB	 30			; 0000001eH
  009d3	1e		 DB	 30			; 0000001eH
  009d4	1e		 DB	 30			; 0000001eH
  009d5	1e		 DB	 30			; 0000001eH
  009d6	1e		 DB	 30			; 0000001eH
  009d7	1e		 DB	 30			; 0000001eH
  009d8	1a		 DB	 26			; 0000001aH
  009d9	1b		 DB	 27			; 0000001bH
  009da	1c		 DB	 28			; 0000001cH
  009db	1e		 DB	 30			; 0000001eH
  009dc	1e		 DB	 30			; 0000001eH
  009dd	1e		 DB	 30			; 0000001eH
  009de	1e		 DB	 30			; 0000001eH
  009df	1e		 DB	 30			; 0000001eH
  009e0	1e		 DB	 30			; 0000001eH
  009e1	1e		 DB	 30			; 0000001eH
  009e2	1e		 DB	 30			; 0000001eH
  009e3	1e		 DB	 30			; 0000001eH
  009e4	1e		 DB	 30			; 0000001eH
  009e5	1e		 DB	 30			; 0000001eH
  009e6	1e		 DB	 30			; 0000001eH
  009e7	1e		 DB	 30			; 0000001eH
  009e8	1e		 DB	 30			; 0000001eH
  009e9	1e		 DB	 30			; 0000001eH
  009ea	1e		 DB	 30			; 0000001eH
  009eb	1e		 DB	 30			; 0000001eH
  009ec	1e		 DB	 30			; 0000001eH
  009ed	1e		 DB	 30			; 0000001eH
  009ee	1d		 DB	 29			; 0000001dH
  009ef	90		 npad	 1
$LN151@DataServer:
  009f0	00 00 00 00	 DD	 $LN87@DataServer
  009f4	00 00 00 00	 DD	 $LN57@DataServer
  009f8	00 00 00 00	 DD	 $LN62@DataServer
  009fc	00 00 00 00	 DD	 $LN66@DataServer
  00a00	00 00 00 00	 DD	 $LN58@DataServer
  00a04	00 00 00 00	 DD	 $LN49@DataServer
  00a08	00 00 00 00	 DD	 $LN48@DataServer
  00a0c	00 00 00 00	 DD	 $LN1@DataServer
  00a10	00 00 00 00	 DD	 $LN75@DataServer
  00a14	00 00 00 00	 DD	 $LN18@DataServer
  00a18	00 00 00 00	 DD	 $LN47@DataServer
  00a1c	00 00 00 00	 DD	 $LN40@DataServer
  00a20	00 00 00 00	 DD	 $LN38@DataServer
  00a24	00 00 00 00	 DD	 $LN34@DataServer
  00a28	00 00 00 00	 DD	 $LN33@DataServer
  00a2c	00 00 00 00	 DD	 $LN14@DataServer
  00a30	00 00 00 00	 DD	 $LN13@DataServer
  00a34	00 00 00 00	 DD	 $LN12@DataServer
  00a38	00 00 00 00	 DD	 $LN11@DataServer
  00a3c	00 00 00 00	 DD	 $LN74@DataServer
  00a40	00 00 00 00	 DD	 $LN6@DataServer
  00a44	00 00 00 00	 DD	 $LN78@DataServer
  00a48	00 00 00 00	 DD	 $LN144@DataServer
$LN148@DataServer:
  00a4c	00		 DB	 0
  00a4d	01		 DB	 1
  00a4e	02		 DB	 2
  00a4f	03		 DB	 3
  00a50	04		 DB	 4
  00a51	05		 DB	 5
  00a52	06		 DB	 6
  00a53	07		 DB	 7
  00a54	16		 DB	 22			; 00000016H
  00a55	16		 DB	 22			; 00000016H
  00a56	16		 DB	 22			; 00000016H
  00a57	16		 DB	 22			; 00000016H
  00a58	16		 DB	 22			; 00000016H
  00a59	16		 DB	 22			; 00000016H
  00a5a	16		 DB	 22			; 00000016H
  00a5b	16		 DB	 22			; 00000016H
  00a5c	08		 DB	 8
  00a5d	09		 DB	 9
  00a5e	0a		 DB	 10			; 0000000aH
  00a5f	0b		 DB	 11			; 0000000bH
  00a60	16		 DB	 22			; 00000016H
  00a61	0c		 DB	 12			; 0000000cH
  00a62	16		 DB	 22			; 00000016H
  00a63	16		 DB	 22			; 00000016H
  00a64	16		 DB	 22			; 00000016H
  00a65	16		 DB	 22			; 00000016H
  00a66	0d		 DB	 13			; 0000000dH
  00a67	0e		 DB	 14			; 0000000eH
  00a68	0f		 DB	 15			; 0000000fH
  00a69	10		 DB	 16			; 00000010H
  00a6a	11		 DB	 17			; 00000011H
  00a6b	12		 DB	 18			; 00000012H
  00a6c	16		 DB	 22			; 00000016H
  00a6d	16		 DB	 22			; 00000016H
  00a6e	16		 DB	 22			; 00000016H
  00a6f	16		 DB	 22			; 00000016H
  00a70	16		 DB	 22			; 00000016H
  00a71	16		 DB	 22			; 00000016H
  00a72	16		 DB	 22			; 00000016H
  00a73	16		 DB	 22			; 00000016H
  00a74	13		 DB	 19			; 00000013H
  00a75	16		 DB	 22			; 00000016H
  00a76	16		 DB	 22			; 00000016H
  00a77	16		 DB	 22			; 00000016H
  00a78	16		 DB	 22			; 00000016H
  00a79	14		 DB	 20			; 00000014H
  00a7a	16		 DB	 22			; 00000016H
  00a7b	15		 DB	 21			; 00000015H
$LN152@DataServer:
  00a7c	00 00 00 00	 DD	 $LN124@DataServer
  00a80	00 00 00 00	 DD	 $LN123@DataServer
  00a84	00 00 00 00	 DD	 $LN125@DataServer
  00a88	00 00 00 00	 DD	 $LN122@DataServer
  00a8c	00 00 00 00	 DD	 $LN121@DataServer
  00a90	00 00 00 00	 DD	 $LN120@DataServer
  00a94	00 00 00 00	 DD	 $LN119@DataServer
  00a98	00 00 00 00	 DD	 $LN118@DataServer
  00a9c	00 00 00 00	 DD	 $LN117@DataServer
  00aa0	00 00 00 00	 DD	 $LN116@DataServer
  00aa4	00 00 00 00	 DD	 $LN115@DataServer
  00aa8	00 00 00 00	 DD	 $LN114@DataServer
  00aac	00 00 00 00	 DD	 $LN113@DataServer
  00ab0	00 00 00 00	 DD	 $LN112@DataServer
  00ab4	00 00 00 00	 DD	 $LN111@DataServer
  00ab8	00 00 00 00	 DD	 $LN110@DataServer
  00abc	00 00 00 00	 DD	 $LN109@DataServer
  00ac0	00 00 00 00	 DD	 $LN108@DataServer
  00ac4	00 00 00 00	 DD	 $LN107@DataServer
  00ac8	00 00 00 00	 DD	 $LN125@DataServer
  00acc	00 00 00 00	 DD	 $LN125@DataServer
  00ad0	00 00 00 00	 DD	 $LN125@DataServer
  00ad4	00 00 00 00	 DD	 $LN106@DataServer
  00ad8	00 00 00 00	 DD	 $LN105@DataServer
  00adc	00 00 00 00	 DD	 $LN104@DataServer
  00ae0	00 00 00 00	 DD	 $LN103@DataServer
  00ae4	00 00 00 00	 DD	 $LN102@DataServer
  00ae8	00 00 00 00	 DD	 $LN101@DataServer
$LN153@DataServer:
  00aec	00 00 00 00	 DD	 $LN84@DataServer
  00af0	00 00 00 00	 DD	 $LN85@DataServer
  00af4	00 00 00 00	 DD	 $LN83@DataServer
  00af8	00 00 00 00	 DD	 $LN85@DataServer
  00afc	00 00 00 00	 DD	 $LN82@DataServer
  00b00	00 00 00 00	 DD	 $LN85@DataServer
  00b04	00 00 00 00	 DD	 $LN81@DataServer
$LN154@DataServer:
  00b08	00 00 00 00	 DD	 $LN70@DataServer
  00b0c	00 00 00 00	 DD	 $LN73@DataServer
  00b10	00 00 00 00	 DD	 $LN69@DataServer
  00b14	00 00 00 00	 DD	 $LN68@DataServer
  00b18	00 00 00 00	 DD	 $LN67@DataServer
$LN155@DataServer:
  00b1c	00 00 00 00	 DD	 $LN54@DataServer
  00b20	00 00 00 00	 DD	 $LN53@DataServer
  00b24	00 00 00 00	 DD	 $LN52@DataServer
  00b28	00 00 00 00	 DD	 $LN51@DataServer
  00b2c	00 00 00 00	 DD	 $LN50@DataServer
$LN156@DataServer:
  00b30	00 00 00 00	 DD	 $LN30@DataServer
  00b34	00 00 00 00	 DD	 $LN29@DataServer
  00b38	00 00 00 00	 DD	 $LN28@DataServer
  00b3c	00 00 00 00	 DD	 $LN27@DataServer
  00b40	00 00 00 00	 DD	 $LN26@DataServer
  00b44	00 00 00 00	 DD	 $LN25@DataServer
  00b48	00 00 00 00	 DD	 $LN24@DataServer
  00b4c	00 00 00 00	 DD	 $LN22@DataServer
  00b50	00 00 00 00	 DD	 $LN21@DataServer
  00b54	00 00 00 00	 DD	 $LN20@DataServer
  00b58	00 00 00 00	 DD	 $LN19@DataServer
  00b5c	00 00 00 00	 DD	 $LN31@DataServer
$LN149@DataServer:
  00b60	00		 DB	 0
  00b61	01		 DB	 1
  00b62	02		 DB	 2
  00b63	03		 DB	 3
  00b64	04		 DB	 4
  00b65	0b		 DB	 11			; 0000000bH
  00b66	05		 DB	 5
  00b67	0b		 DB	 11			; 0000000bH
  00b68	0b		 DB	 11			; 0000000bH
  00b69	0b		 DB	 11			; 0000000bH
  00b6a	0b		 DB	 11			; 0000000bH
  00b6b	0b		 DB	 11			; 0000000bH
  00b6c	0b		 DB	 11			; 0000000bH
  00b6d	0b		 DB	 11			; 0000000bH
  00b6e	0b		 DB	 11			; 0000000bH
  00b6f	0b		 DB	 11			; 0000000bH
  00b70	0b		 DB	 11			; 0000000bH
  00b71	06		 DB	 6
  00b72	0b		 DB	 11			; 0000000bH
  00b73	0b		 DB	 11			; 0000000bH
  00b74	0b		 DB	 11			; 0000000bH
  00b75	07		 DB	 7
  00b76	08		 DB	 8
  00b77	09		 DB	 9
  00b78	0b		 DB	 11			; 0000000bH
  00b79	0b		 DB	 11			; 0000000bH
  00b7a	0b		 DB	 11			; 0000000bH
  00b7b	0b		 DB	 11			; 0000000bH
  00b7c	0b		 DB	 11			; 0000000bH
  00b7d	0b		 DB	 11			; 0000000bH
  00b7e	0b		 DB	 11			; 0000000bH
  00b7f	0b		 DB	 11			; 0000000bH
  00b80	0a		 DB	 10			; 0000000aH
?DataServerProtocolCore@@YAXEPAEH@Z ENDP		; DataServerProtocolCore
_TEXT	ENDS
PUBLIC	??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?TestDSSend@@YAXXZ				; TestDSSend
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__imp__wsprintfA:PROC
EXTRN	?iCount@@3HA:DWORD				; iCount
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@
CONST	SEGMENT
??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@ DB 'Test Data Send', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_size$ = -2012						; size = 4
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestDSSend@@YAXXZ PROC					; TestDSSend

; 653  : {

  00b90	55		 push	 ebp
  00b91	8b ec		 mov	 ebp, esp
  00b93	81 ec 1c 08 00
	00		 sub	 esp, 2076		; 0000081cH
  00b99	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00b9e	33 c5		 xor	 eax, ebp
  00ba0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00ba3	53		 push	 ebx
  00ba4	56		 push	 esi
  00ba5	57		 push	 edi

; 654  : 	PMSG_TEST pMsg;
; 655  : 	int size;
; 656  : 
; 657  : 	size = sizeof(PMSG_TEST);

  00ba6	c7 85 24 f8 ff
	ff d4 07 00 00	 mov	 DWORD PTR _size$[ebp], 2004 ; 000007d4H

; 658  : 	pMsg.h.c=0xC2;

  00bb0	c6 85 28 f8 ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 659  : 	pMsg.h.headcode =0xFF;

  00bb7	c6 85 2b f8 ff
	ff ff		 mov	 BYTE PTR _pMsg$[ebp+3], 255 ; 000000ffH

; 660  : 	pMsg.h.sizeH = SET_NUMBERH(size);

  00bbe	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00bc4	c1 e8 08	 shr	 eax, 8
  00bc7	88 85 29 f8 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], al

; 661  : 	pMsg.h.sizeL = SET_NUMBERL(size);

  00bcd	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00bd3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00bd8	88 85 2a f8 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], al

; 662  : 
; 663  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00bde	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00be3	50		 push	 eax
  00be4	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00be9	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00bef	51		 push	 ecx
  00bf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00bf6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 664  : 	LogAdd("%s", pMsg.testbuf );

  00bf9	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00bff	50		 push	 eax
  00c00	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00c05	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00c0b	83 c4 08	 add	 esp, 8

; 665  : 	cDBSMng.Send((char *)&pMsg, size);

  00c0e	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00c14	50		 push	 eax
  00c15	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00c1b	51		 push	 ecx
  00c1c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00c21	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 666  : 	iCount++;

  00c26	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00c2b	83 c0 01	 add	 eax, 1
  00c2e	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 667  : 
; 668  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00c33	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00c38	50		 push	 eax
  00c39	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00c3e	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00c44	51		 push	 ecx
  00c45	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00c4b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 669  : 	LogAdd("%s", pMsg.testbuf);

  00c4e	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00c54	50		 push	 eax
  00c55	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00c5a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00c60	83 c4 08	 add	 esp, 8

; 670  : 	cDBSMng.Send((char *)&pMsg, size);

  00c63	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00c69	50		 push	 eax
  00c6a	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00c70	51		 push	 ecx
  00c71	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00c76	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 671  : 	iCount++;

  00c7b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00c80	83 c0 01	 add	 eax, 1
  00c83	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 672  : 
; 673  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00c88	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00c8d	50		 push	 eax
  00c8e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00c93	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00c99	51		 push	 ecx
  00c9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00ca0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 674  : 	LogAdd("%s", pMsg.testbuf);

  00ca3	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00ca9	50		 push	 eax
  00caa	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00caf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00cb5	83 c4 08	 add	 esp, 8

; 675  : 	cDBSMng.Send((char *)&pMsg, size);

  00cb8	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00cbe	50		 push	 eax
  00cbf	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00cc5	51		 push	 ecx
  00cc6	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00ccb	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 676  : 	iCount++;

  00cd0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00cd5	83 c0 01	 add	 eax, 1
  00cd8	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 677  : 
; 678  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00cdd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00ce2	50		 push	 eax
  00ce3	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00ce8	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00cee	51		 push	 ecx
  00cef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00cf5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 679  : 	LogAdd("%s", pMsg.testbuf);

  00cf8	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00cfe	50		 push	 eax
  00cff	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00d04	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00d0a	83 c4 08	 add	 esp, 8

; 680  : 	cDBSMng.Send((char *)&pMsg, size);

  00d0d	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00d13	50		 push	 eax
  00d14	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00d1a	51		 push	 ecx
  00d1b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00d20	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 681  : 	iCount++;

  00d25	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00d2a	83 c0 01	 add	 eax, 1
  00d2d	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 682  : 
; 683  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00d32	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00d37	50		 push	 eax
  00d38	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00d3d	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00d43	51		 push	 ecx
  00d44	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00d4a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 684  : 	LogAdd("%s", pMsg.testbuf);

  00d4d	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00d53	50		 push	 eax
  00d54	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00d59	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00d5f	83 c4 08	 add	 esp, 8

; 685  : 	cDBSMng.Send((char *)&pMsg, size);

  00d62	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00d68	50		 push	 eax
  00d69	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00d6f	51		 push	 ecx
  00d70	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00d75	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 686  : 	iCount++;

  00d7a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00d7f	83 c0 01	 add	 eax, 1
  00d82	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 687  : 
; 688  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00d87	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00d8c	50		 push	 eax
  00d8d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00d92	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00d98	51		 push	 ecx
  00d99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00d9f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 689  : 	LogAdd("%s", pMsg.testbuf);

  00da2	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00da8	50		 push	 eax
  00da9	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00dae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00db4	83 c4 08	 add	 esp, 8

; 690  : 	cDBSMng.Send((char *)&pMsg, size);

  00db7	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00dbd	50		 push	 eax
  00dbe	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00dc4	51		 push	 ecx
  00dc5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00dca	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 691  : 	iCount++;

  00dcf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00dd4	83 c0 01	 add	 eax, 1
  00dd7	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 692  : 
; 693  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00ddc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00de1	50		 push	 eax
  00de2	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00de7	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00ded	51		 push	 ecx
  00dee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00df4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 694  : 	LogAdd("%s", pMsg.testbuf);

  00df7	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00dfd	50		 push	 eax
  00dfe	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00e03	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00e09	83 c4 08	 add	 esp, 8

; 695  : 	cDBSMng.Send((char *)&pMsg, size);

  00e0c	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00e12	50		 push	 eax
  00e13	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00e19	51		 push	 ecx
  00e1a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00e1f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 696  : 	iCount++;

  00e24	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00e29	83 c0 01	 add	 eax, 1
  00e2c	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 697  : 
; 698  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00e31	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00e36	50		 push	 eax
  00e37	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00e3c	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00e42	51		 push	 ecx
  00e43	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00e49	83 c4 0c	 add	 esp, 12			; 0000000cH

; 699  : 	LogAdd("%s", pMsg.testbuf);

  00e4c	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00e52	50		 push	 eax
  00e53	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00e58	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00e5e	83 c4 08	 add	 esp, 8

; 700  : 	cDBSMng.Send((char *)&pMsg, size);

  00e61	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00e67	50		 push	 eax
  00e68	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00e6e	51		 push	 ecx
  00e6f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00e74	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 701  : 	iCount++;

  00e79	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00e7e	83 c0 01	 add	 eax, 1
  00e81	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 702  : 
; 703  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00e86	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00e8b	50		 push	 eax
  00e8c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00e91	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00e97	51		 push	 ecx
  00e98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00e9e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 704  : 	LogAdd("%s", pMsg.testbuf);

  00ea1	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00ea7	50		 push	 eax
  00ea8	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00ead	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00eb3	83 c4 08	 add	 esp, 8

; 705  : 	cDBSMng.Send((char *)&pMsg, size);

  00eb6	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00ebc	50		 push	 eax
  00ebd	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00ec3	51		 push	 ecx
  00ec4	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00ec9	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 706  : 	iCount++;

  00ece	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00ed3	83 c0 01	 add	 eax, 1
  00ed6	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 707  : 
; 708  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00edb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00ee0	50		 push	 eax
  00ee1	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00ee6	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00eec	51		 push	 ecx
  00eed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00ef3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 709  : 	LogAdd("%s", pMsg.testbuf);

  00ef6	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00efc	50		 push	 eax
  00efd	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00f02	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00f08	83 c4 08	 add	 esp, 8

; 710  : 	cDBSMng.Send((char *)&pMsg, size);

  00f0b	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00f11	50		 push	 eax
  00f12	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00f18	51		 push	 ecx
  00f19	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00f1e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 711  : 	iCount++;

  00f23	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00f28	83 c0 01	 add	 eax, 1
  00f2b	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 712  : 
; 713  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00f30	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00f35	50		 push	 eax
  00f36	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00f3b	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00f41	51		 push	 ecx
  00f42	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00f48	83 c4 0c	 add	 esp, 12			; 0000000cH

; 714  : 	LogAdd("%s", pMsg.testbuf);

  00f4b	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00f51	50		 push	 eax
  00f52	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00f57	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00f5d	83 c4 08	 add	 esp, 8

; 715  : 	cDBSMng.Send((char *)&pMsg, size);

  00f60	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00f66	50		 push	 eax
  00f67	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00f6d	51		 push	 ecx
  00f6e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00f73	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 716  : 	iCount++;

  00f78	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00f7d	83 c0 01	 add	 eax, 1
  00f80	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 717  : 
; 718  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00f85	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00f8a	50		 push	 eax
  00f8b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00f90	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00f96	51		 push	 ecx
  00f97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00f9d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 719  : 	LogAdd("%s", pMsg.testbuf);

  00fa0	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00fa6	50		 push	 eax
  00fa7	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00fac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00fb2	83 c4 08	 add	 esp, 8

; 720  : 	cDBSMng.Send((char *)&pMsg, size);

  00fb5	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00fbb	50		 push	 eax
  00fbc	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00fc2	51		 push	 ecx
  00fc3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00fc8	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 721  : 	iCount++;

  00fcd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00fd2	83 c0 01	 add	 eax, 1
  00fd5	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 722  : 
; 723  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00fda	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00fdf	50		 push	 eax
  00fe0	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00fe5	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00feb	51		 push	 ecx
  00fec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00ff2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 724  : 	LogAdd("%s", pMsg.testbuf);

  00ff5	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00ffb	50		 push	 eax
  00ffc	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01001	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01007	83 c4 08	 add	 esp, 8

; 725  : 	cDBSMng.Send((char *)&pMsg, size);

  0100a	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  01010	50		 push	 eax
  01011	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01017	51		 push	 ecx
  01018	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0101d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 726  : 	iCount++;

  01022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01027	83 c0 01	 add	 eax, 1
  0102a	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 727  : 
; 728  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0102f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01034	50		 push	 eax
  01035	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0103a	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  01040	51		 push	 ecx
  01041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 729  : 	LogAdd("%s", pMsg.testbuf);

  0104a	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  01050	50		 push	 eax
  01051	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01056	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0105c	83 c4 08	 add	 esp, 8

; 730  : 	cDBSMng.Send((char *)&pMsg, size);

  0105f	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  01065	50		 push	 eax
  01066	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0106c	51		 push	 ecx
  0106d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  01072	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 731  : 	iCount++;

  01077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0107c	83 c0 01	 add	 eax, 1
  0107f	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 732  : 
; 733  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  01084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01089	50		 push	 eax
  0108a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0108f	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  01095	51		 push	 ecx
  01096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0109c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 734  : 	LogAdd("%s", pMsg.testbuf);

  0109f	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  010a5	50		 push	 eax
  010a6	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  010ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  010b1	83 c4 08	 add	 esp, 8

; 735  : 	cDBSMng.Send((char *)&pMsg, size);

  010b4	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  010ba	50		 push	 eax
  010bb	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  010c1	51		 push	 ecx
  010c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  010c7	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 736  : 	iCount++;

  010cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  010d1	83 c0 01	 add	 eax, 1
  010d4	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 737  : 
; 738  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  010d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  010de	50		 push	 eax
  010df	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  010e4	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  010ea	51		 push	 ecx
  010eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  010f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 739  : 	LogAdd("%s", pMsg.testbuf);

  010f4	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  010fa	50		 push	 eax
  010fb	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01100	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01106	83 c4 08	 add	 esp, 8

; 740  : 	cDBSMng.Send((char *)&pMsg, size);

  01109	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0110f	50		 push	 eax
  01110	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01116	51		 push	 ecx
  01117	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0111c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 741  : 	iCount++;

  01121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01126	83 c0 01	 add	 eax, 1
  01129	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 742  : 
; 743  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0112e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01133	50		 push	 eax
  01134	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  01139	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0113f	51		 push	 ecx
  01140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 744  : 	LogAdd("%s", pMsg.testbuf);

  01149	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0114f	50		 push	 eax
  01150	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01155	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0115b	83 c4 08	 add	 esp, 8

; 745  : 	cDBSMng.Send((char *)&pMsg, size);

  0115e	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  01164	50		 push	 eax
  01165	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0116b	51		 push	 ecx
  0116c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  01171	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 746  : 	iCount++;

  01176	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0117b	83 c0 01	 add	 eax, 1
  0117e	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 747  : 
; 748  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  01183	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01188	50		 push	 eax
  01189	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0118e	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  01194	51		 push	 ecx
  01195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0119b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 749  : 	LogAdd("%s", pMsg.testbuf);

  0119e	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  011a4	50		 push	 eax
  011a5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  011aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  011b0	83 c4 08	 add	 esp, 8

; 750  : 	cDBSMng.Send((char *)&pMsg, size);

  011b3	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  011b9	50		 push	 eax
  011ba	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  011c0	51		 push	 ecx
  011c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  011c6	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 751  : 	iCount++;

  011cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  011d0	83 c0 01	 add	 eax, 1
  011d3	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 752  : 
; 753  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  011d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  011dd	50		 push	 eax
  011de	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  011e3	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  011e9	51		 push	 ecx
  011ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  011f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 754  : 	LogAdd("%s", pMsg.testbuf);

  011f3	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  011f9	50		 push	 eax
  011fa	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  011ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01205	83 c4 08	 add	 esp, 8

; 755  : 	cDBSMng.Send((char *)&pMsg, size);

  01208	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0120e	50		 push	 eax
  0120f	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01215	51		 push	 ecx
  01216	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0121b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 756  : 	iCount++;

  01220	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01225	83 c0 01	 add	 eax, 1
  01228	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 757  : 
; 758  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0122d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01232	50		 push	 eax
  01233	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  01238	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0123e	51		 push	 ecx
  0123f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01245	83 c4 0c	 add	 esp, 12			; 0000000cH

; 759  : 	LogAdd("%s", pMsg.testbuf);

  01248	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0124e	50		 push	 eax
  0124f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01254	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0125a	83 c4 08	 add	 esp, 8

; 760  : 	cDBSMng.Send((char *)&pMsg, size);

  0125d	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  01263	50		 push	 eax
  01264	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0126a	51		 push	 ecx
  0126b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  01270	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 761  : 	iCount++;

  01275	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0127a	83 c0 01	 add	 eax, 1
  0127d	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 762  : 
; 763  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  01282	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01287	50		 push	 eax
  01288	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0128d	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  01293	51		 push	 ecx
  01294	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0129a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 764  : 	LogAdd("%s", pMsg.testbuf);

  0129d	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  012a3	50		 push	 eax
  012a4	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  012a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  012af	83 c4 08	 add	 esp, 8

; 765  : 	cDBSMng.Send((char *)&pMsg, size);

  012b2	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  012b8	50		 push	 eax
  012b9	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  012bf	51		 push	 ecx
  012c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  012c5	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 766  : 	iCount++;

  012ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  012cf	83 c0 01	 add	 eax, 1
  012d2	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 767  : 
; 768  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  012d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  012dc	50		 push	 eax
  012dd	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  012e2	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  012e8	51		 push	 ecx
  012e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  012ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 769  : 	LogAdd("%s", pMsg.testbuf);

  012f2	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  012f8	50		 push	 eax
  012f9	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  012fe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01304	83 c4 08	 add	 esp, 8

; 770  : 	cDBSMng.Send((char *)&pMsg, size);

  01307	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0130d	50		 push	 eax
  0130e	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01314	51		 push	 ecx
  01315	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0131a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 771  : 	iCount++;

  0131f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01324	83 c0 01	 add	 eax, 1
  01327	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 772  : 
; 773  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0132c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01331	50		 push	 eax
  01332	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  01337	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0133d	51		 push	 ecx
  0133e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01344	83 c4 0c	 add	 esp, 12			; 0000000cH

; 774  : 	LogAdd("%s", pMsg.testbuf);

  01347	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0134d	50		 push	 eax
  0134e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01353	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01359	83 c4 08	 add	 esp, 8

; 775  : 	cDBSMng.Send((char *)&pMsg, size);

  0135c	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  01362	50		 push	 eax
  01363	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01369	51		 push	 ecx
  0136a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0136f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 776  : 	iCount++;

  01374	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  01379	83 c0 01	 add	 eax, 1
  0137c	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 777  : 
; 778  : 	LogAdd("Test Data Send");

  01381	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@
  01386	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0138c	83 c4 04	 add	 esp, 4

; 779  : }

  0138f	5f		 pop	 edi
  01390	5e		 pop	 esi
  01391	5b		 pop	 ebx
  01392	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01395	33 cd		 xor	 ecx, ebp
  01397	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0139c	8b e5		 mov	 esp, ebp
  0139e	5d		 pop	 ebp
  0139f	c3		 ret	 0
?TestDSSend@@YAXXZ ENDP					; TestDSSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DataServerLogin@@YAXH@Z			; DataServerLogin
EXTRN	?GDLicenseUser@CExLicense@@QAEXXZ:PROC		; CExLicense::GDLicenseUser
EXTRN	?Send@DBSockMng@@QAEHHPADH@Z:PROC		; DBSockMng::Send
EXTRN	_strcpy:PROC
EXTRN	?szServerName@@3PADA:BYTE			; szServerName
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?GameServerPort@@3HA:DWORD			; GameServerPort
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pInfo$ = -64						; size = 58
__$ArrayPad$ = -4					; size = 4
_server$ = 8						; size = 4
?DataServerLogin@@YAXH@Z PROC				; DataServerLogin

; 783  : {

  013a0	55		 push	 ebp
  013a1	8b ec		 mov	 ebp, esp
  013a3	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  013a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  013ae	33 c5		 xor	 eax, ebp
  013b0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  013b3	53		 push	 ebx
  013b4	56		 push	 esi
  013b5	57		 push	 edi

; 784  : 	SDHP_SERVERINFO pInfo;
; 785  : 	pInfo.h.c =0xC1;

  013b6	c6 45 c0 c1	 mov	 BYTE PTR _pInfo$[ebp], 193 ; 000000c1H

; 786  : 	pInfo.h.size = sizeof(SDHP_SERVERINFO);

  013ba	c6 45 c1 3a	 mov	 BYTE PTR _pInfo$[ebp+1], 58 ; 0000003aH

; 787  : 	pInfo.h.headcode =0x00;

  013be	c6 45 c2 00	 mov	 BYTE PTR _pInfo$[ebp+2], 0

; 788  : 	pInfo.Port =(WORD)GameServerPort;

  013c2	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?GameServerPort@@3HA
  013c8	66 89 45 c4	 mov	 WORD PTR _pInfo$[ebp+4], ax

; 789  : 	pInfo.Type =1;

  013cc	c6 45 c3 01	 mov	 BYTE PTR _pInfo$[ebp+3], 1

; 790  : 	pInfo.ServerCode =gGameServerCode;

  013d0	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  013d6	66 89 45 f8	 mov	 WORD PTR _pInfo$[ebp+56], ax

; 791  : 	strcpy( (char*)&pInfo.ServerName[0], (const char*)&szServerName[0] );

  013da	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  013df	8d 45 c6	 lea	 eax, DWORD PTR _pInfo$[ebp+6]
  013e2	50		 push	 eax
  013e3	e8 00 00 00 00	 call	 _strcpy
  013e8	83 c4 08	 add	 esp, 8

; 792  : 	cDBSMng.Send(server, (char*)&pInfo , pInfo.h.size  );	

  013eb	0f b6 45 c1	 movzx	 eax, BYTE PTR _pInfo$[ebp+1]
  013ef	50		 push	 eax
  013f0	8d 4d c0	 lea	 ecx, DWORD PTR _pInfo$[ebp]
  013f3	51		 push	 ecx
  013f4	8b 55 08	 mov	 edx, DWORD PTR _server$[ebp]
  013f7	52		 push	 edx
  013f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  013fd	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHHPADH@Z ; DBSockMng::Send

; 793  : 
; 794  : 	g_ExLicense.GDLicenseUser();

  01402	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01407	e8 00 00 00 00	 call	 ?GDLicenseUser@CExLicense@@QAEXXZ ; CExLicense::GDLicenseUser

; 795  : }

  0140c	5f		 pop	 edi
  0140d	5e		 pop	 esi
  0140e	5b		 pop	 ebx
  0140f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01412	33 cd		 xor	 ecx, ebp
  01414	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01419	8b e5		 mov	 esp, ebp
  0141b	5d		 pop	 ebp
  0141c	c3		 ret	 0
?DataServerLogin@@YAXH@Z ENDP				; DataServerLogin
_TEXT	ENDS
EXTRN	?DSReqSelect@CBanSystem@@QAEXXZ:PROC		; CBanSystem::DSReqSelect
EXTRN	?GDReqRegSiegeList@CDungeonSiege@@QAEXXZ:PROC	; CDungeonSiege::GDReqRegSiegeList
EXTRN	?GDSiegeOwner@CDungeonSiege@@QAEXXZ:PROC	; CDungeonSiege::GDSiegeOwner
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?gServerReady@@3HA:DWORD			; gServerReady
EXTRN	?DataServerConnected@@3HA:DWORD			; DataServerConnected
EXTRN	?DB_Start@CExGDManager@@QAEXXZ:PROC		; CExGDManager::DB_Start
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z PROC	; DataServerLoginResult

; 799  : {

  01420	55		 push	 ebp
  01421	8b ec		 mov	 ebp, esp
  01423	83 ec 40	 sub	 esp, 64			; 00000040H
  01426	53		 push	 ebx
  01427	56		 push	 esi
  01428	57		 push	 edi

; 800  : 	if (lpMsg->Result == false )

  01429	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0142c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  01430	85 c9		 test	 ecx, ecx
  01432	75 22		 jne	 SHORT $LN1@DataServer@2

; 801  : 	{
; 802  : #if(SWENG_FIX==TRUE)
; 803  : 		LogAddC(2, "%s", lMsg.Get(MSGGET(1, 210)));	//FIX_CRASH

  01434	68 d2 01 00 00	 push	 466			; 000001d2H
  01439	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0143e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01443	50		 push	 eax
  01444	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  01449	6a 02		 push	 2
  0144b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01451	83 c4 0c	 add	 esp, 12			; 0000000cH

; 804  : #else
; 805  : 		MsgBox(lMsg.Get(MSGGET(1, 210)));	
; 806  : #endif
; 807  : 		return;

  01454	eb 60		 jmp	 SHORT $LN2@DataServer@2
$LN1@DataServer@2:

; 808  : 	}
; 809  : 	
; 810  : #if(CUSTOM_SAVE_PT==TRUE)
; 811  : 	gParty.DBIndex = lpMsg->PartyCount;

  01456	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01459	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0145c	89 0d 28 b9 18
	00		 mov	 DWORD PTR ?gParty@@3VPartyClass@@A+1620264, ecx

; 812  : #endif
; 813  : 
; 814  : 	g_ExGDManager.DB_Start();

  01462	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExGDManager@@3VCExGDManager@@A ; g_ExGDManager
  01467	e8 00 00 00 00	 call	 ?DB_Start@CExGDManager@@QAEXXZ ; CExGDManager::DB_Start

; 815  : 
; 816  : 	DataServerConnected = TRUE;

  0146c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DataServerConnected@@3HA, 1 ; DataServerConnected

; 817  : 	gServerReady++;

  01476	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gServerReady@@3HA ; gServerReady
  0147b	83 c0 01	 add	 eax, 1
  0147e	a3 00 00 00 00	 mov	 DWORD PTR ?gServerReady@@3HA, eax ; gServerReady

; 818  : 	SendMessage(ghWnd, WM_START_SERVER, 0, 0); 

  01483	6a 00		 push	 0
  01485	6a 00		 push	 0
  01487	68 05 04 00 00	 push	 1029			; 00000405H
  0148c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  01491	50		 push	 eax
  01492	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 819  : 
; 820  : #if(EVENT_DUNGEON_SIEGE)
; 821  : 	g_DungeonSiege.GDSiegeOwner();

  01498	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  0149d	e8 00 00 00 00	 call	 ?GDSiegeOwner@CDungeonSiege@@QAEXXZ ; CDungeonSiege::GDSiegeOwner

; 822  : 	g_DungeonSiege.GDReqRegSiegeList();

  014a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  014a7	e8 00 00 00 00	 call	 ?GDReqRegSiegeList@CDungeonSiege@@QAEXXZ ; CDungeonSiege::GDReqRegSiegeList

; 823  : #endif
; 824  : 
; 825  : 	#if(DEV_BANSYSTEM)
; 826  : 	g_BanSystem.DSReqSelect();

  014ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BanSystem@@3VCBanSystem@@A ; g_BanSystem
  014b1	e8 00 00 00 00	 call	 ?DSReqSelect@CBanSystem@@QAEXXZ ; CBanSystem::DSReqSelect
$LN2@DataServer@2:

; 827  : 	#endif
; 828  : }

  014b6	5f		 pop	 edi
  014b7	5e		 pop	 esi
  014b8	5b		 pop	 ebx
  014b9	8b e5		 mov	 esp, ebp
  014bb	5d		 pop	 ebp
  014bc	c3		 ret	 0
?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ENDP	; DataServerLoginResult
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
PUBLIC	??_C@_0DI@OHFHMHBN@Requested?5character?5list?5doesn?8t@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?ExConfig@@3VcExConfigs@@A:BYTE			; ExConfig
EXTRN	?LevelSmallConvert@@YAEH@Z:PROC			; LevelSmallConvert
EXTRN	?IsPet@CPetEx@@QAE_NH@Z:PROC			; CPetEx::IsPet
EXTRN	?g_PetEx@@3VCPetEx@@A:BYTE			; g_PetEx
EXTRN	?Player@CBanSystem@@QAE_NH@Z:PROC		; CBanSystem::Player
EXTRN	_memset:PROC
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0DI@OHFHMHBN@Requested?5character?5list?5doesn?8t@
CONST	SEGMENT
??_C@_0DI@OHFHMHBN@Requested?5character?5list?5doesn?8t@ DB 'Requested ch'
	DB	'aracter list doesn''t match the user. (%s)%s', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv1037 = -464						; size = 4
tv1016 = -464						; size = 4
tv988 = -464						; size = 4
tv960 = -464						; size = 4
tv932 = -464						; size = 4
tv679 = -464						; size = 4
_pMsg$ = -396						; size = 5
_levelindex$245428 = -388				; size = 4
_changeup$245329 = -384					; size = 4
_n$245321 = -380					; size = 4
_GenerableClass$ = -373					; size = 1
_HightLevel$ = -372					; size = 4
_btExcellentOption$ = -365				; size = 1
_TempInventory$ = -364					; size = 24
_pCList$ = -340						; size = 34
_pCLCount$ = -304					; size = 8
_index$ = -293						; size = 1
_aIndex$ = -292						; size = 4
_lsOfs$ = -288						; size = 4
_lOfs$ = -284						; size = 4
_sendbuf$ = -280					; size = 256
_szId$ = -24						; size = 11
_lpCL$ = -12						; size = 4
_lpCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?JGPGetCharList@@YAXPAE@Z PROC				; JGPGetCharList

; 852  : {

  014c0	55		 push	 ebp
  014c1	8b ec		 mov	 ebp, esp
  014c3	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  014c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  014ce	33 c5		 xor	 eax, ebp
  014d0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  014d3	53		 push	 ebx
  014d4	56		 push	 esi
  014d5	57		 push	 edi

; 853  : 	SDHP_CHARLISTCOUNT * lpCount = (SDHP_CHARLISTCOUNT *)lpRecv;

  014d6	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  014d9	89 45 f8	 mov	 DWORD PTR _lpCount$[ebp], eax

; 854  : 	SDHP_CHARLIST * lpCL;
; 855  : 	char szId[MAX_ACCOUNT_LEN+1];
; 856  : 	BYTE sendbuf[256];
; 857  : 	int lOfs = 0;

  014dc	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 858  : 	int lsOfs = sizeof(SDHP_CHARLISTCOUNT);

  014e6	c7 85 e0 fe ff
	ff 1c 00 00 00	 mov	 DWORD PTR _lsOfs$[ebp], 28 ; 0000001cH

; 859  : 	int aIndex = lpCount->Number;

  014f0	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  014f3	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  014f7	89 8d dc fe ff
	ff		 mov	 DWORD PTR _aIndex$[ebp], ecx

; 860  : 	BYTE index;
; 861  : 	PMSG_CHARLISTCOUNT pCLCount;	// Packet Char List Count 7
; 862  : 	PMSG_CHARLIST pCList;
; 863  : 	WORD TempInventory[12];
; 864  : 	BYTE btExcellentOption;
; 865  : 
; 866  : 	pCLCount.h.c		= 0xC1;

  014fd	c6 85 d0 fe ff
	ff c1		 mov	 BYTE PTR _pCLCount$[ebp], 193 ; 000000c1H

; 867  : 	pCLCount.h.headcode = 0xF3;

  01504	c6 85 d2 fe ff
	ff f3		 mov	 BYTE PTR _pCLCount$[ebp+2], 243 ; 000000f3H

; 868  : 	pCLCount.subcode	= 0x00;

  0150b	c6 85 d3 fe ff
	ff 00		 mov	 BYTE PTR _pCLCount$[ebp+3], 0

; 869  : 	pCLCount.Count		= lpCount->Count;

  01512	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  01515	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  01518	88 8d d6 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+6], cl

; 870  : 
; 871  : #if(DEBUG_CODE)
; 872  : 	LogAddC(2,"pCLCount.Count: %d",pCLCount.Count);
; 873  : #endif
; 874  : 
; 875  : 	szId[MAX_ACCOUNT_LEN] = 0;

  0151e	c6 45 f2 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 876  : 	memcpy(szId, lpCount->AccountId, MAX_ACCOUNT_LEN);

  01522	6a 0a		 push	 10			; 0000000aH
  01524	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  01527	83 c0 0d	 add	 eax, 13			; 0000000dH
  0152a	50		 push	 eax
  0152b	8d 4d e8	 lea	 ecx, DWORD PTR _szId$[ebp]
  0152e	51		 push	 ecx
  0152f	e8 00 00 00 00	 call	 _memcpy
  01534	83 c4 0c	 add	 esp, 12			; 0000000cH

; 877  : 
; 878  : 	if(gObjIsAccontConnect(aIndex, szId) == FALSE)

  01537	8d 45 e8	 lea	 eax, DWORD PTR _szId$[ebp]
  0153a	50		 push	 eax
  0153b	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01541	51		 push	 ecx
  01542	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  01547	83 c4 08	 add	 esp, 8
  0154a	85 c0		 test	 eax, eax
  0154c	75 3f		 jne	 SHORT $LN85@JGPGetChar

; 879  : 	{
; 880  : 		LogAddC(2, "Requested character list doesn't match the user. (%s)%s", gObj[aIndex].AccountID, szId);

  0154e	8d 45 e8	 lea	 eax, DWORD PTR _szId$[ebp]
  01551	50		 push	 eax
  01552	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01558	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0155e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01564	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  01568	50		 push	 eax
  01569	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OHFHMHBN@Requested?5character?5list?5doesn?8t@
  0156e	6a 02		 push	 2
  01570	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01576	83 c4 10	 add	 esp, 16			; 00000010H

; 881  : 		CloseClient(aIndex);

  01579	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  0157f	50		 push	 eax
  01580	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  01585	83 c4 04	 add	 esp, 4

; 882  : 		return;

  01588	e9 0f 14 00 00	 jmp	 $LN86@JGPGetChar
$LN85@JGPGetChar:

; 883  : 	}
; 884  : 
; 885  : 	gObj[aIndex].Magumsa		= lpCount->Magumsa;

  0158d	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  01593	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01599	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0159f	8b 55 f8	 mov	 edx, DWORD PTR _lpCount$[ebp]
  015a2	8a 52 0c	 mov	 dl, BYTE PTR [edx+12]
  015a5	88 54 01 34	 mov	 BYTE PTR [ecx+eax+52], dl

; 886  : 	pCLCount.MaxClass			= lpCount->Magumsa + 2;

  015a9	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  015ac	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  015b0	83 c1 02	 add	 ecx, 2
  015b3	88 8d d4 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+4], cl

; 887  : 	pCLCount.MaxClass			+= 1;

  015b9	0f b6 85 d4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCLCount$[ebp+4]
  015c0	83 c0 01	 add	 eax, 1
  015c3	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+4], al

; 888  : 	pCLCount.MoveCnt			= lpCount->MoveCnt;

  015c9	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  015cc	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  015cf	88 8d d5 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+5], cl

; 889  : 	// ----
; 890  : #ifdef EXPINV
; 891  : #ifdef DEBUG_CODE
; 892  : 	LogAddC(2, "lpCount->ExpandedWarehouse: %d", lpCount->ExpandedWarehouse);
; 893  : 	
; 894  : #endif
; 895  : 	pCLCount.ExpandedWarehouse		= lpCount->ExpandedWarehouse;

  015d5	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  015d8	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  015dc	0f 95 c1	 setne	 cl
  015df	88 8d d7 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+7], cl

; 896  : 	gObj[aIndex].ExpandedWarehouse	= lpCount->ExpandedWarehouse;

  015e5	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  015eb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  015f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015f7	8b 55 f8	 mov	 edx, DWORD PTR _lpCount$[ebp]
  015fa	8a 52 19	 mov	 dl, BYTE PTR [edx+25]
  015fd	88 94 01 25 26
	00 00		 mov	 BYTE PTR [ecx+eax+9765], dl

; 897  : #endif
; 898  : 
; 899  : 	memset(sendbuf, 0, sizeof(sendbuf));

  01604	68 00 01 00 00	 push	 256			; 00000100H
  01609	6a 00		 push	 0
  0160b	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  01611	50		 push	 eax
  01612	e8 00 00 00 00	 call	 _memset
  01617	83 c4 0c	 add	 esp, 12			; 0000000cH

; 900  : 	lOfs += sizeof(PMSG_CHARLISTCOUNT);

  0161a	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  01620	83 c0 08	 add	 eax, 8
  01623	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 901  : 
; 902  : #ifdef CHARCREATE_TEMP
; 903  : 	int HightLevel		= 0;

  01629	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _HightLevel$[ebp], 0

; 904  : 	BYTE GenerableClass = 0;

  01633	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _GenerableClass$[ebp], 0

; 905  : #endif
; 906  : 
; 907  : 	if( pCLCount.Count > 0 )

  0163a	0f b6 85 d6 fe
	ff ff		 movzx	 eax, BYTE PTR _pCLCount$[ebp+6]
  01641	85 c0		 test	 eax, eax
  01643	0f 8e 24 12 00
	00		 jle	 $LN84@JGPGetChar

; 908  : 	{
; 909  : 		for ( int n=0;n<pCLCount.Count ;n++)

  01649	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$245321[ebp], 0
  01653	eb 0f		 jmp	 SHORT $LN83@JGPGetChar
$LN82@JGPGetChar:
  01655	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _n$245321[ebp]
  0165b	83 c0 01	 add	 eax, 1
  0165e	89 85 84 fe ff
	ff		 mov	 DWORD PTR _n$245321[ebp], eax
$LN83@JGPGetChar:
  01664	0f b6 85 d6 fe
	ff ff		 movzx	 eax, BYTE PTR _pCLCount$[ebp+6]
  0166b	39 85 84 fe ff
	ff		 cmp	 DWORD PTR _n$245321[ebp], eax
  01671	0f 8d f6 11 00
	00		 jge	 $LN84@JGPGetChar

; 910  : 		{
; 911  : 			memset(&pCList, 0, sizeof(pCList));

  01677	6a 22		 push	 34			; 00000022H
  01679	6a 00		 push	 0
  0167b	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _pCList$[ebp]
  01681	50		 push	 eax
  01682	e8 00 00 00 00	 call	 _memset
  01687	83 c4 0c	 add	 esp, 12			; 0000000cH

; 912  : 			lpCL = (SDHP_CHARLIST *)&lpRecv[lsOfs];

  0168a	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0168d	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _lsOfs$[ebp]
  01693	89 45 f4	 mov	 DWORD PTR _lpCL$[ebp], eax

; 913  : #ifdef CHARCREATE_TEMP
; 914  : 			if( lpCL->Level > HightLevel )

  01696	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01699	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0169d	3b 8d 8c fe ff
	ff		 cmp	 ecx, DWORD PTR _HightLevel$[ebp]
  016a3	7e 0d		 jle	 SHORT $LN80@JGPGetChar

; 915  : 			{
; 916  : 				HightLevel = lpCL->Level;

  016a5	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  016a8	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  016ac	89 8d 8c fe ff
	ff		 mov	 DWORD PTR _HightLevel$[ebp], ecx
$LN80@JGPGetChar:

; 917  : 			}
; 918  : #endif
; 919  : 			pCList.Index = lpCL->Index;

  016b2	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  016b5	8a 08		 mov	 cl, BYTE PTR [eax]
  016b7	88 8d ac fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp], cl

; 920  : 			pCList.Level = lpCL->Level;

  016bd	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  016c0	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  016c4	66 89 8d b8 fe
	ff ff		 mov	 WORD PTR _pCList$[ebp+12], cx

; 921  : 			pCList.CtlCode = lpCL->CtlCode;

  016cb	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  016ce	8a 48 0f	 mov	 cl, BYTE PTR [eax+15]
  016d1	88 8d ba fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+14], cl

; 922  : 			pCList.btGuildStatus = lpCL->btGuildStatus;

  016d7	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  016da	8a 48 41	 mov	 cl, BYTE PTR [eax+65]
  016dd	88 8d cd fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+33], cl

; 923  : 
; 924  : 			if ( gObj[aIndex].m_cAccountItemBlock != 0 )

  016e3	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  016e9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  016ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016f5	0f b6 94 01 14
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax+532]
  016fd	85 d2		 test	 edx, edx
  016ff	74 10		 je	 SHORT $LN79@JGPGetChar

; 925  : 				pCList.CtlCode |= 0x10;	// Set Block Item

  01701	0f b6 85 ba fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+14]
  01708	83 c8 10	 or	 eax, 16			; 00000010H
  0170b	88 85 ba fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+14], al
$LN79@JGPGetChar:

; 926  : 
; 927  : 			#if(DEV_BANSYSTEM)
; 928  : 			if(!g_BanSystem.Player(aIndex))

  01711	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  01717	50		 push	 eax
  01718	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BanSystem@@3VCBanSystem@@A ; g_BanSystem
  0171d	e8 00 00 00 00	 call	 ?Player@CBanSystem@@QAE_NH@Z ; CBanSystem::Player
  01722	0f b6 c8	 movzx	 ecx, al
  01725	85 c9		 test	 ecx, ecx
  01727	75 07		 jne	 SHORT $LN78@JGPGetChar

; 929  : 			{
; 930  : 				pCList.CtlCode = 0x01;

  01729	c6 85 ba fe ff
	ff 01		 mov	 BYTE PTR _pCList$[ebp+14], 1
$LN78@JGPGetChar:

; 931  : 			}
; 932  : 			#endif
; 933  : 
; 934  : 			memcpy(pCList.Name, lpCL->Name, MAX_ACCOUNT_LEN);

  01730	6a 0a		 push	 10			; 0000000aH
  01732	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01735	83 c0 01	 add	 eax, 1
  01738	50		 push	 eax
  01739	8d 8d ad fe ff
	ff		 lea	 ecx, DWORD PTR _pCList$[ebp+1]
  0173f	51		 push	 ecx
  01740	e8 00 00 00 00	 call	 _memcpy
  01745	83 c4 0c	 add	 esp, 12			; 0000000cH

; 935  : 
; 936  : 			pCList.CharSet[CS_CLASS] = CS_GET_CLASS(lpCL->Class);

  01748	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0174b	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0174f	c1 f9 04	 sar	 ecx, 4
  01752	c1 e1 05	 shl	 ecx, 5
  01755	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  0175b	88 8d bb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+15], cl

; 937  : 			int changeup = CS_GET_CHANGEUP(lpCL->Class);

  01761	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01764	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  01768	83 e1 07	 and	 ecx, 7
  0176b	89 8d 80 fe ff
	ff		 mov	 DWORD PTR _changeup$245329[ebp], ecx

; 938  : 			pCList.CharSet[CS_CLASS] |= CS_SET_CHANGEUP(changeup);

  01771	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _changeup$245329[ebp]
  01777	c1 e0 04	 shl	 eax, 4
  0177a	83 e0 10	 and	 eax, 16			; 00000010H
  0177d	0f b6 8d bb fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+15]
  01784	0b c8		 or	 ecx, eax
  01786	88 8d bb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+15], cl

; 939  : 			pCList.CharSet[CS_CLASS] |= CS_GET_MASTERCLASS(changeup);

  0178c	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _changeup$245329[ebp]
  01792	d1 f8		 sar	 eax, 1
  01794	c1 e0 03	 shl	 eax, 3
  01797	83 e0 08	 and	 eax, 8
  0179a	0f b6 8d bb fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+15]
  017a1	0b c8		 or	 ecx, eax
  017a3	88 8d bb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+15], cl

; 940  : 
; 941  : 			pCList.CharSet[9] = 0;

  017a9	c6 85 c4 fe ff
	ff 00		 mov	 BYTE PTR _pCList$[ebp+24], 0

; 942  : 
; 943  : 			if ( lpCL->dbInventory[0] == (BYTE)-1 && (lpCL->dbInventory[2] & 0x80) == 0x80 && (lpCL->dbInventory[3]& 0xF0) == 0xF0  )

  017b0	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  017b3	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  017b7	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  017bd	75 32		 jne	 SHORT $LN77@JGPGetChar
  017bf	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  017c2	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  017c6	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  017cc	74 23		 je	 SHORT $LN77@JGPGetChar
  017ce	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  017d1	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  017d5	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  017db	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  017e1	75 0e		 jne	 SHORT $LN77@JGPGetChar

; 944  : 			{
; 945  : 				TempInventory[0] = -1;

  017e3	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  017e8	66 89 85 94 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp], ax

; 946  : 			}
; 947  : 			else

  017ef	eb 2e		 jmp	 SHORT $LN76@JGPGetChar
$LN77@JGPGetChar:

; 948  : 			{
; 949  : 				TempInventory[0] = (lpCL->dbInventory[0] + (lpCL->dbInventory[2]&0x80)*2)+ (lpCL->dbInventory[3]&0xF0)*32;

  017f1	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  017f4	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  017f8	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  017fb	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  017ff	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01804	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01807	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0180a	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  0180e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01813	c1 e0 05	 shl	 eax, 5
  01816	03 c8		 add	 ecx, eax
  01818	66 89 8d 94 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp], cx
$LN76@JGPGetChar:

; 950  : 			}
; 951  : 			if ( lpCL->dbInventory[4] == (BYTE)-1 && (lpCL->dbInventory[6]& 0x80) == 0x80 && (lpCL->dbInventory[7]& 0xF0) == 0xF0  )

  0181f	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01822	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  01826	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0182c	75 32		 jne	 SHORT $LN75@JGPGetChar
  0182e	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01831	0f b6 48 16	 movzx	 ecx, BYTE PTR [eax+22]
  01835	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0183b	74 23		 je	 SHORT $LN75@JGPGetChar
  0183d	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01840	0f b6 48 17	 movzx	 ecx, BYTE PTR [eax+23]
  01844	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0184a	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  01850	75 0e		 jne	 SHORT $LN75@JGPGetChar

; 952  : 			{
; 953  : 				TempInventory[1] = -1;

  01852	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  01857	66 89 85 96 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+2], ax

; 954  : 			}
; 955  : 			else

  0185e	eb 2e		 jmp	 SHORT $LN74@JGPGetChar
$LN75@JGPGetChar:

; 956  : 			{
; 957  : 				TempInventory[1] = (lpCL->dbInventory[4] + (lpCL->dbInventory[6]&0x80)*2)+ (lpCL->dbInventory[7]&0xF0)*32;

  01860	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01863	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  01867	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0186a	0f b6 42 16	 movzx	 eax, BYTE PTR [edx+22]
  0186e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01873	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01876	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01879	0f b6 42 17	 movzx	 eax, BYTE PTR [edx+23]
  0187d	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01882	c1 e0 05	 shl	 eax, 5
  01885	03 c8		 add	 ecx, eax
  01887	66 89 8d 96 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+2], cx
$LN74@JGPGetChar:

; 958  : 			}
; 959  : 			if ( lpCL->dbInventory[8] == (BYTE)-1 && (lpCL->dbInventory[10]& 0x80) == 0x80 && (lpCL->dbInventory[11]& 0xF0) == 0xF0  )

  0188e	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01891	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  01895	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0189b	75 32		 jne	 SHORT $LN73@JGPGetChar
  0189d	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  018a0	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  018a4	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  018aa	74 23		 je	 SHORT $LN73@JGPGetChar
  018ac	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  018af	0f b6 48 1b	 movzx	 ecx, BYTE PTR [eax+27]
  018b3	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  018b9	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  018bf	75 0e		 jne	 SHORT $LN73@JGPGetChar

; 960  : 			{
; 961  : 				TempInventory[2] = 0x1FF;

  018c1	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  018c6	66 89 85 98 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+4], ax

; 962  : 			}
; 963  : 			else

  018cd	eb 3e		 jmp	 SHORT $LN72@JGPGetChar
$LN73@JGPGetChar:

; 964  : 			{
; 965  : 				TempInventory[2] = ((lpCL->dbInventory[8] + (lpCL->dbInventory[10]&0x80)*2)+ (lpCL->dbInventory[11]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  018cf	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  018d2	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  018d6	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  018d9	0f b6 42 1a	 movzx	 eax, BYTE PTR [edx+26]
  018dd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  018e2	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  018e5	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  018e8	0f b6 42 1b	 movzx	 eax, BYTE PTR [edx+27]
  018ec	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  018f1	c1 e0 05	 shl	 eax, 5
  018f4	03 c8		 add	 ecx, eax
  018f6	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  018fc	79 08		 jns	 SHORT $LN101@JGPGetChar
  018fe	49		 dec	 ecx
  018ff	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01905	41		 inc	 ecx
$LN101@JGPGetChar:
  01906	66 89 8d 98 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+4], cx
$LN72@JGPGetChar:

; 966  : 			}
; 967  : 			if ( lpCL->dbInventory[12] == (BYTE)-1 && (lpCL->dbInventory[14]& 0x80) == 0x80 && (lpCL->dbInventory[15]& 0xF0) == 0xF0  )

  0190d	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01910	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  01914	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0191a	75 32		 jne	 SHORT $LN71@JGPGetChar
  0191c	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0191f	0f b6 48 1e	 movzx	 ecx, BYTE PTR [eax+30]
  01923	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01929	74 23		 je	 SHORT $LN71@JGPGetChar
  0192b	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0192e	0f b6 48 1f	 movzx	 ecx, BYTE PTR [eax+31]
  01932	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01938	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  0193e	75 0e		 jne	 SHORT $LN71@JGPGetChar

; 968  : 			{
; 969  : 				TempInventory[3] = 0x1FF;

  01940	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01945	66 89 85 9a fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+6], ax

; 970  : 			}
; 971  : 			else

  0194c	eb 3e		 jmp	 SHORT $LN70@JGPGetChar
$LN71@JGPGetChar:

; 972  : 			{
; 973  : 				TempInventory[3] = ((lpCL->dbInventory[12] + (lpCL->dbInventory[14]&0x80)*2)+ (lpCL->dbInventory[15]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  0194e	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01951	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  01955	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01958	0f b6 42 1e	 movzx	 eax, BYTE PTR [edx+30]
  0195c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01961	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01964	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01967	0f b6 42 1f	 movzx	 eax, BYTE PTR [edx+31]
  0196b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01970	c1 e0 05	 shl	 eax, 5
  01973	03 c8		 add	 ecx, eax
  01975	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  0197b	79 08		 jns	 SHORT $LN102@JGPGetChar
  0197d	49		 dec	 ecx
  0197e	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01984	41		 inc	 ecx
$LN102@JGPGetChar:
  01985	66 89 8d 9a fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+6], cx
$LN70@JGPGetChar:

; 974  : 			}
; 975  : 			if ( lpCL->dbInventory[16] == (BYTE)-1 && (lpCL->dbInventory[18]& 0x80) == 0x80 && (lpCL->dbInventory[19]& 0xF0) == 0xF0  )

  0198c	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0198f	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  01993	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01999	75 32		 jne	 SHORT $LN69@JGPGetChar
  0199b	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0199e	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  019a2	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  019a8	74 23		 je	 SHORT $LN69@JGPGetChar
  019aa	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  019ad	0f b6 48 23	 movzx	 ecx, BYTE PTR [eax+35]
  019b1	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  019b7	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  019bd	75 0e		 jne	 SHORT $LN69@JGPGetChar

; 976  : 			{
; 977  : 				TempInventory[4] = 0x1FF;

  019bf	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  019c4	66 89 85 9c fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+8], ax

; 978  : 			}
; 979  : 			else

  019cb	eb 3e		 jmp	 SHORT $LN68@JGPGetChar
$LN69@JGPGetChar:

; 980  : 			{
; 981  : 				TempInventory[4] = ((lpCL->dbInventory[16] + (lpCL->dbInventory[18]&0x80)*2)+ (lpCL->dbInventory[19]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  019cd	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  019d0	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  019d4	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  019d7	0f b6 42 22	 movzx	 eax, BYTE PTR [edx+34]
  019db	25 80 00 00 00	 and	 eax, 128		; 00000080H
  019e0	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  019e3	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  019e6	0f b6 42 23	 movzx	 eax, BYTE PTR [edx+35]
  019ea	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  019ef	c1 e0 05	 shl	 eax, 5
  019f2	03 c8		 add	 ecx, eax
  019f4	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  019fa	79 08		 jns	 SHORT $LN103@JGPGetChar
  019fc	49		 dec	 ecx
  019fd	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01a03	41		 inc	 ecx
$LN103@JGPGetChar:
  01a04	66 89 8d 9c fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+8], cx
$LN68@JGPGetChar:

; 982  : 			}
; 983  : 			if ( lpCL->dbInventory[20] == (BYTE)-1 && (lpCL->dbInventory[22]& 0x80) == 0x80 && (lpCL->dbInventory[23]& 0xF0) == 0xF0  )

  01a0b	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01a0e	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  01a12	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01a18	75 32		 jne	 SHORT $LN67@JGPGetChar
  01a1a	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01a1d	0f b6 48 26	 movzx	 ecx, BYTE PTR [eax+38]
  01a21	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01a27	74 23		 je	 SHORT $LN67@JGPGetChar
  01a29	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01a2c	0f b6 48 27	 movzx	 ecx, BYTE PTR [eax+39]
  01a30	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01a36	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  01a3c	75 0e		 jne	 SHORT $LN67@JGPGetChar

; 984  : 			{
; 985  : 				TempInventory[5] = 0x1FF;

  01a3e	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01a43	66 89 85 9e fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+10], ax

; 986  : 			}
; 987  : 			else

  01a4a	eb 3e		 jmp	 SHORT $LN66@JGPGetChar
$LN67@JGPGetChar:

; 988  : 			{
; 989  : 				TempInventory[5] = ((lpCL->dbInventory[20] + (lpCL->dbInventory[22]&0x80)*2)+ (lpCL->dbInventory[23]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  01a4c	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01a4f	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  01a53	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01a56	0f b6 42 26	 movzx	 eax, BYTE PTR [edx+38]
  01a5a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01a5f	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01a62	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01a65	0f b6 42 27	 movzx	 eax, BYTE PTR [edx+39]
  01a69	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01a6e	c1 e0 05	 shl	 eax, 5
  01a71	03 c8		 add	 ecx, eax
  01a73	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  01a79	79 08		 jns	 SHORT $LN104@JGPGetChar
  01a7b	49		 dec	 ecx
  01a7c	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01a82	41		 inc	 ecx
$LN104@JGPGetChar:
  01a83	66 89 8d 9e fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+10], cx
$LN66@JGPGetChar:

; 990  : 			}
; 991  : 			if ( lpCL->dbInventory[24] == (BYTE)-1 && (lpCL->dbInventory[26]& 0x80) == 0x80 && (lpCL->dbInventory[27]& 0xF0) == 0xF0  )

  01a8a	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01a8d	0f b6 48 28	 movzx	 ecx, BYTE PTR [eax+40]
  01a91	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01a97	75 32		 jne	 SHORT $LN65@JGPGetChar
  01a99	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01a9c	0f b6 48 2a	 movzx	 ecx, BYTE PTR [eax+42]
  01aa0	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01aa6	74 23		 je	 SHORT $LN65@JGPGetChar
  01aa8	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01aab	0f b6 48 2b	 movzx	 ecx, BYTE PTR [eax+43]
  01aaf	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01ab5	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  01abb	75 0e		 jne	 SHORT $LN65@JGPGetChar

; 992  : 			{
; 993  : 				TempInventory[6] = 0x1FF;

  01abd	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01ac2	66 89 85 a0 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+12], ax

; 994  : 			}
; 995  : 			else

  01ac9	eb 3e		 jmp	 SHORT $LN64@JGPGetChar
$LN65@JGPGetChar:

; 996  : 			{
; 997  : 				TempInventory[6] = ((lpCL->dbInventory[24] + (lpCL->dbInventory[26]&0x80)*2)+ (lpCL->dbInventory[27]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  01acb	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01ace	0f b6 48 28	 movzx	 ecx, BYTE PTR [eax+40]
  01ad2	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01ad5	0f b6 42 2a	 movzx	 eax, BYTE PTR [edx+42]
  01ad9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01ade	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01ae1	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01ae4	0f b6 42 2b	 movzx	 eax, BYTE PTR [edx+43]
  01ae8	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01aed	c1 e0 05	 shl	 eax, 5
  01af0	03 c8		 add	 ecx, eax
  01af2	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  01af8	79 08		 jns	 SHORT $LN105@JGPGetChar
  01afa	49		 dec	 ecx
  01afb	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01b01	41		 inc	 ecx
$LN105@JGPGetChar:
  01b02	66 89 8d a0 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+12], cx
$LN64@JGPGetChar:

; 998  : 			}
; 999  : 			if ( lpCL->dbInventory[28] == (BYTE)-1 && (lpCL->dbInventory[30]& 0x80) == 0x80 && (lpCL->dbInventory[31]& 0xF0) == 0xF0  )

  01b09	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01b0c	0f b6 48 2c	 movzx	 ecx, BYTE PTR [eax+44]
  01b10	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01b16	75 32		 jne	 SHORT $LN63@JGPGetChar
  01b18	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01b1b	0f b6 48 2e	 movzx	 ecx, BYTE PTR [eax+46]
  01b1f	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01b25	74 23		 je	 SHORT $LN63@JGPGetChar
  01b27	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01b2a	0f b6 48 2f	 movzx	 ecx, BYTE PTR [eax+47]
  01b2e	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01b34	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  01b3a	75 0e		 jne	 SHORT $LN63@JGPGetChar

; 1000 : 			{
; 1001 : 				TempInventory[7] = 0x1FF;

  01b3c	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01b41	66 89 85 a2 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+14], ax

; 1002 : 			}
; 1003 : 			else

  01b48	eb 3e		 jmp	 SHORT $LN62@JGPGetChar
$LN63@JGPGetChar:

; 1004 : 			{
; 1005 : 				TempInventory[7] = ((lpCL->dbInventory[28] + (lpCL->dbInventory[30]&0x80)*2)+ (lpCL->dbInventory[31]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  01b4a	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01b4d	0f b6 48 2c	 movzx	 ecx, BYTE PTR [eax+44]
  01b51	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01b54	0f b6 42 2e	 movzx	 eax, BYTE PTR [edx+46]
  01b58	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01b5d	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01b60	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01b63	0f b6 42 2f	 movzx	 eax, BYTE PTR [edx+47]
  01b67	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01b6c	c1 e0 05	 shl	 eax, 5
  01b6f	03 c8		 add	 ecx, eax
  01b71	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  01b77	79 08		 jns	 SHORT $LN106@JGPGetChar
  01b79	49		 dec	 ecx
  01b7a	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01b80	41		 inc	 ecx
$LN106@JGPGetChar:
  01b81	66 89 8d a2 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+14], cx
$LN62@JGPGetChar:

; 1006 : 			}
; 1007 : 			if ( lpCL->dbInventory[32] == (BYTE)-1 && (lpCL->dbInventory[34]& 0x80) == 0x80 && (lpCL->dbInventory[35]& 0xF0) == 0xF0  )

  01b88	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01b8b	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01b8f	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01b95	75 32		 jne	 SHORT $LN61@JGPGetChar
  01b97	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01b9a	0f b6 48 32	 movzx	 ecx, BYTE PTR [eax+50]
  01b9e	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01ba4	74 23		 je	 SHORT $LN61@JGPGetChar
  01ba6	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01ba9	0f b6 48 33	 movzx	 ecx, BYTE PTR [eax+51]
  01bad	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01bb3	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  01bb9	75 0e		 jne	 SHORT $LN61@JGPGetChar

; 1008 : 			{
; 1009 : 				TempInventory[8] = 0x1FF;

  01bbb	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01bc0	66 89 85 a4 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+16], ax

; 1010 : 			}
; 1011 : 			else

  01bc7	eb 3e		 jmp	 SHORT $LN60@JGPGetChar
$LN61@JGPGetChar:

; 1012 : 			{
; 1013 : 				TempInventory[8] = ((lpCL->dbInventory[32] + (lpCL->dbInventory[34]&0x80)*2)+ (lpCL->dbInventory[35]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  01bc9	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  01bcc	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01bd0	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01bd3	0f b6 42 32	 movzx	 eax, BYTE PTR [edx+50]
  01bd7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01bdc	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  01bdf	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  01be2	0f b6 42 33	 movzx	 eax, BYTE PTR [edx+51]
  01be6	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01beb	c1 e0 05	 shl	 eax, 5
  01bee	03 c8		 add	 ecx, eax
  01bf0	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  01bf6	79 08		 jns	 SHORT $LN107@JGPGetChar
  01bf8	49		 dec	 ecx
  01bf9	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  01bff	41		 inc	 ecx
$LN107@JGPGetChar:
  01c00	66 89 8d a4 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+16], cx
$LN60@JGPGetChar:

; 1014 : 			}
; 1015 : 
; 1016 : 			pCList.CharSet[12] |= DBI_GET_TYPE(TempInventory[0]);

  01c07	0f b7 85 94 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp]
  01c0e	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  01c13	c1 f8 04	 sar	 eax, 4
  01c16	0f b6 8d c7 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+27]
  01c1d	0b c8		 or	 ecx, eax
  01c1f	88 8d c7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], cl

; 1017 : 			pCList.CharSet[1] = TempInventory[0] % 256;

  01c25	0f b7 85 94 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp]
  01c2c	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  01c31	79 07		 jns	 SHORT $LN108@JGPGetChar
  01c33	48		 dec	 eax
  01c34	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  01c39	40		 inc	 eax
$LN108@JGPGetChar:
  01c3a	88 85 bc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+16], al

; 1018 : 
; 1019 : 			pCList.CharSet[13] |= DBI_GET_TYPE(TempInventory[1]);

  01c40	0f b7 85 96 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+2]
  01c47	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  01c4c	c1 f8 04	 sar	 eax, 4
  01c4f	0f b6 8d c8 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+28]
  01c56	0b c8		 or	 ecx, eax
  01c58	88 8d c8 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+28], cl

; 1020 : 			pCList.CharSet[2] = TempInventory[1] % 256;

  01c5e	0f b7 85 96 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+2]
  01c65	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  01c6a	79 07		 jns	 SHORT $LN109@JGPGetChar
  01c6c	48		 dec	 eax
  01c6d	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  01c72	40		 inc	 eax
$LN109@JGPGetChar:
  01c73	88 85 bd fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+17], al

; 1021 : 
; 1022 : 			pCList.CharSet[13] |= (int)(TempInventory[2] & 0x1E0) >> 5;

  01c79	0f b7 85 98 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+4]
  01c80	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01c85	c1 f8 05	 sar	 eax, 5
  01c88	0f b6 8d c8 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+28]
  01c8f	0b c8		 or	 ecx, eax
  01c91	88 8d c8 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+28], cl

; 1023 : 			pCList.CharSet[9] |= (int)(TempInventory[2] & 0x10) << 3;

  01c97	0f b7 85 98 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+4]
  01c9e	83 e0 10	 and	 eax, 16			; 00000010H
  01ca1	c1 e0 03	 shl	 eax, 3
  01ca4	0f b6 8d c4 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+24]
  01cab	0b c8		 or	 ecx, eax
  01cad	88 8d c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], cl

; 1024 : 			pCList.CharSet[3] |= (int)(TempInventory[2] & 0x0F) << 4;

  01cb3	0f b7 85 98 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+4]
  01cba	83 e0 0f	 and	 eax, 15			; 0000000fH
  01cbd	c1 e0 04	 shl	 eax, 4
  01cc0	0f b6 8d be fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+18]
  01cc7	0b c8		 or	 ecx, eax
  01cc9	88 8d be fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+18], cl

; 1025 : 
; 1026 : 			pCList.CharSet[14] |= (int)(TempInventory[3] & 0x1E0) >> 1;

  01ccf	0f b7 85 9a fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+6]
  01cd6	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01cdb	d1 f8		 sar	 eax, 1
  01cdd	0f b6 8d c9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+29]
  01ce4	0b c8		 or	 ecx, eax
  01ce6	88 8d c9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], cl

; 1027 : 			pCList.CharSet[9] |= (int)(TempInventory[3] & 0x10) << 2;

  01cec	0f b7 85 9a fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+6]
  01cf3	83 e0 10	 and	 eax, 16			; 00000010H
  01cf6	c1 e0 02	 shl	 eax, 2
  01cf9	0f b6 8d c4 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+24]
  01d00	0b c8		 or	 ecx, eax
  01d02	88 8d c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], cl

; 1028 : 			pCList.CharSet[3] |= (int)(TempInventory[3] & 0x0F);

  01d08	0f b7 85 9a fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+6]
  01d0f	83 e0 0f	 and	 eax, 15			; 0000000fH
  01d12	0f b6 8d be fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+18]
  01d19	0b c8		 or	 ecx, eax
  01d1b	88 8d be fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+18], cl

; 1029 : 
; 1030 : 			pCList.CharSet[14] |= (int)(TempInventory[4] & 0x1E0) >> 5;

  01d21	0f b7 85 9c fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+8]
  01d28	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01d2d	c1 f8 05	 sar	 eax, 5
  01d30	0f b6 8d c9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+29]
  01d37	0b c8		 or	 ecx, eax
  01d39	88 8d c9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], cl

; 1031 : 			pCList.CharSet[9] |= (int)(TempInventory[4] & 0x10) << 1;

  01d3f	0f b7 85 9c fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+8]
  01d46	83 e0 10	 and	 eax, 16			; 00000010H
  01d49	d1 e0		 shl	 eax, 1
  01d4b	0f b6 8d c4 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+24]
  01d52	0b c8		 or	 ecx, eax
  01d54	88 8d c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], cl

; 1032 : 			pCList.CharSet[4] |= (int)(TempInventory[4] & 0x0F) << 4;

  01d5a	0f b7 85 9c fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+8]
  01d61	83 e0 0f	 and	 eax, 15			; 0000000fH
  01d64	c1 e0 04	 shl	 eax, 4
  01d67	0f b6 8d bf fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+19]
  01d6e	0b c8		 or	 ecx, eax
  01d70	88 8d bf fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+19], cl

; 1033 : 
; 1034 : 			pCList.CharSet[15] |= (int)(TempInventory[5] & 0x1E0) >> 1;

  01d76	0f b7 85 9e fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+10]
  01d7d	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01d82	d1 f8		 sar	 eax, 1
  01d84	0f b6 8d ca fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+30]
  01d8b	0b c8		 or	 ecx, eax
  01d8d	88 8d ca fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], cl

; 1035 : 			pCList.CharSet[9] |= (int)(TempInventory[5] & 0x10);

  01d93	0f b7 85 9e fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+10]
  01d9a	83 e0 10	 and	 eax, 16			; 00000010H
  01d9d	0f b6 8d c4 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+24]
  01da4	0b c8		 or	 ecx, eax
  01da6	88 8d c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], cl

; 1036 : 			pCList.CharSet[4] |= (int)(TempInventory[5] & 0x0F);

  01dac	0f b7 85 9e fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+10]
  01db3	83 e0 0f	 and	 eax, 15			; 0000000fH
  01db6	0f b6 8d bf fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+19]
  01dbd	0b c8		 or	 ecx, eax
  01dbf	88 8d bf fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+19], cl

; 1037 : 
; 1038 : 			pCList.CharSet[15] |= (int)(TempInventory[6] & 0x1E0) >> 5;

  01dc5	0f b7 85 a0 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+12]
  01dcc	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01dd1	c1 f8 05	 sar	 eax, 5
  01dd4	0f b6 8d ca fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+30]
  01ddb	0b c8		 or	 ecx, eax
  01ddd	88 8d ca fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], cl

; 1039 : 			pCList.CharSet[9] |= (int)(TempInventory[6] & 0x10) >> 1;

  01de3	0f b7 85 a0 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+12]
  01dea	83 e0 10	 and	 eax, 16			; 00000010H
  01ded	d1 f8		 sar	 eax, 1
  01def	0f b6 8d c4 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+24]
  01df6	0b c8		 or	 ecx, eax
  01df8	88 8d c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], cl

; 1040 : 			pCList.CharSet[5] |= (int)(TempInventory[6] & 0x0F) << 4;

  01dfe	0f b7 85 a0 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+12]
  01e05	83 e0 0f	 and	 eax, 15			; 0000000fH
  01e08	c1 e0 04	 shl	 eax, 4
  01e0b	0f b6 8d c0 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+20]
  01e12	0b c8		 or	 ecx, eax
  01e14	88 8d c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], cl

; 1041 : 
; 1042 : 			index = 0;

  01e1a	c6 85 db fe ff
	ff 00		 mov	 BYTE PTR _index$[ebp], 0

; 1043 : 
; 1044 : 			// Wings Set
; 1045 : 			switch (TempInventory[7])

  01e21	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  01e28	89 85 30 fe ff
	ff		 mov	 DWORD PTR tv679[ebp], eax
  01e2e	81 bd 30 fe ff
	ff ff 01 00 00	 cmp	 DWORD PTR tv679[ebp], 511 ; 000001ffH
  01e38	7f 30		 jg	 SHORT $LN88@JGPGetChar
  01e3a	81 bd 30 fe ff
	ff ff 01 00 00	 cmp	 DWORD PTR tv679[ebp], 511 ; 000001ffH
  01e44	74 29		 je	 SHORT $LN57@JGPGetChar
  01e46	81 bd 30 fe ff
	ff 87 00 00 00	 cmp	 DWORD PTR tv679[ebp], 135 ; 00000087H
  01e50	0f 87 9a 03 00
	00		 ja	 $LN58@JGPGetChar
  01e56	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR tv679[ebp]
  01e5c	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN99@JGPGetChar[ecx]
  01e63	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN110@JGPGetChar[edx*4]
$LN88@JGPGetChar:
  01e6a	e9 81 03 00 00	 jmp	 $LN58@JGPGetChar
$LN57@JGPGetChar:

; 1046 : 			{
; 1047 : 			case 0x1FF: // No Wings
; 1048 : 				index |= 0;

  01e6f	8a 85 db fe ff
	ff		 mov	 al, BYTE PTR _index$[ebp]
  01e75	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al

; 1049 : 				break;

  01e7b	e9 70 03 00 00	 jmp	 $LN58@JGPGetChar
$LN56@JGPGetChar:

; 1050 : 			case 0: // Wings of Elf
; 1051 : 				pCList.CharSet[5] |= CS_SET_WING1(1);

  01e80	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01e87	83 c8 04	 or	 eax, 4
  01e8a	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1052 : 				pCList.CharSet[9] |= 1;

  01e90	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01e97	83 c8 01	 or	 eax, 1
  01e9a	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1053 : 				break;

  01ea0	e9 4b 03 00 00	 jmp	 $LN58@JGPGetChar
$LN55@JGPGetChar:

; 1054 : 			case 1: // Wings of Heaven
; 1055 : 				pCList.CharSet[5] |= CS_SET_WING1(1);

  01ea5	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01eac	83 c8 04	 or	 eax, 4
  01eaf	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1056 : 				pCList.CharSet[9] |= 2;

  01eb5	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01ebc	83 c8 02	 or	 eax, 2
  01ebf	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1057 : 				break;

  01ec5	e9 26 03 00 00	 jmp	 $LN58@JGPGetChar
$LN54@JGPGetChar:

; 1058 : 			case 2: // Wings of Satan
; 1059 : 				pCList.CharSet[5] |= CS_SET_WING1(1);

  01eca	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01ed1	83 c8 04	 or	 eax, 4
  01ed4	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1060 : 				pCList.CharSet[9] |= 3;

  01eda	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01ee1	83 c8 03	 or	 eax, 3
  01ee4	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1061 : 				break;

  01eea	e9 01 03 00 00	 jmp	 $LN58@JGPGetChar
$LN53@JGPGetChar:

; 1062 : 			case 41:
; 1063 : 				pCList.CharSet[5] |= CS_SET_WING1(1);

  01eef	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01ef6	83 c8 04	 or	 eax, 4
  01ef9	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1064 : 				pCList.CharSet[9] |= 4;

  01eff	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01f06	83 c8 04	 or	 eax, 4
  01f09	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1065 : 				break;

  01f0f	e9 dc 02 00 00	 jmp	 $LN58@JGPGetChar
$LN52@JGPGetChar:

; 1066 : 			case 3: // Muse Elf Wings
; 1067 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01f14	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01f1b	83 c8 08	 or	 eax, 8
  01f1e	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1068 : 				pCList.CharSet[9] |= 1;

  01f24	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01f2b	83 c8 01	 or	 eax, 1
  01f2e	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1069 : 				break;

  01f34	e9 b7 02 00 00	 jmp	 $LN58@JGPGetChar
$LN51@JGPGetChar:

; 1070 : 			case 4: // Soul Master Wings
; 1071 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01f39	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01f40	83 c8 08	 or	 eax, 8
  01f43	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1072 : 				pCList.CharSet[9] |= 2;

  01f49	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01f50	83 c8 02	 or	 eax, 2
  01f53	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1073 : 				break;

  01f59	e9 92 02 00 00	 jmp	 $LN58@JGPGetChar
$LN50@JGPGetChar:

; 1074 : 			case 5: // Blade Knight Wings
; 1075 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01f5e	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01f65	83 c8 08	 or	 eax, 8
  01f68	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1076 : 				pCList.CharSet[9] |= 3;

  01f6e	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01f75	83 c8 03	 or	 eax, 3
  01f78	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1077 : 				break;

  01f7e	e9 6d 02 00 00	 jmp	 $LN58@JGPGetChar
$LN49@JGPGetChar:

; 1078 : 			case 6: // Magic Gladiator Wings
; 1079 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01f83	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01f8a	83 c8 08	 or	 eax, 8
  01f8d	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1080 : 				pCList.CharSet[9] |= 4;

  01f93	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01f9a	83 c8 04	 or	 eax, 4
  01f9d	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1081 : 				break;

  01fa3	e9 48 02 00 00	 jmp	 $LN58@JGPGetChar
$LN48@JGPGetChar:

; 1082 : 			case 30: // Cape of Lord
; 1083 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01fa8	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01faf	83 c8 08	 or	 eax, 8
  01fb2	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1084 : 				pCList.CharSet[9] |= 5;

  01fb8	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01fbf	83 c8 05	 or	 eax, 5
  01fc2	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1085 : 				break;

  01fc8	e9 23 02 00 00	 jmp	 $LN58@JGPGetChar
$LN47@JGPGetChar:

; 1086 : 			case 42: // Bloody Summoner Wings
; 1087 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01fcd	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01fd4	83 c8 08	 or	 eax, 8
  01fd7	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1088 : 				pCList.CharSet[9] |= 6;

  01fdd	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  01fe4	83 c8 06	 or	 eax, 6
  01fe7	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1089 : 				break;

  01fed	e9 fe 01 00 00	 jmp	 $LN58@JGPGetChar
$LN46@JGPGetChar:

; 1090 : 			case 49: // Cloak of Warrior
; 1091 : 				pCList.CharSet[5] |= CS_SET_WING1(2);

  01ff2	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  01ff9	83 c8 08	 or	 eax, 8
  01ffc	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1092 : 				pCList.CharSet[9] |= 7;

  02002	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  02009	83 c8 07	 or	 eax, 7
  0200c	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1093 : 				break;

  02012	e9 d9 01 00 00	 jmp	 $LN58@JGPGetChar
$LN45@JGPGetChar:

; 1094 : 			case 36: // Blade Master Wings
; 1095 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  02017	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  0201e	83 c8 0c	 or	 eax, 12			; 0000000cH
  02021	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1096 : 				pCList.CharSet[9] |= 1;

  02027	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  0202e	83 c8 01	 or	 eax, 1
  02031	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1097 : 				break;

  02037	e9 b4 01 00 00	 jmp	 $LN58@JGPGetChar
$LN44@JGPGetChar:

; 1098 : 			case 37: // Grand Master Wings
; 1099 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  0203c	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  02043	83 c8 0c	 or	 eax, 12			; 0000000cH
  02046	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1100 : 				pCList.CharSet[9] |= 2;

  0204c	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  02053	83 c8 02	 or	 eax, 2
  02056	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1101 : 				break;

  0205c	e9 8f 01 00 00	 jmp	 $LN58@JGPGetChar
$LN43@JGPGetChar:

; 1102 : 			case 38: // High Elf Wings
; 1103 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  02061	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  02068	83 c8 0c	 or	 eax, 12			; 0000000cH
  0206b	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1104 : 				pCList.CharSet[9] |= 3;

  02071	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  02078	83 c8 03	 or	 eax, 3
  0207b	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1105 : 				break;

  02081	e9 6a 01 00 00	 jmp	 $LN58@JGPGetChar
$LN42@JGPGetChar:

; 1106 : 			case 39: // Duel Master Wings
; 1107 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  02086	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  0208d	83 c8 0c	 or	 eax, 12			; 0000000cH
  02090	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1108 : 				pCList.CharSet[9] |= 4;

  02096	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  0209d	83 c8 04	 or	 eax, 4
  020a0	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1109 : 				break;

  020a6	e9 45 01 00 00	 jmp	 $LN58@JGPGetChar
$LN41@JGPGetChar:

; 1110 : 			case 40: // Lord Emperor Cape
; 1111 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  020ab	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  020b2	83 c8 0c	 or	 eax, 12			; 0000000cH
  020b5	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1112 : 				pCList.CharSet[9] |= 5;

  020bb	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  020c2	83 c8 05	 or	 eax, 5
  020c5	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1113 : 				break;

  020cb	e9 20 01 00 00	 jmp	 $LN58@JGPGetChar
$LN40@JGPGetChar:

; 1114 : 			case 43: // Dimension Master Wings
; 1115 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  020d0	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  020d7	83 c8 0c	 or	 eax, 12			; 0000000cH
  020da	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1116 : 				pCList.CharSet[9] |= 6;

  020e0	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  020e7	83 c8 06	 or	 eax, 6
  020ea	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1117 : 				break;

  020f0	e9 fb 00 00 00	 jmp	 $LN58@JGPGetChar
$LN39@JGPGetChar:

; 1118 : 			case 50: // Fist Master Cloak
; 1119 : 				pCList.CharSet[5] |= CS_SET_WING1(-1);

  020f5	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  020fc	83 c8 0c	 or	 eax, 12			; 0000000cH
  020ff	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1120 : 				pCList.CharSet[9] |= 7;

  02105	0f b6 85 c4 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+24]
  0210c	83 c8 07	 or	 eax, 7
  0210f	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1121 : 				break;

  02115	e9 d6 00 00 00	 jmp	 $LN58@JGPGetChar
$LN38@JGPGetChar:

; 1122 : 			case 130: // Small Cape of Lord
; 1123 : 				pCList.CharSet[5] |= CS_SET_WING1(3);

  0211a	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  02121	83 c8 0c	 or	 eax, 12			; 0000000cH
  02124	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1124 : 				pCList.CharSet[17] |= 32;

  0212a	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  02131	83 c8 20	 or	 eax, 32			; 00000020H
  02134	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al

; 1125 : 				break;

  0213a	e9 b1 00 00 00	 jmp	 $LN58@JGPGetChar
$LN37@JGPGetChar:

; 1126 : 			case 131: // Small Wings of Misery
; 1127 : 				pCList.CharSet[5] |= CS_SET_WING1(3);

  0213f	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  02146	83 c8 0c	 or	 eax, 12			; 0000000cH
  02149	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1128 : 				pCList.CharSet[17] |= 64;

  0214f	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  02156	83 c8 40	 or	 eax, 64			; 00000040H
  02159	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al

; 1129 : 				break;

  0215f	e9 8c 00 00 00	 jmp	 $LN58@JGPGetChar
$LN36@JGPGetChar:

; 1130 : 			case 132: // Small Wings of Elf
; 1131 : 				pCList.CharSet[5] |= CS_SET_WING1(3);

  02164	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  0216b	83 c8 0c	 or	 eax, 12			; 0000000cH
  0216e	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1132 : 				pCList.CharSet[17] |= 96;

  02174	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  0217b	83 c8 60	 or	 eax, 96			; 00000060H
  0217e	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al

; 1133 : 				break;

  02184	eb 6a		 jmp	 SHORT $LN58@JGPGetChar
$LN35@JGPGetChar:

; 1134 : 			case 133: // Small Wings of Heaven
; 1135 : 				pCList.CharSet[5] |= CS_SET_WING1(3);

  02186	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  0218d	83 c8 0c	 or	 eax, 12			; 0000000cH
  02190	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1136 : 				pCList.CharSet[17] |= 128;

  02196	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  0219d	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  021a2	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al

; 1137 : 				break;

  021a8	eb 46		 jmp	 SHORT $LN58@JGPGetChar
$LN34@JGPGetChar:

; 1138 : 			case 134: // Small Wings of Satan
; 1139 : 				pCList.CharSet[5] |= CS_SET_WING1(3);

  021aa	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  021b1	83 c8 0c	 or	 eax, 12			; 0000000cH
  021b4	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1140 : 				pCList.CharSet[17] |= 160;

  021ba	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  021c1	0d a0 00 00 00	 or	 eax, 160		; 000000a0H
  021c6	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al

; 1141 : 				break;

  021cc	eb 22		 jmp	 SHORT $LN58@JGPGetChar
$LN33@JGPGetChar:

; 1142 : 			case 135: // Small Cloak of Warrior
; 1143 : 				pCList.CharSet[5] |= CS_SET_WING1(3);

  021ce	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  021d5	83 c8 0c	 or	 eax, 12			; 0000000cH
  021d8	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1144 : 				pCList.CharSet[17] |= 192;

  021de	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  021e5	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  021ea	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al
$LN58@JGPGetChar:

; 1145 : 				break;
; 1146 : 			}
; 1147 : #ifdef NEWWINGS
; 1148 : 			if( IS_NEWWINGS(TempInventory[7]+ITEMGET(12, 0)) )
; 1149 : 			{
; 1150 : 				pCList.CharSet[5]	|= CS_SET_WING1(3);
; 1151 : 				pCList.CharSet[17]	|= (BYTE)(TempInventory[7] - 180 + 1) << 2;
; 1152 : 			}
; 1153 : #endif
; 1154 : #ifdef NEWWINGS_2_5
; 1155 : 			if( IS_NEWWINGS_2_5(TempInventory[7]+ITEMGET(12, 0)) )

  021f0	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  021f7	05 00 18 00 00	 add	 eax, 6144		; 00001800H
  021fc	3d ba 18 00 00	 cmp	 eax, 6330		; 000018baH
  02201	7d 0c		 jge	 SHORT $LN89@JGPGetChar
  02203	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv932[ebp], 0
  0220d	eb 1e		 jmp	 SHORT $LN90@JGPGetChar
$LN89@JGPGetChar:
  0220f	0f b7 8d a2 fe
	ff ff		 movzx	 ecx, WORD PTR _TempInventory$[ebp+14]
  02216	81 c1 00 18 00
	00		 add	 ecx, 6144		; 00001800H
  0221c	33 d2		 xor	 edx, edx
  0221e	81 f9 bc 18 00
	00		 cmp	 ecx, 6332		; 000018bcH
  02224	0f 9e c2	 setle	 dl
  02227	89 95 30 fe ff
	ff		 mov	 DWORD PTR tv932[ebp], edx
$LN90@JGPGetChar:
  0222d	83 bd 30 fe ff
	ff 00		 cmp	 DWORD PTR tv932[ebp], 0
  02234	74 31		 je	 SHORT $LN32@JGPGetChar

; 1156 : 			{
; 1157 : 				pCList.CharSet[5]	|= CS_SET_WING1(3);

  02236	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  0223d	83 c8 0c	 or	 eax, 12			; 0000000cH
  02240	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1158 : 				pCList.CharSet[17]	|= (BYTE)(TempInventory[7] - 180 + 1) << 2;

  02246	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  0224d	2d b3 00 00 00	 sub	 eax, 179		; 000000b3H
  02252	0f b6 c8	 movzx	 ecx, al
  02255	c1 e1 02	 shl	 ecx, 2
  02258	0f b6 95 cc fe
	ff ff		 movzx	 edx, BYTE PTR _pCList$[ebp+32]
  0225f	0b d1		 or	 edx, ecx
  02261	88 95 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], dl
$LN32@JGPGetChar:

; 1159 : 			}
; 1160 : #endif
; 1161 : #ifdef NEWWINGS_4
; 1162 : 			if( IS_NEWWINGS_4(TempInventory[7]+ITEMGET(12, 0)) )

  02267	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  0226e	05 00 18 00 00	 add	 eax, 6144		; 00001800H
  02273	3d b4 18 00 00	 cmp	 eax, 6324		; 000018b4H
  02278	7d 0c		 jge	 SHORT $LN91@JGPGetChar
  0227a	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv960[ebp], 0
  02284	eb 1e		 jmp	 SHORT $LN92@JGPGetChar
$LN91@JGPGetChar:
  02286	0f b7 8d a2 fe
	ff ff		 movzx	 ecx, WORD PTR _TempInventory$[ebp+14]
  0228d	81 c1 00 18 00
	00		 add	 ecx, 6144		; 00001800H
  02293	33 d2		 xor	 edx, edx
  02295	81 f9 b9 18 00
	00		 cmp	 ecx, 6329		; 000018b9H
  0229b	0f 9e c2	 setle	 dl
  0229e	89 95 30 fe ff
	ff		 mov	 DWORD PTR tv960[ebp], edx
$LN92@JGPGetChar:
  022a4	83 bd 30 fe ff
	ff 00		 cmp	 DWORD PTR tv960[ebp], 0
  022ab	74 31		 je	 SHORT $LN31@JGPGetChar

; 1163 : 			{
; 1164 : 				pCList.CharSet[5]	|= CS_SET_WING1(3);

  022ad	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  022b4	83 c8 0c	 or	 eax, 12			; 0000000cH
  022b7	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1165 : 				pCList.CharSet[17]	|= (BYTE)(TempInventory[7] - 180 + 1) << 2;

  022bd	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  022c4	2d b3 00 00 00	 sub	 eax, 179		; 000000b3H
  022c9	0f b6 c8	 movzx	 ecx, al
  022cc	c1 e1 02	 shl	 ecx, 2
  022cf	0f b6 95 cc fe
	ff ff		 movzx	 edx, BYTE PTR _pCList$[ebp+32]
  022d6	0b d1		 or	 edx, ecx
  022d8	88 95 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], dl
$LN31@JGPGetChar:

; 1166 : 			}
; 1167 : #endif
; 1168 : #ifdef NEWWINGS_5
; 1169 : 			if( IS_NEWWINGS_5(TempInventory[7]+ITEMGET(12, 0)) )

  022de	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  022e5	05 00 18 00 00	 add	 eax, 6144		; 00001800H
  022ea	3d bd 18 00 00	 cmp	 eax, 6333		; 000018bdH
  022ef	7d 0c		 jge	 SHORT $LN93@JGPGetChar
  022f1	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv988[ebp], 0
  022fb	eb 1e		 jmp	 SHORT $LN94@JGPGetChar
$LN93@JGPGetChar:
  022fd	0f b7 8d a2 fe
	ff ff		 movzx	 ecx, WORD PTR _TempInventory$[ebp+14]
  02304	81 c1 00 18 00
	00		 add	 ecx, 6144		; 00001800H
  0230a	33 d2		 xor	 edx, edx
  0230c	81 f9 c2 18 00
	00		 cmp	 ecx, 6338		; 000018c2H
  02312	0f 9e c2	 setle	 dl
  02315	89 95 30 fe ff
	ff		 mov	 DWORD PTR tv988[ebp], edx
$LN94@JGPGetChar:
  0231b	83 bd 30 fe ff
	ff 00		 cmp	 DWORD PTR tv988[ebp], 0
  02322	74 31		 je	 SHORT $LN30@JGPGetChar

; 1170 : 			{
; 1171 : 				pCList.CharSet[5]	|= CS_SET_WING1(3);

  02324	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  0232b	83 c8 0c	 or	 eax, 12			; 0000000cH
  0232e	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1172 : 				pCList.CharSet[17]	|= (BYTE)(TempInventory[7] - 180 + 1) << 2;

  02334	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  0233b	2d b3 00 00 00	 sub	 eax, 179		; 000000b3H
  02340	0f b6 c8	 movzx	 ecx, al
  02343	c1 e1 02	 shl	 ecx, 2
  02346	0f b6 95 cc fe
	ff ff		 movzx	 edx, BYTE PTR _pCList$[ebp+32]
  0234d	0b d1		 or	 edx, ecx
  0234f	88 95 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], dl
$LN30@JGPGetChar:

; 1173 : 			}
; 1174 : #endif
; 1175 : #ifdef NEWWINGS_6
; 1176 : 			if( IS_NEWWINGS_6(TempInventory[7]+ITEMGET(12, 0)) )

  02355	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  0235c	05 00 18 00 00	 add	 eax, 6144		; 00001800H
  02361	3d c3 18 00 00	 cmp	 eax, 6339		; 000018c3H
  02366	7d 0c		 jge	 SHORT $LN95@JGPGetChar
  02368	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1016[ebp], 0
  02372	eb 1e		 jmp	 SHORT $LN96@JGPGetChar
$LN95@JGPGetChar:
  02374	0f b7 8d a2 fe
	ff ff		 movzx	 ecx, WORD PTR _TempInventory$[ebp+14]
  0237b	81 c1 00 18 00
	00		 add	 ecx, 6144		; 00001800H
  02381	33 d2		 xor	 edx, edx
  02383	81 f9 dc 18 00
	00		 cmp	 ecx, 6364		; 000018dcH
  02389	0f 9e c2	 setle	 dl
  0238c	89 95 30 fe ff
	ff		 mov	 DWORD PTR tv1016[ebp], edx
$LN96@JGPGetChar:
  02392	83 bd 30 fe ff
	ff 00		 cmp	 DWORD PTR tv1016[ebp], 0
  02399	74 31		 je	 SHORT $LN29@JGPGetChar

; 1177 : 			{
; 1178 : 				//if(g_ExLicense.CheckUser(eExUB::PrideMuLocal || eExUB::PrideMu || eExUB::Local3 || eExUB::Local2)){
; 1179 : 			
; 1180 : 				pCList.CharSet[5]	|= CS_SET_WING1(3);

  0239b	0f b6 85 c0 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+20]
  023a2	83 c8 0c	 or	 eax, 12			; 0000000cH
  023a5	88 85 c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1181 : 				pCList.CharSet[17]	|= (BYTE)(TempInventory[7] - 180 + 1) << 2;

  023ab	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+14]
  023b2	2d b3 00 00 00	 sub	 eax, 179		; 000000b3H
  023b7	0f b6 c8	 movzx	 ecx, al
  023ba	c1 e1 02	 shl	 ecx, 2
  023bd	0f b6 95 cc fe
	ff ff		 movzx	 edx, BYTE PTR _pCList$[ebp+32]
  023c4	0b d1		 or	 edx, ecx
  023c6	88 95 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], dl
$LN29@JGPGetChar:

; 1182 : 				//}
; 1183 : 			}
; 1184 : #endif
; 1185 : 			// Pets Set
; 1186 : 			switch (TempInventory[8])

  023cc	0f b7 85 a4 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+16]
  023d3	89 85 30 fe ff
	ff		 mov	 DWORD PTR tv1037[ebp], eax
  023d9	83 bd 30 fe ff
	ff 43		 cmp	 DWORD PTR tv1037[ebp], 67 ; 00000043H
  023e0	7f 3d		 jg	 SHORT $LN97@JGPGetChar
  023e2	83 bd 30 fe ff
	ff 43		 cmp	 DWORD PTR tv1037[ebp], 67 ; 00000043H
  023e9	0f 84 0a 01 00
	00		 je	 $LN21@JGPGetChar
  023ef	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR tv1037[ebp]
  023f5	83 e9 03	 sub	 ecx, 3
  023f8	89 8d 30 fe ff
	ff		 mov	 DWORD PTR tv1037[ebp], ecx
  023fe	83 bd 30 fe ff
	ff 3e		 cmp	 DWORD PTR tv1037[ebp], 62 ; 0000003eH
  02405	0f 87 f7 01 00
	00		 ja	 $LN13@JGPGetChar
  0240b	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR tv1037[ebp]
  02411	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN100@JGPGetChar[edx]
  02418	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN111@JGPGetChar[eax*4]
$LN97@JGPGetChar:
  0241f	83 bd 30 fe ff
	ff 7b		 cmp	 DWORD PTR tv1037[ebp], 123 ; 0000007bH
  02426	7f 2c		 jg	 SHORT $LN98@JGPGetChar
  02428	83 bd 30 fe ff
	ff 7b		 cmp	 DWORD PTR tv1037[ebp], 123 ; 0000007bH
  0242f	0f 84 98 00 00
	00		 je	 $LN23@JGPGetChar
  02435	83 bd 30 fe ff
	ff 50		 cmp	 DWORD PTR tv1037[ebp], 80 ; 00000050H
  0243c	0f 84 a0 00 00
	00		 je	 $LN22@JGPGetChar
  02442	83 bd 30 fe ff
	ff 6a		 cmp	 DWORD PTR tv1037[ebp], 106 ; 0000006aH
  02449	0f 84 eb 00 00
	00		 je	 $LN18@JGPGetChar
  0244f	e9 ae 01 00 00	 jmp	 $LN13@JGPGetChar
$LN98@JGPGetChar:
  02454	81 bd 30 fe ff
	ff ff 01 00 00	 cmp	 DWORD PTR tv1037[ebp], 511 ; 000001ffH
  0245e	74 05		 je	 SHORT $LN26@JGPGetChar
  02460	e9 9d 01 00 00	 jmp	 $LN13@JGPGetChar
$LN26@JGPGetChar:

; 1187 : 			{
; 1188 : 			case 0x1FF:
; 1189 : 				index |= 0x03;

  02465	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  0246c	83 c8 03	 or	 eax, 3
  0246f	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al

; 1190 : 				break;

  02475	e9 e7 01 00 00	 jmp	 $LN27@JGPGetChar
$LN25@JGPGetChar:

; 1191 : 			case 4: // Dark Horse
; 1192 : 				index |= CS_SET_HELPER(-1);

  0247a	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  02481	83 c8 03	 or	 eax, 3
  02484	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al

; 1193 : 				pCList.CharSet[12] |= 0x01;

  0248a	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+27]
  02491	83 c8 01	 or	 eax, 1
  02494	88 85 c7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], al

; 1194 : 				break;

  0249a	e9 c2 01 00 00	 jmp	 $LN27@JGPGetChar
$LN24@JGPGetChar:

; 1195 : 			case 3: // Dinorant
; 1196 : 				pCList.CharSet[10] |= 0x01;

  0249f	0f b6 85 c5 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+25]
  024a6	83 c8 01	 or	 eax, 1
  024a9	88 85 c5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], al

; 1197 : 				index |= (TempInventory[8] ) & 0x03;

  024af	0f b7 85 a4 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+16]
  024b6	83 e0 03	 and	 eax, 3
  024b9	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _index$[ebp]
  024c0	0b c8		 or	 ecx, eax
  024c2	88 8d db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], cl

; 1198 : 				break;

  024c8	e9 94 01 00 00	 jmp	 $LN27@JGPGetChar
$LN23@JGPGetChar:

; 1199 : 			case 123: // Skeleton Pet
; 1200 : 				pCList.CharSet[16] |= 96;

  024cd	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  024d4	83 c8 60	 or	 eax, 96			; 00000060H
  024d7	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al

; 1201 : 				break;

  024dd	e9 7f 01 00 00	 jmp	 $LN27@JGPGetChar
$LN22@JGPGetChar:

; 1202 : 			case 80: // Panda Pet
; 1203 : 				pCList.CharSet[16] |= 224;

  024e2	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  024e9	0d e0 00 00 00	 or	 eax, 224		; 000000e0H
  024ee	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al

; 1204 : 				break;

  024f4	e9 68 01 00 00	 jmp	 $LN27@JGPGetChar
$LN21@JGPGetChar:

; 1205 : 			case 67: // Rudolf Pet
; 1206 : 				pCList.CharSet[16] |= 0x80;

  024f9	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  02500	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  02505	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al

; 1207 : 				break;

  0250b	e9 51 01 00 00	 jmp	 $LN27@JGPGetChar
$LN20@JGPGetChar:

; 1208 : 			case 64: // Demon Pet
; 1209 : 				pCList.CharSet[16] |= 0x20;

  02510	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  02517	83 c8 20	 or	 eax, 32			; 00000020H
  0251a	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al

; 1210 : 				break;

  02520	e9 3c 01 00 00	 jmp	 $LN27@JGPGetChar
$LN19@JGPGetChar:

; 1211 : 			case 65: // Spirit of Guardian Pet
; 1212 : 				pCList.CharSet[16] |= 0x40;

  02525	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  0252c	83 c8 40	 or	 eax, 64			; 00000040H
  0252f	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al

; 1213 : 				break;

  02535	e9 27 01 00 00	 jmp	 $LN27@JGPGetChar
$LN18@JGPGetChar:

; 1214 : 			case 106:	//JPN Unicorn
; 1215 : 				pCList.CharSet[16] |= 0xA0;

  0253a	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  02541	0d a0 00 00 00	 or	 eax, 160		; 000000a0H
  02546	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al

; 1216 : 				break;

  0254c	e9 10 01 00 00	 jmp	 $LN27@JGPGetChar
$LN17@JGPGetChar:

; 1217 : 			case 37:
; 1218 : 				index |= CS_SET_HELPER(-1);

  02551	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  02558	83 c8 03	 or	 eax, 3
  0255b	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al

; 1219 : 				pCList.CharSet[10] &= 0xFE;

  02561	0f b6 85 c5 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+25]
  02568	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  0256d	88 85 c5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], al

; 1220 : 				pCList.CharSet[12] &= 0xFE;

  02573	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+27]
  0257a	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  0257f	88 85 c7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], al

; 1221 : 				pCList.CharSet[12] |= 0x04;

  02585	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+27]
  0258c	83 c8 04	 or	 eax, 4
  0258f	88 85 c7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], al

; 1222 : 				pCList.CharSet[16] = 0;

  02595	c6 85 cb fe ff
	ff 00		 mov	 BYTE PTR _pCList$[ebp+31], 0

; 1223 : 				btExcellentOption = lpCL->dbInventory[34] & 0x3F;

  0259c	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0259f	0f b6 48 32	 movzx	 ecx, BYTE PTR [eax+50]
  025a3	83 e1 3f	 and	 ecx, 63			; 0000003fH
  025a6	88 8d 93 fe ff
	ff		 mov	 BYTE PTR _btExcellentOption$[ebp], cl

; 1224 : 
; 1225 : 				if ( (btExcellentOption&1) == 1 ) // Red Fenrir

  025ac	0f b6 85 93 fe
	ff ff		 movzx	 eax, BYTE PTR _btExcellentOption$[ebp]
  025b3	83 e0 01	 and	 eax, 1
  025b6	74 10		 je	 SHORT $LN16@JGPGetChar

; 1226 : 				{
; 1227 : 					pCList.CharSet[16] |= 0x01;

  025b8	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  025bf	83 c8 01	 or	 eax, 1
  025c2	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al
$LN16@JGPGetChar:

; 1228 : 				}
; 1229 : 				if ( (btExcellentOption&2) == 2 ) // Blue Fenrir

  025c8	0f b6 85 93 fe
	ff ff		 movzx	 eax, BYTE PTR _btExcellentOption$[ebp]
  025cf	83 e0 02	 and	 eax, 2
  025d2	74 10		 je	 SHORT $LN15@JGPGetChar

; 1230 : 				{
; 1231 : 					pCList.CharSet[16] |= 0x02;

  025d4	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+31]
  025db	83 c8 02	 or	 eax, 2
  025de	88 85 cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], al
$LN15@JGPGetChar:

; 1232 : 				}
; 1233 : 				if ( (btExcellentOption&4) == 4 ) // Gold Fenrir 

  025e4	0f b6 85 93 fe
	ff ff		 movzx	 eax, BYTE PTR _btExcellentOption$[ebp]
  025eb	83 e0 04	 and	 eax, 4
  025ee	74 10		 je	 SHORT $LN14@JGPGetChar

; 1234 : 				{
; 1235 : 					pCList.CharSet[17] |= 0x01;

  025f0	0f b6 85 cc fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+32]
  025f7	83 c8 01	 or	 eax, 1
  025fa	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al
$LN14@JGPGetChar:

; 1236 : 				}
; 1237 : 				break;

  02600	eb 5f		 jmp	 SHORT $LN27@JGPGetChar
$LN13@JGPGetChar:

; 1238 : 			default:
; 1239 : 				#if(ENABLE_PETEX)
; 1240 : 				if(g_PetEx.IsPet(ITEMGET(13, TempInventory[8])))

  02602	0f b7 85 a4 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+16]
  02609	05 00 1a 00 00	 add	 eax, 6656		; 00001a00H
  0260e	50		 push	 eax
  0260f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PetEx@@3VCPetEx@@A ; g_PetEx
  02614	e8 00 00 00 00	 call	 ?IsPet@CPetEx@@QAE_NH@Z	; CPetEx::IsPet
  02619	0f b6 c8	 movzx	 ecx, al
  0261c	85 c9		 test	 ecx, ecx
  0261e	74 28		 je	 SHORT $LN12@JGPGetChar

; 1241 : 				{
; 1242 : 					index |= CS_SET_HELPER(3);

  02620	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  02627	83 c8 03	 or	 eax, 3
  0262a	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al

; 1243 : 					pCList.CharSet[16] |= TempInventory[8];

  02630	0f b7 85 a4 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+16]
  02637	0f b6 8d cb fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+31]
  0263e	0b c8		 or	 ecx, eax
  02640	88 8d cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], cl

; 1244 : 					break;

  02646	eb 19		 jmp	 SHORT $LN27@JGPGetChar
$LN12@JGPGetChar:

; 1245 : 				}
; 1246 : 				#endif
; 1247 : 				index |= (TempInventory[8] ) & 0x03;

  02648	0f b7 85 a4 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+16]
  0264f	83 e0 03	 and	 eax, 3
  02652	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _index$[ebp]
  02659	0b c8		 or	 ecx, eax
  0265b	88 8d db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], cl
$LN27@JGPGetChar:

; 1248 : 				break;
; 1249 : 			}
; 1250 : 
; 1251 : 			pCList.CharSet[5] |= index;

  02661	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  02668	0f b6 8d c0 fe
	ff ff		 movzx	 ecx, BYTE PTR _pCList$[ebp+20]
  0266f	0b c8		 or	 ecx, eax
  02671	88 8d c0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], cl

; 1252 : 
; 1253 : 			int levelindex = 0;

  02677	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _levelindex$245428[ebp], 0

; 1254 : 
; 1255 : 			if ( TempInventory[0] != (WORD)-1 )

  02681	0f b7 85 94 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp]
  02688	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0268d	74 1f		 je	 SHORT $LN11@JGPGetChar

; 1256 : 			{
; 1257 : 				levelindex = LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[1]));

  0268f	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  02692	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  02696	c1 f9 03	 sar	 ecx, 3
  02699	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0269c	51		 push	 ecx
  0269d	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  026a2	83 c4 04	 add	 esp, 4
  026a5	0f b6 d0	 movzx	 edx, al
  026a8	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN11@JGPGetChar:

; 1258 : 			}
; 1259 : 			if ( TempInventory[1] != (WORD)-1 )

  026ae	0f b7 85 96 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+2]
  026b5	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  026ba	74 28		 je	 SHORT $LN10@JGPGetChar

; 1260 : 			{
; 1261 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[5])) << 3;

  026bc	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  026bf	0f b6 48 15	 movzx	 ecx, BYTE PTR [eax+21]
  026c3	c1 f9 03	 sar	 ecx, 3
  026c6	83 e1 0f	 and	 ecx, 15			; 0000000fH
  026c9	51		 push	 ecx
  026ca	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  026cf	83 c4 04	 add	 esp, 4
  026d2	0f b6 d0	 movzx	 edx, al
  026d5	c1 e2 03	 shl	 edx, 3
  026d8	0b 95 7c fe ff
	ff		 or	 edx, DWORD PTR _levelindex$245428[ebp]
  026de	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN10@JGPGetChar:

; 1262 : 			}
; 1263 : 			if ( TempInventory[2] < 0x1FF )

  026e4	0f b7 85 98 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+4]
  026eb	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  026f0	7d 28		 jge	 SHORT $LN9@JGPGetChar

; 1264 : 			{
; 1265 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[9])) << 6;

  026f2	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  026f5	0f b6 48 19	 movzx	 ecx, BYTE PTR [eax+25]
  026f9	c1 f9 03	 sar	 ecx, 3
  026fc	83 e1 0f	 and	 ecx, 15			; 0000000fH
  026ff	51		 push	 ecx
  02700	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  02705	83 c4 04	 add	 esp, 4
  02708	0f b6 d0	 movzx	 edx, al
  0270b	c1 e2 06	 shl	 edx, 6
  0270e	0b 95 7c fe ff
	ff		 or	 edx, DWORD PTR _levelindex$245428[ebp]
  02714	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN9@JGPGetChar:

; 1266 : 			}
; 1267 : 			if ( TempInventory[3] < 0x1FF )

  0271a	0f b7 85 9a fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+6]
  02721	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  02726	7d 28		 jge	 SHORT $LN8@JGPGetChar

; 1268 : 			{
; 1269 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[13])) << 9;

  02728	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0272b	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  0272f	c1 f9 03	 sar	 ecx, 3
  02732	83 e1 0f	 and	 ecx, 15			; 0000000fH
  02735	51		 push	 ecx
  02736	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0273b	83 c4 04	 add	 esp, 4
  0273e	0f b6 d0	 movzx	 edx, al
  02741	c1 e2 09	 shl	 edx, 9
  02744	0b 95 7c fe ff
	ff		 or	 edx, DWORD PTR _levelindex$245428[ebp]
  0274a	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN8@JGPGetChar:

; 1270 : 			}
; 1271 : 			if ( TempInventory[4] < 0x1FF )

  02750	0f b7 85 9c fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+8]
  02757	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  0275c	7d 28		 jge	 SHORT $LN7@JGPGetChar

; 1272 : 			{
; 1273 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[17])) << 12;

  0275e	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  02761	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  02765	c1 f9 03	 sar	 ecx, 3
  02768	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0276b	51		 push	 ecx
  0276c	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  02771	83 c4 04	 add	 esp, 4
  02774	0f b6 d0	 movzx	 edx, al
  02777	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  0277a	0b 95 7c fe ff
	ff		 or	 edx, DWORD PTR _levelindex$245428[ebp]
  02780	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN7@JGPGetChar:

; 1274 : 			}
; 1275 : 			if ( TempInventory[5] < 0x1FF )

  02786	0f b7 85 9e fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+10]
  0278d	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  02792	7d 28		 jge	 SHORT $LN6@JGPGetChar

; 1276 : 			{
; 1277 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[21])) << 15;

  02794	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  02797	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  0279b	c1 f9 03	 sar	 ecx, 3
  0279e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  027a1	51		 push	 ecx
  027a2	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  027a7	83 c4 04	 add	 esp, 4
  027aa	0f b6 d0	 movzx	 edx, al
  027ad	c1 e2 0f	 shl	 edx, 15			; 0000000fH
  027b0	0b 95 7c fe ff
	ff		 or	 edx, DWORD PTR _levelindex$245428[ebp]
  027b6	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN6@JGPGetChar:

; 1278 : 			}
; 1279 : 			if ( TempInventory[6] < 0x1FF )

  027bc	0f b7 85 a0 fe
	ff ff		 movzx	 eax, WORD PTR _TempInventory$[ebp+12]
  027c3	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  027c8	7d 28		 jge	 SHORT $LN5@JGPGetChar

; 1280 : 			{
; 1281 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[25])) << 18;

  027ca	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  027cd	0f b6 48 29	 movzx	 ecx, BYTE PTR [eax+41]
  027d1	c1 f9 03	 sar	 ecx, 3
  027d4	83 e1 0f	 and	 ecx, 15			; 0000000fH
  027d7	51		 push	 ecx
  027d8	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  027dd	83 c4 04	 add	 esp, 4
  027e0	0f b6 d0	 movzx	 edx, al
  027e3	c1 e2 12	 shl	 edx, 18			; 00000012H
  027e6	0b 95 7c fe ff
	ff		 or	 edx, DWORD PTR _levelindex$245428[ebp]
  027ec	89 95 7c fe ff
	ff		 mov	 DWORD PTR _levelindex$245428[ebp], edx
$LN5@JGPGetChar:

; 1282 : 			}
; 1283 : 
; 1284 : 			pCList.CharSet[6] = ((int)levelindex >> 0x10) & 0xFF;

  027f2	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$245428[ebp]
  027f8	c1 f8 10	 sar	 eax, 16			; 00000010H
  027fb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02800	88 85 c1 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+21], al

; 1285 : 			pCList.CharSet[7] = ((int)levelindex >> 0x08) & 0xFF;

  02806	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$245428[ebp]
  0280c	c1 f8 08	 sar	 eax, 8
  0280f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02814	88 85 c2 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+22], al

; 1286 : 			pCList.CharSet[8] = ((int)levelindex) & 0xFF;

  0281a	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$245428[ebp]
  02820	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02825	88 85 c3 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+23], al

; 1287 : 
; 1288 : 			memcpy(&sendbuf[lOfs], &pCList, sizeof(pCList));

  0282b	6a 22		 push	 34			; 00000022H
  0282d	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _pCList$[ebp]
  02833	50		 push	 eax
  02834	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  0283a	8d 94 0d e8 fe
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  02841	52		 push	 edx
  02842	e8 00 00 00 00	 call	 _memcpy
  02847	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1289 : 			lsOfs += sizeof(SDHP_CHARLIST);

  0284a	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$[ebp]
  02850	83 c0 42	 add	 eax, 66			; 00000042H
  02853	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _lsOfs$[ebp], eax

; 1290 : 			lOfs += sizeof(pCList);

  02859	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0285f	83 c0 22	 add	 eax, 34			; 00000022H
  02862	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 1291 : 		}

  02868	e9 e8 ed ff ff	 jmp	 $LN82@JGPGetChar
$LN84@JGPGetChar:

; 1292 : 		// ----
; 1293 : 	}
; 1294 : 
; 1295 : #ifdef CHARCREATE_TEMP
; 1296 : 		if( HightLevel >= ExConfig.ExCustom.CreateSUMLevel )  //gCreateSUMLevel

  0286d	0f bf 05 12 00
	00 00		 movsx	 eax, WORD PTR ?ExConfig@@3VcExConfigs@@A+18
  02874	39 85 8c fe ff
	ff		 cmp	 DWORD PTR _HightLevel$[ebp], eax
  0287a	7c 10		 jl	 SHORT $LN4@JGPGetChar

; 1297 : 		{
; 1298 : 			GenerableClass += 1;

  0287c	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _GenerableClass$[ebp]
  02883	83 c0 01	 add	 eax, 1
  02886	88 85 8b fe ff
	ff		 mov	 BYTE PTR _GenerableClass$[ebp], al
$LN4@JGPGetChar:

; 1299 : 		}
; 1300 : 		// ----
; 1301 : 		if( HightLevel >= ExConfig.ExCustom.CreateMONKLevel ) //gCreateMONKLevel

  0288c	0f bf 05 14 00
	00 00		 movsx	 eax, WORD PTR ?ExConfig@@3VcExConfigs@@A+20
  02893	39 85 8c fe ff
	ff		 cmp	 DWORD PTR _HightLevel$[ebp], eax
  02899	7c 10		 jl	 SHORT $LN3@JGPGetChar

; 1302 : 		{
; 1303 : 			GenerableClass += 8;

  0289b	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _GenerableClass$[ebp]
  028a2	83 c0 08	 add	 eax, 8
  028a5	88 85 8b fe ff
	ff		 mov	 BYTE PTR _GenerableClass$[ebp], al
$LN3@JGPGetChar:

; 1304 : 		}
; 1305 : 		// ----
; 1306 : 		if( HightLevel >= ExConfig.ExCustom.CreateMGLevel )	  //gCreateMGLevel

  028ab	0f bf 05 0e 00
	00 00		 movsx	 eax, WORD PTR ?ExConfig@@3VcExConfigs@@A+14
  028b2	39 85 8c fe ff
	ff		 cmp	 DWORD PTR _HightLevel$[ebp], eax
  028b8	7c 27		 jl	 SHORT $LN2@JGPGetChar

; 1307 : 		{
; 1308 : 			GenerableClass += 4;

  028ba	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _GenerableClass$[ebp]
  028c1	83 c0 04	 add	 eax, 4
  028c4	88 85 8b fe ff
	ff		 mov	 BYTE PTR _GenerableClass$[ebp], al

; 1309 : 			gObj[aIndex].Magumsa = 1;

  028ca	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  028d0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  028d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028dc	c6 44 01 34 01	 mov	 BYTE PTR [ecx+eax+52], 1
$LN2@JGPGetChar:

; 1310 : 		}
; 1311 : 		// ----
; 1312 : 		if( HightLevel >= ExConfig.ExCustom.CreateDLLevel )	  //gCreateDLLevel

  028e1	0f bf 05 10 00
	00 00		 movsx	 eax, WORD PTR ?ExConfig@@3VcExConfigs@@A+16
  028e8	39 85 8c fe ff
	ff		 cmp	 DWORD PTR _HightLevel$[ebp], eax
  028ee	7c 27		 jl	 SHORT $LN1@JGPGetChar

; 1313 : 		{
; 1314 : 			GenerableClass += 2;

  028f0	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _GenerableClass$[ebp]
  028f7	83 c0 02	 add	 eax, 2
  028fa	88 85 8b fe ff
	ff		 mov	 BYTE PTR _GenerableClass$[ebp], al

; 1315 : 			gObj[aIndex].Magumsa = 2;

  02900	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  02906	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0290c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02912	c6 44 01 34 02	 mov	 BYTE PTR [ecx+eax+52], 2
$LN1@JGPGetChar:

; 1316 : 		}
; 1317 : 		// ----
; 1318 : 		PMSG_UPD_SUMMONER_CREATE pMsg;
; 1319 : 		pMsg.h.set((LPBYTE)&pMsg, 0xDE, sizeof(pMsg));

  02917	6a 05		 push	 5
  02919	68 de 00 00 00	 push	 222			; 000000deH
  0291e	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  02924	50		 push	 eax
  02925	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0292b	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 1320 : 		pMsg.btResult = 0;

  02930	c6 85 77 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1321 : 		pMsg.IsSummonerEnable = GenerableClass;

  02937	8a 85 8b fe ff
	ff		 mov	 al, BYTE PTR _GenerableClass$[ebp]
  0293d	88 85 78 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al

; 1322 : 		// ----
; 1323 : 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  02943	6a 05		 push	 5
  02945	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0294b	50		 push	 eax
  0294c	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  02952	51		 push	 ecx
  02953	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02958	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1324 : #endif
; 1325 : 
; 1326 : 	pCLCount.h.size = lOfs;

  0295b	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  02961	88 85 d1 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+1], al

; 1327 : 	memcpy(sendbuf, &pCLCount, sizeof(PMSG_CHARLISTCOUNT));	

  02967	6a 08		 push	 8
  02969	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _pCLCount$[ebp]
  0296f	50		 push	 eax
  02970	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  02976	51		 push	 ecx
  02977	e8 00 00 00 00	 call	 _memcpy
  0297c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1328 : 
; 1329 : 	DataSend(aIndex, sendbuf, lOfs);

  0297f	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  02985	50		 push	 eax
  02986	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  0298c	51		 push	 ecx
  0298d	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$[ebp]
  02993	52		 push	 edx
  02994	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02999	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN86@JGPGetChar:

; 1330 : 
; 1331 : 	//g_ExUser.GCDataClient(aIndex);
; 1332 : #if(SYSTEM_ACHIEVEMENTS)
; 1333 : 	//g_Achievements.GCSettingsData(aIndex);
; 1334 : #endif
; 1335 : }

  0299c	5f		 pop	 edi
  0299d	5e		 pop	 esi
  0299e	5b		 pop	 ebx
  0299f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  029a2	33 cd		 xor	 ecx, ebp
  029a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  029a9	8b e5		 mov	 esp, ebp
  029ab	5d		 pop	 ebp
  029ac	c3		 ret	 0
  029ad	8d 49 00	 npad	 3
$LN110@JGPGetChar:
  029b0	00 00 00 00	 DD	 $LN56@JGPGetChar
  029b4	00 00 00 00	 DD	 $LN55@JGPGetChar
  029b8	00 00 00 00	 DD	 $LN54@JGPGetChar
  029bc	00 00 00 00	 DD	 $LN52@JGPGetChar
  029c0	00 00 00 00	 DD	 $LN51@JGPGetChar
  029c4	00 00 00 00	 DD	 $LN50@JGPGetChar
  029c8	00 00 00 00	 DD	 $LN49@JGPGetChar
  029cc	00 00 00 00	 DD	 $LN48@JGPGetChar
  029d0	00 00 00 00	 DD	 $LN45@JGPGetChar
  029d4	00 00 00 00	 DD	 $LN44@JGPGetChar
  029d8	00 00 00 00	 DD	 $LN43@JGPGetChar
  029dc	00 00 00 00	 DD	 $LN42@JGPGetChar
  029e0	00 00 00 00	 DD	 $LN41@JGPGetChar
  029e4	00 00 00 00	 DD	 $LN53@JGPGetChar
  029e8	00 00 00 00	 DD	 $LN47@JGPGetChar
  029ec	00 00 00 00	 DD	 $LN40@JGPGetChar
  029f0	00 00 00 00	 DD	 $LN46@JGPGetChar
  029f4	00 00 00 00	 DD	 $LN39@JGPGetChar
  029f8	00 00 00 00	 DD	 $LN38@JGPGetChar
  029fc	00 00 00 00	 DD	 $LN37@JGPGetChar
  02a00	00 00 00 00	 DD	 $LN36@JGPGetChar
  02a04	00 00 00 00	 DD	 $LN35@JGPGetChar
  02a08	00 00 00 00	 DD	 $LN34@JGPGetChar
  02a0c	00 00 00 00	 DD	 $LN33@JGPGetChar
  02a10	00 00 00 00	 DD	 $LN58@JGPGetChar
$LN99@JGPGetChar:
  02a14	00		 DB	 0
  02a15	01		 DB	 1
  02a16	02		 DB	 2
  02a17	03		 DB	 3
  02a18	04		 DB	 4
  02a19	05		 DB	 5
  02a1a	06		 DB	 6
  02a1b	18		 DB	 24			; 00000018H
  02a1c	18		 DB	 24			; 00000018H
  02a1d	18		 DB	 24			; 00000018H
  02a1e	18		 DB	 24			; 00000018H
  02a1f	18		 DB	 24			; 00000018H
  02a20	18		 DB	 24			; 00000018H
  02a21	18		 DB	 24			; 00000018H
  02a22	18		 DB	 24			; 00000018H
  02a23	18		 DB	 24			; 00000018H
  02a24	18		 DB	 24			; 00000018H
  02a25	18		 DB	 24			; 00000018H
  02a26	18		 DB	 24			; 00000018H
  02a27	18		 DB	 24			; 00000018H
  02a28	18		 DB	 24			; 00000018H
  02a29	18		 DB	 24			; 00000018H
  02a2a	18		 DB	 24			; 00000018H
  02a2b	18		 DB	 24			; 00000018H
  02a2c	18		 DB	 24			; 00000018H
  02a2d	18		 DB	 24			; 00000018H
  02a2e	18		 DB	 24			; 00000018H
  02a2f	18		 DB	 24			; 00000018H
  02a30	18		 DB	 24			; 00000018H
  02a31	18		 DB	 24			; 00000018H
  02a32	07		 DB	 7
  02a33	18		 DB	 24			; 00000018H
  02a34	18		 DB	 24			; 00000018H
  02a35	18		 DB	 24			; 00000018H
  02a36	18		 DB	 24			; 00000018H
  02a37	18		 DB	 24			; 00000018H
  02a38	08		 DB	 8
  02a39	09		 DB	 9
  02a3a	0a		 DB	 10			; 0000000aH
  02a3b	0b		 DB	 11			; 0000000bH
  02a3c	0c		 DB	 12			; 0000000cH
  02a3d	0d		 DB	 13			; 0000000dH
  02a3e	0e		 DB	 14			; 0000000eH
  02a3f	0f		 DB	 15			; 0000000fH
  02a40	18		 DB	 24			; 00000018H
  02a41	18		 DB	 24			; 00000018H
  02a42	18		 DB	 24			; 00000018H
  02a43	18		 DB	 24			; 00000018H
  02a44	18		 DB	 24			; 00000018H
  02a45	10		 DB	 16			; 00000010H
  02a46	11		 DB	 17			; 00000011H
  02a47	18		 DB	 24			; 00000018H
  02a48	18		 DB	 24			; 00000018H
  02a49	18		 DB	 24			; 00000018H
  02a4a	18		 DB	 24			; 00000018H
  02a4b	18		 DB	 24			; 00000018H
  02a4c	18		 DB	 24			; 00000018H
  02a4d	18		 DB	 24			; 00000018H
  02a4e	18		 DB	 24			; 00000018H
  02a4f	18		 DB	 24			; 00000018H
  02a50	18		 DB	 24			; 00000018H
  02a51	18		 DB	 24			; 00000018H
  02a52	18		 DB	 24			; 00000018H
  02a53	18		 DB	 24			; 00000018H
  02a54	18		 DB	 24			; 00000018H
  02a55	18		 DB	 24			; 00000018H
  02a56	18		 DB	 24			; 00000018H
  02a57	18		 DB	 24			; 00000018H
  02a58	18		 DB	 24			; 00000018H
  02a59	18		 DB	 24			; 00000018H
  02a5a	18		 DB	 24			; 00000018H
  02a5b	18		 DB	 24			; 00000018H
  02a5c	18		 DB	 24			; 00000018H
  02a5d	18		 DB	 24			; 00000018H
  02a5e	18		 DB	 24			; 00000018H
  02a5f	18		 DB	 24			; 00000018H
  02a60	18		 DB	 24			; 00000018H
  02a61	18		 DB	 24			; 00000018H
  02a62	18		 DB	 24			; 00000018H
  02a63	18		 DB	 24			; 00000018H
  02a64	18		 DB	 24			; 00000018H
  02a65	18		 DB	 24			; 00000018H
  02a66	18		 DB	 24			; 00000018H
  02a67	18		 DB	 24			; 00000018H
  02a68	18		 DB	 24			; 00000018H
  02a69	18		 DB	 24			; 00000018H
  02a6a	18		 DB	 24			; 00000018H
  02a6b	18		 DB	 24			; 00000018H
  02a6c	18		 DB	 24			; 00000018H
  02a6d	18		 DB	 24			; 00000018H
  02a6e	18		 DB	 24			; 00000018H
  02a6f	18		 DB	 24			; 00000018H
  02a70	18		 DB	 24			; 00000018H
  02a71	18		 DB	 24			; 00000018H
  02a72	18		 DB	 24			; 00000018H
  02a73	18		 DB	 24			; 00000018H
  02a74	18		 DB	 24			; 00000018H
  02a75	18		 DB	 24			; 00000018H
  02a76	18		 DB	 24			; 00000018H
  02a77	18		 DB	 24			; 00000018H
  02a78	18		 DB	 24			; 00000018H
  02a79	18		 DB	 24			; 00000018H
  02a7a	18		 DB	 24			; 00000018H
  02a7b	18		 DB	 24			; 00000018H
  02a7c	18		 DB	 24			; 00000018H
  02a7d	18		 DB	 24			; 00000018H
  02a7e	18		 DB	 24			; 00000018H
  02a7f	18		 DB	 24			; 00000018H
  02a80	18		 DB	 24			; 00000018H
  02a81	18		 DB	 24			; 00000018H
  02a82	18		 DB	 24			; 00000018H
  02a83	18		 DB	 24			; 00000018H
  02a84	18		 DB	 24			; 00000018H
  02a85	18		 DB	 24			; 00000018H
  02a86	18		 DB	 24			; 00000018H
  02a87	18		 DB	 24			; 00000018H
  02a88	18		 DB	 24			; 00000018H
  02a89	18		 DB	 24			; 00000018H
  02a8a	18		 DB	 24			; 00000018H
  02a8b	18		 DB	 24			; 00000018H
  02a8c	18		 DB	 24			; 00000018H
  02a8d	18		 DB	 24			; 00000018H
  02a8e	18		 DB	 24			; 00000018H
  02a8f	18		 DB	 24			; 00000018H
  02a90	18		 DB	 24			; 00000018H
  02a91	18		 DB	 24			; 00000018H
  02a92	18		 DB	 24			; 00000018H
  02a93	18		 DB	 24			; 00000018H
  02a94	18		 DB	 24			; 00000018H
  02a95	18		 DB	 24			; 00000018H
  02a96	12		 DB	 18			; 00000012H
  02a97	13		 DB	 19			; 00000013H
  02a98	14		 DB	 20			; 00000014H
  02a99	15		 DB	 21			; 00000015H
  02a9a	16		 DB	 22			; 00000016H
  02a9b	17		 DB	 23			; 00000017H
$LN111@JGPGetChar:
  02a9c	00 00 00 00	 DD	 $LN24@JGPGetChar
  02aa0	00 00 00 00	 DD	 $LN25@JGPGetChar
  02aa4	00 00 00 00	 DD	 $LN17@JGPGetChar
  02aa8	00 00 00 00	 DD	 $LN20@JGPGetChar
  02aac	00 00 00 00	 DD	 $LN19@JGPGetChar
  02ab0	00 00 00 00	 DD	 $LN13@JGPGetChar
$LN100@JGPGetChar:
  02ab4	00		 DB	 0
  02ab5	01		 DB	 1
  02ab6	05		 DB	 5
  02ab7	05		 DB	 5
  02ab8	05		 DB	 5
  02ab9	05		 DB	 5
  02aba	05		 DB	 5
  02abb	05		 DB	 5
  02abc	05		 DB	 5
  02abd	05		 DB	 5
  02abe	05		 DB	 5
  02abf	05		 DB	 5
  02ac0	05		 DB	 5
  02ac1	05		 DB	 5
  02ac2	05		 DB	 5
  02ac3	05		 DB	 5
  02ac4	05		 DB	 5
  02ac5	05		 DB	 5
  02ac6	05		 DB	 5
  02ac7	05		 DB	 5
  02ac8	05		 DB	 5
  02ac9	05		 DB	 5
  02aca	05		 DB	 5
  02acb	05		 DB	 5
  02acc	05		 DB	 5
  02acd	05		 DB	 5
  02ace	05		 DB	 5
  02acf	05		 DB	 5
  02ad0	05		 DB	 5
  02ad1	05		 DB	 5
  02ad2	05		 DB	 5
  02ad3	05		 DB	 5
  02ad4	05		 DB	 5
  02ad5	05		 DB	 5
  02ad6	02		 DB	 2
  02ad7	05		 DB	 5
  02ad8	05		 DB	 5
  02ad9	05		 DB	 5
  02ada	05		 DB	 5
  02adb	05		 DB	 5
  02adc	05		 DB	 5
  02add	05		 DB	 5
  02ade	05		 DB	 5
  02adf	05		 DB	 5
  02ae0	05		 DB	 5
  02ae1	05		 DB	 5
  02ae2	05		 DB	 5
  02ae3	05		 DB	 5
  02ae4	05		 DB	 5
  02ae5	05		 DB	 5
  02ae6	05		 DB	 5
  02ae7	05		 DB	 5
  02ae8	05		 DB	 5
  02ae9	05		 DB	 5
  02aea	05		 DB	 5
  02aeb	05		 DB	 5
  02aec	05		 DB	 5
  02aed	05		 DB	 5
  02aee	05		 DB	 5
  02aef	05		 DB	 5
  02af0	05		 DB	 5
  02af1	03		 DB	 3
  02af2	04		 DB	 4
?JGPGetCharList@@YAXPAE@Z ENDP				; JGPGetCharList
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 80   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 82   : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 83   : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 84   : 	};	// line : 22

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
PUBLIC	??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
PUBLIC	?__LINE__Var@?1??DataServerGetCharListRequest@@YAXF@Z@4JA ; `DataServerGetCharListRequest'::`2'::__LINE__Var
PUBLIC	__$ArrayPad$
PUBLIC	?DataServerGetCharListRequest@@YAXF@Z		; DataServerGetCharListRequest
EXTRN	_strlen:PROC
EXTRN	?gObjGetAccountId@@YAPADH@Z:PROC		; gObjGetAccountId
EXTRN	?GCLicenseUser@CExLicense@@QAEXH@Z:PROC		; CExLicense::GCLicenseUser
;	COMDAT ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DataServerGetCharListRequest@@YAXF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DataServerGetCharListRequest@@YAXF@Z@4JA DD 0542H ; `DataServerGetCharListRequest'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
_AccountId$ = -36					; size = 4
_TempId$ = -32						; size = 11
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?DataServerGetCharListRequest@@YAXF@Z PROC		; DataServerGetCharListRequest

; 1346 : {

  02b00	55		 push	 ebp
  02b01	8b ec		 mov	 ebp, esp
  02b03	83 ec 64	 sub	 esp, 100		; 00000064H
  02b06	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02b0b	33 c5		 xor	 eax, ebp
  02b0d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02b10	53		 push	 ebx
  02b11	56		 push	 esi
  02b12	57		 push	 edi

; 1347 : 	g_ExLicense.GCLicenseUser(aIndex);

  02b13	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  02b17	50		 push	 eax
  02b18	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  02b1d	e8 00 00 00 00	 call	 ?GCLicenseUser@CExLicense@@QAEXH@Z ; CExLicense::GCLicenseUser

; 1348 : 
; 1349 : 	SDHP_GETCHARLIST pMsg;
; 1350 : 	char TempId[11];
; 1351 : 	char* AccountId;
; 1352 : 
; 1353 : 	memset(TempId, 0, sizeof(TempId));

  02b22	6a 0b		 push	 11			; 0000000bH
  02b24	6a 00		 push	 0
  02b26	8d 45 e0	 lea	 eax, DWORD PTR _TempId$[ebp]
  02b29	50		 push	 eax
  02b2a	e8 00 00 00 00	 call	 _memset
  02b2f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1354 : 	AccountId = gObjGetAccountId(aIndex);

  02b32	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  02b36	50		 push	 eax
  02b37	e8 00 00 00 00	 call	 ?gObjGetAccountId@@YAPADH@Z ; gObjGetAccountId
  02b3c	83 c4 04	 add	 esp, 4
  02b3f	89 45 dc	 mov	 DWORD PTR _AccountId$[ebp], eax

; 1355 : 
; 1356 : 	if ( AccountId == 0 )

  02b42	83 7d dc 00	 cmp	 DWORD PTR _AccountId$[ebp], 0
  02b46	75 39		 jne	 SHORT $LN2@DataServer@3

; 1357 : 	{
; 1358 : 		LogAdd(lMsg.Get(MSGGET(1, 166)), __FILE__, __LINE__);

  02b48	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DataServerGetCharListRequest@@YAXF@Z@4JA
  02b4d	83 c0 0c	 add	 eax, 12			; 0000000cH
  02b50	50		 push	 eax
  02b51	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
  02b56	68 a6 01 00 00	 push	 422			; 000001a6H
  02b5b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02b60	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02b65	50		 push	 eax
  02b66	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  02b6c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1359 : 		CloseClient(aIndex);

  02b6f	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  02b73	50		 push	 eax
  02b74	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02b79	83 c4 04	 add	 esp, 4

; 1360 : 		return;

  02b7c	e9 90 00 00 00	 jmp	 $LN3@DataServer@3
$LN2@DataServer@3:

; 1361 : 	}
; 1362 : 
; 1363 : 	// When Len is Less than 1
; 1364 : 	if ( strlen(AccountId) < 1 )

  02b81	8b 45 dc	 mov	 eax, DWORD PTR _AccountId$[ebp]
  02b84	50		 push	 eax
  02b85	e8 00 00 00 00	 call	 _strlen
  02b8a	83 c4 04	 add	 esp, 4
  02b8d	83 f8 01	 cmp	 eax, 1
  02b90	73 36		 jae	 SHORT $LN1@DataServer@3

; 1365 : 	{
; 1366 : 		// Error Message
; 1367 : 		//
; 1368 : 		LogAdd(lMsg.Get(MSGGET(1, 167)), __FILE__, __LINE__);

  02b92	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DataServerGetCharListRequest@@YAXF@Z@4JA
  02b97	83 c0 16	 add	 eax, 22			; 00000016H
  02b9a	50		 push	 eax
  02b9b	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
  02ba0	68 a7 01 00 00	 push	 423			; 000001a7H
  02ba5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02baa	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02baf	50		 push	 eax
  02bb0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  02bb6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1369 : 		CloseClient(aIndex);

  02bb9	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  02bbd	50		 push	 eax
  02bbe	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02bc3	83 c4 04	 add	 esp, 4

; 1370 : 		return;

  02bc6	eb 49		 jmp	 SHORT $LN3@DataServer@3
$LN1@DataServer@3:

; 1371 : 	}
; 1372 : 
; 1373 : 	strcpy((char*)TempId, AccountId);

  02bc8	8b 45 dc	 mov	 eax, DWORD PTR _AccountId$[ebp]
  02bcb	50		 push	 eax
  02bcc	8d 4d e0	 lea	 ecx, DWORD PTR _TempId$[ebp]
  02bcf	51		 push	 ecx
  02bd0	e8 00 00 00 00	 call	 _strcpy
  02bd5	83 c4 08	 add	 esp, 8

; 1374 : 
; 1375 : 	pMsg.h.c  = 0xC1;

  02bd8	c6 45 ec c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 1376 : 	pMsg.h.size  = sizeof(SDHP_GETCHARLIST);

  02bdc	c6 45 ed 10	 mov	 BYTE PTR _pMsg$[ebp+1], 16 ; 00000010H

; 1377 : 	pMsg.h.headcode = 0x01;

  02be0	c6 45 ee 01	 mov	 BYTE PTR _pMsg$[ebp+2], 1

; 1378 : 	pMsg.Number = aIndex;

  02be4	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  02be8	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 1379 : 	memcpy(pMsg.Id , TempId, sizeof(TempId)-1);

  02bec	6a 0a		 push	 10			; 0000000aH
  02bee	8d 45 e0	 lea	 eax, DWORD PTR _TempId$[ebp]
  02bf1	50		 push	 eax
  02bf2	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  02bf5	51		 push	 ecx
  02bf6	e8 00 00 00 00	 call	 _memcpy
  02bfb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1380 : 
; 1381 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  02bfe	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02c02	50		 push	 eax
  02c03	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02c06	51		 push	 ecx
  02c07	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  02c0c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@DataServer@3:

; 1382 : 	
; 1383 : }

  02c11	5f		 pop	 edi
  02c12	5e		 pop	 esi
  02c13	5b		 pop	 ebx
  02c14	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02c17	33 cd		 xor	 ecx, ebp
  02c19	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02c1e	8b e5		 mov	 esp, ebp
  02c20	5d		 pop	 ebp
  02c21	c3		 ret	 0
?DataServerGetCharListRequest@@YAXF@Z ENDP		; DataServerGetCharListRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_changeup$ = -68					; size = 4
_aIndex$ = -64						; size = 4
_szAccountID$ = -60					; size = 11
_pResult$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z PROC ; JGCharacterCreateRequest

; 1399 : {

  02c30	55		 push	 ebp
  02c31	8b ec		 mov	 ebp, esp
  02c33	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  02c39	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02c3e	33 c5		 xor	 eax, ebp
  02c40	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02c43	53		 push	 ebx
  02c44	56		 push	 esi
  02c45	57		 push	 edi

; 1400 : 	PMSG_CHARCREATERESULT pResult;
; 1401 : 	char szAccountID[MAX_ACCOUNT_LEN+1];
; 1402 : 	int aIndex = lpMsg->Number;

  02c46	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02c49	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  02c4d	89 4d c0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1403 : 
; 1404 : 	szAccountID[MAX_ACCOUNT_LEN] = 0;

  02c50	c6 45 ce 00	 mov	 BYTE PTR _szAccountID$[ebp+10], 0

; 1405 : 	memcpy(szAccountID, lpMsg->AccountId, sizeof(lpMsg->AccountId));

  02c54	6a 0a		 push	 10			; 0000000aH
  02c56	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02c59	83 c0 06	 add	 eax, 6
  02c5c	50		 push	 eax
  02c5d	8d 4d c4	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  02c60	51		 push	 ecx
  02c61	e8 00 00 00 00	 call	 _memcpy
  02c66	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1406 : 
; 1407 : 	if ( gObjIsAccontConnect(aIndex, szAccountID) == FALSE )

  02c69	8d 45 c4	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  02c6c	50		 push	 eax
  02c6d	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  02c70	51		 push	 ecx
  02c71	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  02c76	83 c4 08	 add	 esp, 8
  02c79	85 c0		 test	 eax, eax
  02c7b	75 30		 jne	 SHORT $LN2@JGCharacte

; 1408 : 	{
; 1409 : 		LogAddC(2, lMsg.Get(MSGGET(1, 168)), szAccountID);

  02c7d	8d 45 c4	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  02c80	50		 push	 eax
  02c81	68 a8 01 00 00	 push	 424			; 000001a8H
  02c86	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02c8b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02c90	50		 push	 eax
  02c91	6a 02		 push	 2
  02c93	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  02c99	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1410 : 		CloseClient(aIndex);

  02c9c	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02c9f	50		 push	 eax
  02ca0	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02ca5	83 c4 04	 add	 esp, 4

; 1411 : 		return;

  02ca8	e9 bc 00 00 00	 jmp	 $LN3@JGCharacte
$LN2@JGCharacte:

; 1412 : 	}
; 1413 : 
; 1414 : 	pResult.h.c = 0xC1;

  02cad	c6 45 d0 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 1415 : 	pResult.h.size = sizeof(PMSG_CHARCREATERESULT);

  02cb1	c6 45 d1 2c	 mov	 BYTE PTR _pResult$[ebp+1], 44 ; 0000002cH

; 1416 : 	pResult.h.headcode = 0xF3;

  02cb5	c6 45 d2 f3	 mov	 BYTE PTR _pResult$[ebp+2], 243 ; 000000f3H

; 1417 : 	pResult.subcode = 0x01;

  02cb9	c6 45 d3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 1418 : 	pResult.Result = lpMsg->Result;

  02cbd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02cc0	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  02cc3	88 4d d4	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 1419 : 	pResult.pos = lpMsg->Pos;

  02cc6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02cc9	8a 48 1a	 mov	 cl, BYTE PTR [eax+26]
  02ccc	88 4d df	 mov	 BYTE PTR _pResult$[ebp+15], cl

; 1420 : 	pResult.Class = (lpMsg->ClassSkin >> 4 << 5) & 0xE0;

  02ccf	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02cd2	0f b6 48 1b	 movzx	 ecx, BYTE PTR [eax+27]
  02cd6	c1 f9 04	 sar	 ecx, 4
  02cd9	c1 e1 05	 shl	 ecx, 5
  02cdc	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  02ce2	88 4d e2	 mov	 BYTE PTR _pResult$[ebp+18], cl

; 1421 : 	int changeup = lpMsg->ClassSkin & 0x07; 

  02ce5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02ce8	0f b6 48 1b	 movzx	 ecx, BYTE PTR [eax+27]
  02cec	83 e1 07	 and	 ecx, 7
  02cef	89 4d bc	 mov	 DWORD PTR _changeup$[ebp], ecx

; 1422 : 	pResult.Class |= (changeup << 4) & 0x10;

  02cf2	8b 45 bc	 mov	 eax, DWORD PTR _changeup$[ebp]
  02cf5	c1 e0 04	 shl	 eax, 4
  02cf8	83 e0 10	 and	 eax, 16			; 00000010H
  02cfb	0f b6 4d e2	 movzx	 ecx, BYTE PTR _pResult$[ebp+18]
  02cff	0b c8		 or	 ecx, eax
  02d01	88 4d e2	 mov	 BYTE PTR _pResult$[ebp+18], cl

; 1423 : 	pResult.Class |= (changeup << 4) & 0x20; //Season 2.5 add-on

  02d04	8b 45 bc	 mov	 eax, DWORD PTR _changeup$[ebp]
  02d07	c1 e0 04	 shl	 eax, 4
  02d0a	83 e0 20	 and	 eax, 32			; 00000020H
  02d0d	0f b6 4d e2	 movzx	 ecx, BYTE PTR _pResult$[ebp+18]
  02d11	0b c8		 or	 ecx, eax
  02d13	88 4d e2	 mov	 BYTE PTR _pResult$[ebp+18], cl

; 1424 : 	pResult.Level = lpMsg->Level;

  02d16	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02d19	66 8b 48 34	 mov	 cx, WORD PTR [eax+52]
  02d1d	66 89 4d e0	 mov	 WORD PTR _pResult$[ebp+16], cx

; 1425 : 	memcpy(pResult.Name, lpMsg->Name, sizeof(pResult.Name));

  02d21	6a 0a		 push	 10			; 0000000aH
  02d23	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02d26	83 c0 10	 add	 eax, 16			; 00000010H
  02d29	50		 push	 eax
  02d2a	8d 4d d5	 lea	 ecx, DWORD PTR _pResult$[ebp+5]
  02d2d	51		 push	 ecx
  02d2e	e8 00 00 00 00	 call	 _memcpy
  02d33	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1426 : 
; 1427 : 	if ( pResult.Result == 1 )

  02d36	0f b6 45 d4	 movzx	 eax, BYTE PTR _pResult$[ebp+4]
  02d3a	83 f8 01	 cmp	 eax, 1
  02d3d	75 15		 jne	 SHORT $LN1@JGCharacte

; 1428 : 	{
; 1429 : 		memcpy(pResult.Equipment, lpMsg->Equipment, sizeof(pResult.Equipment));

  02d3f	6a 18		 push	 24			; 00000018H
  02d41	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02d44	83 c0 1c	 add	 eax, 28			; 0000001cH
  02d47	50		 push	 eax
  02d48	8d 4d e3	 lea	 ecx, DWORD PTR _pResult$[ebp+19]
  02d4b	51		 push	 ecx
  02d4c	e8 00 00 00 00	 call	 _memcpy
  02d51	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@JGCharacte:

; 1430 : 	}
; 1431 : 
; 1432 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  02d54	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  02d58	50		 push	 eax
  02d59	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  02d5c	51		 push	 ecx
  02d5d	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02d60	52		 push	 edx
  02d61	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02d66	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@JGCharacte:

; 1433 : }

  02d69	5f		 pop	 edi
  02d6a	5e		 pop	 esi
  02d6b	5b		 pop	 ebx
  02d6c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02d6f	33 cd		 xor	 ecx, ebp
  02d71	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02d76	8b e5		 mov	 esp, ebp
  02d78	5d		 pop	 ebp
  02d79	c3		 ret	 0
?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ENDP ; JGCharacterCreateRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?JGCharacterCreateFailSend@@YAXHPAD@Z		; JGCharacterCreateFailSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pResult$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_id$ = 12						; size = 4
?JGCharacterCreateFailSend@@YAXHPAD@Z PROC		; JGCharacterCreateFailSend

; 1437 : {

  02d80	55		 push	 ebp
  02d81	8b ec		 mov	 ebp, esp
  02d83	83 ec 70	 sub	 esp, 112		; 00000070H
  02d86	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02d8b	33 c5		 xor	 eax, ebp
  02d8d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02d90	53		 push	 ebx
  02d91	56		 push	 esi
  02d92	57		 push	 edi

; 1438 : 	PMSG_CHARCREATERESULT  pResult;
; 1439 : 
; 1440 : 	pResult.h.c = 0xC1;

  02d93	c6 45 d0 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 1441 : 	pResult.h.size = sizeof (PMSG_CHARCREATERESULT);

  02d97	c6 45 d1 2c	 mov	 BYTE PTR _pResult$[ebp+1], 44 ; 0000002cH

; 1442 : 	pResult.h.headcode = 0xF3;

  02d9b	c6 45 d2 f3	 mov	 BYTE PTR _pResult$[ebp+2], 243 ; 000000f3H

; 1443 : 	pResult.subcode = 0x01;

  02d9f	c6 45 d3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 1444 : 	pResult.Result = false;

  02da3	c6 45 d4 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 1445 : 	pResult.pos = 0;

  02da7	c6 45 df 00	 mov	 BYTE PTR _pResult$[ebp+15], 0

; 1446 : 	memcpy(pResult.Name, id, sizeof(pResult.Name));

  02dab	6a 0a		 push	 10			; 0000000aH
  02dad	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  02db0	50		 push	 eax
  02db1	8d 4d d5	 lea	 ecx, DWORD PTR _pResult$[ebp+5]
  02db4	51		 push	 ecx
  02db5	e8 00 00 00 00	 call	 _memcpy
  02dba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1447 : 
; 1448 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  02dbd	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  02dc1	50		 push	 eax
  02dc2	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  02dc5	51		 push	 ecx
  02dc6	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02dc9	52		 push	 edx
  02dca	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02dcf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1449 : }

  02dd2	5f		 pop	 edi
  02dd3	5e		 pop	 esi
  02dd4	5b		 pop	 ebx
  02dd5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02dd8	33 cd		 xor	 ecx, ebp
  02dda	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02ddf	8b e5		 mov	 esp, ebp
  02de1	5d		 pop	 ebp
  02de2	c3		 ret	 0
?JGCharacterCreateFailSend@@YAXHPAD@Z ENDP		; JGCharacterCreateFailSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_aIndex$ = -28						; size = 4
_szAccountId$ = -24					; size = 11
_pResult$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z PROC	; JGCharDelRequest

; 1453 : {

  02df0	55		 push	 ebp
  02df1	8b ec		 mov	 ebp, esp
  02df3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  02df6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02dfb	33 c5		 xor	 eax, ebp
  02dfd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02e00	53		 push	 ebx
  02e01	56		 push	 esi
  02e02	57		 push	 edi

; 1454 : 	PMSG_RESULT pResult;
; 1455 : 	char szAccountId[MAX_ACCOUNT_LEN+1];
; 1456 : 	int aIndex = lpMsg->Number;

  02e03	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02e06	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  02e0a	89 4d e4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1457 : 	szAccountId[MAX_ACCOUNT_LEN] = 0;

  02e0d	c6 45 f2 00	 mov	 BYTE PTR _szAccountId$[ebp+10], 0

; 1458 : 	memcpy(szAccountId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  02e11	6a 0a		 push	 10			; 0000000aH
  02e13	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02e16	83 c0 06	 add	 eax, 6
  02e19	50		 push	 eax
  02e1a	8d 4d e8	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  02e1d	51		 push	 ecx
  02e1e	e8 00 00 00 00	 call	 _memcpy
  02e23	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1459 : 
; 1460 : 	if ( ::gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  02e26	8d 45 e8	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  02e29	50		 push	 eax
  02e2a	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  02e2d	51		 push	 ecx
  02e2e	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  02e33	83 c4 08	 add	 esp, 8
  02e36	85 c0		 test	 eax, eax
  02e38	75 2d		 jne	 SHORT $LN1@JGCharDelR

; 1461 : 	{
; 1462 : 		LogAddC(2, lMsg.Get(MSGGET(1, 169)), szAccountId);

  02e3a	8d 45 e8	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  02e3d	50		 push	 eax
  02e3e	68 a9 01 00 00	 push	 425			; 000001a9H
  02e43	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02e48	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02e4d	50		 push	 eax
  02e4e	6a 02		 push	 2
  02e50	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  02e56	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1463 : 		CloseClient(aIndex);

  02e59	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02e5c	50		 push	 eax
  02e5d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02e62	83 c4 04	 add	 esp, 4

; 1464 : 
; 1465 : 		return;

  02e65	eb 32		 jmp	 SHORT $LN2@JGCharDelR
$LN1@JGCharDelR:

; 1466 : 	}
; 1467 : 
; 1468 : 	pResult.h.c = 0xC1;

  02e67	c6 45 f4 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 1469 : 	pResult.h.size = sizeof(PMSG_RESULT);

  02e6b	c6 45 f5 05	 mov	 BYTE PTR _pResult$[ebp+1], 5

; 1470 : 	pResult.h.headcode = 0xF3;

  02e6f	c6 45 f6 f3	 mov	 BYTE PTR _pResult$[ebp+2], 243 ; 000000f3H

; 1471 : 	pResult.subcode = 0x02;

  02e73	c6 45 f7 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 1472 : 	pResult.result = lpMsg->Result;

  02e77	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02e7a	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  02e7d	88 4d f8	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 1473 : 
; 1474 : 	DataSend(lpMsg->Number, (UCHAR*)&pResult, pResult.h.size);

  02e80	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  02e84	50		 push	 eax
  02e85	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  02e88	51		 push	 ecx
  02e89	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  02e8c	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  02e90	50		 push	 eax
  02e91	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02e96	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@JGCharDelR:

; 1475 : }

  02e99	5f		 pop	 edi
  02e9a	5e		 pop	 esi
  02e9b	5b		 pop	 ebx
  02e9c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02e9f	33 cd		 xor	 ecx, ebp
  02ea1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02ea6	8b e5		 mov	 esp, ebp
  02ea8	5d		 pop	 ebp
  02ea9	c3		 ret	 0
?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ENDP	; JGCharDelRequest
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	?GCItemListSend@@YAXH@Z				; GCItemListSend
PUBLIC	??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@ ; `string'
PUBLIC	??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@ ; `string'
PUBLIC	??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ ; `string'
PUBLIC	??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@LIHKGJJG@?$DP?$DP?$DP?$DP?5ZEN?5MODIFY?5?$DP?$DP?$DP?$DP?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?1??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA ; `JGGetCharacterInfo'::`2'::__LINE__Var
PUBLIC	??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@ ; `string'
PUBLIC	??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?GCPlayerConnect@CDungeonSiege@@QAEXH@Z:PROC	; CDungeonSiege::GCPlayerConnect
EXTRN	?g_WaitOpen@@3_NA:BYTE				; g_WaitOpen
EXTRN	?SendClose@ConnectEx@@QAEXHH@Z:PROC		; ConnectEx::SendClose
EXTRN	?g_ConnectEx@@3VConnectEx@@A:QWORD		; g_ConnectEx
EXTRN	?CheckPremiumServer@PremiumSystem@@QAE_NH@Z:PROC ; PremiumSystem::CheckPremiumServer
EXTRN	?Premium@@3VPremiumSystem@@A:BYTE		; Premium
EXTRN	?UserConnect@PremiumSystemEx@@QAEXH@Z:PROC	; PremiumSystemEx::UserConnect
EXTRN	?g_PremiumSystemEx@@3VPremiumSystemEx@@A:BYTE	; g_PremiumSystemEx
EXTRN	?RestoreParty@PartyClass@@QAEXH@Z:PROC		; PartyClass::RestoreParty
EXTRN	?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; NewsBoard::OpenMain
EXTRN	?g_NewsBoard@@3VNewsBoard@@A:BYTE		; g_NewsBoard
EXTRN	?ConnectAdmin@GMManager@@QAEXH@Z:PROC		; GMManager::ConnectAdmin
EXTRN	?g_GMManager@@3VGMManager@@A:BYTE		; g_GMManager
EXTRN	?ExUserDataSend@@YAXH@Z:PROC			; ExUserDataSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?gWelcomeMessage@@3PADA:BYTE			; gWelcomeMessage
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?GCMapEventStateSend@@YAXHEE@Z:PROC		; GCMapEventStateSend
EXTRN	?gAppearTamaJJang@@3HA:DWORD			; gAppearTamaJJang
EXTRN	?gTamaJJangEvent@@3HA:DWORD			; gTamaJJangEvent
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?GDLoad@CMarriage@@QAEXH@Z:PROC			; CMarriage::GDLoad
EXTRN	?ReqMacro@MUHelper@@QAEXH@Z:PROC		; MUHelper::ReqMacro
EXTRN	?ReqQuestInfo@cWinQuestSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; cWinQuestSystem::ReqQuestInfo
EXTRN	?ReqExDBGensInfo@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::ReqExDBGensInfo
EXTRN	?DGGuildMemberInfoRequest@@YAXH@Z:PROC		; DGGuildMemberInfoRequest
EXTRN	?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestUtil::Quest3rdRequestInfo
EXTRN	?CGRequestQuestInfo@@YAXH@Z:PROC		; CGRequestQuestInfo
EXTRN	?GDReqMasterLevelInfo@CMasterLevelSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::GDReqMasterLevelInfo
EXTRN	?GDReqLuckyItemSelect@LuckyItemManager@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; LuckyItemManager::GDReqLuckyItemSelect
EXTRN	?RequestPeriodItemInfo@CPeriodItemEx@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CPeriodItemEx::RequestPeriodItemInfo
EXTRN	?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z:PROC ; GCMagicListMultiSend
EXTRN	?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestInfo::QuestInfoSave
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?gObjGetStatPointState@@YAXHAAF000@Z:PROC	; gObjGetStatPointState
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?GJReqMapSvrMove@@YAXHGGEE@Z:PROC		; GJReqMapSvrMove
EXTRN	?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z:PROC ; CMapServerManager::CheckMoveMapSvr
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?MapNumberCheck@@YAHH@Z:PROC			; MapNumberCheck
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
EXTRN	?gObjSetCharacter@@YAHPAEH@Z:PROC		; gObjSetCharacter
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	_strncmp:PROC
EXTRN	__fltused:DWORD
EXTRN	__allshr:PROC
;	COMDAT ??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@
CONST	SEGMENT
??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@ DB '[FRUIT'
	DB	' System] Character Stat Error [%s][%s] (MinusPoint:%d/PlusPoi'
	DB	'nt:%d) (MaxMinus:%d/MaxPlus:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@
CONST	SEGMENT
??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@ DB '['
	DB	'FRUIT System] [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus'
	DB	':%d/MaxPlus:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
CONST	SEGMENT
??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ DB '[MapSe'
	DB	'rverMng] Request to Move Map Server : (%d) - [%s][%s] (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
CONST	SEGMENT
??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ DB '[MapSe'
	DB	'rverMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s]['
	DB	'%s] (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LIHKGJJG@?$DP?$DP?$DP?$DP?5ZEN?5MODIFY?5?$DP?$DP?$DP?$DP?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd@
CONST	SEGMENT
??_C@_0CG@LIHKGJJG@?$DP?$DP?$DP?$DP?5ZEN?5MODIFY?5?$DP?$DP?$DP?$DP?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd@ DB '?'
	DB	'??? ZEN MODIFY ???? [%s][%s] %d -> 0', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA DD 060fH ; `JGGetCharacterInfo'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@
CONST	SEGMENT
??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@ DB '[A'
	DB	'nti-HACK][JGGetCharacterInfo] Attempted Character-Copy by dou'
	DB	'ble logging [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@
CONST	SEGMENT
??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@ DB 'error-L1 '
	DB	': Load Block Character infomation', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv1129 = -276						; size = 8
tv1119 = -276						; size = 8
tv1110 = -276						; size = 8
tv1100 = -276						; size = 8
tv1053 = -272						; size = 4
tv1043 = -272						; size = 4
tv1034 = -272						; size = 4
tv1024 = -272						; size = 4
tv1127 = -268						; size = 4
tv1117 = -268						; size = 4
tv1108 = -268						; size = 4
tv1098 = -268						; size = 4
tv1051 = -268						; size = 4
tv1041 = -268						; size = 4
tv1032 = -268						; size = 4
tv1022 = -268						; size = 4
tv1124 = -262						; size = 2
tv1114 = -262						; size = 2
tv1105 = -262						; size = 2
tv1095 = -262						; size = 2
tv1048 = -262						; size = 2
tv1038 = -262						; size = 2
tv1029 = -262						; size = 2
tv1019 = -262						; size = 2
_pResult$ = -196					; size = 5
_MaxMinusPoint$ = -188					; size = 2
_MinusPoint$ = -184					; size = 2
_MaxAddPoint$ = -180					; size = 2
_AddPoint$ = -176					; size = 2
_NextExperience$ = -172					; size = 8
_Experience$ = -164					; size = 8
_wGameServerCode$245677 = -156				; size = 2
_lpObj$ = -152						; size = 4
_i$245657 = -148					; size = 4
_aIndex$ = -144						; size = 4
_szName$ = -140						; size = 11
_szAccountId$ = -128					; size = 11
_pjMsg$ = -116						; size = 112
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z PROC ; JGGetCharacterInfo

; 1551 : {

  02eb0	55		 push	 ebp
  02eb1	8b ec		 mov	 ebp, esp
  02eb3	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  02eb9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02ebe	33 c5		 xor	 eax, ebp
  02ec0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02ec3	53		 push	 ebx
  02ec4	56		 push	 esi
  02ec5	57		 push	 edi

; 1552 : 	PMSG_CHARMAPJOINRESULT pjMsg;
; 1553 : 
; 1554 : 	char szAccountId[MAX_ACCOUNT_LEN+1];
; 1555 : 	char szName[MAX_ACCOUNT_LEN+1];
; 1556 : 	int aIndex = lpMsg->Number;

  02ec6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02ec9	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  02ecd	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1557 : 
; 1558 : 	szAccountId[MAX_ACCOUNT_LEN] = 0;

  02ed3	c6 45 8a 00	 mov	 BYTE PTR _szAccountId$[ebp+10], 0

; 1559 : 	memcpy(szAccountId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  02ed7	6a 0a		 push	 10			; 0000000aH
  02ed9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02edc	83 c0 08	 add	 eax, 8
  02edf	50		 push	 eax
  02ee0	8d 4d 80	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  02ee3	51		 push	 ecx
  02ee4	e8 00 00 00 00	 call	 _memcpy
  02ee9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1560 : 
; 1561 : 	if ( gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  02eec	8d 45 80	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  02eef	50		 push	 eax
  02ef0	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  02ef6	51		 push	 ecx
  02ef7	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  02efc	83 c4 08	 add	 esp, 8
  02eff	85 c0		 test	 eax, eax
  02f01	75 33		 jne	 SHORT $LN31@JGGetChara

; 1562 : 	{
; 1563 : 		LogAddC(2, lMsg.Get(MSGGET(1, 170)), szAccountId);

  02f03	8d 45 80	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  02f06	50		 push	 eax
  02f07	68 aa 01 00 00	 push	 426			; 000001aaH
  02f0c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02f11	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02f16	50		 push	 eax
  02f17	6a 02		 push	 2
  02f19	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  02f1f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1564 : 		CloseClient(aIndex);

  02f22	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  02f28	50		 push	 eax
  02f29	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02f2e	83 c4 04	 add	 esp, 4

; 1565 : 		return;

  02f31	e9 2a 0f 00 00	 jmp	 $LN32@JGGetChara
$LN31@JGGetChara:

; 1566 : 	}
; 1567 : 
; 1568 : 	szName[MAX_ACCOUNT_LEN] = 0;

  02f36	c6 85 7e ff ff
	ff 00		 mov	 BYTE PTR _szName$[ebp+10], 0

; 1569 : 	memcpy(szName, lpMsg->Name, MAX_ACCOUNT_LEN);

  02f3d	6a 0a		 push	 10			; 0000000aH
  02f3f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02f42	83 c0 12	 add	 eax, 18			; 00000012H
  02f45	50		 push	 eax
  02f46	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szName$[ebp]
  02f4c	51		 push	 ecx
  02f4d	e8 00 00 00 00	 call	 _memcpy
  02f52	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1570 : 
; 1571 : 	if ( lpMsg->result == false )

  02f55	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02f58	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  02f5c	85 c9		 test	 ecx, ecx
  02f5e	75 4d		 jne	 SHORT $LN30@JGGetChara

; 1572 : 	{
; 1573 : 		LogAddC(2, lMsg.Get(MSGGET(1, 171)), szName, gObj[aIndex].AccountID);

  02f60	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  02f66	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02f6c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02f72	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  02f76	52		 push	 edx
  02f77	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szName$[ebp]
  02f7d	50		 push	 eax
  02f7e	68 ab 01 00 00	 push	 427			; 000001abH
  02f83	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02f88	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02f8d	50		 push	 eax
  02f8e	6a 02		 push	 2
  02f90	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  02f96	83 c4 10	 add	 esp, 16			; 00000010H

; 1574 : 		CloseClient(aIndex);

  02f99	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  02f9f	50		 push	 eax
  02fa0	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02fa5	83 c4 04	 add	 esp, 4

; 1575 : 		return;

  02fa8	e9 b3 0e 00 00	 jmp	 $LN32@JGGetChara
$LN30@JGGetChara:

; 1576 : 	}
; 1577 : 
; 1578 : 	if ( (lpMsg->CtlCode&1) != 0 )

  02fad	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  02fb0	0f b6 88 d4 10
	00 00		 movzx	 ecx, BYTE PTR [eax+4308]
  02fb7	83 e1 01	 and	 ecx, 1
  02fba	74 42		 je	 SHORT $LN29@JGGetChara

; 1579 : 	{
; 1580 : 		LogAddC(2, "error-L1 : Load Block Character infomation", szName, gObj[aIndex].AccountID);

  02fbc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  02fc2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02fc8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02fce	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  02fd2	52		 push	 edx
  02fd3	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szName$[ebp]
  02fd9	50		 push	 eax
  02fda	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@
  02fdf	6a 02		 push	 2
  02fe1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  02fe7	83 c4 10	 add	 esp, 16			; 00000010H

; 1581 : 		CloseClient(aIndex);

  02fea	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  02ff0	50		 push	 eax
  02ff1	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  02ff6	83 c4 04	 add	 esp, 4

; 1582 : 		return;

  02ff9	e9 62 0e 00 00	 jmp	 $LN32@JGGetChara
$LN29@JGGetChara:

; 1583 : 	}
; 1584 : 
; 1585 : 	for (int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  02ffe	c7 85 6c ff ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$245657[ebp], 14000 ; 000036b0H
  03008	eb 0f		 jmp	 SHORT $LN28@JGGetChara
$LN27@JGGetChara:
  0300a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i$245657[ebp]
  03010	83 c0 01	 add	 eax, 1
  03013	89 85 6c ff ff
	ff		 mov	 DWORD PTR _i$245657[ebp], eax
$LN28@JGGetChara:
  03019	81 bd 6c ff ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$245657[ebp], 15000 ; 00003a98H
  03023	0f 8d d7 00 00
	00		 jge	 $LN26@JGGetChara

; 1586 : 	{
; 1587 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  03029	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i$245657[ebp]
  0302f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0303b	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  03040	0f 85 b5 00 00
	00		 jne	 $LN23@JGGetChara

; 1588 : 		{
; 1589 : 			if ( gObj[i].Type == OBJ_USER )

  03046	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i$245657[ebp]
  0304c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03058	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0305d	83 fa 01	 cmp	 edx, 1
  03060	0f 85 95 00 00
	00		 jne	 $LN23@JGGetChara

; 1590 : 			{
; 1591 : 				if ( !strncmp(szName, gObj[i].Name, MAX_ACCOUNT_LEN) || !strncmp(szAccountId, gObj[i].AccountID, MAX_ACCOUNT_LEN))

  03066	6a 0a		 push	 10			; 0000000aH
  03068	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i$245657[ebp]
  0306e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0307a	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0307e	52		 push	 edx
  0307f	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szName$[ebp]
  03085	50		 push	 eax
  03086	e8 00 00 00 00	 call	 _strncmp
  0308b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0308e	85 c0		 test	 eax, eax
  03090	74 29		 je	 SHORT $LN22@JGGetChara
  03092	6a 0a		 push	 10			; 0000000aH
  03094	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i$245657[ebp]
  0309a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  030a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030a6	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  030aa	52		 push	 edx
  030ab	8d 45 80	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  030ae	50		 push	 eax
  030af	e8 00 00 00 00	 call	 _strncmp
  030b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  030b7	85 c0		 test	 eax, eax
  030b9	75 40		 jne	 SHORT $LN23@JGGetChara
$LN22@JGGetChara:

; 1592 : 				{
; 1593 : 					LogAddTD("[Anti-HACK][JGGetCharacterInfo] Attempted Character-Copy by double logging [%s][%s]",	szName, gObj[aIndex].AccountID);

  030bb	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  030c1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  030c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030cd	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  030d1	52		 push	 edx
  030d2	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szName$[ebp]
  030d8	50		 push	 eax
  030d9	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@
  030de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  030e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1594 : 					CloseClient(aIndex);

  030e7	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  030ed	50		 push	 eax
  030ee	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  030f3	83 c4 04	 add	 esp, 4

; 1595 : 					return;

  030f6	e9 65 0d 00 00	 jmp	 $LN32@JGGetChara
$LN23@JGGetChara:

; 1596 : 				}
; 1597 : 			}
; 1598 : 		}
; 1599 : 	}

  030fb	e9 0a ff ff ff	 jmp	 $LN27@JGGetChara
$LN26@JGGetChara:

; 1600 : 
; 1601 : 	if ( gObjSetCharacter( (LPBYTE)lpMsg, aIndex) == FALSE )

  03100	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03106	50		 push	 eax
  03107	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0310a	51		 push	 ecx
  0310b	e8 00 00 00 00	 call	 ?gObjSetCharacter@@YAHPAEH@Z ; gObjSetCharacter
  03110	83 c4 08	 add	 esp, 8
  03113	85 c0		 test	 eax, eax
  03115	75 36		 jne	 SHORT $LN21@JGGetChara

; 1602 : 	{
; 1603 : 		LogAddC(2, lMsg.Get(MSGGET(1, 172)), szName);

  03117	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szName$[ebp]
  0311d	50		 push	 eax
  0311e	68 ac 01 00 00	 push	 428			; 000001acH
  03123	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  03128	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0312d	50		 push	 eax
  0312e	6a 02		 push	 2
  03130	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  03136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1604 : 		CloseClient(aIndex);

  03139	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  0313f	50		 push	 eax
  03140	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  03145	83 c4 04	 add	 esp, 4

; 1605 : 		return;

  03148	e9 13 0d 00 00	 jmp	 $LN32@JGGetChara
$LN21@JGGetChara:

; 1606 : 	}
; 1607 : 
; 1608 : 	gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  0314d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03153	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03159	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0315f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03165	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0316b	8b 84 02 58 01
	00 00		 mov	 eax, DWORD PTR [edx+eax+344]
  03172	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03178	03 84 0a 5c 01
	00 00		 add	 eax, DWORD PTR [edx+ecx+348]
  0317f	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  03185	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0318b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03191	89 84 0a 54 01
	00 00		 mov	 DWORD PTR [edx+ecx+340], eax

; 1609 : 
; 1610 : 	if ( szAuthKey[0] != AUTHKEY0 )

  03198	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?szAuthKey@@3PADA
  0319f	83 f8 29	 cmp	 eax, 41			; 00000029H
  031a2	74 05		 je	 SHORT $LN20@JGGetChara

; 1611 : 	{
; 1612 : 		DestroyGIocp();

  031a4	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN20@JGGetChara:

; 1613 : 	}
; 1614 : 
; 1615 : 	LPOBJ lpObj = &gObj[aIndex];

  031a9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  031af	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  031b5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  031bb	89 85 68 ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax

; 1616 : 
; 1617 : 	if ( gObj[aIndex].m_Index != aIndex )

  031c1	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  031c7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  031cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  031d3	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  031d6	3b 95 70 ff ff
	ff		 cmp	 edx, DWORD PTR _aIndex$[ebp]
  031dc	74 3d		 je	 SHORT $LN19@JGGetChara

; 1618 : 	{
; 1619 : 		LogAddC(2, lMsg.Get(MSGGET(1, 173)), __FILE__, __LINE__);

  031de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
  031e3	83 c0 44	 add	 eax, 68			; 00000044H
  031e6	50		 push	 eax
  031e7	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
  031ec	68 ad 01 00 00	 push	 429			; 000001adH
  031f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  031f6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  031fb	50		 push	 eax
  031fc	6a 02		 push	 2
  031fe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  03204	83 c4 10	 add	 esp, 16			; 00000010H

; 1620 : 		CloseClient(aIndex);

  03207	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  0320d	50		 push	 eax
  0320e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  03213	83 c4 04	 add	 esp, 4

; 1621 : 		return;

  03216	e9 45 0c 00 00	 jmp	 $LN32@JGGetChara
$LN19@JGGetChara:

; 1622 : 	}
; 1623 : 
; 1624 : 	if ( lpObj->Money < 0 )

  0321b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03221	83 b8 f0 00 00
	00 00		 cmp	 DWORD PTR [eax+240], 0
  03228	7d 4a		 jge	 SHORT $LN18@JGGetChara

; 1625 : 	{
; 1626 : 		LogAddC(2, " ZEN MODIFY  [%s][%s] %d -> 0", szName, gObj[aIndex].AccountID, lpObj->Money);

  0322a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03230	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  03236	51		 push	 ecx
  03237	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _aIndex$[ebp]
  0323d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  03243	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03248	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0324c	51		 push	 ecx
  0324d	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _szName$[ebp]
  03253	52		 push	 edx
  03254	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LIHKGJJG@?$DP?$DP?$DP?$DP?5ZEN?5MODIFY?5?$DP?$DP?$DP?$DP?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd@
  03259	6a 02		 push	 2
  0325b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  03261	83 c4 14	 add	 esp, 20			; 00000014H

; 1627 : 		lpObj->Money = 0;

  03264	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0326a	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0
$LN18@JGGetChara:

; 1628 : 	}
; 1629 : 
; 1630 : 	if ( lpObj->m_bMapSvrMoveReq == false )

  03274	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0327a	0f b6 88 e5 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+7141]
  03281	85 c9		 test	 ecx, ecx
  03283	0f 85 62 01 00
	00		 jne	 $LN15@JGGetChara

; 1631 : 	{
; 1632 : 		if ( MapNumberCheck(lpObj->MapNumber) == FALSE )

  03289	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0328f	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  03296	51		 push	 ecx
  03297	e8 00 00 00 00	 call	 ?MapNumberCheck@@YAHH@Z	; MapNumberCheck
  0329c	83 c4 04	 add	 esp, 4
  0329f	85 c0		 test	 eax, eax
  032a1	75 30		 jne	 SHORT $LN16@JGGetChara

; 1633 : 		{
; 1634 : 			LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  032a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
  032a8	83 c0 53	 add	 eax, 83			; 00000053H
  032ab	50		 push	 eax
  032ac	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
  032b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  032b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  032bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1635 : 			CloseClient(aIndex);

  032bf	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  032c5	50		 push	 eax
  032c6	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  032cb	83 c4 04	 add	 esp, 4

; 1636 : 
; 1637 : 			return;

  032ce	e9 8d 0b 00 00	 jmp	 $LN32@JGGetChara
$LN16@JGGetChara:

; 1638 : 		}
; 1639 : 
; 1640 : 		short wGameServerCode = g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->MapNumber, lpObj->m_sPrevMapSvrCode);

  032d3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  032d9	0f b7 88 ec 1b
	00 00		 movzx	 ecx, WORD PTR [eax+7148]
  032e0	51		 push	 ecx
  032e1	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  032e7	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  032ee	50		 push	 eax
  032ef	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  032f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  032f7	52		 push	 edx
  032f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  032fd	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  03302	66 89 85 64 ff
	ff ff		 mov	 WORD PTR _wGameServerCode$245677[ebp], ax

; 1641 : 
; 1642 : 		if ( wGameServerCode != gGameServerCode )

  03309	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _wGameServerCode$245677[ebp]
  03310	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  03317	3b c1		 cmp	 eax, ecx
  03319	0f 84 cc 00 00
	00		 je	 $LN15@JGGetChara

; 1643 : 		{
; 1644 : 			if ( wGameServerCode == -1 )

  0331f	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _wGameServerCode$245677[ebp]
  03326	83 f8 ff	 cmp	 eax, -1
  03329	75 41		 jne	 SHORT $LN14@JGGetChara

; 1645 : 			{
; 1646 : 				LogAddC(2,"[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)", lpObj->AccountID, lpObj->Name, lpObj->m_Index);

  0332b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03331	8b 08		 mov	 ecx, DWORD PTR [eax]
  03333	51		 push	 ecx
  03334	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  0333a	83 c2 77	 add	 edx, 119		; 00000077H
  0333d	52		 push	 edx
  0333e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03344	83 c0 6c	 add	 eax, 108		; 0000006cH
  03347	50		 push	 eax
  03348	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
  0334d	6a 02		 push	 2
  0334f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  03355	83 c4 14	 add	 esp, 20			; 00000014H

; 1647 : 				CloseClient(aIndex);

  03358	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  0335e	50		 push	 eax
  0335f	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  03364	83 c4 04	 add	 esp, 4

; 1648 : 				return;

  03367	e9 f4 0a 00 00	 jmp	 $LN32@JGGetChara
$LN14@JGGetChara:

; 1649 : 			}
; 1650 : 
; 1651 : 			GJReqMapSvrMove(lpObj->m_Index, wGameServerCode, lpObj->MapNumber, lpObj->X, lpObj->Y);

  0336c	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03372	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  03379	51		 push	 ecx
  0337a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  03380	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  03387	50		 push	 eax
  03388	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0338e	66 0f b6 91 49
	01 00 00	 movzx	 dx, BYTE PTR [ecx+329]
  03396	0f b7 c2	 movzx	 eax, dx
  03399	50		 push	 eax
  0339a	0f b7 8d 64 ff
	ff ff		 movzx	 ecx, WORD PTR _wGameServerCode$245677[ebp]
  033a1	51		 push	 ecx
  033a2	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  033a8	8b 02		 mov	 eax, DWORD PTR [edx]
  033aa	50		 push	 eax
  033ab	e8 00 00 00 00	 call	 ?GJReqMapSvrMove@@YAXHGGEE@Z ; GJReqMapSvrMove
  033b0	83 c4 14	 add	 esp, 20			; 00000014H

; 1652 : 			LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)", wGameServerCode, lpObj->AccountID, lpObj->Name, lpObj->m_Index);

  033b3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  033b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  033bb	51		 push	 ecx
  033bc	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  033c2	83 c2 77	 add	 edx, 119		; 00000077H
  033c5	52		 push	 edx
  033c6	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  033cc	83 c0 6c	 add	 eax, 108		; 0000006cH
  033cf	50		 push	 eax
  033d0	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _wGameServerCode$245677[ebp]
  033d7	51		 push	 ecx
  033d8	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
  033dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  033e3	83 c4 14	 add	 esp, 20			; 00000014H

; 1653 : 			return;

  033e6	e9 75 0a 00 00	 jmp	 $LN32@JGGetChara
$LN15@JGGetChara:

; 1654 : 		}
; 1655 : 	}
; 1656 : 
; 1657 : 	lpObj->m_bMapSvrMoveReq = false;

  033eb	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  033f1	c6 80 e5 1b 00
	00 00		 mov	 BYTE PTR [eax+7141], 0

; 1658 : 
; 1659 : 	pjMsg.h.c = 0xC3;

  033f8	c6 45 8c c3	 mov	 BYTE PTR _pjMsg$[ebp], 195 ; 000000c3H

; 1660 : 	pjMsg.h.headcode = 0xF3;

  033fc	c6 45 8e f3	 mov	 BYTE PTR _pjMsg$[ebp+2], 243 ; 000000f3H

; 1661 : 	pjMsg.h.size = sizeof(PMSG_CHARMAPJOINRESULT); //0x44

  03400	c6 45 8d 70	 mov	 BYTE PTR _pjMsg$[ebp+1], 112 ; 00000070H

; 1662 : 	pjMsg.subcode = 0x03;

  03404	c6 45 8f 03	 mov	 BYTE PTR _pjMsg$[ebp+3], 3

; 1663 : 
; 1664 : 	pjMsg.MapX = lpObj->X; //124

  03408	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0340e	8a 88 44 01 00
	00		 mov	 cl, BYTE PTR [eax+324]
  03414	88 4d 90	 mov	 BYTE PTR _pjMsg$[ebp+4], cl

; 1665 : 	pjMsg.MapY = lpObj->Y; //126

  03417	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0341d	8a 88 46 01 00
	00		 mov	 cl, BYTE PTR [eax+326]
  03423	88 4d 91	 mov	 BYTE PTR _pjMsg$[ebp+5], cl

; 1666 : 	pjMsg.MapNumber = lpObj->MapNumber; //129

  03426	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0342c	8a 88 49 01 00
	00		 mov	 cl, BYTE PTR [eax+329]
  03432	88 4d 92	 mov	 BYTE PTR _pjMsg$[ebp+6], cl

; 1667 : 	pjMsg.Dir = lpObj->Dir; //128

  03435	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0343b	8a 88 48 01 00
	00		 mov	 cl, BYTE PTR [eax+328]
  03441	88 4d 93	 mov	 BYTE PTR _pjMsg$[ebp+7], cl

; 1668 : 
; 1669 : 	__int64 Experience = lpObj->Experience; //0AC

  03444	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0344a	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  03450	33 d2		 xor	 edx, edx
  03452	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _Experience$[ebp], ecx
  03458	89 95 60 ff ff
	ff		 mov	 DWORD PTR _Experience$[ebp+4], edx

; 1670 : 
; 1671 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpObj) != FALSE) //Set ML Exp Info

  0345e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03464	50		 push	 eax
  03465	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  0346a	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  0346f	85 c0		 test	 eax, eax
  03471	74 1e		 je	 SHORT $LN13@JGGetChara

; 1672 : 	{
; 1673 : 		Experience = lpObj->MLExp;

  03473	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03479	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  0347f	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _Experience$[ebp], ecx
  03485	8b 90 dc 00 00
	00		 mov	 edx, DWORD PTR [eax+220]
  0348b	89 95 60 ff ff
	ff		 mov	 DWORD PTR _Experience$[ebp+4], edx
$LN13@JGGetChara:

; 1674 : 	}
; 1675 : 
; 1676 : 	pjMsg.ExpHHH = SET_NUMBERH(SET_NUMBERHW(HIDWORD(Experience)));

  03491	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  03497	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _Experience$[ebp+4]
  0349d	b1 20		 mov	 cl, 32			; 00000020H
  0349f	e8 00 00 00 00	 call	 __allshr
  034a4	c1 e8 10	 shr	 eax, 16			; 00000010H
  034a7	0f b7 c0	 movzx	 eax, ax
  034aa	c1 e8 08	 shr	 eax, 8
  034ad	88 45 94	 mov	 BYTE PTR _pjMsg$[ebp+8], al

; 1677 : 	pjMsg.ExpHHL = SET_NUMBERL(SET_NUMBERHW(HIDWORD(Experience)));

  034b0	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  034b6	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _Experience$[ebp+4]
  034bc	b1 20		 mov	 cl, 32			; 00000020H
  034be	e8 00 00 00 00	 call	 __allshr
  034c3	c1 e8 10	 shr	 eax, 16			; 00000010H
  034c6	0f b7 c0	 movzx	 eax, ax
  034c9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  034ce	88 45 95	 mov	 BYTE PTR _pjMsg$[ebp+9], al

; 1678 : 	pjMsg.ExpHLH = SET_NUMBERH(SET_NUMBERLW(HIDWORD(Experience)));

  034d1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  034d7	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _Experience$[ebp+4]
  034dd	b1 20		 mov	 cl, 32			; 00000020H
  034df	e8 00 00 00 00	 call	 __allshr
  034e4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  034e9	0f b7 c0	 movzx	 eax, ax
  034ec	c1 e8 08	 shr	 eax, 8
  034ef	88 45 96	 mov	 BYTE PTR _pjMsg$[ebp+10], al

; 1679 : 	pjMsg.ExpHLL = SET_NUMBERL(SET_NUMBERLW(HIDWORD(Experience)));

  034f2	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  034f8	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _Experience$[ebp+4]
  034fe	b1 20		 mov	 cl, 32			; 00000020H
  03500	e8 00 00 00 00	 call	 __allshr
  03505	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0350a	0f b7 c0	 movzx	 eax, ax
  0350d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03512	88 45 97	 mov	 BYTE PTR _pjMsg$[ebp+11], al

; 1680 : 	pjMsg.ExpLHH = SET_NUMBERH(SET_NUMBERHW(LODWORD(Experience)));

  03515	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  0351b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _Experience$[ebp+4]
  03521	83 e1 00	 and	 ecx, 0
  03524	c1 e8 10	 shr	 eax, 16			; 00000010H
  03527	0f b7 d0	 movzx	 edx, ax
  0352a	c1 ea 08	 shr	 edx, 8
  0352d	88 55 98	 mov	 BYTE PTR _pjMsg$[ebp+12], dl

; 1681 : 	pjMsg.ExpLHL = SET_NUMBERL(SET_NUMBERHW(LODWORD(Experience)));

  03530	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  03536	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _Experience$[ebp+4]
  0353c	83 e1 00	 and	 ecx, 0
  0353f	c1 e8 10	 shr	 eax, 16			; 00000010H
  03542	0f b7 d0	 movzx	 edx, ax
  03545	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0354b	88 55 99	 mov	 BYTE PTR _pjMsg$[ebp+13], dl

; 1682 : 	pjMsg.ExpLLH = SET_NUMBERH(SET_NUMBERLW(LODWORD(Experience)));

  0354e	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  03554	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _Experience$[ebp+4]
  0355a	83 e1 00	 and	 ecx, 0
  0355d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03562	0f b7 d0	 movzx	 edx, ax
  03565	c1 ea 08	 shr	 edx, 8
  03568	88 55 9a	 mov	 BYTE PTR _pjMsg$[ebp+14], dl

; 1683 : 	pjMsg.ExpLLL = SET_NUMBERL(SET_NUMBERLW(LODWORD(Experience)));

  0356b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _Experience$[ebp]
  03571	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _Experience$[ebp+4]
  03577	83 e1 00	 and	 ecx, 0
  0357a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0357f	0f b7 d0	 movzx	 edx, ax
  03582	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  03588	88 55 9b	 mov	 BYTE PTR _pjMsg$[ebp+15], dl

; 1684 : 
; 1685 : 	__int64 NextExperience = lpObj->NextExp;

  0358b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03591	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  03597	33 d2		 xor	 edx, edx
  03599	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _NextExperience$[ebp], ecx
  0359f	89 95 58 ff ff
	ff		 mov	 DWORD PTR _NextExperience$[ebp+4], edx

; 1686 : 
; 1687 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpObj) != FALSE) //Set ML NextExp Info

  035a5	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  035ab	50		 push	 eax
  035ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  035b1	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  035b6	85 c0		 test	 eax, eax
  035b8	74 1e		 je	 SHORT $LN12@JGGetChara

; 1688 : 	{
; 1689 : 		NextExperience = lpObj->MLNextExp;

  035ba	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  035c0	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  035c6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _NextExperience$[ebp], ecx
  035cc	8b 90 e4 00 00
	00		 mov	 edx, DWORD PTR [eax+228]
  035d2	89 95 58 ff ff
	ff		 mov	 DWORD PTR _NextExperience$[ebp+4], edx
$LN12@JGGetChara:

; 1690 : 	}
; 1691 : 
; 1692 : 	pjMsg.NextExpHHH = SET_NUMBERH(SET_NUMBERHW(HIDWORD(NextExperience)));

  035d8	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  035de	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _NextExperience$[ebp+4]
  035e4	b1 20		 mov	 cl, 32			; 00000020H
  035e6	e8 00 00 00 00	 call	 __allshr
  035eb	c1 e8 10	 shr	 eax, 16			; 00000010H
  035ee	0f b7 c0	 movzx	 eax, ax
  035f1	c1 e8 08	 shr	 eax, 8
  035f4	88 45 9c	 mov	 BYTE PTR _pjMsg$[ebp+16], al

; 1693 : 	pjMsg.NextExpHHL = SET_NUMBERL(SET_NUMBERHW(HIDWORD(NextExperience)));

  035f7	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  035fd	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _NextExperience$[ebp+4]
  03603	b1 20		 mov	 cl, 32			; 00000020H
  03605	e8 00 00 00 00	 call	 __allshr
  0360a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0360d	0f b7 c0	 movzx	 eax, ax
  03610	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03615	88 45 9d	 mov	 BYTE PTR _pjMsg$[ebp+17], al

; 1694 : 	pjMsg.NextExpHLH = SET_NUMBERH(SET_NUMBERLW(HIDWORD(NextExperience)));

  03618	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  0361e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _NextExperience$[ebp+4]
  03624	b1 20		 mov	 cl, 32			; 00000020H
  03626	e8 00 00 00 00	 call	 __allshr
  0362b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03630	0f b7 c0	 movzx	 eax, ax
  03633	c1 e8 08	 shr	 eax, 8
  03636	88 45 9e	 mov	 BYTE PTR _pjMsg$[ebp+18], al

; 1695 : 	pjMsg.NextExpHLL = SET_NUMBERL(SET_NUMBERLW(HIDWORD(NextExperience)));

  03639	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  0363f	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _NextExperience$[ebp+4]
  03645	b1 20		 mov	 cl, 32			; 00000020H
  03647	e8 00 00 00 00	 call	 __allshr
  0364c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03651	0f b7 c0	 movzx	 eax, ax
  03654	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03659	88 45 9f	 mov	 BYTE PTR _pjMsg$[ebp+19], al

; 1696 : 	pjMsg.NextExpLHH = SET_NUMBERH(SET_NUMBERHW(LODWORD(NextExperience)));

  0365c	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  03662	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _NextExperience$[ebp+4]
  03668	83 e1 00	 and	 ecx, 0
  0366b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0366e	0f b7 d0	 movzx	 edx, ax
  03671	c1 ea 08	 shr	 edx, 8
  03674	88 55 a0	 mov	 BYTE PTR _pjMsg$[ebp+20], dl

; 1697 : 	pjMsg.NextExpLHL = SET_NUMBERL(SET_NUMBERHW(LODWORD(NextExperience)));

  03677	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  0367d	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _NextExperience$[ebp+4]
  03683	83 e1 00	 and	 ecx, 0
  03686	c1 e8 10	 shr	 eax, 16			; 00000010H
  03689	0f b7 d0	 movzx	 edx, ax
  0368c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  03692	88 55 a1	 mov	 BYTE PTR _pjMsg$[ebp+21], dl

; 1698 : 	pjMsg.NextExpLLH = SET_NUMBERH(SET_NUMBERLW(LODWORD(NextExperience)));

  03695	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  0369b	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _NextExperience$[ebp+4]
  036a1	83 e1 00	 and	 ecx, 0
  036a4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  036a9	0f b7 d0	 movzx	 edx, ax
  036ac	c1 ea 08	 shr	 edx, 8
  036af	88 55 a2	 mov	 BYTE PTR _pjMsg$[ebp+22], dl

; 1699 : 	pjMsg.NextExpLLL = SET_NUMBERL(SET_NUMBERLW(LODWORD(NextExperience)));

  036b2	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _NextExperience$[ebp]
  036b8	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _NextExperience$[ebp+4]
  036be	83 e1 00	 and	 ecx, 0
  036c1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  036c6	0f b7 d0	 movzx	 edx, ax
  036c9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  036cf	88 55 a3	 mov	 BYTE PTR _pjMsg$[ebp+23], dl

; 1700 : 
; 1701 : 	pjMsg.LevelUpPoint = lpObj->LevelUpPoint;

  036d2	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  036d8	66 8b 88 c0 00
	00 00		 mov	 cx, WORD PTR [eax+192]
  036df	66 89 4d a4	 mov	 WORD PTR _pjMsg$[ebp+24], cx

; 1702 : 	pjMsg.Str = lpObj->Strength;

  036e3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  036e9	66 8b 88 f4 00
	00 00		 mov	 cx, WORD PTR [eax+244]
  036f0	66 89 4d a6	 mov	 WORD PTR _pjMsg$[ebp+26], cx

; 1703 : 	pjMsg.Dex = lpObj->Dexterity;

  036f4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  036fa	66 8b 88 f6 00
	00 00		 mov	 cx, WORD PTR [eax+246]
  03701	66 89 4d a8	 mov	 WORD PTR _pjMsg$[ebp+28], cx

; 1704 : 	pjMsg.Vit = lpObj->Vitality;

  03705	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0370b	66 8b 88 f8 00
	00 00		 mov	 cx, WORD PTR [eax+248]
  03712	66 89 4d aa	 mov	 WORD PTR _pjMsg$[ebp+30], cx

; 1705 : 	pjMsg.Energy = lpObj->Energy;

  03716	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0371c	66 8b 88 fa 00
	00 00		 mov	 cx, WORD PTR [eax+250]
  03723	66 89 4d ac	 mov	 WORD PTR _pjMsg$[ebp+32], cx

; 1706 : 	pjMsg.Money = lpObj->Money;

  03727	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0372d	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  03733	89 4d c0	 mov	 DWORD PTR _pjMsg$[ebp+52], ecx

; 1707 : 	pjMsg.PkLevel = lpObj->m_PK_Level;

  03736	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0373c	8a 88 3d 01 00
	00		 mov	 cl, BYTE PTR [eax+317]
  03742	88 4d c4	 mov	 BYTE PTR _pjMsg$[ebp+56], cl

; 1708 : 	pjMsg.Life = (WORD)lpObj->Life;

  03745	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0374b	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  03751	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1019[ebp]
  03757	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1019[ebp]
  0375e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  03763	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1022[ebp], eax
  03769	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1022[ebp]
  0376f	db 9d f0 fe ff
	ff		 fistp	 DWORD PTR tv1024[ebp]
  03775	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1019[ebp]
  0377b	66 8b 8d f0 fe
	ff ff		 mov	 cx, WORD PTR tv1024[ebp]
  03782	66 89 4d ae	 mov	 WORD PTR _pjMsg$[ebp+34], cx

; 1709 : 	pjMsg.MaxLife = (WORD)(lpObj->AddLife + lpObj->MaxLife);

  03786	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0378c	db 80 4c 01 00
	00		 fild	 DWORD PTR [eax+332]
  03792	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03798	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  0379e	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1029[ebp]
  037a4	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1029[ebp]
  037ab	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  037b0	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1032[ebp], eax
  037b6	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1032[ebp]
  037bc	db 9d f0 fe ff
	ff		 fistp	 DWORD PTR tv1034[ebp]
  037c2	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1029[ebp]
  037c8	66 8b 95 f0 fe
	ff ff		 mov	 dx, WORD PTR tv1034[ebp]
  037cf	66 89 55 b0	 mov	 WORD PTR _pjMsg$[ebp+36], dx

; 1710 : 	pjMsg.Mana = (WORD)lpObj->Mana;

  037d3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  037d9	d9 80 10 01 00
	00		 fld	 DWORD PTR [eax+272]
  037df	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1038[ebp]
  037e5	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1038[ebp]
  037ec	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  037f1	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1041[ebp], eax
  037f7	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1041[ebp]
  037fd	db 9d f0 fe ff
	ff		 fistp	 DWORD PTR tv1043[ebp]
  03803	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1038[ebp]
  03809	66 8b 8d f0 fe
	ff ff		 mov	 cx, WORD PTR tv1043[ebp]
  03810	66 89 4d b2	 mov	 WORD PTR _pjMsg$[ebp+38], cx

; 1711 : 	pjMsg.MaxMana = (WORD)(lpObj->AddMana + lpObj->MaxMana);

  03814	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0381a	db 80 50 01 00
	00		 fild	 DWORD PTR [eax+336]
  03820	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03826	d8 81 14 01 00
	00		 fadd	 DWORD PTR [ecx+276]
  0382c	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1048[ebp]
  03832	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1048[ebp]
  03839	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0383e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1051[ebp], eax
  03844	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1051[ebp]
  0384a	db 9d f0 fe ff
	ff		 fistp	 DWORD PTR tv1053[ebp]
  03850	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1048[ebp]
  03856	66 8b 95 f0 fe
	ff ff		 mov	 dx, WORD PTR tv1053[ebp]
  0385d	66 89 55 b4	 mov	 WORD PTR _pjMsg$[ebp+40], dx

; 1712 : 	pjMsg.wShield = lpObj->iShield;

  03861	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03867	66 8b 88 54 01
	00 00		 mov	 cx, WORD PTR [eax+340]
  0386e	66 89 4d b6	 mov	 WORD PTR _pjMsg$[ebp+42], cx

; 1713 : 	pjMsg.wMaxShield = lpObj->iMaxShield + lpObj->iAddShield;

  03872	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03878	8b 88 58 01 00
	00		 mov	 ecx, DWORD PTR [eax+344]
  0387e	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  03884	03 8a 5c 01 00
	00		 add	 ecx, DWORD PTR [edx+348]
  0388a	66 89 4d b8	 mov	 WORD PTR _pjMsg$[ebp+44], cx

; 1714 : 	pjMsg.CtlCode = lpMsg->CtlCode;

  0388e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  03891	8a 88 d4 10 00
	00		 mov	 cl, BYTE PTR [eax+4308]
  03897	88 4d c5	 mov	 BYTE PTR _pjMsg$[ebp+57], cl

; 1715 : 	pjMsg.BP = lpObj->BP;

  0389a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  038a0	66 8b 88 28 01
	00 00		 mov	 cx, WORD PTR [eax+296]
  038a7	66 89 4d ba	 mov	 WORD PTR _pjMsg$[ebp+46], cx

; 1716 : 	pjMsg.MaxBP = lpObj->MaxBP + lpObj->AddBP;

  038ab	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  038b1	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  038b7	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  038bd	03 8a 30 01 00
	00		 add	 ecx, DWORD PTR [edx+304]
  038c3	66 89 4d bc	 mov	 WORD PTR _pjMsg$[ebp+48], cx

; 1717 : 	pjMsg.Leadership = lpObj->Leadership;

  038c7	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  038cd	66 8b 88 18 01
	00 00		 mov	 cx, WORD PTR [eax+280]
  038d4	66 89 4d ca	 mov	 WORD PTR _pjMsg$[ebp+62], cx

; 1718 : 
; 1719 : 	pjMsg.UpPoint = lpObj->LevelUpPoint;

  038d8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  038de	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  038e4	89 4d d4	 mov	 DWORD PTR _pjMsg$[ebp+72], ecx

; 1720 : 
; 1721 : 	short AddPoint = 0;

  038e7	33 c0		 xor	 eax, eax
  038e9	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _AddPoint$[ebp], ax

; 1722 : 	short MaxAddPoint = 0;

  038f0	33 c0		 xor	 eax, eax
  038f2	66 89 85 4c ff
	ff ff		 mov	 WORD PTR _MaxAddPoint$[ebp], ax

; 1723 : 	short MinusPoint = 0;

  038f9	33 c0		 xor	 eax, eax
  038fb	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _MinusPoint$[ebp], ax

; 1724 : 	short MaxMinusPoint = 0;

  03902	33 c0		 xor	 eax, eax
  03904	66 89 85 44 ff
	ff ff		 mov	 WORD PTR _MaxMinusPoint$[ebp], ax

; 1725 : 
; 1726 : #ifdef EXPINV
; 1727 : 	pjMsg.ExpandedInventoryLevel = lpObj->ExpandedInventory;

  0390b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03911	8a 88 24 26 00
	00		 mov	 cl, BYTE PTR [eax+9764]
  03917	88 4d d0	 mov	 BYTE PTR _pjMsg$[ebp+68], cl

; 1728 : #endif
; 1729 : 	
; 1730 : 	gObjGetStatPointState(lpObj->m_Index, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);

  0391a	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _MaxMinusPoint$[ebp]
  03920	50		 push	 eax
  03921	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _MinusPoint$[ebp]
  03927	51		 push	 ecx
  03928	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _MaxAddPoint$[ebp]
  0392e	52		 push	 edx
  0392f	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _AddPoint$[ebp]
  03935	50		 push	 eax
  03936	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0393c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0393e	52		 push	 edx
  0393f	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState
  03944	83 c4 14	 add	 esp, 20			; 00000014H

; 1731 : 
; 1732 : 	pjMsg.AddPoint = AddPoint;

  03947	66 8b 85 50 ff
	ff ff		 mov	 ax, WORD PTR _AddPoint$[ebp]
  0394e	66 89 45 c6	 mov	 WORD PTR _pjMsg$[ebp+58], ax

; 1733 : 	pjMsg.MaxAddPoint = MaxAddPoint;

  03952	66 8b 85 4c ff
	ff ff		 mov	 ax, WORD PTR _MaxAddPoint$[ebp]
  03959	66 89 45 c8	 mov	 WORD PTR _pjMsg$[ebp+60], ax

; 1734 : 	pjMsg.wMinusPoint = MinusPoint;

  0395d	66 8b 85 48 ff
	ff ff		 mov	 ax, WORD PTR _MinusPoint$[ebp]
  03964	66 89 45 cc	 mov	 WORD PTR _pjMsg$[ebp+64], ax

; 1735 : 	pjMsg.wMaxMinusPoint = MaxMinusPoint;

  03968	66 8b 85 44 ff
	ff ff		 mov	 ax, WORD PTR _MaxMinusPoint$[ebp]
  0396f	66 89 45 ce	 mov	 WORD PTR _pjMsg$[ebp+66], ax

; 1736 : 
; 1737 : 	pjMsg.Reset = lpObj->Reset;

  03973	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03979	66 8b 88 90 22
	00 00		 mov	 cx, WORD PTR [eax+8848]
  03980	66 89 4d d8	 mov	 WORD PTR _pjMsg$[ebp+76], cx

; 1738 : 	pjMsg.GReset = lpObj->GReset;

  03984	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0398a	66 8b 88 94 22
	00 00		 mov	 cx, WORD PTR [eax+8852]
  03991	66 89 4d da	 mov	 WORD PTR _pjMsg$[ebp+78], cx

; 1739 : 
; 1740 : 	pjMsg.dwLife = lpObj->Life;

  03995	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0399b	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  039a1	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1095[ebp]
  039a7	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1095[ebp]
  039ae	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  039b3	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1098[ebp], eax
  039b9	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1098[ebp]
  039bf	df bd ec fe ff
	ff		 fistp	 QWORD PTR tv1100[ebp]
  039c5	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1095[ebp]
  039cb	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv1100[ebp]
  039d1	89 4d dc	 mov	 DWORD PTR _pjMsg$[ebp+80], ecx

; 1741 : 	pjMsg.dwMaxLife = lpObj->AddLife + lpObj->MaxLife;

  039d4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  039da	db 80 4c 01 00
	00		 fild	 DWORD PTR [eax+332]
  039e0	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  039e6	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  039ec	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1105[ebp]
  039f2	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1105[ebp]
  039f9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  039fe	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1108[ebp], eax
  03a04	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1108[ebp]
  03a0a	df bd ec fe ff
	ff		 fistp	 QWORD PTR tv1110[ebp]
  03a10	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1105[ebp]
  03a16	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv1110[ebp]
  03a1c	89 55 e0	 mov	 DWORD PTR _pjMsg$[ebp+84], edx

; 1742 : 	pjMsg.dwMana = lpObj->Mana;

  03a1f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03a25	d9 80 10 01 00
	00		 fld	 DWORD PTR [eax+272]
  03a2b	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1114[ebp]
  03a31	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1114[ebp]
  03a38	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  03a3d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1117[ebp], eax
  03a43	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1117[ebp]
  03a49	df bd ec fe ff
	ff		 fistp	 QWORD PTR tv1119[ebp]
  03a4f	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1114[ebp]
  03a55	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv1119[ebp]
  03a5b	89 4d e4	 mov	 DWORD PTR _pjMsg$[ebp+88], ecx

; 1743 : 	pjMsg.dwMaxMana = lpObj->AddMana + lpObj->MaxMana;

  03a5e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03a64	db 80 50 01 00
	00		 fild	 DWORD PTR [eax+336]
  03a6a	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03a70	d8 81 14 01 00
	00		 fadd	 DWORD PTR [ecx+276]
  03a76	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv1124[ebp]
  03a7c	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv1124[ebp]
  03a83	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  03a88	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1127[ebp], eax
  03a8e	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv1127[ebp]
  03a94	df bd ec fe ff
	ff		 fistp	 QWORD PTR tv1129[ebp]
  03a9a	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv1124[ebp]
  03aa0	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv1129[ebp]
  03aa6	89 55 e8	 mov	 DWORD PTR _pjMsg$[ebp+92], edx

; 1744 : 	pjMsg.dwShield = lpObj->iShield;

  03aa9	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03aaf	8b 88 54 01 00
	00		 mov	 ecx, DWORD PTR [eax+340]
  03ab5	89 4d ec	 mov	 DWORD PTR _pjMsg$[ebp+96], ecx

; 1745 : 	pjMsg.dwMaxShield = lpObj->iMaxShield + lpObj->iAddShield;

  03ab8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03abe	8b 88 58 01 00
	00		 mov	 ecx, DWORD PTR [eax+344]
  03ac4	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  03aca	03 8a 5c 01 00
	00		 add	 ecx, DWORD PTR [edx+348]
  03ad0	89 4d f0	 mov	 DWORD PTR _pjMsg$[ebp+100], ecx

; 1746 : 	pjMsg.dwBP = lpObj->BP;

  03ad3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03ad9	8b 88 28 01 00
	00		 mov	 ecx, DWORD PTR [eax+296]
  03adf	89 4d f4	 mov	 DWORD PTR _pjMsg$[ebp+104], ecx

; 1747 : 	pjMsg.dwMaxBP = lpObj->MaxBP + lpObj->AddBP;

  03ae2	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03ae8	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  03aee	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  03af4	03 8a 30 01 00
	00		 add	 ecx, DWORD PTR [edx+304]
  03afa	89 4d f8	 mov	 DWORD PTR _pjMsg$[ebp+108], ecx

; 1748 : 
; 1749 : 	LogAddTD("[FRUIT System] [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus:%d/MaxPlus:%d)", lpObj->AccountID, lpObj->Name, MinusPoint, AddPoint, MaxMinusPoint, MaxAddPoint);

  03afd	0f bf 85 4c ff
	ff ff		 movsx	 eax, WORD PTR _MaxAddPoint$[ebp]
  03b04	50		 push	 eax
  03b05	0f bf 8d 44 ff
	ff ff		 movsx	 ecx, WORD PTR _MaxMinusPoint$[ebp]
  03b0c	51		 push	 ecx
  03b0d	0f bf 95 50 ff
	ff ff		 movsx	 edx, WORD PTR _AddPoint$[ebp]
  03b14	52		 push	 edx
  03b15	0f bf 85 48 ff
	ff ff		 movsx	 eax, WORD PTR _MinusPoint$[ebp]
  03b1c	50		 push	 eax
  03b1d	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03b23	83 c1 77	 add	 ecx, 119		; 00000077H
  03b26	51		 push	 ecx
  03b27	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  03b2d	83 c2 6c	 add	 edx, 108		; 0000006cH
  03b30	52		 push	 edx
  03b31	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@
  03b36	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03b3c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1750 : 
; 1751 : 	if ( AddPoint < 0 || AddPoint > MaxAddPoint || MinusPoint < 0 || MinusPoint > MaxMinusPoint )

  03b3f	0f bf 85 50 ff
	ff ff		 movsx	 eax, WORD PTR _AddPoint$[ebp]
  03b46	85 c0		 test	 eax, eax
  03b48	7c 2f		 jl	 SHORT $LN10@JGGetChara
  03b4a	0f bf 85 50 ff
	ff ff		 movsx	 eax, WORD PTR _AddPoint$[ebp]
  03b51	0f bf 8d 4c ff
	ff ff		 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  03b58	3b c1		 cmp	 eax, ecx
  03b5a	7f 1d		 jg	 SHORT $LN10@JGGetChara
  03b5c	0f bf 85 48 ff
	ff ff		 movsx	 eax, WORD PTR _MinusPoint$[ebp]
  03b63	85 c0		 test	 eax, eax
  03b65	7c 12		 jl	 SHORT $LN10@JGGetChara
  03b67	0f bf 85 48 ff
	ff ff		 movsx	 eax, WORD PTR _MinusPoint$[ebp]
  03b6e	0f bf 8d 44 ff
	ff ff		 movsx	 ecx, WORD PTR _MaxMinusPoint$[ebp]
  03b75	3b c1		 cmp	 eax, ecx
  03b77	7e 42		 jle	 SHORT $LN11@JGGetChara
$LN10@JGGetChara:

; 1752 : 	{
; 1753 : 		LogAddTD("[FRUIT System] Character Stat Error [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus:%d/MaxPlus:%d)", lpObj->AccountID, lpObj->Name, MinusPoint, AddPoint, MaxMinusPoint, MaxAddPoint);

  03b79	0f bf 85 4c ff
	ff ff		 movsx	 eax, WORD PTR _MaxAddPoint$[ebp]
  03b80	50		 push	 eax
  03b81	0f bf 8d 44 ff
	ff ff		 movsx	 ecx, WORD PTR _MaxMinusPoint$[ebp]
  03b88	51		 push	 ecx
  03b89	0f bf 95 50 ff
	ff ff		 movsx	 edx, WORD PTR _AddPoint$[ebp]
  03b90	52		 push	 edx
  03b91	0f bf 85 48 ff
	ff ff		 movsx	 eax, WORD PTR _MinusPoint$[ebp]
  03b98	50		 push	 eax
  03b99	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03b9f	83 c1 77	 add	 ecx, 119		; 00000077H
  03ba2	51		 push	 ecx
  03ba3	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  03ba9	83 c2 6c	 add	 edx, 108		; 0000006cH
  03bac	52		 push	 edx
  03bad	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@
  03bb2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03bb8	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN11@JGGetChara:

; 1754 : 	}
; 1755 : 
; 1756 : 	g_QuestInfo.QuestInfoSave(lpObj);

  03bbb	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03bc1	50		 push	 eax
  03bc2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  03bc7	e8 00 00 00 00	 call	 ?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestInfo::QuestInfoSave

; 1757 : 	
; 1758 : 	DataSend(aIndex, (LPBYTE)&pjMsg, pjMsg.h.size);

  03bcc	0f b6 45 8d	 movzx	 eax, BYTE PTR _pjMsg$[ebp+1]
  03bd0	50		 push	 eax
  03bd1	8d 4d 8c	 lea	 ecx, DWORD PTR _pjMsg$[ebp]
  03bd4	51		 push	 ecx
  03bd5	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _aIndex$[ebp]
  03bdb	52		 push	 edx
  03bdc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  03be1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1759 : 
; 1760 : 	GCItemListSend(aIndex);

  03be4	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03bea	50		 push	 eax
  03beb	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  03bf0	83 c4 04	 add	 esp, 4

; 1761 : 	GCMagicListMultiSend(lpObj, 0);

  03bf3	6a 00		 push	 0
  03bf5	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03bfb	50		 push	 eax
  03bfc	e8 00 00 00 00	 call	 ?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicListMultiSend
  03c01	83 c4 08	 add	 esp, 8

; 1762 : 
; 1763 : #ifdef PERIOD
; 1764 : 	g_PeriodItemEx.RequestPeriodItemInfo(lpObj);	//1.01.00

  03c04	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03c0a	50		 push	 eax
  03c0b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  03c10	e8 00 00 00 00	 call	 ?RequestPeriodItemInfo@CPeriodItemEx@@QAEXPAUOBJECTSTRUCT@@@Z ; CPeriodItemEx::RequestPeriodItemInfo

; 1765 : #endif
; 1766 : #ifdef LUCKYITEM
; 1767 : 	g_LuckyItemManager.GDReqLuckyItemSelect(lpObj);	//1.01.00

  03c15	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03c1b	50		 push	 eax
  03c1c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  03c21	e8 00 00 00 00	 call	 ?GDReqLuckyItemSelect@LuckyItemManager@@QAEXPAUOBJECTSTRUCT@@@Z ; LuckyItemManager::GDReqLuckyItemSelect

; 1768 : #endif
; 1769 : 
; 1770 : 	g_MasterLevelSystem.GDReqMasterLevelInfo(lpObj);

  03c26	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03c2c	50		 push	 eax
  03c2d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  03c32	e8 00 00 00 00	 call	 ?GDReqMasterLevelInfo@CMasterLevelSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::GDReqMasterLevelInfo

; 1771 : 
; 1772 : 	CGRequestQuestInfo(aIndex);

  03c37	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03c3d	50		 push	 eax
  03c3e	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  03c43	83 c4 04	 add	 esp, 4

; 1773 : 	
; 1774 : 	//Season 2.5 Quest New CALL
; 1775 : 	g_QuestUtil.Quest3rdRequestInfo(lpObj);

  03c46	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03c4c	50		 push	 eax
  03c4d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestUtil@@3VCQuestUtil@@A ; g_QuestUtil
  03c52	e8 00 00 00 00	 call	 ?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestUtil::Quest3rdRequestInfo

; 1776 : 
; 1777 : 	DGGuildMemberInfoRequest(aIndex);

  03c57	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03c5d	50		 push	 eax
  03c5e	e8 00 00 00 00	 call	 ?DGGuildMemberInfoRequest@@YAXH@Z ; DGGuildMemberInfoRequest
  03c63	83 c4 04	 add	 esp, 4

; 1778 : #if(FIX_LAND_OWNDER==TRUE)
; 1779 : 	lpObj->GuildLoadTick = 1;

  03c66	b8 01 00 00 00	 mov	 eax, 1
  03c6b	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03c71	66 89 81 10 29
	00 00		 mov	 WORD PTR [ecx+10512], ax

; 1780 : #endif
; 1781 : 	if(gGENS)

  03c78	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  03c7f	74 11		 je	 SHORT $LN9@JGGetChara

; 1782 : 	{
; 1783 : 		gGensSystem.ReqExDBGensInfo(lpObj);

  03c81	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03c87	50		 push	 eax
  03c88	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  03c8d	e8 00 00 00 00	 call	 ?ReqExDBGensInfo@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::ReqExDBGensInfo
$LN9@JGGetChara:

; 1784 : 		//gGensSystem.GDReqAbusingInfo(lpObj);
; 1785 : 		//Off for time
; 1786 : 		//gGensSystem.ReqGensRewardDay(lpObj);
; 1787 : 	}
; 1788 : 
; 1789 : 	if(g_ExLicense.user.WinQuest)

  03c92	0f b6 05 ca 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+202
  03c99	85 c0		 test	 eax, eax
  03c9b	74 11		 je	 SHORT $LN8@JGGetChara

; 1790 : 	{
; 1791 : 		gWinQuestSystem.ReqQuestInfo(lpObj);

  03c9d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03ca3	50		 push	 eax
  03ca4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWinQuestSystem@@3VcWinQuestSystem@@A ; gWinQuestSystem
  03ca9	e8 00 00 00 00	 call	 ?ReqQuestInfo@cWinQuestSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; cWinQuestSystem::ReqQuestInfo
$LN8@JGGetChara:

; 1792 : 	}
; 1793 : 
; 1794 : #ifdef MUHELPER
; 1795 : 	g_MUHelper.ReqMacro(lpObj->m_Index);

  03cae	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03cb4	8b 08		 mov	 ecx, DWORD PTR [eax]
  03cb6	51		 push	 ecx
  03cb7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MUHelper@@3VMUHelper@@A ; g_MUHelper
  03cbc	e8 00 00 00 00	 call	 ?ReqMacro@MUHelper@@QAEXH@Z ; MUHelper::ReqMacro

; 1796 : #endif
; 1797 : 
; 1798 : 	//g_ExGDManager.DB_Load(aIndex);
; 1799 : 
; 1800 : #if(CUSTOM_MARRIAGE)
; 1801 : 	g_Marriage.GDLoad(aIndex);

  03cc1	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03cc7	50		 push	 eax
  03cc8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Marriage@@3VCMarriage@@A ; g_Marriage
  03ccd	e8 00 00 00 00	 call	 ?GDLoad@CMarriage@@QAEXH@Z ; CMarriage::GDLoad

; 1802 : #endif
; 1803 : 
; 1804 : 	FriendListRequest(aIndex);

  03cd2	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03cd8	50		 push	 eax
  03cd9	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  03cde	83 c4 04	 add	 esp, 4

; 1805 : 
; 1806 : 	if ( gTamaJJangEvent != FALSE )

  03ce1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gTamaJJangEvent@@3HA, 0 ; gTamaJJangEvent
  03ce8	74 2e		 je	 SHORT $LN5@JGGetChara

; 1807 : 	{
; 1808 : 		if ( gAppearTamaJJang != 0 )

  03cea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gAppearTamaJJang@@3HA, 0 ; gAppearTamaJJang
  03cf1	74 25		 je	 SHORT $LN5@JGGetChara

; 1809 : 		{
; 1810 : 			if ( lpObj->MapNumber == MAP_INDEX_RORENCIA )

  03cf3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03cf9	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  03d00	85 c9		 test	 ecx, ecx
  03d02	75 14		 jne	 SHORT $LN5@JGGetChara

; 1811 : 			{
; 1812 : 				GCMapEventStateSend(MAP_INDEX_RORENCIA, gAppearTamaJJang, 2);

  03d04	6a 02		 push	 2
  03d06	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gAppearTamaJJang@@3HA
  03d0d	50		 push	 eax
  03d0e	6a 00		 push	 0
  03d10	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  03d15	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@JGGetChara:

; 1813 : 			}
; 1814 : 		}
; 1815 : 	}
; 1816 : 
; 1817 : 	gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  03d18	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03d1e	8b 08		 mov	 ecx, DWORD PTR [eax]
  03d20	51		 push	 ecx
  03d21	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  03d26	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 1818 : 
; 1819 : 	PMSG_QUESTSYSTEM_TEMP pResult;
; 1820 : 	pResult.h.set((LPBYTE)&pResult, 0xF6, 0x1A, sizeof(pResult));

  03d2b	6a 05		 push	 5
  03d2d	6a 1a		 push	 26			; 0000001aH
  03d2f	68 f6 00 00 00	 push	 246			; 000000f6H
  03d34	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  03d3a	50		 push	 eax
  03d3b	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  03d41	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 1821 : 	pResult.Result = NULL;

  03d46	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+4], 0

; 1822 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  03d4d	0f b6 85 3d ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  03d54	50		 push	 eax
  03d55	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  03d5b	51		 push	 ecx
  03d5c	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _aIndex$[ebp]
  03d62	52		 push	 edx
  03d63	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  03d68	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1823 : 
; 1824 : 	//if(g_ExLicense.user.Rage)
; 1825 : 	//{
; 1826 : 	//	gSystemOfRage.RageConnect(aIndex);
; 1827 : 	//}
; 1828 : 
; 1829 : 	GCServerMsgStringSend(gWelcomeMessage, lpObj->m_Index, 0);

  03d6b	6a 00		 push	 0
  03d6d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03d73	8b 08		 mov	 ecx, DWORD PTR [eax]
  03d75	51		 push	 ecx
  03d76	68 00 00 00 00	 push	 OFFSET ?gWelcomeMessage@@3PADA ; gWelcomeMessage
  03d7b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  03d80	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1830 : 
; 1831 : 	ExUserDataSend(aIndex);

  03d83	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03d89	50		 push	 eax
  03d8a	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  03d8f	83 c4 04	 add	 esp, 4

; 1832 : 
; 1833 : 	g_GMManager.ConnectAdmin(aIndex);

  03d92	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03d98	50		 push	 eax
  03d99	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GMManager@@3VGMManager@@A ; g_GMManager
  03d9e	e8 00 00 00 00	 call	 ?ConnectAdmin@GMManager@@QAEXH@Z ; GMManager::ConnectAdmin

; 1834 : 
; 1835 : #if(CUSTOM_NPC_BUFFER==TRUE)
; 1836 : 	//g_BufferSystem.UserConnect(aIndex);
; 1837 : #endif
; 1838 : 
; 1839 : #if(CUSTOM_NEWS==TRUE)
; 1840 : 	if( g_NewsBoard.m_ShowOnLogin )

  03da3	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR ?g_NewsBoard@@3VNewsBoard@@A+1
  03daa	85 c0		 test	 eax, eax
  03dac	74 11		 je	 SHORT $LN4@JGGetChara

; 1841 : 	{
; 1842 : 		g_NewsBoard.OpenMain(lpObj);

  03dae	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03db4	50		 push	 eax
  03db5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewsBoard@@3VNewsBoard@@A ; g_NewsBoard
  03dba	e8 00 00 00 00	 call	 ?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z ; NewsBoard::OpenMain
$LN4@JGGetChara:

; 1843 : 	}
; 1844 : #endif // NEWS_BOARD
; 1845 : 
; 1846 : //#if(ANTI_CHEAT_PLUS==TRUE)
; 1847 : //	g_AntiCheatPlus.GC_Cheat(aIndex);
; 1848 : //	g_AntiCheatPlus.CheckMultiWindow(aIndex);
; 1849 : //	g_AntiCheatPlus.CheckMaxWindow(aIndex);
; 1850 : //#endif
; 1851 : //
; 1852 : //#if(CUSTOM_SMITHY == TRUE)
; 1853 : //	g_Smithy.GCIemSend(aIndex);
; 1854 : //#endif
; 1855 : 
; 1856 : #if(CUSTOM_SAVE_PT==TRUE)
; 1857 : 	gParty.RestoreParty(aIndex);

  03dbf	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03dc5	50		 push	 eax
  03dc6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  03dcb	e8 00 00 00 00	 call	 ?RestoreParty@PartyClass@@QAEXH@Z ; PartyClass::RestoreParty

; 1858 : #endif
; 1859 : //#if(OFFLINE_MODE==TRUE)
; 1860 : //	if(g_ExLicense.user.OfflineMode)
; 1861 : //	{
; 1862 : //		g_OfflineMode.GCConfig(aIndex);
; 1863 : //	}
; 1864 : //#endif
; 1865 : #if(CUSTOM_PREMIUM_SYSTEM==TRUE)
; 1866 : 	g_PremiumSystemEx.UserConnect(aIndex);

  03dd0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03dd6	50		 push	 eax
  03dd7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PremiumSystemEx@@3VPremiumSystemEx@@A ; g_PremiumSystemEx
  03ddc	e8 00 00 00 00	 call	 ?UserConnect@PremiumSystemEx@@QAEXH@Z ; PremiumSystemEx::UserConnect

; 1867 : #endif
; 1868 : 
; 1869 : #if(_RECONNECT_)
; 1870 : 	if(g_ConnectEx.ConnectIndex == aIndex)
; 1871 : 	{
; 1872 : 		//g_ConnectEx.ConnectTick = 0;
; 1873 : 	}
; 1874 : #endif
; 1875 : 
; 1876 : 	if(Premium.CheckPremiumServer(aIndex) == false)

  03de1	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03de7	50		 push	 eax
  03de8	b9 00 00 00 00	 mov	 ecx, OFFSET ?Premium@@3VPremiumSystem@@A ; Premium
  03ded	e8 00 00 00 00	 call	 ?CheckPremiumServer@PremiumSystem@@QAE_NH@Z ; PremiumSystem::CheckPremiumServer
  03df2	0f b6 c8	 movzx	 ecx, al
  03df5	85 c9		 test	 ecx, ecx
  03df7	75 13		 jne	 SHORT $LN2@JGGetChara

; 1877 : 	{
; 1878 : 		#if(_RECONNECT_)
; 1879 : 		g_ConnectEx.SendClose(aIndex, NORM_DC);

  03df9	6a 00		 push	 0
  03dfb	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03e01	50		 push	 eax
  03e02	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectEx@@3VConnectEx@@A ; g_ConnectEx
  03e07	e8 00 00 00 00	 call	 ?SendClose@ConnectEx@@QAEXHH@Z ; ConnectEx::SendClose
$LN2@JGGetChara:

; 1880 : 		#else
; 1881 : 		CloseClient(aIndex);
; 1882 : 		#endif
; 1883 : 	}
; 1884 : #if(CONFIG_WAITOPEN)
; 1885 : 	if(g_WaitOpen == true)

  03e0c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?g_WaitOpen@@3_NA ; g_WaitOpen
  03e13	83 f8 01	 cmp	 eax, 1
  03e16	75 15		 jne	 SHORT $LN1@JGGetChara

; 1886 : 	{
; 1887 : #if(_RECONNECT_)
; 1888 : 		g_ConnectEx.SendClose(aIndex, NORM_DC);

  03e18	6a 00		 push	 0
  03e1a	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03e20	50		 push	 eax
  03e21	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectEx@@3VConnectEx@@A ; g_ConnectEx
  03e26	e8 00 00 00 00	 call	 ?SendClose@ConnectEx@@QAEXHH@Z ; ConnectEx::SendClose

; 1889 : #else
; 1890 : 		CloseClient(aIndex);
; 1891 : #endif
; 1892 : 		return;

  03e2b	eb 33		 jmp	 SHORT $LN32@JGGetChara
$LN1@JGGetChara:

; 1893 : 	}
; 1894 : #endif
; 1895 : #if(EVENT_DUNGEON_SIEGE)
; 1896 : 	g_DungeonSiege.GCPlayerConnect(aIndex);

  03e2d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  03e33	50		 push	 eax
  03e34	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  03e39	e8 00 00 00 00	 call	 ?GCPlayerConnect@CDungeonSiege@@QAEXH@Z ; CDungeonSiege::GCPlayerConnect

; 1897 : #endif
; 1898 : 
; 1899 : //#if(CUSTOM_MAPQUEST)
; 1900 : //	g_MapQuest.TeleportMap(lpObj->m_Index, lpObj->MapNumber);
; 1901 : //#endif
; 1902 : 
; 1903 : 	lpObj->m_iLoadConfigNumber = 1;

  03e3e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03e44	c7 80 d4 2a 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+10964], 1

; 1904 : 	lpObj->m_iLoadConfigTickCount = GetTickCount();

  03e4e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  03e54	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03e5a	89 81 d8 2a 00
	00		 mov	 DWORD PTR [ecx+10968], eax
$LN32@JGGetChara:

; 1905 : }

  03e60	5f		 pop	 edi
  03e61	5e		 pop	 esi
  03e62	5b		 pop	 ebx
  03e63	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  03e66	33 cd		 xor	 ecx, ebp
  03e68	e8 00 00 00 00	 call	 @__security_check_cookie@4
  03e6d	8b e5		 mov	 esp, ebp
  03e6f	5d		 pop	 ebp
  03e70	c3		 ret	 0
?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ENDP ; JGGetCharacterInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	__chkstk:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
_TEXT	SEGMENT
_n$245855 = -4144					; size = 4
_itemcount$ = -4140					; size = 4
_lpObj$ = -4136						; size = 4
_sendBuf$ = -4132					; size = 4096
_pMsgILSize$ = -36					; size = 4
_sOfs$ = -32						; size = 4
_pMsgIL$ = -28						; size = 13
_pMsgILC$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCItemListSend@@YAXH@Z PROC				; GCItemListSend

; 1930 : {

  03e80	55		 push	 ebp
  03e81	8b ec		 mov	 ebp, esp
  03e83	b8 70 10 00 00	 mov	 eax, 4208		; 00001070H
  03e88	e8 00 00 00 00	 call	 __chkstk
  03e8d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  03e92	33 c5		 xor	 eax, ebp
  03e94	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  03e97	53		 push	 ebx
  03e98	56		 push	 esi
  03e99	57		 push	 edi

; 1931 : 	PMSG_INVENTORYLISTCOUNT pMsgILC;	// Packet Message Item List Count
; 1932 : 	PMSG_INVENTORYLIST pMsgIL;	// Packet Message Item List
; 1933 : 	int sOfs = sizeof(PMSG_INVENTORYLISTCOUNT);

  03e9a	c7 45 e0 06 00
	00 00		 mov	 DWORD PTR _sOfs$[ebp], 6

; 1934 : 	int pMsgILSize = sizeof(PMSG_INVENTORYLIST);

  03ea1	c7 45 dc 0d 00
	00 00		 mov	 DWORD PTR _pMsgILSize$[ebp], 13 ; 0000000dH

; 1935 : 	BYTE sendBuf[WAREHOUSE_BUFF];
; 1936 : 	LPOBJ lpObj = &gObj[aIndex];

  03ea8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03eab	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03eb1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03eb7	89 85 d8 ef ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax

; 1937 : 	int itemcount = 0;

  03ebd	c7 85 d4 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _itemcount$[ebp], 0

; 1938 : 	
; 1939 : 	for ( int n=0;n<INVENTORY_SIZE;n++)

  03ec7	c7 85 d0 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$245855[ebp], 0
  03ed1	eb 0f		 jmp	 SHORT $LN5@GCItemList
$LN4@GCItemList:
  03ed3	8b 85 d0 ef ff
	ff		 mov	 eax, DWORD PTR _n$245855[ebp]
  03ed9	83 c0 01	 add	 eax, 1
  03edc	89 85 d0 ef ff
	ff		 mov	 DWORD PTR _n$245855[ebp], eax
$LN5@GCItemList:
  03ee2	81 bd d0 ef ff
	ff ec 00 00 00	 cmp	 DWORD PTR _n$245855[ebp], 236 ; 000000ecH
  03eec	0f 8d c5 00 00
	00		 jge	 $LN3@GCItemList

; 1940 : 	{
; 1941 : 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  03ef2	8b 8d d0 ef ff
	ff		 mov	 ecx, DWORD PTR _n$245855[ebp]
  03ef8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03efe	8b 85 d8 ef ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  03f04	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  03f0a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  03f0f	83 f8 01	 cmp	 eax, 1
  03f12	0f 85 9a 00 00
	00		 jne	 $LN2@GCItemList

; 1942 : 		{
; 1943 : 			if ( lpObj->pInventory[n].m_bItemExist == false )

  03f18	8b 85 d0 ef ff
	ff		 mov	 eax, DWORD PTR _n$245855[ebp]
  03f1e	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  03f24	8b 8d d8 ef ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03f2a	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03f30	0f b6 84 02 88
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+136]
  03f38	85 c0		 test	 eax, eax
  03f3a	75 02		 jne	 SHORT $LN1@GCItemList

; 1944 : 			{
; 1945 : 				continue;

  03f3c	eb 95		 jmp	 SHORT $LN4@GCItemList
$LN1@GCItemList:

; 1946 : 			}
; 1947 : 
; 1948 : 			pMsgIL.Pos = n;

  03f3e	8a 85 d0 ef ff
	ff		 mov	 al, BYTE PTR _n$245855[ebp]
  03f44	88 45 e4	 mov	 BYTE PTR _pMsgIL$[ebp], al

; 1949 : 
; 1950 : 			ItemByteConvert(pMsgIL.ItemInfo,lpObj->pInventory[n]);

  03f47	8b 85 d0 ef ff
	ff		 mov	 eax, DWORD PTR _n$245855[ebp]
  03f4d	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  03f53	8b 8d d8 ef ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03f59	8b b1 24 0e 00
	00		 mov	 esi, DWORD PTR [ecx+3620]
  03f5f	03 f0		 add	 esi, eax
  03f61	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  03f67	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  03f6c	8b fc		 mov	 edi, esp
  03f6e	f3 a5		 rep movsd
  03f70	8d 55 e5	 lea	 edx, DWORD PTR _pMsgIL$[ebp+1]
  03f73	52		 push	 edx
  03f74	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  03f79	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 1951 : 
; 1952 : 			memcpy(&sendBuf[sOfs], &pMsgIL, pMsgILSize);

  03f7f	8b 45 dc	 mov	 eax, DWORD PTR _pMsgILSize$[ebp]
  03f82	50		 push	 eax
  03f83	8d 4d e4	 lea	 ecx, DWORD PTR _pMsgIL$[ebp]
  03f86	51		 push	 ecx
  03f87	8b 55 e0	 mov	 edx, DWORD PTR _sOfs$[ebp]
  03f8a	8d 84 15 dc ef
	ff ff		 lea	 eax, DWORD PTR _sendBuf$[ebp+edx]
  03f91	50		 push	 eax
  03f92	e8 00 00 00 00	 call	 _memcpy
  03f97	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1953 : 			itemcount++;

  03f9a	8b 85 d4 ef ff
	ff		 mov	 eax, DWORD PTR _itemcount$[ebp]
  03fa0	83 c0 01	 add	 eax, 1
  03fa3	89 85 d4 ef ff
	ff		 mov	 DWORD PTR _itemcount$[ebp], eax

; 1954 : 			sOfs += pMsgILSize;

  03fa9	8b 45 e0	 mov	 eax, DWORD PTR _sOfs$[ebp]
  03fac	03 45 dc	 add	 eax, DWORD PTR _pMsgILSize$[ebp]
  03faf	89 45 e0	 mov	 DWORD PTR _sOfs$[ebp], eax
$LN2@GCItemList:

; 1955 : 		}
; 1956 : 	}

  03fb2	e9 1c ff ff ff	 jmp	 $LN4@GCItemList
$LN3@GCItemList:

; 1957 : 
; 1958 : 	pMsgILC.h.c = 0xC4;

  03fb7	c6 45 f4 c4	 mov	 BYTE PTR _pMsgILC$[ebp], 196 ; 000000c4H

; 1959 : 	pMsgILC.h.headcode = 0xF3;

  03fbb	c6 45 f7 f3	 mov	 BYTE PTR _pMsgILC$[ebp+3], 243 ; 000000f3H

; 1960 : 	pMsgILC.subcode = 0x10;

  03fbf	c6 45 f8 10	 mov	 BYTE PTR _pMsgILC$[ebp+4], 16 ; 00000010H

; 1961 : 	pMsgILC.h.sizeH = SET_NUMBERH(sOfs);

  03fc3	8b 45 e0	 mov	 eax, DWORD PTR _sOfs$[ebp]
  03fc6	c1 e8 08	 shr	 eax, 8
  03fc9	88 45 f5	 mov	 BYTE PTR _pMsgILC$[ebp+1], al

; 1962 : 	pMsgILC.h.sizeL = SET_NUMBERL(sOfs);

  03fcc	8b 45 e0	 mov	 eax, DWORD PTR _sOfs$[ebp]
  03fcf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03fd4	88 45 f6	 mov	 BYTE PTR _pMsgILC$[ebp+2], al

; 1963 : 	pMsgILC.Count = itemcount;

  03fd7	8a 85 d4 ef ff
	ff		 mov	 al, BYTE PTR _itemcount$[ebp]
  03fdd	88 45 f9	 mov	 BYTE PTR _pMsgILC$[ebp+5], al

; 1964 : 	memcpy(sendBuf, &pMsgILC, sizeof(PMSG_INVENTORYLISTCOUNT));

  03fe0	6a 06		 push	 6
  03fe2	8d 45 f4	 lea	 eax, DWORD PTR _pMsgILC$[ebp]
  03fe5	50		 push	 eax
  03fe6	8d 8d dc ef ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  03fec	51		 push	 ecx
  03fed	e8 00 00 00 00	 call	 _memcpy
  03ff2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1965 : 
; 1966 : 	DataSend(aIndex, sendBuf, sOfs);

  03ff5	8b 45 e0	 mov	 eax, DWORD PTR _sOfs$[ebp]
  03ff8	50		 push	 eax
  03ff9	8d 8d dc ef ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  03fff	51		 push	 ecx
  04000	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  04003	52		 push	 edx
  04004	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  04009	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1967 : }

  0400c	5f		 pop	 edi
  0400d	5e		 pop	 esi
  0400e	5b		 pop	 ebx
  0400f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  04012	33 cd		 xor	 ecx, ebp
  04014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  04019	8b e5		 mov	 esp, ebp
  0401b	5d		 pop	 ebp
  0401c	c3		 ret	 0
?GCItemListSend@@YAXH@Z ENDP				; GCItemListSend
_TEXT	ENDS
PUBLIC	?gObjSavePetItemInfo@@YAXHH@Z			; gObjSavePetItemInfo
PUBLIC	__real@4024000000000000
PUBLIC	?GDSetWarehouseList@@YAXH@Z			; GDSetWarehouseList
PUBLIC	??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@ ; `string'
PUBLIC	??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z	; GJSetCharacterInfo
EXTRN	?DB_Save@CExGDManager@@QAEXH@Z:PROC		; CExGDManager::DB_Save
EXTRN	?DGSendInformation@cWinQuestSystem@@QAEXH@Z:PROC ; cWinQuestSystem::DGSendInformation
EXTRN	?SendSaveData@cSystemOfRage@@QAEXH@Z:PROC	; cSystemOfRage::SendSaveData
EXTRN	?gSystemOfRage@@3VcSystemOfRage@@A:BYTE		; gSystemOfRage
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?GDReqSaveContributePoint@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::GDReqSaveContributePoint
EXTRN	?GDRequestMasterLevelInfoSave@CMasterLevelSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::GDRequestMasterLevelInfoSave
EXTRN	?Quest3rdSaveInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestUtil::Quest3rdSaveInfo
EXTRN	?GDReqLuckyItemInsert2nd@LuckyItemManager@@QAEXH@Z:PROC ; LuckyItemManager::GDReqLuckyItemInsert2nd
EXTRN	?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjStatTextSave
EXTRN	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z:PROC	; MagicByteConvert
EXTRN	?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z:PROC	; ItemByteConvert16
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@
CONST	SEGMENT
??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@ DB '['
	DB	'MapServerMng][%s][%s] GJSetCharacterInfo() - MapServerMove Ch'
	DB	'aracter Save Start (%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@
CONST	SEGMENT
??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@ DB '[MapServe'
	DB	'rMng] GJSetCharacterInfo() - Inventory Already Saved [%s][%s]'
	DB	' (%d)', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv434 = -4552						; size = 4
tv426 = -4552						; size = 4
tv418 = -4552						; size = 4
tv410 = -4552						; size = 4
tv432 = -4548						; size = 4
tv424 = -4548						; size = 4
tv416 = -4548						; size = 4
tv408 = -4548						; size = 4
tv429 = -4542						; size = 2
tv421 = -4542						; size = 2
tv413 = -4542						; size = 2
tv405 = -4542						; size = 2
_pCSave$ = -4476					; size = 4472
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_bMapServerMove$ = 16					; size = 4
?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z PROC	; GJSetCharacterInfo

; 2042 : {

  04020	55		 push	 ebp
  04021	8b ec		 mov	 ebp, esp
  04023	b8 c8 11 00 00	 mov	 eax, 4552		; 000011c8H
  04028	e8 00 00 00 00	 call	 __chkstk
  0402d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  04032	33 c5		 xor	 eax, ebp
  04034	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  04037	53		 push	 ebx
  04038	56		 push	 esi
  04039	57		 push	 edi

; 2043 : 	if ( lpObj->m_bMapSvrMoveQuit == true )

  0403a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0403d	0f b6 88 e4 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+7140]
  04044	83 f9 01	 cmp	 ecx, 1
  04047	75 29		 jne	 SHORT $LN10@GJSetChara

; 2044 : 	{
; 2045 : 		LogAddC(2,"[MapServerMng] GJSetCharacterInfo() - Inventory Already Saved [%s][%s] (%d)",
; 2046 : 			lpObj->AccountID, lpObj->Name, lpObj->m_Index);

  04049	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0404c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0404e	51		 push	 ecx
  0404f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  04052	83 c2 77	 add	 edx, 119		; 00000077H
  04055	52		 push	 edx
  04056	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04059	83 c0 6c	 add	 eax, 108		; 0000006cH
  0405c	50		 push	 eax
  0405d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@
  04062	6a 02		 push	 2
  04064	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0406a	83 c4 14	 add	 esp, 20			; 00000014H

; 2047 : 
; 2048 : 		return;

  0406d	e9 c8 05 00 00	 jmp	 $LN11@GJSetChara
$LN10@GJSetChara:

; 2049 : 	}
; 2050 : 
; 2051 : 	if ( bMapServerMove == TRUE )

  04072	83 7d 10 01	 cmp	 DWORD PTR _bMapServerMove$[ebp], 1
  04076	75 2e		 jne	 SHORT $LN9@GJSetChara

; 2052 : 	{
; 2053 : 		lpObj->m_bMapSvrMoveQuit = TRUE;

  04078	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0407b	c6 80 e4 1b 00
	00 01		 mov	 BYTE PTR [eax+7140], 1

; 2054 : 
; 2055 : 		LogAddC(5, "[MapServerMng][%s][%s] GJSetCharacterInfo() - MapServerMove Character Save Start (%d)",
; 2056 : 			lpObj->AccountID, lpObj->Name, lpObj->m_Index);

  04082	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04085	8b 08		 mov	 ecx, DWORD PTR [eax]
  04087	51		 push	 ecx
  04088	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0408b	83 c2 77	 add	 edx, 119		; 00000077H
  0408e	52		 push	 edx
  0408f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04092	83 c0 6c	 add	 eax, 108		; 0000006cH
  04095	50		 push	 eax
  04096	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@
  0409b	6a 05		 push	 5
  0409d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  040a3	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@GJSetChara:

; 2057 : 	}
; 2058 : 
; 2059 : 
; 2060 : 	if ( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type == 6 && lpObj->m_IfState.state == 1)

  040a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  040a9	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  040af	83 e1 03	 and	 ecx, 3
  040b2	76 37		 jbe	 SHORT $LN8@GJSetChara
  040b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  040b7	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  040bd	c1 e9 06	 shr	 ecx, 6
  040c0	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  040c6	83 f9 06	 cmp	 ecx, 6
  040c9	75 20		 jne	 SHORT $LN8@GJSetChara
  040cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  040ce	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  040d4	c1 e9 02	 shr	 ecx, 2
  040d7	83 e1 0f	 and	 ecx, 15			; 0000000fH
  040da	83 f9 01	 cmp	 ecx, 1
  040dd	75 0c		 jne	 SHORT $LN8@GJSetChara

; 2061 : 	{
; 2062 : 		GDSetWarehouseList(aIndex);

  040df	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  040e2	50		 push	 eax
  040e3	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList
  040e8	83 c4 04	 add	 esp, 4
$LN8@GJSetChara:

; 2063 : 	}
; 2064 : 
; 2065 : 	if ( szAuthKey[1] != AUTHKEY1 )

  040eb	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szAuthKey@@3PADA+1
  040f2	83 f8 23	 cmp	 eax, 35			; 00000023H
  040f5	74 05		 je	 SHORT $LN7@GJSetChara

; 2066 : 	{
; 2067 : 		DestroyGIocp();

  040f7	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN7@GJSetChara:

; 2068 : 	}
; 2069 : 
; 2070 : 	SDHP_DBCHAR_INFOSAVE pCSave;
; 2071 :  
; 2072 : 	pCSave.h.c = 0xC2;

  040fc	c6 85 84 ee ff
	ff c2		 mov	 BYTE PTR _pCSave$[ebp], 194 ; 000000c2H

; 2073 : 	pCSave.h.headcode = 0x07;

  04103	c6 85 87 ee ff
	ff 07		 mov	 BYTE PTR _pCSave$[ebp+3], 7

; 2074 : 	pCSave.h.sizeH = sizeof(SDHP_DBCHAR_INFOSAVE) >> 8;

  0410a	c6 85 85 ee ff
	ff 11		 mov	 BYTE PTR _pCSave$[ebp+1], 17 ; 00000011H

; 2075 : 	pCSave.h.sizeL = sizeof(SDHP_DBCHAR_INFOSAVE) & 0xFF;

  04111	c6 85 86 ee ff
	ff 78		 mov	 BYTE PTR _pCSave$[ebp+2], 120 ; 00000078H

; 2076 : 
; 2077 : 
; 2078 : 	pCSave.AccountID[MAX_ACCOUNT_LEN] = 0;

  04118	c6 85 92 ee ff
	ff 00		 mov	 BYTE PTR _pCSave$[ebp+14], 0

; 2079 : 	memcpy(pCSave.AccountID, lpObj->AccountID, sizeof(pCSave.AccountID)-1);

  0411f	6a 0a		 push	 10			; 0000000aH
  04121	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04124	83 c0 6c	 add	 eax, 108		; 0000006cH
  04127	50		 push	 eax
  04128	8d 8d 88 ee ff
	ff		 lea	 ecx, DWORD PTR _pCSave$[ebp+4]
  0412e	51		 push	 ecx
  0412f	e8 00 00 00 00	 call	 _memcpy
  04134	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2080 : 	pCSave.Name[MAX_ACCOUNT_LEN] = 0;

  04137	c6 85 9d ee ff
	ff 00		 mov	 BYTE PTR _pCSave$[ebp+25], 0

; 2081 : 	memcpy(pCSave.Name, lpObj->Name, sizeof(pCSave.Name)-1);

  0413e	6a 0a		 push	 10			; 0000000aH
  04140	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04143	83 c0 77	 add	 eax, 119		; 00000077H
  04146	50		 push	 eax
  04147	8d 8d 93 ee ff
	ff		 lea	 ecx, DWORD PTR _pCSave$[ebp+15]
  0414d	51		 push	 ecx
  0414e	e8 00 00 00 00	 call	 _memcpy
  04153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2082 : 	pCSave.Brother[MAX_ACCOUNT_LEN] = 0;

  04156	c6 45 ee 00	 mov	 BYTE PTR _pCSave$[ebp+4458], 0

; 2083 : 	memcpy(pCSave.Brother, lpObj->Brotherhood, sizeof(pCSave.Brother)-1);

  0415a	6a 0a		 push	 10			; 0000000aH
  0415c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0415f	05 69 28 00 00	 add	 eax, 10345		; 00002869H
  04164	50		 push	 eax
  04165	8d 4d e4	 lea	 ecx, DWORD PTR _pCSave$[ebp+4448]
  04168	51		 push	 ecx
  04169	e8 00 00 00 00	 call	 _memcpy
  0416e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2084 : 
; 2085 : 	pCSave.Class = lpObj->DbClass;

  04171	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04174	8a 88 ba 00 00
	00		 mov	 cl, BYTE PTR [eax+186]
  0417a	88 8d a0 ee ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+28], cl

; 2086 : 	pCSave.Level = lpObj->Level;

  04180	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04183	66 8b 88 be 00
	00 00		 mov	 cx, WORD PTR [eax+190]
  0418a	66 89 8d 9e ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+26], cx

; 2087 : 	pCSave.LevelUpPoint = lpObj->LevelUpPoint;

  04191	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04194	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0419a	89 8d a4 ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+32], ecx

; 2088 : 	pCSave.Exp = lpObj->Experience;

  041a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  041a3	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  041a9	89 8d a8 ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+36], ecx

; 2089 : 	pCSave.NextExp = lpObj->NextExp;

  041af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  041b2	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  041b8	89 8d ac ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+40], ecx

; 2090 : 	pCSave.Money = lpObj->Money;

  041be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  041c1	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  041c7	89 8d b0 ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+44], ecx

; 2091 : 	pCSave.Str = lpObj->Strength;

  041cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  041d0	66 8b 88 f4 00
	00 00		 mov	 cx, WORD PTR [eax+244]
  041d7	66 89 8d b4 ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+48], cx

; 2092 : 	pCSave.Dex = lpObj->Dexterity;

  041de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  041e1	66 8b 88 f6 00
	00 00		 mov	 cx, WORD PTR [eax+246]
  041e8	66 89 8d b6 ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+50], cx

; 2093 : 	pCSave.Vit = lpObj->Vitality;

  041ef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  041f2	66 8b 88 f8 00
	00 00		 mov	 cx, WORD PTR [eax+248]
  041f9	66 89 8d b8 ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+52], cx

; 2094 : 	pCSave.Energy = lpObj->Energy;

  04200	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04203	66 8b 88 fa 00
	00 00		 mov	 cx, WORD PTR [eax+250]
  0420a	66 89 8d ba ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+54], cx

; 2095 : 	pCSave.Life = (WORD)(lpObj->Life*10.0f);

  04211	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04214	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  0421a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  04220	d9 bd 42 ee ff
	ff		 fnstcw	 WORD PTR tv405[ebp]
  04226	0f b7 85 42 ee
	ff ff		 movzx	 eax, WORD PTR tv405[ebp]
  0422d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  04232	89 85 3c ee ff
	ff		 mov	 DWORD PTR tv408[ebp], eax
  04238	d9 ad 3c ee ff
	ff		 fldcw	 WORD PTR tv408[ebp]
  0423e	db 9d 38 ee ff
	ff		 fistp	 DWORD PTR tv410[ebp]
  04244	d9 ad 42 ee ff
	ff		 fldcw	 WORD PTR tv405[ebp]
  0424a	66 8b 8d 38 ee
	ff ff		 mov	 cx, WORD PTR tv410[ebp]
  04251	66 89 8d bc ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+56], cx

; 2096 : 	pCSave.MaxLife =(WORD)(lpObj->MaxLife*10.0f);

  04258	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0425b	d9 80 00 01 00
	00		 fld	 DWORD PTR [eax+256]
  04261	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  04267	d9 bd 42 ee ff
	ff		 fnstcw	 WORD PTR tv413[ebp]
  0426d	0f b7 85 42 ee
	ff ff		 movzx	 eax, WORD PTR tv413[ebp]
  04274	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  04279	89 85 3c ee ff
	ff		 mov	 DWORD PTR tv416[ebp], eax
  0427f	d9 ad 3c ee ff
	ff		 fldcw	 WORD PTR tv416[ebp]
  04285	db 9d 38 ee ff
	ff		 fistp	 DWORD PTR tv418[ebp]
  0428b	d9 ad 42 ee ff
	ff		 fldcw	 WORD PTR tv413[ebp]
  04291	66 8b 8d 38 ee
	ff ff		 mov	 cx, WORD PTR tv418[ebp]
  04298	66 89 8d be ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+58], cx

; 2097 : 	pCSave.Mana = (WORD)(lpObj->Mana*10.0f);

  0429f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  042a2	d9 80 10 01 00
	00		 fld	 DWORD PTR [eax+272]
  042a8	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  042ae	d9 bd 42 ee ff
	ff		 fnstcw	 WORD PTR tv421[ebp]
  042b4	0f b7 85 42 ee
	ff ff		 movzx	 eax, WORD PTR tv421[ebp]
  042bb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  042c0	89 85 3c ee ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
  042c6	d9 ad 3c ee ff
	ff		 fldcw	 WORD PTR tv424[ebp]
  042cc	db 9d 38 ee ff
	ff		 fistp	 DWORD PTR tv426[ebp]
  042d2	d9 ad 42 ee ff
	ff		 fldcw	 WORD PTR tv421[ebp]
  042d8	66 8b 8d 38 ee
	ff ff		 mov	 cx, WORD PTR tv426[ebp]
  042df	66 89 8d c0 ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+60], cx

; 2098 : 	pCSave.MaxMana = (WORD)(lpObj->MaxMana*10.0f);

  042e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  042e9	d9 80 14 01 00
	00		 fld	 DWORD PTR [eax+276]
  042ef	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  042f5	d9 bd 42 ee ff
	ff		 fnstcw	 WORD PTR tv429[ebp]
  042fb	0f b7 85 42 ee
	ff ff		 movzx	 eax, WORD PTR tv429[ebp]
  04302	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  04307	89 85 3c ee ff
	ff		 mov	 DWORD PTR tv432[ebp], eax
  0430d	d9 ad 3c ee ff
	ff		 fldcw	 WORD PTR tv432[ebp]
  04313	db 9d 38 ee ff
	ff		 fistp	 DWORD PTR tv434[ebp]
  04319	d9 ad 42 ee ff
	ff		 fldcw	 WORD PTR tv429[ebp]
  0431f	66 8b 8d 38 ee
	ff ff		 mov	 cx, WORD PTR tv434[ebp]
  04326	66 89 8d c2 ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+62], cx

; 2099 : 	ItemByteConvert16((LPBYTE)pCSave.dbInventory , lpObj->pInventory, INVENTORY_SIZE);

  0432d	68 ec 00 00 00	 push	 236			; 000000ecH
  04332	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04335	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0433b	51		 push	 ecx
  0433c	8d 95 c4 ee ff
	ff		 lea	 edx, DWORD PTR _pCSave$[ebp+64]
  04342	52		 push	 edx
  04343	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16
  04348	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2100 : 	MagicByteConvert(pCSave.dbMagicList, lpObj->Magic, MAGIC_SIZE);

  0434b	68 96 00 00 00	 push	 150			; 00000096H
  04350	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04353	8b 88 c8 04 00
	00		 mov	 ecx, DWORD PTR [eax+1224]
  04359	51		 push	 ecx
  0435a	8d 95 84 fd ff
	ff		 lea	 edx, DWORD PTR _pCSave$[ebp+3840]
  04360	52		 push	 edx
  04361	e8 00 00 00 00	 call	 ?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z ; MagicByteConvert
  04366	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2101 : 	pCSave.MapNumber = lpObj->MapNumber;

  04369	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0436c	8a 88 49 01 00
	00		 mov	 cl, BYTE PTR [eax+329]
  04372	88 8d 46 ff ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+4290], cl

; 2102 : 	pCSave.MapX = lpObj->X;

  04378	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0437b	8a 88 44 01 00
	00		 mov	 cl, BYTE PTR [eax+324]
  04381	88 8d 47 ff ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+4291], cl

; 2103 : 	pCSave.MapY = lpObj->Y;

  04387	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0438a	8a 88 46 01 00
	00		 mov	 cl, BYTE PTR [eax+326]
  04390	88 8d 48 ff ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+4292], cl

; 2104 : 	pCSave.Dir = lpObj->Dir;

  04396	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04399	8a 88 48 01 00
	00		 mov	 cl, BYTE PTR [eax+328]
  0439f	88 8d 49 ff ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+4293], cl

; 2105 : 	pCSave.PkCount = lpObj->m_PK_Count;

  043a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043a8	0f be 88 3c 01
	00 00		 movsx	 ecx, BYTE PTR [eax+316]
  043af	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+4296], ecx

; 2106 : 	pCSave.PkLevel = lpObj->m_PK_Level;

  043b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043b8	0f be 88 3d 01
	00 00		 movsx	 ecx, BYTE PTR [eax+317]
  043bf	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+4300], ecx

; 2107 : 	pCSave.PkTime = lpObj->m_PK_Time;

  043c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043c8	8b 88 40 01 00
	00		 mov	 ecx, DWORD PTR [eax+320]
  043ce	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+4304], ecx

; 2108 : 	pCSave.Leadership = lpObj->Leadership;

  043d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043d7	66 8b 88 18 01
	00 00		 mov	 cx, WORD PTR [eax+280]
  043de	66 89 4d 8c	 mov	 WORD PTR _pCSave$[ebp+4360], cx

; 2109 : 	pCSave.ChatLitmitTime = lpObj->ChatLitmitTime;

  043e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043e5	66 8b 88 1c 01
	00 00		 mov	 cx, WORD PTR [eax+284]
  043ec	66 89 4d 8e	 mov	 WORD PTR _pCSave$[ebp+4362], cx

; 2110 : 	pCSave.iFruitPoint = lpObj->iFruitPoint;

  043f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043f3	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  043f9	89 4d 90	 mov	 DWORD PTR _pCSave$[ebp+4364], ecx

; 2111 : 	pCSave.PCPoint = lpObj->PCPoint;

  043fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  043ff	8b 88 88 22 00
	00		 mov	 ecx, DWORD PTR [eax+8840]
  04405	89 4d 94	 mov	 DWORD PTR _pCSave$[ebp+4368], ecx

; 2112 : 	pCSave.ExFreePoints = lpObj->ExFreePoints;

  04408	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0440b	8b 88 8c 22 00
	00		 mov	 ecx, DWORD PTR [eax+8844]
  04411	89 4d 98	 mov	 DWORD PTR _pCSave$[ebp+4372], ecx

; 2113 : 	pCSave.Reset = lpObj->Reset;

  04414	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04417	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0441d	89 4d 9c	 mov	 DWORD PTR _pCSave$[ebp+4376], ecx

; 2114 : 	pCSave.GReset = lpObj->GReset;

  04420	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04423	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  04429	89 4d a0	 mov	 DWORD PTR _pCSave$[ebp+4380], ecx

; 2115 : 	pCSave.ExQuestNum = lpObj->ExQuestNum;

  0442c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0442f	8b 88 b0 22 00
	00		 mov	 ecx, DWORD PTR [eax+8880]
  04435	89 4d a4	 mov	 DWORD PTR _pCSave$[ebp+4384], ecx

; 2116 : 	pCSave.ExQuestKill = lpObj->ExQuestKill;

  04438	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0443b	8b 88 b4 22 00
	00		 mov	 ecx, DWORD PTR [eax+8884]
  04441	89 4d a8	 mov	 DWORD PTR _pCSave$[ebp+4388], ecx

; 2117 : 
; 2118 : 	//if(g_ExLicense.CheckUser(SILVER1) || g_ExLicense.CheckUser(SILVER2))
; 2119 : 	//{
; 2120 : 	//	pCSave.PremiumTime = time(NULL) + lpObj->PremiumTime;
; 2121 : 	//}
; 2122 : 	//else
; 2123 : 	//{
; 2124 : 		pCSave.PremiumTime = lpObj->PremiumTime;

  04444	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04447	8b 88 b8 22 00
	00		 mov	 ecx, DWORD PTR [eax+8888]
  0444d	89 4d ac	 mov	 DWORD PTR _pCSave$[ebp+4392], ecx

; 2125 : 	//}
; 2126 : 
; 2127 : #ifdef PREM_TYPE
; 2128 : 	pCSave.PremiumTimeType = lpObj->PremiumTimeType;

  04450	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04453	8b 88 bc 22 00
	00		 mov	 ecx, DWORD PTR [eax+8892]
  04459	89 4d b0	 mov	 DWORD PTR _pCSave$[ebp+4396], ecx

; 2129 : #endif
; 2130 : 	pCSave.ExCred = lpObj->ExCred;

  0445c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0445f	d9 80 a8 22 00
	00		 fld	 DWORD PTR [eax+8872]
  04465	d9 5d b4	 fstp	 DWORD PTR _pCSave$[ebp+4400]

; 2131 : 	pCSave.BanChat = lpObj->BanChat;

  04468	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0446b	8b 88 b4 27 00
	00		 mov	 ecx, DWORD PTR [eax+10164]
  04471	89 4d b8	 mov	 DWORD PTR _pCSave$[ebp+4404], ecx

; 2132 : 	pCSave.BanPost = lpObj->BanPost;

  04474	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04477	8b 88 b8 27 00
	00		 mov	 ecx, DWORD PTR [eax+10168]
  0447d	89 4d bc	 mov	 DWORD PTR _pCSave$[ebp+4408], ecx

; 2133 : 	pCSave.BanChar = lpObj->BanChar;

  04480	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04483	8b 88 bc 27 00
	00		 mov	 ecx, DWORD PTR [eax+10172]
  04489	89 4d c0	 mov	 DWORD PTR _pCSave$[ebp+4412], ecx

; 2134 : 	pCSave.ChaosBank = lpObj->ChaosBank;

  0448c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0448f	8b 88 e0 27 00
	00		 mov	 ecx, DWORD PTR [eax+10208]
  04495	89 4d c4	 mov	 DWORD PTR _pCSave$[ebp+4416], ecx

; 2135 : 	pCSave.BlessBank = lpObj->BlessBank;

  04498	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0449b	8b 88 e4 27 00
	00		 mov	 ecx, DWORD PTR [eax+10212]
  044a1	89 4d c8	 mov	 DWORD PTR _pCSave$[ebp+4420], ecx

; 2136 : 	pCSave.SoulBank = lpObj->SoulBank;

  044a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044a7	8b 88 e8 27 00
	00		 mov	 ecx, DWORD PTR [eax+10216]
  044ad	89 4d cc	 mov	 DWORD PTR _pCSave$[ebp+4424], ecx

; 2137 : 	pCSave.LifeBank = lpObj->LifeBank;

  044b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044b3	8b 88 ec 27 00
	00		 mov	 ecx, DWORD PTR [eax+10220]
  044b9	89 4d d0	 mov	 DWORD PTR _pCSave$[ebp+4428], ecx

; 2138 : 	pCSave.MTDate = lpObj->MTDate;

  044bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044bf	8b 88 08 28 00
	00		 mov	 ecx, DWORD PTR [eax+10248]
  044c5	89 4d d4	 mov	 DWORD PTR _pCSave$[ebp+4432], ecx

; 2139 : 	pCSave.AutoParty = lpObj->AutoPt;

  044c8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044cb	66 8b 88 0c 28
	00 00		 mov	 cx, WORD PTR [eax+10252]
  044d2	66 89 4d d8	 mov	 WORD PTR _pCSave$[ebp+4436], cx

; 2140 : 	pCSave.Zen = lpObj->Zen;

  044d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044d9	8b 88 10 28 00
	00		 mov	 ecx, DWORD PTR [eax+10256]
  044df	89 4d dc	 mov	 DWORD PTR _pCSave$[ebp+4440], ecx

; 2141 : 	pCSave.QTDate = lpObj->QTDate;

  044e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044e5	8b 88 14 28 00
	00		 mov	 ecx, DWORD PTR [eax+10260]
  044eb	89 4d e0	 mov	 DWORD PTR _pCSave$[ebp+4444], ecx

; 2142 : #ifdef EXPINV
; 2143 : 	pCSave.ExpandedInventory = lpObj->ExpandedInventory;

  044ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  044f1	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  044f8	89 4d f0	 mov	 DWORD PTR _pCSave$[ebp+4460], ecx

; 2144 : 
; 2145 : 	if( pCSave.ExpandedInventory < 0 || pCSave.ExpandedInventory > 2 )

  044fb	83 7d f0 00	 cmp	 DWORD PTR _pCSave$[ebp+4460], 0
  044ff	7c 06		 jl	 SHORT $LN5@GJSetChara
  04501	83 7d f0 02	 cmp	 DWORD PTR _pCSave$[ebp+4460], 2
  04505	7e 07		 jle	 SHORT $LN6@GJSetChara
$LN5@GJSetChara:

; 2146 : 	{
; 2147 : 		pCSave.ExpandedInventory = 0;

  04507	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pCSave$[ebp+4460], 0
$LN6@GJSetChara:

; 2148 : 	}
; 2149 : #endif
; 2150 : 
; 2151 : 	pCSave.CharInfoSave = 0;

  0450e	c6 45 8a 00	 mov	 BYTE PTR _pCSave$[ebp+4358], 0

; 2152 : 	memcpy(pCSave.dbQuest, lpObj->m_Quest, sizeof(pCSave.dbQuest));

  04512	6a 32		 push	 50			; 00000032H
  04514	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04517	05 8c 10 00 00	 add	 eax, 4236		; 0000108cH
  0451c	50		 push	 eax
  0451d	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _pCSave$[ebp+4308]
  04523	51		 push	 ecx
  04524	e8 00 00 00 00	 call	 _memcpy
  04529	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2153 : 
; 2154 : #if(CUSTOM_SAVE_PT==TRUE)
; 2155 : 	pCSave.PartyIndex = lpObj->PartyIndex;

  0452c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0452f	8b 88 d0 28 00
	00		 mov	 ecx, DWORD PTR [eax+10448]
  04535	89 4d f4	 mov	 DWORD PTR _pCSave$[ebp+4464], ecx

; 2156 : #endif	
; 2157 : 
; 2158 : 	pCSave.DonateCredit = lpObj->m_iDonateCredit;

  04538	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0453b	8b 88 18 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11032]
  04541	89 4d f8	 mov	 DWORD PTR _pCSave$[ebp+4468], ecx

; 2159 : 
; 2160 : 	if ( cDBSMng.Send((char*)&pCSave, sizeof(SDHP_DBCHAR_INFOSAVE)) == FALSE )

  04544	68 78 11 00 00	 push	 4472			; 00001178H
  04549	8d 85 84 ee ff
	ff		 lea	 eax, DWORD PTR _pCSave$[ebp]
  0454f	50		 push	 eax
  04550	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  04555	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  0455a	85 c0		 test	 eax, eax
  0455c	75 27		 jne	 SHORT $LN4@GJSetChara

; 2161 : 	{
; 2162 : 		LogAddC(2, lMsg.Get(MSGGET(1, 174)), lpObj->Name);

  0455e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04561	83 c0 77	 add	 eax, 119		; 00000077H
  04564	50		 push	 eax
  04565	68 ae 01 00 00	 push	 430			; 000001aeH
  0456a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0456f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  04574	50		 push	 eax
  04575	6a 02		 push	 2
  04577	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0457d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2163 : 		return;

  04580	e9 b5 00 00 00	 jmp	 $LN11@GJSetChara
$LN4@GJSetChara:

; 2164 : 	}
; 2165 : 
; 2166 : 	gObjItemTextSave(lpObj);

  04585	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04588	50		 push	 eax
  04589	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave
  0458e	83 c4 04	 add	 esp, 4

; 2167 : 	gObjStatTextSave(lpObj);

  04591	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  04594	50		 push	 eax
  04595	e8 00 00 00 00	 call	 ?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjStatTextSave
  0459a	83 c4 04	 add	 esp, 4

; 2168 : 	gObjSavePetItemInfo(aIndex, 0);

  0459d	6a 00		 push	 0
  0459f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  045a2	50		 push	 eax
  045a3	e8 00 00 00 00	 call	 ?gObjSavePetItemInfo@@YAXHH@Z ; gObjSavePetItemInfo
  045a8	83 c4 08	 add	 esp, 8

; 2169 : #ifdef LUCKYITEM
; 2170 : 	g_LuckyItemManager.GDReqLuckyItemInsert2nd(aIndex);//Season 6 up (1.01.00)

  045ab	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  045ae	50		 push	 eax
  045af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  045b4	e8 00 00 00 00	 call	 ?GDReqLuckyItemInsert2nd@LuckyItemManager@@QAEXH@Z ; LuckyItemManager::GDReqLuckyItemInsert2nd

; 2171 : #endif
; 2172 : 	//Season 2.5 Quest New CALL
; 2173 : 	g_QuestUtil.Quest3rdSaveInfo(lpObj);

  045b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  045bc	50		 push	 eax
  045bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestUtil@@3VCQuestUtil@@A ; g_QuestUtil
  045c2	e8 00 00 00 00	 call	 ?Quest3rdSaveInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestUtil::Quest3rdSaveInfo

; 2174 : 
; 2175 : 	//Season 3.0 Master Level New CALL
; 2176 : 	g_MasterLevelSystem.GDRequestMasterLevelInfoSave(lpObj);

  045c7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  045ca	50		 push	 eax
  045cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  045d0	e8 00 00 00 00	 call	 ?GDRequestMasterLevelInfoSave@CMasterLevelSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::GDRequestMasterLevelInfoSave

; 2177 : 
; 2178 : 	if(gGENS)

  045d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  045dc	74 0e		 je	 SHORT $LN3@GJSetChara

; 2179 : 	{
; 2180 : 		gGensSystem.GDReqSaveContributePoint(lpObj);

  045de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  045e1	50		 push	 eax
  045e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  045e7	e8 00 00 00 00	 call	 ?GDReqSaveContributePoint@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GDReqSaveContributePoint
$LN3@GJSetChara:

; 2181 : 		//gGensSystem.DBSaveAbusingKillUserName(lpObj);
; 2182 : 	}
; 2183 : #ifdef GAMESHOP
; 2184 : 	gGameShop.GDSaveUserInfo(aIndex);

  045ec	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  045ef	50		 push	 eax
  045f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  045f5	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 2185 : #endif
; 2186 : 
; 2187 : 	if(g_ExLicense.user.Rage)

  045fa	0f b6 05 c9 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+201
  04601	85 c0		 test	 eax, eax
  04603	74 0e		 je	 SHORT $LN2@GJSetChara

; 2188 : 	{
; 2189 : 		gSystemOfRage.SendSaveData(aIndex);

  04605	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  04608	50		 push	 eax
  04609	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  0460e	e8 00 00 00 00	 call	 ?SendSaveData@cSystemOfRage@@QAEXH@Z ; cSystemOfRage::SendSaveData
$LN2@GJSetChara:

; 2190 : 	}
; 2191 : 
; 2192 : 	if(g_ExLicense.user.WinQuest) 

  04613	0f b6 05 ca 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+202
  0461a	85 c0		 test	 eax, eax
  0461c	74 0e		 je	 SHORT $LN1@GJSetChara

; 2193 : 	{
; 2194 : 		gWinQuestSystem.DGSendInformation(aIndex);

  0461e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  04621	50		 push	 eax
  04622	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWinQuestSystem@@3VcWinQuestSystem@@A ; gWinQuestSystem
  04627	e8 00 00 00 00	 call	 ?DGSendInformation@cWinQuestSystem@@QAEXH@Z ; cWinQuestSystem::DGSendInformation
$LN1@GJSetChara:

; 2195 : 	}
; 2196 : 
; 2197 : 	g_ExGDManager.DB_Save(aIndex);

  0462c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0462f	50		 push	 eax
  04630	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExGDManager@@3VCExGDManager@@A ; g_ExGDManager
  04635	e8 00 00 00 00	 call	 ?DB_Save@CExGDManager@@QAEXH@Z ; CExGDManager::DB_Save
$LN11@GJSetChara:

; 2198 : }

  0463a	5f		 pop	 edi
  0463b	5e		 pop	 esi
  0463c	5b		 pop	 ebx
  0463d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  04640	33 cd		 xor	 ecx, ebp
  04642	e8 00 00 00 00	 call	 @__security_check_cookie@4
  04647	8b e5		 mov	 esp, ebp
  04649	5d		 pop	 ebp
  0464a	c3		 ret	 0
?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ENDP	; GJSetCharacterInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDGetWarehouseList@@YAXHPADH@Z			; GDGetWarehouseList
EXTRN	?ClearWarehouse@CGuildBank@@QAEXH@Z:PROC	; CGuildBank::ClearWarehouse
EXTRN	?g_GuildBank@@3VCGuildBank@@A:BYTE		; g_GuildBank
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AccountID$ = 12					; size = 4
_Number$ = 16						; size = 4
?GDGetWarehouseList@@YAXHPADH@Z PROC			; GDGetWarehouseList

; 2216 : {

  04650	55		 push	 ebp
  04651	8b ec		 mov	 ebp, esp
  04653	83 ec 58	 sub	 esp, 88			; 00000058H
  04656	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0465b	33 c5		 xor	 eax, ebp
  0465d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  04660	53		 push	 ebx
  04661	56		 push	 esi
  04662	57		 push	 edi

; 2217 : 	if ( strlen(AccountID) < 1 )

  04663	8b 45 0c	 mov	 eax, DWORD PTR _AccountID$[ebp]
  04666	50		 push	 eax
  04667	e8 00 00 00 00	 call	 _strlen
  0466c	83 c4 04	 add	 esp, 4
  0466f	83 f8 01	 cmp	 eax, 1
  04672	73 02		 jae	 SHORT $LN1@GDGetWareh

; 2218 : 	{
; 2219 : 		return;

  04674	eb 4d		 jmp	 SHORT $LN2@GDGetWareh
$LN1@GDGetWareh:

; 2220 : 	}
; 2221 : 
; 2222 : 	#if(DEV_GUILDBANK)
; 2223 : 	g_GuildBank.ClearWarehouse(aIndex);

  04676	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  04679	50		 push	 eax
  0467a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  0467f	e8 00 00 00 00	 call	 ?ClearWarehouse@CGuildBank@@QAEXH@Z ; CGuildBank::ClearWarehouse

; 2224 : 	#endif
; 2225 : 
; 2226 : 	SDHP_GETWAREHOUSEDB	pMsg;
; 2227 : 
; 2228 : 	pMsg.h.c = 0xC1;

  04684	c6 45 e8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2229 : 	pMsg.h.headcode = 0x08;

  04688	c6 45 ea 08	 mov	 BYTE PTR _pMsg$[ebp+2], 8

; 2230 : 	pMsg.h.size = sizeof(SDHP_GETWAREHOUSEDB);

  0468c	c6 45 e9 14	 mov	 BYTE PTR _pMsg$[ebp+1], 20 ; 00000014H

; 2231 : 	pMsg.aIndex = aIndex;

  04690	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  04694	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2232 : 	memcpy(pMsg.AccountID, AccountID, sizeof(pMsg.AccountID));

  04698	6a 0a		 push	 10			; 0000000aH
  0469a	8b 45 0c	 mov	 eax, DWORD PTR _AccountID$[ebp]
  0469d	50		 push	 eax
  0469e	8d 4d eb	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  046a1	51		 push	 ecx
  046a2	e8 00 00 00 00	 call	 _memcpy
  046a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2233 : 	//LPOBJ lpObj = &gObj[aIndex];
; 2234 : 
; 2235 : 	pMsg.Number = Number;

  046aa	8b 45 10	 mov	 eax, DWORD PTR _Number$[ebp]
  046ad	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2236 : 
; 2237 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  046b0	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  046b4	50		 push	 eax
  046b5	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  046b8	51		 push	 ecx
  046b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  046be	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDGetWareh:

; 2238 : }

  046c3	5f		 pop	 edi
  046c4	5e		 pop	 esi
  046c5	5b		 pop	 ebx
  046c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  046c9	33 cd		 xor	 ecx, ebp
  046cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  046d0	8b e5		 mov	 esp, ebp
  046d2	5d		 pop	 ebp
  046d3	c3		 ret	 0
?GDGetWarehouseList@@YAXHPADH@Z ENDP			; GDGetWarehouseList
_TEXT	ENDS
PUBLIC	?gObjRequestPetItemInfo@@YAXHH@Z		; gObjRequestPetItemInfo
PUBLIC	__real@437f0000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@3f800000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GCWarehouseStateSend@@YAXHE@Z:PROC		; GCWarehouseStateSend
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
EXTRN	?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; GCUserWarehouseSend
EXTRN	?gObjWarehouseItemSet@@YAXHHE@Z:PROC		; gObjWarehouseItemSet
EXTRN	?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjWarehouseInsertItemPos
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z:PROC	; CItem::Convert
EXTRN	?CheckItemType@CSocketOption@@QAEEH@Z:PROC	; CSocketOption::CheckItemType
EXTRN	?g_SocketOption@@3VCSocketOption@@A:BYTE	; g_SocketOption
EXTRN	?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z:PROC ; CItemSystemFor380::Is380Item
EXTRN	?g_kItemSystemFor380@@3VCItemSystemFor380@@A:BYTE ; g_kItemSystemFor380
EXTRN	?IsItem@@YAHH@Z:PROC				; IsItem
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@
CONST	SEGMENT
??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@ DB '['
	DB	'380Item][%s][%s] Invalid 380 Item Option in Warehouse pos[%d]'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv663 = -360						; size = 4
_loword$246059 = -292					; size = 2
_hiword$246055 = -288					; size = 2
_i$246031 = -284					; size = 4
_SocketOptionIndex$246030 = -277			; size = 1
_SocketOption$246029 = -276				; size = 5
_n$245993 = -268					; size = 4
_dbsize$ = -264						; size = 4
_item$ = -260						; size = 212
_OptionData$ = -45					; size = 1
__type$ = -44						; size = 4
_itype$ = -40						; size = 4
_lpObj$ = -36						; size = 4
_pResult$ = -32						; size = 11
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z PROC ; DGGetWarehouseList

; 2242 : {

  046e0	55		 push	 ebp
  046e1	8b ec		 mov	 ebp, esp
  046e3	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  046e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  046ee	33 c5		 xor	 eax, ebp
  046f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  046f3	53		 push	 ebx
  046f4	56		 push	 esi
  046f5	57		 push	 edi

; 2243 : 	char szId[11];
; 2244 : 	int aIndex = 0;

  046f6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _aIndex$[ebp], 0

; 2245 : 	PMSG_TALKRESULT pResult;
; 2246 : 
; 2247 : 	szId[MAX_ACCOUNT_LEN]=0;

  046fd	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 2248 : 	memcpy(szId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  04701	6a 0a		 push	 10			; 0000000aH
  04703	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04706	83 c0 04	 add	 eax, 4
  04709	50		 push	 eax
  0470a	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0470d	51		 push	 ecx
  0470e	e8 00 00 00 00	 call	 _memcpy
  04713	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2249 : 	aIndex = lpMsg->aIndex;

  04716	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04719	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0471d	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2250 : 
; 2251 : 	if ( !gObjIsAccontConnect(aIndex, szId))

  04720	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  04723	50		 push	 eax
  04724	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  04727	51		 push	 ecx
  04728	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0472d	83 c4 08	 add	 esp, 8
  04730	85 c0		 test	 eax, eax
  04732	75 28		 jne	 SHORT $LN63@DGGetWareh

; 2252 : 	{
; 2253 : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), szId, aIndex);

  04734	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  04737	50		 push	 eax
  04738	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0473b	51		 push	 ecx
  0473c	68 af 01 00 00	 push	 431			; 000001afH
  04741	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  04746	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0474b	50		 push	 eax
  0474c	6a 02		 push	 2
  0474e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  04754	83 c4 10	 add	 esp, 16			; 00000010H

; 2254 : 		return;

  04757	e9 5c 0a 00 00	 jmp	 $LN64@DGGetWareh
$LN63@DGGetWareh:

; 2255 : 	}
; 2256 : 
; 2257 : 	LPOBJ lpObj = &gObj[aIndex];

  0475c	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0475f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04765	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0476b	89 45 dc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2258 : 	int itype;
; 2259 : 	int _type;
; 2260 : 	BYTE OptionData;
; 2261 : 	CItem item;

  0476e	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  04774	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 2262 : 
; 2263 : 	memset(gObj[aIndex].pWarehouseMap, (BYTE)-1, WAREHOUSE_SIZE);

  04779	68 f0 00 00 00	 push	 240			; 000000f0H
  0477e	68 ff 00 00 00	 push	 255			; 000000ffH
  04783	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  04786	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0478c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04792	8b 94 01 60 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3680]
  04799	52		 push	 edx
  0479a	e8 00 00 00 00	 call	 _memset
  0479f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2264 : 	gObj[aIndex].WarehouseMoney = lpMsg->Money;

  047a2	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  047a5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  047ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  047b1	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  047b4	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  047b7	89 94 01 6c 0e
	00 00		 mov	 DWORD PTR [ecx+eax+3692], edx

; 2265 : 	gObj[aIndex].WarehousePW = lpMsg->pw;

  047be	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  047c1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  047c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  047cd	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  047d0	66 8b 92 16 0f
	00 00		 mov	 dx, WORD PTR [edx+3862]
  047d7	66 89 94 01 66
	0e 00 00	 mov	 WORD PTR [ecx+eax+3686], dx

; 2266 : 	int dbsize = 7;

  047df	c7 85 f8 fe ff
	ff 07 00 00 00	 mov	 DWORD PTR _dbsize$[ebp], 7

; 2267 : 
; 2268 : 	if ( lpMsg->DbVersion >= 3 )

  047e9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  047ec	0f b6 88 14 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3860]
  047f3	83 f9 03	 cmp	 ecx, 3
  047f6	7c 0c		 jl	 SHORT $LN62@DGGetWareh

; 2269 : 	{
; 2270 : 		dbsize = 16;

  047f8	c7 85 f8 fe ff
	ff 10 00 00 00	 mov	 DWORD PTR _dbsize$[ebp], 16 ; 00000010H
  04802	eb 19		 jmp	 SHORT $LN60@DGGetWareh
$LN62@DGGetWareh:

; 2271 : 	}
; 2272 : 	else if ( lpMsg->DbVersion >= 1 )

  04804	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04807	0f b6 88 14 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3860]
  0480e	83 f9 01	 cmp	 ecx, 1
  04811	7c 0a		 jl	 SHORT $LN60@DGGetWareh

; 2273 : 	{
; 2274 : 		dbsize = 10;

  04813	c7 85 f8 fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
$LN60@DGGetWareh:

; 2275 : 	}
; 2276 : 
; 2277 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  0481d	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$245993[ebp], 0
  04827	eb 0f		 jmp	 SHORT $LN59@DGGetWareh
$LN58@DGGetWareh:
  04829	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  0482f	83 c0 01	 add	 eax, 1
  04832	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _n$245993[ebp], eax
$LN59@DGGetWareh:
  04838	81 bd f4 fe ff
	ff f0 00 00 00	 cmp	 DWORD PTR _n$245993[ebp], 240 ; 000000f0H
  04842	0f 8d 8f 08 00
	00		 jge	 $LN57@DGGetWareh

; 2278 : 	{
; 2279 : 		itype = lpMsg->dbItems[n*dbsize];

  04848	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  0484e	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04855	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04858	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  0485d	89 55 d8	 mov	 DWORD PTR _itype$[ebp], edx

; 2280 : 		
; 2281 : 		if ( dbsize == 16 )

  04860	83 bd f8 fe ff
	ff 10		 cmp	 DWORD PTR _dbsize$[ebp], 16 ; 00000010H
  04867	75 4f		 jne	 SHORT $LN56@DGGetWareh

; 2282 : 		{
; 2283 : 			itype |= (lpMsg->dbItems[n*dbsize+9] & 0xF0) << 5;

  04869	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  0486f	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04876	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04879	0f b6 54 01 1d	 movzx	 edx, BYTE PTR [ecx+eax+29]
  0487e	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  04884	c1 e2 05	 shl	 edx, 5
  04887	0b 55 d8	 or	 edx, DWORD PTR _itype$[ebp]
  0488a	89 55 d8	 mov	 DWORD PTR _itype$[ebp], edx

; 2284 : 			itype |= (lpMsg->dbItems[n*dbsize+7] & 0x80) << 1;

  0488d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04893	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  0489a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0489d	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  048a2	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  048a8	d1 e2		 shl	 edx, 1
  048aa	0b 55 d8	 or	 edx, DWORD PTR _itype$[ebp]
  048ad	89 55 d8	 mov	 DWORD PTR _itype$[ebp], edx

; 2285 : 			_type = itype;

  048b0	8b 45 d8	 mov	 eax, DWORD PTR _itype$[ebp]
  048b3	89 45 d4	 mov	 DWORD PTR __type$[ebp], eax
  048b6	eb 7b		 jmp	 SHORT $LN52@DGGetWareh
$LN56@DGGetWareh:

; 2286 : 		}
; 2287 : 		else if ( dbsize == 10 )

  048b8	83 bd f8 fe ff
	ff 0a		 cmp	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
  048bf	75 4e		 jne	 SHORT $LN54@DGGetWareh

; 2288 : 		{
; 2289 : 			if ( ((lpMsg->dbItems[n*dbsize+7] >> 7) & 0x01) )

  048c1	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  048c7	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  048ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  048d1	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  048d6	c1 fa 07	 sar	 edx, 7
  048d9	83 e2 01	 and	 edx, 1
  048dc	74 0b		 je	 SHORT $LN53@DGGetWareh

; 2290 : 			{
; 2291 : 				itype += 256;

  048de	8b 45 d8	 mov	 eax, DWORD PTR _itype$[ebp]
  048e1	05 00 01 00 00	 add	 eax, 256		; 00000100H
  048e6	89 45 d8	 mov	 DWORD PTR _itype$[ebp], eax
$LN53@DGGetWareh:

; 2292 : 			}
; 2293 : 
; 2294 : 			_type = (itype / 32 * MAX_SUBTYPE_ITEMS) + itype % 32;

  048e9	8b 45 d8	 mov	 eax, DWORD PTR _itype$[ebp]
  048ec	99		 cdq
  048ed	83 e2 1f	 and	 edx, 31			; 0000001fH
  048f0	03 c2		 add	 eax, edx
  048f2	c1 f8 05	 sar	 eax, 5
  048f5	c1 e0 09	 shl	 eax, 9
  048f8	8b 4d d8	 mov	 ecx, DWORD PTR _itype$[ebp]
  048fb	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  04901	79 05		 jns	 SHORT $LN66@DGGetWareh
  04903	49		 dec	 ecx
  04904	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  04907	41		 inc	 ecx
$LN66@DGGetWareh:
  04908	03 c1		 add	 eax, ecx
  0490a	89 45 d4	 mov	 DWORD PTR __type$[ebp], eax

; 2295 : 		}
; 2296 : 		else

  0490d	eb 24		 jmp	 SHORT $LN52@DGGetWareh
$LN54@DGGetWareh:

; 2297 : 		{
; 2298 : 			_type = (itype / MAX_TYPE_ITEMS * MAX_SUBTYPE_ITEMS) + itype % 16;

  0490f	8b 45 d8	 mov	 eax, DWORD PTR _itype$[ebp]
  04912	99		 cdq
  04913	83 e2 0f	 and	 edx, 15			; 0000000fH
  04916	03 c2		 add	 eax, edx
  04918	c1 f8 04	 sar	 eax, 4
  0491b	c1 e0 09	 shl	 eax, 9
  0491e	8b 4d d8	 mov	 ecx, DWORD PTR _itype$[ebp]
  04921	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  04927	79 05		 jns	 SHORT $LN67@DGGetWareh
  04929	49		 dec	 ecx
  0492a	83 c9 f0	 or	 ecx, -16		; fffffff0H
  0492d	41		 inc	 ecx
$LN67@DGGetWareh:
  0492e	03 c1		 add	 eax, ecx
  04930	89 45 d4	 mov	 DWORD PTR __type$[ebp], eax
$LN52@DGGetWareh:

; 2299 : 		}
; 2300 : 
; 2301 : 		gObj[aIndex].pWarehouse[n].Clear();

  04933	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  04936	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0493c	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$245993[ebp]
  04942	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  04948	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0494e	03 8c 02 5c 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3676]
  04955	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 2302 : 
; 2303 : 		if ( dbsize >= 16 )

  0495a	83 bd f8 fe ff
	ff 10		 cmp	 DWORD PTR _dbsize$[ebp], 16 ; 00000010H
  04961	7c 66		 jl	 SHORT $LN51@DGGetWareh

; 2304 : 		{
; 2305 : 			if ( lpMsg->dbItems[n*dbsize] == (BYTE)-1 && (lpMsg->dbItems[n*dbsize+9] & 0xF0) == 0xF0 && (lpMsg->dbItems[n*dbsize+7] & 0x80) == 0x80)

  04963	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04969	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04970	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04973	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  04978	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0497e	75 47		 jne	 SHORT $LN50@DGGetWareh
  04980	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04986	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  0498d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04990	0f b6 54 01 1d	 movzx	 edx, BYTE PTR [ecx+eax+29]
  04995	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  0499b	81 fa f0 00 00
	00		 cmp	 edx, 240		; 000000f0H
  049a1	75 24		 jne	 SHORT $LN50@DGGetWareh
  049a3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  049a9	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  049b0	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  049b3	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  049b8	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  049be	74 07		 je	 SHORT $LN50@DGGetWareh

; 2306 : 			{
; 2307 : 				itype = -1;

  049c0	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN50@DGGetWareh:

; 2308 : 			}
; 2309 : 		}

  049c7	eb 70		 jmp	 SHORT $LN45@DGGetWareh
$LN51@DGGetWareh:

; 2310 : 		else if ( dbsize >= 10 )

  049c9	83 bd f8 fe ff
	ff 0a		 cmp	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
  049d0	7c 43		 jl	 SHORT $LN48@DGGetWareh

; 2311 : 		{
; 2312 : 			if ( lpMsg->dbItems[n*dbsize] == (BYTE)-1 && (lpMsg->dbItems[n*dbsize+7] & 0x80) == 0x80)

  049d2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  049d8	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  049df	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  049e2	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  049e7	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  049ed	75 24		 jne	 SHORT $LN47@DGGetWareh
  049ef	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  049f5	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  049fc	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  049ff	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  04a04	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  04a0a	74 07		 je	 SHORT $LN47@DGGetWareh

; 2313 : 			{
; 2314 : 				itype = -1;

  04a0c	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN47@DGGetWareh:

; 2315 : 			}
; 2316 : 		}
; 2317 : 		else

  04a13	eb 24		 jmp	 SHORT $LN45@DGGetWareh
$LN48@DGGetWareh:

; 2318 : 		{
; 2319 : 			if ( lpMsg->dbItems[n*dbsize] == (BYTE)-1 )

  04a15	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04a1b	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04a22	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04a25	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  04a2a	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  04a30	75 07		 jne	 SHORT $LN45@DGGetWareh

; 2320 : 			{
; 2321 : 				itype = -1;

  04a32	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN45@DGGetWareh:

; 2322 : 			}
; 2323 : 		}
; 2324 : 
; 2325 : 		if ( IsItem(_type) == FALSE )

  04a39	8b 45 d4	 mov	 eax, DWORD PTR __type$[ebp]
  04a3c	50		 push	 eax
  04a3d	e8 00 00 00 00	 call	 ?IsItem@@YAHH@Z		; IsItem
  04a42	83 c4 04	 add	 esp, 4
  04a45	85 c0		 test	 eax, eax
  04a47	75 07		 jne	 SHORT $LN44@DGGetWareh

; 2326 : 		{
; 2327 : 			itype = -1;

  04a49	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN44@DGGetWareh:

; 2328 : 		}
; 2329 : 
; 2330 : 		if ( _type == ITEMGET(14,17) || _type == ITEMGET(14,18) )

  04a50	81 7d d4 11 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7185 ; 00001c11H
  04a57	74 09		 je	 SHORT $LN42@DGGetWareh
  04a59	81 7d d4 12 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7186 ; 00001c12H
  04a60	75 20		 jne	 SHORT $LN41@DGGetWareh
$LN42@DGGetWareh:

; 2331 : 		{
; 2332 : 			if ( lpMsg->dbItems[n*dbsize+2]== 0 )

  04a62	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04a68	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04a6f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04a72	0f b6 54 01 16	 movzx	 edx, BYTE PTR [ecx+eax+22]
  04a77	85 d2		 test	 edx, edx
  04a79	75 07		 jne	 SHORT $LN41@DGGetWareh

; 2333 : 			{
; 2334 : 				_type = -1;

  04a7b	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR __type$[ebp], -1
$LN41@DGGetWareh:

; 2335 : 			}
; 2336 : 		}
; 2337 : 
; 2338 : 		if ( _type == ITEMGET(14,19) )

  04a82	81 7d d4 13 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7187 ; 00001c13H
  04a89	75 24		 jne	 SHORT $LN39@DGGetWareh

; 2339 : 		{
; 2340 : 			if ( lpMsg->dbItems[n*dbsize+2] == (BYTE)-1 )

  04a8b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04a91	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04a98	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04a9b	0f b6 54 01 16	 movzx	 edx, BYTE PTR [ecx+eax+22]
  04aa0	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  04aa6	75 07		 jne	 SHORT $LN39@DGGetWareh

; 2341 : 			{
; 2342 : 				itype = -1;

  04aa8	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN39@DGGetWareh:

; 2343 : 			}
; 2344 : 		}
; 2345 : 
; 2346 : 		if ( itype != -1 )

  04aaf	83 7d d8 ff	 cmp	 DWORD PTR _itype$[ebp], -1
  04ab3	0f 84 19 06 00
	00		 je	 $LN38@DGGetWareh

; 2347 : 		{
; 2348 : 			item.m_Level = DBI_GET_LEVEL(lpMsg->dbItems[n*dbsize+1]);

  04ab9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04abf	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04ac6	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04ac9	0f b6 54 01 15	 movzx	 edx, BYTE PTR [ecx+eax+21]
  04ace	c1 fa 03	 sar	 edx, 3
  04ad1	83 e2 0f	 and	 edx, 15			; 0000000fH
  04ad4	66 89 95 04 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx

; 2349 : 
; 2350 : 			if ( lpMsg->DbVersion	< 2 )

  04adb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04ade	0f b6 88 14 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3860]
  04ae5	83 f9 02	 cmp	 ecx, 2
  04ae8	7d 2a		 jge	 SHORT $LN37@DGGetWareh

; 2351 : 			{
; 2352 : 				lpMsg->dbItems[n*dbsize+8] = -1;

  04aea	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04af0	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04af7	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04afa	c6 44 01 1c ff	 mov	 BYTE PTR [ecx+eax+28], 255 ; 000000ffH

; 2353 : 				lpMsg->dbItems[n*dbsize+9] = -1;

  04aff	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04b05	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04b0c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04b0f	c6 44 01 1d ff	 mov	 BYTE PTR [ecx+eax+29], 255 ; 000000ffH
$LN37@DGGetWareh:

; 2354 : 			}
; 2355 : 
; 2356 : 			if ( _type != ITEMGET(14,11) )

  04b14	81 7d d4 0b 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7179 ; 00001c0bH
  04b1b	74 15		 je	 SHORT $LN35@DGGetWareh

; 2357 : 			{
; 2358 : 				if ( item.m_Level > 15 )	//Season 5 +15 Items

  04b1d	0f bf 85 04 ff
	ff ff		 movsx	 eax, WORD PTR _item$[ebp+8]
  04b24	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  04b27	7e 09		 jle	 SHORT $LN35@DGGetWareh

; 2359 : 				{
; 2360 : 					item.m_Level = 0;

  04b29	33 c0		 xor	 eax, eax
  04b2b	66 89 85 04 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax
$LN35@DGGetWareh:

; 2361 : 				}
; 2362 : 			}
; 2363 : 
; 2364 : 			OptionData = lpMsg->dbItems[n*dbsize+1];

  04b32	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04b38	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04b3f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04b42	8a 54 01 15	 mov	 dl, BYTE PTR [ecx+eax+21]
  04b46	88 55 d3	 mov	 BYTE PTR _OptionData$[ebp], dl

; 2365 : 			item.m_Option1 = ( (OptionData) >> 7 );

  04b49	0f b6 45 d3	 movzx	 eax, BYTE PTR _OptionData$[ebp]
  04b4d	c1 f8 07	 sar	 eax, 7
  04b50	88 45 90	 mov	 BYTE PTR _item$[ebp+148], al

; 2366 : 			item.m_Option2 = DBI_GET_LUCK(OptionData);

  04b53	0f b6 45 d3	 movzx	 eax, BYTE PTR _OptionData$[ebp]
  04b57	c1 f8 02	 sar	 eax, 2
  04b5a	83 e0 01	 and	 eax, 1
  04b5d	88 45 91	 mov	 BYTE PTR _item$[ebp+149], al

; 2367 : 			item.m_Option3 = DBI_GET_OPTION(OptionData);

  04b60	0f b6 45 d3	 movzx	 eax, BYTE PTR _OptionData$[ebp]
  04b64	83 e0 03	 and	 eax, 3
  04b67	88 45 92	 mov	 BYTE PTR _item$[ebp+150], al

; 2368 : 
; 2369 : 			if ( dbsize >= 10 )

  04b6a	83 bd f8 fe ff
	ff 0a		 cmp	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
  04b71	7c 24		 jl	 SHORT $LN34@DGGetWareh

; 2370 : 			{
; 2371 : 				//if ( _type == ITEMGET(13,3) )
; 2372 : 				//{
; 2373 : 					item.m_Option3 |= DBI_GET_DINO_OPTION(lpMsg->dbItems[n*dbsize+7]);

  04b73	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04b79	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04b80	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04b83	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  04b88	83 e2 40	 and	 edx, 64			; 00000040H
  04b8b	c1 fa 04	 sar	 edx, 4
  04b8e	0f b6 45 92	 movzx	 eax, BYTE PTR _item$[ebp+150]
  04b92	0b c2		 or	 eax, edx
  04b94	88 45 92	 mov	 BYTE PTR _item$[ebp+150], al
$LN34@DGGetWareh:

; 2374 : 				//}
; 2375 : 				//else
; 2376 : 				//{
; 2377 : 				//	if ( DBI_GET_OPTION16(lpMsg->dbItems[n*dbsize+7]) == 0x40 )
; 2378 : 				//	{
; 2379 : 				//		item.m_Option3 = 4;
; 2380 : 				//	}
; 2381 : 				//}
; 2382 : 			}
; 2383 : 
; 2384 : 			item.m_Durability = lpMsg->dbItems[n*dbsize+2];

  04b97	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04b9d	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04ba4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04ba7	0f b6 54 01 16	 movzx	 edx, BYTE PTR [ecx+eax+22]
  04bac	89 95 98 fe ff
	ff		 mov	 DWORD PTR tv663[ebp], edx
  04bb2	db 85 98 fe ff
	ff		 fild	 DWORD PTR tv663[ebp]
  04bb8	d9 9d 20 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]

; 2385 : 
; 2386 : 			if ( dbsize >= 16 )

  04bbe	83 bd f8 fe ff
	ff 10		 cmp	 DWORD PTR _dbsize$[ebp], 16 ; 00000010H
  04bc5	7c 17		 jl	 SHORT $LN33@DGGetWareh

; 2387 : 			{
; 2388 : 				item.m_JewelOfHarmonyOption = lpMsg->dbItems[n*dbsize+10];

  04bc7	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04bcd	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04bd4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04bd7	8a 54 01 1e	 mov	 dl, BYTE PTR [ecx+eax+30]
  04bdb	88 55 c0	 mov	 BYTE PTR _item$[ebp+196], dl
$LN33@DGGetWareh:

; 2389 : 			}
; 2390 : 
; 2391 : 			if ( dbsize >= 16 )

  04bde	83 bd f8 fe ff
	ff 10		 cmp	 DWORD PTR _dbsize$[ebp], 16 ; 00000010H
  04be5	7c 6d		 jl	 SHORT $LN30@DGGetWareh

; 2392 : 			{
; 2393 : 				item.m_ItemOptionEx = DBI_GET_380OPTION(lpMsg->dbItems[n*dbsize+9]);

  04be7	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04bed	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04bf4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04bf7	0f b6 54 01 1d	 movzx	 edx, BYTE PTR [ecx+eax+29]
  04bfc	83 e2 08	 and	 edx, 8
  04bff	c1 e2 04	 shl	 edx, 4
  04c02	88 55 c6	 mov	 BYTE PTR _item$[ebp+202], dl

; 2394 : 
; 2395 : 				if ( item.m_ItemOptionEx != 0 )

  04c05	0f b6 45 c6	 movzx	 eax, BYTE PTR _item$[ebp+202]
  04c09	85 c0		 test	 eax, eax
  04c0b	74 47		 je	 SHORT $LN30@DGGetWareh

; 2396 : 				{
; 2397 : 					item.m_Type = itype;

  04c0d	66 8b 45 d8	 mov	 ax, WORD PTR _itype$[ebp]
  04c11	66 89 85 02 ff
	ff ff		 mov	 WORD PTR _item$[ebp+6], ax

; 2398 : 					if ( g_kItemSystemFor380.Is380Item(&item)== FALSE )

  04c18	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  04c1e	50		 push	 eax
  04c1f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  04c24	e8 00 00 00 00	 call	 ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380Item
  04c29	85 c0		 test	 eax, eax
  04c2b	75 27		 jne	 SHORT $LN30@DGGetWareh

; 2399 : 					{
; 2400 : 						item.m_ItemOptionEx = 0;

  04c2d	c6 45 c6 00	 mov	 BYTE PTR _item$[ebp+202], 0

; 2401 : 
; 2402 : 						LogAddTD("[380Item][%s][%s] Invalid 380 Item Option in Warehouse pos[%d]", lpObj->AccountID, lpObj->Name, n);

  04c31	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04c37	50		 push	 eax
  04c38	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  04c3b	83 c1 77	 add	 ecx, 119		; 00000077H
  04c3e	51		 push	 ecx
  04c3f	8b 55 dc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  04c42	83 c2 6c	 add	 edx, 108		; 0000006cH
  04c45	52		 push	 edx
  04c46	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@
  04c4b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  04c51	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@DGGetWareh:

; 2403 : 					}
; 2404 : 				}
; 2405 : 			}
; 2406 : 			//SocketSystem Season 4.5 addon start
; 2407 : 			BYTE SocketOption[5];
; 2408 : 			BYTE SocketOptionIndex = 0xFF;

  04c54	c6 85 eb fe ff
	ff ff		 mov	 BYTE PTR _SocketOptionIndex$246030[ebp], 255 ; 000000ffH

; 2409 : 			int i = 0;

  04c5b	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$246031[ebp], 0

; 2410 : 			memset(&SocketOption, 0xFF, 5);

  04c65	6a 05		 push	 5
  04c67	68 ff 00 00 00	 push	 255			; 000000ffH
  04c6c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _SocketOption$246029[ebp]
  04c72	50		 push	 eax
  04c73	e8 00 00 00 00	 call	 _memset
  04c78	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2411 : 			
; 2412 : 			if ( g_SocketOption.CheckItemType(itype) == 1 )

  04c7b	8b 45 d8	 mov	 eax, DWORD PTR _itype$[ebp]
  04c7e	50		 push	 eax
  04c7f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  04c84	e8 00 00 00 00	 call	 ?CheckItemType@CSocketOption@@QAEEH@Z ; CSocketOption::CheckItemType
  04c89	0f b6 c8	 movzx	 ecx, al
  04c8c	83 f9 01	 cmp	 ecx, 1
  04c8f	75 6d		 jne	 SHORT $LN29@DGGetWareh

; 2413 : 			{
; 2414 : 				SocketOptionIndex = lpMsg->dbItems[n*dbsize+10];

  04c91	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04c97	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04c9e	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04ca1	8a 54 01 1e	 mov	 dl, BYTE PTR [ecx+eax+30]
  04ca5	88 95 eb fe ff
	ff		 mov	 BYTE PTR _SocketOptionIndex$246030[ebp], dl

; 2415 : 
; 2416 : 				for(i = 0; i < 5; i++)

  04cab	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$246031[ebp], 0
  04cb5	eb 0f		 jmp	 SHORT $LN28@DGGetWareh
$LN27@DGGetWareh:
  04cb7	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$246031[ebp]
  04cbd	83 c0 01	 add	 eax, 1
  04cc0	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$246031[ebp], eax
$LN28@DGGetWareh:
  04cc6	83 bd e4 fe ff
	ff 05		 cmp	 DWORD PTR _i$246031[ebp], 5
  04ccd	7d 2d		 jge	 SHORT $LN26@DGGetWareh

; 2417 : 				{
; 2418 : 					SocketOption[i] =  lpMsg->dbItems[((n*dbsize)+11)+i];

  04ccf	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04cd5	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04cdc	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$246031[ebp]
  04ce2	8d 54 08 0b	 lea	 edx, DWORD PTR [eax+ecx+11]
  04ce6	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$246031[ebp]
  04cec	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04cef	8a 54 11 14	 mov	 dl, BYTE PTR [ecx+edx+20]
  04cf3	88 94 05 ec fe
	ff ff		 mov	 BYTE PTR _SocketOption$246029[ebp+eax], dl

; 2419 : 				}

  04cfa	eb bb		 jmp	 SHORT $LN27@DGGetWareh
$LN26@DGGetWareh:

; 2420 : 			}
; 2421 : 			else

  04cfc	eb 3b		 jmp	 SHORT $LN22@DGGetWareh
$LN29@DGGetWareh:

; 2422 : 			{
; 2423 : 				SocketOptionIndex = 0;

  04cfe	c6 85 eb fe ff
	ff 00		 mov	 BYTE PTR _SocketOptionIndex$246030[ebp], 0

; 2424 : 
; 2425 : 				for(i = 0; i < 5; i++)

  04d05	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$246031[ebp], 0
  04d0f	eb 0f		 jmp	 SHORT $LN24@DGGetWareh
$LN23@DGGetWareh:
  04d11	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$246031[ebp]
  04d17	83 c0 01	 add	 eax, 1
  04d1a	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$246031[ebp], eax
$LN24@DGGetWareh:
  04d20	83 bd e4 fe ff
	ff 05		 cmp	 DWORD PTR _i$246031[ebp], 5
  04d27	7d 10		 jge	 SHORT $LN22@DGGetWareh

; 2426 : 				{
; 2427 : 					SocketOption[i] = 0xFF;

  04d29	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$246031[ebp]
  04d2f	c6 84 05 ec fe
	ff ff ff	 mov	 BYTE PTR _SocketOption$246029[ebp+eax], 255 ; 000000ffH

; 2428 : 				}

  04d37	eb d8		 jmp	 SHORT $LN23@DGGetWareh
$LN22@DGGetWareh:

; 2429 : 			}
; 2430 : 			//SocketSystem Season 4.5 addon end
; 2431 : 
; 2432 : #ifdef PERIOD
; 2433 : 			if( dbsize >= 16 )	//1.01.00

  04d39	83 bd f8 fe ff
	ff 10		 cmp	 DWORD PTR _dbsize$[ebp], 16 ; 00000010H
  04d40	7c 1d		 jl	 SHORT $LN21@DGGetWareh

; 2434 : 			{
; 2435 : 				item.m_PeriodItemOption = (lpMsg->dbItems[n*dbsize+DBI_OPTION380_DATA] & 6) >> 1;

  04d42	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04d48	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04d4f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04d52	0f b6 54 01 1d	 movzx	 edx, BYTE PTR [ecx+eax+29]
  04d57	83 e2 06	 and	 edx, 6
  04d5a	d1 fa		 sar	 edx, 1
  04d5c	88 55 ce	 mov	 BYTE PTR _item$[ebp+210], dl
$LN21@DGGetWareh:

; 2436 : 			}
; 2437 : #endif
; 2438 : 
; 2439 : 			if ( lpMsg->DbVersion == 0 )

  04d5f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04d62	0f b6 88 14 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3860]
  04d69	85 c9		 test	 ecx, ecx
  04d6b	75 34		 jne	 SHORT $LN20@DGGetWareh

; 2440 : 			{
; 2441 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, 0, 0, 0, NULL, 0xFF, 0, 3);

  04d6d	6a 03		 push	 3
  04d6f	6a 00		 push	 0
  04d71	68 ff 00 00 00	 push	 255			; 000000ffH
  04d76	6a 00		 push	 0
  04d78	6a 00		 push	 0
  04d7a	6a 00		 push	 0
  04d7c	6a 00		 push	 0
  04d7e	0f b6 45 92	 movzx	 eax, BYTE PTR _item$[ebp+150]
  04d82	50		 push	 eax
  04d83	0f b6 4d 91	 movzx	 ecx, BYTE PTR _item$[ebp+149]
  04d87	51		 push	 ecx
  04d88	0f b6 55 90	 movzx	 edx, BYTE PTR _item$[ebp+148]
  04d8c	52		 push	 edx
  04d8d	8b 45 d8	 mov	 eax, DWORD PTR _itype$[ebp]
  04d90	50		 push	 eax
  04d91	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  04d97	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
  04d9c	e9 d9 00 00 00	 jmp	 $LN17@DGGetWareh
$LN20@DGGetWareh:

; 2442 : 			}
; 2443 : #ifdef PERIOD
; 2444 : 			else if ( lpMsg->DbVersion <= 2 )

  04da1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04da4	0f b6 88 14 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3860]
  04dab	83 f9 02	 cmp	 ecx, 2
  04dae	7f 62		 jg	 SHORT $LN18@DGGetWareh

; 2445 : 			{
; 2446 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, DBI_GET_NOPTION(lpMsg->dbItems[n*dbsize+7]), lpMsg->dbItems[n*dbsize+8], item.m_ItemOptionEx, 0, 0xFF, item.m_PeriodItemOption, 1);

  04db0	6a 01		 push	 1
  04db2	0f b6 45 ce	 movzx	 eax, BYTE PTR _item$[ebp+210]
  04db6	50		 push	 eax
  04db7	68 ff 00 00 00	 push	 255			; 000000ffH
  04dbc	6a 00		 push	 0
  04dbe	0f b6 4d c6	 movzx	 ecx, BYTE PTR _item$[ebp+202]
  04dc2	51		 push	 ecx
  04dc3	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$245993[ebp]
  04dc9	0f af 95 f8 fe
	ff ff		 imul	 edx, DWORD PTR _dbsize$[ebp]
  04dd0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04dd3	0f b6 4c 10 1c	 movzx	 ecx, BYTE PTR [eax+edx+28]
  04dd8	51		 push	 ecx
  04dd9	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$245993[ebp]
  04ddf	0f af 95 f8 fe
	ff ff		 imul	 edx, DWORD PTR _dbsize$[ebp]
  04de6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  04de9	0f b6 4c 10 1b	 movzx	 ecx, BYTE PTR [eax+edx+27]
  04dee	83 e1 3f	 and	 ecx, 63			; 0000003fH
  04df1	51		 push	 ecx
  04df2	0f b6 55 92	 movzx	 edx, BYTE PTR _item$[ebp+150]
  04df6	52		 push	 edx
  04df7	0f b6 45 91	 movzx	 eax, BYTE PTR _item$[ebp+149]
  04dfb	50		 push	 eax
  04dfc	0f b6 4d 90	 movzx	 ecx, BYTE PTR _item$[ebp+148]
  04e00	51		 push	 ecx
  04e01	8b 55 d8	 mov	 edx, DWORD PTR _itype$[ebp]
  04e04	52		 push	 edx
  04e05	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  04e0b	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 2447 : 			}
; 2448 : 			else

  04e10	eb 68		 jmp	 SHORT $LN17@DGGetWareh
$LN18@DGGetWareh:

; 2449 : 			{
; 2450 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, DBI_GET_NOPTION(lpMsg->dbItems[n*dbsize+7]), lpMsg->dbItems[n*dbsize+8], item.m_ItemOptionEx, SocketOption, SocketOptionIndex, item.m_PeriodItemOption, 3);

  04e12	6a 03		 push	 3
  04e14	0f b6 45 ce	 movzx	 eax, BYTE PTR _item$[ebp+210]
  04e18	50		 push	 eax
  04e19	0f b6 8d eb fe
	ff ff		 movzx	 ecx, BYTE PTR _SocketOptionIndex$246030[ebp]
  04e20	51		 push	 ecx
  04e21	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _SocketOption$246029[ebp]
  04e27	52		 push	 edx
  04e28	0f b6 45 c6	 movzx	 eax, BYTE PTR _item$[ebp+202]
  04e2c	50		 push	 eax
  04e2d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$245993[ebp]
  04e33	0f af 8d f8 fe
	ff ff		 imul	 ecx, DWORD PTR _dbsize$[ebp]
  04e3a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  04e3d	0f b6 44 0a 1c	 movzx	 eax, BYTE PTR [edx+ecx+28]
  04e42	50		 push	 eax
  04e43	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$245993[ebp]
  04e49	0f af 8d f8 fe
	ff ff		 imul	 ecx, DWORD PTR _dbsize$[ebp]
  04e50	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  04e53	0f b6 44 0a 1b	 movzx	 eax, BYTE PTR [edx+ecx+27]
  04e58	83 e0 3f	 and	 eax, 63			; 0000003fH
  04e5b	50		 push	 eax
  04e5c	0f b6 4d 92	 movzx	 ecx, BYTE PTR _item$[ebp+150]
  04e60	51		 push	 ecx
  04e61	0f b6 55 91	 movzx	 edx, BYTE PTR _item$[ebp+149]
  04e65	52		 push	 edx
  04e66	0f b6 45 90	 movzx	 eax, BYTE PTR _item$[ebp+148]
  04e6a	50		 push	 eax
  04e6b	8b 4d d8	 mov	 ecx, DWORD PTR _itype$[ebp]
  04e6e	51		 push	 ecx
  04e6f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  04e75	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
$LN17@DGGetWareh:

; 2451 : 			}
; 2452 : #else
; 2453 : 			else if ( lpMsg->DbVersion <= 2 )
; 2454 : 			{
; 2455 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, DBI_GET_NOPTION(lpMsg->dbItems[n*dbsize+7]), lpMsg->dbItems[n*dbsize+8], item.m_ItemOptionEx, 0, 0xFF, 0, 1);
; 2456 : 			}
; 2457 : 			else
; 2458 : 			{
; 2459 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, DBI_GET_NOPTION(lpMsg->dbItems[n*dbsize+7]), lpMsg->dbItems[n*dbsize+8], item.m_ItemOptionEx, SocketOption, SocketOptionIndex, 0, 3);
; 2460 : 			}
; 2461 : #endif
; 2462 : 
; 2463 : 
; 2464 : 
; 2465 : 			if ( _type == ITEMGET(14,7) )

  04e7a	81 7d d4 07 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7175 ; 00001c07H
  04e81	75 05		 jne	 SHORT $LN16@DGGetWareh
  04e83	e9 af 00 00 00	 jmp	 $LN7@DGGetWareh
$LN16@DGGetWareh:

; 2466 : 			{
; 2467 : 				
; 2468 : 			}
; 2469 : 			else if ( (_type >= ITEMGET(14,0) && _type <= ITEMGET(14,8)) || ( _type >= ITEMGET(14,35) && _type <= ITEMGET(14,40) ) )

  04e88	81 7d d4 00 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7168 ; 00001c00H
  04e8f	7c 09		 jl	 SHORT $LN12@DGGetWareh
  04e91	81 7d d4 08 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7176 ; 00001c08H
  04e98	7e 12		 jle	 SHORT $LN13@DGGetWareh
$LN12@DGGetWareh:
  04e9a	81 7d d4 23 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7203 ; 00001c23H
  04ea1	7c 43		 jl	 SHORT $LN14@DGGetWareh
  04ea3	81 7d d4 28 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7208 ; 00001c28H
  04eaa	7f 3a		 jg	 SHORT $LN14@DGGetWareh
$LN13@DGGetWareh:

; 2470 : 			{
; 2471 : 				if ( item.m_Durability == 0.0f )

  04eac	d9 85 20 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  04eb2	d9 ee		 fldz
  04eb4	da e9		 fucompp
  04eb6	df e0		 fnstsw	 ax
  04eb8	f6 c4 44	 test	 ah, 68			; 00000044H
  04ebb	7a 08		 jp	 SHORT $LN11@DGGetWareh

; 2472 : 				{
; 2473 : 					item.m_Durability = 1.0f;

  04ebd	d9 e8		 fld1
  04ebf	d9 9d 20 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
$LN11@DGGetWareh:

; 2474 : 				}
; 2475 : 
; 2476 : 				if ( item.m_Durability > 255.0f )

  04ec5	d9 85 20 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  04ecb	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@406fe00000000000
  04ed1	df e0		 fnstsw	 ax
  04ed3	f6 c4 41	 test	 ah, 65			; 00000041H
  04ed6	75 0c		 jne	 SHORT $LN10@DGGetWareh

; 2477 : 				{
; 2478 : 					item.m_Durability = 255.0f;

  04ed8	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  04ede	d9 9d 20 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
$LN10@DGGetWareh:

; 2479 : 				}
; 2480 : 			}

  04ee4	eb 51		 jmp	 SHORT $LN7@DGGetWareh
$LN14@DGGetWareh:

; 2481 : 			else if ( _type != ITEMGET(13,10) && _type != ITEMGET(14,29) && _type != ITEMGET(14,21) && item.m_Level == 3 && _type != ITEMGET(14,100))//Lucky Coin  (S4.5)

  04ee6	81 7d d4 0a 1a
	00 00		 cmp	 DWORD PTR __type$[ebp], 6666 ; 00001a0aH
  04eed	74 48		 je	 SHORT $LN7@DGGetWareh
  04eef	81 7d d4 1d 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7197 ; 00001c1dH
  04ef6	74 3f		 je	 SHORT $LN7@DGGetWareh
  04ef8	81 7d d4 15 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7189 ; 00001c15H
  04eff	74 36		 je	 SHORT $LN7@DGGetWareh
  04f01	0f bf 85 04 ff
	ff ff		 movsx	 eax, WORD PTR _item$[ebp+8]
  04f08	83 f8 03	 cmp	 eax, 3
  04f0b	75 2a		 jne	 SHORT $LN7@DGGetWareh
  04f0d	81 7d d4 64 1c
	00 00		 cmp	 DWORD PTR __type$[ebp], 7268 ; 00001c64H
  04f14	74 21		 je	 SHORT $LN7@DGGetWareh

; 2482 : 			{
; 2483 : 				if ( item.m_Durability > item.m_BaseDurability )

  04f16	d9 85 20 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  04f1c	d9 85 28 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+44]
  04f22	de d9		 fcompp
  04f24	df e0		 fnstsw	 ax
  04f26	f6 c4 05	 test	 ah, 5
  04f29	7a 0c		 jp	 SHORT $LN7@DGGetWareh

; 2484 : 				{
; 2485 : 					item.m_Durability = item.m_BaseDurability;

  04f2b	d9 85 28 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+44]
  04f31	d9 9d 20 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
$LN7@DGGetWareh:

; 2486 : 				}
; 2487 : 			}
; 2488 : 
; 2489 : 			lpObj->pWarehouse[n].m_Option1 = item.m_Option1;

  04f37	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04f3d	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  04f43	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  04f46	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  04f4c	8a 4d 90	 mov	 cl, BYTE PTR _item$[ebp+148]
  04f4f	88 8c 02 94 00
	00 00		 mov	 BYTE PTR [edx+eax+148], cl

; 2490 : 			lpObj->pWarehouse[n].m_Option2 = item.m_Option2;

  04f56	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04f5c	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  04f62	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  04f65	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  04f6b	8a 4d 91	 mov	 cl, BYTE PTR _item$[ebp+149]
  04f6e	88 8c 02 95 00
	00 00		 mov	 BYTE PTR [edx+eax+149], cl

; 2491 : 			lpObj->pWarehouse[n].m_Option3 = item.m_Option3;

  04f75	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04f7b	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  04f81	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  04f84	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  04f8a	8a 4d 92	 mov	 cl, BYTE PTR _item$[ebp+150]
  04f8d	88 8c 02 96 00
	00 00		 mov	 BYTE PTR [edx+eax+150], cl

; 2492 : 
; 2493 : 			lpObj->pWarehouse[n].m_JewelOfHarmonyOption = item.m_JewelOfHarmonyOption;

  04f94	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04f9a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  04fa0	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  04fa3	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  04fa9	8a 4d c0	 mov	 cl, BYTE PTR _item$[ebp+196]
  04fac	88 8c 02 c4 00
	00 00		 mov	 BYTE PTR [edx+eax+196], cl

; 2494 : 			lpObj->pWarehouse[n].m_ItemOptionEx = item.m_ItemOptionEx;

  04fb3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04fb9	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  04fbf	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  04fc2	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  04fc8	8a 4d c6	 mov	 cl, BYTE PTR _item$[ebp+202]
  04fcb	88 8c 02 ca 00
	00 00		 mov	 BYTE PTR [edx+eax+202], cl

; 2495 : 
; 2496 : 			WORD hiword = MAKE_NUMBERW(lpMsg->dbItems[n*dbsize+3], lpMsg->dbItems[n*dbsize+4]);

  04fd2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  04fd8	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  04fdf	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  04fe2	0f b6 54 01 18	 movzx	 edx, BYTE PTR [ecx+eax+24]
  04fe7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  04fed	0f b6 c2	 movzx	 eax, dl
  04ff0	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$245993[ebp]
  04ff6	0f af 8d f8 fe
	ff ff		 imul	 ecx, DWORD PTR _dbsize$[ebp]
  04ffd	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05000	0f b6 4c 0a 17	 movzx	 ecx, BYTE PTR [edx+ecx+23]
  05005	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0500b	0f b6 d1	 movzx	 edx, cl
  0500e	c1 e2 08	 shl	 edx, 8
  05011	0b c2		 or	 eax, edx
  05013	66 89 85 e0 fe
	ff ff		 mov	 WORD PTR _hiword$246055[ebp], ax

; 2497 : 			WORD loword = MAKE_NUMBERW(lpMsg->dbItems[n*dbsize+5], lpMsg->dbItems[n*dbsize+6]);

  0501a	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  05020	0f af 85 f8 fe
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  05027	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0502a	0f b6 54 01 1a	 movzx	 edx, BYTE PTR [ecx+eax+26]
  0502f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  05035	0f b6 c2	 movzx	 eax, dl
  05038	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$245993[ebp]
  0503e	0f af 8d f8 fe
	ff ff		 imul	 ecx, DWORD PTR _dbsize$[ebp]
  05045	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05048	0f b6 4c 0a 19	 movzx	 ecx, BYTE PTR [edx+ecx+25]
  0504d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  05053	0f b6 d1	 movzx	 edx, cl
  05056	c1 e2 08	 shl	 edx, 8
  05059	0b c2		 or	 eax, edx
  0505b	66 89 85 dc fe
	ff ff		 mov	 WORD PTR _loword$246059[ebp], ax

; 2498 : 
; 2499 : 			item.m_Number = MAKE_NUMBERDW(hiword, loword);

  05062	0f b7 85 dc fe
	ff ff		 movzx	 eax, WORD PTR _loword$246059[ebp]
  05069	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0506e	0f b7 c8	 movzx	 ecx, ax
  05071	0f b7 95 e0 fe
	ff ff		 movzx	 edx, WORD PTR _hiword$246055[ebp]
  05078	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0507e	0f b7 c2	 movzx	 eax, dx
  05081	c1 e0 10	 shl	 eax, 16			; 00000010H
  05084	0b c8		 or	 ecx, eax
  05086	89 8d fc fe ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 2500 : 
; 2501 : 			gObjWarehouseInsertItemPos(lpObj->m_Index, item, n, -1);

  0508c	6a ff		 push	 -1
  0508e	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  05094	50		 push	 eax
  05095	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0509b	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  050a0	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  050a6	8b fc		 mov	 edi, esp
  050a8	f3 a5		 rep movsd
  050aa	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  050ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  050af	52		 push	 edx
  050b0	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos
  050b5	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H

; 2502 : 			gObjWarehouseItemSet(lpObj->m_Index, n, 1);

  050bb	6a 01		 push	 1
  050bd	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$245993[ebp]
  050c3	50		 push	 eax
  050c4	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  050c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  050c9	52		 push	 edx
  050ca	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet
  050cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@DGGetWareh:

; 2503 : 		}
; 2504 : 	}

  050d2	e9 52 f7 ff ff	 jmp	 $LN58@DGGetWareh
$LN57@DGGetWareh:

; 2505 : 
; 2506 : 	pResult.h.c = 0xC3;

  050d7	c6 45 e0 c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 2507 : 	pResult.h.headcode = 0x30;

  050db	c6 45 e2 30	 mov	 BYTE PTR _pResult$[ebp+2], 48 ; 00000030H

; 2508 : 	pResult.h.size = sizeof(PMSG_TALKRESULT);

  050df	c6 45 e1 0b	 mov	 BYTE PTR _pResult$[ebp+1], 11 ; 0000000bH

; 2509 : 	pResult.result = 2;

  050e3	c6 45 e3 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 2510 : #ifdef DEBUG_CODE
; 2511 : 	//if(lpObj->TESTW == 0)	//DeBug
; 2512 : #endif
; 2513 : 
; 2514 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);	//    

  050e7	0f b6 45 e1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  050eb	50		 push	 eax
  050ec	8d 4d e0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  050ef	51		 push	 ecx
  050f0	8b 55 dc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  050f3	8b 02		 mov	 eax, DWORD PTR [edx]
  050f5	50		 push	 eax
  050f6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  050fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2515 : 
; 2516 : 	GCUserWarehouseSend(&gObj[aIndex]);//    

  050fe	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05101	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05107	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0510d	50		 push	 eax
  0510e	e8 00 00 00 00	 call	 ?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z ; GCUserWarehouseSend
  05113	83 c4 04	 add	 esp, 4

; 2517 : 
; 2518 : 	if ( bCanWarehouseLock == TRUE )

  05116	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  0511d	75 64		 jne	 SHORT $LN2@DGGetWareh

; 2519 : 	{
; 2520 : 		if ( gObj[aIndex].WarehousePW > 0 )

  0511f	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05122	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0512e	0f bf 94 01 66
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3686]
  05136	85 d2		 test	 edx, edx
  05138	7e 3b		 jle	 SHORT $LN5@DGGetWareh

; 2521 : 		{
; 2522 : 			if ( gObj[aIndex].WarehouseLock == 0 )

  0513a	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0513d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05149	0f b6 94 01 68
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3688]
  05151	85 d2		 test	 edx, edx
  05153	75 10		 jne	 SHORT $LN4@DGGetWareh

; 2523 : 			{
; 2524 : 				GCWarehouseStateSend(aIndex, 12);

  05155	6a 0c		 push	 12			; 0000000cH
  05157	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0515a	50		 push	 eax
  0515b	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  05160	83 c4 08	 add	 esp, 8

; 2525 : 			}
; 2526 : 			else

  05163	eb 0e		 jmp	 SHORT $LN3@DGGetWareh
$LN4@DGGetWareh:

; 2527 : 			{
; 2528 : 				GCWarehouseStateSend(aIndex, 1);

  05165	6a 01		 push	 1
  05167	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0516a	50		 push	 eax
  0516b	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  05170	83 c4 08	 add	 esp, 8
$LN3@DGGetWareh:

; 2529 : 			}
; 2530 : 		}
; 2531 : 		else

  05173	eb 0e		 jmp	 SHORT $LN2@DGGetWareh
$LN5@DGGetWareh:

; 2532 : 		{
; 2533 : 			GCWarehouseStateSend(aIndex, 0);

  05175	6a 00		 push	 0
  05177	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0517a	50		 push	 eax
  0517b	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  05180	83 c4 08	 add	 esp, 8
$LN2@DGGetWareh:

; 2534 : 		}
; 2535 : 	}
; 2536 : 
; 2537 : 	lpObj->LoadWareHouseInfo = true;

  05183	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05186	c6 80 54 10 00
	00 01		 mov	 BYTE PTR [eax+4180], 1

; 2538 : 	lpObj->m_ReqWarehouseOpen = false;

  0518d	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05190	c6 80 1c 11 00
	00 00		 mov	 BYTE PTR [eax+4380], 0

; 2539 : 	gObjRequestPetItemInfo(lpObj->m_Index, 1);

  05197	6a 01		 push	 1
  05199	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0519c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0519e	51		 push	 ecx
  0519f	e8 00 00 00 00	 call	 ?gObjRequestPetItemInfo@@YAXHH@Z ; gObjRequestPetItemInfo
  051a4	83 c4 08	 add	 esp, 8

; 2540 : 
; 2541 : 	if ( szAuthKey[2] != AUTHKEY2 )

  051a7	0f be 05 02 00
	00 00		 movsx	 eax, BYTE PTR ?szAuthKey@@3PADA+2
  051ae	83 f8 be	 cmp	 eax, -66		; ffffffbeH
  051b1	74 05		 je	 SHORT $LN1@DGGetWareh

; 2542 : 	{
; 2543 : 		DestroyGIocp();

  051b3	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN1@DGGetWareh:
$LN64@DGGetWareh:

; 2544 : 	}
; 2545 : }

  051b8	5f		 pop	 edi
  051b9	5e		 pop	 esi
  051ba	5b		 pop	 ebx
  051bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  051be	33 cd		 xor	 ecx, ebp
  051c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  051c5	8b e5		 mov	 esp, ebp
  051c7	5d		 pop	 ebp
  051c8	c3		 ret	 0
?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ENDP ; DGGetWarehouseList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$246085 = -48					; size = 12
_lpObj$ = -36						; size = 4
_pResult$ = -32						; size = 11
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z PROC ; GDGetWarehouseNoItem

; 2549 : {

  051d0	55		 push	 ebp
  051d1	8b ec		 mov	 ebp, esp
  051d3	83 ec 70	 sub	 esp, 112		; 00000070H
  051d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  051db	33 c5		 xor	 eax, ebp
  051dd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  051e0	53		 push	 ebx
  051e1	56		 push	 esi
  051e2	57		 push	 edi

; 2550 : 	char szId[11];
; 2551 : 	int aIndex = lpMsg->aIndex;

  051e3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  051e6	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  051ea	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2552 : 	PMSG_TALKRESULT pResult;
; 2553 : 
; 2554 : 	szId[MAX_ACCOUNT_LEN] = 0;

  051ed	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 2555 : 	memcpy(szId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  051f1	6a 0a		 push	 10			; 0000000aH
  051f3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  051f6	83 c0 03	 add	 eax, 3
  051f9	50		 push	 eax
  051fa	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  051fd	51		 push	 ecx
  051fe	e8 00 00 00 00	 call	 _memcpy
  05203	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2556 : 
; 2557 : 	if ( !gObjIsAccontConnect(aIndex, szId) )

  05206	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  05209	50		 push	 eax
  0520a	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0520d	51		 push	 ecx
  0520e	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  05213	83 c4 08	 add	 esp, 8
  05216	85 c0		 test	 eax, eax
  05218	75 28		 jne	 SHORT $LN3@GDGetWareh@2

; 2558 : 	{
; 2559 : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), szId, aIndex);

  0521a	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0521d	50		 push	 eax
  0521e	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  05221	51		 push	 ecx
  05222	68 af 01 00 00	 push	 431			; 000001afH
  05227	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0522c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  05231	50		 push	 eax
  05232	6a 02		 push	 2
  05234	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0523a	83 c4 10	 add	 esp, 16			; 00000010H

; 2560 : 		return;

  0523d	e9 16 01 00 00	 jmp	 $LN4@GDGetWareh@2
$LN3@GDGetWareh@2:

; 2561 : 	}
; 2562 : 
; 2563 : 	LPOBJ lpObj = &gObj[aIndex];

  05242	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05245	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0524b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05251	89 45 dc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2564 : 
; 2565 : 	/* Guild Bank Fix */
; 2566 : 	g_GuildBank.ClearWarehouse(aIndex);

  05254	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05257	50		 push	 eax
  05258	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  0525d	e8 00 00 00 00	 call	 ?ClearWarehouse@CGuildBank@@QAEXH@Z ; CGuildBank::ClearWarehouse

; 2567 : 	
; 2568 : 	if ( lpObj->m_IfState.type == 6 )

  05262	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05265	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  0526b	c1 e9 06	 shr	 ecx, 6
  0526e	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  05274	83 f9 06	 cmp	 ecx, 6
  05277	0f 85 c7 00 00
	00		 jne	 $LN2@GDGetWareh@2

; 2569 : 	{
; 2570 : 		if ( lpObj->m_IfState.state == 0 )

  0527d	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05280	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  05286	c1 e9 02	 shr	 ecx, 2
  05289	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0528c	0f 85 b2 00 00
	00		 jne	 $LN2@GDGetWareh@2

; 2571 : 		{
; 2572 : 			lpObj->m_IfState.state = 1;

  05292	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05295	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  0529b	83 e1 c3	 and	 ecx, -61		; ffffffc3H
  0529e	83 c9 04	 or	 ecx, 4
  052a1	8b 55 dc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  052a4	89 8a 1c 0e 00
	00		 mov	 DWORD PTR [edx+3612], ecx

; 2573 : 			lpObj->WarehouseSave = 1;

  052aa	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  052ad	c7 80 70 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3696], 1

; 2574 : 			pResult.h.c = 0xC3;

  052b7	c6 45 e0 c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 2575 : 			pResult.h.headcode = 0x30;

  052bb	c6 45 e2 30	 mov	 BYTE PTR _pResult$[ebp+2], 48 ; 00000030H

; 2576 : 			pResult.h.size = sizeof(pResult);

  052bf	c6 45 e1 0b	 mov	 BYTE PTR _pResult$[ebp+1], 11 ; 0000000bH

; 2577 : 			pResult.result = 2;

  052c3	c6 45 e3 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 2578 : 
; 2579 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  052c7	0f b6 45 e1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  052cb	50		 push	 eax
  052cc	8d 4d e0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  052cf	51		 push	 ecx
  052d0	8b 55 dc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  052d3	8b 02		 mov	 eax, DWORD PTR [edx]
  052d5	50		 push	 eax
  052d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  052db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2580 : 			LogAddC(2, lMsg.Get(MSGGET(1, 176)), lpObj->Name);

  052de	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  052e1	83 c0 77	 add	 eax, 119		; 00000077H
  052e4	50		 push	 eax
  052e5	68 b0 01 00 00	 push	 432			; 000001b0H
  052ea	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  052ef	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  052f4	50		 push	 eax
  052f5	6a 02		 push	 2
  052f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  052fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2581 : 		
; 2582 : 			PMSG_MONEY pMsg; // Season 4.5 fix
; 2583 : 
; 2584 : 			PHeadSetB((LPBYTE)&pMsg, 0x81, sizeof(pMsg));

  05300	6a 0c		 push	 12			; 0000000cH
  05302	68 81 00 00 00	 push	 129			; 00000081H
  05307	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$246085[ebp]
  0530a	50		 push	 eax
  0530b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  05310	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2585 : 			pMsg.Result = 1;

  05313	c6 45 d3 01	 mov	 BYTE PTR _pMsg$246085[ebp+3], 1

; 2586 : 			pMsg.iMoney = lpObj->Money;

  05317	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0531a	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  05320	89 4d d8	 mov	 DWORD PTR _pMsg$246085[ebp+8], ecx

; 2587 : 			pMsg.wMoney = lpObj->WarehouseMoney;

  05323	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05326	8b 88 6c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3692]
  0532c	89 4d d4	 mov	 DWORD PTR _pMsg$246085[ebp+4], ecx

; 2588 : 
; 2589 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0532f	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$246085[ebp+1]
  05333	50		 push	 eax
  05334	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$246085[ebp]
  05337	51		 push	 ecx
  05338	8b 55 ec	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0533b	52		 push	 edx
  0533c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  05341	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GDGetWareh@2:

; 2590 : 		}
; 2591 : 	}
; 2592 : 
; 2593 : 	lpObj->LoadWareHouseInfo = true;

  05344	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05347	c6 80 54 10 00
	00 01		 mov	 BYTE PTR [eax+4180], 1

; 2594 : 	lpObj->m_ReqWarehouseOpen = false;

  0534e	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05351	c6 80 1c 11 00
	00 00		 mov	 BYTE PTR [eax+4380], 0
$LN4@GDGetWareh@2:

; 2595 : 
; 2596 : 
; 2597 : 
; 2598 : }

  05358	5f		 pop	 edi
  05359	5e		 pop	 esi
  0535a	5b		 pop	 ebx
  0535b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0535e	33 cd		 xor	 ecx, ebp
  05360	e8 00 00 00 00	 call	 @__security_check_cookie@4
  05365	8b e5		 mov	 esp, ebp
  05367	5d		 pop	 ebp
  05368	c3		 ret	 0
?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ENDP ; GDGetWarehouseNoItem
_TEXT	ENDS
PUBLIC	??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?GDSetGuildWarehouseList@CGuildBank@@QAEXH@Z:PROC ; CGuildBank::GDSetGuildWarehouseList
;	COMDAT ??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@
CONST	SEGMENT
??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@ DB '['
	DB	'%s][%s] WareHouse Save Fail : Not Open', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pMsg$ = -3872						; size = 3868
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSetWarehouseList@@YAXH@Z PROC			; GDSetWarehouseList

; 2602 : {

  05370	55		 push	 ebp
  05371	8b ec		 mov	 ebp, esp
  05373	81 ec 60 0f 00
	00		 sub	 esp, 3936		; 00000f60H
  05379	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0537e	33 c5		 xor	 eax, ebp
  05380	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  05383	53		 push	 ebx
  05384	56		 push	 esi
  05385	57		 push	 edi

; 2603 : #if(DEV_GUILDBANK)
; 2604 : 	if(g_GuildBank.m_iEnable == 1 && gObj[aIndex].m_bGuildBank == true)

  05386	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_GuildBank@@3VCGuildBank@@A, 1
  0538d	75 2f		 jne	 SHORT $LN2@GDSetWareh
  0538f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05392	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05398	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0539e	0f b6 94 01 25
	2b 00 00	 movzx	 edx, BYTE PTR [ecx+eax+11045]
  053a6	83 fa 01	 cmp	 edx, 1
  053a9	75 13		 jne	 SHORT $LN2@GDSetWareh

; 2605 : 	{
; 2606 : 		g_GuildBank.GDSetGuildWarehouseList(aIndex);

  053ab	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  053ae	50		 push	 eax
  053af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  053b4	e8 00 00 00 00	 call	 ?GDSetGuildWarehouseList@CGuildBank@@QAEXH@Z ; CGuildBank::GDSetGuildWarehouseList

; 2607 : 		/* Guild Bank Fix */
; 2608 : 		/*LPOBJ lpObj = &gObj[aIndex];
; 2609 : 
; 2610 : 		if(lpObj->Type == OBJ_USER)
; 2611 : 		{
; 2612 : 			for(int i=0;i<WAREHOUSE_SIZE;i++)
; 2613 : 			{
; 2614 : 				lpObj->pWarehouse[i].Clear();
; 2615 : 			}
; 2616 : 		}*/
; 2617 : 
; 2618 : 		return;

  053b9	e9 59 01 00 00	 jmp	 $LN3@GDSetWareh
$LN2@GDSetWareh:

; 2619 : 	}
; 2620 : #endif
; 2621 : 
; 2622 : 	SDHP_GETWAREHOUSEDB_SAVE pMsg;
; 2623 : 	
; 2624 : 	if ( gObj[aIndex].LoadWareHouseInfo == false )

  053be	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  053c1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  053c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053cd	0f b6 94 01 54
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax+4180]
  053d5	85 d2		 test	 edx, edx
  053d7	75 3b		 jne	 SHORT $LN1@GDSetWareh

; 2625 : 	{
; 2626 : 		LogAddTD("[%s][%s] WareHouse Save Fail : Not Open",	gObj[aIndex].AccountID, gObj[aIndex].Name);

  053d9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  053dc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  053e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053e8	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  053ec	52		 push	 edx
  053ed	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  053f0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  053f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053fc	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  05400	52		 push	 edx
  05401	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@
  05406	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0540c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2627 : 		return;

  0540f	e9 03 01 00 00	 jmp	 $LN3@GDSetWareh
$LN1@GDSetWareh:

; 2628 : 	}
; 2629 : 
; 2630 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, sizeof(pMsg.AccountID));

  05414	6a 0a		 push	 10			; 0000000aH
  05416	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05419	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0541f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05425	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  05429	52		 push	 edx
  0542a	8d 85 e4 f0 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  05430	50		 push	 eax
  05431	e8 00 00 00 00	 call	 _memcpy
  05436	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2631 : 	pMsg.aIndex = aIndex;

  05439	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  0543d	66 89 85 ee f0
	ff ff		 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2632 : 	pMsg.h.c = 0xC2;

  05444	c6 85 e0 f0 ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 2633 : 	pMsg.h.headcode = 0x09;

  0544b	c6 85 e3 f0 ff
	ff 09		 mov	 BYTE PTR _pMsg$[ebp+3], 9

; 2634 : 	pMsg.h.sizeH = HIBYTE(sizeof(pMsg));

  05452	c6 85 e1 f0 ff
	ff 0f		 mov	 BYTE PTR _pMsg$[ebp+1], 15 ; 0000000fH

; 2635 : 	pMsg.h.sizeL = LOBYTE(sizeof(pMsg));

  05459	c6 85 e2 f0 ff
	ff 1c		 mov	 BYTE PTR _pMsg$[ebp+2], 28 ; 0000001cH

; 2636 : 	pMsg.Money = gObj[aIndex].WarehouseMoney;

  05460	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05463	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05469	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0546f	8b 94 01 6c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3692]
  05476	89 95 f0 f0 ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+16], edx

; 2637 : 	pMsg.pw = gObj[aIndex].WarehousePW;

  0547c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0547f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05485	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0548b	66 8b 94 01 66
	0e 00 00	 mov	 dx, WORD PTR [ecx+eax+3686]
  05493	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+3862], dx

; 2638 : 
; 2639 : 	pMsg.Number	= gObj[aIndex].WarehouseNumber;

  05497	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0549a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054a6	8b 94 01 e8 2a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+10984]
  054ad	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+3864], edx

; 2640 : 
; 2641 : 	ItemByteConvert16(pMsg.dbItems, gObj[aIndex].pWarehouse, WAREHOUSE_SIZE);

  054b0	68 f0 00 00 00	 push	 240			; 000000f0H
  054b5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  054b8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054c4	8b 94 01 5c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3676]
  054cb	52		 push	 edx
  054cc	8d 85 f4 f0 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+20]
  054d2	50		 push	 eax
  054d3	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16
  054d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2642 : 
; 2643 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  054db	68 1c 0f 00 00	 push	 3868			; 00000f1cH
  054e0	8d 85 e0 f0 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  054e6	50		 push	 eax
  054e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  054ec	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2644 : 	gObjSavePetItemInfo(aIndex, 1);

  054f1	6a 01		 push	 1
  054f3	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  054f6	50		 push	 eax
  054f7	e8 00 00 00 00	 call	 ?gObjSavePetItemInfo@@YAXHH@Z ; gObjSavePetItemInfo
  054fc	83 c4 08	 add	 esp, 8

; 2645 : 	gObjWarehouseTextSave(&gObj[aIndex]);

  054ff	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05502	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05508	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0550e	50		 push	 eax
  0550f	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave
  05514	83 c4 04	 add	 esp, 4
$LN3@GDSetWareh:

; 2646 : 
; 2647 : #if(DEV_GUILDBANK)
; 2648 : /* Guild Bank Fix */
; 2649 : 	/*LPOBJ lpObj = &gObj[aIndex];
; 2650 : 
; 2651 : 	if(lpObj->Type == OBJ_USER)
; 2652 : 	{
; 2653 : 		for(int i=0;i<WAREHOUSE_SIZE;i++)
; 2654 : 		{
; 2655 : 			lpObj->pWarehouse[i].Clear();
; 2656 : 		}
; 2657 : 	}*/
; 2658 : #endif
; 2659 : }

  05517	5f		 pop	 edi
  05518	5e		 pop	 esi
  05519	5b		 pop	 ebx
  0551a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0551d	33 cd		 xor	 ecx, ebp
  0551f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  05524	8b e5		 mov	 esp, ebp
  05526	5d		 pop	 ebp
  05527	c3		 ret	 0
?GDSetWarehouseList@@YAXH@Z ENDP			; GDSetWarehouseList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z		; GDUserItemSave
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -3796						; size = 3790
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z PROC		; GDUserItemSave

; 2671 : {

  05530	55		 push	 ebp
  05531	8b ec		 mov	 ebp, esp
  05533	81 ec 14 0f 00
	00		 sub	 esp, 3860		; 00000f14H
  05539	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0553e	33 c5		 xor	 eax, ebp
  05540	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  05543	53		 push	 ebx
  05544	56		 push	 esi
  05545	57		 push	 edi

; 2672 : 	SDHP_DBCHAR_ITEMSAVE pMsg;
; 2673 : 
; 2674 : 	pMsg.h.c = 0xC2;

  05546	c6 85 2c f1 ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 2675 : 	pMsg.h.headcode = 0x11;

  0554d	c6 85 2f f1 ff
	ff 11		 mov	 BYTE PTR _pMsg$[ebp+3], 17 ; 00000011H

; 2676 : 	pMsg.h.sizeH = HIBYTE(sizeof(pMsg));

  05554	c6 85 2d f1 ff
	ff 0e		 mov	 BYTE PTR _pMsg$[ebp+1], 14 ; 0000000eH

; 2677 : 	pMsg.h.sizeL = LOBYTE(sizeof(pMsg));

  0555b	c6 85 2e f1 ff
	ff ce		 mov	 BYTE PTR _pMsg$[ebp+2], 206 ; 000000ceH

; 2678 : 	memcpy(pMsg.Name, lpObj->Name, sizeof(pMsg.Name));

  05562	6a 0a		 push	 10			; 0000000aH
  05564	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05567	83 c0 77	 add	 eax, 119		; 00000077H
  0556a	50		 push	 eax
  0556b	8d 8d 30 f1 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  05571	51		 push	 ecx
  05572	e8 00 00 00 00	 call	 _memcpy
  05577	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2679 : 	ItemByteConvert16(pMsg.dbInventory, lpObj->pInventory, INVENTORY_SIZE);

  0557a	68 ec 00 00 00	 push	 236			; 000000ecH
  0557f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05582	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  05588	51		 push	 ecx
  05589	8d 95 3a f1 ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+14]
  0558f	52		 push	 edx
  05590	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16
  05595	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2680 : 
; 2681 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  05598	68 ce 0e 00 00	 push	 3790			; 00000eceH
  0559d	8d 85 2c f1 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  055a3	50		 push	 eax
  055a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  055a9	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2682 : }

  055ae	5f		 pop	 edi
  055af	5e		 pop	 esi
  055b0	5b		 pop	 ebx
  055b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  055b4	33 cd		 xor	 ecx, ebp
  055b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  055bb	8b e5		 mov	 esp, ebp
  055bd	5d		 pop	 ebp
  055be	c3		 ret	 0
?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; GDUserItemSave
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDSetWarehouseMoney@@YAXH@Z			; GDSetWarehouseMoney
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSetWarehouseMoney@@YAXH@Z PROC			; GDSetWarehouseMoney

; 2694 : {

  055c0	55		 push	 ebp
  055c1	8b ec		 mov	 ebp, esp
  055c3	83 ec 58	 sub	 esp, 88			; 00000058H
  055c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  055cb	33 c5		 xor	 eax, ebp
  055cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  055d0	53		 push	 ebx
  055d1	56		 push	 esi
  055d2	57		 push	 edi

; 2695 : 	SDHP_WAREHOUSEMONEY_SAVE pMsg;
; 2696 : 
; 2697 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, sizeof(pMsg.AccountID));

  055d3	6a 0a		 push	 10			; 0000000aH
  055d5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  055d8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  055de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  055e4	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  055e8	52		 push	 edx
  055e9	8d 45 eb	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  055ec	50		 push	 eax
  055ed	e8 00 00 00 00	 call	 _memcpy
  055f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2698 : 	pMsg.aIndex = aIndex;

  055f5	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  055f9	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2699 : 	pMsg.h.c = 0xC1;

  055fd	c6 45 e8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2700 : 	pMsg.h.headcode = 0x12;

  05601	c6 45 ea 12	 mov	 BYTE PTR _pMsg$[ebp+2], 18 ; 00000012H

; 2701 : 	pMsg.h.size = sizeof(pMsg);

  05605	c6 45 e9 14	 mov	 BYTE PTR _pMsg$[ebp+1], 20 ; 00000014H

; 2702 : 	pMsg.Money = gObj[aIndex].WarehouseMoney;

  05609	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0560c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05612	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05618	8b 94 01 6c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3692]
  0561f	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+16], edx

; 2703 : 
; 2704 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  05622	6a 14		 push	 20			; 00000014H
  05624	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  05627	50		 push	 eax
  05628	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0562d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2705 : }

  05632	5f		 pop	 edi
  05633	5e		 pop	 esi
  05634	5b		 pop	 ebx
  05635	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  05638	33 cd		 xor	 ecx, ebp
  0563a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0563f	8b e5		 mov	 esp, ebp
  05641	5d		 pop	 ebp
  05642	c3		 ret	 0
?GDSetWarehouseMoney@@YAXH@Z ENDP			; GDSetWarehouseMoney
_TEXT	ENDS
PUBLIC	?GDGameServerInfoSave@@YAXXZ			; GDGameServerInfoSave
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
?GDGameServerInfoSave@@YAXXZ PROC			; GDGameServerInfoSave

; 2709 : {

  05650	55		 push	 ebp
  05651	8b ec		 mov	 ebp, esp
  05653	83 ec 40	 sub	 esp, 64			; 00000040H
  05656	53		 push	 ebx
  05657	56		 push	 esi
  05658	57		 push	 edi

; 2710 : 	return;
; 2711 : }

  05659	5f		 pop	 edi
  0565a	5e		 pop	 esi
  0565b	5b		 pop	 ebx
  0565c	8b e5		 mov	 esp, ebp
  0565e	5d		 pop	 ebp
  0565f	c3		 ret	 0
?GDGameServerInfoSave@@YAXXZ ENDP			; GDGameServerInfoSave
_TEXT	ENDS
PUBLIC	??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@ ; `string'
PUBLIC	??_C@_0CP@NAJCODAF@?$FLItemSerialCreateSend?$FN?5No?5Name?5I@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z	; ItemSerialCreateSend
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?BlockItemDrop@CItemDropManager@@QAE_NHHH@Z:PROC ; CItemDropManager::BlockItemDrop
EXTRN	?gItemDropManager@@3VCItemDropManager@@A:BYTE	; gItemDropManager
;	COMDAT ??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@
CONST	SEGMENT
??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@ DB 'M'
	DB	'onster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d]'
	DB	'[%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NAJCODAF@?$FLItemSerialCreateSend?$FN?5No?5Name?5I@
CONST	SEGMENT
??_C@_0CP@NAJCODAF@?$FLItemSerialCreateSend?$FN?5No?5Name?5I@ DB '[ItemSe'
	DB	'rialCreateSend] No Name Item Drop Block', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv134 = -116						; size = 4
_i$246187 = -48						; size = 4
_NewOption$246186 = -44					; size = 8
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_type$ = 24						; size = 4
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Op1$ = 36						; size = 1
_Op2$ = 40						; size = 1
_Op3$ = 44						; size = 1
_LootIndex$ = 48					; size = 4
_NewOption$ = 52					; size = 1
_SetOption$ = 56					; size = 1
?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z PROC		; ItemSerialCreateSend

; 2738 : {

  05660	55		 push	 ebp
  05661	8b ec		 mov	 ebp, esp
  05663	83 ec 74	 sub	 esp, 116		; 00000074H
  05666	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0566b	33 c5		 xor	 eax, ebp
  0566d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  05670	53		 push	 ebx
  05671	56		 push	 esi
  05672	57		 push	 edi

; 2739 : 	if(MapNumber != 235 && MapNumber != 236)

  05673	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  05677	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  0567c	74 2e		 je	 SHORT $LN18@ItemSerial
  0567e	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  05682	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  05687	74 23		 je	 SHORT $LN18@ItemSerial

; 2740 : 	{
; 2741 : 		if(!gItemDropManager.BlockItemDrop(aIndex,type,MapNumber)) return;

  05689	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  0568d	50		 push	 eax
  0568e	8b 4d 18	 mov	 ecx, DWORD PTR _type$[ebp]
  05691	51		 push	 ecx
  05692	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  05695	52		 push	 edx
  05696	b9 00 00 00 00	 mov	 ecx, OFFSET ?gItemDropManager@@3VCItemDropManager@@A ; gItemDropManager
  0569b	e8 00 00 00 00	 call	 ?BlockItemDrop@CItemDropManager@@QAE_NHHH@Z ; CItemDropManager::BlockItemDrop
  056a0	0f b6 c0	 movzx	 eax, al
  056a3	85 c0		 test	 eax, eax
  056a5	75 05		 jne	 SHORT $LN18@ItemSerial
  056a7	e9 1a 02 00 00	 jmp	 $LN19@ItemSerial
$LN18@ItemSerial:

; 2742 : 	}
; 2743 : #ifdef DRYNEA_31_10
; 2744 : 	if(g_ExLicense.CheckUser(eExUB::drynea))

  056ac	6a 01		 push	 1
  056ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  056b3	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  056b8	0f b6 c0	 movzx	 eax, al
  056bb	85 c0		 test	 eax, eax
  056bd	74 17		 je	 SHORT $LN16@ItemSerial

; 2745 : 	{
; 2746 : 		if(MapNumber == 41)

  056bf	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  056c3	83 f8 29	 cmp	 eax, 41			; 00000029H
  056c6	75 0e		 jne	 SHORT $LN16@ItemSerial

; 2747 : 		{
; 2748 : 			if(type != ITEMGET(14,209))

  056c8	81 7d 18 d1 1c
	00 00		 cmp	 DWORD PTR _type$[ebp], 7377 ; 00001cd1H
  056cf	74 05		 je	 SHORT $LN16@ItemSerial

; 2749 : 			{
; 2750 : 				return;

  056d1	e9 f0 01 00 00	 jmp	 $LN19@ItemSerial
$LN16@ItemSerial:

; 2751 : 			}
; 2752 : 		}
; 2753 : 	}
; 2754 : 
; 2755 : 	
; 2756 : #endif
; 2757 : 
; 2758 : #if(ITEM_NO_NAME_DROP_FIX==TRUE)
; 2759 : 	if(type == -1)

  056d6	83 7d 18 ff	 cmp	 DWORD PTR _type$[ebp], -1
  056da	75 13		 jne	 SHORT $LN13@ItemSerial

; 2760 : 	{
; 2761 : 		LogAddTD("[ItemSerialCreateSend] No Name Item Drop Block");

  056dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@NAJCODAF@?$FLItemSerialCreateSend?$FN?5No?5Name?5I@
  056e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  056e7	83 c4 04	 add	 esp, 4

; 2762 : 		return;

  056ea	e9 d7 01 00 00	 jmp	 $LN19@ItemSerial
$LN13@ItemSerial:

; 2763 : 	}
; 2764 : #endif
; 2765 : 
; 2766 : 	SDHP_ITEMCREATE  pMsg;
; 2767 : 
; 2768 : 	pMsg.h.c = 0xC1;

  056ef	c6 45 dc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2769 : 	pMsg.h.headcode = 0x52;

  056f3	c6 45 de 52	 mov	 BYTE PTR _pMsg$[ebp+2], 82 ; 00000052H

; 2770 : 	pMsg.h.size = sizeof(pMsg);

  056f7	c6 45 dd 20	 mov	 BYTE PTR _pMsg$[ebp+1], 32 ; 00000020H

; 2771 : 	pMsg.MapNumber = MapNumber;

  056fb	8a 45 0c	 mov	 al, BYTE PTR _MapNumber$[ebp]
  056fe	88 45 e1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 2772 : 	pMsg.x = x;

  05701	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  05704	88 45 df	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2773 : 	pMsg.y = y;

  05707	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  0570a	88 45 e0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2774 : 	pMsg.Type = type;

  0570d	66 8b 45 18	 mov	 ax, WORD PTR _type$[ebp]
  05711	66 89 45 e2	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 2775 : 	pMsg.Level = level;

  05715	8a 45 1c	 mov	 al, BYTE PTR _level$[ebp]
  05718	88 45 e4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 2776 : 
; 2777 : 	if (dur == 0 )

  0571b	0f b6 45 20	 movzx	 eax, BYTE PTR _dur$[ebp]
  0571f	85 c0		 test	 eax, eax
  05721	75 1e		 jne	 SHORT $LN12@ItemSerial

; 2778 : 	{
; 2779 : 		dur = ItemGetDurability(type, level, NewOption, SetOption);

  05723	0f b6 45 38	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  05727	50		 push	 eax
  05728	0f b6 4d 34	 movzx	 ecx, BYTE PTR _NewOption$[ebp]
  0572c	51		 push	 ecx
  0572d	0f b6 55 1c	 movzx	 edx, BYTE PTR _level$[ebp]
  05731	52		 push	 edx
  05732	8b 45 18	 mov	 eax, DWORD PTR _type$[ebp]
  05735	50		 push	 eax
  05736	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0573b	83 c4 10	 add	 esp, 16			; 00000010H
  0573e	88 45 20	 mov	 BYTE PTR _dur$[ebp], al
$LN12@ItemSerial:

; 2780 : 	}
; 2781 : 
; 2782 : 	pMsg.Dur = dur;

  05741	8a 45 20	 mov	 al, BYTE PTR _dur$[ebp]
  05744	88 45 e5	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 2783 : 	pMsg.Op1 = Op1;

  05747	8a 45 24	 mov	 al, BYTE PTR _Op1$[ebp]
  0574a	88 45 e6	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 2784 : 	pMsg.Op2 = Op2;

  0574d	8a 45 28	 mov	 al, BYTE PTR _Op2$[ebp]
  05750	88 45 e7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 2785 : 	pMsg.Op3 = Op3;

  05753	8a 45 2c	 mov	 al, BYTE PTR _Op3$[ebp]
  05756	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 2786 : 	pMsg.NewOption = NewOption;

  05759	8a 45 34	 mov	 al, BYTE PTR _NewOption$[ebp]
  0575c	88 45 e9	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 2787 : 	pMsg.aIndex = aIndex;

  0575f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05762	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2788 : 	pMsg.lootindex = LootIndex;

  05765	66 8b 45 30	 mov	 ax, WORD PTR _LootIndex$[ebp]
  05769	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 2789 : 	pMsg.SetOption = SetOption;

  0576d	8a 45 38	 mov	 al, BYTE PTR _SetOption$[ebp]
  05770	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+22], al

; 2790 : 
; 2791 : #ifdef PERIOD
; 2792 : 	if( MapNumber == 236 )

  05773	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  05777	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  0577c	75 06		 jne	 SHORT $LN11@ItemSerial

; 2793 : 	{
; 2794 : 		pMsg.lDuration = LootIndex;

  0577e	8b 45 30	 mov	 eax, DWORD PTR _LootIndex$[ebp]
  05781	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
$LN11@ItemSerial:

; 2795 : 	}
; 2796 : #endif
; 2797 : 
; 2798 : 	if ( OBJMAX_RANGE(aIndex) != FALSE  && gObj[aIndex].Type != OBJ_USER )

  05784	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  05788	7d 09		 jge	 SHORT $LN21@ItemSerial
  0578a	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
  05791	eb 0f		 jmp	 SHORT $LN22@ItemSerial
$LN21@ItemSerial:
  05793	33 c0		 xor	 eax, eax
  05795	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0579c	0f 9e c0	 setle	 al
  0579f	89 45 8c	 mov	 DWORD PTR tv134[ebp], eax
$LN22@ItemSerial:
  057a2	83 7d 8c 00	 cmp	 DWORD PTR tv134[ebp], 0
  057a6	0f 84 07 01 00
	00		 je	 $LN10@ItemSerial
  057ac	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  057af	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  057b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  057bb	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  057c0	83 fa 01	 cmp	 edx, 1
  057c3	0f 84 ea 00 00
	00		 je	 $LN10@ItemSerial

; 2799 : 	{
; 2800 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 2801 : 
; 2802 : 		for ( int i=0;i<MAX_EXOPTION_SIZE;i++)

  057c9	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$246187[ebp], 0
  057d0	eb 09		 jmp	 SHORT $LN9@ItemSerial
$LN8@ItemSerial:
  057d2	8b 45 d0	 mov	 eax, DWORD PTR _i$246187[ebp]
  057d5	83 c0 01	 add	 eax, 1
  057d8	89 45 d0	 mov	 DWORD PTR _i$246187[ebp], eax
$LN9@ItemSerial:
  057db	83 7d d0 08	 cmp	 DWORD PTR _i$246187[ebp], 8
  057df	7d 0a		 jge	 SHORT $LN7@ItemSerial

; 2803 : 		{
; 2804 : 			NewOption[i] = 0;

  057e1	8b 45 d0	 mov	 eax, DWORD PTR _i$246187[ebp]
  057e4	c6 44 05 d4 00	 mov	 BYTE PTR _NewOption$246186[ebp+eax], 0

; 2805 : 		}

  057e9	eb e7		 jmp	 SHORT $LN8@ItemSerial
$LN7@ItemSerial:

; 2806 : 
; 2807 : 		if ( (pMsg.NewOption & 0x20) != 0 )

  057eb	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  057ef	83 e0 20	 and	 eax, 32			; 00000020H
  057f2	74 04		 je	 SHORT $LN6@ItemSerial

; 2808 : 		{
; 2809 : 			NewOption[0] = TRUE;

  057f4	c6 45 d4 01	 mov	 BYTE PTR _NewOption$246186[ebp], 1
$LN6@ItemSerial:

; 2810 : 		}
; 2811 : 		if ( (pMsg.NewOption & 0x10) != 0 )

  057f8	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  057fc	83 e0 10	 and	 eax, 16			; 00000010H
  057ff	74 04		 je	 SHORT $LN5@ItemSerial

; 2812 : 		{
; 2813 : 			NewOption[1] = TRUE;

  05801	c6 45 d5 01	 mov	 BYTE PTR _NewOption$246186[ebp+1], 1
$LN5@ItemSerial:

; 2814 : 		}
; 2815 : 
; 2816 : 		if ( (pMsg.NewOption & 0x8) != 0 )

  05805	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  05809	83 e0 08	 and	 eax, 8
  0580c	74 04		 je	 SHORT $LN4@ItemSerial

; 2817 : 		{
; 2818 : 			NewOption[2] = TRUE;

  0580e	c6 45 d6 01	 mov	 BYTE PTR _NewOption$246186[ebp+2], 1
$LN4@ItemSerial:

; 2819 : 		}
; 2820 : 		if ( (pMsg.NewOption & 0x4) != 0 )

  05812	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  05816	83 e0 04	 and	 eax, 4
  05819	74 04		 je	 SHORT $LN3@ItemSerial

; 2821 : 		{
; 2822 : 			NewOption[3] = TRUE;

  0581b	c6 45 d7 01	 mov	 BYTE PTR _NewOption$246186[ebp+3], 1
$LN3@ItemSerial:

; 2823 : 		}
; 2824 : 
; 2825 : 		if ( (pMsg.NewOption & 0x2) != 0 )

  0581f	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  05823	83 e0 02	 and	 eax, 2
  05826	74 04		 je	 SHORT $LN2@ItemSerial

; 2826 : 		{
; 2827 : 			NewOption[4] = TRUE;

  05828	c6 45 d8 01	 mov	 BYTE PTR _NewOption$246186[ebp+4], 1
$LN2@ItemSerial:

; 2828 : 		}
; 2829 : 		if ( (pMsg.NewOption & 0x1) != 0 )

  0582c	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  05830	83 e0 01	 and	 eax, 1
  05833	74 04		 je	 SHORT $LN1@ItemSerial

; 2830 : 		{
; 2831 : 			NewOption[5] = TRUE;

  05835	c6 45 d9 01	 mov	 BYTE PTR _NewOption$246186[ebp+5], 1
$LN1@ItemSerial:

; 2832 : 		}
; 2833 : 
; 2834 : 		LogAddTD("Monster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", gObj[aIndex].Name, MapNumber, pMsg.x, pMsg.y, ItemAttribute[pMsg.Type].Name, pMsg.Level, pMsg.Op1,pMsg.Op2, pMsg.Op3, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4],	NewOption[5], NewOption[6], pMsg.SetOption);

  05839	0f b6 45 f2	 movzx	 eax, BYTE PTR _pMsg$[ebp+22]
  0583d	50		 push	 eax
  0583e	0f b6 4d da	 movzx	 ecx, BYTE PTR _NewOption$246186[ebp+6]
  05842	51		 push	 ecx
  05843	0f b6 55 d9	 movzx	 edx, BYTE PTR _NewOption$246186[ebp+5]
  05847	52		 push	 edx
  05848	0f b6 45 d8	 movzx	 eax, BYTE PTR _NewOption$246186[ebp+4]
  0584c	50		 push	 eax
  0584d	0f b6 4d d7	 movzx	 ecx, BYTE PTR _NewOption$246186[ebp+3]
  05851	51		 push	 ecx
  05852	0f b6 55 d6	 movzx	 edx, BYTE PTR _NewOption$246186[ebp+2]
  05856	52		 push	 edx
  05857	0f b6 45 d5	 movzx	 eax, BYTE PTR _NewOption$246186[ebp+1]
  0585b	50		 push	 eax
  0585c	0f b6 4d d4	 movzx	 ecx, BYTE PTR _NewOption$246186[ebp]
  05860	51		 push	 ecx
  05861	0f b6 55 e8	 movzx	 edx, BYTE PTR _pMsg$[ebp+12]
  05865	52		 push	 edx
  05866	0f b6 45 e7	 movzx	 eax, BYTE PTR _pMsg$[ebp+11]
  0586a	50		 push	 eax
  0586b	0f b6 4d e6	 movzx	 ecx, BYTE PTR _pMsg$[ebp+10]
  0586f	51		 push	 ecx
  05870	0f b6 55 e4	 movzx	 edx, BYTE PTR _pMsg$[ebp+8]
  05874	52		 push	 edx
  05875	0f bf 45 e2	 movsx	 eax, WORD PTR _pMsg$[ebp+6]
  05879	6b c0 70	 imul	 eax, 112		; 00000070H
  0587c	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  05881	50		 push	 eax
  05882	0f b6 4d e0	 movzx	 ecx, BYTE PTR _pMsg$[ebp+4]
  05886	51		 push	 ecx
  05887	0f b6 55 df	 movzx	 edx, BYTE PTR _pMsg$[ebp+3]
  0588b	52		 push	 edx
  0588c	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  05890	50		 push	 eax
  05891	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  05894	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0589a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058a0	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  058a4	50		 push	 eax
  058a5	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@
  058aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  058b0	83 c4 48	 add	 esp, 72			; 00000048H
$LN10@ItemSerial:

; 2835 : 	}
; 2836 : 
; 2837 : 	cDBSMng.Send( (char*)&pMsg, pMsg.h.size);

  058b3	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  058b7	50		 push	 eax
  058b8	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  058bb	51		 push	 ecx
  058bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  058c1	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN19@ItemSerial:

; 2838 : }

  058c6	5f		 pop	 edi
  058c7	5e		 pop	 esi
  058c8	5b		 pop	 ebx
  058c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  058cc	33 cd		 xor	 ecx, ebp
  058ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  058d3	8b e5		 mov	 esp, ebp
  058d5	5d		 pop	 ebp
  058d6	c3		 ret	 0
?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ENDP		; ItemSerialCreateSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z	; PetItemSerialCreateSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_type$ = 24						; size = 4
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Op1$ = 36						; size = 1
_Op2$ = 40						; size = 1
_Op3$ = 44						; size = 1
_LootIndex$ = 48					; size = 4
_NewOption$ = 52					; size = 1
_SetOption$ = 56					; size = 1
?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z PROC	; PetItemSerialCreateSend

; 2842 : {

  058e0	55		 push	 ebp
  058e1	8b ec		 mov	 ebp, esp
  058e3	83 ec 64	 sub	 esp, 100		; 00000064H
  058e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  058eb	33 c5		 xor	 eax, ebp
  058ed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  058f0	53		 push	 ebx
  058f1	56		 push	 esi
  058f2	57		 push	 edi

; 2843 : 	SDHP_ITEMCREATE  pMsg;
; 2844 : 
; 2845 : 	pMsg.h.c = 0xC1;

  058f3	c6 45 dc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2846 : 	pMsg.h.headcode = 0x55;

  058f7	c6 45 de 55	 mov	 BYTE PTR _pMsg$[ebp+2], 85 ; 00000055H

; 2847 : 	pMsg.h.size = sizeof(pMsg);

  058fb	c6 45 dd 20	 mov	 BYTE PTR _pMsg$[ebp+1], 32 ; 00000020H

; 2848 : 	pMsg.MapNumber = MapNumber;

  058ff	8a 45 0c	 mov	 al, BYTE PTR _MapNumber$[ebp]
  05902	88 45 e1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 2849 : 	pMsg.x = x;

  05905	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  05908	88 45 df	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2850 : 	pMsg.y = y;

  0590b	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  0590e	88 45 e0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2851 : 	pMsg.Type = type;

  05911	66 8b 45 18	 mov	 ax, WORD PTR _type$[ebp]
  05915	66 89 45 e2	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 2852 : 	pMsg.Level = level;

  05919	8a 45 1c	 mov	 al, BYTE PTR _level$[ebp]
  0591c	88 45 e4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 2853 : 
; 2854 : 	if (dur == 0 )

  0591f	0f b6 45 20	 movzx	 eax, BYTE PTR _dur$[ebp]
  05923	85 c0		 test	 eax, eax
  05925	75 1e		 jne	 SHORT $LN1@PetItemSer

; 2855 : 	{
; 2856 : 		dur = ItemGetDurability(type, level, NewOption, SetOption);

  05927	0f b6 45 38	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  0592b	50		 push	 eax
  0592c	0f b6 4d 34	 movzx	 ecx, BYTE PTR _NewOption$[ebp]
  05930	51		 push	 ecx
  05931	0f b6 55 1c	 movzx	 edx, BYTE PTR _level$[ebp]
  05935	52		 push	 edx
  05936	8b 45 18	 mov	 eax, DWORD PTR _type$[ebp]
  05939	50		 push	 eax
  0593a	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0593f	83 c4 10	 add	 esp, 16			; 00000010H
  05942	88 45 20	 mov	 BYTE PTR _dur$[ebp], al
$LN1@PetItemSer:

; 2857 : 	}
; 2858 : 
; 2859 : 	pMsg.Dur = dur;

  05945	8a 45 20	 mov	 al, BYTE PTR _dur$[ebp]
  05948	88 45 e5	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 2860 : 	pMsg.Op1 = Op1;

  0594b	8a 45 24	 mov	 al, BYTE PTR _Op1$[ebp]
  0594e	88 45 e6	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 2861 : 	pMsg.Op2 = Op2;

  05951	8a 45 28	 mov	 al, BYTE PTR _Op2$[ebp]
  05954	88 45 e7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 2862 : 	pMsg.Op3 = Op3;

  05957	8a 45 2c	 mov	 al, BYTE PTR _Op3$[ebp]
  0595a	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 2863 : 	pMsg.NewOption = NewOption;

  0595d	8a 45 34	 mov	 al, BYTE PTR _NewOption$[ebp]
  05960	88 45 e9	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 2864 : 	pMsg.aIndex = aIndex;

  05963	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05966	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2865 : 	pMsg.lootindex = LootIndex;

  05969	66 8b 45 30	 mov	 ax, WORD PTR _LootIndex$[ebp]
  0596d	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 2866 : 	pMsg.SetOption = SetOption;

  05971	8a 45 38	 mov	 al, BYTE PTR _SetOption$[ebp]
  05974	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+22], al

; 2867 : 
; 2868 : 	cDBSMng.Send( (char*)&pMsg, pMsg.h.size);

  05977	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0597b	50		 push	 eax
  0597c	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0597f	51		 push	 ecx
  05980	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  05985	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2869 : }

  0598a	5f		 pop	 edi
  0598b	5e		 pop	 esi
  0598c	5b		 pop	 ebx
  0598d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  05990	33 cd		 xor	 ecx, ebp
  05992	e8 00 00 00 00	 call	 @__security_check_cookie@4
  05997	8b e5		 mov	 esp, ebp
  05999	5d		 pop	 ebp
  0599a	c3		 ret	 0
?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ENDP	; PetItemSerialCreateSend
_TEXT	ENDS
PUBLIC	??_C@_0GD@IBNDEANJ@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@ ; `string'
PUBLIC	??_C@_0IG@JDKHCHPG@?$FLSocketItem?$FN?5Drop?5Socket?5Item?5?$CI?5@ ; `string'
PUBLIC	??_C@_0FC@JMDFINCJ@?$FLLuckyCoin?5Trade?$FN?5Error?5?3?5Failed@ ; `string'
PUBLIC	??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@ ; `string'
PUBLIC	??_C@_0GA@MJMGDDA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@ ; `string'
PUBLIC	??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@ ; `string'
PUBLIC	??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@ ; `string'
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA ; `ItemSerialCreateRecv'::`2'::__LINE__Var
PUBLIC	__$ArrayPad$
EXTRN	?GetBridgeIndex@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeIndex
EXTRN	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEQAEE@Z:PROC ; MapClass::MonsterItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?GetRandomSlotCount@CSocketOption@@QAEEH@Z:PROC	; CSocketOption::GetRandomSlotCount
EXTRN	?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z:PROC ; CBloodCastle::GetItemMapNumberSecond
EXTRN	?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z:PROC ; CBloodCastle::GetItemMapNumberFirst
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?GCSendLuckyCoinResult@@YAXHE@Z:PROC		; GCSendLuckyCoinResult
EXTRN	?SetPeriodItemInfo@CPeriodItemEx@@QAE_NPAUOBJECTSTRUCT@@GKK@Z:PROC ; CPeriodItemEx::SetPeriodItemInfo
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?gObjInventoryInsertItem@@YAEHVCItem@@@Z:PROC	; gObjInventoryInsertItem
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjChaosItemSet@@YAXHHE@Z:PROC		; gObjChaosItemSet
EXTRN	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjChaosBoxInsertItemPos
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?SockeetItem@cGrandHero@@QAE_NH@Z:PROC		; cGrandHero::SockeetItem
EXTRN	?GrandHero@@3VcGrandHero@@A:BYTE		; GrandHero
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
;	COMDAT ??_C@_0GD@IBNDEANJ@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@
CONST	SEGMENT
??_C@_0GD@IBNDEANJ@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@ DB 'M'
	DB	'onster Item Drop [%d][%d][%d] : serial:%u [%s][%d][%d][%d][%d'
	DB	'] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IG@JDKHCHPG@?$FLSocketItem?$FN?5Drop?5Socket?5Item?5?$CI?5@
CONST	SEGMENT
??_C@_0IG@JDKHCHPG@?$FLSocketItem?$FN?5Drop?5Socket?5Item?5?$CI?5@ DB '[S'
	DB	'ocketItem] Drop Socket Item ( Socket Slot : %d ) - %s, [%d,%d'
	DB	',%d,%d], Serial : %u, ItemCode : %d, Level : %d, MapNumber : '
	DB	'%d(%d/%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@JMDFINCJ@?$FLLuckyCoin?5Trade?$FN?5Error?5?3?5Failed@
CONST	SEGMENT
??_C@_0FC@JMDFINCJ@?$FLLuckyCoin?5Trade?$FN?5Error?5?3?5Failed@ DB '[Luck'
	DB	'yCoin Trade] Error : Failed To Insert Item Type:%d, TypeIndex'
	DB	':%d to [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@
CONST	SEGMENT
??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@ DB '[Cas'
	DB	'hShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to'
	DB	' [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@MJMGDDA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@
CONST	SEGMENT
??_C@_0GA@MJMGDDA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@ DB '['
	DB	'%s][%s] CBMix Item Create Item:%s [%u][%d] [%d][%d][%d][%d] E'
	DB	'x:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@
CONST	SEGMENT
??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@ DB 'error-L2: '
	DB	'ChaosBox not used.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@
CONST	SEGMENT
??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@ DB 'error-L2: D'
	DB	'arkTrainerBox not used.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA DD 0b39H ; `ItemSerialCreateRecv'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
tv1587 = -1100						; size = 4
tv1513 = -1100						; size = 4
tv1452 = -1100						; size = 4
tv1380 = -1100						; size = 4
tv1158 = -1100						; size = 4
tv1155 = -1100						; size = 4
tv1152 = -1100						; size = 4
tv1008 = -1100						; size = 4
_i$246349 = -1032					; size = 4
_NewOption$246348 = -1028				; size = 8
_iBridgeIndex$246344 = -1020				; size = 4
_iItemCount$246340 = -1016				; size = 4
_i$246336 = -1012					; size = 4
_i$246329 = -1008					; size = 4
_SocketOptionIndex$246326 = -1001			; size = 1
_SocketOption$246325 = -1000				; size = 5
_SocketSlotCount$246324 = -989				; size = 1
_iRetMapNumber$246321 = -988				; size = 4
_btItemPos$246315 = -981				; size = 1
_iItemIndex$246314 = -980				; size = 4
_iItemType$246313 = -976				; size = 4
_pCreateItem$246312 = -972				; size = 212
_btItemPos$246301 = -757				; size = 1
_iItemIndex$246300 = -756				; size = 4
_iItemType$246299 = -752				; size = 4
_pCreateItem$246298 = -748				; size = 212
_btItemPos$246287 = -533				; size = 1
_CS_Item$246285 = -532					; size = 5
_iItemIndex$246283 = -524				; size = 4
_iItemType$246282 = -520				; size = 4
_pCreateItem$246281 = -516				; size = 212
_ExOption$246276 = -304					; size = 8
_Sockeet$246272 = -296					; size = 5
_Sockeet$246269 = -288					; size = 5
_Sockeet$246266 = -280					; size = 5
_Sockeet$246263 = -272					; size = 5
_Sockeet$246260 = -264					; size = 5
_Sockeet$246254 = -256					; size = 5
_NewItem$246248 = -248					; size = 212
_pMsg$246243 = -36					; size = 16
_lootindex$ = -20					; size = 4
_aIndex$ = -16						; size = 4
_mapnumber$ = -12					; size = 4
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z PROC ; ItemSerialCreateRecv

; 2873 : {

  059a0	55		 push	 ebp
  059a1	8b ec		 mov	 ebp, esp
  059a3	81 ec 4c 04 00
	00		 sub	 esp, 1100		; 0000044cH
  059a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  059ae	33 c5		 xor	 eax, ebp
  059b0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  059b3	53		 push	 ebx
  059b4	56		 push	 esi
  059b5	57		 push	 edi

; 2874 : #if(DANGER_FIX==TRUE)
; 2875 : 	if(!lpMsg)

  059b6	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  059ba	75 05		 jne	 SHORT $LN84@ItemSerial@2

; 2876 : 	{
; 2877 : 		return;

  059bc	e9 89 13 00 00	 jmp	 $LN85@ItemSerial@2
$LN84@ItemSerial@2:

; 2878 : 	}
; 2879 : #endif
; 2880 : 
; 2881 : 	LPOBJ lpObj;
; 2882 : 	int mapnumber = lpMsg->MapNumber;

  059c1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  059c4	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  059c8	89 4d f4	 mov	 DWORD PTR _mapnumber$[ebp], ecx

; 2883 : 	int aIndex = lpMsg->aIndex;

  059cb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  059ce	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  059d1	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2884 : 	int lootindex = lpMsg->lootindex;

  059d4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  059d7	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  059db	89 4d ec	 mov	 DWORD PTR _lootindex$[ebp], ecx

; 2885 : 
; 2886 : 	if ( mapnumber != (BYTE)-1 )

  059de	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _mapnumber$[ebp], 255 ; 000000ffH
  059e5	74 1a		 je	 SHORT $LN82@ItemSerial@2

; 2887 : 	{
; 2888 : 		if ( mapnumber < 0 || (mapnumber > MAX_NUMBER_MAP-1 && mapnumber < 235) )

  059e7	83 7d f4 00	 cmp	 DWORD PTR _mapnumber$[ebp], 0
  059eb	7c 0f		 jl	 SHORT $LN81@ItemSerial@2
  059ed	83 7d f4 59	 cmp	 DWORD PTR _mapnumber$[ebp], 89 ; 00000059H
  059f1	7e 0e		 jle	 SHORT $LN82@ItemSerial@2
  059f3	81 7d f4 eb 00
	00 00		 cmp	 DWORD PTR _mapnumber$[ebp], 235 ; 000000ebH
  059fa	7d 05		 jge	 SHORT $LN82@ItemSerial@2
$LN81@ItemSerial@2:

; 2889 : 		{
; 2890 : 			return;

  059fc	e9 49 13 00 00	 jmp	 $LN85@ItemSerial@2
$LN82@ItemSerial@2:

; 2891 : 		}
; 2892 : 	}
; 2893 : 
; 2894 : 	if ( lpMsg->MapNumber == (BYTE)-1 || lpMsg->MapNumber == (BYTE)-2 )

  05a01	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05a04	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  05a08	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  05a0e	74 13		 je	 SHORT $LN79@ItemSerial@2
  05a10	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05a13	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  05a17	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  05a1d	0f 85 58 07 00
	00		 jne	 $LN80@ItemSerial@2
$LN79@ItemSerial@2:

; 2895 : 	{
; 2896 : 		if ( gObjIsConnectedGP(aIndex) == FALSE )

  05a23	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05a26	50		 push	 eax
  05a27	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  05a2c	83 c4 04	 add	 esp, 4
  05a2f	85 c0		 test	 eax, eax
  05a31	75 23		 jne	 SHORT $LN78@ItemSerial@2

; 2897 : 		{
; 2898 : 			LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  05a33	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA
  05a38	83 c0 19	 add	 eax, 25			; 00000019H
  05a3b	50		 push	 eax
  05a3c	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
  05a41	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  05a46	6a 02		 push	 2
  05a48	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  05a4e	83 c4 10	 add	 esp, 16			; 00000010H

; 2899 : 			return;

  05a51	e9 f4 12 00 00	 jmp	 $LN85@ItemSerial@2
$LN78@ItemSerial@2:

; 2900 : 		}
; 2901 : 		
; 2902 : 		lpObj = &gObj[aIndex];

  05a56	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  05a59	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05a5f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05a65	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2903 : 
; 2904 : 		if ( lpMsg->MapNumber == (BYTE)-2 )

  05a68	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05a6b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  05a6f	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  05a75	75 2c		 jne	 SHORT $LN77@ItemSerial@2

; 2905 : 		{
; 2906 : 			if ( lpObj->m_IfState.type != 13 )

  05a77	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05a7a	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  05a80	c1 e9 06	 shr	 ecx, 6
  05a83	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  05a89	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  05a8c	74 13		 je	 SHORT $LN76@ItemSerial@2

; 2907 : 			{
; 2908 : 				LogAdd("error-L2: DarkTrainerBox not used.");

  05a8e	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@
  05a93	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  05a99	83 c4 04	 add	 esp, 4

; 2909 : 				return;

  05a9c	e9 a9 12 00 00	 jmp	 $LN85@ItemSerial@2
$LN76@ItemSerial@2:

; 2910 : 			}
; 2911 : 		}

  05aa1	eb 2a		 jmp	 SHORT $LN74@ItemSerial@2
$LN77@ItemSerial@2:

; 2912 : 		else if ( lpObj->m_IfState.type != 7 )

  05aa3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05aa6	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  05aac	c1 e9 06	 shr	 ecx, 6
  05aaf	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  05ab5	83 f9 07	 cmp	 ecx, 7
  05ab8	74 13		 je	 SHORT $LN74@ItemSerial@2

; 2913 : 		{
; 2914 : 			LogAdd("error-L2: ChaosBox not used.");

  05aba	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@
  05abf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  05ac5	83 c4 04	 add	 esp, 4

; 2915 : 			return;

  05ac8	e9 7d 12 00 00	 jmp	 $LN85@ItemSerial@2
$LN74@ItemSerial@2:

; 2916 : 		}
; 2917 : 		
; 2918 : 		PMSG_CHAOSMIXRESULT pMsg;
; 2919 : 
; 2920 : 		pMsg.h.c = 0xC1;

  05acd	c6 45 dc c1	 mov	 BYTE PTR _pMsg$246243[ebp], 193 ; 000000c1H

; 2921 : 		pMsg.h.headcode = 0x86;

  05ad1	c6 45 de 86	 mov	 BYTE PTR _pMsg$246243[ebp+2], 134 ; 00000086H

; 2922 : 		pMsg.h.size = sizeof(PMSG_CHAOSMIXRESULT);

  05ad5	c6 45 dd 10	 mov	 BYTE PTR _pMsg$246243[ebp+1], 16 ; 00000010H

; 2923 : 
; 2924 : 		if ( lpMsg->MapNumber == (BYTE)-2 )

  05ad9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05adc	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  05ae0	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  05ae6	75 06		 jne	 SHORT $LN73@ItemSerial@2

; 2925 : 		{
; 2926 : 			pMsg.Result = 100;

  05ae8	c6 45 df 64	 mov	 BYTE PTR _pMsg$246243[ebp+3], 100 ; 00000064H

; 2927 : 		}
; 2928 : 		else

  05aec	eb 04		 jmp	 SHORT $LN72@ItemSerial@2
$LN73@ItemSerial@2:

; 2929 : 		{
; 2930 : 			pMsg.Result = 1;

  05aee	c6 45 df 01	 mov	 BYTE PTR _pMsg$246243[ebp+3], 1
$LN72@ItemSerial@2:

; 2931 : 		}
; 2932 : 
; 2933 : 		CItem NewItem;

  05af2	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05af8	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 2934 : 
; 2935 : 		NewItem.m_Level = lpMsg->Level;

  05afd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b00	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  05b05	66 89 8d 10 ff
	ff ff		 mov	 WORD PTR _NewItem$246248[ebp+8], cx

; 2936 : 		NewItem.m_Durability = (float)ItemGetDurability(lpMsg->Type, lpMsg->Level, lpMsg->NewOption, lpMsg->SetOption);

  05b0c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b0f	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  05b13	51		 push	 ecx
  05b14	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05b17	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  05b1b	50		 push	 eax
  05b1c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05b1f	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  05b23	52		 push	 edx
  05b24	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b27	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  05b2b	51		 push	 ecx
  05b2c	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  05b31	83 c4 10	 add	 esp, 16			; 00000010H
  05b34	89 85 b4 fb ff
	ff		 mov	 DWORD PTR tv1152[ebp], eax
  05b3a	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1152[ebp]
  05b40	d9 9d 2c ff ff
	ff		 fstp	 DWORD PTR _NewItem$246248[ebp+36]

; 2937 : 
; 2938 : 		if ( lpMsg->Type == ITEMGET(14,7) ) // Siege Potion

  05b46	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b49	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  05b4d	81 f9 07 1c 00
	00		 cmp	 ecx, 7175		; 00001c07H
  05b53	75 19		 jne	 SHORT $LN71@ItemSerial@2

; 2939 : 		{
; 2940 : 			NewItem.m_Durability = lpMsg->Dur;

  05b55	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b58	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  05b5c	89 8d b4 fb ff
	ff		 mov	 DWORD PTR tv1155[ebp], ecx
  05b62	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1155[ebp]
  05b68	d9 9d 2c ff ff
	ff		 fstp	 DWORD PTR _NewItem$246248[ebp+36]
$LN71@ItemSerial@2:

; 2941 : 		}
; 2942 : 
; 2943 : 		if ( lpMsg->Type == ITEMGET(13,37) )

  05b6e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b71	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  05b75	81 f9 25 1a 00
	00		 cmp	 ecx, 6693		; 00001a25H
  05b7b	75 19		 jne	 SHORT $LN70@ItemSerial@2

; 2944 : 		{
; 2945 : 			NewItem.m_Durability = lpMsg->Dur;// egfg

  05b7d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05b80	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  05b84	89 8d b4 fb ff
	ff		 mov	 DWORD PTR tv1158[ebp], ecx
  05b8a	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1158[ebp]
  05b90	d9 9d 2c ff ff
	ff		 fstp	 DWORD PTR _NewItem$246248[ebp+36]
$LN70@ItemSerial@2:

; 2946 : 		}
; 2947 : 
; 2948 : #ifdef PRIVATE_MODULE
; 2949 : 
; 2950 : #ifdef GRAND_HERO_DEV
; 2951 : 		if(g_ExLicense.user.GrandHero)

  05b96	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  05b9d	85 c0		 test	 eax, eax
  05b9f	0f 84 d4 00 00
	00		 je	 $LN67@ItemSerial@2

; 2952 : 		{
; 2953 : 			if(GrandHero.SockeetItem(lpMsg->Type) == TRUE)

  05ba5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05ba8	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  05bac	51		 push	 ecx
  05bad	b9 00 00 00 00	 mov	 ecx, OFFSET ?GrandHero@@3VcGrandHero@@A ; GrandHero
  05bb2	e8 00 00 00 00	 call	 ?SockeetItem@cGrandHero@@QAE_NH@Z ; cGrandHero::SockeetItem
  05bb7	0f b6 d0	 movzx	 edx, al
  05bba	83 fa 01	 cmp	 edx, 1
  05bbd	75 72		 jne	 SHORT $LN68@ItemSerial@2

; 2954 : 			{
; 2955 : 				BYTE Sockeet[5] = {0xFE,0xFE,0xFE,0xFE,0xFE};

  05bbf	c6 85 00 ff ff
	ff fe		 mov	 BYTE PTR _Sockeet$246254[ebp], 254 ; 000000feH
  05bc6	c6 85 01 ff ff
	ff fe		 mov	 BYTE PTR _Sockeet$246254[ebp+1], 254 ; 000000feH
  05bcd	c6 85 02 ff ff
	ff fe		 mov	 BYTE PTR _Sockeet$246254[ebp+2], 254 ; 000000feH
  05bd4	c6 85 03 ff ff
	ff fe		 mov	 BYTE PTR _Sockeet$246254[ebp+3], 254 ; 000000feH
  05bdb	c6 85 04 ff ff
	ff fe		 mov	 BYTE PTR _Sockeet$246254[ebp+4], 254 ; 000000feH

; 2956 : 				NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, Sockeet, 0xFF, 0, CURRENT_DB_VERSION);

  05be2	6a 03		 push	 3
  05be4	6a 00		 push	 0
  05be6	68 ff 00 00 00	 push	 255			; 000000ffH
  05beb	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _Sockeet$246254[ebp]
  05bf1	50		 push	 eax
  05bf2	6a 00		 push	 0
  05bf4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05bf7	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  05bfb	52		 push	 edx
  05bfc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05bff	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  05c03	51		 push	 ecx
  05c04	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05c07	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  05c0b	50		 push	 eax
  05c0c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05c0f	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  05c13	52		 push	 edx
  05c14	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05c17	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  05c1b	51		 push	 ecx
  05c1c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05c1f	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  05c23	50		 push	 eax
  05c24	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05c2a	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 2957 : 			}
; 2958 : 			else

  05c2f	eb 48		 jmp	 SHORT $LN67@ItemSerial@2
$LN68@ItemSerial@2:

; 2959 : 			{
; 2960 : 				NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, 0, 0xFF, 0, CURRENT_DB_VERSION);

  05c31	6a 03		 push	 3
  05c33	6a 00		 push	 0
  05c35	68 ff 00 00 00	 push	 255			; 000000ffH
  05c3a	6a 00		 push	 0
  05c3c	6a 00		 push	 0
  05c3e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05c41	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  05c45	51		 push	 ecx
  05c46	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05c49	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  05c4d	50		 push	 eax
  05c4e	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05c51	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  05c55	52		 push	 edx
  05c56	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05c59	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  05c5d	51		 push	 ecx
  05c5e	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05c61	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  05c65	50		 push	 eax
  05c66	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05c69	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  05c6d	52		 push	 edx
  05c6e	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05c74	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
$LN67@ItemSerial@2:

; 2961 : 			}
; 2962 : 		}
; 2963 : #endif
; 2964 : 		if(g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::MedoniAndrei))

  05c79	6a 01		 push	 1
  05c7b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  05c80	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  05c85	0f b6 c0	 movzx	 eax, al
  05c88	85 c0		 test	 eax, eax
  05c8a	75 17		 jne	 SHORT $LN65@ItemSerial@2
  05c8c	6a 32		 push	 50			; 00000032H
  05c8e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  05c93	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  05c98	0f b6 c0	 movzx	 eax, al
  05c9b	85 c0		 test	 eax, eax
  05c9d	0f 84 42 03 00
	00		 je	 $LN66@ItemSerial@2
$LN65@ItemSerial@2:

; 2965 : 		{
; 2966 : 			if(g_SocketOption.CheckItemType(lpMsg->Type))

  05ca3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05ca6	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  05caa	51		 push	 ecx
  05cab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  05cb0	e8 00 00 00 00	 call	 ?CheckItemType@CSocketOption@@QAEEH@Z ; CSocketOption::CheckItemType
  05cb5	0f b6 d0	 movzx	 edx, al
  05cb8	85 d2		 test	 edx, edx
  05cba	0f 84 db 02 00
	00		 je	 $LN64@ItemSerial@2

; 2967 : 			{
; 2968 : 				if(lpObj->MixManagerSocket == 1)

  05cc0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05cc3	0f b6 88 18 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10264]
  05cca	83 f9 01	 cmp	 ecx, 1
  05ccd	75 75		 jne	 SHORT $LN63@ItemSerial@2

; 2969 : 				{
; 2970 : 					BYTE Sockeet[5] = {0xFE,0xFF,0xFF,0xFF,0xFF};

  05ccf	c6 85 f8 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246260[ebp], 254 ; 000000feH
  05cd6	c6 85 f9 fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246260[ebp+1], 255 ; 000000ffH
  05cdd	c6 85 fa fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246260[ebp+2], 255 ; 000000ffH
  05ce4	c6 85 fb fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246260[ebp+3], 255 ; 000000ffH
  05ceb	c6 85 fc fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246260[ebp+4], 255 ; 000000ffH

; 2971 : 					NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, Sockeet, 0xFF, 0, CURRENT_DB_VERSION);

  05cf2	6a 03		 push	 3
  05cf4	6a 00		 push	 0
  05cf6	68 ff 00 00 00	 push	 255			; 000000ffH
  05cfb	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _Sockeet$246260[ebp]
  05d01	50		 push	 eax
  05d02	6a 00		 push	 0
  05d04	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05d07	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  05d0b	52		 push	 edx
  05d0c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05d0f	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  05d13	51		 push	 ecx
  05d14	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05d17	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  05d1b	50		 push	 eax
  05d1c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05d1f	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  05d23	52		 push	 edx
  05d24	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05d27	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  05d2b	51		 push	 ecx
  05d2c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05d2f	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  05d33	50		 push	 eax
  05d34	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05d3a	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
  05d3f	e9 55 02 00 00	 jmp	 $LN54@ItemSerial@2
$LN63@ItemSerial@2:

; 2972 : 				}
; 2973 : 				else if(lpObj->MixManagerSocket == 2)

  05d44	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05d47	0f b6 88 18 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10264]
  05d4e	83 f9 02	 cmp	 ecx, 2
  05d51	75 75		 jne	 SHORT $LN61@ItemSerial@2

; 2974 : 				{
; 2975 : 					BYTE Sockeet[5] = {0xFE,0xFE,0xFF,0xFF,0xFF};

  05d53	c6 85 f0 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246263[ebp], 254 ; 000000feH
  05d5a	c6 85 f1 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246263[ebp+1], 254 ; 000000feH
  05d61	c6 85 f2 fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246263[ebp+2], 255 ; 000000ffH
  05d68	c6 85 f3 fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246263[ebp+3], 255 ; 000000ffH
  05d6f	c6 85 f4 fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246263[ebp+4], 255 ; 000000ffH

; 2976 : 					NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, Sockeet, 0xFF, 0, CURRENT_DB_VERSION);

  05d76	6a 03		 push	 3
  05d78	6a 00		 push	 0
  05d7a	68 ff 00 00 00	 push	 255			; 000000ffH
  05d7f	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Sockeet$246263[ebp]
  05d85	50		 push	 eax
  05d86	6a 00		 push	 0
  05d88	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05d8b	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  05d8f	52		 push	 edx
  05d90	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05d93	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  05d97	51		 push	 ecx
  05d98	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05d9b	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  05d9f	50		 push	 eax
  05da0	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05da3	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  05da7	52		 push	 edx
  05da8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05dab	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  05daf	51		 push	 ecx
  05db0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05db3	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  05db7	50		 push	 eax
  05db8	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05dbe	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
  05dc3	e9 d1 01 00 00	 jmp	 $LN54@ItemSerial@2
$LN61@ItemSerial@2:

; 2977 : 				}
; 2978 : 				else if(lpObj->MixManagerSocket == 3)

  05dc8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05dcb	0f b6 88 18 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10264]
  05dd2	83 f9 03	 cmp	 ecx, 3
  05dd5	75 75		 jne	 SHORT $LN59@ItemSerial@2

; 2979 : 				{
; 2980 : 					BYTE Sockeet[5] = {0xFE,0xFE,0xFE,0xFF,0xFF};

  05dd7	c6 85 e8 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246266[ebp], 254 ; 000000feH
  05dde	c6 85 e9 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246266[ebp+1], 254 ; 000000feH
  05de5	c6 85 ea fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246266[ebp+2], 254 ; 000000feH
  05dec	c6 85 eb fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246266[ebp+3], 255 ; 000000ffH
  05df3	c6 85 ec fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246266[ebp+4], 255 ; 000000ffH

; 2981 : 					NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, Sockeet, 0xFF, 0, CURRENT_DB_VERSION);

  05dfa	6a 03		 push	 3
  05dfc	6a 00		 push	 0
  05dfe	68 ff 00 00 00	 push	 255			; 000000ffH
  05e03	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _Sockeet$246266[ebp]
  05e09	50		 push	 eax
  05e0a	6a 00		 push	 0
  05e0c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05e0f	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  05e13	52		 push	 edx
  05e14	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05e17	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  05e1b	51		 push	 ecx
  05e1c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05e1f	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  05e23	50		 push	 eax
  05e24	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05e27	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  05e2b	52		 push	 edx
  05e2c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05e2f	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  05e33	51		 push	 ecx
  05e34	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05e37	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  05e3b	50		 push	 eax
  05e3c	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05e42	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
  05e47	e9 4d 01 00 00	 jmp	 $LN54@ItemSerial@2
$LN59@ItemSerial@2:

; 2982 : 				}
; 2983 : 				else if(lpObj->MixManagerSocket == 4)

  05e4c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05e4f	0f b6 88 18 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10264]
  05e56	83 f9 04	 cmp	 ecx, 4
  05e59	75 75		 jne	 SHORT $LN57@ItemSerial@2

; 2984 : 				{
; 2985 : 					BYTE Sockeet[5] = {0xFE,0xFE,0xFE,0xFE,0xFF};

  05e5b	c6 85 e0 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246269[ebp], 254 ; 000000feH
  05e62	c6 85 e1 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246269[ebp+1], 254 ; 000000feH
  05e69	c6 85 e2 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246269[ebp+2], 254 ; 000000feH
  05e70	c6 85 e3 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246269[ebp+3], 254 ; 000000feH
  05e77	c6 85 e4 fe ff
	ff ff		 mov	 BYTE PTR _Sockeet$246269[ebp+4], 255 ; 000000ffH

; 2986 : 					NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, Sockeet, 0xFF, 0, CURRENT_DB_VERSION);

  05e7e	6a 03		 push	 3
  05e80	6a 00		 push	 0
  05e82	68 ff 00 00 00	 push	 255			; 000000ffH
  05e87	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _Sockeet$246269[ebp]
  05e8d	50		 push	 eax
  05e8e	6a 00		 push	 0
  05e90	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05e93	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  05e97	52		 push	 edx
  05e98	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05e9b	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  05e9f	51		 push	 ecx
  05ea0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05ea3	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  05ea7	50		 push	 eax
  05ea8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05eab	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  05eaf	52		 push	 edx
  05eb0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05eb3	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  05eb7	51		 push	 ecx
  05eb8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05ebb	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  05ebf	50		 push	 eax
  05ec0	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05ec6	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
  05ecb	e9 c9 00 00 00	 jmp	 $LN54@ItemSerial@2
$LN57@ItemSerial@2:

; 2987 : 				}
; 2988 : 				else if(lpObj->MixManagerSocket == 5)

  05ed0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  05ed3	0f b6 88 18 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10264]
  05eda	83 f9 05	 cmp	 ecx, 5
  05edd	75 72		 jne	 SHORT $LN55@ItemSerial@2

; 2989 : 				{
; 2990 : 					BYTE Sockeet[5] = {0xFE,0xFE,0xFE,0xFE,0xFE};

  05edf	c6 85 d8 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246272[ebp], 254 ; 000000feH
  05ee6	c6 85 d9 fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246272[ebp+1], 254 ; 000000feH
  05eed	c6 85 da fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246272[ebp+2], 254 ; 000000feH
  05ef4	c6 85 db fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246272[ebp+3], 254 ; 000000feH
  05efb	c6 85 dc fe ff
	ff fe		 mov	 BYTE PTR _Sockeet$246272[ebp+4], 254 ; 000000feH

; 2991 : 					NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, Sockeet, 0xFF, 0, CURRENT_DB_VERSION);

  05f02	6a 03		 push	 3
  05f04	6a 00		 push	 0
  05f06	68 ff 00 00 00	 push	 255			; 000000ffH
  05f0b	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _Sockeet$246272[ebp]
  05f11	50		 push	 eax
  05f12	6a 00		 push	 0
  05f14	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05f17	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  05f1b	52		 push	 edx
  05f1c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05f1f	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  05f23	51		 push	 ecx
  05f24	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05f27	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  05f2b	50		 push	 eax
  05f2c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05f2f	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  05f33	52		 push	 edx
  05f34	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05f37	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  05f3b	51		 push	 ecx
  05f3c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05f3f	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  05f43	50		 push	 eax
  05f44	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05f4a	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 2992 : 				}
; 2993 : 				else

  05f4f	eb 48		 jmp	 SHORT $LN54@ItemSerial@2
$LN55@ItemSerial@2:

; 2994 : 				{
; 2995 : 					NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, NULL, 0xFF, 0, CURRENT_DB_VERSION);

  05f51	6a 03		 push	 3
  05f53	6a 00		 push	 0
  05f55	68 ff 00 00 00	 push	 255			; 000000ffH
  05f5a	6a 00		 push	 0
  05f5c	6a 00		 push	 0
  05f5e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05f61	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  05f65	51		 push	 ecx
  05f66	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05f69	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  05f6d	50		 push	 eax
  05f6e	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05f71	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  05f75	52		 push	 edx
  05f76	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05f79	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  05f7d	51		 push	 ecx
  05f7e	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05f81	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  05f85	50		 push	 eax
  05f86	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05f89	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  05f8d	52		 push	 edx
  05f8e	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05f94	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
$LN54@ItemSerial@2:

; 2996 : 				}
; 2997 : 			}
; 2998 : 			else

  05f99	eb 48		 jmp	 SHORT $LN53@ItemSerial@2
$LN64@ItemSerial@2:

; 2999 : 			{
; 3000 : 				NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, NULL, 0xFF, 0, CURRENT_DB_VERSION);

  05f9b	6a 03		 push	 3
  05f9d	6a 00		 push	 0
  05f9f	68 ff 00 00 00	 push	 255			; 000000ffH
  05fa4	6a 00		 push	 0
  05fa6	6a 00		 push	 0
  05fa8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05fab	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  05faf	51		 push	 ecx
  05fb0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05fb3	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  05fb7	50		 push	 eax
  05fb8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05fbb	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  05fbf	52		 push	 edx
  05fc0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05fc3	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  05fc7	51		 push	 ecx
  05fc8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05fcb	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  05fcf	50		 push	 eax
  05fd0	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  05fd3	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  05fd7	52		 push	 edx
  05fd8	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  05fde	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
$LN53@ItemSerial@2:

; 3001 : 			}
; 3002 : 		}
; 3003 : 		else

  05fe3	eb 48		 jmp	 SHORT $LN52@ItemSerial@2
$LN66@ItemSerial@2:

; 3004 : 		{
; 3005 : 			NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, NULL, 0xFF, 0, CURRENT_DB_VERSION);

  05fe5	6a 03		 push	 3
  05fe7	6a 00		 push	 0
  05fe9	68 ff 00 00 00	 push	 255			; 000000ffH
  05fee	6a 00		 push	 0
  05ff0	6a 00		 push	 0
  05ff2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  05ff5	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  05ff9	51		 push	 ecx
  05ffa	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  05ffd	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  06001	50		 push	 eax
  06002	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06005	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  06009	52		 push	 edx
  0600a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0600d	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  06011	51		 push	 ecx
  06012	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06015	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  06019	50		 push	 eax
  0601a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0601d	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  06021	52		 push	 edx
  06022	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  06028	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
$LN52@ItemSerial@2:

; 3006 : 		}
; 3007 : #else
; 3008 : 		NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0, NULL, 0xFF, 0, CURRENT_DB_VERSION);
; 3009 : #endif
; 3010 : 		ItemByteConvert(pMsg.ItemInfo, NewItem);

  0602d	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  06033	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  06038	8d b5 08 ff ff
	ff		 lea	 esi, DWORD PTR _NewItem$246248[ebp]
  0603e	8b fc		 mov	 edi, esp
  06040	f3 a5		 rep movsd
  06042	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$246243[ebp+4]
  06045	50		 push	 eax
  06046	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  0604b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3011 : 
; 3012 : 		NewItem.m_Number = lpMsg->m_Number;

  06051	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06054	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  06057	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _NewItem$246248[ebp], ecx

; 3013 : 		g_MixSystem.ChaosBoxInit(lpObj);

  0605d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06060	50		 push	 eax
  06061	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  06066	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 3014 : 		gObjChaosBoxInsertItemPos(aIndex, NewItem, 0, -1);

  0606b	6a ff		 push	 -1
  0606d	6a 00		 push	 0
  0606f	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  06075	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0607a	8d b5 08 ff ff
	ff		 lea	 esi, DWORD PTR _NewItem$246248[ebp]
  06080	8b fc		 mov	 edi, esp
  06082	f3 a5		 rep movsd
  06084	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  06087	50		 push	 eax
  06088	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos
  0608d	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H

; 3015 : 		gObjChaosItemSet(aIndex, 0, 1);

  06093	6a 01		 push	 1
  06095	6a 00		 push	 0
  06097	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0609a	50		 push	 eax
  0609b	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet
  060a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3016 : 		BYTE ExOption[MAX_EXOPTION_SIZE];
; 3017 : 		ItemIsBufExOption(ExOption, &NewItem);

  060a3	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR _NewItem$246248[ebp]
  060a9	50		 push	 eax
  060aa	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _ExOption$246276[ebp]
  060b0	51		 push	 ecx
  060b1	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  060b6	83 c4 08	 add	 esp, 8

; 3018 : 
; 3019 : 		LogAddTD("[%s][%s] CBMix Item Create Item:%s [%u][%d] [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",	lpObj->AccountID, lpObj->Name, NewItem.GetName(), lpMsg->m_Number, lpMsg->Dur, NewItem.m_Level, NewItem.m_Option1, NewItem.m_Option2, NewItem.m_Option3, ExOption[0], ExOption[1], ExOption[2], ExOption[3], ExOption[4], ExOption[5], ExOption[6], lpMsg->SetOption);

  060b9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  060bc	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  060c0	51		 push	 ecx
  060c1	0f b6 95 d6 fe
	ff ff		 movzx	 edx, BYTE PTR _ExOption$246276[ebp+6]
  060c8	52		 push	 edx
  060c9	0f b6 85 d5 fe
	ff ff		 movzx	 eax, BYTE PTR _ExOption$246276[ebp+5]
  060d0	50		 push	 eax
  060d1	0f b6 8d d4 fe
	ff ff		 movzx	 ecx, BYTE PTR _ExOption$246276[ebp+4]
  060d8	51		 push	 ecx
  060d9	0f b6 95 d3 fe
	ff ff		 movzx	 edx, BYTE PTR _ExOption$246276[ebp+3]
  060e0	52		 push	 edx
  060e1	0f b6 85 d2 fe
	ff ff		 movzx	 eax, BYTE PTR _ExOption$246276[ebp+2]
  060e8	50		 push	 eax
  060e9	0f b6 8d d1 fe
	ff ff		 movzx	 ecx, BYTE PTR _ExOption$246276[ebp+1]
  060f0	51		 push	 ecx
  060f1	0f b6 95 d0 fe
	ff ff		 movzx	 edx, BYTE PTR _ExOption$246276[ebp]
  060f8	52		 push	 edx
  060f9	0f b6 45 9e	 movzx	 eax, BYTE PTR _NewItem$246248[ebp+150]
  060fd	50		 push	 eax
  060fe	0f b6 4d 9d	 movzx	 ecx, BYTE PTR _NewItem$246248[ebp+149]
  06102	51		 push	 ecx
  06103	0f b6 55 9c	 movzx	 edx, BYTE PTR _NewItem$246248[ebp+148]
  06107	52		 push	 edx
  06108	0f bf 85 10 ff
	ff ff		 movsx	 eax, WORD PTR _NewItem$246248[ebp+8]
  0610f	50		 push	 eax
  06110	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06113	0f b6 51 0f	 movzx	 edx, BYTE PTR [ecx+15]
  06117	52		 push	 edx
  06118	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0611b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0611e	51		 push	 ecx
  0611f	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$246248[ebp]
  06125	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0612a	50		 push	 eax
  0612b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0612e	83 c2 77	 add	 edx, 119		; 00000077H
  06131	52		 push	 edx
  06132	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  06135	83 c0 6c	 add	 eax, 108		; 0000006cH
  06138	50		 push	 eax
  06139	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@MJMGDDA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@
  0613e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  06144	83 c4 48	 add	 esp, 72			; 00000048H

; 3020 : 
; 3021 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  06147	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$246243[ebp+1]
  0614b	50		 push	 eax
  0614c	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$246243[ebp]
  0614f	51		 push	 ecx
  06150	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  06153	52		 push	 edx
  06154	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  06159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3022 : 		gObj[aIndex].ChaosLock = FALSE;

  0615c	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0615f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0616b	c7 84 01 88 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3720], 0

; 3023 : 		return;

  06176	e9 cf 0b 00 00	 jmp	 $LN85@ItemSerial@2
$LN80@ItemSerial@2:

; 3024 : 	}
; 3025 : 
; 3026 : 	if ( lpMsg->MapNumber == 235 )

  0617b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0617e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  06182	81 f9 eb 00 00
	00		 cmp	 ecx, 235		; 000000ebH
  06188	0f 85 55 02 00
	00		 jne	 $LN51@ItemSerial@2

; 3027 : 	{
; 3028 : 		//if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )
; 3029 : 		//{
; 3030 : 		//	int iType  = ITEM_GET_TYPE(lpMsg->Type);
; 3031 : 		//	int iTypeIndex = ITEM_GET_INDEX(lpMsg->Type);
; 3032 : 
; 3033 : 		//	BYTE iItemPos = gObjInventoryInsertItem(&gObj[lpMsg->aIndex], iType, iTypeIndex, lpMsg->Level, lpMsg->m_Number, lpMsg->Dur);
; 3034 : 
; 3035 : 		//	if ( iItemPos == (BYTE)-1 )
; 3036 : 		//	{
; 3037 : 		//		LogAddTD("[Mu_2Anv_Event] Error : Failed To Gift Item Type:%d, TypeIndex:%d to [%s][%s]", iType, iTypeIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3038 : 		//	}
; 3039 : 		//	else
; 3040 : 		//	{
; 3041 : 		//		::GCInventoryItemOneSend(lpMsg->aIndex, iItemPos);
; 3042 : 		//	}
; 3043 : 		//}
; 3044 : 
; 3045 : 		if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )

  0618e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06191	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06194	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0619a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  061a0	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  061a5	0f 8e 33 02 00
	00		 jle	 $LN43@ItemSerial@2

; 3046 : 		{
; 3047 : 			CItem pCreateItem;

  061ab	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246281[ebp]
  061b1	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3048 : 			int iItemType = ITEM_GET_TYPE(lpMsg->Type);

  061b6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  061b9	0f bf 40 0c	 movsx	 eax, WORD PTR [eax+12]
  061bd	99		 cdq
  061be	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  061c4	03 c2		 add	 eax, edx
  061c6	c1 f8 09	 sar	 eax, 9
  061c9	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _iItemType$246282[ebp], eax

; 3049 : 			int iItemIndex	= ITEM_GET_INDEX(lpMsg->Type);

  061cf	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  061d2	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  061d6	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  061dc	79 08		 jns	 SHORT $LN89@ItemSerial@2
  061de	49		 dec	 ecx
  061df	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  061e5	41		 inc	 ecx
$LN89@ItemSerial@2:
  061e6	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _iItemIndex$246283[ebp], ecx

; 3050 : #ifdef PERIOD
; 3051 : 			//if(lpMsg->x == 1 && lpMsg->y == 1)	//Credit Donate Himik bla
; 3052 : 			//{
; 3053 : 			//	pCreateItem.m_Number = 1;//lpMsg->m_Number;
; 3054 : 			//}
; 3055 : 			//else if(lpMsg->x == 2 && lpMsg->y == 2)
; 3056 : 			//{
; 3057 : 			//	pCreateItem.m_Number = 2;//lpMsg->m_Number;
; 3058 : 			//}
; 3059 : 			//else
; 3060 : 			{
; 3061 : 				pCreateItem.m_Number = lpMsg->m_Number;

  061ec	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  061ef	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  061f2	89 8d fc fd ff
	ff		 mov	 DWORD PTR _pCreateItem$246281[ebp], ecx

; 3062 : 			}
; 3063 : #endif
; 3064 : 			pCreateItem.m_Level = lpMsg->Level;//Season 4.5 changed position

  061f8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  061fb	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  06200	66 89 8d 04 fe
	ff ff		 mov	 WORD PTR _pCreateItem$246281[ebp+8], cx

; 3065 : 			pCreateItem.m_Durability = lpMsg->Dur;//Season 4.5 changed positionhfm

  06207	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0620a	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0620e	89 8d b4 fb ff
	ff		 mov	 DWORD PTR tv1380[ebp], ecx
  06214	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1380[ebp]
  0621a	d9 9d 20 fe ff
	ff		 fstp	 DWORD PTR _pCreateItem$246281[ebp+36]

; 3066 : 
; 3067 : 			if ( g_SocketOption.CheckItemType(ITEMGET(iItemType, iItemIndex)) == 1 )

  06220	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _iItemType$246282[ebp]
  06226	c1 e0 09	 shl	 eax, 9
  06229	03 85 f4 fd ff
	ff		 add	 eax, DWORD PTR _iItemIndex$246283[ebp]
  0622f	50		 push	 eax
  06230	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  06235	e8 00 00 00 00	 call	 ?CheckItemType@CSocketOption@@QAEEH@Z ; CSocketOption::CheckItemType
  0623a	0f b6 c8	 movzx	 ecx, al
  0623d	83 f9 01	 cmp	 ecx, 1
  06240	75 7a		 jne	 SHORT $LN49@ItemSerial@2

; 3068 : 			{
; 3069 : 				BYTE CS_Item[5] = {0xFE,0xFE,0xFE,0xFE,0xFE};

  06242	c6 85 ec fd ff
	ff fe		 mov	 BYTE PTR _CS_Item$246285[ebp], 254 ; 000000feH
  06249	c6 85 ed fd ff
	ff fe		 mov	 BYTE PTR _CS_Item$246285[ebp+1], 254 ; 000000feH
  06250	c6 85 ee fd ff
	ff fe		 mov	 BYTE PTR _CS_Item$246285[ebp+2], 254 ; 000000feH
  06257	c6 85 ef fd ff
	ff fe		 mov	 BYTE PTR _CS_Item$246285[ebp+3], 254 ; 000000feH
  0625e	c6 85 f0 fd ff
	ff fe		 mov	 BYTE PTR _CS_Item$246285[ebp+4], 254 ; 000000feH

; 3070 : 				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, CS_Item, 0xFF, 0, 3);

  06265	6a 03		 push	 3
  06267	6a 00		 push	 0
  06269	68 ff 00 00 00	 push	 255			; 000000ffH
  0626e	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _CS_Item$246285[ebp]
  06274	50		 push	 eax
  06275	6a 00		 push	 0
  06277	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0627a	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  0627e	52		 push	 edx
  0627f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06282	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06286	51		 push	 ecx
  06287	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0628a	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  0628e	50		 push	 eax
  0628f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06292	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  06296	52		 push	 edx
  06297	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0629a	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0629e	51		 push	 ecx
  0629f	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _iItemType$246282[ebp]
  062a5	c1 e2 09	 shl	 edx, 9
  062a8	03 95 f4 fd ff
	ff		 add	 edx, DWORD PTR _iItemIndex$246283[ebp]
  062ae	52		 push	 edx
  062af	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246281[ebp]
  062b5	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 3071 : 			}
; 3072 : 			else

  062ba	eb 50		 jmp	 SHORT $LN48@ItemSerial@2
$LN49@ItemSerial@2:

; 3073 : 			{
; 3074 : 				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, NULL, 0xFF, 0, 3);

  062bc	6a 03		 push	 3
  062be	6a 00		 push	 0
  062c0	68 ff 00 00 00	 push	 255			; 000000ffH
  062c5	6a 00		 push	 0
  062c7	6a 00		 push	 0
  062c9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  062cc	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  062d0	51		 push	 ecx
  062d1	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  062d4	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  062d8	50		 push	 eax
  062d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  062dc	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  062e0	52		 push	 edx
  062e1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  062e4	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  062e8	51		 push	 ecx
  062e9	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  062ec	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  062f0	50		 push	 eax
  062f1	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _iItemType$246282[ebp]
  062f7	c1 e1 09	 shl	 ecx, 9
  062fa	03 8d f4 fd ff
	ff		 add	 ecx, DWORD PTR _iItemIndex$246283[ebp]
  06300	51		 push	 ecx
  06301	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246281[ebp]
  06307	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert
$LN48@ItemSerial@2:

; 3075 : 			}
; 3076 : 
; 3077 : 
; 3078 : 			BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, pCreateItem);

  0630c	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  06312	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  06317	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _pCreateItem$246281[ebp]
  0631d	8b fc		 mov	 edi, esp
  0631f	f3 a5		 rep movsd
  06321	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06324	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06327	51		 push	 ecx
  06328	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  0632d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  06333	88 85 eb fd ff
	ff		 mov	 BYTE PTR _btItemPos$246287[ebp], al

; 3079 : 
; 3080 : 			if ( btItemPos == (BYTE)-1 )

  06339	0f b6 85 eb fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246287[ebp]
  06340	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  06345	75 4b		 jne	 SHORT $LN47@ItemSerial@2

; 3081 : 			{
; 3082 : 				LogAddTD("[CashShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]", iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);

  06347	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0634a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0634d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06353	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06359	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  0635d	50		 push	 eax
  0635e	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06361	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  06364	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0636a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0636f	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  06373	51		 push	 ecx
  06374	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _iItemIndex$246283[ebp]
  0637a	52		 push	 edx
  0637b	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _iItemType$246282[ebp]
  06381	50		 push	 eax
  06382	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@
  06387	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0638d	83 c4 14	 add	 esp, 20			; 00000014H

; 3083 : 			}
; 3084 : 			else if( pCreateItem.m_Type == ITEMGET(13, 4)

  06390	eb 4c		 jmp	 SHORT $LN43@ItemSerial@2
$LN47@ItemSerial@2:

; 3085 : 				|| pCreateItem.m_Type == ITEMGET(13, 5) )

  06392	0f bf 85 02 fe
	ff ff		 movsx	 eax, WORD PTR _pCreateItem$246281[ebp+6]
  06399	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  0639e	74 0e		 je	 SHORT $LN44@ItemSerial@2
  063a0	0f bf 85 02 fe
	ff ff		 movsx	 eax, WORD PTR _pCreateItem$246281[ebp+6]
  063a7	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  063ac	75 19		 jne	 SHORT $LN45@ItemSerial@2
$LN44@ItemSerial@2:

; 3086 : 			{
; 3087 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  063ae	0f b6 85 eb fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246287[ebp]
  063b5	50		 push	 eax
  063b6	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  063b9	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  063bc	52		 push	 edx
  063bd	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  063c2	83 c4 08	 add	 esp, 8

; 3088 : 			}
; 3089 : 			else

  063c5	eb 17		 jmp	 SHORT $LN43@ItemSerial@2
$LN45@ItemSerial@2:

; 3090 : 			{
; 3091 : //#ifdef PERIOD
; 3092 : //				if( lpMsg->lDuration > 0 )
; 3093 : //				{
; 3094 : //					g_PeriodItemEx.SetPeriodItemInfo(&gObj[lpMsg->aIndex], lpMsg->Type, lpMsg->m_Number, lpMsg->lDuration);
; 3095 : //				}
; 3096 : //#endif
; 3097 : 							//LogAdd("[CREDIT DONATE][%s] Type: %d, Index: %d, Level: %d, Skill: %d, Luck: %d, Opt: %d, Exellent: %d, Ancent: %d, Serial: %X",
; 3098 : 							//	lpObj->AccountID,iItemType,iItemIndex,lpMsg->Level,lpMsg->Op1,lpMsg->Op2,lpMsg->Op3,lpMsg->NewOption,lpMsg->SetOption,lpMsg->m_Number);
; 3099 : 				//ExLog(0,"[%s] Type: %d, Index: %d, Level: %d, Skill: %d, Luck: %d, Opt: %d, Exellent: %d, Ancent: %d, Serial: %d",
; 3100 : 				//	lpObj->AccountID,iItemType,iItemIndex,lpMsg->Level,lpMsg->Op1,lpMsg->Op2,lpMsg->Op3,lpMsg->NewOption,lpMsg->SetOption,lpMsg->m_Number);
; 3101 : 				//ExLog(0,"%s",lpObj->AccountID);
; 3102 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  063c7	0f b6 85 eb fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246287[ebp]
  063ce	50		 push	 eax
  063cf	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  063d2	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  063d5	52		 push	 edx
  063d6	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  063db	83 c4 08	 add	 esp, 8
$LN43@ItemSerial@2:

; 3103 : 				//GDUserItemSave(lpObj);
; 3104 : 			}
; 3105 : 		}
; 3106 : 
; 3107 : 	}

  063de	e9 67 09 00 00	 jmp	 $LN28@ItemSerial@2
$LN51@ItemSerial@2:

; 3108 : 	else if ( lpMsg->MapNumber == 236 )

  063e3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  063e6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  063ea	81 f9 ec 00 00
	00		 cmp	 ecx, 236		; 000000ecH
  063f0	0f 85 f8 01 00
	00		 jne	 $LN41@ItemSerial@2

; 3109 : 	{
; 3110 : 		if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )

  063f6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  063f9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  063fc	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06402	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06408	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  0640d	0f 8e d6 01 00
	00		 jle	 $LN35@ItemSerial@2

; 3111 : 		{
; 3112 : 			CItem pCreateItem;

  06413	8d 8d 14 fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246298[ebp]
  06419	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3113 : 			int iItemType = ITEM_GET_TYPE(lpMsg->Type);

  0641e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06421	0f bf 40 0c	 movsx	 eax, WORD PTR [eax+12]
  06425	99		 cdq
  06426	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0642c	03 c2		 add	 eax, edx
  0642e	c1 f8 09	 sar	 eax, 9
  06431	89 85 10 fd ff
	ff		 mov	 DWORD PTR _iItemType$246299[ebp], eax

; 3114 : 			int iItemIndex	= ITEM_GET_INDEX(lpMsg->Type);

  06437	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0643a	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  0643e	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  06444	79 08		 jns	 SHORT $LN90@ItemSerial@2
  06446	49		 dec	 ecx
  06447	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  0644d	41		 inc	 ecx
$LN90@ItemSerial@2:
  0644e	89 8d 0c fd ff
	ff		 mov	 DWORD PTR _iItemIndex$246300[ebp], ecx

; 3115 : #ifdef PERIOD
; 3116 : 			pCreateItem.m_Number = lpMsg->m_Number;

  06454	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06457	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0645a	89 8d 14 fd ff
	ff		 mov	 DWORD PTR _pCreateItem$246298[ebp], ecx

; 3117 : #endif
; 3118 : 			pCreateItem.m_Level = lpMsg->Level;//Season 4.5 changed position

  06460	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06463	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  06468	66 89 8d 1c fd
	ff ff		 mov	 WORD PTR _pCreateItem$246298[ebp+8], cx

; 3119 : 			pCreateItem.m_Durability = lpMsg->Dur;//Season 4.5 changed position

  0646f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06472	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  06476	89 8d b4 fb ff
	ff		 mov	 DWORD PTR tv1452[ebp], ecx
  0647c	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1452[ebp]
  06482	d9 9d 38 fd ff
	ff		 fstp	 DWORD PTR _pCreateItem$246298[ebp+36]

; 3120 : #if CASH_SHOP_ADDITIONAL == 1
; 3121 : 			if ( g_SocketOption.CheckItemType(ITEMGET(iItemType, iItemIndex)) == 1 )
; 3122 : 			{
; 3123 : 				BYTE CS_Item[5] = {0xFE,0xFE,0xFE,0xFE,0xFE};
; 3124 : 				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, CS_Item, 0xFF, 0, 3);
; 3125 : 			}
; 3126 : 			else
; 3127 : 			{
; 3128 : 				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, NULL, 0xFF, 0, 3);
; 3129 : 			}
; 3130 : 
; 3131 : #else
; 3132 : 			pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, NULL, 0xFF, 0, 3);

  06488	6a 03		 push	 3
  0648a	6a 00		 push	 0
  0648c	68 ff 00 00 00	 push	 255			; 000000ffH
  06491	6a 00		 push	 0
  06493	6a 00		 push	 0
  06495	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06498	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  0649c	51		 push	 ecx
  0649d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  064a0	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  064a4	50		 push	 eax
  064a5	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  064a8	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  064ac	52		 push	 edx
  064ad	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  064b0	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  064b4	51		 push	 ecx
  064b5	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  064b8	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  064bc	50		 push	 eax
  064bd	8b 8d 10 fd ff
	ff		 mov	 ecx, DWORD PTR _iItemType$246299[ebp]
  064c3	c1 e1 09	 shl	 ecx, 9
  064c6	03 8d 0c fd ff
	ff		 add	 ecx, DWORD PTR _iItemIndex$246300[ebp]
  064cc	51		 push	 ecx
  064cd	8d 8d 14 fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246298[ebp]
  064d3	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 3133 : #endif
; 3134 : 			BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, pCreateItem);

  064d8	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  064de	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  064e3	8d b5 14 fd ff
	ff		 lea	 esi, DWORD PTR _pCreateItem$246298[ebp]
  064e9	8b fc		 mov	 edi, esp
  064eb	f3 a5		 rep movsd
  064ed	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  064f0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  064f3	51		 push	 ecx
  064f4	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  064f9	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  064ff	88 85 0b fd ff
	ff		 mov	 BYTE PTR _btItemPos$246301[ebp], al

; 3135 : 
; 3136 : 			if ( btItemPos == (BYTE)-1 )

  06505	0f b6 85 0b fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246301[ebp]
  0650c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  06511	75 4e		 jne	 SHORT $LN39@ItemSerial@2

; 3137 : 			{
; 3138 : 				LogAddTD("[CashShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]", iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);

  06513	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06516	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06519	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0651f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06525	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  06529	50		 push	 eax
  0652a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0652d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  06530	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  06536	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0653b	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0653f	51		 push	 ecx
  06540	8b 95 0c fd ff
	ff		 mov	 edx, DWORD PTR _iItemIndex$246300[ebp]
  06546	52		 push	 edx
  06547	8b 85 10 fd ff
	ff		 mov	 eax, DWORD PTR _iItemType$246299[ebp]
  0654d	50		 push	 eax
  0654e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@
  06553	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  06559	83 c4 14	 add	 esp, 20			; 00000014H

; 3139 : 			}
; 3140 : 			else if( pCreateItem.m_Type == ITEMGET(13, 4)

  0655c	e9 88 00 00 00	 jmp	 $LN35@ItemSerial@2
$LN39@ItemSerial@2:

; 3141 : 				|| pCreateItem.m_Type == ITEMGET(13, 5) )

  06561	0f bf 85 1a fd
	ff ff		 movsx	 eax, WORD PTR _pCreateItem$246298[ebp+6]
  06568	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  0656d	74 0e		 je	 SHORT $LN36@ItemSerial@2
  0656f	0f bf 85 1a fd
	ff ff		 movsx	 eax, WORD PTR _pCreateItem$246298[ebp+6]
  06576	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  0657b	75 19		 jne	 SHORT $LN37@ItemSerial@2
$LN36@ItemSerial@2:

; 3142 : 			{
; 3143 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  0657d	0f b6 85 0b fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246301[ebp]
  06584	50		 push	 eax
  06585	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06588	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0658b	52		 push	 edx
  0658c	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  06591	83 c4 08	 add	 esp, 8

; 3144 : 			}
; 3145 : 			else

  06594	eb 53		 jmp	 SHORT $LN35@ItemSerial@2
$LN37@ItemSerial@2:

; 3146 : 			{
; 3147 : #ifdef PERIOD
; 3148 : 				if( lpMsg->lDuration > 0 )

  06596	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06599	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0659d	7e 33		 jle	 SHORT $LN34@ItemSerial@2

; 3149 : 				{
; 3150 : 					g_PeriodItemEx.SetPeriodItemInfo(&gObj[lpMsg->aIndex], lpMsg->Type, lpMsg->m_Number, lpMsg->lDuration);

  0659f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  065a2	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  065a5	51		 push	 ecx
  065a6	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  065a9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  065ac	50		 push	 eax
  065ad	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  065b0	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  065b4	52		 push	 edx
  065b5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  065b8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  065bb	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  065c1	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  065c7	51		 push	 ecx
  065c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemEx@@3VCPeriodItemEx@@A ; g_PeriodItemEx
  065cd	e8 00 00 00 00	 call	 ?SetPeriodItemInfo@CPeriodItemEx@@QAE_NPAUOBJECTSTRUCT@@GKK@Z ; CPeriodItemEx::SetPeriodItemInfo
$LN34@ItemSerial@2:

; 3151 : 				}
; 3152 : #endif
; 3153 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  065d2	0f b6 85 0b fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246301[ebp]
  065d9	50		 push	 eax
  065da	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  065dd	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  065e0	52		 push	 edx
  065e1	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  065e6	83 c4 08	 add	 esp, 8
$LN35@ItemSerial@2:

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}

  065e9	e9 5c 07 00 00	 jmp	 $LN28@ItemSerial@2
$LN41@ItemSerial@2:

; 3157 : 	else if ( lpMsg->MapNumber == 237 )//Season 4.5 lucky coin trade system addon

  065ee	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  065f1	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  065f5	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  065fb	0f 85 c3 01 00
	00		 jne	 $LN32@ItemSerial@2

; 3158 : 	{
; 3159 : 		if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )

  06601	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06604	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06607	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0660d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06613	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  06618	0f 8e a1 01 00
	00		 jle	 $LN31@ItemSerial@2

; 3160 : 		{
; 3161 : 			CItem pCreateItem;

  0661e	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246312[ebp]
  06624	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3162 : 			
; 3163 : 			int iItemType = ITEM_GET_TYPE(lpMsg->Type);

  06629	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0662c	0f bf 40 0c	 movsx	 eax, WORD PTR [eax+12]
  06630	99		 cdq
  06631	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  06637	03 c2		 add	 eax, edx
  06639	c1 f8 09	 sar	 eax, 9
  0663c	89 85 30 fc ff
	ff		 mov	 DWORD PTR _iItemType$246313[ebp], eax

; 3164 : 			int iItemIndex	= ITEM_GET_INDEX(lpMsg->Type);

  06642	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06645	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  06649	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  0664f	79 08		 jns	 SHORT $LN91@ItemSerial@2
  06651	49		 dec	 ecx
  06652	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  06658	41		 inc	 ecx
$LN91@ItemSerial@2:
  06659	89 8d 2c fc ff
	ff		 mov	 DWORD PTR _iItemIndex$246314[ebp], ecx

; 3165 : 
; 3166 : 			pCreateItem.m_Level = lpMsg->Level;

  0665f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06662	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  06667	66 89 8d 3c fc
	ff ff		 mov	 WORD PTR _pCreateItem$246312[ebp+8], cx

; 3167 : 			pCreateItem.m_Durability = lpMsg->Dur;

  0666e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06671	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  06675	89 8d b4 fb ff
	ff		 mov	 DWORD PTR tv1513[ebp], ecx
  0667b	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1513[ebp]
  06681	d9 9d 58 fc ff
	ff		 fstp	 DWORD PTR _pCreateItem$246312[ebp+36]

; 3168 : 
; 3169 : 			pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, NULL, 0xFF, 0, 3);

  06687	6a 03		 push	 3
  06689	6a 00		 push	 0
  0668b	68 ff 00 00 00	 push	 255			; 000000ffH
  06690	6a 00		 push	 0
  06692	6a 00		 push	 0
  06694	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06697	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  0669b	51		 push	 ecx
  0669c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0669f	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  066a3	50		 push	 eax
  066a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  066a7	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  066ab	52		 push	 edx
  066ac	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  066af	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  066b3	51		 push	 ecx
  066b4	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  066b7	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  066bb	50		 push	 eax
  066bc	8b 8d 30 fc ff
	ff		 mov	 ecx, DWORD PTR _iItemType$246313[ebp]
  066c2	c1 e1 09	 shl	 ecx, 9
  066c5	03 8d 2c fc ff
	ff		 add	 ecx, DWORD PTR _iItemIndex$246314[ebp]
  066cb	51		 push	 ecx
  066cc	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$246312[ebp]
  066d2	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 3170 : 			pCreateItem.m_Level = lpMsg->Level;

  066d7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  066da	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  066df	66 89 8d 3c fc
	ff ff		 mov	 WORD PTR _pCreateItem$246312[ebp+8], cx

; 3171 : 			
; 3172 : 			BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, pCreateItem);

  066e6	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  066ec	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  066f1	8d b5 34 fc ff
	ff		 lea	 esi, DWORD PTR _pCreateItem$246312[ebp]
  066f7	8b fc		 mov	 edi, esp
  066f9	f3 a5		 rep movsd
  066fb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  066fe	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06701	51		 push	 ecx
  06702	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  06707	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0670d	88 85 2b fc ff
	ff		 mov	 BYTE PTR _btItemPos$246315[ebp], al

; 3173 : 
; 3174 : 			if ( btItemPos == (BYTE)-1 )

  06713	0f b6 85 2b fc
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246315[ebp]
  0671a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0671f	75 5c		 jne	 SHORT $LN30@ItemSerial@2

; 3175 : 			{
; 3176 : 				LogAddTD("[LuckyCoin Trade] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]", iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);

  06721	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06724	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06727	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0672d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06733	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  06737	50		 push	 eax
  06738	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0673b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0673e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  06744	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06749	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0674d	51		 push	 ecx
  0674e	8b 95 2c fc ff
	ff		 mov	 edx, DWORD PTR _iItemIndex$246314[ebp]
  06754	52		 push	 edx
  06755	8b 85 30 fc ff
	ff		 mov	 eax, DWORD PTR _iItemType$246313[ebp]
  0675b	50		 push	 eax
  0675c	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@JMDFINCJ@?$FLLuckyCoin?5Trade?$FN?5Error?5?3?5Failed@
  06761	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  06767	83 c4 14	 add	 esp, 20			; 00000014H

; 3177 : 				GCSendLuckyCoinResult(lpMsg->aIndex, 2);

  0676a	6a 02		 push	 2
  0676c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0676f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  06772	51		 push	 ecx
  06773	e8 00 00 00 00	 call	 ?GCSendLuckyCoinResult@@YAXHE@Z ; GCSendLuckyCoinResult
  06778	83 c4 08	 add	 esp, 8

; 3178 : 			}
; 3179 : 			else

  0677b	eb 28		 jmp	 SHORT $LN29@ItemSerial@2
$LN30@ItemSerial@2:

; 3180 : 			{
; 3181 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  0677d	0f b6 85 2b fc
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$246315[ebp]
  06784	50		 push	 eax
  06785	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06788	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0678b	52		 push	 edx
  0678c	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  06791	83 c4 08	 add	 esp, 8

; 3182 : 				GCSendLuckyCoinResult(lpMsg->aIndex, 1);

  06794	6a 01		 push	 1
  06796	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06799	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0679c	51		 push	 ecx
  0679d	e8 00 00 00 00	 call	 ?GCSendLuckyCoinResult@@YAXHE@Z ; GCSendLuckyCoinResult
  067a2	83 c4 08	 add	 esp, 8
$LN29@ItemSerial@2:

; 3183 : 			}
; 3184 : 
; 3185 : 			gObj[aIndex].ChaosLock = false;

  067a5	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  067a8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  067ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  067b4	c7 84 01 88 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3720], 0
$LN31@ItemSerial@2:

; 3186 : 		}
; 3187 : 	}
; 3188 : //	else if ( lpMsg->MapNumber == 238 )
; 3189 : //	{
; 3190 : //		if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )
; 3191 : //		{
; 3192 : //			CItem pCreateItem;
; 3193 : //			int iItemType = ITEM_GET_TYPE(lpMsg->Type);
; 3194 : //			int iItemIndex	= ITEM_GET_INDEX(lpMsg->Type);
; 3195 : ////#ifdef PERIOD
; 3196 : //			pCreateItem.m_Number = lpMsg->m_Number;
; 3197 : ////#endif
; 3198 : //			pCreateItem.m_Level = lpMsg->Level;//Season 4.5 changed position
; 3199 : //			pCreateItem.m_Durability = lpMsg->Dur;//Season 4.5 changed position
; 3200 : //
; 3201 : //			if ( g_SocketOption.CheckItemType(ITEMGET(iItemType, iItemIndex)) == 1 )
; 3202 : //			{
; 3203 : //				BYTE CS_Item[5] = {0xFE,0xFE,0xFE,0xFE,0xFE};
; 3204 : //				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, CS_Item, 0xFF, 0, 3);
; 3205 : //			}
; 3206 : //			else
; 3207 : //			{
; 3208 : //				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0, NULL, 0xFF, 0, 3);
; 3209 : //			}
; 3210 : //
; 3211 : //
; 3212 : //			BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, pCreateItem);
; 3213 : //
; 3214 : //			if ( btItemPos == (BYTE)-1 )
; 3215 : //			{
; 3216 : //				LogAddTD("[CashShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]", iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3217 : //			}
; 3218 : //			else if( pCreateItem.m_Type == ITEMGET(13, 4)
; 3219 : //				|| pCreateItem.m_Type == ITEMGET(13, 5) )
; 3220 : //			{
; 3221 : //				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 3222 : //			}
; 3223 : //			else
; 3224 : //			{
; 3225 : ////#ifdef PERIOD
; 3226 : ////				if( lpMsg->lDuration > 0 )
; 3227 : ////				{
; 3228 : ////					g_PeriodItemEx.SetPeriodItemInfo(&gObj[lpMsg->aIndex], lpMsg->Type, lpMsg->m_Number, lpMsg->lDuration);
; 3229 : ////				}
; 3230 : ////#endif
; 3231 : //							//LogAdd("[CREDIT DONATE][%s] Type: %d, Index: %d, Level: %d, Skill: %d, Luck: %d, Opt: %d, Exellent: %d, Ancent: %d, Serial: %X",
; 3232 : //							//	lpObj->AccountID,iItemType,iItemIndex,lpMsg->Level,lpMsg->Op1,lpMsg->Op2,lpMsg->Op3,lpMsg->NewOption,lpMsg->SetOption,lpMsg->m_Number);
; 3233 : //				//ExLog(0,"[%s] Type: %d, Index: %d, Level: %d, Skill: %d, Luck: %d, Opt: %d, Exellent: %d, Ancent: %d, Serial: %d",
; 3234 : //				//	lpObj->AccountID,iItemType,iItemIndex,lpMsg->Level,lpMsg->Op1,lpMsg->Op2,lpMsg->Op3,lpMsg->NewOption,lpMsg->SetOption,lpMsg->m_Number);
; 3235 : //				ExLog(0,"%s",lpObj->AccountID);
; 3236 : //				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 3237 : //			}
; 3238 : //		}
; 3239 : //	}
; 3240 : 	else

  067bf	e9 86 05 00 00	 jmp	 $LN28@ItemSerial@2
$LN32@ItemSerial@2:

; 3241 : 	{
; 3242 : 		int iRetMapNumber = lpMsg->MapNumber; //loc106

  067c4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  067c7	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  067cb	89 8d 24 fc ff
	ff		 mov	 DWORD PTR _iRetMapNumber$246321[ebp], ecx

; 3243 : 
; 3244 : 		if ( lpMsg->MapNumber >= 238 && lpMsg->MapNumber <= 245 )

  067d1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  067d4	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  067d8	81 f9 ee 00 00
	00		 cmp	 ecx, 238		; 000000eeH
  067de	7c 23		 jl	 SHORT $LN27@ItemSerial@2
  067e0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  067e3	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  067e7	81 f9 f5 00 00
	00		 cmp	 ecx, 245		; 000000f5H
  067ed	7f 14		 jg	 SHORT $LN27@ItemSerial@2

; 3245 : 		{
; 3246 : 			mapnumber = g_BloodCastle.GetItemMapNumberFirst(iRetMapNumber);

  067ef	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _iRetMapNumber$246321[ebp]
  067f5	50		 push	 eax
  067f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  067fb	e8 00 00 00 00	 call	 ?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetItemMapNumberFirst
  06800	89 45 f4	 mov	 DWORD PTR _mapnumber$[ebp], eax
$LN27@ItemSerial@2:

; 3247 : 		}
; 3248 : 
; 3249 : 		if ( lpMsg->MapNumber >= 246 && lpMsg->MapNumber <= 253 )

  06803	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06806	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0680a	81 f9 f6 00 00
	00		 cmp	 ecx, 246		; 000000f6H
  06810	7c 23		 jl	 SHORT $LN26@ItemSerial@2
  06812	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06815	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  06819	81 f9 fd 00 00
	00		 cmp	 ecx, 253		; 000000fdH
  0681f	7f 14		 jg	 SHORT $LN26@ItemSerial@2

; 3250 : 		{
; 3251 : 			mapnumber = g_BloodCastle.GetItemMapNumberSecond(iRetMapNumber);

  06821	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _iRetMapNumber$246321[ebp]
  06827	50		 push	 eax
  06828	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0682d	e8 00 00 00 00	 call	 ?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetItemMapNumberSecond
  06832	89 45 f4	 mov	 DWORD PTR _mapnumber$[ebp], eax
$LN26@ItemSerial@2:

; 3252 : 		}
; 3253 : 		
; 3254 : 		//Season 4.5 SocketSystem Addon Start
; 3255 : 		BYTE SocketSlotCount = 0;

  06835	c6 85 23 fc ff
	ff 00		 mov	 BYTE PTR _SocketSlotCount$246324[ebp], 0

; 3256 : 		BYTE SocketOption[5];
; 3257 : 		BYTE SocketOptionIndex = 0;

  0683c	c6 85 17 fc ff
	ff 00		 mov	 BYTE PTR _SocketOptionIndex$246326[ebp], 0

; 3258 : 
; 3259 : 		if ( g_SocketOption.CheckItemType(lpMsg->Type) == 1 )

  06843	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06846	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  0684a	51		 push	 ecx
  0684b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  06850	e8 00 00 00 00	 call	 ?CheckItemType@CSocketOption@@QAEEH@Z ; CSocketOption::CheckItemType
  06855	0f b6 d0	 movzx	 edx, al
  06858	83 fa 01	 cmp	 edx, 1
  0685b	0f 85 e9 00 00
	00		 jne	 $LN25@ItemSerial@2

; 3260 :         {
; 3261 : 			SocketSlotCount = g_SocketOption.GetRandomSlotCount(lpMsg->Type);

  06861	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06864	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  06868	51		 push	 ecx
  06869	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  0686e	e8 00 00 00 00	 call	 ?GetRandomSlotCount@CSocketOption@@QAEEH@Z ; CSocketOption::GetRandomSlotCount
  06873	88 85 23 fc ff
	ff		 mov	 BYTE PTR _SocketSlotCount$246324[ebp], al

; 3262 : 
; 3263 : 			LogAddTD("[SocketItem] Drop Socket Item ( Socket Slot : %d ) - %s, [%d,%d,%d,%d], Serial : %u, ItemCode : %d, Level : %d, MapNumber : %d(%d/%d)",SocketSlotCount,ItemAttribute[lpMsg->Type].Name,lpMsg->Level,lpMsg->Op1,lpMsg->Op2,lpMsg->Op3, lpMsg->m_Number,lpMsg->Type,lpMsg->Level,lpMsg->MapNumber,lpMsg->x,lpMsg->y);

  06879	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0687c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  06880	51		 push	 ecx
  06881	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06884	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  06888	50		 push	 eax
  06889	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0688c	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  06890	52		 push	 edx
  06891	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06894	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  06898	51		 push	 ecx
  06899	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0689c	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  068a0	50		 push	 eax
  068a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  068a4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  068a7	52		 push	 edx
  068a8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  068ab	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  068af	51		 push	 ecx
  068b0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  068b3	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  068b7	50		 push	 eax
  068b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  068bb	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  068bf	52		 push	 edx
  068c0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  068c3	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  068c7	51		 push	 ecx
  068c8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  068cb	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  068cf	6b c0 70	 imul	 eax, 112		; 00000070H
  068d2	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  068d7	50		 push	 eax
  068d8	0f b6 8d 23 fc
	ff ff		 movzx	 ecx, BYTE PTR _SocketSlotCount$246324[ebp]
  068df	51		 push	 ecx
  068e0	68 00 00 00 00	 push	 OFFSET ??_C@_0IG@JDKHCHPG@?$FLSocketItem?$FN?5Drop?5Socket?5Item?5?$CI?5@
  068e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  068eb	83 c4 34	 add	 esp, 52			; 00000034H

; 3264 : 			
; 3265 : 			SocketOptionIndex = 0xFF;

  068ee	c6 85 17 fc ff
	ff ff		 mov	 BYTE PTR _SocketOptionIndex$246326[ebp], 255 ; 000000ffH

; 3266 : 
; 3267 : 			for(int i = 0;i < 5; i++)

  068f5	c7 85 10 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$246329[ebp], 0
  068ff	eb 0f		 jmp	 SHORT $LN24@ItemSerial@2
$LN23@ItemSerial@2:
  06901	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _i$246329[ebp]
  06907	83 c0 01	 add	 eax, 1
  0690a	89 85 10 fc ff
	ff		 mov	 DWORD PTR _i$246329[ebp], eax
$LN24@ItemSerial@2:
  06910	83 bd 10 fc ff
	ff 05		 cmp	 DWORD PTR _i$246329[ebp], 5
  06917	7d 2f		 jge	 SHORT $LN22@ItemSerial@2

; 3268 : 			{
; 3269 : 				if(i < SocketSlotCount)

  06919	0f b6 85 23 fc
	ff ff		 movzx	 eax, BYTE PTR _SocketSlotCount$246324[ebp]
  06920	39 85 10 fc ff
	ff		 cmp	 DWORD PTR _i$246329[ebp], eax
  06926	7d 10		 jge	 SHORT $LN21@ItemSerial@2

; 3270 : 				{
; 3271 : 					SocketOption[i] = 0xFE;

  06928	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _i$246329[ebp]
  0692e	c6 84 05 18 fc
	ff ff fe	 mov	 BYTE PTR _SocketOption$246325[ebp+eax], 254 ; 000000feH

; 3272 : 				}
; 3273 : 				else

  06936	eb 0e		 jmp	 SHORT $LN20@ItemSerial@2
$LN21@ItemSerial@2:

; 3274 : 				{
; 3275 : 					SocketOption[i] = 0xFF;

  06938	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _i$246329[ebp]
  0693e	c6 84 05 18 fc
	ff ff ff	 mov	 BYTE PTR _SocketOption$246325[ebp+eax], 255 ; 000000ffH
$LN20@ItemSerial@2:

; 3276 : 				}
; 3277 : 			}

  06946	eb b9		 jmp	 SHORT $LN23@ItemSerial@2
$LN22@ItemSerial@2:

; 3278 : 
; 3279 : 		}
; 3280 : 		else

  06948	eb 3b		 jmp	 SHORT $LN16@ItemSerial@2
$LN25@ItemSerial@2:

; 3281 : 		{
; 3282 : 			SocketOptionIndex = 0;

  0694a	c6 85 17 fc ff
	ff 00		 mov	 BYTE PTR _SocketOptionIndex$246326[ebp], 0

; 3283 : 
; 3284 : 			for(int i = 0; i < 5; i++)

  06951	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$246336[ebp], 0
  0695b	eb 0f		 jmp	 SHORT $LN18@ItemSerial@2
$LN17@ItemSerial@2:
  0695d	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _i$246336[ebp]
  06963	83 c0 01	 add	 eax, 1
  06966	89 85 0c fc ff
	ff		 mov	 DWORD PTR _i$246336[ebp], eax
$LN18@ItemSerial@2:
  0696c	83 bd 0c fc ff
	ff 05		 cmp	 DWORD PTR _i$246336[ebp], 5
  06973	7d 10		 jge	 SHORT $LN16@ItemSerial@2

; 3285 : 			{
; 3286 : 				SocketOption[i] = 0xFF;

  06975	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _i$246336[ebp]
  0697b	c6 84 05 18 fc
	ff ff ff	 mov	 BYTE PTR _SocketOption$246325[ebp+eax], 255 ; 000000ffH

; 3287 : 			}

  06983	eb d8		 jmp	 SHORT $LN17@ItemSerial@2
$LN16@ItemSerial@2:

; 3288 : 		}
; 3289 : 
; 3290 : 		int iItemCount = MapC[mapnumber].MonsterItemDrop(lpMsg->Type, lpMsg->Level, lpMsg->Dur, lpMsg->x, lpMsg->y, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, lootindex, lpMsg->m_Number, 0,SocketOption,SocketOptionIndex);

  06985	0f b6 85 17 fc
	ff ff		 movzx	 eax, BYTE PTR _SocketOptionIndex$246326[ebp]
  0698c	50		 push	 eax
  0698d	8d 8d 18 fc ff
	ff		 lea	 ecx, DWORD PTR _SocketOption$246325[ebp]
  06993	51		 push	 ecx
  06994	6a 00		 push	 0
  06996	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06999	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0699c	50		 push	 eax
  0699d	8b 4d ec	 mov	 ecx, DWORD PTR _lootindex$[ebp]
  069a0	51		 push	 ecx
  069a1	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  069a4	0f b6 42 1a	 movzx	 eax, BYTE PTR [edx+26]
  069a8	50		 push	 eax
  069a9	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  069ac	0f b6 51 13	 movzx	 edx, BYTE PTR [ecx+19]
  069b0	52		 push	 edx
  069b1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  069b4	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  069b8	51		 push	 ecx
  069b9	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  069bc	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  069c0	50		 push	 eax
  069c1	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  069c4	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  069c8	52		 push	 edx
  069c9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  069cc	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  069d0	51		 push	 ecx
  069d1	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  069d4	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  069d8	50		 push	 eax
  069d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  069dc	0f b6 51 0f	 movzx	 edx, BYTE PTR [ecx+15]
  069e0	89 95 b4 fb ff
	ff		 mov	 DWORD PTR tv1587[ebp], edx
  069e6	db 85 b4 fb ff
	ff		 fild	 DWORD PTR tv1587[ebp]
  069ec	51		 push	 ecx
  069ed	d9 1c 24	 fstp	 DWORD PTR [esp]
  069f0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  069f3	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  069f7	51		 push	 ecx
  069f8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  069fb	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  069ff	50		 push	 eax
  06a00	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06a03	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06a09	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  06a0f	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEQAEE@Z ; MapClass::MonsterItemDrop
  06a14	89 85 08 fc ff
	ff		 mov	 DWORD PTR _iItemCount$246340[ebp], eax

; 3291 : 		
; 3292 : 		//Season 4.5 SocketSystem Addon end
; 3293 : 
; 3294 : 		if ( iItemCount != -1 )

  06a1a	83 bd 08 fc ff
	ff ff		 cmp	 DWORD PTR _iItemCount$246340[ebp], -1
  06a21	0f 84 e4 01 00
	00		 je	 $LN10@ItemSerial@2

; 3295 : 		{
; 3296 : 			if ( iRetMapNumber >= 238 && iRetMapNumber <= 245)

  06a27	81 bd 24 fc ff
	ff ee 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$246321[ebp], 238 ; 000000eeH
  06a31	7c 5a		 jl	 SHORT $LN14@ItemSerial@2
  06a33	81 bd 24 fc ff
	ff f5 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$246321[ebp], 245 ; 000000f5H
  06a3d	7f 4e		 jg	 SHORT $LN14@ItemSerial@2

; 3297 : 			{
; 3298 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 300000;

  06a3f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06a45	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  06a4a	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06a4d	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06a53	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06a59	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06a5f	89 84 11 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+256], eax

; 3299 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 20000;

  06a66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06a6c	05 20 4e 00 00	 add	 eax, 20000		; 00004e20H
  06a71	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06a74	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06a7a	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06a80	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06a86	89 84 11 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+264], eax
$LN14@ItemSerial@2:

; 3300 : 
; 3301 : 			}
; 3302 : 
; 3303 : 			if ( iRetMapNumber >= 246 && iRetMapNumber <= 253)

  06a8d	81 bd 24 fc ff
	ff f6 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$246321[ebp], 246 ; 000000f6H
  06a97	0f 8c 86 00 00
	00		 jl	 $LN13@ItemSerial@2
  06a9d	81 bd 24 fc ff
	ff fd 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$246321[ebp], 253 ; 000000fdH
  06aa7	7f 7a		 jg	 SHORT $LN13@ItemSerial@2

; 3304 : 			{
; 3305 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 900000;

  06aa9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06aaf	05 a0 bb 0d 00	 add	 eax, 900000		; 000dbba0H
  06ab4	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06ab7	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06abd	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06ac3	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06ac9	89 84 11 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+256], eax

; 3306 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 10000;

  06ad0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06ad6	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  06adb	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06ade	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06ae4	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06aea	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06af0	89 84 11 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+264], eax

; 3307 : 
; 3308 : 				int iBridgeIndex = g_BloodCastle.GetBridgeIndex(mapnumber); //s3 add-on (loc108)

  06af7	8b 45 f4	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  06afa	50		 push	 eax
  06afb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  06b00	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  06b05	89 85 04 fc ff
	ff		 mov	 DWORD PTR _iBridgeIndex$246344[ebp], eax

; 3309 : 
; 3310 : 				g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = lpMsg->m_Number;

  06b0b	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _iBridgeIndex$246344[ebp]
  06b11	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b17	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06b1a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  06b1d	89 90 e8 03 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+1000], edx
$LN13@ItemSerial@2:

; 3311 : 			}
; 3312 : 
; 3313 : 			if( ((mapnumber) < MAP_INDEX_ILLUSIONTEMPLE1)?FALSE:((mapnumber) > MAP_INDEX_ILLUSIONTEMPLE6 )?FALSE:TRUE) //Season 2.5 add-on

  06b23	83 7d f4 2d	 cmp	 DWORD PTR _mapnumber$[ebp], 45 ; 0000002dH
  06b27	7d 0c		 jge	 SHORT $LN87@ItemSerial@2
  06b29	c7 85 b4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1008[ebp], 0
  06b33	eb 0f		 jmp	 SHORT $LN88@ItemSerial@2
$LN87@ItemSerial@2:
  06b35	33 c0		 xor	 eax, eax
  06b37	83 7d f4 32	 cmp	 DWORD PTR _mapnumber$[ebp], 50 ; 00000032H
  06b3b	0f 9e c0	 setle	 al
  06b3e	89 85 b4 fb ff
	ff		 mov	 DWORD PTR tv1008[ebp], eax
$LN88@ItemSerial@2:
  06b44	83 bd b4 fb ff
	ff 00		 cmp	 DWORD PTR tv1008[ebp], 0
  06b4b	0f 84 ba 00 00
	00		 je	 $LN10@ItemSerial@2

; 3314 : 			{
; 3315 : 				if( lpMsg->Type == ITEMGET(14,64) )

  06b51	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06b54	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  06b58	81 f9 40 1c 00
	00		 cmp	 ecx, 7232		; 00001c40H
  06b5e	75 4e		 jne	 SHORT $LN11@ItemSerial@2

; 3316 : 				{
; 3317 : 					MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 15000;

  06b60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06b66	05 98 3a 00 00	 add	 eax, 15000		; 00003a98H
  06b6b	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06b6e	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06b74	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06b7a	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06b80	89 84 11 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+256], eax

; 3318 : 					MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 5000;

  06b87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06b8d	05 88 13 00 00	 add	 eax, 5000		; 00001388H
  06b92	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06b95	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06b9b	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06ba1	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06ba7	89 84 11 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+264], eax
$LN11@ItemSerial@2:

; 3319 : 				}
; 3320 : 
; 3321 : 				if( lpMsg->Type == ITEMGET(12,15) )

  06bae	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06bb1	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  06bb5	81 f9 0f 18 00
	00		 cmp	 ecx, 6159		; 0000180fH
  06bbb	75 4e		 jne	 SHORT $LN10@ItemSerial@2

; 3322 : 				{
; 3323 : 					MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 300000;

  06bbd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06bc3	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  06bc8	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06bcb	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06bd1	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06bd7	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06bdd	89 84 11 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+256], eax

; 3324 : 					MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 10000;

  06be4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  06bea	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  06bef	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06bf2	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  06bf8	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _iItemCount$246340[ebp]
  06bfe	69 d2 74 04 00
	00		 imul	 edx, 1140		; 00000474H
  06c04	89 84 11 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+edx+264], eax
$LN10@ItemSerial@2:

; 3325 : 				}
; 3326 : 			}
; 3327 : 		}
; 3328 : 
; 3329 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 3330 : 
; 3331 : 		for ( int i=0;i<MAX_EXOPTION_SIZE;i++)

  06c0b	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$246349[ebp], 0
  06c15	eb 0f		 jmp	 SHORT $LN9@ItemSerial@2
$LN8@ItemSerial@2:
  06c17	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _i$246349[ebp]
  06c1d	83 c0 01	 add	 eax, 1
  06c20	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _i$246349[ebp], eax
$LN9@ItemSerial@2:
  06c26	83 bd f8 fb ff
	ff 08		 cmp	 DWORD PTR _i$246349[ebp], 8
  06c2d	7d 10		 jge	 SHORT $LN7@ItemSerial@2

; 3332 : 		{
; 3333 : 			NewOption[i] = FALSE;

  06c2f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _i$246349[ebp]
  06c35	c6 84 05 fc fb
	ff ff 00	 mov	 BYTE PTR _NewOption$246348[ebp+eax], 0

; 3334 : 		}

  06c3d	eb d8		 jmp	 SHORT $LN8@ItemSerial@2
$LN7@ItemSerial@2:

; 3335 : 
; 3336 : 		if ( (lpMsg->NewOption & 0x20) != 0 )

  06c3f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06c42	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06c46	83 e1 20	 and	 ecx, 32			; 00000020H
  06c49	74 07		 je	 SHORT $LN6@ItemSerial@2

; 3337 : 		{
; 3338 : 			NewOption[0] = TRUE;

  06c4b	c6 85 fc fb ff
	ff 01		 mov	 BYTE PTR _NewOption$246348[ebp], 1
$LN6@ItemSerial@2:

; 3339 : 		}
; 3340 : 		if ( (lpMsg->NewOption & 0x10) != 0 )

  06c52	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06c55	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06c59	83 e1 10	 and	 ecx, 16			; 00000010H
  06c5c	74 07		 je	 SHORT $LN5@ItemSerial@2

; 3341 : 		{
; 3342 : 			NewOption[1] = TRUE;

  06c5e	c6 85 fd fb ff
	ff 01		 mov	 BYTE PTR _NewOption$246348[ebp+1], 1
$LN5@ItemSerial@2:

; 3343 : 		}
; 3344 : 
; 3345 : 		if ( (lpMsg->NewOption & 0x8) != 0 )

  06c65	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06c68	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06c6c	83 e1 08	 and	 ecx, 8
  06c6f	74 07		 je	 SHORT $LN4@ItemSerial@2

; 3346 : 		{
; 3347 : 			NewOption[2] = TRUE;

  06c71	c6 85 fe fb ff
	ff 01		 mov	 BYTE PTR _NewOption$246348[ebp+2], 1
$LN4@ItemSerial@2:

; 3348 : 		}
; 3349 : 		if ( (lpMsg->NewOption & 0x4) != 0 )

  06c78	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06c7b	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06c7f	83 e1 04	 and	 ecx, 4
  06c82	74 07		 je	 SHORT $LN3@ItemSerial@2

; 3350 : 		{
; 3351 : 			NewOption[3] = TRUE;

  06c84	c6 85 ff fb ff
	ff 01		 mov	 BYTE PTR _NewOption$246348[ebp+3], 1
$LN3@ItemSerial@2:

; 3352 : 		}
; 3353 : 
; 3354 : 		if ( (lpMsg->NewOption & 0x2) != 0 )

  06c8b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06c8e	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06c92	83 e1 02	 and	 ecx, 2
  06c95	74 07		 je	 SHORT $LN2@ItemSerial@2

; 3355 : 		{
; 3356 : 			NewOption[4] = TRUE;

  06c97	c6 85 00 fc ff
	ff 01		 mov	 BYTE PTR _NewOption$246348[ebp+4], 1
$LN2@ItemSerial@2:

; 3357 : 		}
; 3358 : 		if ( (lpMsg->NewOption & 0x1) != 0 )

  06c9e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06ca1	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  06ca5	83 e1 01	 and	 ecx, 1
  06ca8	74 07		 je	 SHORT $LN1@ItemSerial@2

; 3359 : 		{
; 3360 : 			NewOption[5] = TRUE;

  06caa	c6 85 01 fc ff
	ff 01		 mov	 BYTE PTR _NewOption$246348[ebp+5], 1
$LN1@ItemSerial@2:

; 3361 : 		}
; 3362 : 
; 3363 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%u [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6], lpMsg->SetOption);	

  06cb1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06cb4	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  06cb8	51		 push	 ecx
  06cb9	0f b6 95 02 fc
	ff ff		 movzx	 edx, BYTE PTR _NewOption$246348[ebp+6]
  06cc0	52		 push	 edx
  06cc1	0f b6 85 01 fc
	ff ff		 movzx	 eax, BYTE PTR _NewOption$246348[ebp+5]
  06cc8	50		 push	 eax
  06cc9	0f b6 8d 00 fc
	ff ff		 movzx	 ecx, BYTE PTR _NewOption$246348[ebp+4]
  06cd0	51		 push	 ecx
  06cd1	0f b6 95 ff fb
	ff ff		 movzx	 edx, BYTE PTR _NewOption$246348[ebp+3]
  06cd8	52		 push	 edx
  06cd9	0f b6 85 fe fb
	ff ff		 movzx	 eax, BYTE PTR _NewOption$246348[ebp+2]
  06ce0	50		 push	 eax
  06ce1	0f b6 8d fd fb
	ff ff		 movzx	 ecx, BYTE PTR _NewOption$246348[ebp+1]
  06ce8	51		 push	 ecx
  06ce9	0f b6 95 fc fb
	ff ff		 movzx	 edx, BYTE PTR _NewOption$246348[ebp]
  06cf0	52		 push	 edx
  06cf1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06cf4	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  06cf8	51		 push	 ecx
  06cf9	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06cfc	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  06d00	50		 push	 eax
  06d01	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06d04	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  06d08	52		 push	 edx
  06d09	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06d0c	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  06d10	51		 push	 ecx
  06d11	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06d14	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  06d18	6b c0 70	 imul	 eax, 112		; 00000070H
  06d1b	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  06d20	50		 push	 eax
  06d21	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06d24	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  06d27	52		 push	 edx
  06d28	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06d2b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  06d2f	51		 push	 ecx
  06d30	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06d33	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  06d37	50		 push	 eax
  06d38	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  06d3b	51		 push	 ecx
  06d3c	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@IBNDEANJ@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@
  06d41	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  06d47	83 c4 48	 add	 esp, 72			; 00000048H
$LN28@ItemSerial@2:
$LN85@ItemSerial@2:

; 3364 : 	}
; 3365 : }

  06d4a	5f		 pop	 edi
  06d4b	5e		 pop	 esi
  06d4c	5b		 pop	 ebx
  06d4d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06d50	33 cd		 xor	 ecx, ebp
  06d52	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06d57	8b e5		 mov	 esp, ebp
  06d59	5d		 pop	 ebp
  06d5a	c3		 ret	 0
?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ENDP ; ItemSerialCreateRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z		; ItemMovePathSave
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -80						; size = 76
__$ArrayPad$ = -4					; size = 4
_ActID$ = 8						; size = 4
_Name$ = 12						; size = 4
_level$ = 16						; size = 1
_mapnumber$ = 20					; size = 1
_x$ = 24						; size = 1
_y$ = 28						; size = 1
_Item$ = 32						; size = 4
_op1$ = 36						; size = 1
_op2$ = 40						; size = 1
_op3$ = 44						; size = 1
_serial$ = 48						; size = 4
?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z PROC		; ItemMovePathSave

; 3391 : {

  06d60	55		 push	 ebp
  06d61	8b ec		 mov	 ebp, esp
  06d63	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  06d69	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  06d6e	33 c5		 xor	 eax, ebp
  06d70	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06d73	53		 push	 ebx
  06d74	56		 push	 esi
  06d75	57		 push	 edi

; 3392 : 	SDHP_ITEMMOVESAVE pMsg;
; 3393 : 
; 3394 : 	pMsg.h.c = 0xC1;

  06d76	c6 45 b0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 3395 : 	pMsg.h.headcode = 0x53;

  06d7a	c6 45 b2 53	 mov	 BYTE PTR _pMsg$[ebp+2], 83 ; 00000053H

; 3396 : 	pMsg.h.size = sizeof(pMsg);

  06d7e	c6 45 b1 4c	 mov	 BYTE PTR _pMsg$[ebp+1], 76 ; 0000004cH

; 3397 : 	pMsg.ItemLevel = level;

  06d82	8a 45 10	 mov	 al, BYTE PTR _level$[ebp]
  06d85	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+71], al

; 3398 : 	pMsg.Serial = serial;

  06d88	8b 45 30	 mov	 eax, DWORD PTR _serial$[ebp]
  06d8b	89 45 b4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 3399 : 	pMsg.ItemOp1 = op1;

  06d8e	8a 45 24	 mov	 al, BYTE PTR _op1$[ebp]
  06d91	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+72], al

; 3400 : 	pMsg.ItemOp2 = op2;

  06d94	8a 45 28	 mov	 al, BYTE PTR _op2$[ebp]
  06d97	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+73], al

; 3401 : 	pMsg.ItemOp3 = op3;

  06d9a	8a 45 2c	 mov	 al, BYTE PTR _op3$[ebp]
  06d9d	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+74], al

; 3402 : 	pMsg.X = x;

  06da0	8a 45 18	 mov	 al, BYTE PTR _x$[ebp]
  06da3	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+69], al

; 3403 : 	pMsg.Y = y;

  06da6	8a 45 1c	 mov	 al, BYTE PTR _y$[ebp]
  06da9	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+70], al

; 3404 : 	memcpy(pMsg.Account, ActID, sizeof(pMsg.Account));

  06dac	6a 0a		 push	 10			; 0000000aH
  06dae	8b 45 08	 mov	 eax, DWORD PTR _ActID$[ebp]
  06db1	50		 push	 eax
  06db2	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp+28]
  06db5	51		 push	 ecx
  06db6	e8 00 00 00 00	 call	 _memcpy
  06dbb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3405 : 	strcpy(pMsg.ItemName, Item);

  06dbe	8b 45 20	 mov	 eax, DWORD PTR _Item$[ebp]
  06dc1	50		 push	 eax
  06dc2	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp+48]
  06dc5	51		 push	 ecx
  06dc6	e8 00 00 00 00	 call	 _strcpy
  06dcb	83 c4 08	 add	 esp, 8

; 3406 : 	memcpy(pMsg.Name, Name, sizeof(pMsg.Name));

  06dce	6a 0a		 push	 10			; 0000000aH
  06dd0	8b 45 0c	 mov	 eax, DWORD PTR _Name$[ebp]
  06dd3	50		 push	 eax
  06dd4	8d 4d d6	 lea	 ecx, DWORD PTR _pMsg$[ebp+38]
  06dd7	51		 push	 ecx
  06dd8	e8 00 00 00 00	 call	 _memcpy
  06ddd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3407 : 	strcpy(pMsg.ServerName, szServerName);

  06de0	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  06de5	8d 45 b8	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  06de8	50		 push	 eax
  06de9	e8 00 00 00 00	 call	 _strcpy
  06dee	83 c4 08	 add	 esp, 8

; 3408 : 
; 3409 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  06df1	0f b6 45 b1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  06df5	50		 push	 eax
  06df6	8d 4d b0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  06df9	51		 push	 ecx
  06dfa	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  06dff	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3410 : }

  06e04	5f		 pop	 edi
  06e05	5e		 pop	 esi
  06e06	5b		 pop	 ebx
  06e07	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06e0a	33 cd		 xor	 ecx, ebp
  06e0c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06e11	8b e5		 mov	 esp, ebp
  06e13	5d		 pop	 ebp
  06e14	c3		 ret	 0
?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z ENDP		; ItemMovePathSave
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DGOptionDataSend@@YAXHPADPAEEEEEEEH@Z		; DGOptionDataSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szName$ = 12						; size = 4
_KeyBuffer$ = 16					; size = 4
_GO$ = 20						; size = 1
_Qk$ = 24						; size = 1
_Wk$ = 28						; size = 1
_Ek$ = 32						; size = 1
_ChatWnd$ = 36						; size = 1
_Rk$ = 40						; size = 1
_QWERLevel$ = 44					; size = 4
?DGOptionDataSend@@YAXHPADPAEEEEEEEH@Z PROC		; DGOptionDataSend

; 3434 : {

  06e20	55		 push	 ebp
  06e21	8b ec		 mov	 ebp, esp
  06e23	83 ec 70	 sub	 esp, 112		; 00000070H
  06e26	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  06e2b	33 c5		 xor	 eax, ebp
  06e2d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06e30	53		 push	 ebx
  06e31	56		 push	 esi
  06e32	57		 push	 edi

; 3435 : 	SDHP_SKILLKEYDATA pMsg;
; 3436 : 
; 3437 : 	pMsg.h.c = 0xC1;

  06e33	c6 45 d0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 3438 : 	pMsg.h.headcode = 0x60;

  06e37	c6 45 d2 60	 mov	 BYTE PTR _pMsg$[ebp+2], 96 ; 00000060H

; 3439 : 	pMsg.h.size = sizeof(pMsg);

  06e3b	c6 45 d1 2c	 mov	 BYTE PTR _pMsg$[ebp+1], 44 ; 0000002cH

; 3440 : 	memcpy(pMsg.Name, szName, sizeof(pMsg.Name));

  06e3f	6a 0a		 push	 10			; 0000000aH
  06e41	8b 45 0c	 mov	 eax, DWORD PTR _szName$[ebp]
  06e44	50		 push	 eax
  06e45	8d 4d d3	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  06e48	51		 push	 ecx
  06e49	e8 00 00 00 00	 call	 _memcpy
  06e4e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3441 : 	memcpy(pMsg.SkillKeyBuffer, KeyBuffer, sizeof(pMsg.SkillKeyBuffer));

  06e51	6a 14		 push	 20			; 00000014H
  06e53	8b 45 10	 mov	 eax, DWORD PTR _KeyBuffer$[ebp]
  06e56	50		 push	 eax
  06e57	8d 4d dd	 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  06e5a	51		 push	 ecx
  06e5b	e8 00 00 00 00	 call	 _memcpy
  06e60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3442 : 	pMsg.GameOption = GO;

  06e63	8a 45 14	 mov	 al, BYTE PTR _GO$[ebp]
  06e66	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+33], al

; 3443 : 	pMsg.QkeyDefine = Qk;

  06e69	8a 45 18	 mov	 al, BYTE PTR _Qk$[ebp]
  06e6c	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+34], al

; 3444 : 	pMsg.WkeyDefine = Wk;

  06e6f	8a 45 1c	 mov	 al, BYTE PTR _Wk$[ebp]
  06e72	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+35], al

; 3445 : 	pMsg.EkeyDefine = Ek;

  06e75	8a 45 20	 mov	 al, BYTE PTR _Ek$[ebp]
  06e78	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+36], al

; 3446 : 	pMsg.ChatWindow = ChatWnd;

  06e7b	8a 45 24	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  06e7e	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+37], al

; 3447 : 	pMsg.RkeyDefine = Rk;

  06e81	8a 45 28	 mov	 al, BYTE PTR _Rk$[ebp]
  06e84	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+38], al

; 3448 : 	pMsg.QWERLevel = QWERLevel;

  06e87	8b 45 2c	 mov	 eax, DWORD PTR _QWERLevel$[ebp]
  06e8a	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+40], eax

; 3449 : 
; 3450 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  06e8d	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  06e91	50		 push	 eax
  06e92	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  06e95	51		 push	 ecx
  06e96	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  06e9b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3451 : }

  06ea0	5f		 pop	 edi
  06ea1	5e		 pop	 esi
  06ea2	5b		 pop	 ebx
  06ea3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06ea6	33 cd		 xor	 ecx, ebp
  06ea8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06ead	8b e5		 mov	 esp, ebp
  06eaf	5d		 pop	 ebp
  06eb0	c3		 ret	 0
?DGOptionDataSend@@YAXHPADPAEEEEEEEH@Z ENDP		; DGOptionDataSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?GCSkillKeySend@@YAXHPAEEEEEEEH@Z:PROC		; GCSkillKeySend
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_szName$ = -20						; size = 11
_aIndex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z PROC ; DGOptionDataRecv

; 3455 : {

  06ec0	55		 push	 ebp
  06ec1	8b ec		 mov	 ebp, esp
  06ec3	83 ec 54	 sub	 esp, 84			; 00000054H
  06ec6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  06ecb	33 c5		 xor	 eax, ebp
  06ecd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06ed0	53		 push	 ebx
  06ed1	56		 push	 esi
  06ed2	57		 push	 edi

; 3456 : 	int aIndex = lpMsg->aIndex;

  06ed3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06ed6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  06ed9	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 3457 : 	char szName[MAX_ACCOUNT_LEN+1];
; 3458 : 
; 3459 : 	if ( aIndex < 0 || aIndex >= OBJMAX )

  06edc	83 7d f8 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  06ee0	7c 09		 jl	 SHORT $LN2@DGOptionDa
  06ee2	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 15000 ; 00003a98H
  06ee9	7c 05		 jl	 SHORT $LN3@DGOptionDa
$LN2@DGOptionDa:

; 3460 : 	{
; 3461 : 		return;

  06eeb	e9 95 00 00 00	 jmp	 $LN4@DGOptionDa
$LN3@DGOptionDa:

; 3462 : 	}
; 3463 : 
; 3464 : 	memset(szName, 0, sizeof(szName));

  06ef0	6a 0b		 push	 11			; 0000000bH
  06ef2	6a 00		 push	 0
  06ef4	8d 45 ec	 lea	 eax, DWORD PTR _szName$[ebp]
  06ef7	50		 push	 eax
  06ef8	e8 00 00 00 00	 call	 _memset
  06efd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3465 : 	memcpy(szName, lpMsg->Name, sizeof(lpMsg->Name));

  06f00	6a 0a		 push	 10			; 0000000aH
  06f02	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06f05	83 c0 08	 add	 eax, 8
  06f08	50		 push	 eax
  06f09	8d 4d ec	 lea	 ecx, DWORD PTR _szName$[ebp]
  06f0c	51		 push	 ecx
  06f0d	e8 00 00 00 00	 call	 _memcpy
  06f12	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3466 : 
; 3467 : 	if ( strcmp(gObj[aIndex].Name, szName) != 0 )

  06f15	8d 45 ec	 lea	 eax, DWORD PTR _szName$[ebp]
  06f18	50		 push	 eax
  06f19	8b 4d f8	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  06f1c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06f22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06f28	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  06f2c	50		 push	 eax
  06f2d	e8 00 00 00 00	 call	 _strcmp
  06f32	83 c4 08	 add	 esp, 8
  06f35	85 c0		 test	 eax, eax
  06f37	74 02		 je	 SHORT $LN1@DGOptionDa

; 3468 : 	{
; 3469 : 		return;

  06f39	eb 4a		 jmp	 SHORT $LN4@DGOptionDa
$LN1@DGOptionDa:

; 3470 : 	}
; 3471 : 
; 3472 : 	::GCSkillKeySend(aIndex, lpMsg->SkillKeyBuffer, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, lpMsg->RkeyDefine, lpMsg->QWERLevel);

  06f3b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06f3e	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  06f41	51		 push	 ecx
  06f42	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06f45	0f b6 42 2b	 movzx	 eax, BYTE PTR [edx+43]
  06f49	50		 push	 eax
  06f4a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06f4d	0f b6 51 2a	 movzx	 edx, BYTE PTR [ecx+42]
  06f51	52		 push	 edx
  06f52	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06f55	0f b6 48 29	 movzx	 ecx, BYTE PTR [eax+41]
  06f59	51		 push	 ecx
  06f5a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06f5d	0f b6 42 28	 movzx	 eax, BYTE PTR [edx+40]
  06f61	50		 push	 eax
  06f62	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  06f65	0f b6 51 27	 movzx	 edx, BYTE PTR [ecx+39]
  06f69	52		 push	 edx
  06f6a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06f6d	0f b6 48 26	 movzx	 ecx, BYTE PTR [eax+38]
  06f71	51		 push	 ecx
  06f72	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06f75	83 c2 12	 add	 edx, 18			; 00000012H
  06f78	52		 push	 edx
  06f79	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  06f7c	50		 push	 eax
  06f7d	e8 00 00 00 00	 call	 ?GCSkillKeySend@@YAXHPAEEEEEEEH@Z ; GCSkillKeySend
  06f82	83 c4 24	 add	 esp, 36			; 00000024H
$LN4@DGOptionDa:

; 3473 : }

  06f85	5f		 pop	 edi
  06f86	5e		 pop	 esi
  06f87	5b		 pop	 ebx
  06f88	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06f8b	33 cd		 xor	 ecx, ebp
  06f8d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06f92	8b e5		 mov	 esp, ebp
  06f94	5d		 pop	 ebp
  06f95	c3		 ret	 0
?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ENDP ; DGOptionDataRecv
_TEXT	ENDS
PUBLIC	??_C@_0CD@PJLJCJEO@?$DP?$DP?$DP?$DP?5?$DP?$KN?$DP?$DP?$LH?$DP?5?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$LB?$DP?5?$DP?$DP?$LG?$DP?$DP?$DP?$DP@ ; `string'
PUBLIC	??_C@_0BD@FKDAJDLN@?$DP?$DP?$DP?$DP?$DP?$DP?5?$DP?$DP?$LH?$DP?$LF?$DP?$DP?$DP?$DP?$DP?4?$AA@ ; `string'
PUBLIC	??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@ ; `string'
PUBLIC	??_C@_0DI@JHPADDFL@?$DP?$KO?$DP?$KG?5?$DP?$DP?$LL?$DP?$DP?$DP?5change?$EAwebzen?4co?4kr?$LH@ ; `string'
PUBLIC	??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?1??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA ; `DGMoveOtherServer'::`2'::__LINE__Var
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
;	COMDAT ??_C@_0CD@PJLJCJEO@?$DP?$DP?$DP?$DP?5?$DP?$KN?$DP?$DP?$LH?$DP?5?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$LB?$DP?5?$DP?$DP?$LG?$DP?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_0CD@PJLJCJEO@?$DP?$DP?$DP?$DP?5?$DP?$KN?$DP?$DP?$LH?$DP?5?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$LB?$DP?5?$DP?$DP?$LG?$DP?$DP?$DP?$DP@ DB '?'
	DB	'??? ?', 0adH, '??', 0b7H, '? ??????????', 0b1H, '? ??', 0b6H, '?'
	DB	'????.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FKDAJDLN@?$DP?$DP?$DP?$DP?$DP?$DP?5?$DP?$DP?$LH?$DP?$LF?$DP?$DP?$DP?$DP?$DP?4?$AA@
CONST	SEGMENT
??_C@_0BD@FKDAJDLN@?$DP?$DP?$DP?$DP?$DP?$DP?5?$DP?$DP?$LH?$DP?$LF?$DP?$DP?$DP?$DP?$DP?4?$AA@ DB '?'
	DB	'????? ??', 0b7H, '?', 0b5H, '?????.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@
CONST	SEGMENT
??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@ DB '['
	DB	'CharTrasfer] Success [%s][%s] (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JHPADDFL@?$DP?$KO?$DP?$KG?5?$DP?$DP?$LL?$DP?$DP?$DP?5change?$EAwebzen?4co?4kr?$LH@
CONST	SEGMENT
??_C@_0DI@JHPADDFL@?$DP?$KO?$DP?$KG?5?$DP?$DP?$LL?$DP?$DP?$DP?5change?$EAwebzen?4co?4kr?$LH@ DB '?'
	DB	0aeH, '?', 0a6H, ' ??', 0bbH, '??? change@webzen.co.kr', 0b7H, '?'
	DB	' ?', 0aeH, '???? ????', 0b1H, '???', 0b6H, '?????', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@ DB '['
	DB	'CharTrasfer] Fail [%s][%s] (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA DD 0d95H ; `DGMoveOtherServer'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
_pResult$246440 = -8					; size = 4
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z PROC ; DGMoveOtherServer

; 3477 : {

  06fa0	55		 push	 ebp
  06fa1	8b ec		 mov	 ebp, esp
  06fa3	83 ec 48	 sub	 esp, 72			; 00000048H
  06fa6	53		 push	 ebx
  06fa7	56		 push	 esi
  06fa8	57		 push	 edi

; 3478 : 	if ( !gObjIsConnectedGP(lpMsg->Number))

  06fa9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06fac	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  06fb0	51		 push	 ecx
  06fb1	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  06fb6	83 c4 04	 add	 esp, 4
  06fb9	85 c0		 test	 eax, eax
  06fbb	75 23		 jne	 SHORT $LN2@DGMoveOthe

; 3479 : 	{
; 3480 : 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  06fbd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA
  06fc2	83 c0 03	 add	 eax, 3
  06fc5	50		 push	 eax
  06fc6	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CJNCOELN@d?3?2projects?2exteam6?43?2source?2gam@
  06fcb	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  06fd0	6a 02		 push	 2
  06fd2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  06fd8	83 c4 10	 add	 esp, 16			; 00000010H

; 3481 : 		return;

  06fdb	e9 1f 01 00 00	 jmp	 $LN3@DGMoveOthe
$LN2@DGMoveOthe:

; 3482 : 	}
; 3483 : 
; 3484 : 	LPOBJ lpObj = &gObj[lpMsg->Number];

  06fe0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06fe3	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  06fe7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06fed	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06ff3	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 3485 : 
; 3486 : 	if ( lpMsg->Result != 0 )

  06ff6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06ff9	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  06ffd	85 c9		 test	 ecx, ecx
  06fff	74 78		 je	 SHORT $LN1@DGMoveOthe

; 3487 : 	{
; 3488 : 		PMSG_DEFRESULT pResult;
; 3489 : 
; 3490 : 		PHeadSetB((LPBYTE)&pResult, 0x99, sizeof(pResult));

  07001	6a 04		 push	 4
  07003	68 99 00 00 00	 push	 153			; 00000099H
  07008	8d 45 f8	 lea	 eax, DWORD PTR _pResult$246440[ebp]
  0700b	50		 push	 eax
  0700c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  07011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3491 : 		pResult.result = 1;

  07014	c6 45 fb 01	 mov	 BYTE PTR _pResult$246440[ebp+3], 1

; 3492 : 
; 3493 : 		DataSend(lpMsg->Number, (LPBYTE)&pResult, pResult.h.size);

  07018	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$246440[ebp+1]
  0701c	50		 push	 eax
  0701d	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$246440[ebp]
  07020	51		 push	 ecx
  07021	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  07024	0f bf 42 0e	 movsx	 eax, WORD PTR [edx+14]
  07028	50		 push	 eax
  07029	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0702e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3494 : 
; 3495 : 		LogAddTD("[CharTrasfer] Fail [%s][%s] (%d)", lpObj->AccountID, lpObj->Name, lpMsg->Result);

  07031	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07034	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  07038	51		 push	 ecx
  07039	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0703c	83 c2 77	 add	 edx, 119		; 00000077H
  0703f	52		 push	 edx
  07040	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07043	83 c0 6c	 add	 eax, 108		; 0000006cH
  07046	50		 push	 eax
  07047	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@
  0704c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  07052	83 c4 10	 add	 esp, 16			; 00000010H

; 3496 : 		
; 3497 : 		lpObj->m_MoveOtherServer = 0;

  07055	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07058	c6 80 d8 10 00
	00 00		 mov	 BYTE PTR [eax+4312], 0

; 3498 : 		
; 3499 : 		GCServerMsgStringSend("  change@webzen.co.kr  ",lpObj->m_Index, 1);

  0705f	6a 01		 push	 1
  07061	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07064	8b 08		 mov	 ecx, DWORD PTR [eax]
  07066	51		 push	 ecx
  07067	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@JHPADDFL@?$DP?$KO?$DP?$KG?5?$DP?$DP?$LL?$DP?$DP?$DP?5change?$EAwebzen?4co?4kr?$LH@
  0706c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  07071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3500 : 		return;

  07074	e9 86 00 00 00	 jmp	 $LN3@DGMoveOthe
$LN1@DGMoveOthe:

; 3501 : 	}
; 3502 : 
; 3503 : 	LogAddTD("[CharTrasfer] Success [%s][%s] (%d)",	lpObj->AccountID, lpObj->Name, lpMsg->Result);

  07079	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0707c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  07080	51		 push	 ecx
  07081	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  07084	83 c2 77	 add	 edx, 119		; 00000077H
  07087	52		 push	 edx
  07088	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0708b	83 c0 6c	 add	 eax, 108		; 0000006cH
  0708e	50		 push	 eax
  0708f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@
  07094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0709a	83 c4 10	 add	 esp, 16			; 00000010H

; 3504 : 
; 3505 : 	GCServerMsgStringSend(" .", lpObj->m_Index, 1);

  0709d	6a 01		 push	 1
  0709f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  070a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  070a4	51		 push	 ecx
  070a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FKDAJDLN@?$DP?$DP?$DP?$DP?$DP?$DP?5?$DP?$DP?$LH?$DP?$LF?$DP?$DP?$DP?$DP?$DP?4?$AA@
  070aa	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  070af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3506 : 	GCServerMsgStringSend("   .", lpObj->m_Index, 1);

  070b2	6a 01		 push	 1
  070b4	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  070b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  070b9	51		 push	 ecx
  070ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@PJLJCJEO@?$DP?$DP?$DP?$DP?5?$DP?$KN?$DP?$DP?$LH?$DP?5?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$LB?$DP?5?$DP?$DP?$LG?$DP?$DP?$DP?$DP@
  070bf	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  070c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3507 : 
; 3508 : 	GJSetCharacterInfo(lpObj, lpObj->m_Index, 0);

  070c7	6a 00		 push	 0
  070c9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  070cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  070ce	51		 push	 ecx
  070cf	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  070d2	52		 push	 edx
  070d3	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  070d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3509 : 
; 3510 : 	lpObj->LoadWareHouseInfo = false;

  070db	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  070de	c6 80 54 10 00
	00 00		 mov	 BYTE PTR [eax+4180], 0

; 3511 : 	gObjCloseSet(lpObj->m_Index, 2);

  070e5	6a 02		 push	 2
  070e7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  070ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  070ec	51		 push	 ecx
  070ed	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  070f2	83 c4 08	 add	 esp, 8

; 3512 : 	lpObj->m_MoveOtherServer = 0;

  070f5	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  070f8	c6 80 d8 10 00
	00 00		 mov	 BYTE PTR [eax+4312], 0
$LN3@DGMoveOthe:

; 3513 : }

  070ff	5f		 pop	 edi
  07100	5e		 pop	 esi
  07101	5b		 pop	 ebx
  07102	8b e5		 mov	 esp, ebp
  07104	5d		 pop	 ebp
  07105	c3		 ret	 0
?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ENDP ; DGMoveOtherServer
_TEXT	ENDS
PUBLIC	?set@PWMSG_HEAD@@QAEXPAEEH@Z			; PWMSG_HEAD::set
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$246497 = -4148					; size = 20
_n$246489 = -4128					; size = 4
_n$246480 = -4124					; size = 4
_petIteminfo$ = -4120					; size = 8
_founditemcount$ = -4112				; size = 4
_lofs$ = -4108						; size = 4
_pbuffer$ = -4104					; size = 4096
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_inventype$ = 12					; size = 4
?gObjRequestPetItemInfo@@YAXHH@Z PROC			; gObjRequestPetItemInfo

; 3539 : {

  07110	55		 push	 ebp
  07111	8b ec		 mov	 ebp, esp
  07113	b8 74 10 00 00	 mov	 eax, 4212		; 00001074H
  07118	e8 00 00 00 00	 call	 __chkstk
  0711d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07122	33 c5		 xor	 eax, ebp
  07124	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07127	53		 push	 ebx
  07128	56		 push	 esi
  07129	57		 push	 edi

; 3540 : 	LPOBJ lpObj = &gObj[aIndex];

  0712a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0712d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07133	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07139	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3541 : 	char pbuffer[WAREHOUSE_BUFF];//Season 4.5 change size in 2x times
; 3542 : 	int lofs = sizeof(SDHP_REQUEST_PETITEM_INFO);

  0713c	c7 85 f4 ef ff
	ff 14 00 00 00	 mov	 DWORD PTR _lofs$[ebp], 20 ; 00000014H

; 3543 : 	int founditemcount = 0;

  07146	c7 85 f0 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _founditemcount$[ebp], 0

; 3544 : 	Request_PetItem_Info petIteminfo;
; 3545 : 
; 3546 : 	if ( inventype == 0 )

  07150	83 7d 0c 00	 cmp	 DWORD PTR _inventype$[ebp], 0
  07154	0f 85 00 01 00
	00		 jne	 $LN16@gObjReques

; 3547 : 	{
; 3548 : 		for ( int n=0;n<INVENTORY_SIZE;n++)

  0715a	c7 85 e4 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$246480[ebp], 0
  07164	eb 0f		 jmp	 SHORT $LN15@gObjReques
$LN14@gObjReques:
  07166	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _n$246480[ebp]
  0716c	83 c0 01	 add	 eax, 1
  0716f	89 85 e4 ef ff
	ff		 mov	 DWORD PTR _n$246480[ebp], eax
$LN15@gObjReques:
  07175	81 bd e4 ef ff
	ff ec 00 00 00	 cmp	 DWORD PTR _n$246480[ebp], 236 ; 000000ecH
  0717f	0f 8d d0 00 00
	00		 jge	 $LN13@gObjReques

; 3549 : 		{
; 3550 : 			if ( lpObj->pInventory[n].IsItem() )

  07185	8b 8d e4 ef ff
	ff		 mov	 ecx, DWORD PTR _n$246480[ebp]
  0718b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07191	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07194	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0719a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0719f	85 c0		 test	 eax, eax
  071a1	0f 84 a9 00 00
	00		 je	 $LN12@gObjReques

; 3551 : 			{
; 3552 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  071a7	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _n$246480[ebp]
  071ad	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  071b3	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  071b6	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  071bc	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  071c1	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  071c6	74 21		 je	 SHORT $LN10@gObjReques
  071c8	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _n$246480[ebp]
  071ce	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  071d4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  071d7	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  071dd	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  071e2	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  071e7	75 67		 jne	 SHORT $LN12@gObjReques
$LN10@gObjReques:

; 3553 : 				{
; 3554 : 					founditemcount++;

  071e9	8b 85 f0 ef ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  071ef	83 c0 01	 add	 eax, 1
  071f2	89 85 f0 ef ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 3555 : 					petIteminfo.nPos = n;

  071f8	8a 85 e4 ef ff
	ff		 mov	 al, BYTE PTR _n$246480[ebp]
  071fe	88 85 e8 ef ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp], al

; 3556 : 					petIteminfo.nSerial = lpObj->pInventory[n].m_Number;

  07204	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _n$246480[ebp]
  0720a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07210	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  07213	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  07219	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  0721c	89 85 ec ef ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+4], eax

; 3557 : 					memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  07222	6a 08		 push	 8
  07224	8d 85 e8 ef ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  0722a	50		 push	 eax
  0722b	8b 8d f4 ef ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  07231	8d 94 0d f8 ef
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  07238	52		 push	 edx
  07239	e8 00 00 00 00	 call	 _memcpy
  0723e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3558 : 					lofs +=sizeof(petIteminfo);

  07241	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  07247	83 c0 08	 add	 eax, 8
  0724a	89 85 f4 ef ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN12@gObjReques:

; 3559 : 				}
; 3560 : 			}
; 3561 : 		}

  07250	e9 11 ff ff ff	 jmp	 $LN14@gObjReques
$LN13@gObjReques:

; 3562 : 	}
; 3563 : 	else if ( inventype == 1 )

  07255	e9 05 01 00 00	 jmp	 $LN9@gObjReques
$LN16@gObjReques:
  0725a	83 7d 0c 01	 cmp	 DWORD PTR _inventype$[ebp], 1
  0725e	0f 85 fb 00 00
	00		 jne	 $LN9@gObjReques

; 3564 : 	{
; 3565 : 		for ( int n=0;n<WAREHOUSE_SIZE;n++)

  07264	c7 85 e0 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$246489[ebp], 0
  0726e	eb 0f		 jmp	 SHORT $LN7@gObjReques
$LN6@gObjReques:
  07270	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246489[ebp]
  07276	83 c0 01	 add	 eax, 1
  07279	89 85 e0 ef ff
	ff		 mov	 DWORD PTR _n$246489[ebp], eax
$LN7@gObjReques:
  0727f	81 bd e0 ef ff
	ff f0 00 00 00	 cmp	 DWORD PTR _n$246489[ebp], 240 ; 000000f0H
  07289	0f 8d d0 00 00
	00		 jge	 $LN9@gObjReques

; 3566 : 		{
; 3567 : 			if ( lpObj->pWarehouse[n].IsItem() )

  0728f	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _n$246489[ebp]
  07295	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0729b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0729e	03 88 5c 0e 00
	00		 add	 ecx, DWORD PTR [eax+3676]
  072a4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  072a9	85 c0		 test	 eax, eax
  072ab	0f 84 a9 00 00
	00		 je	 $LN4@gObjReques

; 3568 : 			{
; 3569 : 				if ( lpObj->pWarehouse[n].m_Type == ITEMGET(13,4) || lpObj->pWarehouse[n].m_Type == ITEMGET(13,5) )

  072b1	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246489[ebp]
  072b7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  072bd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  072c0	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  072c6	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  072cb	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  072d0	74 21		 je	 SHORT $LN2@gObjReques
  072d2	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246489[ebp]
  072d8	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  072de	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  072e1	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  072e7	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  072ec	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  072f1	75 67		 jne	 SHORT $LN4@gObjReques
$LN2@gObjReques:

; 3570 : 				{
; 3571 : 					founditemcount++;

  072f3	8b 85 f0 ef ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  072f9	83 c0 01	 add	 eax, 1
  072fc	89 85 f0 ef ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 3572 : 					petIteminfo.nPos = n;

  07302	8a 85 e0 ef ff
	ff		 mov	 al, BYTE PTR _n$246489[ebp]
  07308	88 85 e8 ef ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp], al

; 3573 : 					petIteminfo.nSerial = lpObj->pWarehouse[n].m_Number;

  0730e	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246489[ebp]
  07314	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0731a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0731d	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  07323	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  07326	89 85 ec ef ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+4], eax

; 3574 : 					memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  0732c	6a 08		 push	 8
  0732e	8d 85 e8 ef ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  07334	50		 push	 eax
  07335	8b 8d f4 ef ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  0733b	8d 94 0d f8 ef
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  07342	52		 push	 edx
  07343	e8 00 00 00 00	 call	 _memcpy
  07348	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3575 : 					lofs +=sizeof(petIteminfo);

  0734b	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  07351	83 c0 08	 add	 eax, 8
  07354	89 85 f4 ef ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN4@gObjReques:

; 3576 : 				}
; 3577 : 			}
; 3578 : 		}

  0735a	e9 11 ff ff ff	 jmp	 $LN6@gObjReques
$LN9@gObjReques:

; 3579 : 	}
; 3580 : 	
; 3581 : 	if ( founditemcount )

  0735f	83 bd f0 ef ff
	ff 00		 cmp	 DWORD PTR _founditemcount$[ebp], 0
  07366	0f 84 89 00 00
	00		 je	 $LN17@gObjReques

; 3582 : 	{
; 3583 : 		SDHP_REQUEST_PETITEM_INFO pMsg;
; 3584 : 
; 3585 : 		pMsg.h.set((LPBYTE)&pMsg, 0x56, lofs + sizeof(pMsg));

  0736c	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  07372	83 c0 14	 add	 eax, 20			; 00000014H
  07375	50		 push	 eax
  07376	6a 56		 push	 86			; 00000056H
  07378	8d 8d cc ef ff
	ff		 lea	 ecx, DWORD PTR _pMsg$246497[ebp]
  0737e	51		 push	 ecx
  0737f	8d 8d cc ef ff
	ff		 lea	 ecx, DWORD PTR _pMsg$246497[ebp]
  07385	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD@@QAEXPAEEH@Z ; PWMSG_HEAD::set

; 3586 : 		memcpy(pMsg.AccountID, lpObj->AccountID, MAX_ACCOUNT_LEN);

  0738a	6a 0a		 push	 10			; 0000000aH
  0738c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0738f	83 c0 6c	 add	 eax, 108		; 0000006cH
  07392	50		 push	 eax
  07393	8d 8d d0 ef ff
	ff		 lea	 ecx, DWORD PTR _pMsg$246497[ebp+4]
  07399	51		 push	 ecx
  0739a	e8 00 00 00 00	 call	 _memcpy
  0739f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3587 : 		pMsg.Number = aIndex;

  073a2	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  073a6	66 89 85 dc ef
	ff ff		 mov	 WORD PTR _pMsg$246497[ebp+16], ax

; 3588 : 		pMsg.InvenType = inventype;

  073ad	8a 45 0c	 mov	 al, BYTE PTR _inventype$[ebp]
  073b0	88 85 de ef ff
	ff		 mov	 BYTE PTR _pMsg$246497[ebp+18], al

; 3589 : 		pMsg.nCount = founditemcount;

  073b6	8a 85 f0 ef ff
	ff		 mov	 al, BYTE PTR _founditemcount$[ebp]
  073bc	88 85 df ef ff
	ff		 mov	 BYTE PTR _pMsg$246497[ebp+19], al

; 3590 : 		memcpy(pbuffer, &pMsg, sizeof(pMsg));

  073c2	6a 14		 push	 20			; 00000014H
  073c4	8d 85 cc ef ff
	ff		 lea	 eax, DWORD PTR _pMsg$246497[ebp]
  073ca	50		 push	 eax
  073cb	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  073d1	51		 push	 ecx
  073d2	e8 00 00 00 00	 call	 _memcpy
  073d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3591 : 
; 3592 : 		cDBSMng.Send((char*)pbuffer, lofs+sizeof(pMsg));

  073da	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  073e0	83 c0 14	 add	 eax, 20			; 00000014H
  073e3	50		 push	 eax
  073e4	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  073ea	51		 push	 ecx
  073eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  073f0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN17@gObjReques:

; 3593 : 	}
; 3594 : }

  073f5	5f		 pop	 edi
  073f6	5e		 pop	 esi
  073f7	5b		 pop	 ebx
  073f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  073fb	33 cd		 xor	 ecx, ebp
  073fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07402	8b e5		 mov	 esp, ebp
  07404	5d		 pop	 ebp
  07405	c3		 ret	 0
?gObjRequestPetItemInfo@@YAXHH@Z ENDP			; gObjRequestPetItemInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 122  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 		lpBuf[0] = 0xC2;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H

; 124  : 		lpBuf[1] = SET_NUMBERH(size);

  00012	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00015	c1 e8 08	 shr	 eax, 8
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  0001b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 125  : 		lpBuf[2] = SET_NUMBERL(size);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00021	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00029	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 126  : 		lpBuf[3] = head;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0002f	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00032	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 127  : 	};

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
PUBLIC	??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?SetPetItemInfo@CItem@@QAEXHH@Z:PROC		; CItem::SetPetItemInfo
;	COMDAT ??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@ DB 'Request to r'
	DB	'eceive petitem infomation doesn''t match the user %s', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_n$246548 = -40						; size = 4
_n$246538 = -36						; size = 4
_ReCalc$246537 = -32					; size = 4
_szAccountId$ = -28					; size = 11
_aIndex$ = -16						; size = 4
_pPetItemInfo$ = -12					; size = 4
_lpMsg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?DGRecvPetItemInfo@@YAXPAE@Z PROC			; DGRecvPetItemInfo

; 3616 : {

  07410	55		 push	 ebp
  07411	8b ec		 mov	 ebp, esp
  07413	83 ec 68	 sub	 esp, 104		; 00000068H
  07416	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0741b	33 c5		 xor	 eax, ebp
  0741d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07420	53		 push	 ebx
  07421	56		 push	 esi
  07422	57		 push	 edi

; 3617 : 	SDHP_RECV_PETITEM_INFO* lpMsg = (SDHP_RECV_PETITEM_INFO *)lpData;

  07423	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  07426	89 45 f8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 3618 : 	Recv_PetItem_Info* pPetItemInfo = (Recv_PetItem_Info *)((DWORD)lpData + sizeof(SDHP_RECV_PETITEM_INFO));

  07429	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  0742c	83 c0 14	 add	 eax, 20			; 00000014H
  0742f	89 45 f4	 mov	 DWORD PTR _pPetItemInfo$[ebp], eax

; 3619 : 	int aIndex = lpMsg->Number;

  07432	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07435	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  07439	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 3620 : 	char szAccountId[MAX_ACCOUNT_LEN+1];
; 3621 : 	szAccountId[MAX_ACCOUNT_LEN]=0;

  0743c	c6 45 ee 00	 mov	 BYTE PTR _szAccountId$[ebp+10], 0

; 3622 : 
; 3623 : 	memcpy(szAccountId, lpMsg->AccountID, MAX_ACCOUNT_LEN);

  07440	6a 0a		 push	 10			; 0000000aH
  07442	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07445	83 c0 04	 add	 eax, 4
  07448	50		 push	 eax
  07449	8d 4d e4	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  0744c	51		 push	 ecx
  0744d	e8 00 00 00 00	 call	 _memcpy
  07452	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3624 : 	
; 3625 : 	if ( !gObjIsAccontConnect(aIndex, szAccountId))

  07455	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  07458	50		 push	 eax
  07459	8b 4d f0	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0745c	51		 push	 ecx
  0745d	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  07462	83 c4 08	 add	 esp, 8
  07465	85 c0		 test	 eax, eax
  07467	75 25		 jne	 SHORT $LN16@DGRecvPetI

; 3626 : 	{
; 3627 : 		LogAddC(2, "Request to receive petitem infomation doesn't match the user %s", szAccountId);

  07469	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  0746c	50		 push	 eax
  0746d	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@
  07472	6a 02		 push	 2
  07474	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0747a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3628 : 		CloseClient(aIndex);

  0747d	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07480	50		 push	 eax
  07481	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  07486	83 c4 04	 add	 esp, 4

; 3629 : 		
; 3630 : 		return;

  07489	e9 1c 02 00 00	 jmp	 $LN17@DGRecvPetI
$LN16@DGRecvPetI:

; 3631 : 	}
; 3632 : 
; 3633 : 	if ( lpMsg->InvenType == 0 )

  0748e	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  07491	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  07495	85 c9		 test	 ecx, ecx
  07497	0f 85 1a 01 00
	00		 jne	 $LN15@DGRecvPetI

; 3634 : 	{
; 3635 : 		BOOL ReCalc = 0;

  0749d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ReCalc$246537[ebp], 0

; 3636 : 
; 3637 : 		for ( int n=0;n<lpMsg->nCount;n++)

  074a4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _n$246538[ebp], 0
  074ab	eb 09		 jmp	 SHORT $LN14@DGRecvPetI
$LN13@DGRecvPetI:
  074ad	8b 45 dc	 mov	 eax, DWORD PTR _n$246538[ebp]
  074b0	83 c0 01	 add	 eax, 1
  074b3	89 45 dc	 mov	 DWORD PTR _n$246538[ebp], eax
$LN14@DGRecvPetI:
  074b6	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  074b9	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  074bd	39 4d dc	 cmp	 DWORD PTR _n$246538[ebp], ecx
  074c0	0f 8d da 00 00
	00		 jge	 $LN12@DGRecvPetI

; 3638 : 		{
; 3639 : 			if ( pPetItemInfo[n].nPos < INVETORY_WEAR_SIZE )

  074c6	8b 45 dc	 mov	 eax, DWORD PTR _n$246538[ebp]
  074c9	c1 e0 04	 shl	 eax, 4
  074cc	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  074cf	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  074d3	83 fa 0c	 cmp	 edx, 12			; 0000000cH
  074d6	7d 07		 jge	 SHORT $LN11@DGRecvPetI

; 3640 : 			{
; 3641 : 				ReCalc = 1;

  074d8	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _ReCalc$246537[ebp], 1
$LN11@DGRecvPetI:

; 3642 : 			}
; 3643 : 
; 3644 : 			if ( gObj[aIndex].pInventory[pPetItemInfo[n].nPos].IsItem() )

  074df	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  074e2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  074e8	8b 4d dc	 mov	 ecx, DWORD PTR _n$246538[ebp]
  074eb	c1 e1 04	 shl	 ecx, 4
  074ee	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  074f1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  074f5	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  074fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07501	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  07508	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0750d	85 c0		 test	 eax, eax
  0750f	0f 84 86 00 00
	00		 je	 $LN10@DGRecvPetI

; 3645 : 			{
; 3646 : 				if ( gObj[aIndex].pInventory[pPetItemInfo[n].nPos].m_Number == pPetItemInfo[n].nSerial )

  07515	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07518	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0751e	8b 4d dc	 mov	 ecx, DWORD PTR _n$246538[ebp]
  07521	c1 e1 04	 shl	 ecx, 4
  07524	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  07527	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0752b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07531	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07537	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0753e	8b 55 dc	 mov	 edx, DWORD PTR _n$246538[ebp]
  07541	c1 e2 04	 shl	 edx, 4
  07544	8b 75 f4	 mov	 esi, DWORD PTR _pPetItemInfo$[ebp]
  07547	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  0754a	3b 44 16 04	 cmp	 eax, DWORD PTR [esi+edx+4]
  0754e	75 4b		 jne	 SHORT $LN10@DGRecvPetI

; 3647 : 				{
; 3648 : 					gObj[aIndex].pInventory[pPetItemInfo[n].nPos].SetPetItemInfo(pPetItemInfo[n].Level, pPetItemInfo[n].Exp);

  07550	8b 45 dc	 mov	 eax, DWORD PTR _n$246538[ebp]
  07553	c1 e0 04	 shl	 eax, 4
  07556	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  07559	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0755d	52		 push	 edx
  0755e	8b 45 dc	 mov	 eax, DWORD PTR _n$246538[ebp]
  07561	c1 e0 04	 shl	 eax, 4
  07564	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  07567	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  0756c	52		 push	 edx
  0756d	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07570	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07576	8b 4d dc	 mov	 ecx, DWORD PTR _n$246538[ebp]
  07579	c1 e1 04	 shl	 ecx, 4
  0757c	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  0757f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  07583	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07589	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0758f	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  07596	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo
$LN10@DGRecvPetI:

; 3649 : 				}
; 3650 : 			}
; 3651 : 		}

  0759b	e9 0d ff ff ff	 jmp	 $LN13@DGRecvPetI
$LN12@DGRecvPetI:

; 3652 : 
; 3653 : 		if ( ReCalc != FALSE )

  075a0	83 7d e0 00	 cmp	 DWORD PTR _ReCalc$246537[ebp], 0
  075a4	74 0c		 je	 SHORT $LN8@DGRecvPetI

; 3654 : 		{
; 3655 : 			gObjCalCharacter(aIndex);

  075a6	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  075a9	50		 push	 eax
  075aa	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  075af	83 c4 04	 add	 esp, 4
$LN8@DGRecvPetI:

; 3656 : 		}
; 3657 : 	}

  075b2	e9 f3 00 00 00	 jmp	 $LN17@DGRecvPetI
$LN15@DGRecvPetI:

; 3658 : 	else if ( lpMsg->InvenType == 1 )

  075b7	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  075ba	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  075be	83 f9 01	 cmp	 ecx, 1
  075c1	0f 85 e3 00 00
	00		 jne	 $LN17@DGRecvPetI

; 3659 : 	{
; 3660 : 		for ( int n=0;n<lpMsg->nCount;n++)

  075c7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$246548[ebp], 0
  075ce	eb 09		 jmp	 SHORT $LN5@DGRecvPetI
$LN4@DGRecvPetI:
  075d0	8b 45 d8	 mov	 eax, DWORD PTR _n$246548[ebp]
  075d3	83 c0 01	 add	 eax, 1
  075d6	89 45 d8	 mov	 DWORD PTR _n$246548[ebp], eax
$LN5@DGRecvPetI:
  075d9	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  075dc	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  075e0	39 4d d8	 cmp	 DWORD PTR _n$246548[ebp], ecx
  075e3	0f 8d c1 00 00
	00		 jge	 $LN17@DGRecvPetI

; 3661 : 		{
; 3662 : 
; 3663 : 			if ( gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].IsItem() )

  075e9	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  075ec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  075f2	8b 4d d8	 mov	 ecx, DWORD PTR _n$246548[ebp]
  075f5	c1 e1 04	 shl	 ecx, 4
  075f8	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  075fb	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  075ff	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07605	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0760b	03 8c 02 5c 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3676]
  07612	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  07617	85 c0		 test	 eax, eax
  07619	0f 84 86 00 00
	00		 je	 $LN2@DGRecvPetI

; 3664 : 			{
; 3665 : 				if ( gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].m_Number == pPetItemInfo[n].nSerial )

  0761f	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07622	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07628	8b 4d d8	 mov	 ecx, DWORD PTR _n$246548[ebp]
  0762b	c1 e1 04	 shl	 ecx, 4
  0762e	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  07631	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  07635	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0763b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07641	8b 84 02 5c 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3676]
  07648	8b 55 d8	 mov	 edx, DWORD PTR _n$246548[ebp]
  0764b	c1 e2 04	 shl	 edx, 4
  0764e	8b 75 f4	 mov	 esi, DWORD PTR _pPetItemInfo$[ebp]
  07651	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  07654	3b 44 16 04	 cmp	 eax, DWORD PTR [esi+edx+4]
  07658	75 4b		 jne	 SHORT $LN2@DGRecvPetI

; 3666 : 				{
; 3667 : 					gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].SetPetItemInfo(pPetItemInfo[n].Level, pPetItemInfo[n].Exp);

  0765a	8b 45 d8	 mov	 eax, DWORD PTR _n$246548[ebp]
  0765d	c1 e0 04	 shl	 eax, 4
  07660	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  07663	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  07667	52		 push	 edx
  07668	8b 45 d8	 mov	 eax, DWORD PTR _n$246548[ebp]
  0766b	c1 e0 04	 shl	 eax, 4
  0766e	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  07671	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  07676	52		 push	 edx
  07677	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0767a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07680	8b 4d d8	 mov	 ecx, DWORD PTR _n$246548[ebp]
  07683	c1 e1 04	 shl	 ecx, 4
  07686	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  07689	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0768d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07693	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07699	03 8c 02 5c 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3676]
  076a0	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo
$LN2@DGRecvPetI:

; 3668 : 				}
; 3669 : 			}
; 3670 : 		}

  076a5	e9 26 ff ff ff	 jmp	 $LN4@DGRecvPetI
$LN17@DGRecvPetI:

; 3671 : 
; 3672 : 	}
; 3673 : }

  076aa	5f		 pop	 edi
  076ab	5e		 pop	 esi
  076ac	5b		 pop	 ebx
  076ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  076b0	33 cd		 xor	 ecx, ebp
  076b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  076b7	8b e5		 mov	 esp, ebp
  076b9	5d		 pop	 ebp
  076ba	c3		 ret	 0
?DGRecvPetItemInfo@@YAXPAE@Z ENDP			; DGRecvPetItemInfo
_TEXT	ENDS
PUBLIC	??_C@_0CP@LPIJCCNE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@ ; `string'
PUBLIC	??_C@_0CP@LFNBKNNH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CP@LPIJCCNE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@
CONST	SEGMENT
??_C@_0CP@LPIJCCNE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@ DB '['
	DB	'%s][%s][PW][%d,%s]serial:[%u] Level:%d Exp:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LFNBKNNH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@
CONST	SEGMENT
??_C@_0CP@LFNBKNNH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@ DB '['
	DB	'%s][%s][PI][%d,%s]serial:[%u] Level:%d Exp:%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pMsg$246605 = -4140					; size = 5
_n$246595 = -4132					; size = 4
_n$246584 = -4128					; size = 4
_petIteminfo$ = -4124					; size = 12
_founditemcount$ = -4112				; size = 4
_lofs$ = -4108						; size = 4
_pbuffer$ = -4104					; size = 4096
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_inventype$ = 12					; size = 4
?gObjSavePetItemInfo@@YAXHH@Z PROC			; gObjSavePetItemInfo

; 3701 : {

  076c0	55		 push	 ebp
  076c1	8b ec		 mov	 ebp, esp
  076c3	b8 6c 10 00 00	 mov	 eax, 4204		; 0000106cH
  076c8	e8 00 00 00 00	 call	 __chkstk
  076cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  076d2	33 c5		 xor	 eax, ebp
  076d4	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  076d7	53		 push	 ebx
  076d8	56		 push	 esi
  076d9	57		 push	 edi

; 3702 : 	LPOBJ lpObj = &gObj[aIndex];

  076da	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  076dd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  076e3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  076e9	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3703 : 	char pbuffer[WAREHOUSE_BUFF];//Season 4.5 changed size
; 3704 : 	int lofs = sizeof(SDHP_SAVE_PETITEM_INFO);

  076ec	c7 85 f4 ef ff
	ff 05 00 00 00	 mov	 DWORD PTR _lofs$[ebp], 5

; 3705 : 	int founditemcount = 0;

  076f6	c7 85 f0 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _founditemcount$[ebp], 0

; 3706 : 	Save_PetItem_Info petIteminfo;
; 3707 : 
; 3708 : 	if ( inventype == 0 )

  07700	83 7d 0c 00	 cmp	 DWORD PTR _inventype$[ebp], 0
  07704	0f 85 b3 01 00
	00		 jne	 $LN18@gObjSavePe

; 3709 : 	{
; 3710 : 		for ( int n=0;n<INVENTORY_SIZE;n++)

  0770a	c7 85 e0 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$246584[ebp], 0
  07714	eb 0f		 jmp	 SHORT $LN17@gObjSavePe
$LN16@gObjSavePe:
  07716	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  0771c	83 c0 01	 add	 eax, 1
  0771f	89 85 e0 ef ff
	ff		 mov	 DWORD PTR _n$246584[ebp], eax
$LN17@gObjSavePe:
  07725	81 bd e0 ef ff
	ff ec 00 00 00	 cmp	 DWORD PTR _n$246584[ebp], 236 ; 000000ecH
  0772f	0f 8d 83 01 00
	00		 jge	 $LN15@gObjSavePe

; 3711 : 		{
; 3712 : 			if ( lpObj->pInventory[n].IsItem() )

  07735	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _n$246584[ebp]
  0773b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07741	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07744	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0774a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0774f	85 c0		 test	 eax, eax
  07751	0f 84 5c 01 00
	00		 je	 $LN14@gObjSavePe

; 3713 : 			{
; 3714 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  07757	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  0775d	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07763	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  07766	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0776c	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  07771	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  07776	74 25		 je	 SHORT $LN12@gObjSavePe
  07778	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  0777e	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07784	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  07787	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0778d	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  07792	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  07797	0f 85 16 01 00
	00		 jne	 $LN14@gObjSavePe
$LN12@gObjSavePe:

; 3715 : 				{
; 3716 : 					if ( lpObj->pInventory[n].m_IsLoadPetItemInfo != FALSE )

  0779d	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  077a3	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  077a9	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  077ac	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  077b2	83 bc 02 b8 00
	00 00 00	 cmp	 DWORD PTR [edx+eax+184], 0
  077ba	0f 84 f3 00 00
	00		 je	 $LN14@gObjSavePe

; 3717 : 					{
; 3718 : 						founditemcount++;

  077c0	8b 85 f0 ef ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  077c6	83 c0 01	 add	 eax, 1
  077c9	89 85 f0 ef ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 3719 : 						petIteminfo.nSerial = lpObj->pInventory[n].m_Number;

  077cf	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  077d5	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  077db	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  077de	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  077e4	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  077e7	89 85 e4 ef ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp], eax

; 3720 : 						petIteminfo.Level = lpObj->pInventory[n].m_PetItem_Level;

  077ed	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  077f3	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  077f9	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  077fc	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  07802	8a 84 02 bc 00
	00 00		 mov	 al, BYTE PTR [edx+eax+188]
  07809	88 85 e8 ef ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp+4], al

; 3721 : 						petIteminfo.Exp = lpObj->pInventory[n].m_PetItem_Exp;

  0780f	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _n$246584[ebp]
  07815	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0781b	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0781e	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  07824	8b 84 02 c0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+192]
  0782b	89 85 ec ef ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+8], eax

; 3722 : 
; 3723 : 						LogAddTD("[%s][%s][PI][%d,%s]serial:[%u] Level:%d Exp:%d", lpObj->AccountID, lpObj->Name, n, lpObj->pInventory[n].GetName(),petIteminfo.nSerial, petIteminfo.Level, petIteminfo.Exp);

  07831	8b 85 ec ef ff
	ff		 mov	 eax, DWORD PTR _petIteminfo$[ebp+8]
  07837	50		 push	 eax
  07838	0f b6 8d e8 ef
	ff ff		 movzx	 ecx, BYTE PTR _petIteminfo$[ebp+4]
  0783f	51		 push	 ecx
  07840	8b 95 e4 ef ff
	ff		 mov	 edx, DWORD PTR _petIteminfo$[ebp]
  07846	52		 push	 edx
  07847	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _n$246584[ebp]
  0784d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07853	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07856	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0785c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  07861	50		 push	 eax
  07862	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _n$246584[ebp]
  07868	51		 push	 ecx
  07869	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0786c	83 c2 77	 add	 edx, 119		; 00000077H
  0786f	52		 push	 edx
  07870	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07873	83 c0 6c	 add	 eax, 108		; 0000006cH
  07876	50		 push	 eax
  07877	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@LFNBKNNH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@
  0787c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  07882	83 c4 20	 add	 esp, 32			; 00000020H

; 3724 : 
; 3725 : 						memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  07885	6a 0c		 push	 12			; 0000000cH
  07887	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  0788d	50		 push	 eax
  0788e	8b 8d f4 ef ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  07894	8d 94 0d f8 ef
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  0789b	52		 push	 edx
  0789c	e8 00 00 00 00	 call	 _memcpy
  078a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3726 : 						lofs += sizeof(petIteminfo);

  078a4	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  078aa	83 c0 0c	 add	 eax, 12			; 0000000cH
  078ad	89 85 f4 ef ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN14@gObjSavePe:

; 3727 : 					}
; 3728 : 				}
; 3729 : 			}
; 3730 : 		}

  078b3	e9 5e fe ff ff	 jmp	 $LN16@gObjSavePe
$LN15@gObjSavePe:

; 3731 : 	}
; 3732 : 	else if ( inventype == 1 )

  078b8	e9 b8 01 00 00	 jmp	 $LN10@gObjSavePe
$LN18@gObjSavePe:
  078bd	83 7d 0c 01	 cmp	 DWORD PTR _inventype$[ebp], 1
  078c1	0f 85 ae 01 00
	00		 jne	 $LN10@gObjSavePe

; 3733 : 	{
; 3734 : 		for ( int n=0;n<WAREHOUSE_SIZE;n++)

  078c7	c7 85 dc ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$246595[ebp], 0
  078d1	eb 0f		 jmp	 SHORT $LN8@gObjSavePe
$LN7@gObjSavePe:
  078d3	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  078d9	83 c0 01	 add	 eax, 1
  078dc	89 85 dc ef ff
	ff		 mov	 DWORD PTR _n$246595[ebp], eax
$LN8@gObjSavePe:
  078e2	81 bd dc ef ff
	ff f0 00 00 00	 cmp	 DWORD PTR _n$246595[ebp], 240 ; 000000f0H
  078ec	0f 8d 83 01 00
	00		 jge	 $LN10@gObjSavePe

; 3735 : 		{
; 3736 : 			if ( lpObj->pWarehouse[n].IsItem() )

  078f2	8b 8d dc ef ff
	ff		 mov	 ecx, DWORD PTR _n$246595[ebp]
  078f8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  078fe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07901	03 88 5c 0e 00
	00		 add	 ecx, DWORD PTR [eax+3676]
  07907	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0790c	85 c0		 test	 eax, eax
  0790e	0f 84 5c 01 00
	00		 je	 $LN5@gObjSavePe

; 3737 : 			{
; 3738 : 				if ( lpObj->pWarehouse[n].m_Type == ITEMGET(13,4) || lpObj->pWarehouse[n].m_Type == ITEMGET(13,5) )

  07914	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  0791a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07920	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  07923	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  07929	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0792e	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  07933	74 25		 je	 SHORT $LN3@gObjSavePe
  07935	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  0793b	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07941	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  07944	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  0794a	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0794f	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  07954	0f 85 16 01 00
	00		 jne	 $LN5@gObjSavePe
$LN3@gObjSavePe:

; 3739 : 				{
; 3740 : 					if ( lpObj->pWarehouse[n].m_IsLoadPetItemInfo != FALSE )

  0795a	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  07960	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07966	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  07969	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  0796f	83 bc 02 b8 00
	00 00 00	 cmp	 DWORD PTR [edx+eax+184], 0
  07977	0f 84 f3 00 00
	00		 je	 $LN5@gObjSavePe

; 3741 : 					{
; 3742 : 						founditemcount++;

  0797d	8b 85 f0 ef ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  07983	83 c0 01	 add	 eax, 1
  07986	89 85 f0 ef ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 3743 : 						petIteminfo.nSerial = lpObj->pWarehouse[n].m_Number;

  0798c	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  07992	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  07998	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0799b	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  079a1	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  079a4	89 85 e4 ef ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp], eax

; 3744 : 						petIteminfo.Level = lpObj->pWarehouse[n].m_PetItem_Level;

  079aa	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  079b0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  079b6	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  079b9	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  079bf	8a 84 02 bc 00
	00 00		 mov	 al, BYTE PTR [edx+eax+188]
  079c6	88 85 e8 ef ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp+4], al

; 3745 : 						petIteminfo.Exp = lpObj->pWarehouse[n].m_PetItem_Exp;

  079cc	8b 85 dc ef ff
	ff		 mov	 eax, DWORD PTR _n$246595[ebp]
  079d2	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  079d8	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  079db	8b 91 5c 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3676]
  079e1	8b 84 02 c0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+192]
  079e8	89 85 ec ef ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+8], eax

; 3746 : 
; 3747 : 						LogAddTD("[%s][%s][PW][%d,%s]serial:[%u] Level:%d Exp:%d", lpObj->AccountID, lpObj->Name, n, lpObj->pWarehouse[n].GetName(),petIteminfo.nSerial, petIteminfo.Level, petIteminfo.Exp);

  079ee	8b 85 ec ef ff
	ff		 mov	 eax, DWORD PTR _petIteminfo$[ebp+8]
  079f4	50		 push	 eax
  079f5	0f b6 8d e8 ef
	ff ff		 movzx	 ecx, BYTE PTR _petIteminfo$[ebp+4]
  079fc	51		 push	 ecx
  079fd	8b 95 e4 ef ff
	ff		 mov	 edx, DWORD PTR _petIteminfo$[ebp]
  07a03	52		 push	 edx
  07a04	8b 8d dc ef ff
	ff		 mov	 ecx, DWORD PTR _n$246595[ebp]
  07a0a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07a10	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07a13	03 88 5c 0e 00
	00		 add	 ecx, DWORD PTR [eax+3676]
  07a19	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  07a1e	50		 push	 eax
  07a1f	8b 8d dc ef ff
	ff		 mov	 ecx, DWORD PTR _n$246595[ebp]
  07a25	51		 push	 ecx
  07a26	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  07a29	83 c2 77	 add	 edx, 119		; 00000077H
  07a2c	52		 push	 edx
  07a2d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  07a30	83 c0 6c	 add	 eax, 108		; 0000006cH
  07a33	50		 push	 eax
  07a34	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@LPIJCCNE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFu?$FN?5L@
  07a39	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  07a3f	83 c4 20	 add	 esp, 32			; 00000020H

; 3748 : 
; 3749 : 						memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  07a42	6a 0c		 push	 12			; 0000000cH
  07a44	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  07a4a	50		 push	 eax
  07a4b	8b 8d f4 ef ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  07a51	8d 94 0d f8 ef
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  07a58	52		 push	 edx
  07a59	e8 00 00 00 00	 call	 _memcpy
  07a5e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3750 : 						lofs += sizeof(petIteminfo);

  07a61	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  07a67	83 c0 0c	 add	 eax, 12			; 0000000cH
  07a6a	89 85 f4 ef ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN5@gObjSavePe:

; 3751 : 					}
; 3752 : 				}
; 3753 : 			}
; 3754 : 		}

  07a70	e9 5e fe ff ff	 jmp	 $LN7@gObjSavePe
$LN10@gObjSavePe:

; 3755 : 	}
; 3756 : 
; 3757 : 	if ( founditemcount )

  07a75	83 bd f0 ef ff
	ff 00		 cmp	 DWORD PTR _founditemcount$[ebp], 0
  07a7c	74 5d		 je	 SHORT $LN19@gObjSavePe

; 3758 : 	{
; 3759 : 		SDHP_SAVE_PETITEM_INFO pMsg;
; 3760 : 
; 3761 : 		pMsg.h.set((LPBYTE)&pMsg, 0x57, lofs+sizeof(pMsg));

  07a7e	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  07a84	83 c0 05	 add	 eax, 5
  07a87	50		 push	 eax
  07a88	6a 57		 push	 87			; 00000057H
  07a8a	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _pMsg$246605[ebp]
  07a90	51		 push	 ecx
  07a91	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _pMsg$246605[ebp]
  07a97	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD@@QAEXPAEEH@Z ; PWMSG_HEAD::set

; 3762 : 		pMsg.nCount = founditemcount;

  07a9c	8a 85 f0 ef ff
	ff		 mov	 al, BYTE PTR _founditemcount$[ebp]
  07aa2	88 85 d8 ef ff
	ff		 mov	 BYTE PTR _pMsg$246605[ebp+4], al

; 3763 : 		memcpy(pbuffer, &pMsg, sizeof(pMsg));

  07aa8	6a 05		 push	 5
  07aaa	8d 85 d4 ef ff
	ff		 lea	 eax, DWORD PTR _pMsg$246605[ebp]
  07ab0	50		 push	 eax
  07ab1	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  07ab7	51		 push	 ecx
  07ab8	e8 00 00 00 00	 call	 _memcpy
  07abd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3764 : 
; 3765 : 		cDBSMng.Send(pbuffer, lofs+sizeof(pMsg));

  07ac0	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  07ac6	83 c0 05	 add	 eax, 5
  07ac9	50		 push	 eax
  07aca	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  07ad0	51		 push	 ecx
  07ad1	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07ad6	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN19@gObjSavePe:

; 3766 : 	}
; 3767 : }

  07adb	5f		 pop	 edi
  07adc	5e		 pop	 esi
  07add	5b		 pop	 ebx
  07ade	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07ae1	33 cd		 xor	 ecx, ebp
  07ae3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07ae8	8b e5		 mov	 esp, ebp
  07aea	5d		 pop	 ebp
  07aeb	c3		 ret	 0
?gObjSavePetItemInfo@@YAXHH@Z ENDP			; gObjSavePetItemInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleTotalInfo@@YAXHH@Z		; GS_GDReqCastleTotalInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleEventCycle$ = 12				; size = 4
?GS_GDReqCastleTotalInfo@@YAXHH@Z PROC			; GS_GDReqCastleTotalInfo

; 3785 : {

  07af0	55		 push	 ebp
  07af1	8b ec		 mov	 ebp, esp
  07af3	83 ec 50	 sub	 esp, 80			; 00000050H
  07af6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07afb	33 c5		 xor	 eax, ebp
  07afd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07b00	53		 push	 ebx
  07b01	56		 push	 esi
  07b02	57		 push	 edi

; 3786 : 	if ( iMapSvrGroup < 0 )

  07b03	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07b07	7d 02		 jge	 SHORT $LN1@GS_GDReqCa

; 3787 : 	{
; 3788 : 		return;

  07b09	eb 36		 jmp	 SHORT $LN2@GS_GDReqCa
$LN1@GS_GDReqCa:

; 3789 : 	}
; 3790 : 
; 3791 : 	CSP_REQ_CASTLEDATA pMsg;
; 3792 : 
; 3793 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x00, sizeof(CSP_REQ_CASTLEDATA));

  07b0b	6a 0c		 push	 12			; 0000000cH
  07b0d	6a 00		 push	 0
  07b0f	68 80 00 00 00	 push	 128			; 00000080H
  07b14	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07b17	50		 push	 eax
  07b18	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07b1b	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 3794 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07b20	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07b24	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3795 : 	pMsg.iCastleEventCycle = iCastleEventCycle;

  07b28	8b 45 0c	 mov	 eax, DWORD PTR _iCastleEventCycle$[ebp]
  07b2b	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 3796 : 
; 3797 : 	::cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07b2e	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07b32	50		 push	 eax
  07b33	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07b36	51		 push	 ecx
  07b37	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07b3c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqCa:

; 3798 : }

  07b41	5f		 pop	 edi
  07b42	5e		 pop	 esi
  07b43	5b		 pop	 ebx
  07b44	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07b47	33 cd		 xor	 ecx, ebp
  07b49	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07b4e	8b e5		 mov	 esp, ebp
  07b50	5d		 pop	 ebp
  07b51	c3		 ret	 0
?GS_GDReqCastleTotalInfo@@YAXHH@Z ENDP			; GS_GDReqCastleTotalInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqOwnerGuildMaster@@YAXHH@Z		; GS_GDReqOwnerGuildMaster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -84						; size = 4
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqOwnerGuildMaster@@YAXHH@Z PROC			; GS_GDReqOwnerGuildMaster

; 3816 : {

  07b60	55		 push	 ebp
  07b61	8b ec		 mov	 ebp, esp
  07b63	83 ec 54	 sub	 esp, 84			; 00000054H
  07b66	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07b6b	33 c5		 xor	 eax, ebp
  07b6d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07b70	53		 push	 ebx
  07b71	56		 push	 esi
  07b72	57		 push	 edi

; 3817 : 	if ( iMapSvrGroup < 0 )

  07b73	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07b77	7d 02		 jge	 SHORT $LN2@GS_GDReqOw

; 3818 : 	{
; 3819 : 		return;

  07b79	eb 5c		 jmp	 SHORT $LN3@GS_GDReqOw
$LN2@GS_GDReqOw:

; 3820 : 	}
; 3821 : 
; 3822 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07b7b	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07b7f	7d 09		 jge	 SHORT $LN5@GS_GDReqOw
  07b81	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07b88	eb 0f		 jmp	 SHORT $LN6@GS_GDReqOw
$LN5@GS_GDReqOw:
  07b8a	33 c0		 xor	 eax, eax
  07b8c	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07b93	0f 9e c0	 setle	 al
  07b96	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqOw:
  07b99	83 7d ac 00	 cmp	 DWORD PTR tv68[ebp], 0
  07b9d	75 02		 jne	 SHORT $LN1@GS_GDReqOw

; 3823 : 	{
; 3824 : 		return;

  07b9f	eb 36		 jmp	 SHORT $LN3@GS_GDReqOw
$LN1@GS_GDReqOw:

; 3825 : 	}
; 3826 : 
; 3827 : 
; 3828 : 	CSP_REQ_OWNERGUILDMASTER pMsg;
; 3829 : 
; 3830 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x01, sizeof(CSP_REQ_OWNERGUILDMASTER));

  07ba1	6a 0c		 push	 12			; 0000000cH
  07ba3	6a 01		 push	 1
  07ba5	68 80 00 00 00	 push	 128			; 00000080H
  07baa	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07bad	50		 push	 eax
  07bae	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07bb1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 3831 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07bb6	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07bba	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3832 : 	pMsg.iIndex = aIndex;

  07bbe	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07bc1	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 3833 : 
; 3834 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07bc4	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07bc8	50		 push	 eax
  07bc9	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07bcc	51		 push	 ecx
  07bcd	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07bd2	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqOw:

; 3835 : }

  07bd7	5f		 pop	 edi
  07bd8	5e		 pop	 esi
  07bd9	5b		 pop	 ebx
  07bda	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07bdd	33 cd		 xor	 ecx, ebp
  07bdf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07be4	8b e5		 mov	 esp, ebp
  07be6	5d		 pop	 ebp
  07be7	c3		 ret	 0
?GS_GDReqOwnerGuildMaster@@YAXHH@Z ENDP			; GS_GDReqOwnerGuildMaster
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z	; GS_GDReqCastleNpcBuy
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -116						; size = 4
_pMsg$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcDfLevel$ = 24					; size = 4
_iNpcRgLevel$ = 28					; size = 4
_iNpcMaxHP$ = 32					; size = 4
_iNpcHP$ = 36						; size = 4
_btNpcX$ = 40						; size = 1
_btNpcY$ = 44						; size = 1
_btNpcDIR$ = 48						; size = 1
_iBuyCost$ = 52						; size = 4
?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z PROC		; GS_GDReqCastleNpcBuy

; 3863 : {

  07bf0	55		 push	 ebp
  07bf1	8b ec		 mov	 ebp, esp
  07bf3	83 ec 74	 sub	 esp, 116		; 00000074H
  07bf6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07bfb	33 c5		 xor	 eax, ebp
  07bfd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07c00	53		 push	 ebx
  07c01	56		 push	 esi
  07c02	57		 push	 edi

; 3864 : 	if ( iMapSvrGroup < 0 )

  07c03	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07c07	7d 05		 jge	 SHORT $LN2@GS_GDReqCa@2

; 3865 : 	{
; 3866 : 		return;

  07c09	e9 98 00 00 00	 jmp	 $LN3@GS_GDReqCa@2
$LN2@GS_GDReqCa@2:

; 3867 : 	}
; 3868 : 
; 3869 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07c0e	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07c12	7d 09		 jge	 SHORT $LN5@GS_GDReqCa@2
  07c14	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07c1b	eb 0f		 jmp	 SHORT $LN6@GS_GDReqCa@2
$LN5@GS_GDReqCa@2:
  07c1d	33 c0		 xor	 eax, eax
  07c1f	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07c26	0f 9e c0	 setle	 al
  07c29	89 45 8c	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqCa@2:
  07c2c	83 7d 8c 00	 cmp	 DWORD PTR tv68[ebp], 0
  07c30	75 02		 jne	 SHORT $LN1@GS_GDReqCa@2

; 3870 : 	{
; 3871 : 		return;

  07c32	eb 72		 jmp	 SHORT $LN3@GS_GDReqCa@2
$LN1@GS_GDReqCa@2:

; 3872 : 	}
; 3873 : 
; 3874 : 
; 3875 : 	CSP_REQ_NPCBUY pMsg;
; 3876 : 
; 3877 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x03, sizeof(CSP_REQ_NPCBUY));

  07c34	6a 2c		 push	 44			; 0000002cH
  07c36	6a 03		 push	 3
  07c38	68 80 00 00 00	 push	 128			; 00000080H
  07c3d	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07c40	50		 push	 eax
  07c41	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07c44	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 3878 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07c49	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07c4d	66 89 45 d4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3879 : 	pMsg.iIndex = aIndex;

  07c51	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07c54	89 45 d8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 3880 : 	pMsg.iNpcNumber = iNpcNumber;

  07c57	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  07c5a	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 3881 : 	pMsg.iNpcIndex = iNpcIndex;

  07c5d	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  07c60	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 3882 : 	pMsg.iNpcDfLevel = iNpcDfLevel;

  07c63	8b 45 18	 mov	 eax, DWORD PTR _iNpcDfLevel$[ebp]
  07c66	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 3883 : 	pMsg.iNpcRgLevel = iNpcRgLevel;

  07c69	8b 45 1c	 mov	 eax, DWORD PTR _iNpcRgLevel$[ebp]
  07c6c	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 3884 : 	pMsg.iNpcMaxHp = iNpcMaxHP;

  07c6f	8b 45 20	 mov	 eax, DWORD PTR _iNpcMaxHP$[ebp]
  07c72	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 3885 : 	pMsg.iNpcHp = iNpcHP;

  07c75	8b 45 24	 mov	 eax, DWORD PTR _iNpcHP$[ebp]
  07c78	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+32], eax

; 3886 : 	pMsg.btNpcX = btNpcX;

  07c7b	8a 45 28	 mov	 al, BYTE PTR _btNpcX$[ebp]
  07c7e	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+36], al

; 3887 : 	pMsg.btNpcY = btNpcY;

  07c81	8a 45 2c	 mov	 al, BYTE PTR _btNpcY$[ebp]
  07c84	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+37], al

; 3888 : 	pMsg.btNpcDIR = btNpcDIR;

  07c87	8a 45 30	 mov	 al, BYTE PTR _btNpcDIR$[ebp]
  07c8a	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+38], al

; 3889 : 	pMsg.iBuyCost = iBuyCost;

  07c8d	8b 45 34	 mov	 eax, DWORD PTR _iBuyCost$[ebp]
  07c90	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+40], eax

; 3890 : 
; 3891 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07c93	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07c97	50		 push	 eax
  07c98	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07c9b	51		 push	 ecx
  07c9c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07ca1	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqCa@2:

; 3892 : }

  07ca6	5f		 pop	 edi
  07ca7	5e		 pop	 esi
  07ca8	5b		 pop	 ebx
  07ca9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07cac	33 cd		 xor	 ecx, ebp
  07cae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07cb3	8b e5		 mov	 esp, ebp
  07cb5	5d		 pop	 ebp
  07cb6	c3		 ret	 0
?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z ENDP		; GS_GDReqCastleNpcBuy
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z		; GS_GDReqCastleNpcRepair
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -96						; size = 4
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iRepairCost$ = 24					; size = 4
?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z PROC		; GS_GDReqCastleNpcRepair

; 3913 : {

  07cc0	55		 push	 ebp
  07cc1	8b ec		 mov	 ebp, esp
  07cc3	83 ec 60	 sub	 esp, 96			; 00000060H
  07cc6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07ccb	33 c5		 xor	 eax, ebp
  07ccd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07cd0	53		 push	 ebx
  07cd1	56		 push	 esi
  07cd2	57		 push	 edi

; 3914 : 	if ( iMapSvrGroup < 0 )

  07cd3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07cd7	7d 02		 jge	 SHORT $LN2@GS_GDReqCa@3

; 3915 : 	{
; 3916 : 		return;

  07cd9	eb 6e		 jmp	 SHORT $LN3@GS_GDReqCa@3
$LN2@GS_GDReqCa@3:

; 3917 : 	}
; 3918 : 
; 3919 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07cdb	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07cdf	7d 09		 jge	 SHORT $LN5@GS_GDReqCa@3
  07ce1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07ce8	eb 0f		 jmp	 SHORT $LN6@GS_GDReqCa@3
$LN5@GS_GDReqCa@3:
  07cea	33 c0		 xor	 eax, eax
  07cec	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07cf3	0f 9e c0	 setle	 al
  07cf6	89 45 a0	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqCa@3:
  07cf9	83 7d a0 00	 cmp	 DWORD PTR tv68[ebp], 0
  07cfd	75 02		 jne	 SHORT $LN1@GS_GDReqCa@3

; 3920 : 	{
; 3921 : 		return;

  07cff	eb 48		 jmp	 SHORT $LN3@GS_GDReqCa@3
$LN1@GS_GDReqCa@3:

; 3922 : 	}
; 3923 : 
; 3924 : 
; 3925 : 	CSP_REQ_NPCREPAIR pMsg;
; 3926 : 
; 3927 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x04, sizeof(CSP_REQ_NPCREPAIR));

  07d01	6a 18		 push	 24			; 00000018H
  07d03	6a 04		 push	 4
  07d05	68 80 00 00 00	 push	 128			; 00000080H
  07d0a	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07d0d	50		 push	 eax
  07d0e	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07d11	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 3928 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07d16	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07d1a	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3929 : 	pMsg.iIndex = aIndex;

  07d1e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07d21	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 3930 : 	pMsg.iNpcNumber = iNpcNumber;

  07d24	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  07d27	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 3931 : 	pMsg.iNpcIndex = iNpcIndex;

  07d2a	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  07d2d	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 3932 : 	pMsg.iRepairCost = iRepairCost;

  07d30	8b 45 18	 mov	 eax, DWORD PTR _iRepairCost$[ebp]
  07d33	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 3933 : 
; 3934 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07d36	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07d3a	50		 push	 eax
  07d3b	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07d3e	51		 push	 ecx
  07d3f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07d44	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqCa@3:

; 3935 : }

  07d49	5f		 pop	 edi
  07d4a	5e		 pop	 esi
  07d4b	5b		 pop	 ebx
  07d4c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07d4f	33 cd		 xor	 ecx, ebp
  07d51	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07d56	8b e5		 mov	 esp, ebp
  07d58	5d		 pop	 ebp
  07d59	c3		 ret	 0
?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z ENDP		; GS_GDReqCastleNpcRepair
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z		; GS_GDReqCastleNpcUpgrade
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -104						; size = 4
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcUpType$ = 24					; size = 4
_iNpcUpValue$ = 28					; size = 4
_iNpcUpIndex$ = 32					; size = 4
?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z PROC		; GS_GDReqCastleNpcUpgrade

; 3957 : {

  07d60	55		 push	 ebp
  07d61	8b ec		 mov	 ebp, esp
  07d63	83 ec 68	 sub	 esp, 104		; 00000068H
  07d66	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07d6b	33 c5		 xor	 eax, ebp
  07d6d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07d70	53		 push	 ebx
  07d71	56		 push	 esi
  07d72	57		 push	 edi

; 3958 : 	if ( iMapSvrGroup < 0 )

  07d73	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07d77	7d 02		 jge	 SHORT $LN2@GS_GDReqCa@4

; 3959 : 	{
; 3960 : 		return;

  07d79	eb 7a		 jmp	 SHORT $LN3@GS_GDReqCa@4
$LN2@GS_GDReqCa@4:

; 3961 : 	}
; 3962 : 
; 3963 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07d7b	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07d7f	7d 09		 jge	 SHORT $LN5@GS_GDReqCa@4
  07d81	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07d88	eb 0f		 jmp	 SHORT $LN6@GS_GDReqCa@4
$LN5@GS_GDReqCa@4:
  07d8a	33 c0		 xor	 eax, eax
  07d8c	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07d93	0f 9e c0	 setle	 al
  07d96	89 45 98	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqCa@4:
  07d99	83 7d 98 00	 cmp	 DWORD PTR tv68[ebp], 0
  07d9d	75 02		 jne	 SHORT $LN1@GS_GDReqCa@4

; 3964 : 	{
; 3965 : 		return;

  07d9f	eb 54		 jmp	 SHORT $LN3@GS_GDReqCa@4
$LN1@GS_GDReqCa@4:

; 3966 : 	}
; 3967 : 
; 3968 : 
; 3969 : 	CSP_REQ_NPCUPGRADE pMsg;
; 3970 : 
; 3971 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x05, sizeof(CSP_REQ_NPCUPGRADE));

  07da1	6a 20		 push	 32			; 00000020H
  07da3	6a 05		 push	 5
  07da5	68 80 00 00 00	 push	 128			; 00000080H
  07daa	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07dad	50		 push	 eax
  07dae	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07db1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 3972 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07db6	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07dba	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3973 : 	pMsg.iIndex = aIndex;

  07dbe	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07dc1	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 3974 : 	pMsg.iNpcNumber = iNpcNumber;

  07dc4	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  07dc7	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 3975 : 	pMsg.iNpcIndex = iNpcIndex;

  07dca	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  07dcd	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 3976 : 	pMsg.iNpcUpType = iNpcUpType;

  07dd0	8b 45 18	 mov	 eax, DWORD PTR _iNpcUpType$[ebp]
  07dd3	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 3977 : 	pMsg.iNpcUpValue = iNpcUpValue;

  07dd6	8b 45 1c	 mov	 eax, DWORD PTR _iNpcUpValue$[ebp]
  07dd9	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 3978 : 	pMsg.iNpcUpIndex = iNpcUpIndex;

  07ddc	8b 45 20	 mov	 eax, DWORD PTR _iNpcUpIndex$[ebp]
  07ddf	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 3979 : 
; 3980 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07de2	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07de6	50		 push	 eax
  07de7	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07dea	51		 push	 ecx
  07deb	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07df0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqCa@4:

; 3981 : }

  07df5	5f		 pop	 edi
  07df6	5e		 pop	 esi
  07df7	5b		 pop	 ebx
  07df8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07dfb	33 cd		 xor	 ecx, ebp
  07dfd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07e02	8b e5		 mov	 esp, ebp
  07e04	5d		 pop	 ebp
  07e05	c3		 ret	 0
?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z ENDP		; GS_GDReqCastleNpcUpgrade
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqTaxInfo@@YAXHH@Z			; GS_GDReqTaxInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -84						; size = 4
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqTaxInfo@@YAXHH@Z PROC				; GS_GDReqTaxInfo

; 3999 : {

  07e10	55		 push	 ebp
  07e11	8b ec		 mov	 ebp, esp
  07e13	83 ec 54	 sub	 esp, 84			; 00000054H
  07e16	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07e1b	33 c5		 xor	 eax, ebp
  07e1d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07e20	53		 push	 ebx
  07e21	56		 push	 esi
  07e22	57		 push	 edi

; 4000 : 	if ( iMapSvrGroup < 0 )

  07e23	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07e27	7d 02		 jge	 SHORT $LN2@GS_GDReqTa

; 4001 : 	{
; 4002 : 		return;

  07e29	eb 5c		 jmp	 SHORT $LN3@GS_GDReqTa
$LN2@GS_GDReqTa:

; 4003 : 	}
; 4004 : 
; 4005 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07e2b	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07e2f	7d 09		 jge	 SHORT $LN5@GS_GDReqTa
  07e31	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07e38	eb 0f		 jmp	 SHORT $LN6@GS_GDReqTa
$LN5@GS_GDReqTa:
  07e3a	33 c0		 xor	 eax, eax
  07e3c	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07e43	0f 9e c0	 setle	 al
  07e46	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqTa:
  07e49	83 7d ac 00	 cmp	 DWORD PTR tv68[ebp], 0
  07e4d	75 02		 jne	 SHORT $LN1@GS_GDReqTa

; 4006 : 	{
; 4007 : 		return;

  07e4f	eb 36		 jmp	 SHORT $LN3@GS_GDReqTa
$LN1@GS_GDReqTa:

; 4008 : 	}
; 4009 : 
; 4010 : 
; 4011 : 	CSP_REQ_TAXINFO pMsg;
; 4012 : 
; 4013 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x06, sizeof(CSP_REQ_TAXINFO));

  07e51	6a 0c		 push	 12			; 0000000cH
  07e53	6a 06		 push	 6
  07e55	68 80 00 00 00	 push	 128			; 00000080H
  07e5a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07e5d	50		 push	 eax
  07e5e	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07e61	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4014 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07e66	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07e6a	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4015 : 	pMsg.iIndex = aIndex;

  07e6e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07e71	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4016 : 
; 4017 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07e74	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07e78	50		 push	 eax
  07e79	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07e7c	51		 push	 ecx
  07e7d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07e82	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqTa:

; 4018 : }

  07e87	5f		 pop	 edi
  07e88	5e		 pop	 esi
  07e89	5b		 pop	 ebx
  07e8a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07e8d	33 cd		 xor	 ecx, ebp
  07e8f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07e94	8b e5		 mov	 esp, ebp
  07e96	5d		 pop	 ebp
  07e97	c3		 ret	 0
?GS_GDReqTaxInfo@@YAXHH@Z ENDP				; GS_GDReqTaxInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqTaxRateChange@@YAXHHHH@Z		; GS_GDReqTaxRateChange
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -92						; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iTaxType$ = 16						; size = 4
_iTaxRate$ = 20						; size = 4
?GS_GDReqTaxRateChange@@YAXHHHH@Z PROC			; GS_GDReqTaxRateChange

; 4039 : {

  07ea0	55		 push	 ebp
  07ea1	8b ec		 mov	 ebp, esp
  07ea3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  07ea6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07eab	33 c5		 xor	 eax, ebp
  07ead	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07eb0	53		 push	 ebx
  07eb1	56		 push	 esi
  07eb2	57		 push	 edi

; 4040 : 	if ( iMapSvrGroup < 0 )

  07eb3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07eb7	7d 02		 jge	 SHORT $LN2@GS_GDReqTa@2

; 4041 : 	{
; 4042 : 		return;

  07eb9	eb 68		 jmp	 SHORT $LN3@GS_GDReqTa@2
$LN2@GS_GDReqTa@2:

; 4043 : 	}
; 4044 : 
; 4045 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07ebb	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07ebf	7d 09		 jge	 SHORT $LN5@GS_GDReqTa@2
  07ec1	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07ec8	eb 0f		 jmp	 SHORT $LN6@GS_GDReqTa@2
$LN5@GS_GDReqTa@2:
  07eca	33 c0		 xor	 eax, eax
  07ecc	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07ed3	0f 9e c0	 setle	 al
  07ed6	89 45 a4	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqTa@2:
  07ed9	83 7d a4 00	 cmp	 DWORD PTR tv68[ebp], 0
  07edd	75 02		 jne	 SHORT $LN1@GS_GDReqTa@2

; 4046 : 	{
; 4047 : 		return;

  07edf	eb 42		 jmp	 SHORT $LN3@GS_GDReqTa@2
$LN1@GS_GDReqTa@2:

; 4048 : 	}
; 4049 : 
; 4050 : 
; 4051 : 	CSP_REQ_TAXRATECHANGE pMsg;
; 4052 : 
; 4053 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x07, sizeof(CSP_REQ_TAXRATECHANGE));

  07ee1	6a 14		 push	 20			; 00000014H
  07ee3	6a 07		 push	 7
  07ee5	68 80 00 00 00	 push	 128			; 00000080H
  07eea	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07eed	50		 push	 eax
  07eee	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07ef1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4054 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07ef6	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07efa	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4055 : 	pMsg.iIndex = aIndex;

  07efe	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07f01	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4056 : 	pMsg.iTaxRate = iTaxRate; 

  07f04	8b 45 14	 mov	 eax, DWORD PTR _iTaxRate$[ebp]
  07f07	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 4057 : 	pMsg.iTaxKind = iTaxType;

  07f0a	8b 45 10	 mov	 eax, DWORD PTR _iTaxType$[ebp]
  07f0d	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4058 : 	
; 4059 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07f10	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07f14	50		 push	 eax
  07f15	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07f18	51		 push	 ecx
  07f19	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07f1e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqTa@2:

; 4060 : }

  07f23	5f		 pop	 edi
  07f24	5e		 pop	 esi
  07f25	5b		 pop	 ebx
  07f26	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07f29	33 cd		 xor	 ecx, ebp
  07f2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07f30	8b e5		 mov	 esp, ebp
  07f32	5d		 pop	 ebp
  07f33	c3		 ret	 0
?GS_GDReqTaxRateChange@@YAXHHHH@Z ENDP			; GS_GDReqTaxRateChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleMoneyChange@@YAXHHH@Z		; GS_GDReqCastleMoneyChange
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -88						; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iMoneyChange$ = 16					; size = 4
?GS_GDReqCastleMoneyChange@@YAXHHH@Z PROC		; GS_GDReqCastleMoneyChange

; 4078 : {

  07f40	55		 push	 ebp
  07f41	8b ec		 mov	 ebp, esp
  07f43	83 ec 58	 sub	 esp, 88			; 00000058H
  07f46	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07f4b	33 c5		 xor	 eax, ebp
  07f4d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07f50	53		 push	 ebx
  07f51	56		 push	 esi
  07f52	57		 push	 edi

; 4079 : 	if ( iMapSvrGroup < 0 )

  07f53	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07f57	7d 02		 jge	 SHORT $LN2@GS_GDReqCa@5

; 4080 : 	{
; 4081 : 		return;

  07f59	eb 62		 jmp	 SHORT $LN3@GS_GDReqCa@5
$LN2@GS_GDReqCa@5:

; 4082 : 	}
; 4083 : 
; 4084 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  07f5b	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  07f5f	7d 09		 jge	 SHORT $LN5@GS_GDReqCa@5
  07f61	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  07f68	eb 0f		 jmp	 SHORT $LN6@GS_GDReqCa@5
$LN5@GS_GDReqCa@5:
  07f6a	33 c0		 xor	 eax, eax
  07f6c	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  07f73	0f 9e c0	 setle	 al
  07f76	89 45 a8	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqCa@5:
  07f79	83 7d a8 00	 cmp	 DWORD PTR tv68[ebp], 0
  07f7d	75 02		 jne	 SHORT $LN1@GS_GDReqCa@5

; 4085 : 	{
; 4086 : 		return;

  07f7f	eb 3c		 jmp	 SHORT $LN3@GS_GDReqCa@5
$LN1@GS_GDReqCa@5:

; 4087 : 	}
; 4088 : 
; 4089 : 
; 4090 : 	CSP_REQ_MONEYCHANGE pMsg;
; 4091 : 
; 4092 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x08, sizeof(CSP_REQ_MONEYCHANGE));

  07f81	6a 10		 push	 16			; 00000010H
  07f83	6a 08		 push	 8
  07f85	68 80 00 00 00	 push	 128			; 00000080H
  07f8a	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07f8d	50		 push	 eax
  07f8e	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07f91	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4093 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  07f96	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  07f9a	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4094 : 	pMsg.iIndex = aIndex;

  07f9e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  07fa1	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4095 : 	pMsg.iMoneyChanged = iMoneyChange;

  07fa4	8b 45 10	 mov	 eax, DWORD PTR _iMoneyChange$[ebp]
  07fa7	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4096 : 	
; 4097 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  07faa	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  07fae	50		 push	 eax
  07faf	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07fb2	51		 push	 ecx
  07fb3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  07fb8	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqCa@5:

; 4098 : }

  07fbd	5f		 pop	 edi
  07fbe	5e		 pop	 esi
  07fbf	5b		 pop	 ebx
  07fc0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  07fc3	33 cd		 xor	 ecx, ebp
  07fc5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  07fca	8b e5		 mov	 esp, ebp
  07fcc	5d		 pop	 ebp
  07fcd	c3		 ret	 0
?GS_GDReqCastleMoneyChange@@YAXHHH@Z ENDP		; GS_GDReqCastleMoneyChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z		; GS_GDReqSiegeDateChange
EXTRN	?MSSQL2008@@3_NA:BYTE				; MSSQL2008
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_wStartYear$ = 16					; size = 2
_btStartMonth$ = 20					; size = 1
_btStartDay$ = 24					; size = 1
_wEndYear$ = 28						; size = 2
_btEndMonth$ = 32					; size = 1
_btEndDay$ = 36						; size = 1
?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z PROC		; GS_GDReqSiegeDateChange

; 4121 : {

  07fd0	55		 push	 ebp
  07fd1	8b ec		 mov	 ebp, esp
  07fd3	83 ec 58	 sub	 esp, 88			; 00000058H
  07fd6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  07fdb	33 c5		 xor	 eax, ebp
  07fdd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07fe0	53		 push	 ebx
  07fe1	56		 push	 esi
  07fe2	57		 push	 edi

; 4122 : 	if ( iMapSvrGroup < 0 )

  07fe3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  07fe7	7d 02		 jge	 SHORT $LN3@GS_GDReqSi

; 4123 : 	{
; 4124 : 		return;

  07fe9	eb 77		 jmp	 SHORT $LN4@GS_GDReqSi
$LN3@GS_GDReqSi:

; 4125 : 	}
; 4126 : 
; 4127 : 	CSP_REQ_SDEDCHANGE pMsg;
; 4128 : 
; 4129 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x09, sizeof(CSP_REQ_SDEDCHANGE));

  07feb	6a 14		 push	 20			; 00000014H
  07fed	6a 09		 push	 9
  07fef	68 80 00 00 00	 push	 128			; 00000080H
  07ff4	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  07ff7	50		 push	 eax
  07ff8	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  07ffb	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4130 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08000	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08004	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4131 : 	pMsg.iIndex = aIndex;

  08008	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0800b	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4132 : 	pMsg.wStartYear = wStartYear;

  0800e	66 8b 45 10	 mov	 ax, WORD PTR _wStartYear$[ebp]
  08012	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax

; 4133 : //#if(MSSQL2008==1)
; 4134 : 	if(MSSQL2008)

  08016	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?MSSQL2008@@3_NA ; MSSQL2008
  0801d	85 c0		 test	 eax, eax
  0801f	74 0e		 je	 SHORT $LN2@GS_GDReqSi

; 4135 : 	{
; 4136 : 		pMsg.btStartMonth = btStartDay;

  08021	8a 45 18	 mov	 al, BYTE PTR _btStartDay$[ebp]
  08024	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+14], al

; 4137 : 		pMsg.btStartDay = btStartMonth;

  08027	8a 45 14	 mov	 al, BYTE PTR _btStartMonth$[ebp]
  0802a	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+15], al

; 4138 : 	}
; 4139 : 	else

  0802d	eb 0c		 jmp	 SHORT $LN1@GS_GDReqSi
$LN2@GS_GDReqSi:

; 4140 : //#else
; 4141 : 	{
; 4142 : 		pMsg.btStartMonth = btStartMonth;

  0802f	8a 45 14	 mov	 al, BYTE PTR _btStartMonth$[ebp]
  08032	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+14], al

; 4143 : 		pMsg.btStartDay = btStartDay;

  08035	8a 45 18	 mov	 al, BYTE PTR _btStartDay$[ebp]
  08038	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+15], al
$LN1@GS_GDReqSi:

; 4144 : 	}
; 4145 : //#endif
; 4146 : 	pMsg.wEndYear = wEndYear;

  0803b	66 8b 45 1c	 mov	 ax, WORD PTR _wEndYear$[ebp]
  0803f	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 4147 : 	pMsg.btEndMonth = btEndMonth;

  08043	8a 45 20	 mov	 al, BYTE PTR _btEndMonth$[ebp]
  08046	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+18], al

; 4148 : 	pMsg.btEndDay = btEndDay;

  08049	8a 45 24	 mov	 al, BYTE PTR _btEndDay$[ebp]
  0804c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+19], al

; 4149 : 	
; 4150 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0804f	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08053	50		 push	 eax
  08054	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08057	51		 push	 ecx
  08058	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0805d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN4@GS_GDReqSi:

; 4151 : }

  08062	5f		 pop	 edi
  08063	5e		 pop	 esi
  08064	5b		 pop	 ebx
  08065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08068	33 cd		 xor	 ecx, ebp
  0806a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0806f	8b e5		 mov	 esp, ebp
  08071	5d		 pop	 ebp
  08072	c3		 ret	 0
?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z ENDP		; GS_GDReqSiegeDateChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqGuildMarkRegInfo@@YAXHH@Z		; GS_GDReqGuildMarkRegInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -92						; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqGuildMarkRegInfo@@YAXHH@Z PROC			; GS_GDReqGuildMarkRegInfo

; 4169 : {

  08080	55		 push	 ebp
  08081	8b ec		 mov	 ebp, esp
  08083	83 ec 5c	 sub	 esp, 92			; 0000005cH
  08086	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0808b	33 c5		 xor	 eax, ebp
  0808d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08090	53		 push	 ebx
  08091	56		 push	 esi
  08092	57		 push	 edi

; 4170 : 	if ( iMapSvrGroup < 0 )

  08093	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08097	7d 05		 jge	 SHORT $LN2@GS_GDReqGu

; 4171 : 	{
; 4172 : 		return;

  08099	e9 81 00 00 00	 jmp	 $LN3@GS_GDReqGu
$LN2@GS_GDReqGu:

; 4173 : 	}
; 4174 : 
; 4175 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0809e	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  080a2	7d 09		 jge	 SHORT $LN5@GS_GDReqGu
  080a4	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  080ab	eb 0f		 jmp	 SHORT $LN6@GS_GDReqGu
$LN5@GS_GDReqGu:
  080ad	33 c0		 xor	 eax, eax
  080af	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  080b6	0f 9e c0	 setle	 al
  080b9	89 45 a4	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqGu:
  080bc	83 7d a4 00	 cmp	 DWORD PTR tv68[ebp], 0
  080c0	75 02		 jne	 SHORT $LN1@GS_GDReqGu

; 4176 : 	{
; 4177 : 		return;

  080c2	eb 5b		 jmp	 SHORT $LN3@GS_GDReqGu
$LN1@GS_GDReqGu:

; 4178 : 	}
; 4179 : 
; 4180 : 
; 4181 : 	CSP_REQ_GUILDREGINFO pMsg;
; 4182 : 
; 4183 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0A, sizeof(CSP_REQ_GUILDREGINFO));

  080c4	6a 14		 push	 20			; 00000014H
  080c6	6a 0a		 push	 10			; 0000000aH
  080c8	68 80 00 00 00	 push	 128			; 00000080H
  080cd	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  080d0	50		 push	 eax
  080d1	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  080d4	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4184 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  080d9	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  080dd	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4185 : 	pMsg.iIndex = aIndex;

  080e1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  080e4	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4186 : 	memcpy(pMsg.szGuildName, gObj[aIndex].GuildName, 8);

  080e7	6a 08		 push	 8
  080e9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  080ec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  080f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  080f8	8d 94 01 3c 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1084]
  080ff	52		 push	 edx
  08100	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp+12]
  08103	50		 push	 eax
  08104	e8 00 00 00 00	 call	 _memcpy
  08109	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4187 : 	
; 4188 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0810c	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08110	50		 push	 eax
  08111	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08114	51		 push	 ecx
  08115	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0811a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqGu:

; 4189 : }

  0811f	5f		 pop	 edi
  08120	5e		 pop	 esi
  08121	5b		 pop	 ebx
  08122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08125	33 cd		 xor	 ecx, ebp
  08127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0812c	8b e5		 mov	 esp, ebp
  0812e	5d		 pop	 ebp
  0812f	c3		 ret	 0
?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ENDP			; GS_GDReqGuildMarkRegInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqSiegeEndedChange@@YAXHH@Z		; GS_GDReqSiegeEndedChange
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_bIsSiegeEnded$ = 12					; size = 4
?GS_GDReqSiegeEndedChange@@YAXHH@Z PROC			; GS_GDReqSiegeEndedChange

; 4206 : {

  08130	55		 push	 ebp
  08131	8b ec		 mov	 ebp, esp
  08133	83 ec 50	 sub	 esp, 80			; 00000050H
  08136	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0813b	33 c5		 xor	 eax, ebp
  0813d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08140	53		 push	 ebx
  08141	56		 push	 esi
  08142	57		 push	 edi

; 4207 : 	if ( iMapSvrGroup < 0 )

  08143	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08147	7d 02		 jge	 SHORT $LN1@GS_GDReqSi@2

; 4208 : 	{
; 4209 : 		return;

  08149	eb 36		 jmp	 SHORT $LN2@GS_GDReqSi@2
$LN1@GS_GDReqSi@2:

; 4210 : 	}
; 4211 : 
; 4212 : 
; 4213 : 	CSP_REQ_SIEGEENDCHANGE pMsg;
; 4214 : 
; 4215 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0B, sizeof(CSP_REQ_SIEGEENDCHANGE));

  0814b	6a 0c		 push	 12			; 0000000cH
  0814d	6a 0b		 push	 11			; 0000000bH
  0814f	68 80 00 00 00	 push	 128			; 00000080H
  08154	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08157	50		 push	 eax
  08158	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0815b	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4216 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08160	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08164	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4217 : 	pMsg.bIsSiegeEnded = bIsSiegeEnded;

  08168	8b 45 0c	 mov	 eax, DWORD PTR _bIsSiegeEnded$[ebp]
  0816b	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4218 : 	
; 4219 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0816e	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08172	50		 push	 eax
  08173	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08176	51		 push	 ecx
  08177	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0817c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqSi@2:

; 4220 : }

  08181	5f		 pop	 edi
  08182	5e		 pop	 esi
  08183	5b		 pop	 ebx
  08184	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08187	33 cd		 xor	 ecx, ebp
  08189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0818e	8b e5		 mov	 esp, ebp
  08190	5d		 pop	 ebp
  08191	c3		 ret	 0
?GS_GDReqSiegeEndedChange@@YAXHH@Z ENDP			; GS_GDReqSiegeEndedChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z		; GS_GDReqCastleOwnerChange
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_bIsCastleOccupied$ = 12				; size = 4
_lpszGuildName$ = 16					; size = 4
?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z PROC		; GS_GDReqCastleOwnerChange

; 4238 : {

  081a0	55		 push	 ebp
  081a1	8b ec		 mov	 ebp, esp
  081a3	83 ec 58	 sub	 esp, 88			; 00000058H
  081a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  081ab	33 c5		 xor	 eax, ebp
  081ad	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  081b0	53		 push	 ebx
  081b1	56		 push	 esi
  081b2	57		 push	 edi

; 4239 : 	if ( iMapSvrGroup < 0 )

  081b3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  081b7	7d 02		 jge	 SHORT $LN2@GS_GDReqCa@6

; 4240 : 	{
; 4241 : 		return;

  081b9	eb 50		 jmp	 SHORT $LN3@GS_GDReqCa@6
$LN2@GS_GDReqCa@6:

; 4242 : 	}
; 4243 : 
; 4244 : 	if ( lpszGuildName == NULL )

  081bb	83 7d 10 00	 cmp	 DWORD PTR _lpszGuildName$[ebp], 0
  081bf	75 02		 jne	 SHORT $LN1@GS_GDReqCa@6

; 4245 : 	{
; 4246 : 		return;

  081c1	eb 48		 jmp	 SHORT $LN3@GS_GDReqCa@6
$LN1@GS_GDReqCa@6:

; 4247 : 	}
; 4248 : 
; 4249 : 
; 4250 : 	CSP_REQ_CASTLEOWNERCHANGE pMsg;
; 4251 : 
; 4252 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0C, sizeof(CSP_REQ_CASTLEOWNERCHANGE));

  081c3	6a 14		 push	 20			; 00000014H
  081c5	6a 0c		 push	 12			; 0000000cH
  081c7	68 80 00 00 00	 push	 128			; 00000080H
  081cc	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  081cf	50		 push	 eax
  081d0	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  081d3	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4253 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  081d8	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  081dc	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4254 : 	pMsg.bIsCastleOccupied = bIsCastleOccupied;

  081e0	8b 45 0c	 mov	 eax, DWORD PTR _bIsCastleOccupied$[ebp]
  081e3	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4255 : 	memcpy(pMsg.szOwnerGuildName, lpszGuildName, 8);

  081e6	6a 08		 push	 8
  081e8	8b 45 10	 mov	 eax, DWORD PTR _lpszGuildName$[ebp]
  081eb	50		 push	 eax
  081ec	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp+12]
  081ef	51		 push	 ecx
  081f0	e8 00 00 00 00	 call	 _memcpy
  081f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4256 : 	
; 4257 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  081f8	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  081fc	50		 push	 eax
  081fd	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08200	51		 push	 ecx
  08201	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  08206	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqCa@6:

; 4258 : }

  0820b	5f		 pop	 edi
  0820c	5e		 pop	 esi
  0820d	5b		 pop	 ebx
  0820e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08211	33 cd		 xor	 ecx, ebp
  08213	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08218	8b e5		 mov	 esp, ebp
  0821a	5d		 pop	 ebp
  0821b	c3		 ret	 0
?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z ENDP		; GS_GDReqCastleOwnerChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqRegAttackGuild@@YAXHH@Z		; GS_GDReqRegAttackGuild
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -92						; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqRegAttackGuild@@YAXHH@Z PROC			; GS_GDReqRegAttackGuild

; 4276 : {

  08220	55		 push	 ebp
  08221	8b ec		 mov	 ebp, esp
  08223	83 ec 5c	 sub	 esp, 92			; 0000005cH
  08226	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0822b	33 c5		 xor	 eax, ebp
  0822d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08230	53		 push	 ebx
  08231	56		 push	 esi
  08232	57		 push	 edi

; 4277 : 	if ( iMapSvrGroup < 0 )

  08233	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08237	7d 05		 jge	 SHORT $LN2@GS_GDReqRe

; 4278 : 	{
; 4279 : 		return;

  08239	e9 81 00 00 00	 jmp	 $LN3@GS_GDReqRe
$LN2@GS_GDReqRe:

; 4280 : 	}
; 4281 : 
; 4282 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0823e	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  08242	7d 09		 jge	 SHORT $LN5@GS_GDReqRe
  08244	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0824b	eb 0f		 jmp	 SHORT $LN6@GS_GDReqRe
$LN5@GS_GDReqRe:
  0824d	33 c0		 xor	 eax, eax
  0824f	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  08256	0f 9e c0	 setle	 al
  08259	89 45 a4	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqRe:
  0825c	83 7d a4 00	 cmp	 DWORD PTR tv68[ebp], 0
  08260	75 02		 jne	 SHORT $LN1@GS_GDReqRe

; 4283 : 	{
; 4284 : 		return;

  08262	eb 5b		 jmp	 SHORT $LN3@GS_GDReqRe
$LN1@GS_GDReqRe:

; 4285 : 	}
; 4286 : 
; 4287 : 
; 4288 : 	CSP_REQ_REGATTACKGUILD pMsg;
; 4289 : 
; 4290 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0D, sizeof(CSP_REQ_REGATTACKGUILD));

  08264	6a 14		 push	 20			; 00000014H
  08266	6a 0d		 push	 13			; 0000000dH
  08268	68 80 00 00 00	 push	 128			; 00000080H
  0826d	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08270	50		 push	 eax
  08271	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08274	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4291 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08279	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0827d	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4292 : 	pMsg.iIndex = aIndex;

  08281	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  08284	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4293 : 	memcpy(pMsg.szEnemyGuildName, gObj[aIndex].GuildName, 8);

  08287	6a 08		 push	 8
  08289	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0828c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08292	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08298	8d 94 01 3c 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1084]
  0829f	52		 push	 edx
  082a0	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp+12]
  082a3	50		 push	 eax
  082a4	e8 00 00 00 00	 call	 _memcpy
  082a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4294 : 	
; 4295 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  082ac	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  082b0	50		 push	 eax
  082b1	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  082b4	51		 push	 ecx
  082b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  082ba	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqRe:

; 4296 : }

  082bf	5f		 pop	 edi
  082c0	5e		 pop	 esi
  082c1	5b		 pop	 ebx
  082c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  082c5	33 cd		 xor	 ecx, ebp
  082c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  082cc	8b e5		 mov	 esp, ebp
  082ce	5d		 pop	 ebp
  082cf	c3		 ret	 0
?GS_GDReqRegAttackGuild@@YAXHH@Z ENDP			; GS_GDReqRegAttackGuild
_TEXT	ENDS
PUBLIC	?GS_GDReqRestartCastleState@@YAXH@Z		; GS_GDReqRestartCastleState
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqRestartCastleState@@YAXH@Z PROC		; GS_GDReqRestartCastleState

; 4312 : {

  082d0	55		 push	 ebp
  082d1	8b ec		 mov	 ebp, esp
  082d3	83 ec 48	 sub	 esp, 72			; 00000048H
  082d6	53		 push	 ebx
  082d7	56		 push	 esi
  082d8	57		 push	 edi

; 4313 : 	if ( iMapSvrGroup < 0 )

  082d9	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  082dd	7d 02		 jge	 SHORT $LN1@GS_GDReqRe@2

; 4314 : 	{
; 4315 : 		return;

  082df	eb 30		 jmp	 SHORT $LN2@GS_GDReqRe@2
$LN1@GS_GDReqRe@2:

; 4316 : 	}
; 4317 : 
; 4318 : 	CSP_REQ_CASTLESIEGEEND pMsg;
; 4319 : 
; 4320 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0E, sizeof(CSP_REQ_CASTLESIEGEEND));

  082e1	6a 06		 push	 6
  082e3	6a 0e		 push	 14			; 0000000eH
  082e5	68 80 00 00 00	 push	 128			; 00000080H
  082ea	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  082ed	50		 push	 eax
  082ee	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  082f1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4321 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  082f6	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  082fa	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4322 : 	
; 4323 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  082fe	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08302	50		 push	 eax
  08303	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08306	51		 push	 ecx
  08307	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0830c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqRe@2:

; 4324 : }

  08311	5f		 pop	 edi
  08312	5e		 pop	 esi
  08313	5b		 pop	 ebx
  08314	8b e5		 mov	 esp, ebp
  08316	5d		 pop	 ebp
  08317	c3		 ret	 0
?GS_GDReqRestartCastleState@@YAXH@Z ENDP		; GS_GDReqRestartCastleState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z		; GS_GDReqMapSvrMsgMultiCast
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -140						; size = 134
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_lpszMsgText$ = 12					; size = 4
?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z PROC		; GS_GDReqMapSvrMsgMultiCast

; 4341 : {

  08320	55		 push	 ebp
  08321	8b ec		 mov	 ebp, esp
  08323	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  08329	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0832e	33 c5		 xor	 eax, ebp
  08330	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08333	53		 push	 ebx
  08334	56		 push	 esi
  08335	57		 push	 edi

; 4342 : 	if ( iMapSvrGroup < 0 )

  08336	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  0833a	7d 02		 jge	 SHORT $LN2@GS_GDReqMa

; 4343 : 	{
; 4344 : 		return;

  0833c	eb 61		 jmp	 SHORT $LN3@GS_GDReqMa
$LN2@GS_GDReqMa:

; 4345 : 	}
; 4346 : 
; 4347 : 	if ( lpszMsgText == NULL )

  0833e	83 7d 0c 00	 cmp	 DWORD PTR _lpszMsgText$[ebp], 0
  08342	75 02		 jne	 SHORT $LN1@GS_GDReqMa

; 4348 : 	{
; 4349 : 		return;

  08344	eb 59		 jmp	 SHORT $LN3@GS_GDReqMa
$LN1@GS_GDReqMa:

; 4350 : 	}
; 4351 : 
; 4352 : 
; 4353 : 	CSP_REQ_MAPSVRMULTICAST pMsg;
; 4354 : 
; 4355 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0F, sizeof(CSP_REQ_MAPSVRMULTICAST));

  08346	68 86 00 00 00	 push	 134			; 00000086H
  0834b	6a 0f		 push	 15			; 0000000fH
  0834d	68 80 00 00 00	 push	 128			; 00000080H
  08352	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  08358	50		 push	 eax
  08359	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0835f	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4356 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08364	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08368	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4357 : 	strcpy(pMsg.szMsgText, lpszMsgText);

  0836f	8b 45 0c	 mov	 eax, DWORD PTR _lpszMsgText$[ebp]
  08372	50		 push	 eax
  08373	8d 8d 7a ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+6]
  08379	51		 push	 ecx
  0837a	e8 00 00 00 00	 call	 _strcpy
  0837f	83 c4 08	 add	 esp, 8

; 4358 : 	pMsg.szMsgText[127] = 0;

  08382	c6 45 f9 00	 mov	 BYTE PTR _pMsg$[ebp+133], 0

; 4359 : 	
; 4360 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  08386	0f b6 85 75 ff
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0838d	50		 push	 eax
  0838e	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08394	51		 push	 ecx
  08395	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0839a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqMa:

; 4361 : }

  0839f	5f		 pop	 edi
  083a0	5e		 pop	 esi
  083a1	5b		 pop	 ebx
  083a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  083a5	33 cd		 xor	 ecx, ebp
  083a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  083ac	8b e5		 mov	 esp, ebp
  083ae	5d		 pop	 ebp
  083af	c3		 ret	 0
?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z ENDP		; GS_GDReqMapSvrMsgMultiCast
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqRegGuildMark@@YAXHHH@Z			; GS_GDReqRegGuildMark
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -96						; size = 4
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iItemPos$ = 16						; size = 4
?GS_GDReqRegGuildMark@@YAXHHH@Z PROC			; GS_GDReqRegGuildMark

; 4380 : {

  083b0	55		 push	 ebp
  083b1	8b ec		 mov	 ebp, esp
  083b3	83 ec 60	 sub	 esp, 96			; 00000060H
  083b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  083bb	33 c5		 xor	 eax, ebp
  083bd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  083c0	53		 push	 ebx
  083c1	56		 push	 esi
  083c2	57		 push	 edi

; 4381 : 	if ( iMapSvrGroup < 0 )

  083c3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  083c7	7d 05		 jge	 SHORT $LN2@GS_GDReqRe@3

; 4382 : 	{
; 4383 : 		return;

  083c9	e9 87 00 00 00	 jmp	 $LN3@GS_GDReqRe@3
$LN2@GS_GDReqRe@3:

; 4384 : 	}
; 4385 : 
; 4386 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  083ce	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  083d2	7d 09		 jge	 SHORT $LN5@GS_GDReqRe@3
  083d4	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  083db	eb 0f		 jmp	 SHORT $LN6@GS_GDReqRe@3
$LN5@GS_GDReqRe@3:
  083dd	33 c0		 xor	 eax, eax
  083df	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  083e6	0f 9e c0	 setle	 al
  083e9	89 45 a0	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqRe@3:
  083ec	83 7d a0 00	 cmp	 DWORD PTR tv68[ebp], 0
  083f0	75 02		 jne	 SHORT $LN1@GS_GDReqRe@3

; 4387 : 	{
; 4388 : 		return;

  083f2	eb 61		 jmp	 SHORT $LN3@GS_GDReqRe@3
$LN1@GS_GDReqRe@3:

; 4389 : 	}
; 4390 : 
; 4391 : 	CSP_REQ_GUILDREGMARK pMsg;
; 4392 : 
; 4393 : 	pMsg.h.set((LPBYTE)&pMsg,0x80,0x10, sizeof(CSP_REQ_GUILDREGMARK));

  083f4	6a 18		 push	 24			; 00000018H
  083f6	6a 10		 push	 16			; 00000010H
  083f8	68 80 00 00 00	 push	 128			; 00000080H
  083fd	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08400	50		 push	 eax
  08401	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08404	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4394 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08409	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0840d	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4395 : 	pMsg.iIndex = aIndex;

  08411	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  08414	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4396 : 	pMsg.iItemPos = iItemPos;

  08417	8b 45 10	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0841a	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 4397 : 	memcpy(&pMsg.szGuildName,gObj[aIndex].GuildName,sizeof(pMsg.szGuildName));

  0841d	6a 08		 push	 8
  0841f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  08422	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08428	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0842e	8d 94 01 3c 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1084]
  08435	52		 push	 edx
  08436	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp+12]
  08439	50		 push	 eax
  0843a	e8 00 00 00 00	 call	 _memcpy
  0843f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4398 : 	
; 4399 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  08442	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08446	50		 push	 eax
  08447	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0844a	51		 push	 ecx
  0844b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  08450	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqRe@3:

; 4400 : }

  08455	5f		 pop	 edi
  08456	5e		 pop	 esi
  08457	5b		 pop	 ebx
  08458	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0845b	33 cd		 xor	 ecx, ebp
  0845d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08462	8b e5		 mov	 esp, ebp
  08464	5d		 pop	 ebp
  08465	c3		 ret	 0
?GS_GDReqRegGuildMark@@YAXHHH@Z ENDP			; GS_GDReqRegGuildMark
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqGuildMarkReset@@YAXHHPAD@Z		; GS_GDReqGuildMarkReset
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -92						; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
?GS_GDReqGuildMarkReset@@YAXHHPAD@Z PROC		; GS_GDReqGuildMarkReset

; 4418 : {

  08470	55		 push	 ebp
  08471	8b ec		 mov	 ebp, esp
  08473	83 ec 5c	 sub	 esp, 92			; 0000005cH
  08476	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0847b	33 c5		 xor	 eax, ebp
  0847d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08480	53		 push	 ebx
  08481	56		 push	 esi
  08482	57		 push	 edi

; 4419 : 	if ( iMapSvrGroup < 0 )

  08483	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08487	7d 02		 jge	 SHORT $LN3@GS_GDReqGu@2

; 4420 : 	{
; 4421 : 		return;

  08489	eb 76		 jmp	 SHORT $LN4@GS_GDReqGu@2
$LN3@GS_GDReqGu@2:

; 4422 : 	}
; 4423 : 
; 4424 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0848b	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0848f	7d 09		 jge	 SHORT $LN6@GS_GDReqGu@2
  08491	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  08498	eb 0f		 jmp	 SHORT $LN7@GS_GDReqGu@2
$LN6@GS_GDReqGu@2:
  0849a	33 c0		 xor	 eax, eax
  0849c	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  084a3	0f 9e c0	 setle	 al
  084a6	89 45 a4	 mov	 DWORD PTR tv68[ebp], eax
$LN7@GS_GDReqGu@2:
  084a9	83 7d a4 00	 cmp	 DWORD PTR tv68[ebp], 0
  084ad	75 02		 jne	 SHORT $LN2@GS_GDReqGu@2

; 4425 : 	{
; 4426 : 		return;

  084af	eb 50		 jmp	 SHORT $LN4@GS_GDReqGu@2
$LN2@GS_GDReqGu@2:

; 4427 : 	}
; 4428 : 
; 4429 : 	if ( lpszGuildName == NULL )

  084b1	83 7d 10 00	 cmp	 DWORD PTR _lpszGuildName$[ebp], 0
  084b5	75 02		 jne	 SHORT $LN1@GS_GDReqGu@2

; 4430 : 	{
; 4431 : 		return;

  084b7	eb 48		 jmp	 SHORT $LN4@GS_GDReqGu@2
$LN1@GS_GDReqGu@2:

; 4432 : 	}
; 4433 : 
; 4434 : 	CSP_REQ_GUILDRESETMARK pMsg;
; 4435 : 
; 4436 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x11, sizeof(CSP_REQ_GUILDRESETMARK));

  084b9	6a 14		 push	 20			; 00000014H
  084bb	6a 11		 push	 17			; 00000011H
  084bd	68 80 00 00 00	 push	 128			; 00000080H
  084c2	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  084c5	50		 push	 eax
  084c6	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  084c9	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4437 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  084ce	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  084d2	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4438 : 	pMsg.iIndex = aIndex;

  084d6	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  084d9	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4439 : 	memcpy(pMsg.szGuildName, lpszGuildName, 8);

  084dc	6a 08		 push	 8
  084de	8b 45 10	 mov	 eax, DWORD PTR _lpszGuildName$[ebp]
  084e1	50		 push	 eax
  084e2	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp+12]
  084e5	51		 push	 ecx
  084e6	e8 00 00 00 00	 call	 _memcpy
  084eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4440 : 	
; 4441 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  084ee	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  084f2	50		 push	 eax
  084f3	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  084f6	51		 push	 ecx
  084f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  084fc	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN4@GS_GDReqGu@2:

; 4442 : }

  08501	5f		 pop	 edi
  08502	5e		 pop	 esi
  08503	5b		 pop	 ebx
  08504	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08507	33 cd		 xor	 ecx, ebp
  08509	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0850e	8b e5		 mov	 esp, ebp
  08510	5d		 pop	 ebp
  08511	c3		 ret	 0
?GS_GDReqGuildMarkReset@@YAXHHPAD@Z ENDP		; GS_GDReqGuildMarkReset
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqGuildSetGiveUp@@YAXHHH@Z		; GS_GDReqGuildSetGiveUp
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -96						; size = 4
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_bIsGiveUp$ = 16					; size = 4
?GS_GDReqGuildSetGiveUp@@YAXHHH@Z PROC			; GS_GDReqGuildSetGiveUp

; 4461 : {

  08520	55		 push	 ebp
  08521	8b ec		 mov	 ebp, esp
  08523	83 ec 60	 sub	 esp, 96			; 00000060H
  08526	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0852b	33 c5		 xor	 eax, ebp
  0852d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08530	53		 push	 ebx
  08531	56		 push	 esi
  08532	57		 push	 edi

; 4462 : 	if ( iMapSvrGroup < 0 )

  08533	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08537	7d 05		 jge	 SHORT $LN2@GS_GDReqGu@3

; 4463 : 	{
; 4464 : 		return;

  08539	e9 87 00 00 00	 jmp	 $LN3@GS_GDReqGu@3
$LN2@GS_GDReqGu@3:

; 4465 : 	}
; 4466 : 
; 4467 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0853e	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  08542	7d 09		 jge	 SHORT $LN5@GS_GDReqGu@3
  08544	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0854b	eb 0f		 jmp	 SHORT $LN6@GS_GDReqGu@3
$LN5@GS_GDReqGu@3:
  0854d	33 c0		 xor	 eax, eax
  0854f	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  08556	0f 9e c0	 setle	 al
  08559	89 45 a0	 mov	 DWORD PTR tv68[ebp], eax
$LN6@GS_GDReqGu@3:
  0855c	83 7d a0 00	 cmp	 DWORD PTR tv68[ebp], 0
  08560	75 02		 jne	 SHORT $LN1@GS_GDReqGu@3

; 4468 : 	{
; 4469 : 		return;

  08562	eb 61		 jmp	 SHORT $LN3@GS_GDReqGu@3
$LN1@GS_GDReqGu@3:

; 4470 : 	}
; 4471 : 
; 4472 : 	CSP_REQ_GUILDSETGIVEUP pMsg;
; 4473 : 
; 4474 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x12, sizeof(CSP_REQ_GUILDSETGIVEUP));

  08564	6a 18		 push	 24			; 00000018H
  08566	6a 12		 push	 18			; 00000012H
  08568	68 80 00 00 00	 push	 128			; 00000080H
  0856d	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08570	50		 push	 eax
  08571	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08574	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4475 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08579	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0857d	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4476 : 	pMsg.iIndex = aIndex;

  08581	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  08584	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4477 : 	pMsg.bIsGiveUp = bIsGiveUp;

  08587	8b 45 10	 mov	 eax, DWORD PTR _bIsGiveUp$[ebp]
  0858a	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 4478 : 	memcpy(pMsg.szGuildName, gObj[aIndex].GuildName, 8);

  0858d	6a 08		 push	 8
  0858f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  08592	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08598	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0859e	8d 94 01 3c 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1084]
  085a5	52		 push	 edx
  085a6	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp+12]
  085a9	50		 push	 eax
  085aa	e8 00 00 00 00	 call	 _memcpy
  085af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4479 : 	
; 4480 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  085b2	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  085b6	50		 push	 eax
  085b7	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  085ba	51		 push	 ecx
  085bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  085c0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqGu@3:

; 4481 : }

  085c5	5f		 pop	 edi
  085c6	5e		 pop	 esi
  085c7	5b		 pop	 ebx
  085c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  085cb	33 cd		 xor	 ecx, ebp
  085cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  085d2	8b e5		 mov	 esp, ebp
  085d4	5d		 pop	 ebp
  085d5	c3		 ret	 0
?GS_GDReqGuildSetGiveUp@@YAXHHH@Z ENDP			; GS_GDReqGuildSetGiveUp
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqNpcRemove@@YAXHHH@Z			; GS_GDReqNpcRemove
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iNpcNumber$ = 12					; size = 4
_iNpcIndex$ = 16					; size = 4
?GS_GDReqNpcRemove@@YAXHHH@Z PROC			; GS_GDReqNpcRemove

; 4499 : {

  085e0	55		 push	 ebp
  085e1	8b ec		 mov	 ebp, esp
  085e3	83 ec 54	 sub	 esp, 84			; 00000054H
  085e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  085eb	33 c5		 xor	 eax, ebp
  085ed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  085f0	53		 push	 ebx
  085f1	56		 push	 esi
  085f2	57		 push	 edi

; 4500 : 	if ( iMapSvrGroup < 0 )

  085f3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  085f7	7d 02		 jge	 SHORT $LN1@GS_GDReqNp

; 4501 : 	{
; 4502 : 		return;

  085f9	eb 3c		 jmp	 SHORT $LN2@GS_GDReqNp
$LN1@GS_GDReqNp:

; 4503 : 	}
; 4504 : 
; 4505 : 	CSP_REQ_NPCREMOVE pMsg;
; 4506 : 
; 4507 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x16, sizeof(CSP_REQ_NPCREMOVE));

  085fb	6a 10		 push	 16			; 00000010H
  085fd	6a 16		 push	 22			; 00000016H
  085ff	68 80 00 00 00	 push	 128			; 00000080H
  08604	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08607	50		 push	 eax
  08608	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0860b	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4508 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08610	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08614	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4509 : 	pMsg.iNpcNumber = iNpcNumber;

  08618	8b 45 0c	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  0861b	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4510 : 	pMsg.iNpcIndex = iNpcIndex;

  0861e	8b 45 10	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  08621	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4511 : 	
; 4512 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  08624	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08628	50		 push	 eax
  08629	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0862c	51		 push	 ecx
  0862d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  08632	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqNp:

; 4513 : }

  08637	5f		 pop	 edi
  08638	5e		 pop	 esi
  08639	5b		 pop	 ebx
  0863a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0863d	33 cd		 xor	 ecx, ebp
  0863f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08644	8b e5		 mov	 esp, ebp
  08646	5d		 pop	 ebp
  08647	c3		 ret	 0
?GS_GDReqNpcRemove@@YAXHHH@Z ENDP			; GS_GDReqNpcRemove
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z		; GS_GDReqCastleStateSync
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleState$ = 12					; size = 4
_iTaxRateChaos$ = 16					; size = 4
_iTaxRateStore$ = 20					; size = 4
_iTaxHuntZone$ = 24					; size = 4
_lpszOwnerGuild$ = 28					; size = 4
?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z PROC		; GS_GDReqCastleStateSync

; 4534 : {

  08650	55		 push	 ebp
  08651	8b ec		 mov	 ebp, esp
  08653	83 ec 64	 sub	 esp, 100		; 00000064H
  08656	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0865b	33 c5		 xor	 eax, ebp
  0865d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08660	53		 push	 ebx
  08661	56		 push	 esi
  08662	57		 push	 edi

; 4535 : 	if ( iMapSvrGroup < 0 )

  08663	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08667	7d 02		 jge	 SHORT $LN1@GS_GDReqCa@7

; 4536 : 	{
; 4537 : 		return;

  08669	eb 5a		 jmp	 SHORT $LN2@GS_GDReqCa@7
$LN1@GS_GDReqCa@7:

; 4538 : 	}
; 4539 : 
; 4540 : 	CSP_REQ_CASTLESTATESYNC pMsg;
; 4541 : 
; 4542 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x17, sizeof(CSP_REQ_CASTLESTATESYNC));

  0866b	6a 20		 push	 32			; 00000020H
  0866d	6a 17		 push	 23			; 00000017H
  0866f	68 80 00 00 00	 push	 128			; 00000080H
  08674	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08677	50		 push	 eax
  08678	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0867b	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4543 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08680	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08684	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4544 : 	pMsg.iCastleState = iCastleState;

  08688	8b 45 0c	 mov	 eax, DWORD PTR _iCastleState$[ebp]
  0868b	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4545 : 	pMsg.iTaxRateChaos = iTaxRateChaos;

  0868e	8b 45 10	 mov	 eax, DWORD PTR _iTaxRateChaos$[ebp]
  08691	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4546 : 	pMsg.iTaxRateStore = iTaxRateStore;

  08694	8b 45 14	 mov	 eax, DWORD PTR _iTaxRateStore$[ebp]
  08697	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 4547 : 	pMsg.iTaxHuntZone = iTaxHuntZone;

  0869a	8b 45 18	 mov	 eax, DWORD PTR _iTaxHuntZone$[ebp]
  0869d	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 4548 : 	memcpy(pMsg.szOwnerGuildName, lpszOwnerGuild, 8);

  086a0	6a 08		 push	 8
  086a2	8b 45 1c	 mov	 eax, DWORD PTR _lpszOwnerGuild$[ebp]
  086a5	50		 push	 eax
  086a6	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp+24]
  086a9	51		 push	 ecx
  086aa	e8 00 00 00 00	 call	 _memcpy
  086af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4549 : 	
; 4550 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  086b2	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  086b6	50		 push	 eax
  086b7	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  086ba	51		 push	 ecx
  086bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  086c0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqCa@7:

; 4551 : }

  086c5	5f		 pop	 edi
  086c6	5e		 pop	 esi
  086c7	5b		 pop	 ebx
  086c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  086cb	33 cd		 xor	 ecx, ebp
  086cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  086d2	8b e5		 mov	 esp, ebp
  086d4	5d		 pop	 ebp
  086d5	c3		 ret	 0
?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z ENDP		; GS_GDReqCastleStateSync
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleTributeMoney@@YAXHH@Z		; GS_GDReqCastleTributeMoney
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleTributeMoney$ = 12				; size = 4
?GS_GDReqCastleTributeMoney@@YAXHH@Z PROC		; GS_GDReqCastleTributeMoney

; 4568 : {

  086e0	55		 push	 ebp
  086e1	8b ec		 mov	 ebp, esp
  086e3	83 ec 50	 sub	 esp, 80			; 00000050H
  086e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  086eb	33 c5		 xor	 eax, ebp
  086ed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  086f0	53		 push	 ebx
  086f1	56		 push	 esi
  086f2	57		 push	 edi

; 4569 : 	if ( iMapSvrGroup < 0 )

  086f3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  086f7	7d 02		 jge	 SHORT $LN2@GS_GDReqCa@8

; 4570 : 	{
; 4571 : 		return;

  086f9	eb 3e		 jmp	 SHORT $LN3@GS_GDReqCa@8
$LN2@GS_GDReqCa@8:

; 4572 : 	}
; 4573 : 
; 4574 : 	if ( iCastleTributeMoney < 0 )

  086fb	83 7d 0c 00	 cmp	 DWORD PTR _iCastleTributeMoney$[ebp], 0
  086ff	7d 02		 jge	 SHORT $LN1@GS_GDReqCa@8

; 4575 : 	{
; 4576 : 		return;

  08701	eb 36		 jmp	 SHORT $LN3@GS_GDReqCa@8
$LN1@GS_GDReqCa@8:

; 4577 : 	}
; 4578 : 
; 4579 : 	CSP_REQ_CASTLETRIBUTEMONEY pMsg;
; 4580 : 
; 4581 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x18, sizeof(CSP_REQ_CASTLETRIBUTEMONEY));

  08703	6a 0c		 push	 12			; 0000000cH
  08705	6a 18		 push	 24			; 00000018H
  08707	68 80 00 00 00	 push	 128			; 00000080H
  0870c	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0870f	50		 push	 eax
  08710	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08713	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4582 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08718	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0871c	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4583 : 	pMsg.iCastleTributeMoney = iCastleTributeMoney;

  08720	8b 45 0c	 mov	 eax, DWORD PTR _iCastleTributeMoney$[ebp]
  08723	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4584 : 
; 4585 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  08726	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0872a	50		 push	 eax
  0872b	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0872e	51		 push	 ecx
  0872f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  08734	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GS_GDReqCa@8:

; 4586 : }

  08739	5f		 pop	 edi
  0873a	5e		 pop	 esi
  0873b	5b		 pop	 ebx
  0873c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0873f	33 cd		 xor	 ecx, ebp
  08741	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08746	8b e5		 mov	 esp, ebp
  08748	5d		 pop	 ebp
  08749	c3		 ret	 0
?GS_GDReqCastleTributeMoney@@YAXHH@Z ENDP		; GS_GDReqCastleTributeMoney
_TEXT	ENDS
PUBLIC	?GS_GDReqResetCastleTaxInfo@@YAXH@Z		; GS_GDReqResetCastleTaxInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetCastleTaxInfo@@YAXH@Z PROC		; GS_GDReqResetCastleTaxInfo

; 4602 : {

  08750	55		 push	 ebp
  08751	8b ec		 mov	 ebp, esp
  08753	83 ec 48	 sub	 esp, 72			; 00000048H
  08756	53		 push	 ebx
  08757	56		 push	 esi
  08758	57		 push	 edi

; 4603 : 	if ( iMapSvrGroup < 0 )

  08759	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  0875d	7d 02		 jge	 SHORT $LN1@GS_GDReqRe@4

; 4604 : 	{
; 4605 : 		return;

  0875f	eb 30		 jmp	 SHORT $LN2@GS_GDReqRe@4
$LN1@GS_GDReqRe@4:

; 4606 : 	}
; 4607 : 
; 4608 : 	CSP_REQ_RESETCASTLETAXINFO pMsg;
; 4609 : 
; 4610 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x19, sizeof(CSP_REQ_RESETCASTLETAXINFO));

  08761	6a 06		 push	 6
  08763	6a 19		 push	 25			; 00000019H
  08765	68 80 00 00 00	 push	 128			; 00000080H
  0876a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0876d	50		 push	 eax
  0876e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08771	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4611 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08776	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0877a	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4612 : 
; 4613 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0877e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08782	50		 push	 eax
  08783	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08786	51		 push	 ecx
  08787	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0878c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqRe@4:

; 4614 : }

  08791	5f		 pop	 edi
  08792	5e		 pop	 esi
  08793	5b		 pop	 ebx
  08794	8b e5		 mov	 esp, ebp
  08796	5d		 pop	 ebp
  08797	c3		 ret	 0
?GS_GDReqResetCastleTaxInfo@@YAXH@Z ENDP		; GS_GDReqResetCastleTaxInfo
_TEXT	ENDS
PUBLIC	?GS_GDReqResetSiegeGuildInfo@@YAXH@Z		; GS_GDReqResetSiegeGuildInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetSiegeGuildInfo@@YAXH@Z PROC		; GS_GDReqResetSiegeGuildInfo

; 4630 : {

  087a0	55		 push	 ebp
  087a1	8b ec		 mov	 ebp, esp
  087a3	83 ec 48	 sub	 esp, 72			; 00000048H
  087a6	53		 push	 ebx
  087a7	56		 push	 esi
  087a8	57		 push	 edi

; 4631 : 	if ( iMapSvrGroup < 0 )

  087a9	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  087ad	7d 02		 jge	 SHORT $LN1@GS_GDReqRe@5

; 4632 : 	{
; 4633 : 		return;

  087af	eb 30		 jmp	 SHORT $LN2@GS_GDReqRe@5
$LN1@GS_GDReqRe@5:

; 4634 : 	}
; 4635 : 
; 4636 : 	CSP_REQ_RESETSIEGEGUILDINFO pMsg;
; 4637 : 
; 4638 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x1A, sizeof(CSP_REQ_RESETSIEGEGUILDINFO));

  087b1	6a 06		 push	 6
  087b3	6a 1a		 push	 26			; 0000001aH
  087b5	68 80 00 00 00	 push	 128			; 00000080H
  087ba	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  087bd	50		 push	 eax
  087be	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  087c1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4639 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  087c6	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  087ca	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4640 : 
; 4641 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  087ce	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  087d2	50		 push	 eax
  087d3	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  087d6	51		 push	 ecx
  087d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  087dc	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqRe@5:

; 4642 : }

  087e1	5f		 pop	 edi
  087e2	5e		 pop	 esi
  087e3	5b		 pop	 ebx
  087e4	8b e5		 mov	 esp, ebp
  087e6	5d		 pop	 ebp
  087e7	c3		 ret	 0
?GS_GDReqResetSiegeGuildInfo@@YAXH@Z ENDP		; GS_GDReqResetSiegeGuildInfo
_TEXT	ENDS
PUBLIC	?GS_GDReqResetRegSiegeInfo@@YAXH@Z		; GS_GDReqResetRegSiegeInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetRegSiegeInfo@@YAXH@Z PROC			; GS_GDReqResetRegSiegeInfo

; 4658 : {

  087f0	55		 push	 ebp
  087f1	8b ec		 mov	 ebp, esp
  087f3	83 ec 48	 sub	 esp, 72			; 00000048H
  087f6	53		 push	 ebx
  087f7	56		 push	 esi
  087f8	57		 push	 edi

; 4659 : 	if ( iMapSvrGroup < 0 )

  087f9	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  087fd	7d 02		 jge	 SHORT $LN1@GS_GDReqRe@6

; 4660 : 	{
; 4661 : 		return;

  087ff	eb 30		 jmp	 SHORT $LN2@GS_GDReqRe@6
$LN1@GS_GDReqRe@6:

; 4662 : 	}
; 4663 : 
; 4664 : 	CSP_REQ_RESETREGSIEGEINFO pMsg;
; 4665 : 
; 4666 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x1B, sizeof(CSP_REQ_RESETREGSIEGEINFO));

  08801	6a 06		 push	 6
  08803	6a 1b		 push	 27			; 0000001bH
  08805	68 80 00 00 00	 push	 128			; 00000080H
  0880a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0880d	50		 push	 eax
  0880e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08811	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 4667 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08816	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0881a	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4668 : 
; 4669 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0881e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08822	50		 push	 eax
  08823	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08826	51		 push	 ecx
  08827	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0882c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqRe@6:

; 4670 : }

  08831	5f		 pop	 edi
  08832	5e		 pop	 esi
  08833	5b		 pop	 ebx
  08834	8b e5		 mov	 esp, ebp
  08836	5d		 pop	 ebp
  08837	c3		 ret	 0
?GS_GDReqResetRegSiegeInfo@@YAXH@Z ENDP			; GS_GDReqResetRegSiegeInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleInitData@@YAXHH@Z		; GS_GDReqCastleInitData
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleEventCycle$ = 12				; size = 4
?GS_GDReqCastleInitData@@YAXHH@Z PROC			; GS_GDReqCastleInitData

; 4686 : {

  08840	55		 push	 ebp
  08841	8b ec		 mov	 ebp, esp
  08843	83 ec 50	 sub	 esp, 80			; 00000050H
  08846	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0884b	33 c5		 xor	 eax, ebp
  0884d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08850	53		 push	 ebx
  08851	56		 push	 esi
  08852	57		 push	 edi

; 4687 : 	if ( iMapSvrGroup < 0 )

  08853	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08857	7d 02		 jge	 SHORT $LN1@GS_GDReqCa@9

; 4688 : 	{
; 4689 : 		return;

  08859	eb 34		 jmp	 SHORT $LN2@GS_GDReqCa@9
$LN1@GS_GDReqCa@9:

; 4690 : 	}
; 4691 : 
; 4692 : 	CSP_REQ_CSINITDATA pMsg;
; 4693 : 
; 4694 : 	pMsg.h.set((LPBYTE)&pMsg, 0x81, sizeof(CSP_REQ_CSINITDATA));

  0885b	6a 0c		 push	 12			; 0000000cH
  0885d	68 81 00 00 00	 push	 129			; 00000081H
  08862	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08865	50		 push	 eax
  08866	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08869	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 4695 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0886e	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08872	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4696 : 	pMsg.iCastleEventCycle = iCastleEventCycle;

  08876	8b 45 0c	 mov	 eax, DWORD PTR _iCastleEventCycle$[ebp]
  08879	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4697 : 
; 4698 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0887c	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08880	50		 push	 eax
  08881	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08884	51		 push	 ecx
  08885	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0888a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqCa@9:

; 4699 : }

  0888f	5f		 pop	 edi
  08890	5e		 pop	 esi
  08891	5b		 pop	 ebx
  08892	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08895	33 cd		 xor	 ecx, ebp
  08897	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0889c	8b e5		 mov	 esp, ebp
  0889e	5d		 pop	 ebp
  0889f	c3		 ret	 0
?GS_GDReqCastleInitData@@YAXHH@Z ENDP			; GS_GDReqCastleInitData
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqCastleNpcInfo@@YAXHH@Z			; GS_GDReqCastleNpcInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqCastleNpcInfo@@YAXHH@Z PROC			; GS_GDReqCastleNpcInfo

; 4715 : {

  088a0	55		 push	 ebp
  088a1	8b ec		 mov	 ebp, esp
  088a3	83 ec 50	 sub	 esp, 80			; 00000050H
  088a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  088ab	33 c5		 xor	 eax, ebp
  088ad	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  088b0	53		 push	 ebx
  088b1	56		 push	 esi
  088b2	57		 push	 edi

; 4716 : 	if ( iMapSvrGroup < 0 )

  088b3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  088b7	7d 02		 jge	 SHORT $LN1@GS_GDReqCa@10

; 4717 : 	{
; 4718 : 		return;

  088b9	eb 34		 jmp	 SHORT $LN2@GS_GDReqCa@10
$LN1@GS_GDReqCa@10:

; 4719 : 	}
; 4720 : 
; 4721 : 	CSP_REQ_NPCDATA pMsg;
; 4722 : 
; 4723 : 	pMsg.h.set((LPBYTE)&pMsg, 0x82, sizeof(CSP_REQ_NPCDATA));

  088bb	6a 0c		 push	 12			; 0000000cH
  088bd	68 82 00 00 00	 push	 130			; 00000082H
  088c2	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  088c5	50		 push	 eax
  088c6	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  088c9	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 4724 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  088ce	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  088d2	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4725 : 	pMsg.iIndex = aIndex;

  088d6	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  088d9	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4726 : 
; 4727 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  088dc	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  088e0	50		 push	 eax
  088e1	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  088e4	51		 push	 ecx
  088e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  088ea	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqCa@10:

; 4728 : }

  088ef	5f		 pop	 edi
  088f0	5e		 pop	 esi
  088f1	5b		 pop	 ebx
  088f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  088f5	33 cd		 xor	 ecx, ebp
  088f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  088fc	8b e5		 mov	 esp, ebp
  088fe	5d		 pop	 ebp
  088ff	c3		 ret	 0
?GS_GDReqCastleNpcInfo@@YAXHH@Z ENDP			; GS_GDReqCastleNpcInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z		; GS_GDReqAllGuildMarkRegInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z PROC		; GS_GDReqAllGuildMarkRegInfo

; 4744 : {

  08900	55		 push	 ebp
  08901	8b ec		 mov	 ebp, esp
  08903	83 ec 50	 sub	 esp, 80			; 00000050H
  08906	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0890b	33 c5		 xor	 eax, ebp
  0890d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08910	53		 push	 ebx
  08911	56		 push	 esi
  08912	57		 push	 edi

; 4745 : 	if ( iMapSvrGroup < 0 )

  08913	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  08917	7d 02		 jge	 SHORT $LN1@GS_GDReqAl

; 4746 : 	{
; 4747 : 		return;

  08919	eb 34		 jmp	 SHORT $LN2@GS_GDReqAl
$LN1@GS_GDReqAl:

; 4748 : 	}
; 4749 : 
; 4750 : 	CSP_REQ_ALLGUILDREGINFO pMsg;
; 4751 : 
; 4752 : 	pMsg.h.set((LPBYTE)&pMsg, 0x83, sizeof(CSP_REQ_ALLGUILDREGINFO));

  0891b	6a 0c		 push	 12			; 0000000cH
  0891d	68 83 00 00 00	 push	 131			; 00000083H
  08922	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  08925	50		 push	 eax
  08926	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08929	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 4753 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0892e	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08932	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4754 : 	pMsg.iIndex = aIndex;

  08936	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  08939	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4755 : 
; 4756 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0893c	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08940	50		 push	 eax
  08941	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08944	51		 push	 ecx
  08945	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0894a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqAl:

; 4757 : }

  0894f	5f		 pop	 edi
  08950	5e		 pop	 esi
  08951	5b		 pop	 ebx
  08952	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08955	33 cd		 xor	 ecx, ebp
  08957	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0895c	8b e5		 mov	 esp, ebp
  0895e	5d		 pop	 ebp
  0895f	c3		 ret	 0
?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ENDP		; GS_GDReqAllGuildMarkRegInfo
_TEXT	ENDS
PUBLIC	?GS_GDReqCalcRegGuildList@@YAXH@Z		; GS_GDReqCalcRegGuildList
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqCalcRegGuildList@@YAXH@Z PROC			; GS_GDReqCalcRegGuildList

; 4772 : {

  08960	55		 push	 ebp
  08961	8b ec		 mov	 ebp, esp
  08963	83 ec 48	 sub	 esp, 72			; 00000048H
  08966	53		 push	 ebx
  08967	56		 push	 esi
  08968	57		 push	 edi

; 4773 : 	if ( iMapSvrGroup < 0 )

  08969	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  0896d	7d 02		 jge	 SHORT $LN1@GS_GDReqCa@11

; 4774 : 	{
; 4775 : 		return;

  0896f	eb 2e		 jmp	 SHORT $LN2@GS_GDReqCa@11
$LN1@GS_GDReqCa@11:

; 4776 : 	}
; 4777 : 
; 4778 : 	CSP_REQ_CALCREGGUILDLIST pMsg;
; 4779 : 
; 4780 : 	pMsg.h.set((LPBYTE)&pMsg, 0x85, sizeof(CSP_REQ_CALCREGGUILDLIST));

  08971	6a 06		 push	 6
  08973	68 85 00 00 00	 push	 133			; 00000085H
  08978	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0897b	50		 push	 eax
  0897c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0897f	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 4781 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  08984	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  08988	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4782 : 
; 4783 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0898c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  08990	50		 push	 eax
  08991	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  08994	51		 push	 ecx
  08995	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0899a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqCa@11:

; 4784 : }

  0899f	5f		 pop	 edi
  089a0	5e		 pop	 esi
  089a1	5b		 pop	 ebx
  089a2	8b e5		 mov	 esp, ebp
  089a4	5d		 pop	 ebp
  089a5	c3		 ret	 0
?GS_GDReqCalcRegGuildList@@YAXH@Z ENDP			; GS_GDReqCalcRegGuildList
_TEXT	ENDS
PUBLIC	?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z		; GS_GDReqCsLoadTotalGuildInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z PROC		; GS_GDReqCsLoadTotalGuildInfo

; 4799 : {

  089b0	55		 push	 ebp
  089b1	8b ec		 mov	 ebp, esp
  089b3	83 ec 48	 sub	 esp, 72			; 00000048H
  089b6	53		 push	 ebx
  089b7	56		 push	 esi
  089b8	57		 push	 edi

; 4800 : 	if ( iMapSvrGroup < 0 )

  089b9	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  089bd	7d 02		 jge	 SHORT $LN1@GS_GDReqCs

; 4801 : 	{
; 4802 : 		return;

  089bf	eb 2e		 jmp	 SHORT $LN2@GS_GDReqCs
$LN1@GS_GDReqCs:

; 4803 : 	}
; 4804 : 
; 4805 : 	CSP_REQ_CSLOADTOTALGUILDINFO pMsg;
; 4806 : 
; 4807 : 	pMsg.h.set((LPBYTE)&pMsg, 0x88, sizeof(CSP_REQ_CSLOADTOTALGUILDINFO));

  089c1	6a 06		 push	 6
  089c3	68 88 00 00 00	 push	 136			; 00000088H
  089c8	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  089cb	50		 push	 eax
  089cc	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  089cf	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 4808 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  089d4	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  089d8	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4809 : 
; 4810 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  089dc	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  089e0	50		 push	 eax
  089e1	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  089e4	51		 push	 ecx
  089e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  089ea	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GS_GDReqCs:

; 4811 : }

  089ef	5f		 pop	 edi
  089f0	5e		 pop	 esi
  089f1	5b		 pop	 ebx
  089f2	8b e5		 mov	 esp, ebp
  089f4	5d		 pop	 ebp
  089f5	c3		 ret	 0
?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z ENDP		; GS_GDReqCsLoadTotalGuildInfo
_TEXT	ENDS
PUBLIC	??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	?GetMapSvrGroup@CMapServerManager@@QAEHXZ	; CMapServerManager::GetMapSvrGroup
;	COMDAT ??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x00] GS_DGAnsCastleTotalInfo()'
	DB	' - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleTotalInfo@@YAXPAE@Z PROC			; GS_DGAnsCastleTotalInfo

; 4842 : {

  08a00	55		 push	 ebp
  08a01	8b ec		 mov	 ebp, esp
  08a03	83 ec 44	 sub	 esp, 68			; 00000044H
  08a06	53		 push	 ebx
  08a07	56		 push	 esi
  08a08	57		 push	 edi

; 4843 : //#if(GS_CASTLE==1)
; 4844 : 	CSP_ANS_CASTLEDATA* lpMsg = (CSP_ANS_CASTLEDATA*)lpRecv;

  08a09	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  08a0c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 4845 : 
; 4846 : 	if(lpMsg == NULL)

  08a0f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  08a13	75 02		 jne	 SHORT $LN2@GS_DGAnsCa

; 4847 : 		return;

  08a15	eb 25		 jmp	 SHORT $LN3@GS_DGAnsCa
$LN2@GS_DGAnsCa:

; 4848 : 
; 4849 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  08a17	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08a1a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  08a1e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  08a23	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  08a28	3b f0		 cmp	 esi, eax
  08a2a	74 10		 je	 SHORT $LN3@GS_DGAnsCa

; 4850 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x00] GS_DGAnsCastleTotalInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  08a2c	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  08a31	6a 02		 push	 2
  08a33	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08a39	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsCa:

; 4851 : //#else
; 4852 : //	return;
; 4853 : //#endif
; 4854 : }

  08a3c	5f		 pop	 edi
  08a3d	5e		 pop	 esi
  08a3e	5b		 pop	 ebx
  08a3f	8b e5		 mov	 esp, ebp
  08a41	5d		 pop	 ebp
  08a42	c3		 ret	 0
?GS_DGAnsCastleTotalInfo@@YAXPAE@Z ENDP			; GS_DGAnsCastleTotalInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mapservermanager.h
_TEXT	ENDS
;	COMDAT ?GetMapSvrGroup@CMapServerManager@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMapSvrGroup@CMapServerManager@@QAEHXZ PROC		; CMapServerManager::GetMapSvrGroup, COMDAT
; _this$ = ecx

; 49   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 c0 4b 01
	00 00		 cmp	 DWORD PTR [eax+84928], 0
  00016	74 0f		 je	 SHORT $LN1@GetMapSvrG

; 51   : 		{
; 52   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 88 c0 4b 01
	00		 mov	 ecx, DWORD PTR [eax+84928]
  00021	0f b6 41 08	 movzx	 eax, BYTE PTR [ecx+8]
  00025	eb 03		 jmp	 SHORT $LN2@GetMapSvrG
$LN1@GetMapSvrG:

; 53   : 		}
; 54   : 		return -1;

  00027	83 c8 ff	 or	 eax, -1
$LN2@GetMapSvrG:

; 55   : 	}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?GetMapSvrGroup@CMapServerManager@@QAEHXZ ENDP		; CMapServerManager::GetMapSvrGroup
_TEXT	ENDS
EXTRN	?GCAnsCastleSiegeState@@YAXHHPAD0@Z:PROC	; GCAnsCastleSiegeState
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z PROC		; GS_DGAnsOwnerGuildMaster

; 4873 : {

  08a50	55		 push	 ebp
  08a51	8b ec		 mov	 ebp, esp
  08a53	83 ec 44	 sub	 esp, 68			; 00000044H
  08a56	53		 push	 ebx
  08a57	56		 push	 esi
  08a58	57		 push	 edi

; 4874 : //#if(GS_CASTLE==1)
; 4875 : 	CSP_ANS_OWNERGUILDMASTER* lpMsg = (CSP_ANS_OWNERGUILDMASTER*)lpRecv;

  08a59	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  08a5c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 4876 : 
; 4877 : 	if(lpMsg == NULL)

  08a5f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  08a63	75 02		 jne	 SHORT $LN2@GS_DGAnsOw

; 4878 : 		return;

  08a65	eb 4b		 jmp	 SHORT $LN3@GS_DGAnsOw
$LN2@GS_DGAnsOw:

; 4879 : 
; 4880 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  08a67	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08a6a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  08a6e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  08a73	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  08a78	3b f0		 cmp	 esi, eax
  08a7a	74 12		 je	 SHORT $LN1@GS_DGAnsOw

; 4881 : 	{
; 4882 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x00] GS_DGAnsCastleTotalInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  08a7c	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  08a81	6a 02		 push	 2
  08a83	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08a89	83 c4 08	 add	 esp, 8

; 4883 : 		return;

  08a8c	eb 24		 jmp	 SHORT $LN3@GS_DGAnsOw
$LN1@GS_DGAnsOw:

; 4884 : 	}
; 4885 : 
; 4886 : 	GCAnsCastleSiegeState(lpMsg->iIndex,lpMsg->iResult,lpMsg->szCastleOwnGuild,lpMsg->szCastleOwnGuildMaster);

  08a8e	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08a91	83 c0 18	 add	 eax, 24			; 00000018H
  08a94	50		 push	 eax
  08a95	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08a98	83 c1 10	 add	 ecx, 16			; 00000010H
  08a9b	51		 push	 ecx
  08a9c	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08a9f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  08aa2	50		 push	 eax
  08aa3	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08aa6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  08aa9	52		 push	 edx
  08aaa	e8 00 00 00 00	 call	 ?GCAnsCastleSiegeState@@YAXHHPAD0@Z ; GCAnsCastleSiegeState
  08aaf	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@GS_DGAnsOw:

; 4887 : //#else
; 4888 : //	return;
; 4889 : //#endif
; 4890 : }

  08ab2	5f		 pop	 edi
  08ab3	5e		 pop	 esi
  08ab4	5b		 pop	 ebx
  08ab5	8b e5		 mov	 esp, ebp
  08ab7	5d		 pop	 ebp
  08ab8	c3		 ret	 0
?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z ENDP		; GS_DGAnsOwnerGuildMaster
_TEXT	ENDS
PUBLIC	??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ ; `string'
PUBLIC	??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ ; `string'
PUBLIC	??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ ; `string'
PUBLIC	??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsNpcBuy@@YAXHHHH@Z:PROC			; GCAnsNpcBuy
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?AddDbNPC@CCastleSiege@@QAEHHH@Z:PROC		; CCastleSiege::AddDbNPC
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
;	COMDAT ??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
CONST	SEGMENT
??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcBuy() FAILED - Result:(%d), Npc:(CLS:%d'
	DB	', IDX:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
CONST	SEGMENT
??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() FAILED'
	DB	' - Npc:(CLS:%d, IDX:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
CONST	SEGMENT
??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() OK - N'
	DB	'pc:(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x03] GS_DGAnsCastleNpcBuy() - '
	DB	'lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_bAddResult$247316 = -8					; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcBuy@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcBuy

; 4906 : {

  08ac0	55		 push	 ebp
  08ac1	8b ec		 mov	 ebp, esp
  08ac3	83 ec 48	 sub	 esp, 72			; 00000048H
  08ac6	53		 push	 ebx
  08ac7	56		 push	 esi
  08ac8	57		 push	 edi

; 4907 : //#if(GS_CASTLE==1)
; 4908 : 	CSP_ANS_NPCBUY* lpMsg = (CSP_ANS_NPCBUY*)lpRecv;

  08ac9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  08acc	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 4909 : 
; 4910 : 	if(lpMsg == NULL)

  08acf	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  08ad3	75 05		 jne	 SHORT $LN8@GS_DGAnsCa@2

; 4911 : 		return;

  08ad5	e9 90 01 00 00	 jmp	 $LN9@GS_DGAnsCa@2
$LN8@GS_DGAnsCa@2:

; 4912 : 
; 4913 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  08ada	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08add	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  08ae1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  08ae6	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  08aeb	3b f0		 cmp	 esi, eax
  08aed	74 15		 je	 SHORT $LN7@GS_DGAnsCa@2

; 4914 : 	{
; 4915 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x03] GS_DGAnsCastleNpcBuy() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  08aef	68 00 00 00 00	 push	 OFFSET ??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  08af4	6a 02		 push	 2
  08af6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08afc	83 c4 08	 add	 esp, 8

; 4916 : 		return;

  08aff	e9 66 01 00 00	 jmp	 $LN9@GS_DGAnsCa@2
$LN7@GS_DGAnsCa@2:

; 4917 : 	}
; 4918 : 
; 4919 : 	if (lpMsg->iResult == 1)

  08b04	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08b07	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  08b0b	0f 85 12 01 00
	00		 jne	 $LN6@GS_DGAnsCa@2

; 4920 : 	{
; 4921 : 		BOOL bAddResult = g_CastleSiege.AddDbNPC(lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08b11	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08b14	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08b17	51		 push	 ecx
  08b18	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08b1b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08b1e	50		 push	 eax
  08b1f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  08b24	e8 00 00 00 00	 call	 ?AddDbNPC@CCastleSiege@@QAEHHH@Z ; CCastleSiege::AddDbNPC
  08b29	89 45 f8	 mov	 DWORD PTR _bAddResult$247316[ebp], eax

; 4922 : 	
; 4923 : 		if ( bAddResult == TRUE)

  08b2c	83 7d f8 01	 cmp	 DWORD PTR _bAddResult$247316[ebp], 1
  08b30	0f 85 cf 00 00
	00		 jne	 $LN5@GS_DGAnsCa@2

; 4924 : 		{
; 4925 : 			if(gObjIsConnected(lpMsg->iIndex))

  08b36	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08b39	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08b3c	51		 push	 ecx
  08b3d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  08b42	83 c4 04	 add	 esp, 4
  08b45	85 c0		 test	 eax, eax
  08b47	0f 84 9a 00 00
	00		 je	 $LN4@GS_DGAnsCa@2

; 4926 : 			{
; 4927 : 				gObj[lpMsg->iIndex].Money -= lpMsg->iBuyCost;

  08b4d	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08b50	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08b53	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08b59	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08b5f	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08b62	8b 8c 0a f0 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+240]
  08b69	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  08b6c	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08b6f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  08b72	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08b78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08b7e	89 8c 02 f0 00
	00 00		 mov	 DWORD PTR [edx+eax+240], ecx

; 4928 : 
; 4929 : 				if(gObj[lpMsg->iIndex].Money < 0 )

  08b85	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08b88	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08b8b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08b91	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08b97	83 bc 0a f0 00
	00 00 00	 cmp	 DWORD PTR [edx+ecx+240], 0
  08b9f	7d 1d		 jge	 SHORT $LN3@GS_DGAnsCa@2

; 4930 : 				{
; 4931 : 					gObj[lpMsg->iIndex].Money = 0;

  08ba1	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08ba4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08ba7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08bad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08bb3	c7 84 0a f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+240], 0
$LN3@GS_DGAnsCa@2:

; 4932 : 				}
; 4933 : 
; 4934 : 				GCMoneySend(lpMsg->iIndex,gObj[lpMsg->iIndex].Money);

  08bbe	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08bc1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08bc4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08bca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08bd0	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  08bd7	50		 push	 eax
  08bd8	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08bdb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  08bde	52		 push	 edx
  08bdf	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  08be4	83 c4 08	 add	 esp, 8
$LN4@GS_DGAnsCa@2:

; 4935 : 			}
; 4936 : 
; 4937 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() OK - Npc:(CLS:%d, IDX:%d)",lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08be7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08bea	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08bed	51		 push	 ecx
  08bee	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08bf1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08bf4	50		 push	 eax
  08bf5	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
  08bfa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08c00	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4938 : 		}
; 4939 : 		else

  08c03	eb 1c		 jmp	 SHORT $LN2@GS_DGAnsCa@2
$LN5@GS_DGAnsCa@2:

; 4940 : 		{
; 4941 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() FAILED - Npc:(CLS:%d, IDX:%d)",lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08c05	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08c08	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08c0b	51		 push	 ecx
  08c0c	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08c0f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08c12	50		 push	 eax
  08c13	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
  08c18	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08c1e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GS_DGAnsCa@2:

; 4942 : 		}
; 4943 : 	}
; 4944 : 	else

  08c21	eb 23		 jmp	 SHORT $LN1@GS_DGAnsCa@2
$LN6@GS_DGAnsCa@2:

; 4945 : 	{
; 4946 : 		LogAddTD("[CastleSiege] GS_DGAnsCastleNpcBuy() FAILED - Result:(%d), Npc:(CLS:%d, IDX:%d)",lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex); 

  08c23	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08c26	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08c29	51		 push	 ecx
  08c2a	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08c2d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08c30	50		 push	 eax
  08c31	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08c34	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08c37	52		 push	 edx
  08c38	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
  08c3d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08c43	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GS_DGAnsCa@2:

; 4947 : 	}
; 4948 : 
; 4949 : 	GCAnsNpcBuy(lpMsg->iIndex,lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08c46	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08c49	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08c4c	51		 push	 ecx
  08c4d	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08c50	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08c53	50		 push	 eax
  08c54	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08c57	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08c5a	52		 push	 edx
  08c5b	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08c5e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08c61	51		 push	 ecx
  08c62	e8 00 00 00 00	 call	 ?GCAnsNpcBuy@@YAXHHHH@Z	; GCAnsNpcBuy
  08c67	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@GS_DGAnsCa@2:

; 4950 : //#else
; 4951 : //	return;
; 4952 : //#endif
; 4953 : }

  08c6a	5f		 pop	 edi
  08c6b	5e		 pop	 esi
  08c6c	5b		 pop	 ebx
  08c6d	8b e5		 mov	 esp, ebp
  08c6f	5d		 pop	 ebp
  08c70	c3		 ret	 0
?GS_DGAnsCastleNpcBuy@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcBuy
_TEXT	ENDS
PUBLIC	??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ ; `string'
PUBLIC	??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ ; `string'
PUBLIC	??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ ; `string'
PUBLIC	??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsNpcRepair@@YAXHHHHHH@Z:PROC		; GCAnsNpcRepair
EXTRN	?RepairDbNPC@CCastleSiege@@QAEHHHHH@Z:PROC	; CCastleSiege::RepairDbNPC
;	COMDAT ??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
CONST	SEGMENT
??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcRepair() FAILED - Result:(%d), Npc:(CLS'
	DB	':%d, IDX:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
CONST	SEGMENT
??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() '
	DB	'FAILED - Npc:(CLS:%d, IDX:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
CONST	SEGMENT
??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() '
	DB	'OK - Npc:(CLS:%d, IDX:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x04] GS_DGAnsCastleNpcRepair()'
	DB	' - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_bRepairResult$247350 = -8				; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcRepair@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcRepair

; 4970 : {

  08c80	55		 push	 ebp
  08c81	8b ec		 mov	 ebp, esp
  08c83	83 ec 48	 sub	 esp, 72			; 00000048H
  08c86	53		 push	 ebx
  08c87	56		 push	 esi
  08c88	57		 push	 edi

; 4971 : //#if(GS_CASTLE==1)
; 4972 : 	CSP_ANS_NPCREPAIR* lpMsg = (CSP_ANS_NPCREPAIR*) lpRecv;

  08c89	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  08c8c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 4973 : 
; 4974 : 	if(lpMsg == NULL)

  08c8f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  08c93	75 05		 jne	 SHORT $LN8@GS_DGAnsCa@3

; 4975 : 		return;

  08c95	e9 ac 01 00 00	 jmp	 $LN9@GS_DGAnsCa@3
$LN8@GS_DGAnsCa@3:

; 4976 : 
; 4977 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  08c9a	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08c9d	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  08ca1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  08ca6	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  08cab	3b f0		 cmp	 esi, eax
  08cad	74 15		 je	 SHORT $LN7@GS_DGAnsCa@3

; 4978 : 	{
; 4979 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x04] GS_DGAnsCastleNpcRepair() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  08caf	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  08cb4	6a 02		 push	 2
  08cb6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08cbc	83 c4 08	 add	 esp, 8

; 4980 : 		return;

  08cbf	e9 82 01 00 00	 jmp	 $LN9@GS_DGAnsCa@3
$LN7@GS_DGAnsCa@3:

; 4981 : 	}
; 4982 : 
; 4983 : 	if(lpMsg->iResult == 1)

  08cc4	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08cc7	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  08ccb	0f 85 20 01 00
	00		 jne	 $LN6@GS_DGAnsCa@3

; 4984 : 	{
; 4985 : 		BOOL bRepairResult =  g_CastleSiege.RepairDbNPC(lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcHp,lpMsg->iNpcMaxHp);

  08cd1	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08cd4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  08cd7	51		 push	 ecx
  08cd8	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08cdb	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  08cde	50		 push	 eax
  08cdf	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08ce2	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  08ce5	52		 push	 edx
  08ce6	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08ce9	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  08cec	51		 push	 ecx
  08ced	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  08cf2	e8 00 00 00 00	 call	 ?RepairDbNPC@CCastleSiege@@QAEHHHHH@Z ; CCastleSiege::RepairDbNPC
  08cf7	89 45 f8	 mov	 DWORD PTR _bRepairResult$247350[ebp], eax

; 4986 : 		if( bRepairResult == TRUE)

  08cfa	83 7d f8 01	 cmp	 DWORD PTR _bRepairResult$247350[ebp], 1
  08cfe	0f 85 cf 00 00
	00		 jne	 $LN5@GS_DGAnsCa@3

; 4987 : 		{
; 4988 : 			if(gObjIsConnected(lpMsg->iIndex))

  08d04	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08d07	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08d0a	51		 push	 ecx
  08d0b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  08d10	83 c4 04	 add	 esp, 4
  08d13	85 c0		 test	 eax, eax
  08d15	0f 84 9a 00 00
	00		 je	 $LN4@GS_DGAnsCa@3

; 4989 : 			{
; 4990 : 				gObj[lpMsg->iIndex].Money -= lpMsg->iRepairCost;

  08d1b	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08d1e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08d21	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08d27	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d2d	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08d30	8b 8c 0a f0 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+240]
  08d37	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  08d3a	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08d3d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  08d40	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08d46	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d4c	89 8c 02 f0 00
	00 00		 mov	 DWORD PTR [edx+eax+240], ecx

; 4991 : 
; 4992 : 				if(gObj[lpMsg->iIndex].Money < 0 )

  08d53	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08d56	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08d59	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08d5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d65	83 bc 0a f0 00
	00 00 00	 cmp	 DWORD PTR [edx+ecx+240], 0
  08d6d	7d 1d		 jge	 SHORT $LN3@GS_DGAnsCa@3

; 4993 : 				{
; 4994 : 					gObj[lpMsg->iIndex].Money = 0;

  08d6f	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08d72	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08d75	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08d7b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d81	c7 84 0a f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+240], 0
$LN3@GS_DGAnsCa@3:

; 4995 : 				}
; 4996 : 
; 4997 : 				GCMoneySend(lpMsg->iIndex,gObj[lpMsg->iIndex].Money);

  08d8c	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08d8f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08d92	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08d98	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d9e	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  08da5	50		 push	 eax
  08da6	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08da9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  08dac	52		 push	 edx
  08dad	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  08db2	83 c4 08	 add	 esp, 8
$LN4@GS_DGAnsCa@3:

; 4998 : 			}
; 4999 : 
; 5000 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() OK - Npc:(CLS:%d, IDX:%d)",lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08db5	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08db8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08dbb	51		 push	 ecx
  08dbc	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08dbf	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08dc2	50		 push	 eax
  08dc3	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
  08dc8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08dce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5001 : 		}
; 5002 : 		else

  08dd1	eb 1c		 jmp	 SHORT $LN2@GS_DGAnsCa@3
$LN5@GS_DGAnsCa@3:

; 5003 : 		{
; 5004 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() FAILED - Npc:(CLS:%d, IDX:%d)",lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08dd3	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08dd6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08dd9	51		 push	 ecx
  08dda	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08ddd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08de0	50		 push	 eax
  08de1	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
  08de6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08dec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GS_DGAnsCa@3:

; 5005 : 		}
; 5006 : 	}
; 5007 : 	else

  08def	eb 23		 jmp	 SHORT $LN1@GS_DGAnsCa@3
$LN6@GS_DGAnsCa@3:

; 5008 : 	{
; 5009 : 		LogAddTD("[CastleSiege] GS_DGAnsCastleNpcRepair() FAILED - Result:(%d), Npc:(CLS:%d, IDX:%d)",lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  08df1	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08df4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08df7	51		 push	 ecx
  08df8	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08dfb	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08dfe	50		 push	 eax
  08dff	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08e02	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08e05	52		 push	 edx
  08e06	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
  08e0b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08e11	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GS_DGAnsCa@3:

; 5010 : 	}
; 5011 : 
; 5012 : 	GCAnsNpcRepair(lpMsg->iIndex,lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcHp,lpMsg->iNpcMaxHp);

  08e14	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08e17	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  08e1a	51		 push	 ecx
  08e1b	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08e1e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  08e21	50		 push	 eax
  08e22	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08e25	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  08e28	52		 push	 edx
  08e29	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08e2c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  08e2f	51		 push	 ecx
  08e30	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08e33	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  08e36	50		 push	 eax
  08e37	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08e3a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  08e3d	52		 push	 edx
  08e3e	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair
  08e43	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@GS_DGAnsCa@3:

; 5013 : //#else
; 5014 : //	return;
; 5015 : //#endif
; 5016 : }

  08e46	5f		 pop	 edi
  08e47	5e		 pop	 esi
  08e48	5b		 pop	 ebx
  08e49	8b e5		 mov	 esp, ebp
  08e4b	5d		 pop	 ebp
  08e4c	c3		 ret	 0
?GS_DGAnsCastleNpcRepair@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcRepair
_TEXT	ENDS
PUBLIC	??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@ ; `string'
PUBLIC	??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@ ; `string'
PUBLIC	??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsNpcUpgrade@@YAXHHHHHH@Z:PROC		; GCAnsNpcUpgrade
EXTRN	?UpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z:PROC	; CCastleSiege::UpgradeDbNPC
;	COMDAT ??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@
CONST	SEGMENT
??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@ DB '['
	DB	'CastleSiege] [0x80][0x06] GS_DGAnsTaxInfo() - Npc Upgrade OK '
	DB	'(CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@
CONST	SEGMENT
??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@ DB '[Cast'
	DB	'leSiege] ERROR - Castle NPC Upgrade Fail() (CLS:%d, IDX:%d, U'
	DB	'PTYPE:%d, UPVAL:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x05] GS_DGAnsCastleNpcUpgrade('
	DB	') - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z PROC		; GS_DGAnsCastleNpcUpgrade

; 5033 : {

  08e50	55		 push	 ebp
  08e51	8b ec		 mov	 ebp, esp
  08e53	83 ec 44	 sub	 esp, 68			; 00000044H
  08e56	53		 push	 ebx
  08e57	56		 push	 esi
  08e58	57		 push	 edi

; 5034 : //#if (GS_CASTLE==1)
; 5035 : 	CSP_ANS_NPCUPGRADE* lpMsg = (CSP_ANS_NPCUPGRADE*)lpRecv;

  08e59	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  08e5c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5036 : 
; 5037 : 	if(lpMsg == NULL)

  08e5f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  08e63	75 05		 jne	 SHORT $LN4@GS_DGAnsCa@4

; 5038 : 		return;

  08e65	e9 f1 00 00 00	 jmp	 $LN5@GS_DGAnsCa@4
$LN4@GS_DGAnsCa@4:

; 5039 : 
; 5040 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  08e6a	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08e6d	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  08e71	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  08e76	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  08e7b	3b f0		 cmp	 esi, eax
  08e7d	74 15		 je	 SHORT $LN3@GS_DGAnsCa@4

; 5041 : 	{
; 5042 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x05] GS_DGAnsCastleNpcUpgrade() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  08e7f	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  08e84	6a 02		 push	 2
  08e86	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08e8c	83 c4 08	 add	 esp, 8

; 5043 : 		return;

  08e8f	e9 c7 00 00 00	 jmp	 $LN5@GS_DGAnsCa@4
$LN3@GS_DGAnsCa@4:

; 5044 : 	}
; 5045 : 
; 5046 : 	if(lpMsg->iResult == 0)

  08e94	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08e97	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  08e9b	75 2e		 jne	 SHORT $LN2@GS_DGAnsCa@4

; 5047 : 	{
; 5048 : 		LogAddC(2,"[CastleSiege] ERROR - Castle NPC Upgrade Fail() (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  08e9d	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08ea0	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  08ea3	51		 push	 ecx
  08ea4	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08ea7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  08eaa	50		 push	 eax
  08eab	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08eae	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  08eb1	52		 push	 edx
  08eb2	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08eb5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  08eb8	51		 push	 ecx
  08eb9	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@
  08ebe	6a 02		 push	 2
  08ec0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08ec6	83 c4 18	 add	 esp, 24			; 00000018H

; 5049 : 	}
; 5050 : 	else

  08ec9	eb 5e		 jmp	 SHORT $LN1@GS_DGAnsCa@4
$LN2@GS_DGAnsCa@4:

; 5051 : 	{
; 5052 : 		g_CastleSiege.UpgradeDbNPC(lpMsg->iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,lpMsg->iNpcUpIndex);

  08ecb	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08ece	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  08ed1	51		 push	 ecx
  08ed2	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08ed5	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  08ed8	50		 push	 eax
  08ed9	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08edc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  08edf	52		 push	 edx
  08ee0	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08ee3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08ee6	51		 push	 ecx
  08ee7	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08eea	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  08eed	50		 push	 eax
  08eee	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08ef1	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  08ef4	52		 push	 edx
  08ef5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  08efa	e8 00 00 00 00	 call	 ?UpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z ; CCastleSiege::UpgradeDbNPC

; 5053 : 		LogAddTD("[CastleSiege] [0x80][0x06] GS_DGAnsTaxInfo() - Npc Upgrade OK (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",lpMsg->iNpcNumber, lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  08eff	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08f02	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  08f05	51		 push	 ecx
  08f06	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08f09	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  08f0c	50		 push	 eax
  08f0d	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08f10	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  08f13	52		 push	 edx
  08f14	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08f17	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  08f1a	51		 push	 ecx
  08f1b	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@
  08f20	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08f26	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@GS_DGAnsCa@4:

; 5054 : 	}
; 5055 : 
; 5056 : 	GCAnsNpcUpgrade(lpMsg->iIndex,lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  08f29	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08f2c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  08f2f	51		 push	 ecx
  08f30	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08f33	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  08f36	50		 push	 eax
  08f37	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08f3a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  08f3d	52		 push	 edx
  08f3e	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08f41	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  08f44	51		 push	 ecx
  08f45	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08f48	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  08f4b	50		 push	 eax
  08f4c	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08f4f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  08f52	52		 push	 edx
  08f53	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  08f58	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@GS_DGAnsCa@4:

; 5057 : 
; 5058 : //#else
; 5059 : //	return;
; 5060 : //#endif
; 5061 : }

  08f5b	5f		 pop	 edi
  08f5c	5e		 pop	 esi
  08f5d	5b		 pop	 ebx
  08f5e	8b e5		 mov	 esp, ebp
  08f60	5d		 pop	 ebp
  08f61	c3		 ret	 0
?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z ENDP		; GS_DGAnsCastleNpcUpgrade
_TEXT	ENDS
PUBLIC	??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?SetCastleMoney@CCastleSiege@@QAEX_J@Z:PROC	; CCastleSiege::SetCastleMoney
EXTRN	?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z:PROC		; GCAnsTaxMoneyInfo
;	COMDAT ??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x06] GS_DGAnsTaxInfo() - lpMsg'
	DB	'->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsTaxInfo@@YAXPAE@Z PROC				; GS_DGAnsTaxInfo

; 5077 : {

  08f70	55		 push	 ebp
  08f71	8b ec		 mov	 ebp, esp
  08f73	83 ec 44	 sub	 esp, 68			; 00000044H
  08f76	53		 push	 ebx
  08f77	56		 push	 esi
  08f78	57		 push	 edi

; 5078 : //#if(GS_CASTLE==1)
; 5079 : 	CSP_ANS_TAXINFO* lpMsg = (CSP_ANS_TAXINFO*)lpRecv;

  08f79	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  08f7c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5080 : 
; 5081 : 	if(lpMsg == NULL)

  08f7f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  08f83	75 02		 jne	 SHORT $LN3@GS_DGAnsTa

; 5082 : 		return;

  08f85	eb 76		 jmp	 SHORT $LN4@GS_DGAnsTa
$LN3@GS_DGAnsTa:

; 5083 : 	
; 5084 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  08f87	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08f8a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  08f8e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  08f93	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  08f98	3b f0		 cmp	 esi, eax
  08f9a	74 12		 je	 SHORT $LN2@GS_DGAnsTa

; 5085 : 	{
; 5086 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x06] GS_DGAnsTaxInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  08f9c	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  08fa1	6a 02		 push	 2
  08fa3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  08fa9	83 c4 08	 add	 esp, 8

; 5087 : 		return;

  08fac	eb 4f		 jmp	 SHORT $LN4@GS_DGAnsTa
$LN2@GS_DGAnsTa:

; 5088 : 	}
; 5089 : 
; 5090 : 	if(lpMsg->iResult == TRUE)

  08fae	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08fb1	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  08fb5	75 46		 jne	 SHORT $LN4@GS_DGAnsTa

; 5091 : 	{
; 5092 : 		GCAnsTaxMoneyInfo(lpMsg->iIndex,lpMsg->iResult,lpMsg->iTaxRateChaos,lpMsg->iTaxRateStore,lpMsg->i64CastleMoney);

  08fb7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08fba	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08fbd	51		 push	 ecx
  08fbe	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  08fc1	52		 push	 edx
  08fc2	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08fc5	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  08fc9	51		 push	 ecx
  08fca	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  08fcd	0f b6 42 18	 movzx	 eax, BYTE PTR [edx+24]
  08fd1	50		 push	 eax
  08fd2	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  08fd5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08fd8	52		 push	 edx
  08fd9	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08fdc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08fdf	51		 push	 ecx
  08fe0	e8 00 00 00 00	 call	 ?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z ; GCAnsTaxMoneyInfo
  08fe5	83 c4 18	 add	 esp, 24			; 00000018H

; 5093 : 		g_CastleSiege.SetCastleMoney(lpMsg->i64CastleMoney);

  08fe8	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  08feb	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  08fee	51		 push	 ecx
  08fef	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  08ff2	52		 push	 edx
  08ff3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  08ff8	e8 00 00 00 00	 call	 ?SetCastleMoney@CCastleSiege@@QAEX_J@Z ; CCastleSiege::SetCastleMoney
$LN4@GS_DGAnsTa:

; 5094 : 	}
; 5095 : //#else
; 5096 : //	return;
; 5097 : //#endif
; 5098 : }

  08ffd	5f		 pop	 edi
  08ffe	5e		 pop	 esi
  08fff	5b		 pop	 ebx
  09000	8b e5		 mov	 esp, ebp
  09002	5d		 pop	 ebp
  09003	c3		 ret	 0
?GS_DGAnsTaxInfo@@YAXPAE@Z ENDP				; GS_DGAnsTaxInfo
_TEXT	ENDS
PUBLIC	??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsTaxRateChange@@YAXHHEH@Z:PROC		; GCAnsTaxRateChange
EXTRN	?SetTaxRate@CCastleSiege@@QAEXHH@Z:PROC		; CCastleSiege::SetTaxRate
;	COMDAT ??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x07] GS_DGAnsTaxRateChange() -'
	DB	' lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsTaxRateChange@@YAXPAE@Z PROC			; GS_DGAnsTaxRateChange

; 5112 : {

  09010	55		 push	 ebp
  09011	8b ec		 mov	 ebp, esp
  09013	83 ec 44	 sub	 esp, 68			; 00000044H
  09016	53		 push	 ebx
  09017	56		 push	 esi
  09018	57		 push	 edi

; 5113 : //#if(GS_CASTLE==1)
; 5114 : 	CSP_ANS_TAXRATECHANGE* lpMsg = (CSP_ANS_TAXRATECHANGE*)lpRecv;

  09019	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0901c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5115 : 
; 5116 : 	if(lpMsg == NULL)

  0901f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09023	75 02		 jne	 SHORT $LN3@GS_DGAnsTa@2

; 5117 : 		return;

  09025	eb 6d		 jmp	 SHORT $LN4@GS_DGAnsTa@2
$LN3@GS_DGAnsTa@2:

; 5118 : 
; 5119 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09027	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0902a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0902e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09033	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09038	3b f0		 cmp	 esi, eax
  0903a	74 12		 je	 SHORT $LN2@GS_DGAnsTa@2

; 5120 : 	{
; 5121 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x07] GS_DGAnsTaxRateChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0903c	68 00 00 00 00	 push	 OFFSET ??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09041	6a 02		 push	 2
  09043	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09049	83 c4 08	 add	 esp, 8

; 5122 : 		return;

  0904c	eb 46		 jmp	 SHORT $LN4@GS_DGAnsTa@2
$LN2@GS_DGAnsTa@2:

; 5123 : 	}
; 5124 : 
; 5125 : 	if(lpMsg->iResult == 1)

  0904e	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09051	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09055	75 3d		 jne	 SHORT $LN4@GS_DGAnsTa@2

; 5126 : 	{
; 5127 : 		g_CastleSiege.SetTaxRate(lpMsg->iTaxKind,lpMsg->iTaxRate);

  09057	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0905a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0905d	51		 push	 ecx
  0905e	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  09061	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  09064	50		 push	 eax
  09065	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0906a	e8 00 00 00 00	 call	 ?SetTaxRate@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SetTaxRate

; 5128 : 		GCAnsTaxRateChange(lpMsg->iIndex,lpMsg->iResult,lpMsg->iTaxKind,lpMsg->iTaxRate);

  0906f	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09072	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  09075	51		 push	 ecx
  09076	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  09079	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  0907d	50		 push	 eax
  0907e	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  09081	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  09084	52		 push	 edx
  09085	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09088	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0908b	51		 push	 ecx
  0908c	e8 00 00 00 00	 call	 ?GCAnsTaxRateChange@@YAXHHEH@Z ; GCAnsTaxRateChange
  09091	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@GS_DGAnsTa@2:

; 5129 : 	}
; 5130 : //#else
; 5131 : //	return;
; 5132 : //#endif
; 5133 : }

  09094	5f		 pop	 edi
  09095	5e		 pop	 esi
  09096	5b		 pop	 ebx
  09097	8b e5		 mov	 esp, ebp
  09099	5d		 pop	 ebp
  0909a	c3		 ret	 0
?GS_DGAnsTaxRateChange@@YAXPAE@Z ENDP			; GS_DGAnsTaxRateChange
_TEXT	ENDS
PUBLIC	??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@ ; `string'
PUBLIC	??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsMoneyDrawOut@@YAXHH_J@Z:PROC		; GCAnsMoneyDrawOut
;	COMDAT ??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@
CONST	SEGMENT
??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@ DB '['
	DB	'CastleSiege] [0x80][0x08] GS_DGAnsCastleMoneyChange() - Withd'
	DB	'raw Request OK [%s][%s] (ReqMoney:%d, TotMoney:%I64d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x08] GS_DGAnsCastleMoneyChange'
	DB	'() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleMoneyChange@@YAXPAE@Z PROC		; GS_DGAnsCastleMoneyChange

; 5147 : {

  090a0	55		 push	 ebp
  090a1	8b ec		 mov	 ebp, esp
  090a3	83 ec 44	 sub	 esp, 68			; 00000044H
  090a6	53		 push	 ebx
  090a7	56		 push	 esi
  090a8	57		 push	 edi

; 5148 : //#if(GS_CASTLE==1)
; 5149 : 	CSP_ANS_MONEYCHANGE* lpMsg = (CSP_ANS_MONEYCHANGE*)lpRecv;

  090a9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  090ac	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5150 : 
; 5151 : 	if(lpMsg == NULL)

  090af	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  090b3	75 05		 jne	 SHORT $LN6@GS_DGAnsCa@5

; 5152 : 		return;

  090b5	e9 7c 01 00 00	 jmp	 $LN7@GS_DGAnsCa@5
$LN6@GS_DGAnsCa@5:

; 5153 : 
; 5154 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  090ba	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  090bd	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  090c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  090c6	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  090cb	3b f0		 cmp	 esi, eax
  090cd	74 15		 je	 SHORT $LN5@GS_DGAnsCa@5

; 5155 : 	{
; 5156 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x08] GS_DGAnsCastleMoneyChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  090cf	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  090d4	6a 02		 push	 2
  090d6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  090dc	83 c4 08	 add	 esp, 8

; 5157 : 		return;

  090df	e9 52 01 00 00	 jmp	 $LN7@GS_DGAnsCa@5
$LN5@GS_DGAnsCa@5:

; 5158 : 	}
; 5159 : 
; 5160 : 	if(lpMsg->iResult == TRUE)

  090e4	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  090e7	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  090eb	0f 85 24 01 00
	00		 jne	 $LN4@GS_DGAnsCa@5

; 5161 : 	{
; 5162 : 		if(gObjIsConnected(lpMsg->iIndex))

  090f1	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  090f4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  090f7	51		 push	 ecx
  090f8	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  090fd	83 c4 04	 add	 esp, 4
  09100	85 c0		 test	 eax, eax
  09102	0f 84 f8 00 00
	00		 je	 $LN3@GS_DGAnsCa@5

; 5163 : 		{
; 5164 : 			if(lpMsg->iMoneyChanged < 0)

  09108	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0910b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0910f	0f 8d eb 00 00
	00		 jge	 $LN3@GS_DGAnsCa@5

; 5165 : 			{
; 5166 : 				gObj[lpMsg->iIndex].Money -= lpMsg->iMoneyChanged;

  09115	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09118	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0911b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09121	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09127	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0912a	8b 8c 0a f0 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+240]
  09131	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  09134	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  09137	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0913a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09140	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09146	89 8c 02 f0 00
	00 00		 mov	 DWORD PTR [edx+eax+240], ecx

; 5167 : 
; 5168 : 				if(gObj[lpMsg->iIndex].Money > MAX_ZEN)

  0914d	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09150	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09153	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09159	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0915f	81 bc 0a f0 00
	00 00 00 94 35
	77		 cmp	 DWORD PTR [edx+ecx+240], 2000000000 ; 77359400H
  0916a	7e 1d		 jle	 SHORT $LN1@GS_DGAnsCa@5

; 5169 : 				{
; 5170 : 					gObj[lpMsg->iIndex].Money = MAX_ZEN;

  0916c	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0916f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09172	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09178	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0917e	c7 84 0a f0 00
	00 00 00 94 35
	77		 mov	 DWORD PTR [edx+ecx+240], 2000000000 ; 77359400H
$LN1@GS_DGAnsCa@5:

; 5171 : 				}
; 5172 : 				GCMoneySend(lpMsg->iIndex,gObj[lpMsg->iIndex].Money);

  09189	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0918c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0918f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09195	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0919b	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  091a2	50		 push	 eax
  091a3	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  091a6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  091a9	52		 push	 edx
  091aa	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  091af	83 c4 08	 add	 esp, 8

; 5173 : 
; 5174 : 				LogAddTD("[CastleSiege] [0x80][0x08] GS_DGAnsCastleMoneyChange() - Withdraw Request OK [%s][%s] (ReqMoney:%d, TotMoney:%I64d)",gObj[lpMsg->iIndex].AccountID,
; 5175 : 				gObj[lpMsg->iIndex].Name,lpMsg->iMoneyChanged,lpMsg->i64CastleMoney);

  091b2	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  091b5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  091b8	51		 push	 ecx
  091b9	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  091bc	52		 push	 edx
  091bd	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  091c0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  091c3	51		 push	 ecx
  091c4	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  091c7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  091ca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  091d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  091d6	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  091da	52		 push	 edx
  091db	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  091de	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  091e1	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  091e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  091ed	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  091f1	50		 push	 eax
  091f2	68 00 00 00 00	 push	 OFFSET ??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@
  091f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  091fd	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@GS_DGAnsCa@5:

; 5176 : 			}
; 5177 : 		}
; 5178 : 		g_CastleSiege.SetCastleMoney(lpMsg->i64CastleMoney);

  09200	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09203	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  09206	51		 push	 ecx
  09207	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0920a	52		 push	 edx
  0920b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09210	e8 00 00 00 00	 call	 ?SetCastleMoney@CCastleSiege@@QAEX_J@Z ; CCastleSiege::SetCastleMoney
$LN4@GS_DGAnsCa@5:

; 5179 : 	}
; 5180 : 	
; 5181 : 	GCAnsMoneyDrawOut(lpMsg->iIndex,lpMsg->iResult,lpMsg->i64CastleMoney);

  09215	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09218	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0921b	51		 push	 ecx
  0921c	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0921f	52		 push	 edx
  09220	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09223	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  09226	51		 push	 ecx
  09227	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0922a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0922d	50		 push	 eax
  0922e	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut
  09233	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@GS_DGAnsCa@5:

; 5182 : //#else
; 5183 : //	return;
; 5184 : //#endif
; 5185 : }

  09236	5f		 pop	 edi
  09237	5e		 pop	 esi
  09238	5b		 pop	 ebx
  09239	8b e5		 mov	 esp, ebp
  0923b	5d		 pop	 ebp
  0923c	c3		 ret	 0
?GS_DGAnsCastleMoneyChange@@YAXPAE@Z ENDP		; GS_DGAnsCastleMoneyChange
_TEXT	ENDS
PUBLIC	??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x09] GS_DGAnsSiegeDateChange()'
	DB	' - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsSiegeDateChange@@YAXPAE@Z PROC			; GS_DGAnsSiegeDateChange

; 5203 : {

  09240	55		 push	 ebp
  09241	8b ec		 mov	 ebp, esp
  09243	83 ec 44	 sub	 esp, 68			; 00000044H
  09246	53		 push	 ebx
  09247	56		 push	 esi
  09248	57		 push	 edi

; 5204 : //#if(GS_CASTLE==1)
; 5205 : 	CSP_ANS_SDEDCHANGE* lpMsg = (CSP_ANS_SDEDCHANGE*)lpRecv;

  09249	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0924c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5206 : 
; 5207 : 	if(lpMsg == NULL)

  0924f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09253	75 02		 jne	 SHORT $LN2@GS_DGAnsSi

; 5208 : 		return;

  09255	eb 25		 jmp	 SHORT $LN3@GS_DGAnsSi
$LN2@GS_DGAnsSi:

; 5209 : 
; 5210 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09257	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0925a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0925e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09263	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09268	3b f0		 cmp	 esi, eax
  0926a	74 10		 je	 SHORT $LN3@GS_DGAnsSi

; 5211 : 	{
; 5212 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x09] GS_DGAnsSiegeDateChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0926c	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09271	6a 02		 push	 2
  09273	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09279	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsSi:

; 5213 : 		return;
; 5214 : 	}
; 5215 : //#else
; 5216 : //	return;
; 5217 : //#endif
; 5218 : }

  0927c	5f		 pop	 edi
  0927d	5e		 pop	 esi
  0927e	5b		 pop	 ebx
  0927f	8b e5		 mov	 esp, ebp
  09281	5d		 pop	 ebp
  09282	c3		 ret	 0
?GS_DGAnsSiegeDateChange@@YAXPAE@Z ENDP			; GS_DGAnsSiegeDateChange
_TEXT	ENDS
PUBLIC	??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z:PROC ; GCAnsGuildRegInfo
;	COMDAT ??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0A] GS_DGAnsGuildMarkRegInfo('
	DB	') - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z PROC		; GS_DGAnsGuildMarkRegInfo

; 5221 : {

  09290	55		 push	 ebp
  09291	8b ec		 mov	 ebp, esp
  09293	83 ec 44	 sub	 esp, 68			; 00000044H
  09296	53		 push	 ebx
  09297	56		 push	 esi
  09298	57		 push	 edi

; 5222 : //#if(GS_CASTLE==1)
; 5223 : 	CSP_ANS_GUILDREGINFO* lpMsg = (CSP_ANS_GUILDREGINFO*)lpRecv;

  09299	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0929c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5224 : 
; 5225 : 	if(lpMsg == NULL)

  0929f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  092a3	75 02		 jne	 SHORT $LN2@GS_DGAnsGu

; 5226 : 		return;

  092a5	eb 41		 jmp	 SHORT $LN3@GS_DGAnsGu
$LN2@GS_DGAnsGu:

; 5227 : 	
; 5228 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  092a7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  092aa	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  092ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  092b3	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  092b8	3b f0		 cmp	 esi, eax
  092ba	74 12		 je	 SHORT $LN1@GS_DGAnsGu

; 5229 : 	{
; 5230 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0A] GS_DGAnsGuildMarkRegInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  092bc	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  092c1	6a 02		 push	 2
  092c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  092c9	83 c4 08	 add	 esp, 8

; 5231 : 		return;

  092cc	eb 1a		 jmp	 SHORT $LN3@GS_DGAnsGu
$LN1@GS_DGAnsGu:

; 5232 : 	}
; 5233 : 
; 5234 : 	GCAnsGuildRegInfo(lpMsg->iIndex,lpMsg->iResult,lpMsg);

  092ce	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  092d1	50		 push	 eax
  092d2	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  092d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  092d8	52		 push	 edx
  092d9	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  092dc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  092df	51		 push	 ecx
  092e0	e8 00 00 00 00	 call	 ?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ; GCAnsGuildRegInfo
  092e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GS_DGAnsGu:

; 5235 : //#else
; 5236 : //	return;
; 5237 : //#endif
; 5238 : 
; 5239 : }

  092e8	5f		 pop	 edi
  092e9	5e		 pop	 esi
  092ea	5b		 pop	 ebx
  092eb	8b e5		 mov	 esp, ebp
  092ed	5d		 pop	 ebp
  092ee	c3		 ret	 0
?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z ENDP		; GS_DGAnsGuildMarkRegInfo
_TEXT	ENDS
PUBLIC	??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0B] GS_DGAnsSiegeEndedChange('
	DB	') - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsSiegeEndedChange@@YAXPAE@Z PROC		; GS_DGAnsSiegeEndedChange

; 5251 : {

  092f0	55		 push	 ebp
  092f1	8b ec		 mov	 ebp, esp
  092f3	83 ec 44	 sub	 esp, 68			; 00000044H
  092f6	53		 push	 ebx
  092f7	56		 push	 esi
  092f8	57		 push	 edi

; 5252 : //#if(GS_CASTLE==1)
; 5253 : 	CSP_ANS_SIEGEENDCHANGE* lpMsg = (CSP_ANS_SIEGEENDCHANGE*)lpRecv;

  092f9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  092fc	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5254 : 
; 5255 : 	if(lpMsg == NULL)

  092ff	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09303	75 02		 jne	 SHORT $LN2@GS_DGAnsSi@2

; 5256 : 		return;

  09305	eb 25		 jmp	 SHORT $LN3@GS_DGAnsSi@2
$LN2@GS_DGAnsSi@2:

; 5257 : 
; 5258 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09307	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0930a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0930e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09313	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09318	3b f0		 cmp	 esi, eax
  0931a	74 10		 je	 SHORT $LN3@GS_DGAnsSi@2

; 5259 : 	{
; 5260 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0B] GS_DGAnsSiegeEndedChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0931c	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09321	6a 02		 push	 2
  09323	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09329	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsSi@2:

; 5261 : 		return;
; 5262 : 	}
; 5263 : //#else
; 5264 : //	return;
; 5265 : //#endif
; 5266 : 
; 5267 : }

  0932c	5f		 pop	 edi
  0932d	5e		 pop	 esi
  0932e	5b		 pop	 ebx
  0932f	8b e5		 mov	 esp, ebp
  09331	5d		 pop	 ebp
  09332	c3		 ret	 0
?GS_DGAnsSiegeEndedChange@@YAXPAE@Z ENDP		; GS_DGAnsSiegeEndedChange
_TEXT	ENDS
PUBLIC	??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0C] GS_DGAnsCastleOwnerChange'
	DB	'() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleOwnerChange@@YAXPAE@Z PROC		; GS_DGAnsCastleOwnerChange

; 5284 : {

  09340	55		 push	 ebp
  09341	8b ec		 mov	 ebp, esp
  09343	83 ec 44	 sub	 esp, 68			; 00000044H
  09346	53		 push	 ebx
  09347	56		 push	 esi
  09348	57		 push	 edi

; 5285 : //#if(GS_CASTLE==1)
; 5286 : 	CSP_ANS_CASTLEOWNERCHANGE* lpMsg = (CSP_ANS_CASTLEOWNERCHANGE*)lpRecv;

  09349	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0934c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5287 : 
; 5288 : 	if(lpMsg == NULL)

  0934f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09353	75 02		 jne	 SHORT $LN2@GS_DGAnsCa@6

; 5289 : 		return;

  09355	eb 25		 jmp	 SHORT $LN3@GS_DGAnsCa@6
$LN2@GS_DGAnsCa@6:

; 5290 : 
; 5291 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09357	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0935a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0935e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09363	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09368	3b f0		 cmp	 esi, eax
  0936a	74 10		 je	 SHORT $LN3@GS_DGAnsCa@6

; 5292 : 	{
; 5293 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0C] GS_DGAnsCastleOwnerChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0936c	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09371	6a 02		 push	 2
  09373	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09379	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsCa@6:

; 5294 : 		return;
; 5295 : 	}
; 5296 : //#else
; 5297 : //	return;
; 5298 : //#endif
; 5299 : }

  0937c	5f		 pop	 edi
  0937d	5e		 pop	 esi
  0937e	5b		 pop	 ebx
  0937f	8b e5		 mov	 esp, ebp
  09381	5d		 pop	 ebp
  09382	c3		 ret	 0
?GS_DGAnsCastleOwnerChange@@YAXPAE@Z ENDP		; GS_DGAnsCastleOwnerChange
_TEXT	ENDS
PUBLIC	??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsRegCastleSiege@@YAXHHPAD@Z:PROC		; GCAnsRegCastleSiege
;	COMDAT ??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0D] GS_DGAnsRegAttackGuild() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsRegAttackGuild@@YAXPAE@Z PROC			; GS_DGAnsRegAttackGuild

; 5313 : {

  09390	55		 push	 ebp
  09391	8b ec		 mov	 ebp, esp
  09393	83 ec 44	 sub	 esp, 68			; 00000044H
  09396	53		 push	 ebx
  09397	56		 push	 esi
  09398	57		 push	 edi

; 5314 : //#if(GS_CASTLE==1)
; 5315 : 	CSP_ANS_REGATTACKGUILD* lpMsg = (CSP_ANS_REGATTACKGUILD*)lpRecv;

  09399	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0939c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5316 : 
; 5317 : 	if(lpMsg == NULL)

  0939f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  093a3	75 02		 jne	 SHORT $LN2@GS_DGAnsRe

; 5318 : 		return;

  093a5	eb 44		 jmp	 SHORT $LN3@GS_DGAnsRe
$LN2@GS_DGAnsRe:

; 5319 : 
; 5320 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  093a7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  093aa	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  093ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  093b3	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  093b8	3b f0		 cmp	 esi, eax
  093ba	74 12		 je	 SHORT $LN1@GS_DGAnsRe

; 5321 : 	{
; 5322 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0D] GS_DGAnsRegAttackGuild() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  093bc	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  093c1	6a 02		 push	 2
  093c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  093c9	83 c4 08	 add	 esp, 8

; 5323 : 		return;

  093cc	eb 1d		 jmp	 SHORT $LN3@GS_DGAnsRe
$LN1@GS_DGAnsRe:

; 5324 : 	}
; 5325 : 
; 5326 : 	GCAnsRegCastleSiege(lpMsg->iIndex,lpMsg->iResult,lpMsg->szEnemyGuildName);

  093ce	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  093d1	83 c0 10	 add	 eax, 16			; 00000010H
  093d4	50		 push	 eax
  093d5	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  093d8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  093db	52		 push	 edx
  093dc	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  093df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  093e2	51		 push	 ecx
  093e3	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  093e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GS_DGAnsRe:

; 5327 : //#else
; 5328 : //	return;
; 5329 : //#endif
; 5330 : }

  093eb	5f		 pop	 edi
  093ec	5e		 pop	 esi
  093ed	5b		 pop	 ebx
  093ee	8b e5		 mov	 esp, ebp
  093f0	5d		 pop	 ebp
  093f1	c3		 ret	 0
?GS_DGAnsRegAttackGuild@@YAXPAE@Z ENDP			; GS_DGAnsRegAttackGuild
_TEXT	ENDS
PUBLIC	??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?ResetCastleCycle@CCastleSiege@@QAEXXZ:PROC	; CCastleSiege::ResetCastleCycle
;	COMDAT ??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0E] GS_DGAnsRestartCastleStat'
	DB	'e() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsRestartCastleState@@YAXPAE@Z PROC		; GS_DGAnsRestartCastleState

; 5341 : {

  09400	55		 push	 ebp
  09401	8b ec		 mov	 ebp, esp
  09403	83 ec 44	 sub	 esp, 68			; 00000044H
  09406	53		 push	 ebx
  09407	56		 push	 esi
  09408	57		 push	 edi

; 5342 : //#if(GS_CASTLE==1)
; 5343 : 	CSP_ANS_CASTLESIEGEEND* lpMsg = (CSP_ANS_CASTLESIEGEEND*)lpRecv;

  09409	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0940c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5344 : 
; 5345 : 	if(lpMsg == NULL)

  0940f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09413	75 02		 jne	 SHORT $LN3@GS_DGAnsRe@2

; 5346 : 		return;

  09415	eb 33		 jmp	 SHORT $LN4@GS_DGAnsRe@2
$LN3@GS_DGAnsRe@2:

; 5347 : 
; 5348 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09417	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0941a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0941e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09423	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09428	3b f0		 cmp	 esi, eax
  0942a	74 14		 je	 SHORT $LN2@GS_DGAnsRe@2

; 5349 : 	{
; 5350 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0E] GS_DGAnsRestartCastleState() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0942c	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09431	6a 02		 push	 2
  09433	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09439	83 c4 08	 add	 esp, 8

; 5351 : 		return;

  0943c	eb 0c		 jmp	 SHORT $LN4@GS_DGAnsRe@2

; 5352 : 	}
; 5353 : 	else

  0943e	eb 0a		 jmp	 SHORT $LN4@GS_DGAnsRe@2
$LN2@GS_DGAnsRe@2:

; 5354 : 	{
; 5355 : 		g_CastleSiege.ResetCastleCycle();

  09440	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09445	e8 00 00 00 00	 call	 ?ResetCastleCycle@CCastleSiege@@QAEXXZ ; CCastleSiege::ResetCastleCycle
$LN4@GS_DGAnsRe@2:

; 5356 : 	}
; 5357 : //#else
; 5358 : //	return;
; 5359 : //#endif
; 5360 : }

  0944a	5f		 pop	 edi
  0944b	5e		 pop	 esi
  0944c	5b		 pop	 ebx
  0944d	8b e5		 mov	 esp, ebp
  0944f	5d		 pop	 ebp
  09450	c3		 ret	 0
?GS_DGAnsRestartCastleState@@YAXPAE@Z ENDP		; GS_DGAnsRestartCastleState
_TEXT	ENDS
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
PUBLIC	??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SendNoticeToAllUser@TNotice@@SAXPAX@Z:PROC	; TNotice::SendNoticeToAllUser
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	_memset:PROC
;	COMDAT ??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0F] GS_DGAnsMapSvrMsgMultiCas'
	DB	't() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pNotice$247590 = -424					; size = 272
_szNotice$ = -152					; size = 144
_lpMsg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z PROC		; GS_DGAnsMapSvrMsgMultiCast

; 5377 : {

  09460	55		 push	 ebp
  09461	8b ec		 mov	 ebp, esp
  09463	81 ec e8 01 00
	00		 sub	 esp, 488		; 000001e8H
  09469	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0946e	33 c5		 xor	 eax, ebp
  09470	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  09473	53		 push	 ebx
  09474	56		 push	 esi
  09475	57		 push	 edi

; 5378 : 	CSP_ANS_MAPSVRMULTICAST * lpMsg = (CSP_ANS_MAPSVRMULTICAST *)lpRecv;

  09476	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09479	89 45 f8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5379 : 
; 5380 : 	if ( lpMsg == NULL )

  0947c	83 7d f8 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09480	75 05		 jne	 SHORT $LN3@GS_DGAnsMa

; 5381 : 	{
; 5382 : 		return;

  09482	e9 ce 00 00 00	 jmp	 $LN4@GS_DGAnsMa
$LN3@GS_DGAnsMa:

; 5383 : 	}
; 5384 : 
; 5385 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  09487	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0948a	0f b7 70 04	 movzx	 esi, WORD PTR [eax+4]
  0948e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09493	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09498	3b f0		 cmp	 esi, eax
  0949a	74 15		 je	 SHORT $LN2@GS_DGAnsMa

; 5386 : 	{
; 5387 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x0F] GS_DGAnsMapSvrMsgMultiCast() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  0949c	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  094a1	6a 02		 push	 2
  094a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  094a9	83 c4 08	 add	 esp, 8

; 5388 : 		return;

  094ac	e9 a4 00 00 00	 jmp	 $LN4@GS_DGAnsMa
$LN2@GS_DGAnsMa:

; 5389 : 	}
; 5390 : 
; 5391 : 	char szNotice[144] = {0};

  094b1	c6 85 68 ff ff
	ff 00		 mov	 BYTE PTR _szNotice$[ebp], 0
  094b8	68 8f 00 00 00	 push	 143			; 0000008fH
  094bd	6a 00		 push	 0
  094bf	8d 85 69 ff ff
	ff		 lea	 eax, DWORD PTR _szNotice$[ebp+1]
  094c5	50		 push	 eax
  094c6	e8 00 00 00 00	 call	 _memset
  094cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5392 : 	memcpy(szNotice, lpMsg->szMsgText, 128);

  094ce	68 80 00 00 00	 push	 128			; 00000080H
  094d3	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  094d6	83 c0 06	 add	 eax, 6
  094d9	50		 push	 eax
  094da	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szNotice$[ebp]
  094e0	51		 push	 ecx
  094e1	e8 00 00 00 00	 call	 _memcpy
  094e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5393 : 
; 5394 : 	if ( strlen(szNotice) > 1 )

  094e9	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szNotice$[ebp]
  094ef	50		 push	 eax
  094f0	e8 00 00 00 00	 call	 _strlen
  094f5	83 c4 04	 add	 esp, 4
  094f8	83 f8 01	 cmp	 eax, 1
  094fb	76 58		 jbe	 SHORT $LN4@GS_DGAnsMa

; 5395 : 	{
; 5396 : 		PMSG_NOTICE pNotice;
; 5397 : 
; 5398 : 		TNotice::MakeNoticeMsg((TNotice *)&pNotice, 0, szNotice);

  094fd	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szNotice$[ebp]
  09503	50		 push	 eax
  09504	6a 00		 push	 0
  09506	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$247590[ebp]
  0950c	51		 push	 ecx
  0950d	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  09512	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5399 : 		TNotice::SetNoticeProperty((TNotice *)&pNotice, 0, _ARGB(255, 255, 200, 80), 1, 0, 20);

  09515	6a 14		 push	 20			; 00000014H
  09517	6a 00		 push	 0
  09519	6a 01		 push	 1
  0951b	6a 50		 push	 80			; 00000050H
  0951d	68 c8 00 00 00	 push	 200			; 000000c8H
  09522	68 ff 00 00 00	 push	 255			; 000000ffH
  09527	68 ff 00 00 00	 push	 255			; 000000ffH
  0952c	e8 00 00 00 00	 call	 ?_ARGB@@YAKEEEE@Z	; _ARGB
  09531	83 c4 10	 add	 esp, 16			; 00000010H
  09534	50		 push	 eax
  09535	6a 00		 push	 0
  09537	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$247590[ebp]
  0953d	50		 push	 eax
  0953e	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty
  09543	83 c4 18	 add	 esp, 24			; 00000018H

; 5400 : 		TNotice::SendNoticeToAllUser((TNotice *)&pNotice);

  09546	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$247590[ebp]
  0954c	50		 push	 eax
  0954d	e8 00 00 00 00	 call	 ?SendNoticeToAllUser@TNotice@@SAXPAX@Z ; TNotice::SendNoticeToAllUser
  09552	83 c4 04	 add	 esp, 4
$LN4@GS_DGAnsMa:

; 5401 : 	}
; 5402 : 
; 5403 : }

  09555	5f		 pop	 edi
  09556	5e		 pop	 esi
  09557	5b		 pop	 ebx
  09558	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0955b	33 cd		 xor	 ecx, ebp
  0955d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  09562	8b e5		 mov	 esp, ebp
  09564	5d		 pop	 ebp
  09565	c3		 ret	 0
?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z ENDP		; GS_DGAnsMapSvrMsgMultiCast
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tnotice.h
_TEXT	ENDS
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 9    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0000d	c1 e0 18	 shl	 eax, 24			; 00000018H
  00010	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  00014	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0001d	c1 e2 08	 shl	 edx, 8
  00020	03 c2		 add	 eax, edx
  00022	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00026	03 c1		 add	 eax, ecx
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
PUBLIC	??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z:PROC ; GCAnsRegGuildMark
;	COMDAT ??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Castl'
	DB	'eSiege] PACKET-ERROR [0x80][0x10] GS_DGAnsRegGuildMark() - lp'
	DB	'Msg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsRegGuildMark@@YAXPAE@Z PROC			; GS_DGAnsRegGuildMark

; 5406 : {

  09570	55		 push	 ebp
  09571	8b ec		 mov	 ebp, esp
  09573	83 ec 44	 sub	 esp, 68			; 00000044H
  09576	53		 push	 ebx
  09577	56		 push	 esi
  09578	57		 push	 edi

; 5407 : //#if(GS_CASTLE==1)
; 5408 : 	CSP_ANS_GUILDREGMARK* lpMsg = (CSP_ANS_GUILDREGMARK*)lpRecv;

  09579	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0957c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5409 : 		
; 5410 : 	if ( lpMsg == NULL )

  0957f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09583	75 02		 jne	 SHORT $LN3@GS_DGAnsRe@3

; 5411 : 	{
; 5412 : 		return;

  09585	eb 43		 jmp	 SHORT $LN4@GS_DGAnsRe@3
$LN3@GS_DGAnsRe@3:

; 5413 : 	}
; 5414 : 
; 5415 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  09587	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0958a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0958e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09593	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09598	3b f0		 cmp	 esi, eax
  0959a	74 14		 je	 SHORT $LN2@GS_DGAnsRe@3

; 5416 : 	{
; 5417 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x10] GS_DGAnsRegGuildMark() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  0959c	68 00 00 00 00	 push	 OFFSET ??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  095a1	6a 02		 push	 2
  095a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  095a9	83 c4 08	 add	 esp, 8

; 5418 : 		return;

  095ac	eb 1c		 jmp	 SHORT $LN4@GS_DGAnsRe@3

; 5419 : 	}
; 5420 : 	else

  095ae	eb 1a		 jmp	 SHORT $LN4@GS_DGAnsRe@3
$LN2@GS_DGAnsRe@3:

; 5421 : 	{
; 5422 : 		GCAnsRegGuildMark(lpMsg->iIndex,lpMsg->iResult,lpMsg);

  095b0	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  095b3	50		 push	 eax
  095b4	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  095b7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  095ba	52		 push	 edx
  095bb	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  095be	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  095c1	51		 push	 ecx
  095c2	e8 00 00 00 00	 call	 ?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ; GCAnsRegGuildMark
  095c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GS_DGAnsRe@3:

; 5423 : 	}
; 5424 : //#else
; 5425 : //	return;
; 5426 : //#endif
; 5427 : }

  095ca	5f		 pop	 edi
  095cb	5e		 pop	 esi
  095cc	5b		 pop	 ebx
  095cd	8b e5		 mov	 esp, ebp
  095cf	5d		 pop	 ebp
  095d0	c3		 ret	 0
?GS_DGAnsRegGuildMark@@YAXPAE@Z ENDP			; GS_DGAnsRegGuildMark
_TEXT	ENDS
PUBLIC	??_C@_0HM@BBDOKDO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0HM@BBDOKDO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HM@BBDOKDO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cast'
	DB	'leSiege] PACKET-ERROR [0x80][0x11] GS_DGAnsGuildMarkReset() -'
	DB	' lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsGuildMarkReset@@YAXPAE@Z PROC			; GS_DGAnsGuildMarkReset

; 5441 : {

  095e0	55		 push	 ebp
  095e1	8b ec		 mov	 ebp, esp
  095e3	83 ec 44	 sub	 esp, 68			; 00000044H
  095e6	53		 push	 ebx
  095e7	56		 push	 esi
  095e8	57		 push	 edi

; 5442 : //#if(GS_CASTLE==1)
; 5443 : 	CSP_ANS_GUILDRESETMARK* lpMsg = (CSP_ANS_GUILDRESETMARK*)lpRecv;

  095e9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  095ec	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5444 : 	
; 5445 : 	if ( lpMsg == NULL )

  095ef	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  095f3	75 02		 jne	 SHORT $LN2@GS_DGAnsGu@2

; 5446 : 	{
; 5447 : 		return;

  095f5	eb 25		 jmp	 SHORT $LN3@GS_DGAnsGu@2
$LN2@GS_DGAnsGu@2:

; 5448 : 	}
; 5449 : 
; 5450 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  095f7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  095fa	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  095fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09603	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09608	3b f0		 cmp	 esi, eax
  0960a	74 10		 je	 SHORT $LN3@GS_DGAnsGu@2

; 5451 : 	{
; 5452 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x11] GS_DGAnsGuildMarkReset() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  0960c	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@BBDOKDO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09611	6a 02		 push	 2
  09613	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09619	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsGu@2:

; 5453 : 		return;
; 5454 : 	}
; 5455 : //#else
; 5456 : //	return;
; 5457 : //#endif
; 5458 : }

  0961c	5f		 pop	 edi
  0961d	5e		 pop	 esi
  0961e	5b		 pop	 ebx
  0961f	8b e5		 mov	 esp, ebp
  09621	5d		 pop	 ebp
  09622	c3		 ret	 0
?GS_DGAnsGuildMarkReset@@YAXPAE@Z ENDP			; GS_DGAnsGuildMarkReset
_TEXT	ENDS
PUBLIC	??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z:PROC	; GCAnsGiveUpCastleSiege
;	COMDAT ??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x12] GS_DGAnsGuildSetGiveUp() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z PROC			; GS_DGAnsGuildSetGiveUp

; 5473 : {

  09630	55		 push	 ebp
  09631	8b ec		 mov	 ebp, esp
  09633	83 ec 44	 sub	 esp, 68			; 00000044H
  09636	53		 push	 ebx
  09637	56		 push	 esi
  09638	57		 push	 edi

; 5474 : //#if(GS_CASTLE==1)
; 5475 : 	CSP_ANS_GUILDSETGIVEUP* lpMsg = (CSP_ANS_GUILDSETGIVEUP*)lpRecv;

  09639	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0963c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5476 : 
; 5477 : 	if ( lpMsg == NULL )

  0963f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09643	75 02		 jne	 SHORT $LN2@GS_DGAnsGu@3

; 5478 : 	{
; 5479 : 		return;

  09645	eb 52		 jmp	 SHORT $LN3@GS_DGAnsGu@3
$LN2@GS_DGAnsGu@3:

; 5480 : 	}
; 5481 : 
; 5482 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  09647	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0964a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0964e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09653	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09658	3b f0		 cmp	 esi, eax
  0965a	74 12		 je	 SHORT $LN1@GS_DGAnsGu@3

; 5483 : 	{
; 5484 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x12] GS_DGAnsGuildSetGiveUp() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  0965c	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09661	6a 02		 push	 2
  09663	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09669	83 c4 08	 add	 esp, 8

; 5485 : 		return;

  0966c	eb 2b		 jmp	 SHORT $LN3@GS_DGAnsGu@3
$LN1@GS_DGAnsGu@3:

; 5486 : 	}
; 5487 : 	
; 5488 : 	::GCAnsGiveUpCastleSiege(lpMsg->iIndex,lpMsg->iResult,lpMsg->bIsGiveUp,lpMsg->iRegMarkCount,lpMsg->szGuildName);

  0966e	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09671	83 c0 10	 add	 eax, 16			; 00000010H
  09674	50		 push	 eax
  09675	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  09678	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0967b	52		 push	 edx
  0967c	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0967f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  09682	51		 push	 ecx
  09683	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  09686	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  09689	50		 push	 eax
  0968a	8b 4d fc	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0968d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  09690	52		 push	 edx
  09691	e8 00 00 00 00	 call	 ?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z ; GCAnsGiveUpCastleSiege
  09696	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@GS_DGAnsGu@3:

; 5489 : //#else
; 5490 : //	return;
; 5491 : //#endif
; 5492 : }

  09699	5f		 pop	 edi
  0969a	5e		 pop	 esi
  0969b	5b		 pop	 ebx
  0969c	8b e5		 mov	 esp, ebp
  0969e	5d		 pop	 ebp
  0969f	c3		 ret	 0
?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z ENDP			; GS_DGAnsGuildSetGiveUp
_TEXT	ENDS
PUBLIC	??_C@_0HH@NAPOKFHO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0HH@NAPOKFHO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HH@NAPOKFHO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x16] GS_DGAnsNpcRemove() - lpM'
	DB	'sg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsNpcRemove@@YAXPAE@Z PROC			; GS_DGAnsNpcRemove

; 5505 : {

  096a0	55		 push	 ebp
  096a1	8b ec		 mov	 ebp, esp
  096a3	83 ec 44	 sub	 esp, 68			; 00000044H
  096a6	53		 push	 ebx
  096a7	56		 push	 esi
  096a8	57		 push	 edi

; 5506 : //#if(GS_CASTLE==1)
; 5507 : 	CSP_ANS_NPCREMOVE* lpMsg = (CSP_ANS_NPCREMOVE*)lpRecv;

  096a9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  096ac	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5508 : 	
; 5509 : 	if ( lpMsg == NULL )

  096af	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  096b3	75 02		 jne	 SHORT $LN2@GS_DGAnsNp

; 5510 : 	{
; 5511 : 		return;

  096b5	eb 25		 jmp	 SHORT $LN3@GS_DGAnsNp
$LN2@GS_DGAnsNp:

; 5512 : 	}
; 5513 : 
; 5514 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  096b7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  096ba	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  096be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  096c3	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  096c8	3b f0		 cmp	 esi, eax
  096ca	74 10		 je	 SHORT $LN3@GS_DGAnsNp

; 5515 : 	{
; 5516 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x16] GS_DGAnsNpcRemove() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  096cc	68 00 00 00 00	 push	 OFFSET ??_C@_0HH@NAPOKFHO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  096d1	6a 02		 push	 2
  096d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  096d9	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsNp:

; 5517 : 		return;
; 5518 : 	}
; 5519 : //#else
; 5520 : //	return;
; 5521 : //#endif
; 5522 : }

  096dc	5f		 pop	 edi
  096dd	5e		 pop	 esi
  096de	5b		 pop	 ebx
  096df	8b e5		 mov	 esp, ebp
  096e1	5d		 pop	 ebp
  096e2	c3		 ret	 0
?GS_DGAnsNpcRemove@@YAXPAE@Z ENDP			; GS_DGAnsNpcRemove
_TEXT	ENDS
PUBLIC	?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z	; CCastleSiegeSync::SetTaxHuntZone
PUBLIC	?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z	; CCastleSiegeSync::SetTaxRateStore
PUBLIC	?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z	; CCastleSiegeSync::SetTaxRateChaos
PUBLIC	?SetCastleState@CCastleSiegeSync@@QAEXH@Z	; CCastleSiegeSync::SetCastleState
EXTRN	?SetCastleOwnerGuild@CCastleSiegeSync@@QAEXPAD@Z:PROC ; CCastleSiegeSync::SetCastleOwnerGuild
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleStateSync@@YAXPAE@Z PROC			; GS_DGAnsCastleStateSync

; 5543 : {

  096f0	55		 push	 ebp
  096f1	8b ec		 mov	 ebp, esp
  096f3	83 ec 44	 sub	 esp, 68			; 00000044H
  096f6	53		 push	 ebx
  096f7	56		 push	 esi
  096f8	57		 push	 edi

; 5544 : 	CSP_ANS_CASTLESTATESYNC * lpMsg = (CSP_ANS_CASTLESTATESYNC *)lpRecv;

  096f9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  096fc	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5545 : 
; 5546 : 	if ( lpMsg == NULL )

  096ff	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09703	75 02		 jne	 SHORT $LN2@GS_DGAnsCa@7

; 5547 : 	{
; 5548 : 		return;

  09705	eb 6c		 jmp	 SHORT $LN3@GS_DGAnsCa@7
$LN2@GS_DGAnsCa@7:

; 5549 : 	}
; 5550 : 
; 5551 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  09707	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0970a	0f b7 70 04	 movzx	 esi, WORD PTR [eax+4]
  0970e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09713	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09718	3b f0		 cmp	 esi, eax
  0971a	74 02		 je	 SHORT $LN1@GS_DGAnsCa@7

; 5552 : 	{
; 5553 : 		return;

  0971c	eb 55		 jmp	 SHORT $LN3@GS_DGAnsCa@7
$LN1@GS_DGAnsCa@7:

; 5554 : 	}
; 5555 : 
; 5556 : 	g_CastleSiegeSync.SetCastleState(lpMsg->iCastleState); 

  0971e	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09721	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  09724	51		 push	 ecx
  09725	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0972a	e8 00 00 00 00	 call	 ?SetCastleState@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::SetCastleState

; 5557 : 	g_CastleSiegeSync.SetTaxRateChaos(lpMsg->iTaxRateChaos);

  0972f	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09732	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09735	51		 push	 ecx
  09736	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0973b	e8 00 00 00 00	 call	 ?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::SetTaxRateChaos

; 5558 : 	g_CastleSiegeSync.SetTaxRateStore(lpMsg->iTaxRateStore);

  09740	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09743	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  09746	51		 push	 ecx
  09747	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0974c	e8 00 00 00 00	 call	 ?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::SetTaxRateStore

; 5559 : 	g_CastleSiegeSync.SetTaxHuntZone(lpMsg->iTaxHuntZone);

  09751	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09754	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  09757	51		 push	 ecx
  09758	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0975d	e8 00 00 00 00	 call	 ?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::SetTaxHuntZone

; 5560 : 	g_CastleSiegeSync.SetCastleOwnerGuild(lpMsg->szOwnerGuildName);

  09762	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09765	83 c0 18	 add	 eax, 24			; 00000018H
  09768	50		 push	 eax
  09769	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0976e	e8 00 00 00 00	 call	 ?SetCastleOwnerGuild@CCastleSiegeSync@@QAEXPAD@Z ; CCastleSiegeSync::SetCastleOwnerGuild
$LN3@GS_DGAnsCa@7:

; 5561 : }

  09773	5f		 pop	 edi
  09774	5e		 pop	 esi
  09775	5b		 pop	 ebx
  09776	8b e5		 mov	 esp, ebp
  09778	5d		 pop	 ebp
  09779	c3		 ret	 0
?GS_DGAnsCastleStateSync@@YAXPAE@Z ENDP			; GS_DGAnsCastleStateSync
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiegesync.h
_TEXT	ENDS
;	COMDAT ?SetCastleState@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iCastleState$ = 8					; size = 4
?SetCastleState@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetCastleState, COMDAT
; _this$ = ecx

; 30   : 	void SetCastleState(int iCastleState){this->m_iCurCastleState = iCastleState;};	// line : 56

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iCastleState$[ebp]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetCastleState@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetCastleState
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iTaxRate$ = 8						; size = 4
?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetTaxRateChaos, COMDAT
; _this$ = ecx

; 31   : 	void SetTaxRateChaos(int iTaxRate){this->m_iCurTaxRateChaos = iTaxRate;};	// line : 59

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iTaxRate$[ebp]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetTaxRateChaos
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iTaxRate$ = 8						; size = 4
?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetTaxRateStore, COMDAT
; _this$ = ecx

; 32   : 	void SetTaxRateStore(int iTaxRate){this->m_iCurTaxRateStore = iTaxRate;};	// line : 62

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iTaxRate$[ebp]
  00012	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetTaxRateStore
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iTaxRate$ = 8						; size = 4
?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetTaxHuntZone, COMDAT
; _this$ = ecx

; 33   : 	void SetTaxHuntZone(int iTaxRate){this->m_iCurTaxHuntZone = iTaxRate;};	// line : 65

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iTaxRate$[ebp]
  00012	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetTaxHuntZone
_TEXT	ENDS
PUBLIC	??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@ ; `string'
PUBLIC	?GetTributeMoney@CCastleSiegeSync@@QAEHXZ	; CCastleSiegeSync::GetTributeMoney
PUBLIC	??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?ResetTributeMoney@CCastleSiegeSync@@QAEXXZ:PROC ; CCastleSiegeSync::ResetTributeMoney
;	COMDAT ??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@ DB '['
	DB	'CastleSiege] [0x80][0x18] GS_DGAnsCastleTributeMoney() - Mone'
	DB	'y Tribute OK (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x18] GS_DGAnsCastleTributeMone'
	DB	'y() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleTributeMoney@@YAXPAE@Z PROC		; GS_DGAnsCastleTributeMoney

; 5578 : {

  09780	55		 push	 ebp
  09781	8b ec		 mov	 ebp, esp
  09783	83 ec 44	 sub	 esp, 68			; 00000044H
  09786	53		 push	 ebx
  09787	56		 push	 esi
  09788	57		 push	 edi

; 5579 : 	CSP_ANS_CASTLETRIBUTEMONEY * lpMsg = (CSP_ANS_CASTLETRIBUTEMONEY *)lpRecv;

  09789	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0978c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5580 : 
; 5581 : 	if ( lpMsg == NULL )

  0978f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09793	75 02		 jne	 SHORT $LN2@GS_DGAnsCa@8

; 5582 : 	{
; 5583 : 		return;

  09795	eb 4a		 jmp	 SHORT $LN3@GS_DGAnsCa@8
$LN2@GS_DGAnsCa@8:

; 5584 : 	}
; 5585 : 
; 5586 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  09797	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0979a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0979e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  097a3	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  097a8	3b f0		 cmp	 esi, eax
  097aa	74 12		 je	 SHORT $LN1@GS_DGAnsCa@8

; 5587 : 	{
; 5588 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x18] GS_DGAnsCastleTributeMoney() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  097ac	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  097b1	6a 02		 push	 2
  097b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  097b9	83 c4 08	 add	 esp, 8

; 5589 : 		return;

  097bc	eb 23		 jmp	 SHORT $LN3@GS_DGAnsCa@8
$LN1@GS_DGAnsCa@8:

; 5590 : 	}
; 5591 : 	
; 5592 : 	LogAddTD("[CastleSiege] [0x80][0x18] GS_DGAnsCastleTributeMoney() - Money Tribute OK (%d)",	g_CastleSiegeSync.GetTributeMoney());

  097be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  097c3	e8 00 00 00 00	 call	 ?GetTributeMoney@CCastleSiegeSync@@QAEHXZ ; CCastleSiegeSync::GetTributeMoney
  097c8	50		 push	 eax
  097c9	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@
  097ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  097d4	83 c4 08	 add	 esp, 8

; 5593 : 	g_CastleSiegeSync.ResetTributeMoney();

  097d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  097dc	e8 00 00 00 00	 call	 ?ResetTributeMoney@CCastleSiegeSync@@QAEXXZ ; CCastleSiegeSync::ResetTributeMoney
$LN3@GS_DGAnsCa@8:

; 5594 : 	
; 5595 : }

  097e1	5f		 pop	 edi
  097e2	5e		 pop	 esi
  097e3	5b		 pop	 ebx
  097e4	8b e5		 mov	 esp, ebp
  097e6	5d		 pop	 ebp
  097e7	c3		 ret	 0
?GS_DGAnsCastleTributeMoney@@YAXPAE@Z ENDP		; GS_DGAnsCastleTributeMoney
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiegesync.h
_TEXT	ENDS
;	COMDAT ?GetTributeMoney@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTributeMoney@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetTributeMoney, COMDAT
; _this$ = ecx

; 35   : 	int GetTributeMoney(){return this->m_lCastleTributeMoney;};	// line : 77

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetTributeMoney@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetTributeMoney
_TEXT	ENDS
PUBLIC	??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
EXTRN	?ResetCastleTaxInfo@CCastleSiege@@QAEXXZ:PROC	; CCastleSiege::ResetCastleTaxInfo
;	COMDAT ??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x19] GS_DGAnsResetCastleTaxInf'
	DB	'o() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z PROC		; GS_DGAnsResetCastleTaxInfo

; 5607 : {

  097f0	55		 push	 ebp
  097f1	8b ec		 mov	 ebp, esp
  097f3	83 ec 44	 sub	 esp, 68			; 00000044H
  097f6	53		 push	 ebx
  097f7	56		 push	 esi
  097f8	57		 push	 edi

; 5608 : //#if(GS_CASTLE==1)
; 5609 : 	CSP_ANS_RESETCASTLETAXINFO* lpMsg = (CSP_ANS_RESETCASTLETAXINFO*)lpRecv;

  097f9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  097fc	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5610 : 
; 5611 : 	if(lpMsg == NULL)

  097ff	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09803	75 02		 jne	 SHORT $LN4@GS_DGAnsRe@4

; 5612 : 		return;

  09805	eb 3c		 jmp	 SHORT $LN5@GS_DGAnsRe@4
$LN4@GS_DGAnsRe@4:

; 5613 : 
; 5614 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09807	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0980a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0980e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09813	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09818	3b f0		 cmp	 esi, eax
  0981a	74 14		 je	 SHORT $LN3@GS_DGAnsRe@4

; 5615 : 	{
; 5616 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x19] GS_DGAnsResetCastleTaxInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0981c	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09821	6a 02		 push	 2
  09823	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09829	83 c4 08	 add	 esp, 8

; 5617 : 		return;

  0982c	eb 15		 jmp	 SHORT $LN5@GS_DGAnsRe@4

; 5618 : 	}
; 5619 : 	else

  0982e	eb 13		 jmp	 SHORT $LN5@GS_DGAnsRe@4
$LN3@GS_DGAnsRe@4:

; 5620 : 	{
; 5621 : 		if(lpMsg->iResult == 1)

  09830	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09833	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09837	75 0a		 jne	 SHORT $LN5@GS_DGAnsRe@4

; 5622 : 		{
; 5623 : 			g_CastleSiege.ResetCastleTaxInfo();

  09839	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0983e	e8 00 00 00 00	 call	 ?ResetCastleTaxInfo@CCastleSiege@@QAEXXZ ; CCastleSiege::ResetCastleTaxInfo
$LN5@GS_DGAnsRe@4:

; 5624 : 		}
; 5625 : 	}
; 5626 : //#else
; 5627 : //	return;
; 5628 : //#endif
; 5629 : }

  09843	5f		 pop	 edi
  09844	5e		 pop	 esi
  09845	5b		 pop	 ebx
  09846	8b e5		 mov	 esp, ebp
  09848	5d		 pop	 ebp
  09849	c3		 ret	 0
?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z ENDP		; GS_DGAnsResetCastleTaxInfo
_TEXT	ENDS
PUBLIC	??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x1A] GS_DGAnsResetSiegeGuildIn'
	DB	'fo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup'
	DB	'()', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z PROC		; GS_DGAnsResetSiegeGuildInfo

; 5640 : {

  09850	55		 push	 ebp
  09851	8b ec		 mov	 ebp, esp
  09853	83 ec 44	 sub	 esp, 68			; 00000044H
  09856	53		 push	 ebx
  09857	56		 push	 esi
  09858	57		 push	 edi

; 5641 : //#if(GS_CASTLE==1)
; 5642 : 	CSP_ANS_RESETSIEGEGUILDINFO* lpMsg = (CSP_ANS_RESETSIEGEGUILDINFO*)lpRecv;

  09859	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0985c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5643 : 
; 5644 : 	if(lpMsg == NULL)

  0985f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09863	75 02		 jne	 SHORT $LN2@GS_DGAnsRe@5

; 5645 : 		return;

  09865	eb 25		 jmp	 SHORT $LN3@GS_DGAnsRe@5
$LN2@GS_DGAnsRe@5:

; 5646 : 
; 5647 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09867	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0986a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0986e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09873	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09878	3b f0		 cmp	 esi, eax
  0987a	74 10		 je	 SHORT $LN3@GS_DGAnsRe@5

; 5648 : 	{
; 5649 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x1A] GS_DGAnsResetSiegeGuildInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  0987c	68 00 00 00 00	 push	 OFFSET ??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  09881	6a 02		 push	 2
  09883	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09889	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsRe@5:

; 5650 : 		return;
; 5651 : 	}
; 5652 : //#else
; 5653 : //	return;
; 5654 : //#endif
; 5655 : }

  0988c	5f		 pop	 edi
  0988d	5e		 pop	 esi
  0988e	5b		 pop	 ebx
  0988f	8b e5		 mov	 esp, ebp
  09891	5d		 pop	 ebp
  09892	c3		 ret	 0
?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z ENDP		; GS_DGAnsResetSiegeGuildInfo
_TEXT	ENDS
PUBLIC	??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
;	COMDAT ??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x1B] GS_DGAnsResetRegSiegeInfo'
	DB	'() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z PROC		; GS_DGAnsResetRegSiegeInfo

; 5666 : {

  098a0	55		 push	 ebp
  098a1	8b ec		 mov	 ebp, esp
  098a3	83 ec 44	 sub	 esp, 68			; 00000044H
  098a6	53		 push	 ebx
  098a7	56		 push	 esi
  098a8	57		 push	 edi

; 5667 : //#if(GS_CASTLE==1)
; 5668 : 	CSP_ANS_RESETREGSIEGEINFO* lpMsg = (CSP_ANS_RESETREGSIEGEINFO*)lpRecv;

  098a9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  098ac	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5669 : 
; 5670 : 	if(lpMsg == NULL)

  098af	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  098b3	75 02		 jne	 SHORT $LN2@GS_DGAnsRe@6

; 5671 : 		return;

  098b5	eb 25		 jmp	 SHORT $LN3@GS_DGAnsRe@6
$LN2@GS_DGAnsRe@6:

; 5672 : 
; 5673 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  098b7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  098ba	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  098be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  098c3	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  098c8	3b f0		 cmp	 esi, eax
  098ca	74 10		 je	 SHORT $LN3@GS_DGAnsRe@6

; 5674 : 	{
; 5675 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x1B] GS_DGAnsResetRegSiegeInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  098cc	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  098d1	6a 02		 push	 2
  098d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  098d9	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsRe@6:

; 5676 : 		return;
; 5677 : 	}
; 5678 : //#else
; 5679 : //	return;
; 5680 : //#endif
; 5681 : }

  098dc	5f		 pop	 edi
  098dd	5e		 pop	 esi
  098de	5b		 pop	 ebx
  098df	8b e5		 mov	 esp, ebp
  098e1	5d		 pop	 ebp
  098e2	c3		 ret	 0
?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z ENDP		; GS_DGAnsResetRegSiegeInfo
_TEXT	ENDS
PUBLIC	?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z		; CCastleSiege::SetDbDataLoadOK
PUBLIC	??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	?SetDataLoadState@CCastleSiege@@QAEXH@Z		; CCastleSiege::SetDataLoadState
PUBLIC	??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	?GetDataLoadState@CCastleSiege@@QAEHXZ		; CCastleSiege::GetDataLoadState
PUBLIC	??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@ ; `string'
EXTRN	?Init@CCastleSiege@@QAEHXZ:PROC			; CCastleSiege::Init
EXTRN	?FirstCreateDbNPC@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::FirstCreateDbNPC
EXTRN	?SetCastleNpcData@CCastleSiege@@QAEHPAUCSP_CSINITDATA@@H@Z:PROC ; CCastleSiege::SetCastleNpcData
EXTRN	?SetCastleInitData@CCastleSiege@@QAEHPAUCSP_ANS_CSINITDATA@@@Z:PROC ; CCastleSiege::SetCastleInitData
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
;	COMDAT ??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSie'
	DB	'ge.SetCastleNpcData() == FALSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSie'
	DB	'ge.SetCastleInitData() == FALSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iRes'
	DB	'ult == 0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - m_iCastleDa'
	DB	'taLoadState != CASTLESIEGE_DATALOAD_2 (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@
CONST	SEGMENT
??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x81] GS_DGAnsCastleInitData() - lpMs'
	DB	'g->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_bRET_VAL$ = -12					; size = 4
_lpMsgBody$ = -8					; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleInitData@@YAXPAE@Z PROC			; GS_DGAnsCastleInitData

; 5684 : {

  098f0	55		 push	 ebp
  098f1	8b ec		 mov	 ebp, esp
  098f3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  098f6	53		 push	 ebx
  098f7	56		 push	 esi
  098f8	57		 push	 edi

; 5685 : //#if(GS_CASTLE==1)
; 5686 : 	CSP_ANS_CSINITDATA* lpMsg = (CSP_ANS_CSINITDATA*)lpRecv;

  098f9	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  098fc	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5687 : 	CSP_CSINITDATA* lpMsgBody = (CSP_CSINITDATA*)(lpRecv + sizeof(CSP_ANS_CSINITDATA));

  098ff	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09902	83 c0 40	 add	 eax, 64			; 00000040H
  09905	89 45 f8	 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 5688 : 
; 5689 : 	if(lpMsg == NULL)

  09908	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0990c	75 05		 jne	 SHORT $LN7@GS_DGAnsCa@9

; 5690 : 		return;

  0990e	e9 25 01 00 00	 jmp	 $LN8@GS_DGAnsCa@9
$LN7@GS_DGAnsCa@9:

; 5691 : 
; 5692 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09913	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09916	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  0991a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  0991f	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09924	3b f0		 cmp	 esi, eax
  09926	74 15		 je	 SHORT $LN6@GS_DGAnsCa@9

; 5693 : 	{
; 5694 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x81] GS_DGAnsCastleInitData() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09928	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@
  0992d	6a 02		 push	 2
  0992f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09935	83 c4 08	 add	 esp, 8

; 5695 : 		return;

  09938	e9 fb 00 00 00	 jmp	 $LN8@GS_DGAnsCa@9
$LN6@GS_DGAnsCa@9:

; 5696 : 	}
; 5697 : 
; 5698 : 	if(g_CastleSiege.GetDataLoadState() != 2)

  0993d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09942	e8 00 00 00 00	 call	 ?GetDataLoadState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDataLoadState
  09947	83 f8 02	 cmp	 eax, 2
  0994a	74 20		 je	 SHORT $LN5@GS_DGAnsCa@9

; 5699 : 	{
; 5700 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - m_iCastleDataLoadState != CASTLESIEGE_DATALOAD_2 (%d)",g_CastleSiege.GetDataLoadState()) ;

  0994c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09951	e8 00 00 00 00	 call	 ?GetDataLoadState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDataLoadState
  09956	50		 push	 eax
  09957	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  0995c	6a 02		 push	 2
  0995e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09964	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5701 : 		return;

  09967	e9 cc 00 00 00	 jmp	 $LN8@GS_DGAnsCa@9
$LN5@GS_DGAnsCa@9:

; 5702 : 	}
; 5703 : 
; 5704 : 	g_CastleSiege.SetDataLoadState(3);

  0996c	6a 03		 push	 3
  0996e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09973	e8 00 00 00 00	 call	 ?SetDataLoadState@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDataLoadState

; 5705 : 
; 5706 : 	if(lpMsg->iResult == FALSE)

  09978	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0997b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0997f	75 22		 jne	 SHORT $LN4@GS_DGAnsCa@9

; 5707 : 	{
; 5708 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iResult == 0");

  09981	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  09986	6a 02		 push	 2
  09988	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0998e	83 c4 08	 add	 esp, 8

; 5709 : 		MsgBox("[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iResult == 0");

  09991	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  09996	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0999b	83 c4 04	 add	 esp, 4

; 5710 : 		return;

  0999e	e9 95 00 00 00	 jmp	 $LN8@GS_DGAnsCa@9
$LN4@GS_DGAnsCa@9:

; 5711 : 	}
; 5712 : 	
; 5713 : 	BOOL bRET_VAL = FALSE;

  099a3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bRET_VAL$[ebp], 0

; 5714 : 
; 5715 : 	bRET_VAL = g_CastleSiege.SetCastleInitData(lpMsg);

  099aa	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  099ad	50		 push	 eax
  099ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  099b3	e8 00 00 00 00	 call	 ?SetCastleInitData@CCastleSiege@@QAEHPAUCSP_ANS_CSINITDATA@@@Z ; CCastleSiege::SetCastleInitData
  099b8	89 45 f4	 mov	 DWORD PTR _bRET_VAL$[ebp], eax

; 5716 : 
; 5717 : 	if(bRET_VAL == FALSE)

  099bb	83 7d f4 00	 cmp	 DWORD PTR _bRET_VAL$[ebp], 0
  099bf	75 12		 jne	 SHORT $LN3@GS_DGAnsCa@9

; 5718 : 	{
; 5719 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSiege.SetCastleInitData() == FALSE");

  099c1	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  099c6	6a 02		 push	 2
  099c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  099ce	83 c4 08	 add	 esp, 8

; 5720 : 		return;

  099d1	eb 65		 jmp	 SHORT $LN8@GS_DGAnsCa@9
$LN3@GS_DGAnsCa@9:

; 5721 : 	}
; 5722 : 
; 5723 : 	bRET_VAL = g_CastleSiege.SetCastleNpcData(lpMsgBody,lpMsg->iCount);

  099d3	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  099d6	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  099d9	51		 push	 ecx
  099da	8b 55 f8	 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  099dd	52		 push	 edx
  099de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  099e3	e8 00 00 00 00	 call	 ?SetCastleNpcData@CCastleSiege@@QAEHPAUCSP_CSINITDATA@@H@Z ; CCastleSiege::SetCastleNpcData
  099e8	89 45 f4	 mov	 DWORD PTR _bRET_VAL$[ebp], eax

; 5724 : 	
; 5725 : 	if(bRET_VAL == FALSE)

  099eb	83 7d f4 00	 cmp	 DWORD PTR _bRET_VAL$[ebp], 0
  099ef	75 12		 jne	 SHORT $LN2@GS_DGAnsCa@9

; 5726 : 	{
; 5727 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSiege.SetCastleNpcData() == FALSE");

  099f1	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  099f6	6a 02		 push	 2
  099f8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  099fe	83 c4 08	 add	 esp, 8

; 5728 : 		return;

  09a01	eb 35		 jmp	 SHORT $LN8@GS_DGAnsCa@9
$LN2@GS_DGAnsCa@9:

; 5729 : 	}
; 5730 : 
; 5731 : 	g_CastleSiege.SetDbDataLoadOK(TRUE);

  09a03	6a 01		 push	 1
  09a05	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09a0a	e8 00 00 00 00	 call	 ?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDbDataLoadOK

; 5732 : 
; 5733 : 	g_CastleSiege.SetDataLoadState(4);

  09a0f	6a 04		 push	 4
  09a11	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09a16	e8 00 00 00 00	 call	 ?SetDataLoadState@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDataLoadState

; 5734 : 
; 5735 : 	if(lpMsg->iFirstCreate == 1)

  09a1b	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09a1e	83 78 34 01	 cmp	 DWORD PTR [eax+52], 1
  09a22	75 0a		 jne	 SHORT $LN1@GS_DGAnsCa@9

; 5736 : 	{
; 5737 : 		g_CastleSiege.FirstCreateDbNPC();

  09a24	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09a29	e8 00 00 00 00	 call	 ?FirstCreateDbNPC@CCastleSiege@@QAEHXZ ; CCastleSiege::FirstCreateDbNPC
$LN1@GS_DGAnsCa@9:

; 5738 : 	}
; 5739 : 
; 5740 : 	g_CastleSiege.Init();

  09a2e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09a33	e8 00 00 00 00	 call	 ?Init@CCastleSiege@@QAEHXZ ; CCastleSiege::Init
$LN8@GS_DGAnsCa@9:

; 5741 : //#else
; 5742 : //	return;
; 5743 : //#endif
; 5744 : }

  09a38	5f		 pop	 edi
  09a39	5e		 pop	 esi
  09a3a	5b		 pop	 ebx
  09a3b	8b e5		 mov	 esp, ebp
  09a3d	5d		 pop	 ebp
  09a3e	c3		 ret	 0
?GS_DGAnsCastleInitData@@YAXPAE@Z ENDP			; GS_DGAnsCastleInitData
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiege.h
_TEXT	ENDS
;	COMDAT ?GetDataLoadState@CCastleSiege@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDataLoadState@CCastleSiege@@QAEHXZ PROC		; CCastleSiege::GetDataLoadState, COMDAT
; _this$ = ecx

; 282  : 	int GetDataLoadState(){return m_iCastleDataLoadState;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetDataLoadState@CCastleSiege@@QAEHXZ ENDP		; CCastleSiege::GetDataLoadState
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetDataLoadState@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iDataLoadState$ = 8					; size = 4
?SetDataLoadState@CCastleSiege@@QAEXH@Z PROC		; CCastleSiege::SetDataLoadState, COMDAT
; _this$ = ecx

; 283  : 	void SetDataLoadState(int iDataLoadState){m_iCastleDataLoadState = iDataLoadState;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iDataLoadState$[ebp]
  00012	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetDataLoadState@CCastleSiege@@QAEXH@Z ENDP		; CCastleSiege::SetDataLoadState
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDbDataLoadOK$ = 8					; size = 4
?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z PROC		; CCastleSiege::SetDbDataLoadOK, COMDAT
; _this$ = ecx

; 284  : 	void SetDbDataLoadOK(BOOL bDbDataLoadOK){m_bDbDataLoadOK = bDbDataLoadOK;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bDbDataLoadOK$[ebp]
  00012	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z ENDP		; CCastleSiege::SetDbDataLoadOK
_TEXT	ENDS
PUBLIC	??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@ ; `string'
;	COMDAT ??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x82] GS_DGAnsCastleNpcInfo() - lpMsg'
	DB	'->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsgBody$ = -8					; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcInfo@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcInfo

; 5761 : {

  09a40	55		 push	 ebp
  09a41	8b ec		 mov	 ebp, esp
  09a43	83 ec 48	 sub	 esp, 72			; 00000048H
  09a46	53		 push	 ebx
  09a47	56		 push	 esi
  09a48	57		 push	 edi

; 5762 : //#if(GS_CASTLE==1)
; 5763 : 	CSP_ANS_NPCDATA* lpMsg = (CSP_ANS_NPCDATA*)lpRecv;

  09a49	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09a4c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5764 : 	CSP_NPCDATA* lpMsgBody = (CSP_NPCDATA*)(lpRecv+sizeof(CSP_ANS_NPCDATA));

  09a4f	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09a52	83 c0 14	 add	 eax, 20			; 00000014H
  09a55	89 45 f8	 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 5765 : 
; 5766 : 	if(lpMsg == NULL)

  09a58	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09a5c	75 02		 jne	 SHORT $LN2@GS_DGAnsCa@10

; 5767 : 		return;

  09a5e	eb 25		 jmp	 SHORT $LN3@GS_DGAnsCa@10
$LN2@GS_DGAnsCa@10:

; 5768 : 
; 5769 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09a60	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09a63	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09a67	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09a6c	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09a71	3b f0		 cmp	 esi, eax
  09a73	74 10		 je	 SHORT $LN3@GS_DGAnsCa@10

; 5770 : 	{
; 5771 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x82] GS_DGAnsCastleNpcInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09a75	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@
  09a7a	6a 02		 push	 2
  09a7c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09a82	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsCa@10:

; 5772 : 		return;
; 5773 : 	}
; 5774 : //#else
; 5775 : //	return;
; 5776 : //#endif
; 5777 : }

  09a85	5f		 pop	 edi
  09a86	5e		 pop	 esi
  09a87	5b		 pop	 ebx
  09a88	8b e5		 mov	 esp, ebp
  09a8a	5d		 pop	 ebp
  09a8b	c3		 ret	 0
?GS_DGAnsCastleNpcInfo@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcInfo
_TEXT	ENDS
PUBLIC	??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@
CONST	SEGMENT
??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x83] GS_DGAnsAllGuildMarkRegInfo() -'
	DB	' lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$247875 = -1692					; size = 4
_lpMsgSendBody$ = -1688					; size = 4
_lpMsgSend$ = -1684					; size = 4
_cBUFFER$ = -1680					; size = 1668
_lpMsgBody$ = -12					; size = 4
_lpMsg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z PROC		; GS_DGAnsAllGuildMarkRegInfo

; 5810 : {

  09a90	55		 push	 ebp
  09a91	8b ec		 mov	 ebp, esp
  09a93	81 ec dc 06 00
	00		 sub	 esp, 1756		; 000006dcH
  09a99	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  09a9e	33 c5		 xor	 eax, ebp
  09aa0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  09aa3	53		 push	 ebx
  09aa4	56		 push	 esi
  09aa5	57		 push	 edi

; 5811 : //#if(GS_CASTLE==1)
; 5812 : 	CSP_ANS_ALLGUILDREGINFO* lpMsg = (CSP_ANS_ALLGUILDREGINFO*)lpRecv;

  09aa6	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09aa9	89 45 f8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5813 : 	CSP_GUILDREGINFO* lpMsgBody = (CSP_GUILDREGINFO*)(lpRecv+sizeof(CSP_ANS_ALLGUILDREGINFO));

  09aac	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09aaf	83 c0 14	 add	 eax, 20			; 00000014H
  09ab2	89 45 f4	 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 5814 : 	char cBUFFER[1668];
; 5815 : 	PMSG_ANS_CSREGGUILDLIST* lpMsgSend;
; 5816 : 	PMSG_CSREGGUILDLIST* lpMsgSendBody;
; 5817 : 
; 5818 : 	if(lpMsg == NULL)

  09ab5	83 7d f8 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09ab9	75 05		 jne	 SHORT $LN7@GS_DGAnsAl

; 5819 : 		return;

  09abb	e9 38 02 00 00	 jmp	 $LN8@GS_DGAnsAl
$LN7@GS_DGAnsAl:

; 5820 : 
; 5821 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09ac0	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09ac3	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09ac7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09acc	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09ad1	3b f0		 cmp	 esi, eax
  09ad3	74 15		 je	 SHORT $LN6@GS_DGAnsAl

; 5822 : 	{
; 5823 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x83] GS_DGAnsAllGuildMarkRegInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09ad5	68 00 00 00 00	 push	 OFFSET ??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@
  09ada	6a 02		 push	 2
  09adc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09ae2	83 c4 08	 add	 esp, 8

; 5824 : 		return;

  09ae5	e9 0e 02 00 00	 jmp	 $LN8@GS_DGAnsAl
$LN6@GS_DGAnsAl:

; 5825 : 	}
; 5826 : 
; 5827 : 	if(!gObjIsConnected(lpMsg->iIndex))

  09aea	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09aed	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09af0	51		 push	 ecx
  09af1	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  09af6	83 c4 04	 add	 esp, 4
  09af9	85 c0		 test	 eax, eax
  09afb	75 05		 jne	 SHORT $LN5@GS_DGAnsAl

; 5828 : 		return;

  09afd	e9 f6 01 00 00	 jmp	 $LN8@GS_DGAnsAl
$LN5@GS_DGAnsAl:

; 5829 : 
; 5830 : 	lpMsgSend = (PMSG_ANS_CSREGGUILDLIST*)cBUFFER;

  09b02	8d 85 70 f9 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  09b08	89 85 6c f9 ff
	ff		 mov	 DWORD PTR _lpMsgSend$[ebp], eax

; 5831 : 	lpMsgSendBody = (PMSG_CSREGGUILDLIST*)&cBUFFER[12];

  09b0e	8d 85 7c f9 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp+12]
  09b14	89 85 68 f9 ff
	ff		 mov	 DWORD PTR _lpMsgSendBody$[ebp], eax

; 5832 : 
; 5833 : 	lpMsgSend->iCount = 0;

  09b1a	8b 85 6c f9 ff
	ff		 mov	 eax, DWORD PTR _lpMsgSend$[ebp]
  09b20	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 5834 : 	lpMsgSend->btResult = lpMsg->iResult;

  09b27	8b 85 6c f9 ff
	ff		 mov	 eax, DWORD PTR _lpMsgSend$[ebp]
  09b2d	8b 4d f8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  09b30	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  09b33	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 5835 : 	
; 5836 : 	if(lpMsg->iResult == TRUE)

  09b36	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09b39	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09b3d	0f 85 68 01 00
	00		 jne	 $LN4@GS_DGAnsAl

; 5837 : 	{
; 5838 : 		lpMsgSend->iCount = lpMsg->iCount;

  09b43	8b 85 6c f9 ff
	ff		 mov	 eax, DWORD PTR _lpMsgSend$[ebp]
  09b49	8b 4d f8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  09b4c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  09b4f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 5839 : 
; 5840 : 		for(int i=0;i< lpMsg->iCount;i++)

  09b52	c7 85 64 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$247875[ebp], 0
  09b5c	eb 0f		 jmp	 SHORT $LN3@GS_DGAnsAl
$LN2@GS_DGAnsAl:
  09b5e	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09b64	83 c0 01	 add	 eax, 1
  09b67	89 85 64 f9 ff
	ff		 mov	 DWORD PTR _i$247875[ebp], eax
$LN3@GS_DGAnsAl:
  09b6d	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09b70	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09b76	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  09b79	0f 8d 2c 01 00
	00		 jge	 $LN4@GS_DGAnsAl

; 5841 : 		{
; 5842 : 			lpMsgSendBody[i].btSeqNum = lpMsgBody[i].btRegRank;

  09b7f	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09b85	c1 e0 04	 shl	 eax, 4
  09b88	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09b8e	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09b91	8b 95 68 f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSendBody$[ebp]
  09b97	8b 75 f4	 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  09b9a	8a 44 06 0d	 mov	 al, BYTE PTR [esi+eax+13]
  09b9e	88 44 0a 0d	 mov	 BYTE PTR [edx+ecx+13], al

; 5843 : 			lpMsgSendBody[i].btIsGiveUp = lpMsgBody[i].bIsGiveUp;

  09ba2	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09ba8	c1 e0 04	 shl	 eax, 4
  09bab	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09bb1	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09bb4	8b 95 68 f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSendBody$[ebp]
  09bba	8b 75 f4	 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  09bbd	8a 44 06 0c	 mov	 al, BYTE PTR [esi+eax+12]
  09bc1	88 44 0a 0c	 mov	 BYTE PTR [edx+ecx+12], al

; 5844 : 			lpMsgSendBody[i].btRegMarks1 = SET_NUMBERH(SET_NUMBERHW(lpMsgBody[i].iRegMarkCount));

  09bc5	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09bcb	c1 e0 04	 shl	 eax, 4
  09bce	8b 4d f4	 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  09bd1	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  09bd5	c1 ea 10	 shr	 edx, 16			; 00000010H
  09bd8	0f b7 c2	 movzx	 eax, dx
  09bdb	c1 e8 08	 shr	 eax, 8
  09bde	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09be4	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09be7	8b 95 68 f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSendBody$[ebp]
  09bed	88 44 0a 08	 mov	 BYTE PTR [edx+ecx+8], al

; 5845 : 			lpMsgSendBody[i].btRegMarks2 = SET_NUMBERL(SET_NUMBERHW(lpMsgBody[i].iRegMarkCount));

  09bf1	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09bf7	c1 e0 04	 shl	 eax, 4
  09bfa	8b 4d f4	 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  09bfd	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  09c01	c1 ea 10	 shr	 edx, 16			; 00000010H
  09c04	0f b7 c2	 movzx	 eax, dx
  09c07	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09c0c	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09c12	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09c15	8b 95 68 f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSendBody$[ebp]
  09c1b	88 44 0a 09	 mov	 BYTE PTR [edx+ecx+9], al

; 5846 : 			lpMsgSendBody[i].btRegMarks3 = SET_NUMBERH(SET_NUMBERLW(lpMsgBody[i].iRegMarkCount));

  09c1f	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09c25	c1 e0 04	 shl	 eax, 4
  09c28	8b 4d f4	 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  09c2b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  09c2f	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  09c35	0f b7 c2	 movzx	 eax, dx
  09c38	c1 e8 08	 shr	 eax, 8
  09c3b	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09c41	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09c44	8b 95 68 f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSendBody$[ebp]
  09c4a	88 44 0a 0a	 mov	 BYTE PTR [edx+ecx+10], al

; 5847 : 			lpMsgSendBody[i].btRegMarks4 = SET_NUMBERL(SET_NUMBERLW(lpMsgBody[i].iRegMarkCount));

  09c4e	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09c54	c1 e0 04	 shl	 eax, 4
  09c57	8b 4d f4	 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  09c5a	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  09c5e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  09c64	0f b7 c2	 movzx	 eax, dx
  09c67	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09c6c	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09c72	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09c75	8b 95 68 f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSendBody$[ebp]
  09c7b	88 44 0a 0b	 mov	 BYTE PTR [edx+ecx+11], al

; 5848 : 			memcpy(&lpMsgSendBody[i].szGuildName,lpMsgBody[i].szGuildName,sizeof(lpMsgSendBody[i].szGuildName));

  09c7f	6a 08		 push	 8
  09c81	8b 85 64 f9 ff
	ff		 mov	 eax, DWORD PTR _i$247875[ebp]
  09c87	c1 e0 04	 shl	 eax, 4
  09c8a	03 45 f4	 add	 eax, DWORD PTR _lpMsgBody$[ebp]
  09c8d	50		 push	 eax
  09c8e	8b 8d 64 f9 ff
	ff		 mov	 ecx, DWORD PTR _i$247875[ebp]
  09c94	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09c97	03 8d 68 f9 ff
	ff		 add	 ecx, DWORD PTR _lpMsgSendBody$[ebp]
  09c9d	51		 push	 ecx
  09c9e	e8 00 00 00 00	 call	 _memcpy
  09ca3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5849 : 		}

  09ca6	e9 b3 fe ff ff	 jmp	 $LN2@GS_DGAnsAl
$LN4@GS_DGAnsAl:

; 5850 : 	}
; 5851 : 	
; 5852 : 	lpMsgSend->h.set((LPBYTE)lpMsgSend,0xB4,(lpMsgSend->iCount*sizeof(PMSG_CSREGGUILDLIST)+sizeof(PMSG_ANS_CSREGGUILDLIST)));

  09cab	8b 85 6c f9 ff
	ff		 mov	 eax, DWORD PTR _lpMsgSend$[ebp]
  09cb1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  09cb4	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09cb7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  09cba	51		 push	 ecx
  09cbb	68 b4 00 00 00	 push	 180			; 000000b4H
  09cc0	8b 95 6c f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSend$[ebp]
  09cc6	52		 push	 edx
  09cc7	8b 8d 6c f9 ff
	ff		 mov	 ecx, DWORD PTR _lpMsgSend$[ebp]
  09ccd	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD@@QAEXPAEEH@Z ; PWMSG_HEAD::set

; 5853 : 
; 5854 : 	DataSend(lpMsg->iIndex,(LPBYTE)lpMsgSend,(lpMsgSend->iCount*sizeof(PMSG_CSREGGUILDLIST)+sizeof(PMSG_ANS_CSREGGUILDLIST)));

  09cd2	8b 85 6c f9 ff
	ff		 mov	 eax, DWORD PTR _lpMsgSend$[ebp]
  09cd8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  09cdb	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  09cde	83 c1 0c	 add	 ecx, 12			; 0000000cH
  09ce1	51		 push	 ecx
  09ce2	8b 95 6c f9 ff
	ff		 mov	 edx, DWORD PTR _lpMsgSend$[ebp]
  09ce8	52		 push	 edx
  09ce9	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09cec	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09cef	51		 push	 ecx
  09cf0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  09cf5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@GS_DGAnsAl:

; 5855 : //#else
; 5856 : //	return;
; 5857 : //#endif
; 5858 : }

  09cf8	5f		 pop	 edi
  09cf9	5e		 pop	 esi
  09cfa	5b		 pop	 ebx
  09cfb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  09cfe	33 cd		 xor	 ecx, ebp
  09d00	e8 00 00 00 00	 call	 @__security_check_cookie@4
  09d05	8b e5		 mov	 esp, ebp
  09d07	5d		 pop	 ebp
  09d08	c3		 ret	 0
?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z ENDP		; GS_DGAnsAllGuildMarkRegInfo
_TEXT	ENDS
PUBLIC	?SetDbNpcCreated@CCastleSiege@@QAEXH@Z		; CCastleSiege::SetDbNpcCreated
PUBLIC	?GetDbNpcCreated@CCastleSiege@@QAEHXZ		; CCastleSiege::GetDbNpcCreated
PUBLIC	??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@ ; `string'
EXTRN	?CreateDbNPC@CCastleSiege@@QAEXXZ:PROC		; CCastleSiege::CreateDbNPC
;	COMDAT ??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@
CONST	SEGMENT
??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x84] GS_DGAnsFirstCreateNPC() - lpMs'
	DB	'g->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsFirstCreateNPC@@YAXPAE@Z PROC			; GS_DGAnsFirstCreateNPC

; 5873 : {

  09d10	55		 push	 ebp
  09d11	8b ec		 mov	 ebp, esp
  09d13	83 ec 44	 sub	 esp, 68			; 00000044H
  09d16	53		 push	 ebx
  09d17	56		 push	 esi
  09d18	57		 push	 edi

; 5874 : //#if(GS_CASTLE==1)
; 5875 : 	CSP_ANS_NPCSAVEDATA* lpMsg = (CSP_ANS_NPCSAVEDATA*)lpRecv;

  09d19	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09d1c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5876 : 
; 5877 : 	if(lpMsg == NULL)

  09d1f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09d23	75 02		 jne	 SHORT $LN4@GS_DGAnsFi

; 5878 : 	return;

  09d25	eb 54		 jmp	 SHORT $LN5@GS_DGAnsFi
$LN4@GS_DGAnsFi:

; 5879 : 
; 5880 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09d27	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09d2a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09d2e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09d33	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09d38	3b f0		 cmp	 esi, eax
  09d3a	74 12		 je	 SHORT $LN3@GS_DGAnsFi

; 5881 : 	{
; 5882 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x84] GS_DGAnsFirstCreateNPC() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09d3c	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@
  09d41	6a 02		 push	 2
  09d43	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09d49	83 c4 08	 add	 esp, 8

; 5883 : 		return;

  09d4c	eb 2d		 jmp	 SHORT $LN5@GS_DGAnsFi
$LN3@GS_DGAnsFi:

; 5884 : 	}
; 5885 : 
; 5886 : 	if(lpMsg->iResult == TRUE)

  09d4e	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09d51	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09d55	75 24		 jne	 SHORT $LN5@GS_DGAnsFi

; 5887 : 	{
; 5888 : 		if(g_CastleSiege.GetDbNpcCreated() == FALSE)

  09d57	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09d5c	e8 00 00 00 00	 call	 ?GetDbNpcCreated@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDbNpcCreated
  09d61	85 c0		 test	 eax, eax
  09d63	75 16		 jne	 SHORT $LN5@GS_DGAnsFi

; 5889 : 		{
; 5890 : 			g_CastleSiege.CreateDbNPC();

  09d65	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09d6a	e8 00 00 00 00	 call	 ?CreateDbNPC@CCastleSiege@@QAEXXZ ; CCastleSiege::CreateDbNPC

; 5891 : 			g_CastleSiege.SetDbNpcCreated(1);

  09d6f	6a 01		 push	 1
  09d71	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09d76	e8 00 00 00 00	 call	 ?SetDbNpcCreated@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDbNpcCreated
$LN5@GS_DGAnsFi:

; 5892 : 		}
; 5893 : 	}
; 5894 : //#else
; 5895 : //	return;
; 5896 : //#endif
; 5897 : }

  09d7b	5f		 pop	 edi
  09d7c	5e		 pop	 esi
  09d7d	5b		 pop	 ebx
  09d7e	8b e5		 mov	 esp, ebp
  09d80	5d		 pop	 ebp
  09d81	c3		 ret	 0
?GS_DGAnsFirstCreateNPC@@YAXPAE@Z ENDP			; GS_DGAnsFirstCreateNPC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiege.h
_TEXT	ENDS
;	COMDAT ?GetDbNpcCreated@CCastleSiege@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDbNpcCreated@CCastleSiege@@QAEHXZ PROC		; CCastleSiege::GetDbNpcCreated, COMDAT
; _this$ = ecx

; 359  : 	BOOL GetDbNpcCreated(){return m_bDbNpcCreated;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 80 50 01 00
	00		 mov	 eax, DWORD PTR [eax+336]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetDbNpcCreated@CCastleSiege@@QAEHXZ ENDP		; CCastleSiege::GetDbNpcCreated
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetDbNpcCreated@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDbNpcCreated$ = 8					; size = 4
?SetDbNpcCreated@CCastleSiege@@QAEXH@Z PROC		; CCastleSiege::SetDbNpcCreated, COMDAT
; _this$ = ecx

; 360  : 	void SetDbNpcCreated(BOOL bDbNpcCreated){m_bDbNpcCreated = bDbNpcCreated;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bDbNpcCreated$[ebp]
  00012	89 88 50 01 00
	00		 mov	 DWORD PTR [eax+336], ecx
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetDbNpcCreated@CCastleSiege@@QAEXH@Z ENDP		; CCastleSiege::SetDbNpcCreated
_TEXT	ENDS
PUBLIC	??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ ; `string'
PUBLIC	??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ ; `string'
EXTRN	?SetCalcRegGuildList@CCastleSiege@@QAEXPAUCSP_CALCREGGUILDLIST@@H@Z:PROC ; CCastleSiege::SetCalcRegGuildList
;	COMDAT ??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lp'
	DB	'Msg->iResult != 1 (%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
CONST	SEGMENT
??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lp'
	DB	'Msg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsgBody$ = -8					; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCalcREgGuildList@@YAXPAE@Z PROC		; GS_DGAnsCalcREgGuildList

; 5909 : {

  09d90	55		 push	 ebp
  09d91	8b ec		 mov	 ebp, esp
  09d93	83 ec 48	 sub	 esp, 72			; 00000048H
  09d96	53		 push	 ebx
  09d97	56		 push	 esi
  09d98	57		 push	 edi

; 5910 : //#if (GS_CASTLE==1)
; 5911 : 	CSP_ANS_CALCREGGUILDLIST* lpMsg = (CSP_ANS_CALCREGGUILDLIST*)lpRecv;

  09d99	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09d9c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5912 : 	CSP_CALCREGGUILDLIST* lpMsgBody = (CSP_CALCREGGUILDLIST*)(lpRecv+sizeof(CSP_ANS_CALCREGGUILDLIST));

  09d9f	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09da2	83 c0 10	 add	 eax, 16			; 00000010H
  09da5	89 45 f8	 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 5913 : 	
; 5914 : 	if(lpMsg == NULL)

  09da8	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09dac	75 02		 jne	 SHORT $LN3@GS_DGAnsCa@11

; 5915 : 	return;

  09dae	eb 5e		 jmp	 SHORT $LN4@GS_DGAnsCa@11
$LN3@GS_DGAnsCa@11:

; 5916 : 
; 5917 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09db0	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09db3	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09db7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09dbc	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09dc1	3b f0		 cmp	 esi, eax
  09dc3	74 12		 je	 SHORT $LN2@GS_DGAnsCa@11

; 5918 : 	{
; 5919 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09dc5	68 00 00 00 00	 push	 OFFSET ??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
  09dca	6a 02		 push	 2
  09dcc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09dd2	83 c4 08	 add	 esp, 8

; 5920 : 		return;

  09dd5	eb 37		 jmp	 SHORT $LN4@GS_DGAnsCa@11
$LN2@GS_DGAnsCa@11:

; 5921 : 	}
; 5922 : 
; 5923 : 	if(lpMsg->iResult == TRUE)

  09dd7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09dda	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09dde	75 17		 jne	 SHORT $LN1@GS_DGAnsCa@11

; 5924 : 	{
; 5925 : 		g_CastleSiege.SetCalcRegGuildList(lpMsgBody,lpMsg->iCount);

  09de0	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09de3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09de6	51		 push	 ecx
  09de7	8b 55 f8	 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  09dea	52		 push	 edx
  09deb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09df0	e8 00 00 00 00	 call	 ?SetCalcRegGuildList@CCastleSiege@@QAEXPAUCSP_CALCREGGUILDLIST@@H@Z ; CCastleSiege::SetCalcRegGuildList

; 5926 : 		return;

  09df5	eb 17		 jmp	 SHORT $LN4@GS_DGAnsCa@11
$LN1@GS_DGAnsCa@11:

; 5927 : 	}
; 5928 : 
; 5929 : 	LogAddC(2,"[CastleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lpMsg->iResult != 1 (%d)",lpMsg->iResult) ;

  09df7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09dfa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  09dfd	51		 push	 ecx
  09dfe	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
  09e03	6a 02		 push	 2
  09e05	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09e0b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GS_DGAnsCa@11:

; 5930 : //#else
; 5931 : //	return;
; 5932 : //#endif
; 5933 : }

  09e0e	5f		 pop	 edi
  09e0f	5e		 pop	 esi
  09e10	5b		 pop	 ebx
  09e11	8b e5		 mov	 esp, ebp
  09e13	5d		 pop	 ebp
  09e14	c3		 ret	 0
?GS_DGAnsCalcREgGuildList@@YAXPAE@Z ENDP		; GS_DGAnsCalcREgGuildList
_TEXT	ENDS
PUBLIC	??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@ ; `string'
EXTRN	?MakeCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSGUILDUNIONINFO@@H@Z:PROC ; CCastleSiege::MakeCsTotalGuildInfo
;	COMDAT ??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@
CONST	SEGMENT
??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x86] GS_DGAnsCsGulidUnionInfo() - lp'
	DB	'Msg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsgBody$ = -8					; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z PROC		; GS_DGAnsCsGulidUnionInfo

; 5945 : {

  09e20	55		 push	 ebp
  09e21	8b ec		 mov	 ebp, esp
  09e23	83 ec 48	 sub	 esp, 72			; 00000048H
  09e26	53		 push	 ebx
  09e27	56		 push	 esi
  09e28	57		 push	 edi

; 5946 : //#if (GS_CASTLE==1)
; 5947 : 	CSP_ANS_CSGUILDUNIONINFO* lpMsg = (CSP_ANS_CSGUILDUNIONINFO*)lpRecv;

  09e29	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09e2c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5948 : 	CSP_CSGUILDUNIONINFO* lpMsgBody = (CSP_CSGUILDUNIONINFO*)(lpRecv+sizeof(CSP_ANS_CSGUILDUNIONINFO));

  09e2f	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09e32	83 c0 10	 add	 eax, 16			; 00000010H
  09e35	89 45 f8	 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 5949 : 	
; 5950 : 	if(lpMsg == NULL)

  09e38	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09e3c	75 02		 jne	 SHORT $LN3@GS_DGAnsCs

; 5951 : 	return;

  09e3e	eb 45		 jmp	 SHORT $LN4@GS_DGAnsCs
$LN3@GS_DGAnsCs:

; 5952 : 
; 5953 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09e40	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09e43	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09e47	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09e4c	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09e51	3b f0		 cmp	 esi, eax
  09e53	74 12		 je	 SHORT $LN2@GS_DGAnsCs

; 5954 : 	{
; 5955 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x86] GS_DGAnsCsGulidUnionInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09e55	68 00 00 00 00	 push	 OFFSET ??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@
  09e5a	6a 02		 push	 2
  09e5c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09e62	83 c4 08	 add	 esp, 8

; 5956 : 		return;

  09e65	eb 1e		 jmp	 SHORT $LN4@GS_DGAnsCs
$LN2@GS_DGAnsCs:

; 5957 : 	}
; 5958 : 
; 5959 : 	if(lpMsg->iResult == TRUE)

  09e67	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09e6a	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09e6e	75 15		 jne	 SHORT $LN4@GS_DGAnsCs

; 5960 : 	{
; 5961 : 		g_CastleSiege.MakeCsTotalGuildInfo(lpMsgBody,lpMsg->iCount);

  09e70	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09e73	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09e76	51		 push	 ecx
  09e77	8b 55 f8	 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  09e7a	52		 push	 edx
  09e7b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09e80	e8 00 00 00 00	 call	 ?MakeCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSGUILDUNIONINFO@@H@Z ; CCastleSiege::MakeCsTotalGuildInfo
$LN4@GS_DGAnsCs:

; 5962 : 		return;
; 5963 : 	}
; 5964 : //#else
; 5965 : //	return;
; 5966 : //#endif
; 5967 : }

  09e85	5f		 pop	 edi
  09e86	5e		 pop	 esi
  09e87	5b		 pop	 ebx
  09e88	8b e5		 mov	 esp, ebp
  09e8a	5d		 pop	 ebp
  09e8b	c3		 ret	 0
?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z ENDP		; GS_DGAnsCsGulidUnionInfo
_TEXT	ENDS
PUBLIC	?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z	; CCastleSiege::SetIsSiegeGuildList
PUBLIC	??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@ ; `string'
;	COMDAT ??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@
CONST	SEGMENT
??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x87] GS_DGAnsCsSaveTotalGuildInfo() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z PROC		; GS_DGAnsCsSaveTotalGuildInfo

; 5978 : {

  09e90	55		 push	 ebp
  09e91	8b ec		 mov	 ebp, esp
  09e93	83 ec 44	 sub	 esp, 68			; 00000044H
  09e96	53		 push	 ebx
  09e97	56		 push	 esi
  09e98	57		 push	 edi

; 5979 : //#if(GS_CASTLE==1)
; 5980 : 	CSP_ANS_CSSAVETOTALGUILDINFO* lpMsg = (CSP_ANS_CSSAVETOTALGUILDINFO*)lpRecv;

  09e99	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09e9c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 5981 : 	
; 5982 : 	if(lpMsg == NULL)

  09e9f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09ea3	75 02		 jne	 SHORT $LN3@GS_DGAnsCs@2

; 5983 : 	return;

  09ea5	eb 4a		 jmp	 SHORT $LN4@GS_DGAnsCs@2
$LN3@GS_DGAnsCs@2:

; 5984 : 
; 5985 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09ea7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09eaa	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09eae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09eb3	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09eb8	3b f0		 cmp	 esi, eax
  09eba	74 12		 je	 SHORT $LN2@GS_DGAnsCs@2

; 5986 : 	{
; 5987 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x87] GS_DGAnsCsSaveTotalGuildInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09ebc	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@
  09ec1	6a 02		 push	 2
  09ec3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09ec9	83 c4 08	 add	 esp, 8

; 5988 : 		return;

  09ecc	eb 23		 jmp	 SHORT $LN4@GS_DGAnsCs@2
$LN2@GS_DGAnsCs@2:

; 5989 : 	}
; 5990 : 
; 5991 : 	if(lpMsg->iResult == TRUE)

  09ece	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09ed1	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09ed5	75 0e		 jne	 SHORT $LN1@GS_DGAnsCs@2

; 5992 : 	{
; 5993 : 		g_CastleSiege.SetIsSiegeGuildList(TRUE);

  09ed7	6a 01		 push	 1
  09ed9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09ede	e8 00 00 00 00	 call	 ?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetIsSiegeGuildList

; 5994 : 		return;

  09ee3	eb 0c		 jmp	 SHORT $LN4@GS_DGAnsCs@2
$LN1@GS_DGAnsCs@2:

; 5995 : 	}
; 5996 : 	g_CastleSiege.SetIsSiegeGuildList(FALSE);

  09ee5	6a 00		 push	 0
  09ee7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09eec	e8 00 00 00 00	 call	 ?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetIsSiegeGuildList
$LN4@GS_DGAnsCs@2:

; 5997 : //#else
; 5998 : //	return;
; 5999 : //#endif
; 6000 : }

  09ef1	5f		 pop	 edi
  09ef2	5e		 pop	 esi
  09ef3	5b		 pop	 ebx
  09ef4	8b e5		 mov	 esp, ebp
  09ef6	5d		 pop	 ebp
  09ef7	c3		 ret	 0
?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z ENDP		; GS_DGAnsCsSaveTotalGuildInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiege.h
_TEXT	ENDS
;	COMDAT ?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bIsSiegGuildList$ = 8					; size = 4
?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z PROC		; CCastleSiege::SetIsSiegeGuildList, COMDAT
; _this$ = ecx

; 357  : 	void SetIsSiegeGuildList(BOOL bIsSiegGuildList){m_btIsSiegeGuildList = bIsSiegGuildList;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 4d 08	 mov	 cl, BYTE PTR _bIsSiegGuildList$[ebp]
  00012	88 88 d4 00 00
	00		 mov	 BYTE PTR [eax+212], cl
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z ENDP		; CCastleSiege::SetIsSiegeGuildList
_TEXT	ENDS
PUBLIC	??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@ ; `string'
EXTRN	?SetCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSLOADTOTALGUILDINFO@@H@Z:PROC ; CCastleSiege::SetCsTotalGuildInfo
;	COMDAT ??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dsprotocol.cpp
CONST	SEGMENT
??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x88] GS_DGAnsCsLoadTotalGuildInfo() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsgBody$ = -8					; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z PROC		; GS_DGAnsCsLoadTotalGuildInfo

; 6012 : {

  09f00	55		 push	 ebp
  09f01	8b ec		 mov	 ebp, esp
  09f03	83 ec 48	 sub	 esp, 72			; 00000048H
  09f06	53		 push	 ebx
  09f07	56		 push	 esi
  09f08	57		 push	 edi

; 6013 : //#if (GS_CASTLE==1)
; 6014 : 	CSP_ANS_CSLOADTOTALGUILDINFO* lpMsg = (CSP_ANS_CSLOADTOTALGUILDINFO*)lpRecv;

  09f09	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09f0c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 6015 : 	CSP_CSLOADTOTALGUILDINFO* lpMsgBody = (CSP_CSLOADTOTALGUILDINFO*)(lpRecv+sizeof(CSP_ANS_CSLOADTOTALGUILDINFO));

  09f0f	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09f12	83 c0 10	 add	 eax, 16			; 00000010H
  09f15	89 45 f8	 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 6016 : 
; 6017 : 	if(lpMsg == NULL)

  09f18	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09f1c	75 02		 jne	 SHORT $LN3@GS_DGAnsCs@3

; 6018 : 	return;

  09f1e	eb 45		 jmp	 SHORT $LN4@GS_DGAnsCs@3
$LN3@GS_DGAnsCs@3:

; 6019 : 
; 6020 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09f20	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09f23	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09f27	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09f2c	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09f31	3b f0		 cmp	 esi, eax
  09f33	74 12		 je	 SHORT $LN2@GS_DGAnsCs@3

; 6021 : 	{
; 6022 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x88] GS_DGAnsCsLoadTotalGuildInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09f35	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@
  09f3a	6a 02		 push	 2
  09f3c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09f42	83 c4 08	 add	 esp, 8

; 6023 : 		return;

  09f45	eb 1e		 jmp	 SHORT $LN4@GS_DGAnsCs@3
$LN2@GS_DGAnsCs@3:

; 6024 : 	}
; 6025 : 
; 6026 : 	if(lpMsg->iResult == TRUE)

  09f47	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09f4a	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  09f4e	75 15		 jne	 SHORT $LN4@GS_DGAnsCs@3

; 6027 : 	{
; 6028 : 		g_CastleSiege.SetCsTotalGuildInfo(lpMsgBody,lpMsg->iCount);

  09f50	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09f53	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  09f56	51		 push	 ecx
  09f57	8b 55 f8	 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  09f5a	52		 push	 edx
  09f5b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  09f60	e8 00 00 00 00	 call	 ?SetCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSLOADTOTALGUILDINFO@@H@Z ; CCastleSiege::SetCsTotalGuildInfo
$LN4@GS_DGAnsCs@3:

; 6029 : 		return;
; 6030 : 	}
; 6031 : //#else
; 6032 : //	return;
; 6033 : //#endif
; 6034 : }

  09f65	5f		 pop	 edi
  09f66	5e		 pop	 esi
  09f67	5b		 pop	 ebx
  09f68	8b e5		 mov	 esp, ebp
  09f6a	5d		 pop	 ebp
  09f6b	c3		 ret	 0
?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z ENDP		; GS_DGAnsCsLoadTotalGuildInfo
_TEXT	ENDS
PUBLIC	??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@ ; `string'
PUBLIC	??_C@_04OOEBCMBF@FAIL?$AA@			; `string'
PUBLIC	??_C@_07OIIICFNN@SUCCEED?$AA@			; `string'
PUBLIC	??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@ ; `string'
;	COMDAT ??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@
CONST	SEGMENT
??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@ DB '[C'
	DB	'astleSiege] [0x89] GS_DGAnsCastleNpcUpdate() - Npc Data Updat'
	DB	'e Result : ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOEBCMBF@FAIL?$AA@
CONST	SEGMENT
??_C@_04OOEBCMBF@FAIL?$AA@ DB 'FAIL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OIIICFNN@SUCCEED?$AA@
CONST	SEGMENT
??_C@_07OIIICFNN@SUCCEED?$AA@ DB 'SUCCEED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@
CONST	SEGMENT
??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x89] GS_DGAnsCastleNpcUpdate() - lpM'
	DB	'sg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szResult$ = -8						; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcUpdate

; 6045 : {

  09f70	55		 push	 ebp
  09f71	8b ec		 mov	 ebp, esp
  09f73	83 ec 48	 sub	 esp, 72			; 00000048H
  09f76	53		 push	 ebx
  09f77	56		 push	 esi
  09f78	57		 push	 edi

; 6046 : //#if(GS_CASTLE==1)
; 6047 : 	CSP_ANS_NPCUPDATEDATA* lpMsg = (CSP_ANS_NPCUPDATEDATA*)lpRecv;

  09f79	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  09f7c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 6048 : 
; 6049 : 	if(lpMsg == NULL)

  09f7f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  09f83	75 02		 jne	 SHORT $LN4@GS_DGAnsCa@12

; 6050 : 	return;

  09f85	eb 52		 jmp	 SHORT $LN5@GS_DGAnsCa@12
$LN4@GS_DGAnsCa@12:

; 6051 : 
; 6052 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  09f87	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09f8a	0f b7 70 08	 movzx	 esi, WORD PTR [eax+8]
  09f8e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  09f93	e8 00 00 00 00	 call	 ?GetMapSvrGroup@CMapServerManager@@QAEHXZ ; CMapServerManager::GetMapSvrGroup
  09f98	3b f0		 cmp	 esi, eax
  09f9a	74 12		 je	 SHORT $LN3@GS_DGAnsCa@12

; 6053 : 	{
; 6054 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x89] GS_DGAnsCastleNpcUpdate() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()") ;

  09f9c	68 00 00 00 00	 push	 OFFSET ??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@
  09fa1	6a 02		 push	 2
  09fa3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  09fa9	83 c4 08	 add	 esp, 8

; 6055 : 		return;

  09fac	eb 2b		 jmp	 SHORT $LN5@GS_DGAnsCa@12
$LN3@GS_DGAnsCa@12:

; 6056 : 	}
; 6057 : 
; 6058 : 	char* szResult;
; 6059 : 
; 6060 : 	if(lpMsg->iResult != FALSE)

  09fae	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  09fb1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  09fb5	74 09		 je	 SHORT $LN2@GS_DGAnsCa@12

; 6061 : 	{
; 6062 : 		szResult = "SUCCEED";

  09fb7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _szResult$[ebp], OFFSET ??_C@_07OIIICFNN@SUCCEED?$AA@

; 6063 : 	}
; 6064 : 	else

  09fbe	eb 07		 jmp	 SHORT $LN1@GS_DGAnsCa@12
$LN2@GS_DGAnsCa@12:

; 6065 : 	{
; 6066 : 		szResult = "FAIL";

  09fc0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _szResult$[ebp], OFFSET ??_C@_04OOEBCMBF@FAIL?$AA@
$LN1@GS_DGAnsCa@12:

; 6067 : 	}
; 6068 : 
; 6069 : 	LogAddTD("[CastleSiege] [0x89] GS_DGAnsCastleNpcUpdate() - Npc Data Update Result : '%s'",szResult);

  09fc7	8b 45 f8	 mov	 eax, DWORD PTR _szResult$[ebp]
  09fca	50		 push	 eax
  09fcb	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@
  09fd0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09fd6	83 c4 08	 add	 esp, 8
$LN5@GS_DGAnsCa@12:

; 6070 : //#else
; 6071 : //	return;
; 6072 : //#endif
; 6073 : }

  09fd9	5f		 pop	 edi
  09fda	5e		 pop	 esi
  09fdb	5b		 pop	 ebx
  09fdc	8b e5		 mov	 esp, ebp
  09fde	5d		 pop	 ebp
  09fdf	c3		 ret	 0
?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcUpdate
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqCrywolfSync@@YAXHHH@Z			; GDReqCrywolfSync
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCrywolfState$ = 12					; size = 4
_iOccupationState$ = 16					; size = 4
?GDReqCrywolfSync@@YAXHHH@Z PROC			; GDReqCrywolfSync

; 6084 : {

  09fe0	55		 push	 ebp
  09fe1	8b ec		 mov	 ebp, esp
  09fe3	83 ec 54	 sub	 esp, 84			; 00000054H
  09fe6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  09feb	33 c5		 xor	 eax, ebp
  09fed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  09ff0	53		 push	 ebx
  09ff1	56		 push	 esi
  09ff2	57		 push	 edi

; 6085 : 	if ( iMapSvrGroup <0 )

  09ff3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  09ff7	7d 02		 jge	 SHORT $LN1@GDReqCrywo

; 6086 : 		return;

  09ff9	eb 3a		 jmp	 SHORT $LN2@GDReqCrywo
$LN1@GDReqCrywo:

; 6087 : 
; 6088 : 	CWP_REQ_CRYWOLFSYNC pMsg;
; 6089 : 
; 6090 : 	pMsg.h.set((LPBYTE)&pMsg, 0xB0, sizeof(CWP_REQ_CRYWOLFSYNC));

  09ffb	6a 10		 push	 16			; 00000010H
  09ffd	68 b0 00 00 00	 push	 176			; 000000b0H
  0a002	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a005	50		 push	 eax
  0a006	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a009	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6091 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0a00e	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0a012	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 6092 : 	pMsg.iCrywolfState = iCrywolfState;

  0a016	8b 45 0c	 mov	 eax, DWORD PTR _iCrywolfState$[ebp]
  0a019	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 6093 : 	pMsg.iOccupationState = iOccupationState;

  0a01c	8b 45 10	 mov	 eax, DWORD PTR _iOccupationState$[ebp]
  0a01f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 6094 : 
; 6095 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0a022	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0a026	50		 push	 eax
  0a027	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a02a	51		 push	 ecx
  0a02b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0a030	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDReqCrywo:

; 6096 : }

  0a035	5f		 pop	 edi
  0a036	5e		 pop	 esi
  0a037	5b		 pop	 ebx
  0a038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a03b	33 cd		 xor	 ecx, ebp
  0a03d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a042	8b e5		 mov	 esp, ebp
  0a044	5d		 pop	 ebp
  0a045	c3		 ret	 0
?GDReqCrywolfSync@@YAXHHH@Z ENDP			; GDReqCrywolfSync
_TEXT	ENDS
PUBLIC	??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@ ; `string'
EXTRN	?SetOccupationState@CCrywolfSync@@QAEXH@Z:PROC	; CCrywolfSync::SetOccupationState
EXTRN	?SetCrywolfState@CCrywolfSync@@QAEXH@Z:PROC	; CCrywolfSync::SetCrywolfState
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
;	COMDAT ??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@ DB '['
	DB	' CRYWOLF ] SYNC Occupation: %d, State: %d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iOldOccupationState$ = -8				; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?DGAnsCrywolfSync@@YAXPAE@Z PROC			; DGAnsCrywolfSync

; 6109 : {

  0a050	55		 push	 ebp
  0a051	8b ec		 mov	 ebp, esp
  0a053	83 ec 48	 sub	 esp, 72			; 00000048H
  0a056	53		 push	 ebx
  0a057	56		 push	 esi
  0a058	57		 push	 edi

; 6110 : 	CWP_ANS_CRYWOLFSYNC * lpMsg = (CWP_ANS_CRYWOLFSYNC *)lpRecv;

  0a059	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0a05c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 6111 : 
; 6112 : 	if ( lpMsg == NULL )

  0a05f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0a063	75 02		 jne	 SHORT $LN2@DGAnsCrywo

; 6113 : 		return;

  0a065	eb 6e		 jmp	 SHORT $LN3@DGAnsCrywo
$LN2@DGAnsCrywo:

; 6114 : 
; 6115 : 	int iOldOccupationState = g_CrywolfSync.GetOccupationState();

  0a067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0a06c	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  0a071	89 45 f8	 mov	 DWORD PTR _iOldOccupationState$[ebp], eax

; 6116 : 	g_CrywolfSync.SetCrywolfState(lpMsg->iCrywolfState);

  0a074	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a077	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0a07a	51		 push	 ecx
  0a07b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0a080	e8 00 00 00 00	 call	 ?SetCrywolfState@CCrywolfSync@@QAEXH@Z ; CCrywolfSync::SetCrywolfState

; 6117 : 	g_CrywolfSync.SetOccupationState(lpMsg->iOccupationState);

  0a085	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a088	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0a08b	51		 push	 ecx
  0a08c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0a091	e8 00 00 00 00	 call	 ?SetOccupationState@CCrywolfSync@@QAEXH@Z ; CCrywolfSync::SetOccupationState

; 6118 : 
; 6119 : 	if ( GetTickCount() > (dwCrywolfSyncLogTickCount+ 60000) )

  0a096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0a09c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwCrywolfSyncLogTickCount@@3KA ; dwCrywolfSyncLogTickCount
  0a0a2	81 c1 60 ea 00
	00		 add	 ecx, 60000		; 0000ea60H
  0a0a8	3b c1		 cmp	 eax, ecx
  0a0aa	76 29		 jbe	 SHORT $LN3@DGAnsCrywo

; 6120 : 	{
; 6121 : 		LogAddC(4, "[ CRYWOLF ] SYNC Occupation: %d, State: %d", lpMsg->iOccupationState, lpMsg->iCrywolfState);

  0a0ac	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a0af	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0a0b2	51		 push	 ecx
  0a0b3	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0a0b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0a0b9	50		 push	 eax
  0a0ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@
  0a0bf	6a 04		 push	 4
  0a0c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0a0c7	83 c4 10	 add	 esp, 16			; 00000010H

; 6122 : 		dwCrywolfSyncLogTickCount = GetTickCount();

  0a0ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0a0d0	a3 00 00 00 00	 mov	 DWORD PTR ?dwCrywolfSyncLogTickCount@@3KA, eax ; dwCrywolfSyncLogTickCount
$LN3@DGAnsCrywo:

; 6123 : 	}
; 6124 : }

  0a0d5	5f		 pop	 edi
  0a0d6	5e		 pop	 esi
  0a0d7	5b		 pop	 ebx
  0a0d8	8b e5		 mov	 esp, ebp
  0a0da	5d		 pop	 ebp
  0a0db	c3		 ret	 0
?DGAnsCrywolfSync@@YAXPAE@Z ENDP			; DGAnsCrywolfSync
_TEXT	ENDS
PUBLIC	?GDReqCrywolfInfoLoad@@YAXH@Z			; GDReqCrywolfInfoLoad
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GDReqCrywolfInfoLoad@@YAXH@Z PROC			; GDReqCrywolfInfoLoad

; 6133 : {

  0a0e0	55		 push	 ebp
  0a0e1	8b ec		 mov	 ebp, esp
  0a0e3	83 ec 48	 sub	 esp, 72			; 00000048H
  0a0e6	53		 push	 ebx
  0a0e7	56		 push	 esi
  0a0e8	57		 push	 edi

; 6134 : 	if ( iMapSvrGroup <0 )

  0a0e9	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  0a0ed	7d 02		 jge	 SHORT $LN1@GDReqCrywo@2

; 6135 : 		return;

  0a0ef	eb 2e		 jmp	 SHORT $LN2@GDReqCrywo@2
$LN1@GDReqCrywo@2:

; 6136 : 
; 6137 : 	CWP_REQ_CRYWOLFINFOLOAD pMsg;
; 6138 : 
; 6139 : 	pMsg.h.set((LPBYTE)&pMsg, 0xB1, sizeof(CWP_REQ_CRYWOLFINFOLOAD));

  0a0f1	6a 06		 push	 6
  0a0f3	68 b1 00 00 00	 push	 177			; 000000b1H
  0a0f8	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a0fb	50		 push	 eax
  0a0fc	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a0ff	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6140 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0a104	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0a108	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 6141 : 
; 6142 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0a10c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0a110	50		 push	 eax
  0a111	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a114	51		 push	 ecx
  0a115	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0a11a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDReqCrywo@2:

; 6143 : }

  0a11f	5f		 pop	 edi
  0a120	5e		 pop	 esi
  0a121	5b		 pop	 ebx
  0a122	8b e5		 mov	 esp, ebp
  0a124	5d		 pop	 ebp
  0a125	c3		 ret	 0
?GDReqCrywolfInfoLoad@@YAXH@Z ENDP			; GDReqCrywolfInfoLoad
_TEXT	ENDS
PUBLIC	??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@ ; `string'
EXTRN	?ApplyCrywolfDBInfo@CCrywolf@@QAEXHH@Z:PROC	; CCrywolf::ApplyCrywolfDBInfo
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
;	COMDAT ??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@
CONST	SEGMENT
??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@ DB '[ Cry'
	DB	'wolf ] Incorrect DB OccupationState!!!', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iResult$ = -8						; size = 4
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?DGAnsCrywolfInfoLoad@@YAXPAE@Z PROC			; DGAnsCrywolfInfoLoad

; 6154 : {

  0a130	55		 push	 ebp
  0a131	8b ec		 mov	 ebp, esp
  0a133	83 ec 48	 sub	 esp, 72			; 00000048H
  0a136	53		 push	 ebx
  0a137	56		 push	 esi
  0a138	57		 push	 edi

; 6155 : 	CWP_ANS_CRYWOLFINFOLOAD * lpMsg = (CWP_ANS_CRYWOLFINFOLOAD *)lpRecv;

  0a139	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0a13c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 6156 : 
; 6157 : //#if(GS_CASTLE==1)
; 6158 : 	if(lpMsg == NULL)

  0a13f	83 7d fc 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0a143	75 02		 jne	 SHORT $LN4@DGAnsCrywo@2

; 6159 : 	{
; 6160 : 		return;

  0a145	eb 68		 jmp	 SHORT $LN5@DGAnsCrywo@2
$LN4@DGAnsCrywo@2:

; 6161 : 	}
; 6162 : 
; 6163 : 	int iResult;
; 6164 : 
; 6165 : 	if( true != FALSE && lpMsg->iOccupationState >= 0 && lpMsg->iOccupationState <= 2)

  0a147	b8 01 00 00 00	 mov	 eax, 1
  0a14c	85 c0		 test	 eax, eax
  0a14e	74 1b		 je	 SHORT $LN3@DGAnsCrywo@2
  0a150	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a153	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0a157	7c 12		 jl	 SHORT $LN3@DGAnsCrywo@2
  0a159	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a15c	83 78 08 02	 cmp	 DWORD PTR [eax+8], 2
  0a160	7f 09		 jg	 SHORT $LN3@DGAnsCrywo@2

; 6166 : 	{
; 6167 : 		iResult = 1;

  0a162	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 1

; 6168 : 	}
; 6169 : 	else

  0a169	eb 07		 jmp	 SHORT $LN2@DGAnsCrywo@2
$LN3@DGAnsCrywo@2:

; 6170 : 	{
; 6171 : 		iResult = 0;

  0a16b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 0
$LN2@DGAnsCrywo@2:

; 6172 : 	}
; 6173 : 
; 6174 : 	lpMsg->btResult = iResult;

  0a172	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a175	8a 4d f8	 mov	 cl, BYTE PTR _iResult$[ebp]
  0a178	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 6175 : 
; 6176 : 	if((iResult & 0xFF) != 0)

  0a17b	8b 45 f8	 mov	 eax, DWORD PTR _iResult$[ebp]
  0a17e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0a183	74 1a		 je	 SHORT $LN1@DGAnsCrywo@2

; 6177 : 	{
; 6178 : 		g_Crywolf.ApplyCrywolfDBInfo(lpMsg->iCrywolfState,lpMsg->iOccupationState);

  0a185	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a188	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0a18b	51		 push	 ecx
  0a18c	8b 55 fc	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0a18f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0a192	50		 push	 eax
  0a193	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A ; g_Crywolf
  0a198	e8 00 00 00 00	 call	 ?ApplyCrywolfDBInfo@CCrywolf@@QAEXHH@Z ; CCrywolf::ApplyCrywolfDBInfo

; 6179 : 		return;

  0a19d	eb 10		 jmp	 SHORT $LN5@DGAnsCrywo@2
$LN1@DGAnsCrywo@2:

; 6180 : 	}
; 6181 : 
; 6182 : 	LogAddC(2,"[ Crywolf ] Incorrect DB OccupationState!!!");

  0a19f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@
  0a1a4	6a 02		 push	 2
  0a1a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0a1ac	83 c4 08	 add	 esp, 8
$LN5@DGAnsCrywo@2:

; 6183 : //#endif
; 6184 : }

  0a1af	5f		 pop	 edi
  0a1b0	5e		 pop	 esi
  0a1b1	5b		 pop	 ebx
  0a1b2	8b e5		 mov	 esp, ebp
  0a1b4	5d		 pop	 ebp
  0a1b5	c3		 ret	 0
?DGAnsCrywolfInfoLoad@@YAXPAE@Z ENDP			; DGAnsCrywolfInfoLoad
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqCrywolfInfoSave@@YAXHHH@Z			; GDReqCrywolfInfoSave
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCrywolfState$ = 12					; size = 4
_iOccupationState$ = 16					; size = 4
?GDReqCrywolfInfoSave@@YAXHHH@Z PROC			; GDReqCrywolfInfoSave

; 6195 : {

  0a1c0	55		 push	 ebp
  0a1c1	8b ec		 mov	 ebp, esp
  0a1c3	83 ec 54	 sub	 esp, 84			; 00000054H
  0a1c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a1cb	33 c5		 xor	 eax, ebp
  0a1cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a1d0	53		 push	 ebx
  0a1d1	56		 push	 esi
  0a1d2	57		 push	 edi

; 6196 : 	if ( iMapSvrGroup <0 )

  0a1d3	83 7d 08 00	 cmp	 DWORD PTR _iMapSvrGroup$[ebp], 0
  0a1d7	7d 02		 jge	 SHORT $LN1@GDReqCrywo@3

; 6197 : 		return;

  0a1d9	eb 3a		 jmp	 SHORT $LN2@GDReqCrywo@3
$LN1@GDReqCrywo@3:

; 6198 : 
; 6199 : 	CWP_REQ_CRYWOLFINFOSAVE pMsg;
; 6200 : 
; 6201 : 	pMsg.h.set((LPBYTE)&pMsg, 0xB2, sizeof(CWP_REQ_CRYWOLFINFOSAVE));

  0a1db	6a 10		 push	 16			; 00000010H
  0a1dd	68 b2 00 00 00	 push	 178			; 000000b2H
  0a1e2	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a1e5	50		 push	 eax
  0a1e6	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a1e9	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6202 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0a1ee	66 8b 45 08	 mov	 ax, WORD PTR _iMapSvrGroup$[ebp]
  0a1f2	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 6203 : 	pMsg.iCrywolfState = iCrywolfState;

  0a1f6	8b 45 0c	 mov	 eax, DWORD PTR _iCrywolfState$[ebp]
  0a1f9	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 6204 : 	pMsg.iOccupationState = iOccupationState;

  0a1fc	8b 45 10	 mov	 eax, DWORD PTR _iOccupationState$[ebp]
  0a1ff	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 6205 : 
; 6206 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0a202	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0a206	50		 push	 eax
  0a207	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a20a	51		 push	 ecx
  0a20b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0a210	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDReqCrywo@3:

; 6207 : }

  0a215	5f		 pop	 edi
  0a216	5e		 pop	 esi
  0a217	5b		 pop	 ebx
  0a218	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a21b	33 cd		 xor	 ecx, ebp
  0a21d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a222	8b e5		 mov	 esp, ebp
  0a224	5d		 pop	 ebp
  0a225	c3		 ret	 0
?GDReqCrywolfInfoSave@@YAXHHH@Z ENDP			; GDReqCrywolfInfoSave
; Function compile flags: /Odtp /ZI
_lpMsg$ = -4						; size = 4
_lpRecv$ = 8						; size = 4
?DGAnsCrywolfInfoSave@@YAXPAE@Z PROC			; DGAnsCrywolfInfoSave

; 6216 : {

  0a230	55		 push	 ebp
  0a231	8b ec		 mov	 ebp, esp
  0a233	83 ec 44	 sub	 esp, 68			; 00000044H
  0a236	53		 push	 ebx
  0a237	56		 push	 esi
  0a238	57		 push	 edi

; 6217 : 	CWP_ANS_CRYWOLFINFOSAVE * lpMsg = (CWP_ANS_CRYWOLFINFOSAVE *)lpRecv;

  0a239	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  0a23c	89 45 fc	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 6218 : }

  0a23f	5f		 pop	 edi
  0a240	5e		 pop	 esi
  0a241	5b		 pop	 ebx
  0a242	8b e5		 mov	 esp, ebp
  0a244	5d		 pop	 ebp
  0a245	c3		 ret	 0
?DGAnsCrywolfInfoSave@@YAXPAE@Z ENDP			; DGAnsCrywolfInfoSave
_TEXT	ENDS
PUBLIC	??_C@_0BO@LEBNDADM@Character?5Name?5Change?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
;	COMDAT ??_C@_0BO@LEBNDADM@Character?5Name?5Change?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BO@LEBNDADM@Character?5Name?5Change?5?3?5?$CFs?0?$CFs?$AA@ DB 'Cha'
	DB	'racter Name Change : %s,%s', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Name$248179 = -76					; size = 10
_Name2$248178 = -64					; size = 10
_pMsg$ = -52						; size = 25
_Result$ = -21						; size = 1
_aIndex$ = -20						; size = 4
_szAccountID$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGChangeNameResult@@YAXPAUSDHP_CHANGENAME_RESULT@@@Z PROC ; DGChangeNameResult

; 6232 : {

  0a250	55		 push	 ebp
  0a251	8b ec		 mov	 ebp, esp
  0a253	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0a259	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a25e	33 c5		 xor	 eax, ebp
  0a260	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a263	53		 push	 ebx
  0a264	56		 push	 esi
  0a265	57		 push	 edi

; 6233 : 	char szAccountID[10];
; 6234 : 	int aIndex = lpMsg->aIndex;

  0a266	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a269	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0a26c	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 6235 : 
; 6236 : 	BYTE Result = lpMsg->btResult;

  0a26f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a272	8a 48 26	 mov	 cl, BYTE PTR [eax+38]
  0a275	88 4d eb	 mov	 BYTE PTR _Result$[ebp], cl

; 6237 : 
; 6238 : 	szAccountID[10] = '\0';

  0a278	c6 45 fa 00	 mov	 BYTE PTR _szAccountID$[ebp+10], 0

; 6239 : 
; 6240 : 	memcpy(szAccountID, lpMsg->szAccountID, sizeof(szAccountID));

  0a27c	6a 0a		 push	 10			; 0000000aH
  0a27e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a281	83 c0 08	 add	 eax, 8
  0a284	50		 push	 eax
  0a285	8d 4d f0	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  0a288	51		 push	 ecx
  0a289	e8 00 00 00 00	 call	 _memcpy
  0a28e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6241 : 	
; 6242 : 	if(::gObjIsAccontConnect(aIndex, szAccountID) == FALSE )

  0a291	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  0a294	50		 push	 eax
  0a295	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0a298	51		 push	 ecx
  0a299	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0a29e	83 c4 08	 add	 esp, 8
  0a2a1	85 c0		 test	 eax, eax
  0a2a3	75 30		 jne	 SHORT $LN2@DGChangeNa

; 6243 : 	{
; 6244 : 		LogAddC(2, lMsg.Get(424), szAccountID);

  0a2a5	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  0a2a8	50		 push	 eax
  0a2a9	68 a8 01 00 00	 push	 424			; 000001a8H
  0a2ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0a2b3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0a2b8	50		 push	 eax
  0a2b9	6a 02		 push	 2
  0a2bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0a2c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6245 : 		CloseClient(aIndex);

  0a2c4	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a2c7	50		 push	 eax
  0a2c8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0a2cd	83 c4 04	 add	 esp, 4

; 6246 : 		return;

  0a2d0	e9 ad 00 00 00	 jmp	 $LN3@DGChangeNa
$LN2@DGChangeNa:

; 6247 : 	}
; 6248 : 
; 6249 : 	PMSG_CHANGE_NAME pMsg;
; 6250 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x16, sizeof(pMsg));

  0a2d5	6a 19		 push	 25			; 00000019H
  0a2d7	6a 16		 push	 22			; 00000016H
  0a2d9	68 f3 00 00 00	 push	 243			; 000000f3H
  0a2de	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a2e1	50		 push	 eax
  0a2e2	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0a2e7	83 c4 10	 add	 esp, 16			; 00000010H

; 6251 : 	
; 6252 : 	pMsg.btResult = lpMsg->btResult;

  0a2ea	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a2ed	8a 48 26	 mov	 cl, BYTE PTR [eax+38]
  0a2f0	88 4d e4	 mov	 BYTE PTR _pMsg$[ebp+24], cl

; 6253 : 
; 6254 : 	memcpy(pMsg.szName, lpMsg->szName, sizeof(pMsg.szName));

  0a2f3	6a 0a		 push	 10			; 0000000aH
  0a2f5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a2f8	83 c0 12	 add	 eax, 18			; 00000012H
  0a2fb	50		 push	 eax
  0a2fc	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0a2ff	51		 push	 ecx
  0a300	e8 00 00 00 00	 call	 _memcpy
  0a305	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6255 :     memcpy(pMsg.szName2, lpMsg->szName2, sizeof(pMsg.szName2));

  0a308	6a 0a		 push	 10			; 0000000aH
  0a30a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a30d	83 c0 1c	 add	 eax, 28			; 0000001cH
  0a310	50		 push	 eax
  0a311	8d 4d da	 lea	 ecx, DWORD PTR _pMsg$[ebp+14]
  0a314	51		 push	 ecx
  0a315	e8 00 00 00 00	 call	 _memcpy
  0a31a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6256 : 
; 6257 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0a31d	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0a321	50		 push	 eax
  0a322	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a325	51		 push	 ecx
  0a326	8b 55 ec	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0a329	52		 push	 edx
  0a32a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0a32f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6258 : 
; 6259 : 	if ( Result == 0)

  0a332	0f b6 45 eb	 movzx	 eax, BYTE PTR _Result$[ebp]
  0a336	85 c0		 test	 eax, eax
  0a338	75 48		 jne	 SHORT $LN3@DGChangeNa

; 6260 :     {
; 6261 : 		char Name2[10];
; 6262 : 		char Name[10];
; 6263 : 		Name2[10] = '\0';

  0a33a	c6 45 ca 00	 mov	 BYTE PTR _Name2$248178[ebp+10], 0

; 6264 : 		Name[10] = '\0';

  0a33e	c6 45 be 00	 mov	 BYTE PTR _Name$248179[ebp+10], 0

; 6265 : 
; 6266 : 		memcpy(Name2, lpMsg->szName2, sizeof(Name2));

  0a342	6a 0a		 push	 10			; 0000000aH
  0a344	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a347	83 c0 1c	 add	 eax, 28			; 0000001cH
  0a34a	50		 push	 eax
  0a34b	8d 4d c0	 lea	 ecx, DWORD PTR _Name2$248178[ebp]
  0a34e	51		 push	 ecx
  0a34f	e8 00 00 00 00	 call	 _memcpy
  0a354	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6267 : 		memcpy(Name, lpMsg->szName, sizeof(Name));

  0a357	6a 0a		 push	 10			; 0000000aH
  0a359	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a35c	83 c0 12	 add	 eax, 18			; 00000012H
  0a35f	50		 push	 eax
  0a360	8d 4d b4	 lea	 ecx, DWORD PTR _Name$248179[ebp]
  0a363	51		 push	 ecx
  0a364	e8 00 00 00 00	 call	 _memcpy
  0a369	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6268 : 
; 6269 : 		LogAddTD("Character Name Change : %s,%s", Name, Name2);

  0a36c	8d 45 c0	 lea	 eax, DWORD PTR _Name2$248178[ebp]
  0a36f	50		 push	 eax
  0a370	8d 4d b4	 lea	 ecx, DWORD PTR _Name$248179[ebp]
  0a373	51		 push	 ecx
  0a374	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LEBNDADM@Character?5Name?5Change?5?3?5?$CFs?0?$CFs?$AA@
  0a379	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a37f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@DGChangeNa:

; 6270 :     }
; 6271 : }

  0a382	5f		 pop	 edi
  0a383	5e		 pop	 esi
  0a384	5b		 pop	 ebx
  0a385	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a388	33 cd		 xor	 ecx, ebp
  0a38a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a38f	8b e5		 mov	 esp, ebp
  0a391	5d		 pop	 ebp
  0a392	c3		 ret	 0
?DGChangeNameResult@@YAXPAUSDHP_CHANGENAME_RESULT@@@Z ENDP ; DGChangeNameResult
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -28						; size = 5
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGSummonerStateUpdatedSend@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z PROC ; DGSummonerStateUpdatedSend

; 6277 : {

  0a3a0	55		 push	 ebp
  0a3a1	8b ec		 mov	 ebp, esp
  0a3a3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0a3a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a3ab	33 c5		 xor	 eax, ebp
  0a3ad	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a3b0	53		 push	 ebx
  0a3b1	56		 push	 esi
  0a3b2	57		 push	 edi

; 6278 : 	char szId[MAX_ACCOUNT_LEN];
; 6279 : 
; 6280 : 	szId[MAX_ACCOUNT_LEN] = 0;

  0a3b3	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 6281 : 
; 6282 : 	memcpy(szId, lpMsg->szAccountID, MAX_ACCOUNT_LEN);

  0a3b7	6a 0a		 push	 10			; 0000000aH
  0a3b9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a3bc	83 c0 03	 add	 eax, 3
  0a3bf	50		 push	 eax
  0a3c0	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0a3c3	51		 push	 ecx
  0a3c4	e8 00 00 00 00	 call	 _memcpy
  0a3c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6283 : 
; 6284 : 	int aIndex = lpMsg->aIndex;

  0a3cc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a3cf	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0a3d3	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 6285 : 
; 6286 : 	if(::gObjIsAccontConnect(aIndex, szId) == FALSE )

  0a3d6	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0a3d9	50		 push	 eax
  0a3da	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0a3dd	51		 push	 ecx
  0a3de	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0a3e3	83 c4 08	 add	 esp, 8
  0a3e6	85 c0		 test	 eax, eax
  0a3e8	75 41		 jne	 SHORT $LN1@DGSummoner

; 6287 : 	{
; 6288 : 		LogAddC(2, lMsg.Get(MSGGET(1, 165)), gObj[aIndex].AccountID, szId);

  0a3ea	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0a3ed	50		 push	 eax
  0a3ee	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0a3f1	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0a3f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a3fd	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  0a401	50		 push	 eax
  0a402	68 a5 01 00 00	 push	 421			; 000001a5H
  0a407	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0a40c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0a411	50		 push	 eax
  0a412	6a 02		 push	 2
  0a414	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0a41a	83 c4 10	 add	 esp, 16			; 00000010H

; 6289 : 		CloseClient(aIndex);

  0a41d	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a420	50		 push	 eax
  0a421	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0a426	83 c4 04	 add	 esp, 4

; 6290 : 		return;

  0a429	eb 3b		 jmp	 SHORT $LN2@DGSummoner
$LN1@DGSummoner:

; 6291 : 	}
; 6292 : 
; 6293 : 	gObj[aIndex].Summoner = 1;	//Fix Summoner

  0a42b	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a42e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a434	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a43a	c6 84 01 84 20
	00 00 01	 mov	 BYTE PTR [ecx+eax+8324], 1

; 6294 : 	//gObj[aIndex].Summoner = lpMsg->IsSummonerEnable;
; 6295 : 
; 6296 : 	PMSG_UPD_SUMMONER_CREATE pMsg;
; 6297 : 	pMsg.h.set((LPBYTE)&pMsg, 0xDE, sizeof(pMsg));

  0a442	6a 05		 push	 5
  0a444	68 de 00 00 00	 push	 222			; 000000deH
  0a449	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a44c	50		 push	 eax
  0a44d	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a450	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6298 : 
; 6299 : 	pMsg.btResult = 0;

  0a455	c6 45 e7 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 6300 : 	pMsg.IsSummonerEnable = lpMsg->IsSummonerEnable | 15;

  0a459	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a45c	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  0a460	83 c9 0f	 or	 ecx, 15			; 0000000fH
  0a463	88 4d e8	 mov	 BYTE PTR _pMsg$[ebp+4], cl
$LN2@DGSummoner:

; 6301 : 
; 6302 : #ifndef CHARCREATE_TEMP
; 6303 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 6304 : #endif
; 6305 : }

  0a466	5f		 pop	 edi
  0a467	5e		 pop	 esi
  0a468	5b		 pop	 ebx
  0a469	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a46c	33 cd		 xor	 ecx, ebp
  0a46e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a473	8b e5		 mov	 esp, ebp
  0a475	5d		 pop	 ebp
  0a476	c3		 ret	 0
?DGSummonerStateUpdatedSend@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z ENDP ; DGSummonerStateUpdatedSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDSummonerStateUpdate@@YAXPAUOBJECTSTRUCT@@H@Z	; GDSummonerStateUpdate
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GDSummonerStateUpdate@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GDSummonerStateUpdate

; 6316 : {

  0a480	55		 push	 ebp
  0a481	8b ec		 mov	 ebp, esp
  0a483	83 ec 54	 sub	 esp, 84			; 00000054H
  0a486	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a48b	33 c5		 xor	 eax, ebp
  0a48d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a490	53		 push	 ebx
  0a491	56		 push	 esi
  0a492	57		 push	 edi

; 6317 : 	PMSG_REQ_SUMMONER_CREATE pMsg;
; 6318 : 
; 6319 : 	pMsg.h.set((LPBYTE)&pMsg, 0xA2, sizeof(pMsg));

  0a493	6a 10		 push	 16			; 00000010H
  0a495	68 a2 00 00 00	 push	 162			; 000000a2H
  0a49a	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a49d	50		 push	 eax
  0a49e	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a4a1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6320 : 
; 6321 : 	memset(pMsg.szAccountID, 0, sizeof(pMsg.szAccountID));

  0a4a6	6a 0b		 push	 11			; 0000000bH
  0a4a8	6a 00		 push	 0
  0a4aa	8d 45 ef	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  0a4ad	50		 push	 eax
  0a4ae	e8 00 00 00 00	 call	 _memset
  0a4b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6322 : 	memcpy(pMsg.szAccountID, lpObj->AccountID, MAX_ACCOUNT_LEN);

  0a4b6	6a 0a		 push	 10			; 0000000aH
  0a4b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a4bb	83 c0 6c	 add	 eax, 108		; 0000006cH
  0a4be	50		 push	 eax
  0a4bf	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  0a4c2	51		 push	 ecx
  0a4c3	e8 00 00 00 00	 call	 _memcpy
  0a4c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6323 : 
; 6324 : 	pMsg.aIndex = lpObj->m_Index;

  0a4cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a4ce	66 8b 08	 mov	 cx, WORD PTR [eax]
  0a4d1	66 89 4d fa	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 6325 : 
; 6326 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  0a4d5	6a 10		 push	 16			; 00000010H
  0a4d7	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a4da	50		 push	 eax
  0a4db	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0a4e0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6327 : }

  0a4e5	5f		 pop	 edi
  0a4e6	5e		 pop	 esi
  0a4e7	5b		 pop	 ebx
  0a4e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a4eb	33 cd		 xor	 ecx, ebp
  0a4ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a4f2	8b e5		 mov	 esp, ebp
  0a4f4	5d		 pop	 ebp
  0a4f5	c3		 ret	 0
?GDSummonerStateUpdate@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GDSummonerStateUpdate
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -28						; size = 5
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGSummonerStateRecv@@YAXPAUPMSG_ANS_SUMMONER_STATUS@@@Z PROC ; DGSummonerStateRecv

; 6331 : {

  0a500	55		 push	 ebp
  0a501	8b ec		 mov	 ebp, esp
  0a503	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0a506	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a50b	33 c5		 xor	 eax, ebp
  0a50d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a510	53		 push	 ebx
  0a511	56		 push	 esi
  0a512	57		 push	 edi

; 6332 : 	char szId[MAX_ACCOUNT_LEN];
; 6333 : 
; 6334 : 	szId[MAX_ACCOUNT_LEN] = 0;

  0a513	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 6335 : 
; 6336 : 	memcpy(szId, lpMsg->szAccountID, MAX_ACCOUNT_LEN);

  0a517	6a 0a		 push	 10			; 0000000aH
  0a519	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a51c	83 c0 03	 add	 eax, 3
  0a51f	50		 push	 eax
  0a520	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0a523	51		 push	 ecx
  0a524	e8 00 00 00 00	 call	 _memcpy
  0a529	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6337 : 
; 6338 : 	int aIndex = lpMsg->aIndex;

  0a52c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a52f	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0a533	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 6339 : 
; 6340 : 	if(::gObjIsAccontConnect(aIndex, szId) == FALSE )

  0a536	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0a539	50		 push	 eax
  0a53a	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0a53d	51		 push	 ecx
  0a53e	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0a543	83 c4 08	 add	 esp, 8
  0a546	85 c0		 test	 eax, eax
  0a548	75 41		 jne	 SHORT $LN1@DGSummoner@2

; 6341 : 	{
; 6342 : 		LogAddC(2, lMsg.Get(MSGGET(1, 165)), gObj[aIndex].AccountID, szId);

  0a54a	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0a54d	50		 push	 eax
  0a54e	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0a551	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0a557	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a55d	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  0a561	50		 push	 eax
  0a562	68 a5 01 00 00	 push	 421			; 000001a5H
  0a567	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0a56c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0a571	50		 push	 eax
  0a572	6a 02		 push	 2
  0a574	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0a57a	83 c4 10	 add	 esp, 16			; 00000010H

; 6343 : 		CloseClient(aIndex);

  0a57d	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a580	50		 push	 eax
  0a581	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0a586	83 c4 04	 add	 esp, 4

; 6344 : 		return;

  0a589	eb 44		 jmp	 SHORT $LN2@DGSummoner@2
$LN1@DGSummoner@2:

; 6345 : 	}
; 6346 : 
; 6347 : 	//if(lpMsg->btResult == 1)
; 6348 : 	//{
; 6349 : 		gObj[aIndex].Summoner = 1;

  0a58b	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a58e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a594	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a59a	c6 84 01 84 20
	00 00 01	 mov	 BYTE PTR [ecx+eax+8324], 1

; 6350 : 	//}
; 6351 : 
; 6352 : 	PMSG_UPD_SUMMONER_CREATE pMsg;
; 6353 : 	pMsg.h.set((LPBYTE)&pMsg, 0xDE, sizeof(pMsg));

  0a5a2	6a 05		 push	 5
  0a5a4	68 de 00 00 00	 push	 222			; 000000deH
  0a5a9	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a5ac	50		 push	 eax
  0a5ad	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a5b0	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6354 : 
; 6355 : 	pMsg.btResult = 1;

  0a5b5	c6 45 e7 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 6356 : 	pMsg.IsSummonerEnable = 1;//lpMsg->btResult;

  0a5b9	c6 45 e8 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 6357 : 
; 6358 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0a5bd	6a 05		 push	 5
  0a5bf	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a5c2	50		 push	 eax
  0a5c3	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0a5c6	51		 push	 ecx
  0a5c7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0a5cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@DGSummoner@2:

; 6359 : }

  0a5cf	5f		 pop	 edi
  0a5d0	5e		 pop	 esi
  0a5d1	5b		 pop	 ebx
  0a5d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a5d5	33 cd		 xor	 ecx, ebp
  0a5d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a5dc	8b e5		 mov	 esp, ebp
  0a5de	5d		 pop	 ebp
  0a5df	c3		 ret	 0
?DGSummonerStateRecv@@YAXPAUPMSG_ANS_SUMMONER_STATUS@@@Z ENDP ; DGSummonerStateRecv
_TEXT	ENDS
PUBLIC	??_C@_0BF@OJNIPFKN@?$FLUnBanChar?$FN?5?$CFs?5Error?$AA@ ; `string'
PUBLIC	??_C@_0P@HIMPPMLD@?$FLUnBanChar?$FN?5?$CFs?$AA@	; `string'
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
;	COMDAT ??_C@_0BF@OJNIPFKN@?$FLUnBanChar?$FN?5?$CFs?5Error?$AA@
CONST	SEGMENT
??_C@_0BF@OJNIPFKN@?$FLUnBanChar?$FN?5?$CFs?5Error?$AA@ DB '[UnBanChar] %'
	DB	's Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HIMPPMLD@?$FLUnBanChar?$FN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@HIMPPMLD@?$FLUnBanChar?$FN?5?$CFs?$AA@ DB '[UnBanChar] %s', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DSBanSystem@@YAXPAUBAN_CHAR_DS@@@Z PROC		; DSBanSystem

; 6435 : {

  0a5e0	55		 push	 ebp
  0a5e1	8b ec		 mov	 ebp, esp
  0a5e3	83 ec 40	 sub	 esp, 64			; 00000040H
  0a5e6	53		 push	 ebx
  0a5e7	56		 push	 esi
  0a5e8	57		 push	 edi

; 6436 : 	if(lpMsg == NULL)

  0a5e9	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0a5ed	75 02		 jne	 SHORT $LN5@DSBanSyste

; 6437 : 	{
; 6438 : 		return;

  0a5ef	eb 64		 jmp	 SHORT $LN6@DSBanSyste
$LN5@DSBanSyste:

; 6439 : 	}
; 6440 : 
; 6441 : 	if(!gObjIsConnectedGP(lpMsg->aIndex))

  0a5f1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a5f4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0a5f7	51		 push	 ecx
  0a5f8	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0a5fd	83 c4 04	 add	 esp, 4
  0a600	85 c0		 test	 eax, eax
  0a602	75 02		 jne	 SHORT $LN4@DSBanSyste

; 6442 : 	{
; 6443 : 		return;

  0a604	eb 4f		 jmp	 SHORT $LN6@DSBanSyste
$LN4@DSBanSyste:

; 6444 : 	}
; 6445 : 
; 6446 : 	if(lpMsg->Type == 3)

  0a606	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a609	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0a60d	83 f9 03	 cmp	 ecx, 3
  0a610	75 43		 jne	 SHORT $LN6@DSBanSyste

; 6447 : 	{
; 6448 : 		if(lpMsg->Result)

  0a612	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a615	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0a619	85 c9		 test	 ecx, ecx
  0a61b	74 1d		 je	 SHORT $LN2@DSBanSyste

; 6449 : 		{
; 6450 : 			MsgNormal(lpMsg->aIndex,"[UnBanChar] %s",lpMsg->Name);

  0a61d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a620	83 c0 0c	 add	 eax, 12			; 0000000cH
  0a623	50		 push	 eax
  0a624	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HIMPPMLD@?$FLUnBanChar?$FN?5?$CFs?$AA@
  0a629	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0a62c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0a62f	52		 push	 edx
  0a630	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0a635	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6451 : 		}
; 6452 : 		else

  0a638	eb 1b		 jmp	 SHORT $LN6@DSBanSyste
$LN2@DSBanSyste:

; 6453 : 		{
; 6454 : 			MsgNormal(lpMsg->aIndex,"[UnBanChar] %s Error",lpMsg->Name);

  0a63a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a63d	83 c0 0c	 add	 eax, 12			; 0000000cH
  0a640	50		 push	 eax
  0a641	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OJNIPFKN@?$FLUnBanChar?$FN?5?$CFs?5Error?$AA@
  0a646	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0a649	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0a64c	52		 push	 edx
  0a64d	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0a652	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@DSBanSyste:

; 6455 : 		}
; 6456 : 	}
; 6457 : }

  0a655	5f		 pop	 edi
  0a656	5e		 pop	 esi
  0a657	5b		 pop	 ebx
  0a658	8b e5		 mov	 esp, ebp
  0a65a	5d		 pop	 ebp
  0a65b	c3		 ret	 0
?DSBanSystem@@YAXPAUBAN_CHAR_DS@@@Z ENDP		; DSBanSystem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDUpdateExtendedInvenCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z ; GDUpdateExtendedInvenCount
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_ExpandedInventory$ = 12				; size = 1
_dwEventIndex$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
_bBuyAtInGameShop$ = 24					; size = 1
_bIsReplace$ = 28					; size = 1
?GDUpdateExtendedInvenCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z PROC ; GDUpdateExtendedInvenCount

; 6460 : {

  0a660	55		 push	 ebp
  0a661	8b ec		 mov	 ebp, esp
  0a663	83 ec 64	 sub	 esp, 100		; 00000064H
  0a666	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a66b	33 c5		 xor	 eax, ebp
  0a66d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a670	53		 push	 ebx
  0a671	56		 push	 esi
  0a672	57		 push	 edi

; 6461 : 	SDHP_REQ_SET_EXTENDEDINVEN_COUNT pMsg;
; 6462 : 	pMsg.h.set((LPBYTE)&pMsg, 0xD5, sizeof(pMsg));

  0a673	6a 20		 push	 32			; 00000020H
  0a675	68 d5 00 00 00	 push	 213			; 000000d5H
  0a67a	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a67d	50		 push	 eax
  0a67e	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a681	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6463 : 	// ----
; 6464 : 	memcpy(pMsg.szCharName, lpObj->Name, 11);

  0a686	6a 0b		 push	 11			; 0000000bH
  0a688	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a68b	83 c0 77	 add	 eax, 119		; 00000077H
  0a68e	50		 push	 eax
  0a68f	8d 4d df	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  0a692	51		 push	 ecx
  0a693	e8 00 00 00 00	 call	 _memcpy
  0a698	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6465 : 	pMsg.Number				= lpObj->m_Index;

  0a69b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a69e	66 8b 08	 mov	 cx, WORD PTR [eax]
  0a6a1	66 89 4d ea	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 6466 : 	pMsg.ExtendedInvenCount = ExpandedInventory;

  0a6a5	8a 45 0c	 mov	 al, BYTE PTR _ExpandedInventory$[ebp]
  0a6a8	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+16], al

; 6467 : 	pMsg.EventIndex			= dwEventIndex;

  0a6ab	8b 45 10	 mov	 eax, DWORD PTR _dwEventIndex$[ebp]
  0a6ae	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 6468 : 	pMsg.ItemPos			= iItemPos;

  0a6b1	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0a6b4	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 6469 : 	pMsg.BuyAtInGameShop	= bBuyAtInGameShop;

  0a6b7	8a 45 18	 mov	 al, BYTE PTR _bBuyAtInGameShop$[ebp]
  0a6ba	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+28], al

; 6470 : 	pMsg.IsReplace			= bIsReplace;

  0a6bd	8a 45 1c	 mov	 al, BYTE PTR _bIsReplace$[ebp]
  0a6c0	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+29], al

; 6471 : 	// ----
; 6472 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  0a6c3	6a 20		 push	 32			; 00000020H
  0a6c5	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a6c8	50		 push	 eax
  0a6c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0a6ce	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6473 : }

  0a6d3	5f		 pop	 edi
  0a6d4	5e		 pop	 esi
  0a6d5	5b		 pop	 ebx
  0a6d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a6d9	33 cd		 xor	 ecx, ebp
  0a6db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a6e0	8b e5		 mov	 esp, ebp
  0a6e2	5d		 pop	 ebp
  0a6e3	c3		 ret	 0
?GDUpdateExtendedInvenCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z ENDP ; GDUpdateExtendedInvenCount
_TEXT	ENDS
PUBLIC	??_C@_0EL@PCONLJDC@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Er@ ; `string'
PUBLIC	??_C@_0EG@IGKGAEFN@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Fa@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?GCResultForExtendInvenOrWarehouse@@YAXHE@Z:PROC ; GCResultForExtendInvenOrWarehouse
;	COMDAT ??_C@_0EL@PCONLJDC@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Er@
CONST	SEGMENT
??_C@_0EL@PCONLJDC@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Er@ DB '[E'
	DB	'xtended Storage][Inventory] Error Item Pos. User Name : %s. I'
	DB	'temPos : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@IGKGAEFN@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Fa@
CONST	SEGMENT
??_C@_0EG@IGKGAEFN@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Fa@ DB '[E'
	DB	'xtended Storage][Inventory] Fail to extend inventory User Nam'
	DB	'e : %s', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szTemp$ = -268						; size = 256
_lpObj$ = -12						; size = 4
_aIndex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGUpdateExtendedInvenCountResult@@YAXPAUSDHP_ANS_SET_EXTENDEDINVEN_COUNT@@@Z PROC ; DGUpdateExtendedInvenCountResult

; 6478 : {

  0a6f0	55		 push	 ebp
  0a6f1	8b ec		 mov	 ebp, esp
  0a6f3	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  0a6f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a6fe	33 c5		 xor	 eax, ebp
  0a700	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a703	53		 push	 ebx
  0a704	56		 push	 esi
  0a705	57		 push	 edi

; 6479 : 	int aIndex = lpMsg->Number;

  0a706	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a709	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0a70d	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 6480 : 	// ----
; 6481 : 	if( !gObjIsConnected(aIndex) )

  0a710	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a713	50		 push	 eax
  0a714	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0a719	83 c4 04	 add	 esp, 4
  0a71c	85 c0		 test	 eax, eax
  0a71e	75 05		 jne	 SHORT $LN6@DGUpdateEx

; 6482 : 	{
; 6483 : 		return;

  0a720	e9 7f 01 00 00	 jmp	 $LN7@DGUpdateEx
$LN6@DGUpdateEx:

; 6484 : 	}
; 6485 : 	// ----
; 6486 : 	LPOBJ lpObj = &gObj[aIndex];

  0a725	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a728	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a72e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a734	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6487 : 	// ----
; 6488 : 	if( !lpMsg->Result )

  0a737	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a73a	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0a73e	85 c9		 test	 ecx, ecx
  0a740	75 46		 jne	 SHORT $LN5@DGUpdateEx

; 6489 : 	{
; 6490 : 		//if( lpMsg->BuyAtInGameShop == 1 )
; 6491 : 		//		CCashShopInGame::RollBackUseItem(v8, lpMsg->EventIndex);
; 6492 : 		//	else
; 6493 : 		//		GCInventoryItemDeleteSend(v9, 0xFFu, 1u);
; 6494 : 			GCResultForExtendInvenOrWarehouse(aIndex, 0);

  0a742	6a 00		 push	 0
  0a744	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a747	50		 push	 eax
  0a748	e8 00 00 00 00	 call	 ?GCResultForExtendInvenOrWarehouse@@YAXHE@Z ; GCResultForExtendInvenOrWarehouse
  0a74d	83 c4 08	 add	 esp, 8

; 6495 : 			LogAddTD("[Extended Storage][Inventory] Fail to extend inventory User Name : %s", lpObj->Name);

  0a750	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a753	83 c0 77	 add	 eax, 119		; 00000077H
  0a756	50		 push	 eax
  0a757	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@IGKGAEFN@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Fa@
  0a75c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a762	83 c4 08	 add	 esp, 8

; 6496 : 			GCServerMsgStringSend(lMsg.Get(3483), aIndex, 1);

  0a765	6a 01		 push	 1
  0a767	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a76a	50		 push	 eax
  0a76b	68 9b 0d 00 00	 push	 3483			; 00000d9bH
  0a770	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0a775	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0a77a	50		 push	 eax
  0a77b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0a780	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6497 : 			return;

  0a783	e9 1c 01 00 00	 jmp	 $LN7@DGUpdateEx
$LN5@DGUpdateEx:

; 6498 : 	}
; 6499 : 	// ----
; 6500 : 	lpObj->ExpandedInventory = lpMsg->ExtendedInvenCount;

  0a788	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a78b	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0a78e	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  0a791	88 90 24 26 00
	00		 mov	 BYTE PTR [eax+9764], dl

; 6501 : 	// ----
; 6502 : 	if( lpObj->ExpandedInventory < 0 || lpObj->ExpandedInventory > 2 )

  0a797	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a79a	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  0a7a1	85 c9		 test	 ecx, ecx
  0a7a3	7c 0f		 jl	 SHORT $LN3@DGUpdateEx
  0a7a5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a7a8	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  0a7af	83 f9 02	 cmp	 ecx, 2
  0a7b2	7e 0a		 jle	 SHORT $LN4@DGUpdateEx
$LN3@DGUpdateEx:

; 6503 : 	{
; 6504 : 		lpObj->ExpandedInventory = 0;

  0a7b4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a7b7	c6 80 24 26 00
	00 00		 mov	 BYTE PTR [eax+9764], 0
$LN4@DGUpdateEx:

; 6505 : 	}
; 6506 : 	// ----
; 6507 : 	//if( lpMsg->BuyAtInGameShop == 1 )
; 6508 : 	//{
; 6509 : 	//	CCashShopInGame::SetActiveItemResult(v8, lpMsg->EventIndex);
; 6510 : 	//}
; 6511 : 	//else
; 6512 : 	//{
; 6513 : 	if( lpMsg->ItemPos > 203 || lpMsg->ItemPos < 0 )

  0a7be	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a7c1	81 78 0c cb 00
	00 00		 cmp	 DWORD PTR [eax+12], 203	; 000000cbH
  0a7c8	7f 09		 jg	 SHORT $LN1@DGUpdateEx
  0a7ca	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a7cd	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0a7d1	7d 21		 jge	 SHORT $LN2@DGUpdateEx
$LN1@DGUpdateEx:

; 6514 : 	{
; 6515 : 		LogAddTD("[Extended Storage][Inventory] Error Item Pos. User Name : %s. ItemPos : %d", lpObj->Name, lpMsg->ItemPos);

  0a7d3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a7d6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0a7d9	51		 push	 ecx
  0a7da	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0a7dd	83 c2 77	 add	 edx, 119		; 00000077H
  0a7e0	52		 push	 edx
  0a7e1	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PCONLJDC@?$FLExtended?5Storage?$FN?$FLInventory?$FN?5Er@
  0a7e6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a7ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6516 : 		return;

  0a7ef	e9 b0 00 00 00	 jmp	 $LN7@DGUpdateEx
$LN2@DGUpdateEx:

; 6517 : 	}
; 6518 : 	// ----
; 6519 : 	gObjInventoryItemSet(aIndex, lpMsg->ItemPos, 0xFF);

  0a7f4	68 ff 00 00 00	 push	 255			; 000000ffH
  0a7f9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a7fc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0a7ff	51		 push	 ecx
  0a800	8b 55 f8	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0a803	52		 push	 edx
  0a804	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0a809	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6520 : 	lpObj->pInventory[lpMsg->ItemPos].Clear();

  0a80c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a80f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0a812	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a818	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0a81b	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  0a821	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 6521 : 	GCInventoryItemDeleteSend(aIndex, lpMsg->ItemPos, 1);

  0a826	6a 01		 push	 1
  0a828	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a82b	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0a82f	51		 push	 ecx
  0a830	8b 55 f8	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0a833	52		 push	 edx
  0a834	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0a839	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6522 : 	GCResultForExtendInvenOrWarehouse(aIndex, 1);

  0a83c	6a 01		 push	 1
  0a83e	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a841	50		 push	 eax
  0a842	e8 00 00 00 00	 call	 ?GCResultForExtendInvenOrWarehouse@@YAXHE@Z ; GCResultForExtendInvenOrWarehouse
  0a847	83 c4 08	 add	 esp, 8

; 6523 : 	// ----
; 6524 : 	char szTemp[0x100] = { 0 };

  0a84a	c6 85 f4 fe ff
	ff 00		 mov	 BYTE PTR _szTemp$[ebp], 0
  0a851	68 ff 00 00 00	 push	 255			; 000000ffH
  0a856	6a 00		 push	 0
  0a858	8d 85 f5 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp+1]
  0a85e	50		 push	 eax
  0a85f	e8 00 00 00 00	 call	 _memset
  0a864	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6525 : 	wsprintfA(szTemp, lMsg.Get(3481), lpMsg->ExtendedInvenCount);	//maybe 0, 0 in param +

  0a867	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a86a	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0a86e	51		 push	 ecx
  0a86f	68 99 0d 00 00	 push	 3481			; 00000d99H
  0a874	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0a879	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0a87e	50		 push	 eax
  0a87f	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0a885	52		 push	 edx
  0a886	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0a88c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6526 : 	GCServerMsgStringSend(szTemp, aIndex, 1);	

  0a88f	6a 01		 push	 1
  0a891	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a894	50		 push	 eax
  0a895	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0a89b	51		 push	 ecx
  0a89c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0a8a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@DGUpdateEx:

; 6527 : }

  0a8a4	5f		 pop	 edi
  0a8a5	5e		 pop	 esi
  0a8a6	5b		 pop	 ebx
  0a8a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a8aa	33 cd		 xor	 ecx, ebp
  0a8ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a8b1	8b e5		 mov	 esp, ebp
  0a8b3	5d		 pop	 ebp
  0a8b4	c3		 ret	 0
?DGUpdateExtendedInvenCountResult@@YAXPAUSDHP_ANS_SET_EXTENDEDINVEN_COUNT@@@Z ENDP ; DGUpdateExtendedInvenCountResult
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDUpdateExtendedWarehouseCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z ; GDUpdateExtendedWarehouseCount
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_btExtendedWarehouseCount$ = 12				; size = 1
_dwEventIndex$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
_bBuyAtInGameShop$ = 24					; size = 1
_bIsReplace$ = 28					; size = 1
?GDUpdateExtendedWarehouseCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z PROC ; GDUpdateExtendedWarehouseCount

; 6532 : {

  0a8c0	55		 push	 ebp
  0a8c1	8b ec		 mov	 ebp, esp
  0a8c3	83 ec 64	 sub	 esp, 100		; 00000064H
  0a8c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a8cb	33 c5		 xor	 eax, ebp
  0a8cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a8d0	53		 push	 ebx
  0a8d1	56		 push	 esi
  0a8d2	57		 push	 edi

; 6533 : #ifdef DEBUG_CODE
; 6534 : 
; 6535 : 	LogAddC(1,"ExpandedInventory: %d, ExpandedWarehouse: %d",lpObj->ExpandedInventory,lpObj->ExpandedWarehouse);
; 6536 : 
; 6537 : #endif
; 6538 : 	SDHP_REQ_SET_EXTENDEDWAREHOUSE_COUNT pMsg;
; 6539 : 	pMsg.h.set((LPBYTE)&pMsg, 0xD6, sizeof(pMsg));

  0a8d3	6a 20		 push	 32			; 00000020H
  0a8d5	68 d6 00 00 00	 push	 214			; 000000d6H
  0a8da	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a8dd	50		 push	 eax
  0a8de	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0a8e1	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 6540 : 	// ----
; 6541 : 	memcpy(pMsg.AccountId, lpObj->AccountID, 11);

  0a8e6	6a 0b		 push	 11			; 0000000bH
  0a8e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a8eb	83 c0 6c	 add	 eax, 108		; 0000006cH
  0a8ee	50		 push	 eax
  0a8ef	8d 4d df	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  0a8f2	51		 push	 ecx
  0a8f3	e8 00 00 00 00	 call	 _memcpy
  0a8f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6542 : 	pMsg.Number				= lpObj->m_Index;

  0a8fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a8fe	66 8b 08	 mov	 cx, WORD PTR [eax]
  0a901	66 89 4d ea	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 6543 : 	pMsg.ExtendedWarehouseCount = btExtendedWarehouseCount;

  0a905	8a 45 0c	 mov	 al, BYTE PTR _btExtendedWarehouseCount$[ebp]
  0a908	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+16], al

; 6544 : 	pMsg.EventIndex			= dwEventIndex;

  0a90b	8b 45 10	 mov	 eax, DWORD PTR _dwEventIndex$[ebp]
  0a90e	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 6545 : 	pMsg.ItemPos			= iItemPos;

  0a911	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0a914	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 6546 : 	pMsg.BuyAtInGameShop	= bBuyAtInGameShop;

  0a917	8a 45 18	 mov	 al, BYTE PTR _bBuyAtInGameShop$[ebp]
  0a91a	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+28], al

; 6547 : 	pMsg.IsReplace			= bIsReplace;

  0a91d	8a 45 1c	 mov	 al, BYTE PTR _bIsReplace$[ebp]
  0a920	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+29], al

; 6548 : 	// ----
; 6549 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  0a923	6a 20		 push	 32			; 00000020H
  0a925	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0a928	50		 push	 eax
  0a929	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0a92e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6550 : }

  0a933	5f		 pop	 edi
  0a934	5e		 pop	 esi
  0a935	5b		 pop	 ebx
  0a936	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a939	33 cd		 xor	 ecx, ebp
  0a93b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a940	8b e5		 mov	 esp, ebp
  0a942	5d		 pop	 ebp
  0a943	c3		 ret	 0
?GDUpdateExtendedWarehouseCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z ENDP ; GDUpdateExtendedWarehouseCount
_TEXT	ENDS
PUBLIC	??_C@_0EL@NLENBEMH@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Er@ ; `string'
PUBLIC	??_C@_0EF@OLJKBJLP@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Fa@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0EL@NLENBEMH@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Er@
CONST	SEGMENT
??_C@_0EL@NLENBEMH@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Er@ DB '[E'
	DB	'xtended Storage][WareHouse] Error Item Pos. User Name : %s. I'
	DB	'temPos : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@OLJKBJLP@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Fa@
CONST	SEGMENT
??_C@_0EF@OLJKBJLP@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Fa@ DB '[E'
	DB	'xtended Storage][WareHouse] Fail to extend warehouse. User ID'
	DB	' : %s', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szTemp$ = -268						; size = 256
_lpObj$ = -12						; size = 4
_aIndex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGUpdateExtendedWarehouseResult@@YAXPAUSDHP_ANS_SET_EXTENDEDWAREHOUSE_COUNT@@@Z PROC ; DGUpdateExtendedWarehouseResult

; 6555 : {

  0a950	55		 push	 ebp
  0a951	8b ec		 mov	 ebp, esp
  0a953	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  0a959	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a95e	33 c5		 xor	 eax, ebp
  0a960	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a963	53		 push	 ebx
  0a964	56		 push	 esi
  0a965	57		 push	 edi

; 6556 : 	int aIndex = lpMsg->Number;

  0a966	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a969	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0a96d	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 6557 : 	// ----
; 6558 : 	if( !gObjIsConnected(aIndex) )

  0a970	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a973	50		 push	 eax
  0a974	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0a979	83 c4 04	 add	 esp, 4
  0a97c	85 c0		 test	 eax, eax
  0a97e	75 05		 jne	 SHORT $LN4@DGUpdateEx@2

; 6559 : 	{
; 6560 : 		return;

  0a980	e9 58 01 00 00	 jmp	 $LN5@DGUpdateEx@2
$LN4@DGUpdateEx@2:

; 6561 : 	}
; 6562 : 	// ----
; 6563 : 	LPOBJ lpObj = &gObj[aIndex];

  0a985	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a988	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a98e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a994	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6564 : 	// ----
; 6565 : 	if( !lpMsg->Result )

  0a997	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a99a	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0a99e	85 c9		 test	 ecx, ecx
  0a9a0	75 46		 jne	 SHORT $LN3@DGUpdateEx@2

; 6566 : 	{
; 6567 : 		//if( lpMsg->BuyAtInGameShop == 1 )
; 6568 : 		//		CCashShopInGame::RollBackUseItem(v8, lpMsg->EventIndex);
; 6569 : 		//	else
; 6570 : 		//		GCInventoryItemDeleteSend(v9, 0xFFu, 1u);
; 6571 : 			GCResultForExtendInvenOrWarehouse(aIndex, 0);

  0a9a2	6a 00		 push	 0
  0a9a4	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a9a7	50		 push	 eax
  0a9a8	e8 00 00 00 00	 call	 ?GCResultForExtendInvenOrWarehouse@@YAXHE@Z ; GCResultForExtendInvenOrWarehouse
  0a9ad	83 c4 08	 add	 esp, 8

; 6572 : 			LogAddTD("[Extended Storage][WareHouse] Fail to extend warehouse. User ID : %s", lpObj->AccountID);

  0a9b0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a9b3	83 c0 6c	 add	 eax, 108		; 0000006cH
  0a9b6	50		 push	 eax
  0a9b7	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@OLJKBJLP@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Fa@
  0a9bc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a9c2	83 c4 08	 add	 esp, 8

; 6573 : 			GCServerMsgStringSend(lMsg.Get(3483), aIndex, 1);

  0a9c5	6a 01		 push	 1
  0a9c7	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0a9ca	50		 push	 eax
  0a9cb	68 9b 0d 00 00	 push	 3483			; 00000d9bH
  0a9d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0a9d5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0a9da	50		 push	 eax
  0a9db	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0a9e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6574 : 			return;

  0a9e3	e9 f5 00 00 00	 jmp	 $LN5@DGUpdateEx@2
$LN3@DGUpdateEx@2:

; 6575 : 	}
; 6576 : 	// ----
; 6577 : 	lpObj->ExpandedWarehouse = lpMsg->ExtendedWarehouseCount;

  0a9e8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0a9eb	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0a9ee	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  0a9f1	88 90 25 26 00
	00		 mov	 BYTE PTR [eax+9765], dl

; 6578 : 	// ----
; 6579 : 	//if( lpMsg->BuyAtInGameShop == 1 )
; 6580 : 	//{
; 6581 : 	//	CCashShopInGame::SetActiveItemResult(v8, lpMsg->EventIndex);
; 6582 : 	//}
; 6583 : 	//else
; 6584 : 	//{
; 6585 : 	if( lpMsg->ItemPos > 203 || lpMsg->ItemPos < 0 )

  0a9f7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0a9fa	81 78 0c cb 00
	00 00		 cmp	 DWORD PTR [eax+12], 203	; 000000cbH
  0aa01	7f 09		 jg	 SHORT $LN1@DGUpdateEx@2
  0aa03	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0aa06	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0aa0a	7d 21		 jge	 SHORT $LN2@DGUpdateEx@2
$LN1@DGUpdateEx@2:

; 6586 : 	{
; 6587 : 		LogAddTD("[Extended Storage][WareHouse] Error Item Pos. User Name : %s. ItemPos : %d", lpObj->Name, lpMsg->ItemPos);

  0aa0c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0aa0f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0aa12	51		 push	 ecx
  0aa13	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0aa16	83 c2 77	 add	 edx, 119		; 00000077H
  0aa19	52		 push	 edx
  0aa1a	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NLENBEMH@?$FLExtended?5Storage?$FN?$FLWareHouse?$FN?5Er@
  0aa1f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0aa25	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6588 : 		return;

  0aa28	e9 b0 00 00 00	 jmp	 $LN5@DGUpdateEx@2
$LN2@DGUpdateEx@2:

; 6589 : 	}
; 6590 : 	// ----
; 6591 : 	gObjInventoryItemSet(aIndex, lpMsg->ItemPos, 0xFF);

  0aa2d	68 ff 00 00 00	 push	 255			; 000000ffH
  0aa32	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0aa35	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0aa38	51		 push	 ecx
  0aa39	8b 55 f8	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0aa3c	52		 push	 edx
  0aa3d	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0aa42	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6592 : 	lpObj->pInventory[lpMsg->ItemPos].Clear();

  0aa45	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0aa48	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0aa4b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0aa51	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0aa54	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  0aa5a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 6593 : 	GCInventoryItemDeleteSend(aIndex, lpMsg->ItemPos, 1);

  0aa5f	6a 01		 push	 1
  0aa61	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0aa64	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0aa68	51		 push	 ecx
  0aa69	8b 55 f8	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0aa6c	52		 push	 edx
  0aa6d	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0aa72	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 : 	GCResultForExtendInvenOrWarehouse(aIndex, 1);

  0aa75	6a 01		 push	 1
  0aa77	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0aa7a	50		 push	 eax
  0aa7b	e8 00 00 00 00	 call	 ?GCResultForExtendInvenOrWarehouse@@YAXHE@Z ; GCResultForExtendInvenOrWarehouse
  0aa80	83 c4 08	 add	 esp, 8

; 6595 : 	// ----
; 6596 : 	char szTemp[0x100] = { 0 };

  0aa83	c6 85 f4 fe ff
	ff 00		 mov	 BYTE PTR _szTemp$[ebp], 0
  0aa8a	68 ff 00 00 00	 push	 255			; 000000ffH
  0aa8f	6a 00		 push	 0
  0aa91	8d 85 f5 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp+1]
  0aa97	50		 push	 eax
  0aa98	e8 00 00 00 00	 call	 _memset
  0aa9d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6597 : 	wsprintfA(szTemp, lMsg.Get(3482), lpMsg->ExtendedWarehouseCount);	//maybe 0, 0 in param +

  0aaa0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0aaa3	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0aaa7	51		 push	 ecx
  0aaa8	68 9a 0d 00 00	 push	 3482			; 00000d9aH
  0aaad	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0aab2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0aab7	50		 push	 eax
  0aab8	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0aabe	52		 push	 edx
  0aabf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0aac5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6598 : 	GCServerMsgStringSend(szTemp, aIndex, 1);	

  0aac8	6a 01		 push	 1
  0aaca	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0aacd	50		 push	 eax
  0aace	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0aad4	51		 push	 ecx
  0aad5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0aada	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@DGUpdateEx@2:

; 6599 : }

  0aadd	5f		 pop	 edi
  0aade	5e		 pop	 esi
  0aadf	5b		 pop	 ebx
  0aae0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0aae3	33 cd		 xor	 ecx, ebp
  0aae5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0aaea	8b e5		 mov	 esp, ebp
  0aaec	5d		 pop	 ebp
  0aaed	c3		 ret	 0
?DGUpdateExtendedWarehouseResult@@YAXPAUSDHP_ANS_SET_EXTENDEDWAREHOUSE_COUNT@@@Z ENDP ; DGUpdateExtendedWarehouseResult
_TEXT	ENDS
PUBLIC	??_C@_0BG@GOHFOHON@?$FLWarehouse?$FN?$FL?$CFs?$FN?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BF@NNJPEGMD@GDGetWarehouseNumber?$AA@	; `string'
EXTRN	?WarehouseNumberSend@@YAXH@Z:PROC		; WarehouseNumberSend
;	COMDAT ??_C@_0BG@GOHFOHON@?$FLWarehouse?$FN?$FL?$CFs?$FN?5Error?$AA@
CONST	SEGMENT
??_C@_0BG@GOHFOHON@?$FLWarehouse?$FN?$FL?$CFs?$FN?5Error?$AA@ DB '[Wareho'
	DB	'use][%s] Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NNJPEGMD@GDGetWarehouseNumber?$AA@
CONST	SEGMENT
??_C@_0BF@NNJPEGMD@GDGetWarehouseNumber?$AA@ DB 'GDGetWarehouseNumber', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpUser$ = -4						; size = 4
_aRecv$ = 8						; size = 4
?GDGetWarehouseNumber@@YAXPAULOADWAREHOUSENUMBER_SAVE@@@Z PROC ; GDGetWarehouseNumber

; 6604 : {

  0aaf0	55		 push	 ebp
  0aaf1	8b ec		 mov	 ebp, esp
  0aaf3	83 ec 44	 sub	 esp, 68			; 00000044H
  0aaf6	53		 push	 ebx
  0aaf7	56		 push	 esi
  0aaf8	57		 push	 edi

; 6605 : 	if (!gObjIsConnected(aRecv->aIndex))

  0aaf9	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0aafc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0aaff	51		 push	 ecx
  0ab00	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0ab05	83 c4 04	 add	 esp, 4
  0ab08	85 c0		 test	 eax, eax
  0ab0a	75 17		 jne	 SHORT $LN1@GDGetWareh@3

; 6606 : 	{
; 6607 : 		LogAddC(2, "[Warehouse][%s] Error", __FUNCTION__);

  0ab0c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NNJPEGMD@GDGetWarehouseNumber?$AA@
  0ab11	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GOHFOHON@?$FLWarehouse?$FN?$FL?$CFs?$FN?5Error?$AA@
  0ab16	6a 02		 push	 2
  0ab18	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0ab1e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6608 : 		return;

  0ab21	eb 32		 jmp	 SHORT $LN2@GDGetWareh@3
$LN1@GDGetWareh@3:

; 6609 : 	}
; 6610 : 
; 6611 : 	// ----
; 6612 : 	LPOBJ lpUser = &gObj[aRecv->aIndex];

  0ab23	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0ab26	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0ab29	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0ab2f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ab35	89 4d fc	 mov	 DWORD PTR _lpUser$[ebp], ecx

; 6613 : 	// ----
; 6614 : 	lpUser->WarehouseNumber = aRecv->Number;

  0ab38	8b 45 fc	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0ab3b	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0ab3e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0ab41	89 90 e8 2a 00
	00		 mov	 DWORD PTR [eax+10984], edx

; 6615 : 	WarehouseNumberSend(lpUser->m_Index);

  0ab47	8b 45 fc	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0ab4a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0ab4c	51		 push	 ecx
  0ab4d	e8 00 00 00 00	 call	 ?WarehouseNumberSend@@YAXH@Z ; WarehouseNumberSend
  0ab52	83 c4 04	 add	 esp, 4
$LN2@GDGetWareh@3:

; 6616 : }

  0ab55	5f		 pop	 edi
  0ab56	5e		 pop	 esi
  0ab57	5b		 pop	 ebx
  0ab58	8b e5		 mov	 esp, ebp
  0ab5a	5d		 pop	 ebp
  0ab5b	c3		 ret	 0
?GDGetWarehouseNumber@@YAXPAULOADWAREHOUSENUMBER_SAVE@@@Z ENDP ; GDGetWarehouseNumber
_TEXT	ENDS
END
