; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\TMonsterAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7TMonsterAI@@6B@				; TMonsterAI::`vftable'
PUBLIC	??0TMonsterAI@@QAE@XZ				; TMonsterAI::TMonsterAI
PUBLIC	??_R4TMonsterAI@@6B@				; TMonsterAI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAI@@@8				; TMonsterAI `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAI@@8				; TMonsterAI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAI@@8				; TMonsterAI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAI@@8			; TMonsterAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAI@@UAEPAXI@Z:PROC			; TMonsterAI::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAI@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsterai.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAI@@8 DD FLAT:??_R0?AVTMonsterAI@@@8 ; TMonsterAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAI@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAI@@8
rdata$r	SEGMENT
??_R2TMonsterAI@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAI@@8	; TMonsterAI::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAI@@8
rdata$r	SEGMENT
??_R3TMonsterAI@@8 DD 00H				; TMonsterAI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAI@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAI@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAI `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAI@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAI@@6B@
rdata$r	SEGMENT
??_R4TMonsterAI@@6B@ DD 00H				; TMonsterAI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAI@@@8
	DD	FLAT:??_R3TMonsterAI@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAI@@6B@
CONST	SEGMENT
??_7TMonsterAI@@6B@ DD FLAT:??_R4TMonsterAI@@6B@	; TMonsterAI::`vftable'
	DD	FLAT:??_ETMonsterAI@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAI@@QAE@XZ PROC				; TMonsterAI::TMonsterAI
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAI@@6B@

; 25   : 
; 26   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0TMonsterAI@@QAE@XZ ENDP				; TMonsterAI::TMonsterAI
_TEXT	ENDS
PUBLIC	??1TMonsterAI@@UAE@XZ				; TMonsterAI::~TMonsterAI
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GTMonsterAI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTMonsterAI@@UAEPAXI@Z PROC				; TMonsterAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1TMonsterAI@@UAE@XZ	; TMonsterAI::~TMonsterAI
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GTMonsterAI@@UAEPAXI@Z ENDP				; TMonsterAI::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TMonsterAI@@UAE@XZ PROC				; TMonsterAI::~TMonsterAI
; _this$ = ecx

; 29   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAI@@6B@

; 30   : 
; 31   : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1TMonsterAI@@UAE@XZ ENDP				; TMonsterAI::~TMonsterAI
_TEXT	ENDS
PUBLIC	?RunAI@TMonsterAI@@SAHHH@Z			; TMonsterAI::RunAI
PUBLIC	?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z		; TMonsterAI::UpdateCurrentAIUnit
PUBLIC	?MonsterStateMsgProc@TMonsterAI@@SAXH@Z		; TMonsterAI::MonsterStateMsgProc
PUBLIC	?MonsterAIProc@TMonsterAI@@SAXXZ		; TMonsterAI::MonsterAIProc
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ:PROC	; TMonsterAIRule::MonsterAIRuleProc
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpObj$220107 = -8					; size = 4
_n$220103 = -4						; size = 4
?MonsterAIProc@TMonsterAI@@SAXXZ PROC			; TMonsterAI::MonsterAIProc

; 35   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 48	 sub	 esp, 72			; 00000048H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi

; 36   : 	TMonsterAIRule::MonsterAIRuleProc();

  00049	e8 00 00 00 00	 call	 ?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ ; TMonsterAIRule::MonsterAIRuleProc

; 37   : 
; 38   : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$220103[ebp], 0
  00055	eb 09		 jmp	 SHORT $LN7@MonsterAIP
$LN6@MonsterAIP:
  00057	8b 45 fc	 mov	 eax, DWORD PTR _n$220103[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 fc	 mov	 DWORD PTR _n$220103[ebp], eax
$LN7@MonsterAIP:
  00060	81 7d fc c8 32
	00 00		 cmp	 DWORD PTR _n$220103[ebp], 13000 ; 000032c8H
  00067	7d 7c		 jge	 SHORT $LN8@MonsterAIP

; 39   : 	{
; 40   : 		LPOBJ lpObj = &gObj[n];

  00069	8b 45 fc	 mov	 eax, DWORD PTR _n$220103[ebp]
  0006c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00072	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00078	89 45 f8	 mov	 DWORD PTR _lpObj$220107[ebp], eax

; 41   : 
; 42   : 		if ( lpObj->m_iCurrentAI == 0 || lpObj->Live == FALSE ||lpObj->Connected != PLAYER_PLAYING )

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  0007e	83 b8 78 1c 00
	00 00		 cmp	 DWORD PTR [eax+7288], 0
  00085	74 14		 je	 SHORT $LN3@MonsterAIP
  00087	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  0008a	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0008e	85 c9		 test	 ecx, ecx
  00090	74 09		 je	 SHORT $LN3@MonsterAIP
  00092	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  00095	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00099	74 1e		 je	 SHORT $LN4@MonsterAIP
$LN3@MonsterAIP:

; 43   : 		{
; 44   : 			if ( lpObj->m_iCurrentAI != 0 )

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  0009e	83 b8 78 1c 00
	00 00		 cmp	 DWORD PTR [eax+7288], 0
  000a5	74 0e		 je	 SHORT $LN2@MonsterAIP

; 45   : 			{
; 46   : 				TMonsterAI::MonsterStateMsgProc(lpObj->m_Index);

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 ?MonsterStateMsgProc@TMonsterAI@@SAXH@Z ; TMonsterAI::MonsterStateMsgProc
  000b2	83 c4 04	 add	 esp, 4
$LN2@MonsterAIP:

; 47   : 			}
; 48   : 			continue;

  000b5	eb a0		 jmp	 SHORT $LN6@MonsterAIP

; 49   : 		}
; 50   : 		else

  000b7	eb 27		 jmp	 SHORT $LN1@MonsterAIP
$LN4@MonsterAIP:

; 51   : 		{
; 52   : 			TMonsterAI::UpdateCurrentAIUnit(lpObj->m_Index);

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z ; TMonsterAI::UpdateCurrentAIUnit
  000c4	83 c4 04	 add	 esp, 4

; 53   : 			TMonsterAI::RunAI(lpObj->m_Index, lpObj->Class);

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$220107[ebp]
  000ca	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  000d1	51		 push	 ecx
  000d2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$220107[ebp]
  000d5	8b 02		 mov	 eax, DWORD PTR [edx]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?RunAI@TMonsterAI@@SAHHH@Z ; TMonsterAI::RunAI
  000dd	83 c4 08	 add	 esp, 8
$LN1@MonsterAIP:

; 54   : 		}
; 55   : 	}

  000e0	e9 72 ff ff ff	 jmp	 $LN6@MonsterAIP
$LN8@MonsterAIP:

; 56   : }

  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
?MonsterAIProc@TMonsterAI@@SAXXZ ENDP			; TMonsterAI::MonsterAIProc
_TEXT	ENDS
EXTRN	?RunAIUnit@TMonsterAIUnit@@QAEHH@Z:PROC		; TMonsterAIUnit::RunAIUnit
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z:PROC	; TMonsterAIUnit::FindAIUnit
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpAIUnit$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iMonsterClass$ = 12					; size = 4
?RunAI@TMonsterAI@@SAHHH@Z PROC				; TMonsterAI::RunAI

; 61   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	83 ec 48	 sub	 esp, 72			; 00000048H
  000f6	53		 push	 ebx
  000f7	56		 push	 esi
  000f8	57		 push	 edi

; 62   : 	LPOBJ lpObj = &gObj[iIndex];

  000f9	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000fc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00102	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00108	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 63   : 
; 64   : 	TMonsterAI::MonsterStateMsgProc(iIndex);

  0010b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?MonsterStateMsgProc@TMonsterAI@@SAXH@Z ; TMonsterAI::MonsterStateMsgProc
  00114	83 c4 04	 add	 esp, 4

; 65   : 
; 66   : 	if ( lpObj->m_iCurrentAI == 0 )

  00117	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011a	83 b8 78 1c 00
	00 00		 cmp	 DWORD PTR [eax+7288], 0
  00121	75 04		 jne	 SHORT $LN4@RunAI

; 67   : 		return FALSE;

  00123	33 c0		 xor	 eax, eax
  00125	eb 62		 jmp	 SHORT $LN5@RunAI
$LN4@RunAI:

; 68   : 
; 69   : 	TMonsterAIUnit * lpAIUnit = TMonsterAIUnit::FindAIUnit(lpObj->m_iCurrentAI);

  00127	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012a	8b 88 78 1c 00
	00		 mov	 ecx, DWORD PTR [eax+7288]
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 ?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ; TMonsterAIUnit::FindAIUnit
  00136	83 c4 04	 add	 esp, 4
  00139	89 45 f8	 mov	 DWORD PTR _lpAIUnit$[ebp], eax

; 70   : 
; 71   : 	if ( lpAIUnit == NULL )

  0013c	83 7d f8 00	 cmp	 DWORD PTR _lpAIUnit$[ebp], 0
  00140	75 04		 jne	 SHORT $LN3@RunAI

; 72   : 		return FALSE;

  00142	33 c0		 xor	 eax, eax
  00144	eb 43		 jmp	 SHORT $LN5@RunAI
$LN3@RunAI:

; 73   : 
; 74   : 	if ( (GetTickCount() - lpObj->m_iLastAIRunTime) < lpAIUnit->m_iDelayTime )

  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0014f	2b 81 80 1c 00
	00		 sub	 eax, DWORD PTR [ecx+7296]
  00155	8b 55 f8	 mov	 edx, DWORD PTR _lpAIUnit$[ebp]
  00158	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  0015b	73 04		 jae	 SHORT $LN2@RunAI

; 75   : 		return FALSE;

  0015d	33 c0		 xor	 eax, eax
  0015f	eb 28		 jmp	 SHORT $LN5@RunAI
$LN2@RunAI:

; 76   : 
; 77   : 	if ( lpAIUnit->RunAIUnit(iIndex) == FALSE )

  00161	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00164	50		 push	 eax
  00165	8b 4d f8	 mov	 ecx, DWORD PTR _lpAIUnit$[ebp]
  00168	e8 00 00 00 00	 call	 ?RunAIUnit@TMonsterAIUnit@@QAEHH@Z ; TMonsterAIUnit::RunAIUnit
  0016d	85 c0		 test	 eax, eax
  0016f	75 04		 jne	 SHORT $LN1@RunAI

; 78   : 		return FALSE;

  00171	33 c0		 xor	 eax, eax
  00173	eb 14		 jmp	 SHORT $LN5@RunAI
$LN1@RunAI:

; 79   : 
; 80   : 	lpObj->m_iLastAIRunTime = GetTickCount();

  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0017e	89 81 80 1c 00
	00		 mov	 DWORD PTR [ecx+7296], eax

; 81   : 
; 82   : 	return TRUE;

  00184	b8 01 00 00 00	 mov	 eax, 1
$LN5@RunAI:

; 83   : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
?RunAI@TMonsterAI@@SAHHH@Z ENDP				; TMonsterAI::RunAI
_TEXT	ENDS
PUBLIC	?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z ; TMonsterAI::ProcessStateMsg
EXTRN	?gSMMsg@@3PAY0DC@UMessageStateMachine@@A:BYTE	; gSMMsg
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220126 = -8						; size = 4
_lpObj$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?MonsterStateMsgProc@TMonsterAI@@SAXH@Z PROC		; TMonsterAI::MonsterStateMsgProc

; 88   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 48	 sub	 esp, 72			; 00000048H
  00196	53		 push	 ebx
  00197	56		 push	 esi
  00198	57		 push	 edi

; 89   : 	LPOBJ lpObj = &gObj[iIndex];

  00199	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0019c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001a2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a8	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 90   : 
; 91   : 	for ( int i=0;i<MAX_MONSTER_SEND_MSG;i++)

  001ab	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220126[ebp], 0
  001b2	eb 09		 jmp	 SHORT $LN5@MonsterSta
$LN4@MonsterSta:
  001b4	8b 45 f8	 mov	 eax, DWORD PTR _i$220126[ebp]
  001b7	83 c0 01	 add	 eax, 1
  001ba	89 45 f8	 mov	 DWORD PTR _i$220126[ebp], eax
$LN5@MonsterSta:
  001bd	83 7d f8 32	 cmp	 DWORD PTR _i$220126[ebp], 50 ; 00000032H
  001c1	0f 8d ab 00 00
	00		 jge	 $LN6@MonsterSta

; 92   : 	{
; 93   : 		if ( gSMMsg[iIndex][i].MsgCode >= 0 )

  001c7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001ca	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _i$220126[ebp]
  001d3	c1 e1 04	 shl	 ecx, 4
  001d6	83 bc 08 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A[eax+ecx], 0
  001de	0f 8c 89 00 00
	00		 jl	 $LN2@MonsterSta

; 94   : 		{
; 95   : 			if ( GetTickCount() > gSMMsg[iIndex][i].MsgTime )

  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001ea	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  001ed	69 c9 20 03 00
	00		 imul	 ecx, 800		; 00000320H
  001f3	8b 55 f8	 mov	 edx, DWORD PTR _i$220126[ebp]
  001f6	c1 e2 04	 shl	 edx, 4
  001f9	3b 84 11 08 00
	00 00		 cmp	 eax, DWORD PTR ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A[ecx+edx+8]
  00200	76 6b		 jbe	 SHORT $LN2@MonsterSta

; 96   : 			{
; 97   : 				TMonsterAI::ProcessStateMsg(lpObj, gSMMsg[iIndex][i].MsgCode, gSMMsg[iIndex][i].SendUser, gSMMsg[iIndex][i].SubCode);

  00202	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00205	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  0020b	8b 4d f8	 mov	 ecx, DWORD PTR _i$220126[ebp]
  0020e	c1 e1 04	 shl	 ecx, 4
  00211	8b 94 08 0c 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A[eax+ecx+12]
  00218	52		 push	 edx
  00219	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0021c	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  00222	8b 4d f8	 mov	 ecx, DWORD PTR _i$220126[ebp]
  00225	c1 e1 04	 shl	 ecx, 4
  00228	8b 94 08 04 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A[eax+ecx+4]
  0022f	52		 push	 edx
  00230	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00233	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  00239	8b 4d f8	 mov	 ecx, DWORD PTR _i$220126[ebp]
  0023c	c1 e1 04	 shl	 ecx, 4
  0023f	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A[eax+ecx]
  00246	52		 push	 edx
  00247	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 ?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z ; TMonsterAI::ProcessStateMsg
  00250	83 c4 10	 add	 esp, 16			; 00000010H

; 98   : 				gSMMsg[iIndex][i].MsgCode = -1;

  00253	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00256	69 c0 20 03 00
	00		 imul	 eax, 800		; 00000320H
  0025c	8b 4d f8	 mov	 ecx, DWORD PTR _i$220126[ebp]
  0025f	c1 e1 04	 shl	 ecx, 4
  00262	c7 84 08 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A[eax+ecx], -1
$LN2@MonsterSta:

; 99   : 			}
; 100  : 		}
; 101  : 	}

  0026d	e9 42 ff ff ff	 jmp	 $LN4@MonsterSta
$LN6@MonsterSta:

; 102  : }

  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	8b e5		 mov	 esp, ebp
  00277	5d		 pop	 ebp
  00278	c3		 ret	 0
?MonsterStateMsgProc@TMonsterAI@@SAXH@Z ENDP		; TMonsterAI::MonsterStateMsgProc
_TEXT	ENDS
EXTRN	?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z:PROC	; gObjBackSpring2
EXTRN	?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjApplyBuffEffectDuration
EXTRN	?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; retResistance
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?DelAgro@TMonsterAIAgro@@QAEHH@Z:PROC		; TMonsterAIAgro::DelAgro
EXTRN	?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjBackSpring
EXTRN	?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z:PROC ; gObjMonsterDieGiveItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv64 = -76						; size = 4
_lpTargetObj$220154 = -8				; size = 4
_lpTargetObj$220150 = -4				; size = 4
_lpObj$ = 8						; size = 4
_iMsgCode$ = 12						; size = 4
_iIndex$ = 16						; size = 4
_aMsgSubCode$ = 20					; size = 4
?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z PROC ; TMonsterAI::ProcessStateMsg

; 108  : {

  00280	55		 push	 ebp
  00281	8b ec		 mov	 ebp, esp
  00283	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00286	53		 push	 ebx
  00287	56		 push	 esi
  00288	57		 push	 edi

; 109  : 	switch ( iMsgCode )

  00289	8b 45 0c	 mov	 eax, DWORD PTR _iMsgCode$[ebp]
  0028c	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0028f	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  00292	83 e9 01	 sub	 ecx, 1
  00295	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  00298	83 7d b4 38	 cmp	 DWORD PTR tv64[ebp], 56	; 00000038H
  0029c	0f 87 f5 01 00
	00		 ja	 $LN14@ProcessSta
  002a2	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  002a5	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN16@ProcessSta[edx]
  002ac	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN17@ProcessSta[eax*4]
$LN11@ProcessSta:

; 110  : 	{
; 111  : 		case 1:
; 112  : 			gObjMonsterDieGiveItem(lpObj, &gObj[iIndex]);

  002b3	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002b6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002bc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c2	50		 push	 eax
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 ?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterDieGiveItem
  002cc	83 c4 08	 add	 esp, 8

; 113  : 			break;

  002cf	e9 c3 01 00 00	 jmp	 $LN14@ProcessSta
$LN10@ProcessSta:

; 114  : 
; 115  : 		case 2:
; 116  : 			if ( gObj[iIndex].Live != FALSE )

  002d4	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002d7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e3	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  002e8	85 d2		 test	 edx, edx
  002ea	74 1c		 je	 SHORT $LN9@ProcessSta

; 117  : 			{
; 118  : 				gObjBackSpring(lpObj, &gObj[iIndex]);

  002ec	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002ef	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002f5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fb	50		 push	 eax
  002fc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ff	51		 push	 ecx
  00300	e8 00 00 00 00	 call	 ?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjBackSpring
  00305	83 c4 08	 add	 esp, 8
$LN9@ProcessSta:

; 119  : 			}
; 120  : 			break;

  00308	e9 8a 01 00 00	 jmp	 $LN14@ProcessSta
$LN8@ProcessSta:

; 121  : 
; 122  : 		case 3:
; 123  : 			if ( lpObj->TargetNumber != -1 )

  0030d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00310	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  00317	83 f9 ff	 cmp	 ecx, -1
  0031a	74 19		 je	 SHORT $LN7@ProcessSta

; 124  : 			{
; 125  : 				lpObj->m_Agro.DelAgro(lpObj->TargetNumber);

  0031c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031f	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  00326	51		 push	 ecx
  00327	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0032a	81 c1 94 1c 00
	00		 add	 ecx, 7316		; 00001c94H
  00330	e8 00 00 00 00	 call	 ?DelAgro@TMonsterAIAgro@@QAEHH@Z ; TMonsterAIAgro::DelAgro
$LN7@ProcessSta:

; 126  : 			}
; 127  : 
; 128  : 			lpObj->TargetNumber = -1;

  00335	83 c8 ff	 or	 eax, -1
  00338	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0033b	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 129  : 			lpObj->LastAttackerID = -1;

  00342	83 c8 ff	 or	 eax, -1
  00345	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00348	66 89 81 5e 04
	00 00		 mov	 WORD PTR [ecx+1118], ax

; 130  : 			lpObj->m_ActState.Emotion = 0;

  0034f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00352	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  00358	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0035e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00361	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 131  : 			lpObj->m_ActState.Attack = 0;

  00367	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036a	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  00370	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00373	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00376	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 132  : 			lpObj->m_ActState.Move = 0;

  0037c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037f	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  00385	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00388	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0038b	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 133  : 			lpObj->NextActionTime = 1000;

  00391	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00394	c7 80 bc 03 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+956], 1000 ; 000003e8H

; 134  : 			break;

  0039e	e9 f4 00 00 00	 jmp	 $LN14@ProcessSta
$LN6@ProcessSta:

; 135  : 
; 136  : 		case 4:
; 137  : 			lpObj->m_ActState.Emotion = 3;

  003a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a6	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  003ac	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  003b2	83 c9 30	 or	 ecx, 48			; 00000030H
  003b5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003b8	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 138  : 			lpObj->m_ActState.EmotionCount = 1;

  003be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c1	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  003c7	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  003cd	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  003d3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003d6	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 139  : 			break;

  003dc	e9 b6 00 00 00	 jmp	 $LN14@ProcessSta
$LN5@ProcessSta:

; 140  : 
; 141  : 		case 55:
; 142  : 			gObjAttack(lpObj, &gObj[iIndex], NULL, FALSE, FALSE, 0, FALSE,0,0);

  003e1	6a 00		 push	 0
  003e3	6a 00		 push	 0
  003e5	6a 00		 push	 0
  003e7	6a 00		 push	 0
  003e9	6a 00		 push	 0
  003eb	6a 00		 push	 0
  003ed	6a 00		 push	 0
  003ef	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  003f2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003f8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003fe	50		 push	 eax
  003ff	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00402	51		 push	 ecx
  00403	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00408	83 c4 24	 add	 esp, 36			; 00000024H

; 143  : 			break;

  0040b	e9 87 00 00 00	 jmp	 $LN14@ProcessSta
$LN4@ProcessSta:

; 144  : 
; 145  : 		case 56:
; 146  : 			{
; 147  : 				LPOBJ lpTargetObj = &gObj[iIndex];

  00410	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00413	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00419	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0041f	89 45 fc	 mov	 DWORD PTR _lpTargetObj$220150[ebp], eax

; 148  : 				
; 149  : 				if(gObjSearchActiveEffect(lpTargetObj, AT_POISON) == 0)

  00422	6a 37		 push	 55			; 00000037H
  00424	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$220150[ebp]
  00427	50		 push	 eax
  00428	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0042d	83 c4 08	 add	 esp, 8
  00430	0f b6 c8	 movzx	 ecx, al
  00433	85 c9		 test	 ecx, ecx
  00435	75 38		 jne	 SHORT $LN3@ProcessSta

; 150  : 				{
; 151  : 					if ( retResistance(lpTargetObj, 1) == FALSE )

  00437	6a 01		 push	 1
  00439	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$220150[ebp]
  0043c	50		 push	 eax
  0043d	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  00442	83 c4 08	 add	 esp, 8
  00445	85 c0		 test	 eax, eax
  00447	75 26		 jne	 SHORT $LN3@ProcessSta

; 152  : 					{
; 153  : 						lpTargetObj->lpAttackObj = lpObj;

  00449	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$220150[ebp]
  0044c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0044f	89 88 d4 03 00
	00		 mov	 DWORD PTR [eax+980], ecx

; 154  : 						gObjApplyBuffEffectDuration(lpTargetObj, AT_POISON, 19, 3, 0, 0, aMsgSubCode);

  00455	8b 45 14	 mov	 eax, DWORD PTR _aMsgSubCode$[ebp]
  00458	50		 push	 eax
  00459	6a 00		 push	 0
  0045b	6a 00		 push	 0
  0045d	6a 03		 push	 3
  0045f	6a 13		 push	 19			; 00000013H
  00461	6a 37		 push	 55			; 00000037H
  00463	8b 4d fc	 mov	 ecx, DWORD PTR _lpTargetObj$220150[ebp]
  00466	51		 push	 ecx
  00467	e8 00 00 00 00	 call	 ?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjApplyBuffEffectDuration
  0046c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN3@ProcessSta:

; 155  : 					}
; 156  : 				}
; 157  : 			}
; 158  : 			break;

  0046f	eb 26		 jmp	 SHORT $LN14@ProcessSta
$LN1@ProcessSta:

; 159  : 
; 160  : 		case 57:
; 161  : 			{
; 162  : 				LPOBJ lpTargetObj = &gObj[iIndex];

  00471	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00474	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0047a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00480	89 45 f8	 mov	 DWORD PTR _lpTargetObj$220154[ebp], eax

; 163  : 				gObjBackSpring2(lpTargetObj, lpObj, aMsgSubCode);

  00483	8b 45 14	 mov	 eax, DWORD PTR _aMsgSubCode$[ebp]
  00486	50		 push	 eax
  00487	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0048a	51		 push	 ecx
  0048b	8b 55 f8	 mov	 edx, DWORD PTR _lpTargetObj$220154[ebp]
  0048e	52		 push	 edx
  0048f	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  00494	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@ProcessSta:

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  00497	5f		 pop	 edi
  00498	5e		 pop	 esi
  00499	5b		 pop	 ebx
  0049a	8b e5		 mov	 esp, ebp
  0049c	5d		 pop	 ebp
  0049d	c3		 ret	 0
  0049e	8b ff		 npad	 2
$LN17@ProcessSta:
  004a0	00 00 00 00	 DD	 $LN11@ProcessSta
  004a4	00 00 00 00	 DD	 $LN10@ProcessSta
  004a8	00 00 00 00	 DD	 $LN8@ProcessSta
  004ac	00 00 00 00	 DD	 $LN6@ProcessSta
  004b0	00 00 00 00	 DD	 $LN5@ProcessSta
  004b4	00 00 00 00	 DD	 $LN4@ProcessSta
  004b8	00 00 00 00	 DD	 $LN1@ProcessSta
  004bc	00 00 00 00	 DD	 $LN14@ProcessSta
$LN16@ProcessSta:
  004c0	00		 DB	 0
  004c1	01		 DB	 1
  004c2	02		 DB	 2
  004c3	03		 DB	 3
  004c4	07		 DB	 7
  004c5	07		 DB	 7
  004c6	07		 DB	 7
  004c7	07		 DB	 7
  004c8	07		 DB	 7
  004c9	07		 DB	 7
  004ca	07		 DB	 7
  004cb	07		 DB	 7
  004cc	07		 DB	 7
  004cd	07		 DB	 7
  004ce	07		 DB	 7
  004cf	07		 DB	 7
  004d0	07		 DB	 7
  004d1	07		 DB	 7
  004d2	07		 DB	 7
  004d3	07		 DB	 7
  004d4	07		 DB	 7
  004d5	07		 DB	 7
  004d6	07		 DB	 7
  004d7	07		 DB	 7
  004d8	07		 DB	 7
  004d9	07		 DB	 7
  004da	07		 DB	 7
  004db	07		 DB	 7
  004dc	07		 DB	 7
  004dd	07		 DB	 7
  004de	07		 DB	 7
  004df	07		 DB	 7
  004e0	07		 DB	 7
  004e1	07		 DB	 7
  004e2	07		 DB	 7
  004e3	07		 DB	 7
  004e4	07		 DB	 7
  004e5	07		 DB	 7
  004e6	07		 DB	 7
  004e7	07		 DB	 7
  004e8	07		 DB	 7
  004e9	07		 DB	 7
  004ea	07		 DB	 7
  004eb	07		 DB	 7
  004ec	07		 DB	 7
  004ed	07		 DB	 7
  004ee	07		 DB	 7
  004ef	07		 DB	 7
  004f0	07		 DB	 7
  004f1	07		 DB	 7
  004f2	07		 DB	 7
  004f3	07		 DB	 7
  004f4	07		 DB	 7
  004f5	07		 DB	 7
  004f6	04		 DB	 4
  004f7	05		 DB	 5
  004f8	06		 DB	 6
?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z ENDP ; TMonsterAI::ProcessStateMsg
_TEXT	ENDS
PUBLIC	??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@ ; `string'
EXTRN	?SendCrywolfChattingMsg@CCrywolfUtil@@QAAXHPADZZ:PROC ; CCrywolfUtil::SendCrywolfChattingMsg
EXTRN	?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z:PROC	; TMonsterAIRule::GetCurrentAIUnit
;	COMDAT ??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@ DB 0a1H
	DB	0daH, 'AI %s ', 0bfH, 0a1H, 0bcH, 0adH, ' %s ', 0b7H, 0ceH, ' '
	DB	0b9H, 0d9H, 0b2H, 0dbH, 0b4H, 0d9H, '!!', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iCurrentAI$ = -12					; size = 4
_iOldCurrentAI$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z PROC		; TMonsterAI::UpdateCurrentAIUnit

; 175  : {

  00500	55		 push	 ebp
  00501	8b ec		 mov	 ebp, esp
  00503	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00506	53		 push	 ebx
  00507	56		 push	 esi
  00508	57		 push	 edi

; 176  : 	LPOBJ lpObj = &gObj[iIndex];

  00509	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0050c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00512	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00518	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 177  : 
; 178  : 	if ( lpObj->Live == FALSE )

  0051b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051e	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  00522	85 c9		 test	 ecx, ecx
  00524	75 07		 jne	 SHORT $LN4@UpdateCurr

; 179  : 		return FALSE;

  00526	33 c0		 xor	 eax, eax
  00528	e9 91 00 00 00	 jmp	 $LN5@UpdateCurr
$LN4@UpdateCurr:

; 180  : 
; 181  : 	int iOldCurrentAI = lpObj->m_iCurrentAI;

  0052d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00530	8b 88 78 1c 00
	00		 mov	 ecx, DWORD PTR [eax+7288]
  00536	89 4d f8	 mov	 DWORD PTR _iOldCurrentAI$[ebp], ecx

; 182  : 	int iCurrentAI = TMonsterAIRule::GetCurrentAIUnit(lpObj->Class);

  00539	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00543	51		 push	 ecx
  00544	e8 00 00 00 00	 call	 ?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z ; TMonsterAIRule::GetCurrentAIUnit
  00549	83 c4 04	 add	 esp, 4
  0054c	89 45 f4	 mov	 DWORD PTR _iCurrentAI$[ebp], eax

; 183  : 
; 184  : 	if ( iCurrentAI == 0 )

  0054f	83 7d f4 00	 cmp	 DWORD PTR _iCurrentAI$[ebp], 0
  00553	75 18		 jne	 SHORT $LN3@UpdateCurr

; 185  : 	{
; 186  : 		if ( lpObj->m_iBasicAI != 0 )

  00555	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00558	83 b8 74 1c 00
	00 00		 cmp	 DWORD PTR [eax+7284], 0
  0055f	74 0c		 je	 SHORT $LN3@UpdateCurr

; 187  : 		{
; 188  : 			iCurrentAI = lpObj->m_iBasicAI;

  00561	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00564	8b 88 74 1c 00
	00		 mov	 ecx, DWORD PTR [eax+7284]
  0056a	89 4d f4	 mov	 DWORD PTR _iCurrentAI$[ebp], ecx
$LN3@UpdateCurr:

; 189  : 		}
; 190  : 	}
; 191  : 
; 192  : 	lpObj->m_iCurrentAI = iCurrentAI;

  0056d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00570	8b 4d f4	 mov	 ecx, DWORD PTR _iCurrentAI$[ebp]
  00573	89 88 78 1c 00
	00		 mov	 DWORD PTR [eax+7288], ecx

; 193  : 
; 194  : 	if ( iOldCurrentAI != iCurrentAI )

  00579	8b 45 f8	 mov	 eax, DWORD PTR _iOldCurrentAI$[ebp]
  0057c	3b 45 f4	 cmp	 eax, DWORD PTR _iCurrentAI$[ebp]
  0057f	74 38		 je	 SHORT $LN1@UpdateCurr

; 195  : 	{
; 196  : 		UTIL.SendCrywolfChattingMsg(lpObj->m_Index, "★AI %s 에서 %s 로 바꾼다!!", TMonsterAIUnit::FindAIUnit(iOldCurrentAI)->m_szUnitName, TMonsterAIUnit::FindAIUnit(iCurrentAI)->m_szUnitName);

  00581	8b 45 f4	 mov	 eax, DWORD PTR _iCurrentAI$[ebp]
  00584	50		 push	 eax
  00585	e8 00 00 00 00	 call	 ?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ; TMonsterAIUnit::FindAIUnit
  0058a	83 c4 04	 add	 esp, 4
  0058d	83 c0 04	 add	 eax, 4
  00590	50		 push	 eax
  00591	8b 4d f8	 mov	 ecx, DWORD PTR _iOldCurrentAI$[ebp]
  00594	51		 push	 ecx
  00595	e8 00 00 00 00	 call	 ?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ; TMonsterAIUnit::FindAIUnit
  0059a	83 c4 04	 add	 esp, 4
  0059d	83 c0 04	 add	 eax, 4
  005a0	50		 push	 eax
  005a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@
  005a6	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005a9	8b 02		 mov	 eax, DWORD PTR [edx]
  005ab	50		 push	 eax
  005ac	68 00 00 00 00	 push	 OFFSET _UTIL
  005b1	e8 00 00 00 00	 call	 ?SendCrywolfChattingMsg@CCrywolfUtil@@QAAXHPADZZ ; CCrywolfUtil::SendCrywolfChattingMsg
  005b6	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@UpdateCurr:

; 197  : 	}
; 198  : 
; 199  : 	return TRUE;

  005b9	b8 01 00 00 00	 mov	 eax, 1
$LN5@UpdateCurr:

; 200  : }

  005be	5f		 pop	 edi
  005bf	5e		 pop	 esi
  005c0	5b		 pop	 ebx
  005c1	8b e5		 mov	 esp, ebp
  005c3	5d		 pop	 ebp
  005c4	c3		 ret	 0
?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z ENDP		; TMonsterAI::UpdateCurrentAIUnit
_TEXT	ENDS
PUBLIC	?MonsterMove@TMonsterAI@@SAXH@Z			; TMonsterAI::MonsterMove
PUBLIC	?MonsterMoveProc@TMonsterAI@@SAXXZ		; TMonsterAI::MonsterMoveProc
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220168 = -4						; size = 4
?MonsterMoveProc@TMonsterAI@@SAXXZ PROC			; TMonsterAI::MonsterMoveProc

; 205  : {

  005d0	55		 push	 ebp
  005d1	8b ec		 mov	 ebp, esp
  005d3	83 ec 44	 sub	 esp, 68			; 00000044H
  005d6	53		 push	 ebx
  005d7	56		 push	 esi
  005d8	57		 push	 edi

; 206  : 	for ( int i=0;i<OBJ_MAXMONSTER;i++)

  005d9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$220168[ebp], 0
  005e0	eb 09		 jmp	 SHORT $LN4@MonsterMov
$LN3@MonsterMov:
  005e2	8b 45 fc	 mov	 eax, DWORD PTR _i$220168[ebp]
  005e5	83 c0 01	 add	 eax, 1
  005e8	89 45 fc	 mov	 DWORD PTR _i$220168[ebp], eax
$LN4@MonsterMov:
  005eb	81 7d fc c8 32
	00 00		 cmp	 DWORD PTR _i$220168[ebp], 13000 ; 000032c8H
  005f2	7d 27		 jge	 SHORT $LN5@MonsterMov

; 207  : 	{
; 208  : 		if ( gObj[i].m_iCurrentAI !=  0 )

  005f4	8b 45 fc	 mov	 eax, DWORD PTR _i$220168[ebp]
  005f7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  005fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00603	83 bc 01 78 1c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+7288], 0
  0060b	74 0c		 je	 SHORT $LN1@MonsterMov

; 209  : 		{
; 210  : 			TMonsterAI::MonsterMove(i);

  0060d	8b 45 fc	 mov	 eax, DWORD PTR _i$220168[ebp]
  00610	50		 push	 eax
  00611	e8 00 00 00 00	 call	 ?MonsterMove@TMonsterAI@@SAXH@Z ; TMonsterAI::MonsterMove
  00616	83 c4 04	 add	 esp, 4
$LN1@MonsterMov:

; 211  : 		}
; 212  : 	}

  00619	eb c7		 jmp	 SHORT $LN3@MonsterMov
$LN5@MonsterMov:

; 213  : }

  0061b	5f		 pop	 edi
  0061c	5e		 pop	 esi
  0061d	5b		 pop	 ebx
  0061e	8b e5		 mov	 esp, ebp
  00620	5d		 pop	 ebp
  00621	c3		 ret	 0
?MonsterMoveProc@TMonsterAI@@SAXXZ ENDP			; TMonsterAI::MonsterMoveProc
_TEXT	ENDS
PUBLIC	__real@3ff4cccccccccccd
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	_memset:PROC
EXTRN	?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; TMonsterAIUtil::CheckMovingCondition
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff4cccccccccccd
CONST	SEGMENT
__real@3ff4cccccccccccd DQ 03ff4cccccccccccdr	; 1.3
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv224 = -100						; size = 8
tv222 = -92						; size = 4
tv219 = -86						; size = 2
tv216 = -84						; size = 8
_dwDelayTime$220180 = -12				; size = 4
_dwMoveTime$220179 = -8					; size = 4
_lpObj$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?MonsterMove@TMonsterAI@@SAXH@Z PROC			; TMonsterAI::MonsterMove

; 219  : {

  00630	55		 push	 ebp
  00631	8b ec		 mov	 ebp, esp
  00633	83 ec 64	 sub	 esp, 100		; 00000064H
  00636	53		 push	 ebx
  00637	56		 push	 esi
  00638	57		 push	 edi

; 220  : 	LPOBJ lpObj = &gObj[iIndex];

  00639	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0063c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00642	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00648	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 221  : 
; 222  : 	if ( MONSTER_UTIL.CheckMovingCondition(lpObj) == FALSE )

  0064b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0064e	50		 push	 eax
  0064f	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00654	e8 00 00 00 00	 call	 ?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::CheckMovingCondition
  00659	85 c0		 test	 eax, eax
  0065b	75 68		 jne	 SHORT $LN9@MonsterMov@2

; 223  : 	{
; 224  : 		lpObj->PathCur = 0;

  0065d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00660	c7 80 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+392], 0

; 225  : 		lpObj->PathCount = 0;

  0066a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0066d	c7 80 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+388], 0

; 226  : 		lpObj->PathStartEnd = 0;

  00677	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0067a	c6 80 8c 01 00
	00 00		 mov	 BYTE PTR [eax+396], 0

; 227  : 		memset(lpObj->PathX, 0, sizeof(lpObj->PathX));

  00681	6a 1e		 push	 30			; 0000001eH
  00683	6a 00		 push	 0
  00685	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00688	05 ac 01 00 00	 add	 eax, 428		; 000001acH
  0068d	50		 push	 eax
  0068e	e8 00 00 00 00	 call	 _memset
  00693	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : 		memset(lpObj->PathY, 0, sizeof(lpObj->PathY));

  00696	6a 1e		 push	 30			; 0000001eH
  00698	6a 00		 push	 0
  0069a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0069d	05 ca 01 00 00	 add	 eax, 458		; 000001caH
  006a2	50		 push	 eax
  006a3	e8 00 00 00 00	 call	 _memset
  006a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  : 		memset(lpObj->PathDir, 0, sizeof(lpObj->PathY)); //check this out

  006ab	6a 1e		 push	 30			; 0000001eH
  006ad	6a 00		 push	 0
  006af	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b2	05 e8 01 00 00	 add	 eax, 488		; 000001e8H
  006b7	50		 push	 eax
  006b8	e8 00 00 00 00	 call	 _memset
  006bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 230  : 
; 231  : 		return ;

  006c0	e9 22 02 00 00	 jmp	 $LN10@MonsterMov@2
$LN9@MonsterMov@2:

; 232  : 	}
; 233  : 
; 234  : 	if ( lpObj->PathCount != 0 )

  006c5	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c8	83 b8 84 01 00
	00 00		 cmp	 DWORD PTR [eax+388], 0
  006cf	0f 84 af 01 00
	00		 je	 $LN8@MonsterMov@2

; 235  : 	{
; 236  : 		DWORD dwMoveTime = 0;

  006d5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwMoveTime$220179[ebp], 0

; 237  : 		DWORD dwDelayTime = 0;

  006dc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwDelayTime$220180[ebp], 0

; 238  : 
; 239  : 		if ( lpObj->DelayLevel != 0 )

  006e3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e6	0f be 88 c4 03
	00 00		 movsx	 ecx, BYTE PTR [eax+964]
  006ed	85 c9		 test	 ecx, ecx
  006ef	74 09		 je	 SHORT $LN7@MonsterMov@2

; 240  : 			dwDelayTime = 300;

  006f1	c7 45 f4 2c 01
	00 00		 mov	 DWORD PTR _dwDelayTime$220180[ebp], 300 ; 0000012cH

; 241  : 		else

  006f8	eb 07		 jmp	 SHORT $LN6@MonsterMov@2
$LN7@MonsterMov@2:

; 242  : 			dwDelayTime = 0;

  006fa	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwDelayTime$220180[ebp], 0
$LN6@MonsterMov@2:

; 243  : 
; 244  : 		lpObj->m_MoveSpeed = 300;

  00701	b8 2c 01 00 00	 mov	 eax, 300		; 0000012cH
  00706	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00709	66 89 81 ac 04
	00 00		 mov	 WORD PTR [ecx+1196], ax

; 245  : 		
; 246  : 		if ( (lpObj->PathDir[lpObj->PathCur] % 2 ) == 0 )

  00710	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00713	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  00719	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0071c	0f be 84 0a e8
	01 00 00	 movsx	 eax, BYTE PTR [edx+ecx+488]
  00724	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00729	79 05		 jns	 SHORT $LN12@MonsterMov@2
  0072b	48		 dec	 eax
  0072c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0072f	40		 inc	 eax
$LN12@MonsterMov@2:
  00730	85 c0		 test	 eax, eax
  00732	75 40		 jne	 SHORT $LN5@MonsterMov@2

; 247  : 			dwMoveTime = (DWORD)((double)(lpObj->m_MoveSpeed + dwDelayTime) * 1.3);

  00734	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00737	0f bf 88 ac 04
	00 00		 movsx	 ecx, WORD PTR [eax+1196]
  0073e	03 4d f4	 add	 ecx, DWORD PTR _dwDelayTime$220180[ebp]
  00741	89 4d ac	 mov	 DWORD PTR tv216[ebp], ecx
  00744	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv216[ebp+4], 0
  0074b	df 6d ac	 fild	 QWORD PTR tv216[ebp]
  0074e	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff4cccccccccccd
  00754	d9 7d aa	 fnstcw	 WORD PTR tv219[ebp]
  00757	0f b7 45 aa	 movzx	 eax, WORD PTR tv219[ebp]
  0075b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00760	89 45 a4	 mov	 DWORD PTR tv222[ebp], eax
  00763	d9 6d a4	 fldcw	 WORD PTR tv222[ebp]
  00766	df 7d 9c	 fistp	 QWORD PTR tv224[ebp]
  00769	d9 6d aa	 fldcw	 WORD PTR tv219[ebp]
  0076c	8b 55 9c	 mov	 edx, DWORD PTR tv224[ebp]
  0076f	89 55 f8	 mov	 DWORD PTR _dwMoveTime$220179[ebp], edx

; 248  : 		else

  00772	eb 10		 jmp	 SHORT $LN4@MonsterMov@2
$LN5@MonsterMov@2:

; 249  : 			dwMoveTime = lpObj->m_MoveSpeed + dwDelayTime;

  00774	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00777	0f bf 88 ac 04
	00 00		 movsx	 ecx, WORD PTR [eax+1196]
  0077e	03 4d f4	 add	 ecx, DWORD PTR _dwDelayTime$220180[ebp]
  00781	89 4d f8	 mov	 DWORD PTR _dwMoveTime$220179[ebp], ecx
$LN4@MonsterMov@2:

; 250  : 
; 251  : 		if ( (GetTickCount() - lpObj->PathTime) > dwMoveTime )

  00784	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0078a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0078d	2b 81 f8 01 00
	00		 sub	 eax, DWORD PTR [ecx+504]
  00793	3b 45 f8	 cmp	 eax, DWORD PTR _dwMoveTime$220179[ebp]
  00796	0f 86 e6 00 00
	00		 jbe	 $LN3@MonsterMov@2

; 252  : 		{
; 253  : 			if ( lpObj->PathCur < 15 )

  0079c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0079f	83 b8 88 01 00
	00 0f		 cmp	 DWORD PTR [eax+392], 15	; 0000000fH
  007a6	0f 8d b4 00 00
	00		 jge	 $LN1@MonsterMov@2

; 254  : 			{
; 255  : 				lpObj->X = lpObj->PathX[lpObj->PathCur];

  007ac	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007af	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  007b5	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007b8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007bb	66 8b 8c 48 ac
	01 00 00	 mov	 cx, WORD PTR [eax+ecx*2+428]
  007c3	66 89 8a 44 01
	00 00		 mov	 WORD PTR [edx+324], cx

; 256  : 				lpObj->Y = lpObj->PathY[lpObj->PathCur];

  007ca	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007cd	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  007d3	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007d6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d9	66 8b 8c 48 ca
	01 00 00	 mov	 cx, WORD PTR [eax+ecx*2+458]
  007e1	66 89 8a 46 01
	00 00		 mov	 WORD PTR [edx+326], cx

; 257  : 				lpObj->Dir = lpObj->PathDir[lpObj->PathCur];

  007e8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007eb	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  007f1	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007f4	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007f7	8a 8c 08 e8 01
	00 00		 mov	 cl, BYTE PTR [eax+ecx+488]
  007fe	88 8a 48 01 00
	00		 mov	 BYTE PTR [edx+328], cl

; 258  : 				lpObj->PathTime = GetTickCount();

  00804	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0080a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0080d	89 81 f8 01 00
	00		 mov	 DWORD PTR [ecx+504], eax

; 259  : 				lpObj->PathCur++;

  00813	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00816	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  0081c	83 c1 01	 add	 ecx, 1
  0081f	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00822	89 8a 88 01 00
	00		 mov	 DWORD PTR [edx+392], ecx

; 260  : 
; 261  : 				if ( lpObj->PathCur >= lpObj->PathCount )

  00828	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0082b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0082e	8b 90 88 01 00
	00		 mov	 edx, DWORD PTR [eax+392]
  00834	3b 91 84 01 00
	00		 cmp	 edx, DWORD PTR [ecx+388]
  0083a	7c 24		 jl	 SHORT $LN1@MonsterMov@2

; 262  : 				{
; 263  : 					lpObj->PathCur = 0;

  0083c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0083f	c7 80 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+392], 0

; 264  : 					lpObj->PathCount = 0;

  00849	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0084c	c7 80 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+388], 0

; 265  : 					lpObj->PathStartEnd = 0;

  00856	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00859	c6 80 8c 01 00
	00 00		 mov	 BYTE PTR [eax+396], 0
$LN1@MonsterMov@2:

; 266  : 				}
; 267  : 			}
; 268  : 
; 269  : 			CreateFrustrum(lpObj->X, lpObj->Y, iIndex);

  00860	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00863	50		 push	 eax
  00864	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00867	0f bf 91 46 01
	00 00		 movsx	 edx, WORD PTR [ecx+326]
  0086e	52		 push	 edx
  0086f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00872	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00879	51		 push	 ecx
  0087a	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0087f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@MonsterMov@2:

; 270  : 		}
; 271  : 
; 272  : 		return;

  00882	eb 63		 jmp	 SHORT $LN10@MonsterMov@2
$LN8@MonsterMov@2:

; 273  : 
; 274  : 	}
; 275  : 
; 276  : 	lpObj->PathCur = 0;

  00884	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00887	c7 80 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+392], 0

; 277  : 	lpObj->PathCount = 0;

  00891	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00894	c7 80 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+388], 0

; 278  : 	lpObj->PathStartEnd = 0;

  0089e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008a1	c6 80 8c 01 00
	00 00		 mov	 BYTE PTR [eax+396], 0

; 279  : 	memset(lpObj->PathX, 0, sizeof(lpObj->PathX));

  008a8	6a 1e		 push	 30			; 0000001eH
  008aa	6a 00		 push	 0
  008ac	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008af	05 ac 01 00 00	 add	 eax, 428		; 000001acH
  008b4	50		 push	 eax
  008b5	e8 00 00 00 00	 call	 _memset
  008ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : 	memset(lpObj->PathY, 0, sizeof(lpObj->PathY));

  008bd	6a 1e		 push	 30			; 0000001eH
  008bf	6a 00		 push	 0
  008c1	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008c4	05 ca 01 00 00	 add	 eax, 458		; 000001caH
  008c9	50		 push	 eax
  008ca	e8 00 00 00 00	 call	 _memset
  008cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 	memset(lpObj->PathDir, 0, sizeof(lpObj->PathY)); //check this out

  008d2	6a 1e		 push	 30			; 0000001eH
  008d4	6a 00		 push	 0
  008d6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008d9	05 e8 01 00 00	 add	 eax, 488		; 000001e8H
  008de	50		 push	 eax
  008df	e8 00 00 00 00	 call	 _memset
  008e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@MonsterMov@2:

; 282  : }

  008e7	5f		 pop	 edi
  008e8	5e		 pop	 esi
  008e9	5b		 pop	 ebx
  008ea	8b e5		 mov	 esp, ebp
  008ec	5d		 pop	 ebp
  008ed	c3		 ret	 0
?MonsterMove@TMonsterAI@@SAXH@Z ENDP			; TMonsterAI::MonsterMove
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??0TMonsterAIUtil@@QAE@XZ:PROC			; TMonsterAIUtil::TMonsterAIUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__EMONSTER_UTIL@@YAXXZ
text$yc	SEGMENT
??__EMONSTER_UTIL@@YAXXZ PROC				; `dynamic initializer for 'MONSTER_UTIL'', COMDAT

; 16   : static TMonsterAIUtil MONSTER_UTIL;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  0000e	e8 00 00 00 00	 call	 ??0TMonsterAIUtil@@QAE@XZ ; TMonsterAIUtil::TMonsterAIUtil
  00013	68 00 00 00 00	 push	 OFFSET ??__FMONSTER_UTIL@@YAXXZ ; `dynamic atexit destructor for 'MONSTER_UTIL''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EMONSTER_UTIL@@YAXXZ ENDP				; `dynamic initializer for 'MONSTER_UTIL''
text$yc	ENDS
EXTRN	??0CCrywolfUtil@@QAE@XZ:PROC			; CCrywolfUtil::CCrywolfUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__EUTIL@@YAXXZ
text$yc	SEGMENT
??__EUTIL@@YAXXZ PROC					; `dynamic initializer for 'UTIL'', COMDAT

; 17   : static CCrywolfUtil UTIL;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _UTIL
  0000e	e8 00 00 00 00	 call	 ??0CCrywolfUtil@@QAE@XZ	; CCrywolfUtil::CCrywolfUtil
  00013	68 00 00 00 00	 push	 OFFSET ??__FUTIL@@YAXXZ	; `dynamic atexit destructor for 'UTIL''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EUTIL@@YAXXZ ENDP					; `dynamic initializer for 'UTIL''
text$yc	ENDS
EXTRN	??1TMonsterAIUtil@@UAE@XZ:PROC			; TMonsterAIUtil::~TMonsterAIUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FMONSTER_UTIL@@YAXXZ
text$yd	SEGMENT
??__FMONSTER_UTIL@@YAXXZ PROC				; `dynamic atexit destructor for 'MONSTER_UTIL'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  0000e	e8 00 00 00 00	 call	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FMONSTER_UTIL@@YAXXZ ENDP				; `dynamic atexit destructor for 'MONSTER_UTIL''
text$yd	ENDS
EXTRN	??1CCrywolfUtil@@UAE@XZ:PROC			; CCrywolfUtil::~CCrywolfUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FUTIL@@YAXXZ
text$yd	SEGMENT
??__FUTIL@@YAXXZ PROC					; `dynamic atexit destructor for 'UTIL'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _UTIL
  0000e	e8 00 00 00 00	 call	 ??1CCrywolfUtil@@UAE@XZ	; CCrywolfUtil::~CCrywolfUtil
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FUTIL@@YAXXZ ENDP					; `dynamic atexit destructor for 'UTIL''
text$yd	ENDS
_BSS	SEGMENT
_UTIL	DD	01H DUP (?)
_MONSTER_UTIL DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_MONSTER_UTIL$initializer$ DD FLAT:??__EMONSTER_UTIL@@YAXXZ
_UTIL$initializer$ DD FLAT:??__EUTIL@@YAXXZ
CRT$XCU	ENDS
END
