; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\PetEx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Init@CPetEx@@QAEXXZ				; CPetEx::Init
PUBLIC	??0CPetEx@@QAE@XZ				; CPetEx::CPetEx
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\petex.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPetEx@@QAE@XZ PROC					; CPetEx::CPetEx
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 14   : 	this->Init();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Init@CPetEx@@QAEXXZ	; CPetEx::Init

; 15   : }

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CPetEx@@QAE@XZ ENDP					; CPetEx::CPetEx
_TEXT	ENDS
PUBLIC	??1CPetEx@@QAE@XZ				; CPetEx::~CPetEx
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CPetEx@@QAE@XZ PROC					; CPetEx::~CPetEx
; _this$ = ecx

; 18   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1CPetEx@@QAE@XZ ENDP					; CPetEx::~CPetEx
; Function compile flags: /Odtp /ZI
_i$227365 = -16					; size = 4
_n$227361 = -12						; size = 4
_i$227357 = -8						; size = 4
_this$ = -4						; size = 4
?Init@CPetEx@@QAEXXZ PROC				; CPetEx::Init
; _this$ = ecx

; 22   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 50	 sub	 esp, 80			; 00000050H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 	this->m_Enable = 0;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 24   : 	this->m_PetCount = 0;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 25   : 	this->m_ImmortalCount = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 26   : 
; 27   : 	for(int i = 0; i < MAX_PETEX_COUNT; i++)

  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$227357[ebp], 0
  00070	eb 09		 jmp	 SHORT $LN9@Init
$LN8@Init:
  00072	8b 45 f8	 mov	 eax, DWORD PTR _i$227357[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	89 45 f8	 mov	 DWORD PTR _i$227357[ebp], eax
$LN9@Init:
  0007b	83 7d f8 64	 cmp	 DWORD PTR _i$227357[ebp], 100 ; 00000064H
  0007f	0f 8d 82 00 00
	00		 jge	 $LN7@Init

; 28   : 	{
; 29   : 		this->m_Data[i].Active = false;	

  00085	8b 45 f8	 mov	 eax, DWORD PTR _i$227357[ebp]
  00088	6b c0 34	 imul	 eax, 52			; 00000034H
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	c7 44 01 0c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+12], 0

; 30   : 		this->m_Data[i].ItemType = -1;	

  00096	8b 45 f8	 mov	 eax, DWORD PTR _i$227357[ebp]
  00099	6b c0 34	 imul	 eax, 52			; 00000034H
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	c7 44 01 10 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+16], -1

; 31   : 		this->m_Data[i].ItemIndex = -1;	

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _i$227357[ebp]
  000aa	6b c0 34	 imul	 eax, 52			; 00000034H
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+20], -1

; 32   : 		
; 33   : 		for(int n = 0; n < MAX_PETEX_OPTION; n++)

  000b8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$227361[ebp], 0
  000bf	eb 09		 jmp	 SHORT $LN6@Init
$LN5@Init:
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _n$227361[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	89 45 f4	 mov	 DWORD PTR _n$227361[ebp], eax
$LN6@Init:
  000ca	83 7d f4 05	 cmp	 DWORD PTR _n$227361[ebp], 5
  000ce	7d 32		 jge	 SHORT $LN4@Init

; 34   : 		{
; 35   : 			this->m_Data[i].Option[n].Type = 0;

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _i$227357[ebp]
  000d3	6b c0 34	 imul	 eax, 52			; 00000034H
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  000dd	8b 45 f4	 mov	 eax, DWORD PTR _n$227361[ebp]
  000e0	c7 44 c2 0c 00
	00 00 00	 mov	 DWORD PTR [edx+eax*8+12], 0

; 36   : 			this->m_Data[i].Option[n].Value = 0;		

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _i$227357[ebp]
  000eb	6b c0 34	 imul	 eax, 52			; 00000034H
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  000f5	8b 45 f4	 mov	 eax, DWORD PTR _n$227361[ebp]
  000f8	c7 44 c2 10 00
	00 00 00	 mov	 DWORD PTR [edx+eax*8+16], 0

; 37   : 		}

  00100	eb bf		 jmp	 SHORT $LN5@Init
$LN4@Init:

; 38   : 	}

  00102	e9 6b ff ff ff	 jmp	 $LN8@Init
$LN7@Init:

; 39   : 
; 40   : 	for(int i = 0; i < MAX_PETEX_COUNT; i++)

  00107	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$227365[ebp], 0
  0010e	eb 09		 jmp	 SHORT $LN3@Init
$LN2@Init:
  00110	8b 45 f0	 mov	 eax, DWORD PTR _i$227365[ebp]
  00113	83 c0 01	 add	 eax, 1
  00116	89 45 f0	 mov	 DWORD PTR _i$227365[ebp], eax
$LN3@Init:
  00119	83 7d f0 64	 cmp	 DWORD PTR _i$227365[ebp], 100 ; 00000064H
  0011d	7d 3e		 jge	 SHORT $LN10@Init

; 41   : 	{
; 42   : 		this->m_Immoirtal[i].Active = false;	

  0011f	8b 45 f0	 mov	 eax, DWORD PTR _i$227365[ebp]
  00122	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00125	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	c7 84 01 5c 14
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+5212], 0

; 43   : 		this->m_Immoirtal[i].ItemType = -1;	

  00133	8b 45 f0	 mov	 eax, DWORD PTR _i$227365[ebp]
  00136	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00139	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	c7 84 01 60 14
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+5216], -1

; 44   : 		this->m_Immoirtal[i].ItemIndex = -1;	

  00147	8b 45 f0	 mov	 eax, DWORD PTR _i$227365[ebp]
  0014a	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	c7 84 01 64 14
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+5220], -1

; 45   : 	}

  0015b	eb b3		 jmp	 SHORT $LN2@Init
$LN10@Init:

; 46   : }

  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
?Init@CPetEx@@QAEXXZ ENDP				; CPetEx::Init
_TEXT	ENDS
PUBLIC	?Read@CPetEx@@QAEXPAD@Z				; CPetEx::Read
PUBLIC	??_C@_0BB@GHINEGNE@ExData?2PetEx?4dat?$AA@	; `string'
PUBLIC	?Load@CPetEx@@QAEXXZ				; CPetEx::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0BB@GHINEGNE@ExData?2PetEx?4dat?$AA@
CONST	SEGMENT
??_C@_0BB@GHINEGNE@ExData?2PetEx?4dat?$AA@ DB 'ExData\PetEx.dat', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CPetEx@@QAEXXZ PROC				; CPetEx::Load
; _this$ = ecx

; 49   : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	83 ec 44	 sub	 esp, 68			; 00000044H
  00176	53		 push	 ebx
  00177	56		 push	 esi
  00178	57		 push	 edi
  00179	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   : 	this->Init();

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	e8 00 00 00 00	 call	 ?Init@CPetEx@@QAEXXZ	; CPetEx::Init

; 51   : 
; 52   : 	if(g_ExLicense.CheckUser(eExUB::Local)    || 
; 53   : 		g_ExLicense.CheckUser(eExUB::SILVER1)  || 
; 54   : 		g_ExLicense.CheckUser(eExUB::SILVER2) ||
; 55   : 		g_ExLicense.CheckUser(eExUB::eternalmu) ||
; 56   : 		g_ExLicense.CheckUser(eExUB::NSGames))

  00184	6a 00		 push	 0
  00186	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0018b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00190	0f b6 c0	 movzx	 eax, al
  00193	85 c0		 test	 eax, eax
  00195	75 4c		 jne	 SHORT $LN1@Load
  00197	6a 07		 push	 7
  00199	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0019e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001a3	0f b6 c0	 movzx	 eax, al
  001a6	85 c0		 test	 eax, eax
  001a8	75 39		 jne	 SHORT $LN1@Load
  001aa	6a 08		 push	 8
  001ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001b1	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001b6	0f b6 c0	 movzx	 eax, al
  001b9	85 c0		 test	 eax, eax
  001bb	75 26		 jne	 SHORT $LN1@Load
  001bd	6a 4f		 push	 79			; 0000004fH
  001bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001c4	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001c9	0f b6 c0	 movzx	 eax, al
  001cc	85 c0		 test	 eax, eax
  001ce	75 13		 jne	 SHORT $LN1@Load
  001d0	6a 51		 push	 81			; 00000051H
  001d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001d7	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001dc	0f b6 c0	 movzx	 eax, al
  001df	85 c0		 test	 eax, eax
  001e1	74 18		 je	 SHORT $LN3@Load
$LN1@Load:

; 57   : 	{
; 58   : 		this->Read(gDirPath.GetNewPath("ExData\\PetEx.dat"));

  001e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GHINEGNE@ExData?2PetEx?4dat?$AA@
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001ed	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001f2	50		 push	 eax
  001f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	e8 00 00 00 00	 call	 ?Read@CPetEx@@QAEXPAD@Z	; CPetEx::Read
$LN3@Load:

; 59   : 	}
; 60   : }

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b e5		 mov	 esp, ebp
  00200	5d		 pop	 ebp
  00201	c3		 ret	 0
?Load@CPetEx@@QAEXXZ ENDP				; CPetEx::Load
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$227420 = -20						; size = 4
_iMaxType$ = -16					; size = 4
_iType$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Read@CPetEx@@QAEXPAD@Z PROC				; CPetEx::Read
; _this$ = ecx

; 64   : {

  00210	55		 push	 ebp
  00211	8b ec		 mov	 ebp, esp
  00213	83 ec 54	 sub	 esp, 84			; 00000054H
  00216	53		 push	 ebx
  00217	56		 push	 esi
  00218	57		 push	 edi
  00219	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 	SMDFile = fopen(filename, "r");

  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00221	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _fopen
  0022a	83 c4 08	 add	 esp, 8
  0022d	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 66   : 
; 67   : 	if(SMDFile == NULL)

  00232	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00239	75 22		 jne	 SHORT $LN23@Read

; 68   : 	{
; 69   : 		LogAdd(lMsg.Get(MSGGET(1, 198)), filename);

  0023b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0023e	50		 push	 eax
  0023f	68 c6 01 00 00	 push	 454			; 000001c6H
  00244	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00249	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0024e	50		 push	 eax
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00255	83 c4 08	 add	 esp, 8

; 70   : 		return;

  00258	e9 96 02 00 00	 jmp	 $LN24@Read
$LN23@Read:

; 71   : 	}
; 72   : 
; 73   : 	SMDToken Token;
; 74   : 
; 75   : 	int iType = -1;

  0025d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iType$[ebp], -1

; 76   : 	int iMaxType = 1;

  00264	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iMaxType$[ebp], 1

; 77   : 
; 78   : 	if(g_ExLicense.CheckUser(eExUB::SILVER1) || g_ExLicense.CheckUser(eExUB::SILVER2))

  0026b	6a 07		 push	 7
  0026d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00272	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00277	0f b6 c0	 movzx	 eax, al
  0027a	85 c0		 test	 eax, eax
  0027c	75 13		 jne	 SHORT $LN21@Read
  0027e	6a 08		 push	 8
  00280	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00285	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0028a	0f b6 c0	 movzx	 eax, al
  0028d	85 c0		 test	 eax, eax
  0028f	74 07		 je	 SHORT $LN22@Read
$LN21@Read:

; 79   : 	{
; 80   : 		iMaxType = 2;

  00291	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR _iMaxType$[ebp], 2
$LN22@Read:

; 81   : 	}
; 82   : 
; 83   : 	while(true)

  00298	b8 01 00 00 00	 mov	 eax, 1
  0029d	85 c0		 test	 eax, eax
  0029f	0f 84 2e 02 00
	00		 je	 $LN19@Read

; 84   : 	{
; 85   : 		Token = GetToken();

  002a5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002aa	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 86   : 
; 87   :         if(Token == END)

  002ad	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  002b1	75 05		 jne	 SHORT $LN18@Read

; 88   : 		{
; 89   :             break;

  002b3	e9 1b 02 00 00	 jmp	 $LN19@Read
$LN18@Read:

; 90   : 		}
; 91   : 
; 92   : 		iType = (int)TokenNumber;

  002b8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002be	e8 00 00 00 00	 call	 __ftol2_sse
  002c3	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 93   : 
; 94   : 		if(iType < 0 || iType > iMaxType)

  002c6	83 7d f4 00	 cmp	 DWORD PTR _iType$[ebp], 0
  002ca	7c 08		 jl	 SHORT $LN16@Read
  002cc	8b 45 f4	 mov	 eax, DWORD PTR _iType$[ebp]
  002cf	3b 45 f0	 cmp	 eax, DWORD PTR _iMaxType$[ebp]
  002d2	7e 05		 jle	 SHORT $LN17@Read
$LN16@Read:

; 95   : 		{
; 96   : 			break;

  002d4	e9 fa 01 00 00	 jmp	 $LN19@Read
$LN17@Read:

; 97   : 		}
; 98   : 
; 99   : 		while(true)

  002d9	b8 01 00 00 00	 mov	 eax, 1
  002de	85 c0		 test	 eax, eax
  002e0	0f 84 e8 01 00
	00		 je	 $LN14@Read

; 100  : 		{
; 101  : 			if(iType == 0)

  002e6	83 7d f4 00	 cmp	 DWORD PTR _iType$[ebp], 0
  002ea	75 38		 jne	 SHORT $LN13@Read

; 102  : 			{
; 103  : 				Token = GetToken();

  002ec	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002f1	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 104  : 
; 105  : 				if(!strcmp("end", TokenString))

  002f4	68 00 00 00 00	 push	 OFFSET _TokenString
  002f9	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  002fe	e8 00 00 00 00	 call	 _strcmp
  00303	83 c4 08	 add	 esp, 8
  00306	85 c0		 test	 eax, eax
  00308	75 05		 jne	 SHORT $LN12@Read

; 106  : 				{
; 107  : 					break;

  0030a	e9 bf 01 00 00	 jmp	 $LN14@Read
$LN12@Read:

; 108  : 				}
; 109  : 
; 110  : 				this->m_Enable = (int)TokenNumber;

  0030f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00315	e8 00 00 00 00	 call	 __ftol2_sse
  0031a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	89 01		 mov	 DWORD PTR [ecx], eax
  0031f	e9 a5 01 00 00	 jmp	 $LN3@Read
$LN13@Read:

; 111  : 			}
; 112  : 			else if(iType == 1)

  00324	83 7d f4 01	 cmp	 DWORD PTR _iType$[ebp], 1
  00328	0f 85 05 01 00
	00		 jne	 $LN10@Read

; 113  : 			{
; 114  : 				Token = GetToken();

  0032e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00333	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 115  : 
; 116  : 				if(!strcmp("end", TokenString))

  00336	68 00 00 00 00	 push	 OFFSET _TokenString
  0033b	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00340	e8 00 00 00 00	 call	 _strcmp
  00345	83 c4 08	 add	 esp, 8
  00348	85 c0		 test	 eax, eax
  0034a	75 05		 jne	 SHORT $LN9@Read

; 117  : 				{
; 118  : 					break;

  0034c	e9 7d 01 00 00	 jmp	 $LN14@Read
$LN9@Read:

; 119  : 				}
; 120  : 
; 121  : 				if(this->m_PetCount >= MAX_PETEX_COUNT)

  00351	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00354	83 78 04 64	 cmp	 DWORD PTR [eax+4], 100	; 00000064H
  00358	7c 05		 jl	 SHORT $LN8@Read

; 122  : 				{
; 123  : 					break;

  0035a	e9 6f 01 00 00	 jmp	 $LN14@Read
$LN8@Read:

; 124  : 				}
; 125  : 
; 126  : 				this->m_Data[this->m_PetCount].Active = true;

  0035f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00362	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00365	6b c9 34	 imul	 ecx, 52			; 00000034H
  00368	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0036b	c7 44 0a 0c 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+12], 1

; 127  : 
; 128  : 				this->m_Data[this->m_PetCount].ItemType = TokenNumber;

  00373	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00379	e8 00 00 00 00	 call	 __ftol2_sse
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00381	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00384	6b d2 34	 imul	 edx, 52			; 00000034H
  00387	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0038a	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 129  : 
; 130  : 				Token = GetToken();

  0038e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00393	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 131  : 				this->m_Data[this->m_PetCount].ItemIndex = TokenNumber;

  00396	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0039c	e8 00 00 00 00	 call	 __ftol2_sse
  003a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003a7	6b d2 34	 imul	 edx, 52			; 00000034H
  003aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ad	89 44 11 14	 mov	 DWORD PTR [ecx+edx+20], eax

; 132  : 
; 133  : 				for(int i = 0; i < MAX_PETEX_OPTION; i++)

  003b1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$227420[ebp], 0
  003b8	eb 09		 jmp	 SHORT $LN7@Read
$LN6@Read:
  003ba	8b 45 ec	 mov	 eax, DWORD PTR _i$227420[ebp]
  003bd	83 c0 01	 add	 eax, 1
  003c0	89 45 ec	 mov	 DWORD PTR _i$227420[ebp], eax
$LN7@Read:
  003c3	83 7d ec 05	 cmp	 DWORD PTR _i$227420[ebp], 5
  003c7	7d 56		 jge	 SHORT $LN5@Read

; 134  : 				{
; 135  : 					Token = GetToken();

  003c9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003ce	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 136  : 					this->m_Data[this->m_PetCount].Option[i].Type = TokenNumber;

  003d1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003d7	e8 00 00 00 00	 call	 __ftol2_sse
  003dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003df	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003e2	6b d2 34	 imul	 edx, 52			; 00000034H
  003e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e8	8d 54 11 0c	 lea	 edx, DWORD PTR [ecx+edx+12]
  003ec	8b 4d ec	 mov	 ecx, DWORD PTR _i$227420[ebp]
  003ef	89 44 ca 0c	 mov	 DWORD PTR [edx+ecx*8+12], eax

; 137  : 
; 138  : 					Token = GetToken();

  003f3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003f8	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 139  : 					this->m_Data[this->m_PetCount].Option[i].Value = TokenNumber;

  003fb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00401	e8 00 00 00 00	 call	 __ftol2_sse
  00406	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00409	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0040c	6b d2 34	 imul	 edx, 52			; 00000034H
  0040f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00412	8d 54 11 0c	 lea	 edx, DWORD PTR [ecx+edx+12]
  00416	8b 4d ec	 mov	 ecx, DWORD PTR _i$227420[ebp]
  00419	89 44 ca 10	 mov	 DWORD PTR [edx+ecx*8+16], eax

; 140  : 				}

  0041d	eb 9b		 jmp	 SHORT $LN6@Read
$LN5@Read:

; 141  : 
; 142  : 				this->m_PetCount++;

  0041f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00422	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00425	83 c1 01	 add	 ecx, 1
  00428	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0042b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0042e	e9 96 00 00 00	 jmp	 $LN3@Read
$LN10@Read:

; 143  : 			}
; 144  : 			else if(iType == 2)

  00433	83 7d f4 02	 cmp	 DWORD PTR _iType$[ebp], 2
  00437	0f 85 8c 00 00
	00		 jne	 $LN3@Read

; 145  : 			{
; 146  : 				Token = GetToken();

  0043d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00442	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 147  : 
; 148  : 				if(!strcmp("end", TokenString))

  00445	68 00 00 00 00	 push	 OFFSET _TokenString
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0044f	e8 00 00 00 00	 call	 _strcmp
  00454	83 c4 08	 add	 esp, 8
  00457	85 c0		 test	 eax, eax
  00459	75 02		 jne	 SHORT $LN2@Read

; 149  : 				{
; 150  : 					break;

  0045b	eb 71		 jmp	 SHORT $LN14@Read
$LN2@Read:

; 151  : 				}
; 152  : 
; 153  : 				if(this->m_ImmortalCount >= MAX_PETEX_COUNT)

  0045d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00460	83 78 08 64	 cmp	 DWORD PTR [eax+8], 100	; 00000064H
  00464	7c 02		 jl	 SHORT $LN1@Read

; 154  : 				{
; 155  : 					break;

  00466	eb 66		 jmp	 SHORT $LN14@Read
$LN1@Read:

; 156  : 				}
; 157  : 
; 158  : 				this->m_Data[this->m_ImmortalCount].Active = true;

  00468	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0046b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0046e	6b c9 34	 imul	 ecx, 52			; 00000034H
  00471	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00474	c7 44 0a 0c 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+12], 1

; 159  : 
; 160  : 				this->m_Data[this->m_ImmortalCount].ItemType = TokenNumber;

  0047c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00482	e8 00 00 00 00	 call	 __ftol2_sse
  00487	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0048a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0048d	6b d2 34	 imul	 edx, 52			; 00000034H
  00490	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00493	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 161  : 
; 162  : 				Token = GetToken();

  00497	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0049c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 163  : 				this->m_Data[this->m_ImmortalCount].ItemIndex = TokenNumber;

  0049f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004a5	e8 00 00 00 00	 call	 __ftol2_sse
  004aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ad	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  004b0	6b d2 34	 imul	 edx, 52			; 00000034H
  004b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004b6	89 44 11 14	 mov	 DWORD PTR [ecx+edx+20], eax

; 164  : 
; 165  : 				this->m_ImmortalCount++;

  004ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004bd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004c0	83 c1 01	 add	 ecx, 1
  004c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004c6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN3@Read:

; 166  : 			}
; 167  : 		}

  004c9	e9 0b fe ff ff	 jmp	 $LN17@Read
$LN14@Read:

; 168  : 	}

  004ce	e9 c5 fd ff ff	 jmp	 $LN22@Read
$LN19@Read:

; 169  : 
; 170  : 	fclose(SMDFile);

  004d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004d8	50		 push	 eax
  004d9	e8 00 00 00 00	 call	 _fclose
  004de	83 c4 04	 add	 esp, 4

; 171  : 
; 172  : 	LogAdd("%s file load!", filename);

  004e1	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  004e4	50		 push	 eax
  004e5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  004ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004f0	83 c4 08	 add	 esp, 8
$LN24@Read:

; 173  : }

  004f3	5f		 pop	 edi
  004f4	5e		 pop	 esi
  004f5	5b		 pop	 ebx
  004f6	8b e5		 mov	 esp, ebp
  004f8	5d		 pop	 ebp
  004f9	c2 04 00	 ret	 4
?Read@CPetEx@@QAEXPAD@Z ENDP				; CPetEx::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00500	55		 push	 ebp
  00501	8b ec		 mov	 ebp, esp
  00503	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00509	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0050e	33 c5		 xor	 eax, ebp
  00510	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00513	53		 push	 ebx
  00514	56		 push	 esi
  00515	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00516	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0051d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 _fgetc
  00528	83 c4 04	 add	 esp, 4
  0052b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0052e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00532	83 f9 ff	 cmp	 ecx, -1
  00535	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00537	b8 02 00 00 00	 mov	 eax, 2
  0053c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00541	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00543	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00547	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0054a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0054c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 _fgetc
  00557	83 c4 04	 add	 esp, 4
  0055a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0055d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00561	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00564	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00566	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0056a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0056d	74 1c		 je	 SHORT $LN23@GetToken
  0056f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00573	83 f8 ff	 cmp	 eax, -1
  00576	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00578	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0057d	50		 push	 eax
  0057e	e8 00 00 00 00	 call	 _fgetc
  00583	83 c4 04	 add	 esp, 4
  00586	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00589	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0058b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0058f	83 f8 ff	 cmp	 eax, -1
  00592	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00594	b8 02 00 00 00	 mov	 eax, 2
  00599	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0059e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005a2	50		 push	 eax
  005a3	e8 00 00 00 00	 call	 _isspace
  005a8	83 c4 04	 add	 esp, 4
  005ab	85 c0		 test	 eax, eax
  005ad	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  005b3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005b7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  005bd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  005c3	83 e9 22	 sub	 ecx, 34			; 00000022H
  005c6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  005cc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  005d3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  005d9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  005df	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  005e6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  005ed	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  005f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005fc	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00601	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00606	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00610	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00615	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0061a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0061f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00629	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0062e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00633	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00638	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00642	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00647	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0064c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00651	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0065b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00660	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00665	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0066a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0066f	50		 push	 eax
  00670	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00674	51		 push	 ecx
  00675	e8 00 00 00 00	 call	 _ungetc
  0067a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0067d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00680	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00683	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00688	50		 push	 eax
  00689	e8 00 00 00 00	 call	 _getc
  0068e	83 c4 04	 add	 esp, 4
  00691	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00694	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00698	83 f9 ff	 cmp	 ecx, -1
  0069b	74 36		 je	 SHORT $LN12@GetToken
  0069d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006a1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  006a4	74 1a		 je	 SHORT $LN11@GetToken
  006a6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 _isdigit
  006b0	83 c4 04	 add	 esp, 4
  006b3	85 c0		 test	 eax, eax
  006b5	75 09		 jne	 SHORT $LN11@GetToken
  006b7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006bb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  006be	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  006c0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006c3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  006c6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  006c8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006cb	83 c0 01	 add	 eax, 1
  006ce	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  006d1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  006d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006d6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  006d9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  006dc	50		 push	 eax
  006dd	e8 00 00 00 00	 call	 _atof
  006e2	83 c4 04	 add	 esp, 4
  006e5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  006eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  006f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006fa	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  006ff	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00704	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0070b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00710	50		 push	 eax
  00711	e8 00 00 00 00	 call	 _getc
  00716	83 c4 04	 add	 esp, 4
  00719	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0071c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00720	83 f9 ff	 cmp	 ecx, -1
  00723	74 1c		 je	 SHORT $LN8@GetToken
  00725	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00729	83 f8 22	 cmp	 eax, 34			; 00000022H
  0072c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0072e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00731	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00734	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00736	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00739	83 c0 01	 add	 eax, 1
  0073c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0073f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00741	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00745	83 f8 22	 cmp	 eax, 34			; 00000022H
  00748	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0074a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0074f	50		 push	 eax
  00750	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00754	51		 push	 ecx
  00755	e8 00 00 00 00	 call	 _ungetc
  0075a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0075d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00760	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00763	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0076d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00772	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00777	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0077c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00780	50		 push	 eax
  00781	e8 00 00 00 00	 call	 _isalpha
  00786	83 c4 04	 add	 esp, 4
  00789	85 c0		 test	 eax, eax
  0078b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00791	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00798	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0079b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0079e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  007a0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007a3	83 c0 01	 add	 eax, 1
  007a6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  007a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007ae	50		 push	 eax
  007af	e8 00 00 00 00	 call	 _getc
  007b4	83 c4 04	 add	 esp, 4
  007b7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  007ba	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  007be	83 f9 ff	 cmp	 ecx, -1
  007c1	74 36		 je	 SHORT $LN3@GetToken
  007c3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  007c7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  007ca	74 1a		 je	 SHORT $LN2@GetToken
  007cc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  007d0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  007d3	74 11		 je	 SHORT $LN2@GetToken
  007d5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  007d9	50		 push	 eax
  007da	e8 00 00 00 00	 call	 _isalnum
  007df	83 c4 04	 add	 esp, 4
  007e2	85 c0		 test	 eax, eax
  007e4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  007e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007e9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  007ec	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  007ee	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007f1	83 c0 01	 add	 eax, 1
  007f4	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  007f7	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  007f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007fe	50		 push	 eax
  007ff	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00803	51		 push	 ecx
  00804	e8 00 00 00 00	 call	 _ungetc
  00809	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0080c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0080f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00812	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0081c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00821	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00823	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00825	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0082f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00834	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00836	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00838	5f		 pop	 edi
  00839	5e		 pop	 esi
  0083a	5b		 pop	 ebx
  0083b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0083e	33 cd		 xor	 ecx, ebp
  00840	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00845	8b e5		 mov	 esp, ebp
  00847	5d		 pop	 ebp
  00848	c3		 ret	 0
  00849	8d 49 00	 npad	 3
$LN35@GetToken:
  0084c	00 00 00 00	 DD	 $LN10@GetToken
  00850	00 00 00 00	 DD	 $LN19@GetToken
  00854	00 00 00 00	 DD	 $LN17@GetToken
  00858	00 00 00 00	 DD	 $LN14@GetToken
  0085c	00 00 00 00	 DD	 $LN18@GetToken
  00860	00 00 00 00	 DD	 $LN16@GetToken
  00864	00 00 00 00	 DD	 $LN15@GetToken
  00868	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0086c	00		 DB	 0
  0086d	01		 DB	 1
  0086e	07		 DB	 7
  0086f	07		 DB	 7
  00870	07		 DB	 7
  00871	07		 DB	 7
  00872	07		 DB	 7
  00873	07		 DB	 7
  00874	07		 DB	 7
  00875	07		 DB	 7
  00876	02		 DB	 2
  00877	03		 DB	 3
  00878	03		 DB	 3
  00879	07		 DB	 7
  0087a	03		 DB	 3
  0087b	03		 DB	 3
  0087c	03		 DB	 3
  0087d	03		 DB	 3
  0087e	03		 DB	 3
  0087f	03		 DB	 3
  00880	03		 DB	 3
  00881	03		 DB	 3
  00882	03		 DB	 3
  00883	03		 DB	 3
  00884	07		 DB	 7
  00885	04		 DB	 4
  00886	07		 DB	 7
  00887	07		 DB	 7
  00888	07		 DB	 7
  00889	07		 DB	 7
  0088a	07		 DB	 7
  0088b	07		 DB	 7
  0088c	07		 DB	 7
  0088d	07		 DB	 7
  0088e	07		 DB	 7
  0088f	07		 DB	 7
  00890	07		 DB	 7
  00891	07		 DB	 7
  00892	07		 DB	 7
  00893	07		 DB	 7
  00894	07		 DB	 7
  00895	07		 DB	 7
  00896	07		 DB	 7
  00897	07		 DB	 7
  00898	07		 DB	 7
  00899	07		 DB	 7
  0089a	07		 DB	 7
  0089b	07		 DB	 7
  0089c	07		 DB	 7
  0089d	07		 DB	 7
  0089e	07		 DB	 7
  0089f	07		 DB	 7
  008a0	07		 DB	 7
  008a1	07		 DB	 7
  008a2	07		 DB	 7
  008a3	07		 DB	 7
  008a4	07		 DB	 7
  008a5	07		 DB	 7
  008a6	07		 DB	 7
  008a7	07		 DB	 7
  008a8	07		 DB	 7
  008a9	07		 DB	 7
  008aa	07		 DB	 7
  008ab	07		 DB	 7
  008ac	07		 DB	 7
  008ad	07		 DB	 7
  008ae	07		 DB	 7
  008af	07		 DB	 7
  008b0	07		 DB	 7
  008b1	07		 DB	 7
  008b2	07		 DB	 7
  008b3	07		 DB	 7
  008b4	07		 DB	 7
  008b5	07		 DB	 7
  008b6	07		 DB	 7
  008b7	07		 DB	 7
  008b8	07		 DB	 7
  008b9	07		 DB	 7
  008ba	07		 DB	 7
  008bb	07		 DB	 7
  008bc	07		 DB	 7
  008bd	07		 DB	 7
  008be	07		 DB	 7
  008bf	07		 DB	 7
  008c0	07		 DB	 7
  008c1	07		 DB	 7
  008c2	07		 DB	 7
  008c3	07		 DB	 7
  008c4	07		 DB	 7
  008c5	05		 DB	 5
  008c6	07		 DB	 7
  008c7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?IsPet@CPetEx@@QAE_NH@Z				; CPetEx::IsPet
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\petex.cpp
_TEXT	SEGMENT
_i$227434 = -8						; size = 4
_this$ = -4						; size = 4
_ItemID$ = 8						; size = 4
?IsPet@CPetEx@@QAE_NH@Z PROC				; CPetEx::IsPet
; _this$ = ecx

; 176  : {

  008d0	55		 push	 ebp
  008d1	8b ec		 mov	 ebp, esp
  008d3	83 ec 48	 sub	 esp, 72			; 00000048H
  008d6	53		 push	 ebx
  008d7	56		 push	 esi
  008d8	57		 push	 edi
  008d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 	if(!this->m_Enable)

  008dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008df	83 38 00	 cmp	 DWORD PTR [eax], 0
  008e2	75 04		 jne	 SHORT $LN5@IsPet

; 178  : 	{
; 179  : 		return false;

  008e4	32 c0		 xor	 al, al
  008e6	eb 47		 jmp	 SHORT $LN6@IsPet
$LN5@IsPet:

; 180  : 	}	
; 181  : 
; 182  : 	for(int i = 0; i < this->m_PetCount; i++)

  008e8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$227434[ebp], 0
  008ef	eb 09		 jmp	 SHORT $LN4@IsPet
$LN3@IsPet:
  008f1	8b 45 f8	 mov	 eax, DWORD PTR _i$227434[ebp]
  008f4	83 c0 01	 add	 eax, 1
  008f7	89 45 f8	 mov	 DWORD PTR _i$227434[ebp], eax
$LN4@IsPet:
  008fa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008fd	8b 4d f8	 mov	 ecx, DWORD PTR _i$227434[ebp]
  00900	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00903	7d 28		 jge	 SHORT $LN2@IsPet

; 183  : 	{
; 184  : 		if(ITEMGET(this->m_Data[i].ItemType, this->m_Data[i].ItemIndex) == ItemID)

  00905	8b 45 f8	 mov	 eax, DWORD PTR _i$227434[ebp]
  00908	6b c0 34	 imul	 eax, 52			; 00000034H
  0090b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0090e	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00912	c1 e2 09	 shl	 edx, 9
  00915	8b 45 f8	 mov	 eax, DWORD PTR _i$227434[ebp]
  00918	6b c0 34	 imul	 eax, 52			; 00000034H
  0091b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0091e	03 54 01 14	 add	 edx, DWORD PTR [ecx+eax+20]
  00922	3b 55 08	 cmp	 edx, DWORD PTR _ItemID$[ebp]
  00925	75 04		 jne	 SHORT $LN1@IsPet

; 185  : 		{
; 186  : 			return true;

  00927	b0 01		 mov	 al, 1
  00929	eb 04		 jmp	 SHORT $LN6@IsPet
$LN1@IsPet:

; 187  : 		}
; 188  : 	}

  0092b	eb c4		 jmp	 SHORT $LN3@IsPet
$LN2@IsPet:

; 189  : 
; 190  : 	return false;

  0092d	32 c0		 xor	 al, al
$LN6@IsPet:

; 191  : }

  0092f	5f		 pop	 edi
  00930	5e		 pop	 esi
  00931	5b		 pop	 ebx
  00932	8b e5		 mov	 esp, ebp
  00934	5d		 pop	 ebp
  00935	c2 04 00	 ret	 4
?IsPet@CPetEx@@QAE_NH@Z ENDP				; CPetEx::IsPet
_TEXT	ENDS
PUBLIC	?IsPetImmortal@CPetEx@@QAE_NH@Z			; CPetEx::IsPetImmortal
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$227444 = -8						; size = 4
_this$ = -4						; size = 4
_ItemID$ = 8						; size = 4
?IsPetImmortal@CPetEx@@QAE_NH@Z PROC			; CPetEx::IsPetImmortal
; _this$ = ecx

; 194  : {

  00940	55		 push	 ebp
  00941	8b ec		 mov	 ebp, esp
  00943	83 ec 48	 sub	 esp, 72			; 00000048H
  00946	53		 push	 ebx
  00947	56		 push	 esi
  00948	57		 push	 edi
  00949	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : 	if(!this->m_Enable)

  0094c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0094f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00952	75 04		 jne	 SHORT $LN6@IsPetImmor

; 196  : 	{
; 197  : 		return false;

  00954	32 c0		 xor	 al, al
  00956	eb 5a		 jmp	 SHORT $LN7@IsPetImmor
$LN6@IsPetImmor:

; 198  : 	}	
; 199  : 
; 200  : 	for(int i = 0; i < this->m_ImmortalCount; i++)

  00958	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$227444[ebp], 0
  0095f	eb 09		 jmp	 SHORT $LN5@IsPetImmor
$LN4@IsPetImmor:
  00961	8b 45 f8	 mov	 eax, DWORD PTR _i$227444[ebp]
  00964	83 c0 01	 add	 eax, 1
  00967	89 45 f8	 mov	 DWORD PTR _i$227444[ebp], eax
$LN5@IsPetImmor:
  0096a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0096d	8b 4d f8	 mov	 ecx, DWORD PTR _i$227444[ebp]
  00970	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00973	7d 3b		 jge	 SHORT $LN3@IsPetImmor

; 201  : 	{
; 202  : 		if(this->m_Immoirtal[i].Active)

  00975	8b 45 f8	 mov	 eax, DWORD PTR _i$227444[ebp]
  00978	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0097b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0097e	83 bc 01 5c 14
	00 00 00	 cmp	 DWORD PTR [ecx+eax+5212], 0
  00986	74 26		 je	 SHORT $LN2@IsPetImmor

; 203  : 		{
; 204  : 			if(ITEMGET(this->m_Data[i].ItemType, this->m_Data[i].ItemIndex) == ItemID)

  00988	8b 45 f8	 mov	 eax, DWORD PTR _i$227444[ebp]
  0098b	6b c0 34	 imul	 eax, 52			; 00000034H
  0098e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00991	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00995	c1 e2 09	 shl	 edx, 9
  00998	8b 45 f8	 mov	 eax, DWORD PTR _i$227444[ebp]
  0099b	6b c0 34	 imul	 eax, 52			; 00000034H
  0099e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009a1	03 54 01 14	 add	 edx, DWORD PTR [ecx+eax+20]
  009a5	3b 55 08	 cmp	 edx, DWORD PTR _ItemID$[ebp]
  009a8	75 04		 jne	 SHORT $LN2@IsPetImmor

; 205  : 			{
; 206  : 				return true;

  009aa	b0 01		 mov	 al, 1
  009ac	eb 04		 jmp	 SHORT $LN7@IsPetImmor
$LN2@IsPetImmor:

; 207  : 			}
; 208  : 		}
; 209  : 	}

  009ae	eb b1		 jmp	 SHORT $LN4@IsPetImmor
$LN3@IsPetImmor:

; 210  : 
; 211  : 	return false;

  009b0	32 c0		 xor	 al, al
$LN7@IsPetImmor:

; 212  : }

  009b2	5f		 pop	 edi
  009b3	5e		 pop	 esi
  009b4	5b		 pop	 ebx
  009b5	8b e5		 mov	 esp, ebp
  009b7	5d		 pop	 ebp
  009b8	c2 04 00	 ret	 4
?IsPetImmortal@CPetEx@@QAE_NH@Z ENDP			; CPetEx::IsPetImmortal
_TEXT	ENDS
PUBLIC	?GetPetData@CPetEx@@QAEPAUPETEX_DATA@@H@Z	; CPetEx::GetPetData
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$227455 = -8						; size = 4
_this$ = -4						; size = 4
_ItemID$ = 8						; size = 4
?GetPetData@CPetEx@@QAEPAUPETEX_DATA@@H@Z PROC		; CPetEx::GetPetData
; _this$ = ecx

; 215  : {

  009c0	55		 push	 ebp
  009c1	8b ec		 mov	 ebp, esp
  009c3	83 ec 48	 sub	 esp, 72			; 00000048H
  009c6	53		 push	 ebx
  009c7	56		 push	 esi
  009c8	57		 push	 edi
  009c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 	if(!this->m_Enable)

  009cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009cf	83 38 00	 cmp	 DWORD PTR [eax], 0
  009d2	75 04		 jne	 SHORT $LN5@GetPetData

; 217  : 	{
; 218  : 		return false;

  009d4	33 c0		 xor	 eax, eax
  009d6	eb 52		 jmp	 SHORT $LN6@GetPetData
$LN5@GetPetData:

; 219  : 	}	
; 220  : 
; 221  : 	for(int i = 0; i < this->m_PetCount; i++)

  009d8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$227455[ebp], 0
  009df	eb 09		 jmp	 SHORT $LN4@GetPetData
$LN3@GetPetData:
  009e1	8b 45 f8	 mov	 eax, DWORD PTR _i$227455[ebp]
  009e4	83 c0 01	 add	 eax, 1
  009e7	89 45 f8	 mov	 DWORD PTR _i$227455[ebp], eax
$LN4@GetPetData:
  009ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009ed	8b 4d f8	 mov	 ecx, DWORD PTR _i$227455[ebp]
  009f0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  009f3	7d 33		 jge	 SHORT $LN2@GetPetData

; 222  : 	{
; 223  : 		if(ITEMGET(this->m_Data[i].ItemType, this->m_Data[i].ItemIndex) == ItemID)

  009f5	8b 45 f8	 mov	 eax, DWORD PTR _i$227455[ebp]
  009f8	6b c0 34	 imul	 eax, 52			; 00000034H
  009fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009fe	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00a02	c1 e2 09	 shl	 edx, 9
  00a05	8b 45 f8	 mov	 eax, DWORD PTR _i$227455[ebp]
  00a08	6b c0 34	 imul	 eax, 52			; 00000034H
  00a0b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a0e	03 54 01 14	 add	 edx, DWORD PTR [ecx+eax+20]
  00a12	3b 55 08	 cmp	 edx, DWORD PTR _ItemID$[ebp]
  00a15	75 0f		 jne	 SHORT $LN1@GetPetData

; 224  : 		{
; 225  : 			return &this->m_Data[i];

  00a17	8b 45 f8	 mov	 eax, DWORD PTR _i$227455[ebp]
  00a1a	6b c0 34	 imul	 eax, 52			; 00000034H
  00a1d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a20	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  00a24	eb 04		 jmp	 SHORT $LN6@GetPetData
$LN1@GetPetData:

; 226  : 		}
; 227  : 	}

  00a26	eb b9		 jmp	 SHORT $LN3@GetPetData
$LN2@GetPetData:

; 228  : 
; 229  : 	return NULL;

  00a28	33 c0		 xor	 eax, eax
$LN6@GetPetData:

; 230  : }

  00a2a	5f		 pop	 edi
  00a2b	5e		 pop	 esi
  00a2c	5b		 pop	 ebx
  00a2d	8b e5		 mov	 esp, ebp
  00a2f	5d		 pop	 ebp
  00a30	c2 04 00	 ret	 4
?GetPetData@CPetEx@@QAEPAUPETEX_DATA@@H@Z ENDP		; CPetEx::GetPetData
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?PetLife@CPetEx@@QAE_NH@Z			; CPetEx::PetLife
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv68 = -80						; size = 4
_Item$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?PetLife@CPetEx@@QAE_NH@Z PROC				; CPetEx::PetLife
; _this$ = ecx

; 233  : {

  00a40	55		 push	 ebp
  00a41	8b ec		 mov	 ebp, esp
  00a43	83 ec 50	 sub	 esp, 80			; 00000050H
  00a46	53		 push	 ebx
  00a47	56		 push	 esi
  00a48	57		 push	 edi
  00a49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 	if(!this->m_Enable)

  00a4c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a4f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00a52	75 07		 jne	 SHORT $LN5@PetLife

; 235  : 	{
; 236  : 		return false;

  00a54	32 c0		 xor	 al, al
  00a56	e9 ab 00 00 00	 jmp	 $LN6@PetLife
$LN5@PetLife:

; 237  : 	}	
; 238  : 
; 239  : 	if(!OBJMAX_RANGE(aIndex))

  00a5b	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00a5f	7d 09		 jge	 SHORT $LN8@PetLife
  00a61	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00a68	eb 0f		 jmp	 SHORT $LN9@PetLife
$LN8@PetLife:
  00a6a	33 c0		 xor	 eax, eax
  00a6c	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00a73	0f 9e c0	 setle	 al
  00a76	89 45 b0	 mov	 DWORD PTR tv68[ebp], eax
$LN9@PetLife:
  00a79	83 7d b0 00	 cmp	 DWORD PTR tv68[ebp], 0
  00a7d	75 07		 jne	 SHORT $LN4@PetLife

; 240  : 	{
; 241  : 		return false;

  00a7f	32 c0		 xor	 al, al
  00a81	e9 80 00 00 00	 jmp	 $LN6@PetLife
$LN4@PetLife:

; 242  : 	}
; 243  : 
; 244  : 	LPOBJ lpObj = &gObj[aIndex];

  00a86	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a89	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a8f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a95	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 245  : 
; 246  : 	if(lpObj->Type != OBJ_USER)

  00a98	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a9b	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  00a9f	83 f9 01	 cmp	 ecx, 1
  00aa2	74 04		 je	 SHORT $LN3@PetLife

; 247  : 	{
; 248  : 		return false;

  00aa4	32 c0		 xor	 al, al
  00aa6	eb 5e		 jmp	 SHORT $LN6@PetLife
$LN3@PetLife:

; 249  : 	}
; 250  : 
; 251  : 	if(!lpObj->pInventory[8].IsItem())

  00aa8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aab	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00ab1	81 c1 a0 06 00
	00		 add	 ecx, 1696		; 000006a0H
  00ab7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00abc	85 c0		 test	 eax, eax
  00abe	75 04		 jne	 SHORT $LN2@PetLife

; 252  : 	{
; 253  : 		return false;

  00ac0	32 c0		 xor	 al, al
  00ac2	eb 42		 jmp	 SHORT $LN6@PetLife
$LN2@PetLife:

; 254  : 	}
; 255  : 
; 256  : 	CItem * Item = &lpObj->pInventory[8];

  00ac4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac7	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00acd	81 c1 a0 06 00
	00		 add	 ecx, 1696		; 000006a0H
  00ad3	89 4d f4	 mov	 DWORD PTR _Item$[ebp], ecx

; 257  : 
; 258  : 	if(this->IsPet(Item->m_Type) && Item->m_Durability > 0.0f)

  00ad6	8b 45 f4	 mov	 eax, DWORD PTR _Item$[ebp]
  00ad9	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00add	51		 push	 ecx
  00ade	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae1	e8 00 00 00 00	 call	 ?IsPet@CPetEx@@QAE_NH@Z	; CPetEx::IsPet
  00ae6	0f b6 d0	 movzx	 edx, al
  00ae9	85 d2		 test	 edx, edx
  00aeb	74 17		 je	 SHORT $LN1@PetLife
  00aed	8b 45 f4	 mov	 eax, DWORD PTR _Item$[ebp]
  00af0	d9 40 24	 fld	 DWORD PTR [eax+36]
  00af3	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00af9	df e0		 fnstsw	 ax
  00afb	f6 c4 41	 test	 ah, 65			; 00000041H
  00afe	75 04		 jne	 SHORT $LN1@PetLife

; 259  : 	{
; 260  : 		return true;

  00b00	b0 01		 mov	 al, 1
  00b02	eb 02		 jmp	 SHORT $LN6@PetLife
$LN1@PetLife:

; 261  : 	}
; 262  : 
; 263  : 	return false;

  00b04	32 c0		 xor	 al, al
$LN6@PetLife:

; 264  : }

  00b06	5f		 pop	 edi
  00b07	5e		 pop	 esi
  00b08	5b		 pop	 ebx
  00b09	8b e5		 mov	 esp, ebp
  00b0b	5d		 pop	 ebp
  00b0c	c2 04 00	 ret	 4
?PetLife@CPetEx@@QAE_NH@Z ENDP				; CPetEx::PetLife
_TEXT	ENDS
PUBLIC	?Calc@CPetEx@@QAEXH@Z				; CPetEx::Calc
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv90 = -84						; size = 4
tv68 = -84						; size = 4
_i$227481 = -16						; size = 4
_pPetData$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?Calc@CPetEx@@QAEXH@Z PROC				; CPetEx::Calc
; _this$ = ecx

; 267  : {

  00b10	55		 push	 ebp
  00b11	8b ec		 mov	 ebp, esp
  00b13	83 ec 54	 sub	 esp, 84			; 00000054H
  00b16	53		 push	 ebx
  00b17	56		 push	 esi
  00b18	57		 push	 edi
  00b19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 268  : 	if(!this->m_Enable)

  00b1c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b1f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b22	75 05		 jne	 SHORT $LN20@Calc

; 269  : 	{
; 270  : 		return;

  00b24	e9 96 02 00 00	 jmp	 $LN21@Calc
$LN20@Calc:

; 271  : 	}	
; 272  : 
; 273  : 	if(!OBJMAX_RANGE(aIndex))

  00b29	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00b2d	7d 09		 jge	 SHORT $LN23@Calc
  00b2f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00b36	eb 0f		 jmp	 SHORT $LN24@Calc
$LN23@Calc:
  00b38	33 c0		 xor	 eax, eax
  00b3a	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00b41	0f 9e c0	 setle	 al
  00b44	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN24@Calc:
  00b47	83 7d ac 00	 cmp	 DWORD PTR tv68[ebp], 0
  00b4b	75 05		 jne	 SHORT $LN19@Calc

; 274  : 	{
; 275  : 		return;

  00b4d	e9 6d 02 00 00	 jmp	 $LN21@Calc
$LN19@Calc:

; 276  : 	}
; 277  : 
; 278  : 	if(!this->PetLife(aIndex))

  00b52	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b55	50		 push	 eax
  00b56	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b59	e8 00 00 00 00	 call	 ?PetLife@CPetEx@@QAE_NH@Z ; CPetEx::PetLife
  00b5e	0f b6 c8	 movzx	 ecx, al
  00b61	85 c9		 test	 ecx, ecx
  00b63	75 05		 jne	 SHORT $LN18@Calc

; 279  : 	{
; 280  : 		return;

  00b65	e9 55 02 00 00	 jmp	 $LN21@Calc
$LN18@Calc:

; 281  : 	}
; 282  : 
; 283  : 	LPOBJ lpObj = &gObj[aIndex];

  00b6a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b6d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b73	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b79	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 284  : 
; 285  : 	PETEX_DATA* pPetData = this->GetPetData(lpObj->pInventory[8].m_Type);

  00b7c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b7f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00b85	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00b8c	52		 push	 edx
  00b8d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b90	e8 00 00 00 00	 call	 ?GetPetData@CPetEx@@QAEPAUPETEX_DATA@@H@Z ; CPetEx::GetPetData
  00b95	89 45 f4	 mov	 DWORD PTR _pPetData$[ebp], eax

; 286  : 
; 287  : 	if(!pPetData)

  00b98	83 7d f4 00	 cmp	 DWORD PTR _pPetData$[ebp], 0
  00b9c	75 05		 jne	 SHORT $LN17@Calc

; 288  : 	{
; 289  : 		return;

  00b9e	e9 1c 02 00 00	 jmp	 $LN21@Calc
$LN17@Calc:

; 290  : 	}
; 291  : 
; 292  : 	for(int i = 0; i < MAX_PETEX_OPTION; i++)

  00ba3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$227481[ebp], 0
  00baa	eb 09		 jmp	 SHORT $LN16@Calc
$LN15@Calc:
  00bac	8b 45 f0	 mov	 eax, DWORD PTR _i$227481[ebp]
  00baf	83 c0 01	 add	 eax, 1
  00bb2	89 45 f0	 mov	 DWORD PTR _i$227481[ebp], eax
$LN16@Calc:
  00bb5	83 7d f0 05	 cmp	 DWORD PTR _i$227481[ebp], 5
  00bb9	0f 8d 00 02 00
	00		 jge	 $LN21@Calc

; 293  : 	{
; 294  : 		switch(pPetData->Option[i].Type)

  00bbf	8b 45 f0	 mov	 eax, DWORD PTR _i$227481[ebp]
  00bc2	8b 4d f4	 mov	 ecx, DWORD PTR _pPetData$[ebp]
  00bc5	8b 54 c1 0c	 mov	 edx, DWORD PTR [ecx+eax*8+12]
  00bc9	89 55 ac	 mov	 DWORD PTR tv90[ebp], edx
  00bcc	8b 45 ac	 mov	 eax, DWORD PTR tv90[ebp]
  00bcf	83 e8 01	 sub	 eax, 1
  00bd2	89 45 ac	 mov	 DWORD PTR tv90[ebp], eax
  00bd5	83 7d ac 0a	 cmp	 DWORD PTR tv90[ebp], 10	; 0000000aH
  00bd9	0f 87 db 01 00
	00		 ja	 $LN12@Calc
  00bdf	8b 4d ac	 mov	 ecx, DWORD PTR tv90[ebp]
  00be2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN25@Calc[ecx*4]
$LN11@Calc:

; 295  : 		{
; 296  : 		case ePET_DAMAGE:
; 297  : 			lpObj->m_AttackDamageMinRight += pPetData->Option[i].Value;

  00be9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bec	8b 88 84 04 00
	00		 mov	 ecx, DWORD PTR [eax+1156]
  00bf2	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00bf5	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00bf8	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00bfc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bff	89 8a 84 04 00
	00		 mov	 DWORD PTR [edx+1156], ecx

; 298  : 			lpObj->m_AttackDamageMaxRight += pPetData->Option[i].Value;

  00c05	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c08	8b 88 80 04 00
	00		 mov	 ecx, DWORD PTR [eax+1152]
  00c0e	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00c11	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00c14	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00c18	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c1b	89 8a 80 04 00
	00		 mov	 DWORD PTR [edx+1152], ecx

; 299  : 			lpObj->m_AttackDamageMinLeft += pPetData->Option[i].Value;

  00c21	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c24	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  00c2a	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00c2d	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00c30	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00c34	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c37	89 8a 7c 04 00
	00		 mov	 DWORD PTR [edx+1148], ecx

; 300  : 			lpObj->m_AttackDamageMaxLeft += pPetData->Option[i].Value;

  00c3d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c40	8b 88 78 04 00
	00		 mov	 ecx, DWORD PTR [eax+1144]
  00c46	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00c49	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00c4c	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00c50	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c53	89 8a 78 04 00
	00		 mov	 DWORD PTR [edx+1144], ecx

; 301  : 			break;

  00c59	e9 5c 01 00 00	 jmp	 $LN12@Calc
$LN10@Calc:

; 302  : 		case ePET_DEFENCE:
; 303  : 			lpObj->m_Defense += pPetData->Option[i].Value;

  00c5e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c61	8b 88 94 04 00
	00		 mov	 ecx, DWORD PTR [eax+1172]
  00c67	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00c6a	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00c6d	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00c71	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c74	89 8a 94 04 00
	00		 mov	 DWORD PTR [edx+1172], ecx

; 304  : 			break;

  00c7a	e9 3b 01 00 00	 jmp	 $LN12@Calc
$LN9@Calc:

; 305  : 		case ePET_IGNOREDEFENCE:
; 306  : 			lpObj->SetOpIgnoreDefense += pPetData->Option[i].Value;

  00c7f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c82	0f b6 88 3e 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4414]
  00c89	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00c8c	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00c8f	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00c93	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c96	88 8a 3e 11 00
	00		 mov	 BYTE PTR [edx+4414], cl

; 307  : 			break;

  00c9c	e9 19 01 00 00	 jmp	 $LN12@Calc
$LN8@Calc:

; 308  : 		case ePET_CRITICALDAMAGE:
; 309  : 			lpObj->m_CriticalDamage += pPetData->Option[i].Value;

  00ca1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ca4	8b 88 bc 04 00
	00		 mov	 ecx, DWORD PTR [eax+1212]
  00caa	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00cad	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00cb0	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00cb4	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cb7	89 8a bc 04 00
	00		 mov	 DWORD PTR [edx+1212], ecx

; 310  : 			break;

  00cbd	e9 f8 00 00 00	 jmp	 $LN12@Calc
$LN7@Calc:

; 311  : 		case ePET_EXELLENTDAMAGEe:
; 312  : 			lpObj->m_ExcelentDamage += pPetData->Option[i].Value;

  00cc2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cc5	8b 88 c0 04 00
	00		 mov	 ecx, DWORD PTR [eax+1216]
  00ccb	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00cce	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00cd1	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00cd5	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cd8	89 8a c0 04 00
	00		 mov	 DWORD PTR [edx+1216], ecx

; 313  : 			break;

  00cde	e9 d7 00 00 00	 jmp	 $LN12@Calc
$LN6@Calc:

; 314  : 		case ePET_DOUBLEDAMAGE:
; 315  : 			lpObj->SetOpDoubleDamage += pPetData->Option[i].Value;

  00ce3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ce6	0f b6 88 3f 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4415]
  00ced	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00cf0	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00cf3	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00cf7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cfa	88 8a 3f 11 00
	00		 mov	 BYTE PTR [edx+4415], cl

; 316  : 			break;

  00d00	e9 b5 00 00 00	 jmp	 $LN12@Calc
$LN5@Calc:

; 317  : 		case ePET_DECRISEDAMAGE:
; 318  : 			lpObj->DamageMinus += pPetData->Option[i].Value;

  00d05	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d08	0f b6 88 70 01
	00 00		 movzx	 ecx, BYTE PTR [eax+368]
  00d0f	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00d12	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00d15	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00d19	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d1c	88 8a 70 01 00
	00		 mov	 BYTE PTR [edx+368], cl

; 319  : 			break;

  00d22	e9 93 00 00 00	 jmp	 $LN12@Calc
$LN4@Calc:

; 320  : 		case ePET_REFLECTDAMAGE:
; 321  : 			lpObj->DamageReflect += pPetData->Option[i].Value;

  00d27	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d2a	0f b6 88 71 01
	00 00		 movzx	 ecx, BYTE PTR [eax+369]
  00d31	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00d34	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00d37	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00d3b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d3e	88 8a 71 01 00
	00		 mov	 BYTE PTR [edx+369], cl

; 322  : 			break;

  00d44	eb 74		 jmp	 SHORT $LN12@Calc
$LN3@Calc:

; 323  : 		case ePET_SD:
; 324  : 			lpObj->iAddShield += pPetData->Option[i].Value;

  00d46	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d49	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  00d4f	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00d52	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00d55	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00d59	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d5c	89 8a 5c 01 00
	00		 mov	 DWORD PTR [edx+348], ecx

; 325  : 			break;

  00d62	eb 56		 jmp	 SHORT $LN12@Calc
$LN2@Calc:

; 326  : 		case ePET_LIFE:
; 327  : 			lpObj->AddLife += pPetData->Option[i].Value;

  00d64	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d67	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR [eax+332]
  00d6d	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00d70	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00d73	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00d77	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d7a	89 8a 4c 01 00
	00		 mov	 DWORD PTR [edx+332], ecx

; 328  : 			break;

  00d80	eb 38		 jmp	 SHORT $LN12@Calc
$LN1@Calc:

; 329  : 		case ePET_MAGICDAMAGE:
; 330  : 			lpObj->m_MagicDamageMin += pPetData->Option[i].Value;

  00d82	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d85	8b 88 68 04 00
	00		 mov	 ecx, DWORD PTR [eax+1128]
  00d8b	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00d8e	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00d91	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00d95	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d98	89 8a 68 04 00
	00		 mov	 DWORD PTR [edx+1128], ecx

; 331  : 			lpObj->m_MagicDamageMax += pPetData->Option[i].Value;

  00d9e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00da1	8b 88 6c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1132]
  00da7	8b 55 f0	 mov	 edx, DWORD PTR _i$227481[ebp]
  00daa	8b 45 f4	 mov	 eax, DWORD PTR _pPetData$[ebp]
  00dad	03 4c d0 10	 add	 ecx, DWORD PTR [eax+edx*8+16]
  00db1	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00db4	89 8a 6c 04 00
	00		 mov	 DWORD PTR [edx+1132], ecx
$LN12@Calc:

; 332  : 			break;
; 333  : 		}
; 334  : 	}

  00dba	e9 ed fd ff ff	 jmp	 $LN15@Calc
$LN21@Calc:

; 335  : }

  00dbf	5f		 pop	 edi
  00dc0	5e		 pop	 esi
  00dc1	5b		 pop	 ebx
  00dc2	8b e5		 mov	 esp, ebp
  00dc4	5d		 pop	 ebp
  00dc5	c2 04 00	 ret	 4
$LN25@Calc:
  00dc8	00 00 00 00	 DD	 $LN11@Calc
  00dcc	00 00 00 00	 DD	 $LN10@Calc
  00dd0	00 00 00 00	 DD	 $LN9@Calc
  00dd4	00 00 00 00	 DD	 $LN8@Calc
  00dd8	00 00 00 00	 DD	 $LN7@Calc
  00ddc	00 00 00 00	 DD	 $LN6@Calc
  00de0	00 00 00 00	 DD	 $LN5@Calc
  00de4	00 00 00 00	 DD	 $LN4@Calc
  00de8	00 00 00 00	 DD	 $LN3@Calc
  00dec	00 00 00 00	 DD	 $LN2@Calc
  00df0	00 00 00 00	 DD	 $LN1@Calc
?Calc@CPetEx@@QAEXH@Z ENDP				; CPetEx::Calc
_TEXT	ENDS
PUBLIC	?Exp@CPetEx@@QAEXHAA_J@Z			; CPetEx::Exp
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv90 = -84						; size = 4
tv68 = -84						; size = 4
_i$227511 = -16						; size = 4
_pPetData$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_exp$ = 12						; size = 4
?Exp@CPetEx@@QAEXHAA_J@Z PROC				; CPetEx::Exp
; _this$ = ecx

; 338  : {

  00e00	55		 push	 ebp
  00e01	8b ec		 mov	 ebp, esp
  00e03	83 ec 54	 sub	 esp, 84			; 00000054H
  00e06	53		 push	 ebx
  00e07	56		 push	 esi
  00e08	57		 push	 edi
  00e09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 339  : 	if(!this->m_Enable)

  00e0c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e0f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00e12	75 05		 jne	 SHORT $LN10@Exp

; 340  : 	{
; 341  : 		return;

  00e14	e9 dd 00 00 00	 jmp	 $LN11@Exp
$LN10@Exp:

; 342  : 	}	
; 343  : 
; 344  : 	if(!OBJMAX_RANGE(aIndex))

  00e19	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00e1d	7d 09		 jge	 SHORT $LN13@Exp
  00e1f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00e26	eb 0f		 jmp	 SHORT $LN14@Exp
$LN13@Exp:
  00e28	33 c0		 xor	 eax, eax
  00e2a	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00e31	0f 9e c0	 setle	 al
  00e34	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN14@Exp:
  00e37	83 7d ac 00	 cmp	 DWORD PTR tv68[ebp], 0
  00e3b	75 05		 jne	 SHORT $LN9@Exp

; 345  : 	{
; 346  : 		return;

  00e3d	e9 b4 00 00 00	 jmp	 $LN11@Exp
$LN9@Exp:

; 347  : 	}
; 348  : 
; 349  : 	if(!this->PetLife(aIndex))

  00e42	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00e45	50		 push	 eax
  00e46	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e49	e8 00 00 00 00	 call	 ?PetLife@CPetEx@@QAE_NH@Z ; CPetEx::PetLife
  00e4e	0f b6 c8	 movzx	 ecx, al
  00e51	85 c9		 test	 ecx, ecx
  00e53	75 05		 jne	 SHORT $LN8@Exp

; 350  : 	{
; 351  : 		return;

  00e55	e9 9c 00 00 00	 jmp	 $LN11@Exp
$LN8@Exp:

; 352  : 	}
; 353  : 
; 354  : 	LPOBJ lpObj = &gObj[aIndex];

  00e5a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00e5d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00e63	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e69	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 355  : 
; 356  : 	PETEX_DATA* pPetData = this->GetPetData(lpObj->pInventory[8].m_Type);

  00e6c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e6f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e75	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00e7c	52		 push	 edx
  00e7d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e80	e8 00 00 00 00	 call	 ?GetPetData@CPetEx@@QAEPAUPETEX_DATA@@H@Z ; CPetEx::GetPetData
  00e85	89 45 f4	 mov	 DWORD PTR _pPetData$[ebp], eax

; 357  : 
; 358  : 	if(!pPetData)

  00e88	83 7d f4 00	 cmp	 DWORD PTR _pPetData$[ebp], 0
  00e8c	75 02		 jne	 SHORT $LN7@Exp

; 359  : 	{
; 360  : 		return;

  00e8e	eb 66		 jmp	 SHORT $LN11@Exp
$LN7@Exp:

; 361  : 	}
; 362  : 
; 363  : 	for(int i = 0; i < MAX_PETEX_OPTION; i++)

  00e90	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$227511[ebp], 0
  00e97	eb 09		 jmp	 SHORT $LN6@Exp
$LN5@Exp:
  00e99	8b 45 f0	 mov	 eax, DWORD PTR _i$227511[ebp]
  00e9c	83 c0 01	 add	 eax, 1
  00e9f	89 45 f0	 mov	 DWORD PTR _i$227511[ebp], eax
$LN6@Exp:
  00ea2	83 7d f0 05	 cmp	 DWORD PTR _i$227511[ebp], 5
  00ea6	7d 4e		 jge	 SHORT $LN11@Exp

; 364  : 	{
; 365  : 		switch(pPetData->Option[i].Type)

  00ea8	8b 45 f0	 mov	 eax, DWORD PTR _i$227511[ebp]
  00eab	8b 4d f4	 mov	 ecx, DWORD PTR _pPetData$[ebp]
  00eae	8b 54 c1 0c	 mov	 edx, DWORD PTR [ecx+eax*8+12]
  00eb2	89 55 ac	 mov	 DWORD PTR tv90[ebp], edx
  00eb5	83 7d ac 0c	 cmp	 DWORD PTR tv90[ebp], 12	; 0000000cH
  00eb9	74 02		 je	 SHORT $LN1@Exp
  00ebb	eb 37		 jmp	 SHORT $LN2@Exp
$LN1@Exp:

; 366  : 		{
; 367  : 		case ePET_EXPERIENCE:
; 368  : 			exp += ( exp * pPetData->Option[i].Value ) / 100;

  00ebd	8b 45 f0	 mov	 eax, DWORD PTR _i$227511[ebp]
  00ec0	8b 4d f4	 mov	 ecx, DWORD PTR _pPetData$[ebp]
  00ec3	8b 44 c1 10	 mov	 eax, DWORD PTR [ecx+eax*8+16]
  00ec7	99		 cdq
  00ec8	8b 4d 0c	 mov	 ecx, DWORD PTR _exp$[ebp]
  00ecb	52		 push	 edx
  00ecc	50		 push	 eax
  00ecd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00ed0	52		 push	 edx
  00ed1	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ed3	50		 push	 eax
  00ed4	e8 00 00 00 00	 call	 __allmul
  00ed9	6a 00		 push	 0
  00edb	6a 64		 push	 100			; 00000064H
  00edd	52		 push	 edx
  00ede	50		 push	 eax
  00edf	e8 00 00 00 00	 call	 __alldiv
  00ee4	8b 4d 0c	 mov	 ecx, DWORD PTR _exp$[ebp]
  00ee7	03 01		 add	 eax, DWORD PTR [ecx]
  00ee9	13 51 04	 adc	 edx, DWORD PTR [ecx+4]
  00eec	8b 4d 0c	 mov	 ecx, DWORD PTR _exp$[ebp]
  00eef	89 01		 mov	 DWORD PTR [ecx], eax
  00ef1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Exp:

; 369  : 			break;
; 370  : 		}
; 371  : 	}

  00ef4	eb a3		 jmp	 SHORT $LN5@Exp
$LN11@Exp:

; 372  : }

  00ef6	5f		 pop	 edi
  00ef7	5e		 pop	 esi
  00ef8	5b		 pop	 ebx
  00ef9	8b e5		 mov	 esp, ebp
  00efb	5d		 pop	 ebp
  00efc	c2 08 00	 ret	 8
?Exp@CPetEx@@QAEXHAA_J@Z ENDP				; CPetEx::Exp
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	?Zen@CPetEx@@QAEXHAAM@Z				; CPetEx::Zen
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv90 = -84						; size = 4
tv68 = -84						; size = 4
_i$227531 = -16						; size = 4
_pPetData$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?Zen@CPetEx@@QAEXHAAM@Z PROC				; CPetEx::Zen
; _this$ = ecx

; 375  : {

  00f00	55		 push	 ebp
  00f01	8b ec		 mov	 ebp, esp
  00f03	83 ec 54	 sub	 esp, 84			; 00000054H
  00f06	53		 push	 ebx
  00f07	56		 push	 esi
  00f08	57		 push	 edi
  00f09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 	if(!this->m_Enable)

  00f0c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f0f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00f12	75 05		 jne	 SHORT $LN10@Zen

; 377  : 	{
; 378  : 		return;

  00f14	e9 c5 00 00 00	 jmp	 $LN11@Zen
$LN10@Zen:

; 379  : 	}	
; 380  : 
; 381  : 	if(!OBJMAX_RANGE(aIndex))

  00f19	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00f1d	7d 09		 jge	 SHORT $LN13@Zen
  00f1f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00f26	eb 0f		 jmp	 SHORT $LN14@Zen
$LN13@Zen:
  00f28	33 c0		 xor	 eax, eax
  00f2a	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00f31	0f 9e c0	 setle	 al
  00f34	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN14@Zen:
  00f37	83 7d ac 00	 cmp	 DWORD PTR tv68[ebp], 0
  00f3b	75 05		 jne	 SHORT $LN9@Zen

; 382  : 	{
; 383  : 		return;

  00f3d	e9 9c 00 00 00	 jmp	 $LN11@Zen
$LN9@Zen:

; 384  : 	}
; 385  : 
; 386  : 	if(!this->PetLife(aIndex))

  00f42	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00f45	50		 push	 eax
  00f46	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f49	e8 00 00 00 00	 call	 ?PetLife@CPetEx@@QAE_NH@Z ; CPetEx::PetLife
  00f4e	0f b6 c8	 movzx	 ecx, al
  00f51	85 c9		 test	 ecx, ecx
  00f53	75 05		 jne	 SHORT $LN8@Zen

; 387  : 	{
; 388  : 		return;

  00f55	e9 84 00 00 00	 jmp	 $LN11@Zen
$LN8@Zen:

; 389  : 	}
; 390  : 
; 391  : 	LPOBJ lpObj = &gObj[aIndex];

  00f5a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00f5d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00f63	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f69	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 392  : 
; 393  : 	PETEX_DATA* pPetData = this->GetPetData(lpObj->pInventory[8].m_Type);

  00f6c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f6f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f75	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00f7c	52		 push	 edx
  00f7d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f80	e8 00 00 00 00	 call	 ?GetPetData@CPetEx@@QAEPAUPETEX_DATA@@H@Z ; CPetEx::GetPetData
  00f85	89 45 f4	 mov	 DWORD PTR _pPetData$[ebp], eax

; 394  : 
; 395  : 	if(!pPetData)

  00f88	83 7d f4 00	 cmp	 DWORD PTR _pPetData$[ebp], 0
  00f8c	75 02		 jne	 SHORT $LN7@Zen

; 396  : 	{
; 397  : 		return;

  00f8e	eb 4e		 jmp	 SHORT $LN11@Zen
$LN7@Zen:

; 398  : 	}
; 399  : 
; 400  : 	for(int i = 0; i < MAX_PETEX_OPTION; i++)

  00f90	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$227531[ebp], 0
  00f97	eb 09		 jmp	 SHORT $LN6@Zen
$LN5@Zen:
  00f99	8b 45 f0	 mov	 eax, DWORD PTR _i$227531[ebp]
  00f9c	83 c0 01	 add	 eax, 1
  00f9f	89 45 f0	 mov	 DWORD PTR _i$227531[ebp], eax
$LN6@Zen:
  00fa2	83 7d f0 05	 cmp	 DWORD PTR _i$227531[ebp], 5
  00fa6	7d 36		 jge	 SHORT $LN4@Zen

; 401  : 	{
; 402  : 		switch(pPetData->Option[i].Type)

  00fa8	8b 45 f0	 mov	 eax, DWORD PTR _i$227531[ebp]
  00fab	8b 4d f4	 mov	 ecx, DWORD PTR _pPetData$[ebp]
  00fae	8b 54 c1 0c	 mov	 edx, DWORD PTR [ecx+eax*8+12]
  00fb2	89 55 ac	 mov	 DWORD PTR tv90[ebp], edx
  00fb5	83 7d ac 0d	 cmp	 DWORD PTR tv90[ebp], 13	; 0000000dH
  00fb9	74 02		 je	 SHORT $LN1@Zen
  00fbb	eb 1f		 jmp	 SHORT $LN2@Zen
$LN1@Zen:

; 403  : 		{
; 404  : 		case ePET_ZENMONEY:
; 405  : 			money += ( money * pPetData->Option[i].Value ) / 100;

  00fbd	8b 45 f0	 mov	 eax, DWORD PTR _i$227531[ebp]
  00fc0	8b 4d f4	 mov	 ecx, DWORD PTR _pPetData$[ebp]
  00fc3	db 44 c1 10	 fild	 DWORD PTR [ecx+eax*8+16]
  00fc7	8b 55 0c	 mov	 edx, DWORD PTR _money$[ebp]
  00fca	d8 0a		 fmul	 DWORD PTR [edx]
  00fcc	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00fd2	8b 45 0c	 mov	 eax, DWORD PTR _money$[ebp]
  00fd5	d8 00		 fadd	 DWORD PTR [eax]
  00fd7	8b 4d 0c	 mov	 ecx, DWORD PTR _money$[ebp]
  00fda	d9 19		 fstp	 DWORD PTR [ecx]
$LN2@Zen:

; 406  : 			break;
; 407  : 		}
; 408  : 	}

  00fdc	eb bb		 jmp	 SHORT $LN5@Zen
$LN4@Zen:
$LN11@Zen:

; 409  : }

  00fde	5f		 pop	 edi
  00fdf	5e		 pop	 esi
  00fe0	5b		 pop	 ebx
  00fe1	8b e5		 mov	 esp, ebp
  00fe3	5d		 pop	 ebp
  00fe4	c2 08 00	 ret	 8
?Zen@CPetEx@@QAEXHAAM@Z ENDP				; CPetEx::Zen
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Eg_PetEx@@YAXXZ
text$yc	SEGMENT
??__Eg_PetEx@@YAXXZ PROC				; `dynamic initializer for 'g_PetEx'', COMDAT

; 10   : CPetEx g_PetEx;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PetEx@@3VCPetEx@@A ; g_PetEx
  0000e	e8 00 00 00 00	 call	 ??0CPetEx@@QAE@XZ	; CPetEx::CPetEx
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_PetEx@@YAXXZ ; `dynamic atexit destructor for 'g_PetEx''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_PetEx@@YAXXZ ENDP				; `dynamic initializer for 'g_PetEx''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_PetEx@@YAXXZ
text$yd	SEGMENT
??__Fg_PetEx@@YAXXZ PROC				; `dynamic atexit destructor for 'g_PetEx'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PetEx@@3VCPetEx@@A ; g_PetEx
  0000e	e8 00 00 00 00	 call	 ??1CPetEx@@QAE@XZ	; CPetEx::~CPetEx
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_PetEx@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_PetEx''
text$yd	ENDS
PUBLIC	?g_PetEx@@3VCPetEx@@A				; g_PetEx
_BSS	SEGMENT
?g_PetEx@@3VCPetEx@@A DB 0190cH DUP (?)			; g_PetEx
_BSS	ENDS
CRT$XCU	SEGMENT
_g_PetEx$initializer$ DD FLAT:??__Eg_PetEx@@YAXXZ
CRT$XCU	ENDS
END
