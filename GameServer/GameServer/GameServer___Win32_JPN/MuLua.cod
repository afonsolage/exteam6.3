; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MuLua.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_sentinel_ DD	00H
CONST	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Create@MULua@@AAE_NXZ				; MULua::Create
PUBLIC	??0MULua@@QAE@XZ				; MULua::MULua
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mulua.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MULua@@QAE@XZ PROC					; MULua::MULua
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 20   : 	Create();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Create@MULua@@AAE_NXZ	; MULua::Create

; 21   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0MULua@@QAE@XZ ENDP					; MULua::MULua
_TEXT	ENDS
PUBLIC	?Release@MULua@@QAEXXZ				; MULua::Release
PUBLIC	??1MULua@@QAE@XZ				; MULua::~MULua
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MULua@@QAE@XZ PROC					; MULua::~MULua
; _this$ = ecx

; 25   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 	Release();

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Release@MULua@@QAEXXZ	; MULua::Release

; 27   : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??1MULua@@QAE@XZ ENDP					; MULua::~MULua
_TEXT	ENDS
PUBLIC	??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	?DoFile@MULua@@QAE_NPBD@Z			; MULua::DoFile
EXTRN	_lua_pcall:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_lua_tolstring:PROC
EXTRN	_luaL_loadfile:PROC
;	COMDAT ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ DB 'E'
	DB	'rror!!, : %s : State = %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ DB 'Error!!, : %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iState$ = -8						; size = 4
_this$ = -4						; size = 4
_szFileName$ = 8					; size = 4
?DoFile@MULua@@QAE_NPBD@Z PROC				; MULua::DoFile
; _this$ = ecx

; 30   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 48	 sub	 esp, 72			; 00000048H
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 31   : 	int iState = 0;

  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iState$[ebp], 0

; 32   : 
; 33   : 	if ( luaL_loadfile(m_luaState, szFileName) )

  00063	8b 45 08	 mov	 eax, DWORD PTR _szFileName$[ebp]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _luaL_loadfile
  00072	83 c4 08	 add	 esp, 8
  00075	85 c0		 test	 eax, eax
  00077	74 24		 je	 SHORT $LN2@DoFile

; 34   : 	{		
; 35   : 		MsgBox("Error!!, : %s\n", lua_tolstring(m_luaState, -1, 0) );

  00079	6a 00		 push	 0
  0007b	6a ff		 push	 -1
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _lua_tolstring
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	50		 push	 eax
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
  00091	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00096	83 c4 08	 add	 esp, 8

; 36   : 		return false;

  00099	32 c0		 xor	 al, al
  0009b	eb 47		 jmp	 SHORT $LN3@DoFile
$LN2@DoFile:

; 37   : 	}
; 38   : 
; 39   :     iState = lua_pcall(m_luaState, 0, -1, 0);

  0009d	6a 00		 push	 0
  0009f	6a ff		 push	 -1
  000a1	6a 00		 push	 0
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _lua_pcall
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
  000b1	89 45 f8	 mov	 DWORD PTR _iState$[ebp], eax

; 40   : 
; 41   : 	if ( iState )

  000b4	83 7d f8 00	 cmp	 DWORD PTR _iState$[ebp], 0
  000b8	74 28		 je	 SHORT $LN1@DoFile

; 42   : 	{
; 43   : 		MsgBox("Error!!, : %s : State = %d\n", lua_tolstring(m_luaState, -1, 0) , iState);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _iState$[ebp]
  000bd	50		 push	 eax
  000be	6a 00		 push	 0
  000c0	6a ff		 push	 -1
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 _lua_tolstring
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	50		 push	 eax
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
  000d6	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 		return false;

  000de	32 c0		 xor	 al, al
  000e0	eb 02		 jmp	 SHORT $LN3@DoFile
$LN1@DoFile:

; 45   : 	}
; 46   : 
; 47   : 	return true;	

  000e2	b0 01		 mov	 al, 1
$LN3@DoFile:

; 48   : }

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
?DoFile@MULua@@QAE_NPBD@Z ENDP				; MULua::DoFile
_TEXT	ENDS
PUBLIC	?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z		; MULua::DoFile
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_L$ = 8							; size = 4
_szFileName$ = 12					; size = 4
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z PROC		; MULua::DoFile
; _this$ = ecx

; 51   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	83 ec 44	 sub	 esp, 68			; 00000044H
  000f6	53		 push	 ebx
  000f7	56		 push	 esi
  000f8	57		 push	 edi
  000f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   : 	return true;

  000fc	b0 01		 mov	 al, 1

; 53   : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z ENDP		; MULua::DoFile
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MULua::DoString
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T227969 = -73						; size = 1
_this$ = -4						; size = 4
_kString$ = 8						; size = 28
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; MULua::DoString
; _this$ = ecx

; 56   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00116	53		 push	 ebx
  00117	56		 push	 esi
  00118	57		 push	 edi
  00119	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 57   : 	return true;

  0011c	c6 45 b7 01	 mov	 BYTE PTR $T227969[ebp], 1
  00120	8d 4d 08	 lea	 ecx, DWORD PTR _kString$[ebp]
  00123	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00128	8a 45 b7	 mov	 al, BYTE PTR $T227969[ebp]

; 58   : }

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 1c 00	 ret	 28			; 0000001cH
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; MULua::DoString
_TEXT	ENDS
PUBLIC	?GetLua@MULua@@QAEPAUlua_State@@XZ		; MULua::GetLua
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLua@MULua@@QAEPAUlua_State@@XZ PROC			; MULua::GetLua
; _this$ = ecx

; 61   : {

  00140	55		 push	 ebp
  00141	8b ec		 mov	 ebp, esp
  00143	83 ec 44	 sub	 esp, 68			; 00000044H
  00146	53		 push	 ebx
  00147	56		 push	 esi
  00148	57		 push	 edi
  00149	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 62   : 	return m_luaState;

  0014c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	8b 00		 mov	 eax, DWORD PTR [eax]

; 63   : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
?GetLua@MULua@@QAEPAUlua_State@@XZ ENDP			; MULua::GetLua
_TEXT	ENDS
PUBLIC	??_C@_09ENDOEBPC@murequire?$AA@			; `string'
PUBLIC	?MuRequire@@YAHPAUlua_State@@@Z			; MuRequire
EXTRN	_lua_gc:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_luaL_openlibs:PROC
EXTRN	_luaL_newstate:PROC
;	COMDAT ??_C@_09ENDOEBPC@murequire?$AA@
CONST	SEGMENT
??_C@_09ENDOEBPC@murequire?$AA@ DB 'murequire', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Create@MULua@@AAE_NXZ PROC				; MULua::Create
; _this$ = ecx

; 66   : {

  00160	55		 push	 ebp
  00161	8b ec		 mov	 ebp, esp
  00163	83 ec 44	 sub	 esp, 68			; 00000044H
  00166	53		 push	 ebx
  00167	56		 push	 esi
  00168	57		 push	 edi
  00169	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 	m_luaState = luaL_newstate();

  0016c	e8 00 00 00 00	 call	 _luaL_newstate
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	89 01		 mov	 DWORD PTR [ecx], eax

; 68   : 
; 69   : 	luaL_openlibs(m_luaState);

  00176	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00179	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 _luaL_openlibs
  00181	83 c4 04	 add	 esp, 4

; 70   : 	lua_pushcclosure(m_luaState, MuRequire, 0);

  00184	6a 00		 push	 0
  00186	68 00 00 00 00	 push	 OFFSET ?MuRequire@@YAHPAUlua_State@@@Z ; MuRequire
  0018b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00190	51		 push	 ecx
  00191	e8 00 00 00 00	 call	 _lua_pushcclosure
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH

; 71   : 	lua_setfield(m_luaState, LUA_GLOBALSINDEX, "murequire");

  00199	68 00 00 00 00	 push	 OFFSET ??_C@_09ENDOEBPC@murequire?$AA@
  0019e	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  001a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 _lua_setfield
  001ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 72   : 	lua_gc(m_luaState, LUA_GCCOLLECT, 0);

  001b1	6a 00		 push	 0
  001b3	6a 02		 push	 2
  001b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _lua_gc
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   : 
; 74   : 	return true;

  001c3	b0 01		 mov	 al, 1

; 75   : }

  001c5	5f		 pop	 edi
  001c6	5e		 pop	 esi
  001c7	5b		 pop	 ebx
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
?Create@MULua@@AAE_NXZ ENDP				; MULua::Create
_TEXT	ENDS
PUBLIC	?Register@MULua@@QAEXPAX@Z			; MULua::Register
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pLuaState$ = -8					; size = 4
_this$ = -4						; size = 4
_pLua$ = 8						; size = 4
?Register@MULua@@QAEXPAX@Z PROC				; MULua::Register
; _this$ = ecx

; 78   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	83 ec 48	 sub	 esp, 72			; 00000048H
  001d6	53		 push	 ebx
  001d7	56		 push	 esi
  001d8	57		 push	 edi
  001d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 	lua_State* pLuaState = (lua_State*)pLua;

  001dc	8b 45 08	 mov	 eax, DWORD PTR _pLua$[ebp]
  001df	89 45 f8	 mov	 DWORD PTR _pLuaState$[ebp], eax

; 80   : }

  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c2 04 00	 ret	 4
?Register@MULua@@QAEXPAX@Z ENDP				; MULua::Register
_TEXT	ENDS
EXTRN	_lua_close:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Release@MULua@@QAEXXZ PROC				; MULua::Release
; _this$ = ecx

; 83   : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	83 ec 44	 sub	 esp, 68			; 00000044H
  001f6	53		 push	 ebx
  001f7	56		 push	 esi
  001f8	57		 push	 edi
  001f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 	if(m_luaState)

  001fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ff	83 38 00	 cmp	 DWORD PTR [eax], 0
  00202	74 17		 je	 SHORT $LN2@Release

; 85   : 	{
; 86   : 		lua_close(m_luaState);

  00204	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00207	8b 08		 mov	 ecx, DWORD PTR [eax]
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 _lua_close
  0020f	83 c4 04	 add	 esp, 4

; 87   : 		m_luaState = NULL;

  00212	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00215	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN2@Release:

; 88   : 	}
; 89   : }

  0021b	5f		 pop	 edi
  0021c	5e		 pop	 esi
  0021d	5b		 pop	 ebx
  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c3		 ret	 0
?Release@MULua@@QAEXXZ ENDP				; MULua::Release
_TEXT	ENDS
PUBLIC	?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z	; MULua::CreateWinConsole
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	?StartConsole@CWinConsole@@SAPAUHWND__@@PAUHINSTANCE__@@PAUlua_State@@@Z:PROC ; CWinConsole::StartConsole
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_hWnd$ = -8						; size = 4
_this$ = -4						; size = 4
_hInstance$ = 8						; size = 4
?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z PROC	; MULua::CreateWinConsole
; _this$ = ecx

; 93   : {

  00230	55		 push	 ebp
  00231	8b ec		 mov	 ebp, esp
  00233	83 ec 48	 sub	 esp, 72			; 00000048H
  00236	53		 push	 ebx
  00237	56		 push	 esi
  00238	57		 push	 edi
  00239	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 	HWND hWnd = NULL;

  0023c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hWnd$[ebp], 0

; 95   : 
; 96   : 	hWnd = CWinConsole::StartConsole(hInstance, m_luaState);

  00243	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00246	8b 08		 mov	 ecx, DWORD PTR [eax]
  00248	51		 push	 ecx
  00249	8b 55 08	 mov	 edx, DWORD PTR _hInstance$[ebp]
  0024c	52		 push	 edx
  0024d	e8 00 00 00 00	 call	 ?StartConsole@CWinConsole@@SAPAUHWND__@@PAUHINSTANCE__@@PAUlua_State@@@Z ; CWinConsole::StartConsole
  00252	83 c4 08	 add	 esp, 8
  00255	89 45 f8	 mov	 DWORD PTR _hWnd$[ebp], eax

; 97   : 
; 98   : 	if ( hWnd )

  00258	83 7d f8 00	 cmp	 DWORD PTR _hWnd$[ebp], 0
  0025c	74 0c		 je	 SHORT $LN2@CreateWinC

; 99   : 		ShowWindow(hWnd, SW_HIDE);

  0025e	6a 00		 push	 0
  00260	8b 45 f8	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00263	50		 push	 eax
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN2@CreateWinC:

; 100  : 
; 101  : }

  0026a	5f		 pop	 edi
  0026b	5e		 pop	 esi
  0026c	5b		 pop	 ebx
  0026d	8b e5		 mov	 esp, ebp
  0026f	5d		 pop	 ebp
  00270	c2 04 00	 ret	 4
?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z ENDP	; MULua::CreateWinConsole
_TEXT	ENDS
PUBLIC	?DestroyWinConsole@MULua@@QAEXXZ		; MULua::DestroyWinConsole
EXTRN	?StopConsole@CWinConsole@@SAXXZ:PROC		; CWinConsole::StopConsole
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DestroyWinConsole@MULua@@QAEXXZ PROC			; MULua::DestroyWinConsole
; _this$ = ecx

; 105  : {

  00280	55		 push	 ebp
  00281	8b ec		 mov	 ebp, esp
  00283	83 ec 44	 sub	 esp, 68			; 00000044H
  00286	53		 push	 ebx
  00287	56		 push	 esi
  00288	57		 push	 edi
  00289	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	CWinConsole::StopConsole();

  0028c	e8 00 00 00 00	 call	 ?StopConsole@CWinConsole@@SAXXZ ; CWinConsole::StopConsole

; 107  : }

  00291	5f		 pop	 edi
  00292	5e		 pop	 esi
  00293	5b		 pop	 ebx
  00294	8b e5		 mov	 esp, ebp
  00296	5d		 pop	 ebp
  00297	c3		 ret	 0
?DestroyWinConsole@MULua@@QAEXXZ ENDP			; MULua::DestroyWinConsole
_TEXT	ENDS
PUBLIC	??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@ ; `string'
PUBLIC	??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@ ; `string'
PUBLIC	??_C@_07PINPBNPB@_LOADED?$AA@			; `string'
PUBLIC	??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_pushboolean:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_call:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_luaL_error:PROC
EXTRN	_lua_touserdata:PROC
EXTRN	_lua_toboolean:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_settop:PROC
EXTRN	_sprintf:PROC
EXTRN	_luaL_checklstring:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@
CONST	SEGMENT
??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@ DB 'error '
	DB	'loading module ''%s'' from file ''%s'':', 0aH, 09H, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@
CONST	SEGMENT
??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@ DB 'loop or pre'
	DB	'vious error loading module ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PINPBNPB@_LOADED?$AA@
CONST	SEGMENT
??_C@_07PINPBNPB@_LOADED?$AA@ DB '_LOADED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@ DB '..\Data\Lua\%s', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_name$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_L$ = 8							; size = 4
?MuRequire@@YAHPAUlua_State@@@Z PROC			; MuRequire

; 115  : {

  002a0	55		 push	 ebp
  002a1	8b ec		 mov	 ebp, esp
  002a3	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  002a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  002ae	33 c5		 xor	 eax, ebp
  002b0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  002b3	53		 push	 ebx
  002b4	56		 push	 esi
  002b5	57		 push	 edi

; 116  : 	//char *name = NULL;
; 117  : 	char name[MAX_PATH] = { 0 };

  002b6	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _name$[ebp], 0
  002bd	68 03 01 00 00	 push	 259			; 00000103H
  002c2	6a 00		 push	 0
  002c4	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp+1]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 _memset
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 118  : 	sprintf(name, "..\\Data\\Lua\\%s", (LPCSTR)luaL_checklstring(L, 1, 0));

  002d3	6a 00		 push	 0
  002d5	6a 01		 push	 1
  002d7	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 _luaL_checklstring
  002e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e3	50		 push	 eax
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@
  002e9	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  002ef	51		 push	 ecx
  002f0	e8 00 00 00 00	 call	 _sprintf
  002f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  : 	//name = gDirPath.GetNewPath((LPCSTR)luaL_checklstring(L, 1, 0) );
; 120  : 	lua_settop(L, 1);

  002f8	6a 01		 push	 1
  002fa	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 _lua_settop
  00303	83 c4 08	 add	 esp, 8

; 121  : 
; 122  : 	lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");

  00306	68 00 00 00 00	 push	 OFFSET ??_C@_07PINPBNPB@_LOADED?$AA@
  0030b	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  00310	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 _lua_getfield
  00319	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : 	lua_getfield(L, 2, name);

  0031c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00322	50		 push	 eax
  00323	6a 02		 push	 2
  00325	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00328	51		 push	 ecx
  00329	e8 00 00 00 00	 call	 _lua_getfield
  0032e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 
; 125  : 	if ( lua_toboolean(L, -1) )

  00331	6a ff		 push	 -1
  00333	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 _lua_toboolean
  0033c	83 c4 08	 add	 esp, 8
  0033f	85 c0		 test	 eax, eax
  00341	74 37		 je	 SHORT $LN5@MuRequire

; 126  : 	{
; 127  : 		if ( lua_touserdata(L, -1) == sentinel )

  00343	6a ff		 push	 -1
  00345	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00348	50		 push	 eax
  00349	e8 00 00 00 00	 call	 _lua_touserdata
  0034e	83 c4 08	 add	 esp, 8
  00351	3d 00 00 00 00	 cmp	 eax, OFFSET _sentinel_
  00356	75 18		 jne	 SHORT $LN4@MuRequire

; 128  : 			luaL_error(L, "loop or previous error loading module '%s'", name);

  00358	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0035e	50		 push	 eax
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@
  00364	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00367	51		 push	 ecx
  00368	e8 00 00 00 00	 call	 _luaL_error
  0036d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@MuRequire:

; 129  : 
; 130  : 		return 1;

  00370	b8 01 00 00 00	 mov	 eax, 1
  00375	e9 21 01 00 00	 jmp	 $LN6@MuRequire
$LN5@MuRequire:

; 131  : 	}
; 132  : 
; 133  : 
; 134  : 	if ( luaL_loadfile(L, name) )

  0037a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00380	50		 push	 eax
  00381	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00384	51		 push	 ecx
  00385	e8 00 00 00 00	 call	 _luaL_loadfile
  0038a	83 c4 08	 add	 esp, 8
  0038d	85 c0		 test	 eax, eax
  0038f	74 3a		 je	 SHORT $LN3@MuRequire

; 135  : 	{
; 136  : 		luaL_error(L, "error loading module '%s' from file '%s':\n\t%s", 
; 137  : 			lua_tolstring(L, 1, 0), name, lua_tolstring(L, -1, 0));

  00391	6a 00		 push	 0
  00393	6a ff		 push	 -1
  00395	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00398	50		 push	 eax
  00399	e8 00 00 00 00	 call	 _lua_tolstring
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a1	50		 push	 eax
  003a2	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  003a8	51		 push	 ecx
  003a9	6a 00		 push	 0
  003ab	6a 01		 push	 1
  003ad	8b 55 08	 mov	 edx, DWORD PTR _L$[ebp]
  003b0	52		 push	 edx
  003b1	e8 00 00 00 00	 call	 _lua_tolstring
  003b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b9	50		 push	 eax
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@
  003bf	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  003c2	50		 push	 eax
  003c3	e8 00 00 00 00	 call	 _luaL_error
  003c8	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@MuRequire:

; 138  : 	}
; 139  : 
; 140  : 	lua_pushlightuserdata(L, sentinel);

  003cb	68 00 00 00 00	 push	 OFFSET _sentinel_
  003d0	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 _lua_pushlightuserdata
  003d9	83 c4 08	 add	 esp, 8

; 141  : 	lua_setfield(L, 2, name);

  003dc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  003e2	50		 push	 eax
  003e3	6a 02		 push	 2
  003e5	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  003e8	51		 push	 ecx
  003e9	e8 00 00 00 00	 call	 _lua_setfield
  003ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 142  : 	lua_pushstring(L, name);

  003f1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  003f7	50		 push	 eax
  003f8	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  003fb	51		 push	 ecx
  003fc	e8 00 00 00 00	 call	 _lua_pushstring
  00401	83 c4 08	 add	 esp, 8

; 143  : 	lua_call(L, 1, 1);

  00404	6a 01		 push	 1
  00406	6a 01		 push	 1
  00408	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 _lua_call
  00411	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 
; 145  : 	if ( lua_type(L, -1) )

  00414	6a ff		 push	 -1
  00416	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 _lua_type
  0041f	83 c4 08	 add	 esp, 8
  00422	85 c0		 test	 eax, eax
  00424	74 15		 je	 SHORT $LN2@MuRequire

; 146  : 		lua_setfield(L, 2, name);

  00426	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0042c	50		 push	 eax
  0042d	6a 02		 push	 2
  0042f	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00432	51		 push	 ecx
  00433	e8 00 00 00 00	 call	 _lua_setfield
  00438	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@MuRequire:

; 147  : 
; 148  : 	lua_getfield(L, 2, name);

  0043b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00441	50		 push	 eax
  00442	6a 02		 push	 2
  00444	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00447	51		 push	 ecx
  00448	e8 00 00 00 00	 call	 _lua_getfield
  0044d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 
; 150  : 	if ( lua_touserdata(L, -1) == sentinel )

  00450	6a ff		 push	 -1
  00452	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00455	50		 push	 eax
  00456	e8 00 00 00 00	 call	 _lua_touserdata
  0045b	83 c4 08	 add	 esp, 8
  0045e	3d 00 00 00 00	 cmp	 eax, OFFSET _sentinel_
  00463	75 31		 jne	 SHORT $LN1@MuRequire

; 151  : 	{
; 152  : 		lua_pushboolean(L, 1);

  00465	6a 01		 push	 1
  00467	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  0046a	50		 push	 eax
  0046b	e8 00 00 00 00	 call	 _lua_pushboolean
  00470	83 c4 08	 add	 esp, 8

; 153  : 		lua_pushvalue(L, -1);

  00473	6a ff		 push	 -1
  00475	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00478	50		 push	 eax
  00479	e8 00 00 00 00	 call	 _lua_pushvalue
  0047e	83 c4 08	 add	 esp, 8

; 154  : 		lua_setfield(L, 2, name);

  00481	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00487	50		 push	 eax
  00488	6a 02		 push	 2
  0048a	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  0048d	51		 push	 ecx
  0048e	e8 00 00 00 00	 call	 _lua_setfield
  00493	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@MuRequire:

; 155  : 	}
; 156  : 
; 157  : 	return 1;

  00496	b8 01 00 00 00	 mov	 eax, 1
$LN6@MuRequire:

; 158  : }

  0049b	5f		 pop	 edi
  0049c	5e		 pop	 esi
  0049d	5b		 pop	 ebx
  0049e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a1	33 cd		 xor	 ecx, ebp
  004a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a8	8b e5		 mov	 esp, ebp
  004aa	5d		 pop	 ebp
  004ab	c3		 ret	 0
?MuRequire@@YAHPAUlua_State@@@Z ENDP			; MuRequire
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 752  : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 753  : 		_Tidy(true);

  00032	6a 00		 push	 0
  00034	6a 01		 push	 1
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 754  : 		}

  0003e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$201846 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1987 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1988 : 		if (!_Built)

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00010	85 c0		 test	 eax, eax
  00012	75 02		 jne	 SHORT $LN4@Tidy
  00014	eb 44		 jmp	 SHORT $LN3@Tidy
$LN4@Tidy:

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001d	72 3b		 jb	 SHORT $LN3@Tidy

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d f8	 mov	 DWORD PTR __Ptr$201846[ebp], ecx

; 1993 : 			if (0 < _Newsize)

  00027	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0002b	76 14		 jbe	 SHORT $LN1@Tidy

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$201846[ebp]
  00034	51		 push	 ecx
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Tidy:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00047	83 c1 01	 add	 ecx, 1
  0004a	51		 push	 ecx
  0004b	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$201846[ebp]
  0004e	52		 push	 edx
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 c1 18	 add	 ecx, 24			; 00000018H
  00055	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN3@Tidy:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 1998 : 		_Eos(_Newsize);

  00064	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00067	50		 push	 eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1999 : 		}

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 498  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 458  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T228001 = -69						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1952 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  0000c	c6 45 bb 00	 mov	 BYTE PTR $T228001[ebp], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00016	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00019	8d 55 bb	 lea	 edx, DWORD PTR $T228001[ebp]
  0001c	52		 push	 edx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00025	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0002e	83 c4 08	 add	 esp, 8

; 1954 : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 527  : 		_Left = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 10		 mov	 BYTE PTR [eax], dl

; 528  : 		}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv80 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2002 : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00013	72 0a		 jb	 SHORT $LN3@Myptr
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	89 55 b8	 mov	 DWORD PTR tv80[ebp], edx
  0001d	eb 06		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	89 45 b8	 mov	 DWORD PTR tv80[ebp], eax
$LN4@Myptr:
  00025	8b 45 b8	 mov	 eax, DWORD PTR tv80[ebp]

; 2005 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mulua.cpp
;	COMDAT ??__Eg_MuLuaQuestExp@@YAXXZ
text$yc	SEGMENT
??__Eg_MuLuaQuestExp@@YAXXZ PROC			; `dynamic initializer for 'g_MuLuaQuestExp'', COMDAT

; 14   : MULua g_MuLuaQuestExp;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuLuaQuestExp@@3VMULua@@A ; g_MuLuaQuestExp
  0000e	e8 00 00 00 00	 call	 ??0MULua@@QAE@XZ	; MULua::MULua
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MuLuaQuestExp@@YAXXZ ; `dynamic atexit destructor for 'g_MuLuaQuestExp''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MuLuaQuestExp@@YAXXZ ENDP			; `dynamic initializer for 'g_MuLuaQuestExp''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_MuLuaQuestExp@@YAXXZ
text$yd	SEGMENT
??__Fg_MuLuaQuestExp@@YAXXZ PROC			; `dynamic atexit destructor for 'g_MuLuaQuestExp'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuLuaQuestExp@@3VMULua@@A ; g_MuLuaQuestExp
  0000e	e8 00 00 00 00	 call	 ??1MULua@@QAE@XZ	; MULua::~MULua
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MuLuaQuestExp@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_MuLuaQuestExp''
text$yd	ENDS
PUBLIC	?g_MuLuaQuestExp@@3VMULua@@A			; g_MuLuaQuestExp
_BSS	SEGMENT
?g_MuLuaQuestExp@@3VMULua@@A DD 01H DUP (?)		; g_MuLuaQuestExp
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MuLuaQuestExp$initializer$ DD FLAT:??__Eg_MuLuaQuestExp@@YAXXZ
CRT$XCU	ENDS
END
