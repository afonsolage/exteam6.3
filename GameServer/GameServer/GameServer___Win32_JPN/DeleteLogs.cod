; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\DeleteLogs.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06EEHCNIJK@Kundun?$AA@			; `string'
PUBLIC	??_C@_07KEJLPAHK@Kanturu?$AA@			; `string'
PUBLIC	??_C@_07FJPHLACI@Connect?$AA@			; `string'
PUBLIC	??_C@_04NKFKOIHC@Chat?$AA@			; `string'
PUBLIC	??_C@_0M@PLKEEFIP@CastleSiege?$AA@		; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	?FilterName@@YA_NPAD@Z				; FilterName
EXTRN	_strcmp:PROC
;	COMDAT ??_C@_06EEHCNIJK@Kundun?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\deletelogs.cpp
CONST	SEGMENT
??_C@_06EEHCNIJK@Kundun?$AA@ DB 'Kundun', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEJLPAHK@Kanturu?$AA@
CONST	SEGMENT
??_C@_07KEJLPAHK@Kanturu?$AA@ DB 'Kanturu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJPHLACI@Connect?$AA@
CONST	SEGMENT
??_C@_07FJPHLACI@Connect?$AA@ DB 'Connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKFKOIHC@Chat?$AA@
CONST	SEGMENT
??_C@_04NKFKOIHC@Chat?$AA@ DB 'Chat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLKEEFIP@CastleSiege?$AA@
CONST	SEGMENT
??_C@_0M@PLKEEFIP@CastleSiege?$AA@ DB 'CastleSiege', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Names$ = 8						; size = 4
?FilterName@@YA_NPAD@Z PROC				; FilterName

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8    : 	if(!strcmp(Names,"."))	return false;

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _strcmp
  00017	83 c4 08	 add	 esp, 8
  0001a	85 c0		 test	 eax, eax
  0001c	75 07		 jne	 SHORT $LN7@FilterName
  0001e	32 c0		 xor	 al, al
  00020	e9 98 00 00 00	 jmp	 $LN8@FilterName
$LN7@FilterName:

; 9    : 	if(!strcmp(Names,".."))	return false;

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
  0002a	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _strcmp
  00033	83 c4 08	 add	 esp, 8
  00036	85 c0		 test	 eax, eax
  00038	75 04		 jne	 SHORT $LN6@FilterName
  0003a	32 c0		 xor	 al, al
  0003c	eb 7f		 jmp	 SHORT $LN8@FilterName
$LN6@FilterName:

; 10   : 	if(!strcmp(Names,"CastleSiege"))	return false;

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PLKEEFIP@CastleSiege?$AA@
  00043	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _strcmp
  0004c	83 c4 08	 add	 esp, 8
  0004f	85 c0		 test	 eax, eax
  00051	75 04		 jne	 SHORT $LN5@FilterName
  00053	32 c0		 xor	 al, al
  00055	eb 66		 jmp	 SHORT $LN8@FilterName
$LN5@FilterName:

; 11   : 	if(!strcmp(Names,"Chat"))	return false;

  00057	68 00 00 00 00	 push	 OFFSET ??_C@_04NKFKOIHC@Chat?$AA@
  0005c	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _strcmp
  00065	83 c4 08	 add	 esp, 8
  00068	85 c0		 test	 eax, eax
  0006a	75 04		 jne	 SHORT $LN4@FilterName
  0006c	32 c0		 xor	 al, al
  0006e	eb 4d		 jmp	 SHORT $LN8@FilterName
$LN4@FilterName:

; 12   : 	if(!strcmp(Names,"Connect"))	return false;

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_07FJPHLACI@Connect?$AA@
  00075	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _strcmp
  0007e	83 c4 08	 add	 esp, 8
  00081	85 c0		 test	 eax, eax
  00083	75 04		 jne	 SHORT $LN3@FilterName
  00085	32 c0		 xor	 al, al
  00087	eb 34		 jmp	 SHORT $LN8@FilterName
$LN3@FilterName:

; 13   : 	if(!strcmp(Names,"Kanturu"))	return false;

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_07KEJLPAHK@Kanturu?$AA@
  0008e	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _strcmp
  00097	83 c4 08	 add	 esp, 8
  0009a	85 c0		 test	 eax, eax
  0009c	75 04		 jne	 SHORT $LN2@FilterName
  0009e	32 c0		 xor	 al, al
  000a0	eb 1b		 jmp	 SHORT $LN8@FilterName
$LN2@FilterName:

; 14   : 	if(!strcmp(Names,"Kundun"))	return false;

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_06EEHCNIJK@Kundun?$AA@
  000a7	8b 45 08	 mov	 eax, DWORD PTR _Names$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _strcmp
  000b0	83 c4 08	 add	 esp, 8
  000b3	85 c0		 test	 eax, eax
  000b5	75 04		 jne	 SHORT $LN1@FilterName
  000b7	32 c0		 xor	 al, al
  000b9	eb 02		 jmp	 SHORT $LN8@FilterName
$LN1@FilterName:

; 15   : 
; 16   : 	return true;

  000bb	b0 01		 mov	 al, 1
$LN8@FilterName:

; 17   : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?FilterName@@YA_NPAD@Z ENDP				; FilterName
_TEXT	ENDS
PUBLIC	??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_06LLPCNOPC@?4?2LOG?2?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DeleteLogs@@YAXXZ				; DeleteLogs
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_remove:PROC
EXTRN	_sprintf:PROC
EXTRN	?ExConfig@@3VcExConfigs@@A:BYTE			; ExConfig
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@ DB 'Done Logs: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@
CONST	SEGMENT
??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@ DB '.\LOG\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLPCNOPC@?4?2LOG?2?$AA@
CONST	SEGMENT
??_C@_06LLPCNOPC@?4?2LOG?2?$AA@ DB '.\LOG\', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_InfoDate$205273 = -112					; size = 100
_dir$ = -12						; size = 4
_entry$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?DeleteLogs@@YAXXZ PROC					; DeleteLogs

; 20   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000de	33 c5		 xor	 eax, ebp
  000e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000e3	53		 push	 ebx
  000e4	56		 push	 esi
  000e5	57		 push	 edi

; 21   : 	if(!ExConfig.CommonServer.DeleteLogs) return;

  000e6	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR ?ExConfig@@3VcExConfigs@@A+40, 0
  000ed	75 05		 jne	 SHORT $LN6@DeleteLogs
  000ef	e9 89 00 00 00	 jmp	 $LN7@DeleteLogs
$LN6@DeleteLogs:

; 22   : 
; 23   : 	struct dirent *entry;
; 24   : 
; 25   : 	DIR * dir = opendir(".\\LOG\\");

  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_06LLPCNOPC@?4?2LOG?2?$AA@
  000f9	e8 00 00 00 00	 call	 _opendir
  000fe	83 c4 04	 add	 esp, 4
  00101	89 45 f4	 mov	 DWORD PTR _dir$[ebp], eax

; 26   : 
; 27   : 	if (!dir) 

  00104	83 7d f4 00	 cmp	 DWORD PTR _dir$[ebp], 0
  00108	75 02		 jne	 SHORT $LN4@DeleteLogs

; 28   : 	{
; 29   : 		return;

  0010a	eb 71		 jmp	 SHORT $LN7@DeleteLogs
$LN4@DeleteLogs:

; 30   : 	}
; 31   : 
; 32   : 	while ( (entry = readdir(dir)) != NULL)

  0010c	8b 45 f4	 mov	 eax, DWORD PTR _dir$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _readdir
  00115	83 c4 04	 add	 esp, 4
  00118	89 45 f8	 mov	 DWORD PTR _entry$[ebp], eax
  0011b	83 7d f8 00	 cmp	 DWORD PTR _entry$[ebp], 0
  0011f	74 50		 je	 SHORT $LN3@DeleteLogs

; 33   : 	{
; 34   : 		if(!FilterName(entry->d_name))	continue;

  00121	8b 45 f8	 mov	 eax, DWORD PTR _entry$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?FilterName@@YA_NPAD@Z	; FilterName
  0012a	83 c4 04	 add	 esp, 4
  0012d	0f b6 c8	 movzx	 ecx, al
  00130	85 c9		 test	 ecx, ecx
  00132	75 02		 jne	 SHORT $LN2@DeleteLogs
  00134	eb d6		 jmp	 SHORT $LN4@DeleteLogs
$LN2@DeleteLogs:

; 35   : 
; 36   : 		char InfoDate[100];
; 37   : 
; 38   : 		sprintf(InfoDate, ".\\LOG\\%s",entry->d_name);

  00136	8b 45 f8	 mov	 eax, DWORD PTR _entry$[ebp]
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@
  0013f	8d 4d 90	 lea	 ecx, DWORD PTR _InfoDate$205273[ebp]
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 _sprintf
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 39   : 
; 40   : 		if (remove(InfoDate)==NULL)

  0014b	8d 45 90	 lea	 eax, DWORD PTR _InfoDate$205273[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _remove
  00154	83 c4 04	 add	 esp, 4
  00157	85 c0		 test	 eax, eax
  00159	75 14		 jne	 SHORT $LN1@DeleteLogs

; 41   : 		{
; 42   : 			LogAddC(2,"Done Logs: %s",entry->d_name);

  0015b	8b 45 f8	 mov	 eax, DWORD PTR _entry$[ebp]
  0015e	50		 push	 eax
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@
  00164	6a 02		 push	 2
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DeleteLogs:

; 43   : 		}
; 44   : 	}

  0016f	eb 9b		 jmp	 SHORT $LN4@DeleteLogs
$LN3@DeleteLogs:

; 45   : 	closedir(dir);

  00171	8b 45 f4	 mov	 eax, DWORD PTR _dir$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _closedir
  0017a	83 c4 04	 add	 esp, 4
$LN7@DeleteLogs:

; 46   : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00183	33 cd		 xor	 ecx, ebp
  00185	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?DeleteLogs@@YAXXZ ENDP					; DeleteLogs
_TEXT	ENDS
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	??_C@_04FGAJMCLA@?2?$CK?4?$CK?$AA@		; `string'
EXTRN	_strcpy:PROC
EXTRN	_free:PROC
EXTRN	_strlen:PROC
EXTRN	_malloc:PROC
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\dirent.h
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FGAJMCLA@?2?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_04FGAJMCLA@?2?$CK?4?$CK?$AA@ DB '\*.*', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv95 = -76						; size = 4
_p$204442 = -8						; size = 4
_dirp$ = -4						; size = 4
_dirname$ = 8						; size = 4
_opendir PROC

; 345  : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00196	53		 push	 ebx
  00197	56		 push	 esi
  00198	57		 push	 edi

; 346  :   DIR *dirp;
; 347  :   assert (dirname != NULL);
; 348  :   
; 349  :   dirp = (DIR*)malloc (sizeof (struct DIR));

  00199	68 54 02 00 00	 push	 596			; 00000254H
  0019e	e8 00 00 00 00	 call	 _malloc
  001a3	83 c4 04	 add	 esp, 4
  001a6	89 45 fc	 mov	 DWORD PTR _dirp$[ebp], eax

; 350  :   if (dirp != NULL) {

  001a9	83 7d fc 00	 cmp	 DWORD PTR _dirp$[ebp], 0
  001ad	0f 84 fa 00 00
	00		 je	 $LN4@opendir

; 351  :     char *p;
; 352  :     
; 353  :     /* allocate room for directory name */
; 354  :     dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));

  001b3	8b 45 08	 mov	 eax, DWORD PTR _dirname$[ebp]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _strlen
  001bc	83 c4 04	 add	 esp, 4
  001bf	8b f0		 mov	 esi, eax
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_04FGAJMCLA@?2?$CK?4?$CK?$AA@
  001c6	e8 00 00 00 00	 call	 _strlen
  001cb	83 c4 04	 add	 esp, 4
  001ce	8d 4c 06 01	 lea	 ecx, DWORD PTR [esi+eax+1]
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 _malloc
  001d8	83 c4 04	 add	 esp, 4
  001db	8b 55 fc	 mov	 edx, DWORD PTR _dirp$[ebp]
  001de	89 02		 mov	 DWORD PTR [edx], eax

; 355  :     if (dirp->dirname == NULL) {

  001e0	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  001e3	83 38 00	 cmp	 DWORD PTR [eax], 0
  001e6	75 13		 jne	 SHORT $LN3@opendir

; 356  :       /* failed to duplicate directory name.  errno set by malloc() */
; 357  :       free (dirp);

  001e8	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _free
  001f1	83 c4 04	 add	 esp, 4

; 358  :       return NULL;

  001f4	33 c0		 xor	 eax, eax
  001f6	e9 b5 00 00 00	 jmp	 $LN5@opendir
$LN3@opendir:

; 359  :     }
; 360  :     /* Copy directory name while appending directory separator and "*.*".
; 361  :      * Directory separator is not appended if the name already ends with
; 362  :      * drive or directory separator.  Directory separator is assumed to be
; 363  :      * '/' or '\' and drive separator is assumed to be ':'. */
; 364  :     strcpy (dirp->dirname, dirname);

  001fb	8b 45 08	 mov	 eax, DWORD PTR _dirname$[ebp]
  001fe	50		 push	 eax
  001ff	8b 4d fc	 mov	 ecx, DWORD PTR _dirp$[ebp]
  00202	8b 11		 mov	 edx, DWORD PTR [ecx]
  00204	52		 push	 edx
  00205	e8 00 00 00 00	 call	 _strcpy
  0020a	83 c4 08	 add	 esp, 8

; 365  :     p = strchr (dirp->dirname, '\0');

  0020d	6a 00		 push	 0
  0020f	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  00212	8b 08		 mov	 ecx, DWORD PTR [eax]
  00214	51		 push	 ecx
  00215	e8 00 00 00 00	 call	 ?strchr@@YAPADPADH@Z	; strchr
  0021a	83 c4 08	 add	 esp, 8
  0021d	89 45 f8	 mov	 DWORD PTR _p$204442[ebp], eax

; 366  :     if (dirp->dirname < p  &&
; 367  :         *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')

  00220	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  00223	8b 08		 mov	 ecx, DWORD PTR [eax]
  00225	3b 4d f8	 cmp	 ecx, DWORD PTR _p$204442[ebp]
  00228	73 44		 jae	 SHORT $LN2@opendir
  0022a	8b 45 f8	 mov	 eax, DWORD PTR _p$204442[ebp]
  0022d	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00231	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00234	74 38		 je	 SHORT $LN2@opendir
  00236	8b 45 f8	 mov	 eax, DWORD PTR _p$204442[ebp]
  00239	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  0023d	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00240	74 2c		 je	 SHORT $LN2@opendir
  00242	8b 45 f8	 mov	 eax, DWORD PTR _p$204442[ebp]
  00245	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00249	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0024c	74 20		 je	 SHORT $LN2@opendir

; 368  :     {
; 369  :       strcpy (p++, "\\");

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _p$204442[ebp]
  00251	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00259	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  0025c	51		 push	 ecx
  0025d	e8 00 00 00 00	 call	 _strcpy
  00262	83 c4 08	 add	 esp, 8
  00265	8b 55 f8	 mov	 edx, DWORD PTR _p$204442[ebp]
  00268	83 c2 01	 add	 edx, 1
  0026b	89 55 f8	 mov	 DWORD PTR _p$204442[ebp], edx
$LN2@opendir:

; 370  :     }
; 371  : # ifdef DIRENT_WIN32_INTERFACE
; 372  :     strcpy (p, "*"); /*scan files with and without extension in win32*/

  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_01NBENCBCI@?$CK?$AA@
  00273	8b 45 f8	 mov	 eax, DWORD PTR _p$204442[ebp]
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 _strcpy
  0027c	83 c4 08	 add	 esp, 8

; 373  : # else
; 374  :     strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
; 375  : # endif
; 376  : 
; 377  :     /* open stream */
; 378  :     if (_initdir (dirp) == 0) {

  0027f	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 __initdir
  00288	83 c4 04	 add	 esp, 4
  0028b	85 c0		 test	 eax, eax
  0028d	75 1e		 jne	 SHORT $LN4@opendir

; 379  :       /* initialization failed */
; 380  :       free (dirp->dirname);

  0028f	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  00292	8b 08		 mov	 ecx, DWORD PTR [eax]
  00294	51		 push	 ecx
  00295	e8 00 00 00 00	 call	 _free
  0029a	83 c4 04	 add	 esp, 4

; 381  :       free (dirp);

  0029d	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 _free
  002a6	83 c4 04	 add	 esp, 4

; 382  :       return NULL;

  002a9	33 c0		 xor	 eax, eax
  002ab	eb 03		 jmp	 SHORT $LN5@opendir
$LN4@opendir:

; 383  :     }
; 384  :   }
; 385  :   return dirp;

  002ad	8b 45 fc	 mov	 eax, DWORD PTR _dirp$[ebp]
$LN5@opendir:

; 386  : }

  002b0	5f		 pop	 edi
  002b1	5e		 pop	 esi
  002b2	5b		 pop	 ebx
  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
_opendir ENDP
_TEXT	ENDS
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__errno:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_dirp$ = 8						; size = 4
_readdir PROC

; 437  : {

  002c0	55		 push	 ebp
  002c1	8b ec		 mov	 ebp, esp
  002c3	83 ec 40	 sub	 esp, 64			; 00000040H
  002c6	53		 push	 ebx
  002c7	56		 push	 esi
  002c8	57		 push	 edi

; 438  :   assert (dirp != NULL);
; 439  :   if (dirp == NULL) {

  002c9	83 7d 08 00	 cmp	 DWORD PTR _dirp$[ebp], 0
  002cd	75 12		 jne	 SHORT $LN5@readdir

; 440  :     errno = EBADF;

  002cf	e8 00 00 00 00	 call	 __errno
  002d4	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 441  :     return NULL;

  002da	33 c0		 xor	 eax, eax
  002dc	e9 91 00 00 00	 jmp	 $LN6@readdir
$LN5@readdir:

; 442  :   }
; 443  : 
; 444  : #if defined(DIRENT_WIN32_INTERFACE)
; 445  :   if (dirp->search_handle == INVALID_HANDLE_VALUE) {

  002e1	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  002e4	83 b8 50 02 00
	00 ff		 cmp	 DWORD PTR [eax+592], -1
  002eb	75 0f		 jne	 SHORT $LN4@readdir

; 446  :     /* directory stream was opened/rewound incorrectly or it ended normally */
; 447  :     errno = EBADF;

  002ed	e8 00 00 00 00	 call	 __errno
  002f2	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 448  :     return NULL;

  002f8	33 c0		 xor	 eax, eax
  002fa	eb 76		 jmp	 SHORT $LN6@readdir
$LN4@readdir:

; 449  :   }
; 450  : #endif
; 451  : 
; 452  :   if (dirp->dirent_filled != 0) {

  002fc	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  002ff	83 b8 4c 02 00
	00 00		 cmp	 DWORD PTR [eax+588], 0
  00306	74 0f		 je	 SHORT $LN3@readdir

; 453  :     /*
; 454  :      * Directory entry has already been retrieved and there is no need to
; 455  :      * retrieve a new one.  Directory entry will be retrieved in advance
; 456  :      * when the user calls readdir function for the first time.  This is so
; 457  :      * because real dirent has separate functions for opening and reading
; 458  :      * the stream whereas Win32 and DOS dirents open the stream
; 459  :      * automatically when we retrieve the first file.  Therefore, we have to
; 460  :      * save the first file when opening the stream and later we have to
; 461  :      * return the saved entry when the user tries to read the first entry.
; 462  :      */
; 463  :     dirp->dirent_filled = 0;

  00308	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  0030b	c7 80 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+588], 0

; 464  :   } else {

  00315	eb 55		 jmp	 SHORT $LN2@readdir
$LN3@readdir:

; 465  :     /* fill in entry and return that */
; 466  : #if defined(DIRENT_WIN32_INTERFACE)
; 467  :     if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {

  00317	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  0031a	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0031f	50		 push	 eax
  00320	8b 4d 08	 mov	 ecx, DWORD PTR _dirp$[ebp]
  00323	8b 91 50 02 00
	00		 mov	 edx, DWORD PTR [ecx+592]
  00329	52		 push	 edx
  0032a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  00330	85 c0		 test	 eax, eax
  00332	75 2c		 jne	 SHORT $LN1@readdir

; 468  :       /* Last file has been processed or an error occured */
; 469  :       FindClose (dirp->search_handle);

  00334	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00337	8b 88 50 02 00
	00		 mov	 ecx, DWORD PTR [eax+592]
  0033d	51		 push	 ecx
  0033e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 470  :       dirp->search_handle = INVALID_HANDLE_VALUE;

  00344	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00347	c7 80 50 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+592], -1

; 471  :       errno = ENOENT;

  00351	e8 00 00 00 00	 call	 __errno
  00356	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 472  :       return NULL;

  0035c	33 c0		 xor	 eax, eax
  0035e	eb 12		 jmp	 SHORT $LN6@readdir
$LN1@readdir:

; 473  :     }
; 474  : 
; 475  : # elif defined(DIRENT_MSDOS_INTERFACE)
; 476  :     if (_dos_findnext (&dirp->current.data) != 0) {
; 477  :       /* _dos_findnext and findnext will set errno to ENOENT when no
; 478  :        * more entries could be retrieved. */
; 479  :       return NULL;
; 480  :     }
; 481  : # endif
; 482  : 
; 483  :     _setdirname (dirp);

  00360	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00363	50		 push	 eax
  00364	e8 00 00 00 00	 call	 __setdirname
  00369	83 c4 04	 add	 esp, 4
$LN2@readdir:

; 484  :     assert (dirp->dirent_filled == 0);
; 485  :   }
; 486  :   return &dirp->current;

  0036c	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  0036f	83 c0 04	 add	 eax, 4
$LN6@readdir:

; 487  : }

  00372	5f		 pop	 edi
  00373	5e		 pop	 esi
  00374	5b		 pop	 ebx
  00375	8b e5		 mov	 esp, ebp
  00377	5d		 pop	 ebp
  00378	c3		 ret	 0
_readdir ENDP
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_retcode$ = -4						; size = 4
_dirp$ = 8						; size = 4
_closedir PROC

; 511  : {   

  00380	55		 push	 ebp
  00381	8b ec		 mov	 ebp, esp
  00383	83 ec 44	 sub	 esp, 68			; 00000044H
  00386	53		 push	 ebx
  00387	56		 push	 esi
  00388	57		 push	 edi

; 512  :   int retcode = 0;

  00389	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retcode$[ebp], 0

; 513  : 
; 514  :   /* make sure that dirp points to legal structure */
; 515  :   assert (dirp != NULL);
; 516  :   if (dirp == NULL) {

  00390	83 7d 08 00	 cmp	 DWORD PTR _dirp$[ebp], 0
  00394	75 10		 jne	 SHORT $LN4@closedir

; 517  :     errno = EBADF;

  00396	e8 00 00 00 00	 call	 __errno
  0039b	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 518  :     return -1;

  003a1	83 c8 ff	 or	 eax, -1
  003a4	eb 77		 jmp	 SHORT $LN5@closedir
$LN4@closedir:

; 519  :   }
; 520  :  
; 521  :   /* free directory name and search handles */
; 522  :   if (dirp->dirname != NULL) free (dirp->dirname);

  003a6	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  003a9	83 38 00	 cmp	 DWORD PTR [eax], 0
  003ac	74 0e		 je	 SHORT $LN3@closedir
  003ae	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  003b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b3	51		 push	 ecx
  003b4	e8 00 00 00 00	 call	 _free
  003b9	83 c4 04	 add	 esp, 4
$LN3@closedir:

; 523  : 
; 524  : #if defined(DIRENT_WIN32_INTERFACE)
; 525  :   if (dirp->search_handle != INVALID_HANDLE_VALUE) {

  003bc	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  003bf	83 b8 50 02 00
	00 ff		 cmp	 DWORD PTR [eax+592], -1
  003c6	74 26		 je	 SHORT $LN2@closedir

; 526  :     if (FindClose (dirp->search_handle) == FALSE) {

  003c8	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  003cb	8b 88 50 02 00
	00		 mov	 ecx, DWORD PTR [eax+592]
  003d1	51		 push	 ecx
  003d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  003d8	85 c0		 test	 eax, eax
  003da	75 12		 jne	 SHORT $LN2@closedir

; 527  :       /* Unknown error */
; 528  :       retcode = -1;

  003dc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _retcode$[ebp], -1

; 529  :       errno = EBADF;

  003e3	e8 00 00 00 00	 call	 __errno
  003e8	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
$LN2@closedir:

; 530  :     }
; 531  :   }
; 532  : #endif                     
; 533  : 
; 534  :   /* clear dirp structure to make sure that it cannot be used anymore*/
; 535  :   memset (dirp, 0, sizeof (*dirp));

  003ee	68 54 02 00 00	 push	 596			; 00000254H
  003f3	6a 00		 push	 0
  003f5	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 _memset
  003fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 536  : # if defined(DIRENT_WIN32_INTERFACE)
; 537  :   dirp->search_handle = INVALID_HANDLE_VALUE;

  00401	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00404	c7 80 50 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+592], -1

; 538  : # endif
; 539  : 
; 540  :   free (dirp);

  0040e	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00411	50		 push	 eax
  00412	e8 00 00 00 00	 call	 _free
  00417	83 c4 04	 add	 esp, 4

; 541  :   return retcode;

  0041a	8b 45 fc	 mov	 eax, DWORD PTR _retcode$[ebp]
$LN5@closedir:

; 542  : }

  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5b		 pop	 ebx
  00420	8b e5		 mov	 esp, ebp
  00422	5d		 pop	 ebp
  00423	c3		 ret	 0
_closedir ENDP
_TEXT	ENDS
EXTRN	__imp__FindFirstFileA@8:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_dirp$ = 8						; size = 4
__initdir PROC

; 602  : { 

  00430	55		 push	 ebp
  00431	8b ec		 mov	 ebp, esp
  00433	83 ec 40	 sub	 esp, 64			; 00000040H
  00436	53		 push	 ebx
  00437	56		 push	 esi
  00438	57		 push	 edi

; 603  :   assert (dirp != NULL);
; 604  :   assert (dirp->dirname != NULL);
; 605  :   dirp->dirent_filled = 0;

  00439	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  0043c	c7 80 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+588], 0

; 606  : 
; 607  : # if defined(DIRENT_WIN32_INTERFACE)
; 608  :   /* Open stream and retrieve first file */
; 609  :   dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);

  00446	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00449	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0044e	50		 push	 eax
  0044f	8b 4d 08	 mov	 ecx, DWORD PTR _dirp$[ebp]
  00452	8b 11		 mov	 edx, DWORD PTR [ecx]
  00454	52		 push	 edx
  00455	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0045b	8b 4d 08	 mov	 ecx, DWORD PTR _dirp$[ebp]
  0045e	89 81 50 02 00
	00		 mov	 DWORD PTR [ecx+592], eax

; 610  :   if (dirp->search_handle == INVALID_HANDLE_VALUE) {

  00464	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00467	83 b8 50 02 00
	00 ff		 cmp	 DWORD PTR [eax+592], -1
  0046e	75 0f		 jne	 SHORT $LN1@initdir

; 611  :     /* something went wrong but we don't know what.  GetLastError() could
; 612  :      * give us more information about the error, but then we should map
; 613  :      * the error code into errno. */
; 614  :     errno = ENOENT;

  00470	e8 00 00 00 00	 call	 __errno
  00475	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 615  :     return 0;

  0047b	33 c0		 xor	 eax, eax
  0047d	eb 1e		 jmp	 SHORT $LN2@initdir
$LN1@initdir:

; 616  :   }
; 617  : 
; 618  : # elif defined(DIRENT_MSDOS_INTERFACE)
; 619  :   if (_dos_findfirst (dirp->dirname,
; 620  :           _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
; 621  :           &dirp->current.data) != 0)
; 622  :   {
; 623  :     /* _dos_findfirst and findfirst will set errno to ENOENT when no 
; 624  :      * more entries could be retrieved. */
; 625  :     return 0;
; 626  :   }
; 627  : # endif
; 628  : 
; 629  :   /* initialize DIR and it's first entry */
; 630  :   _setdirname (dirp);

  0047f	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  00482	50		 push	 eax
  00483	e8 00 00 00 00	 call	 __setdirname
  00488	83 c4 04	 add	 esp, 4

; 631  :   dirp->dirent_filled = 1;

  0048b	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  0048e	c7 80 4c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+588], 1

; 632  :   return 1;

  00498	b8 01 00 00 00	 mov	 eax, 1
$LN2@initdir:

; 633  : }

  0049d	5f		 pop	 edi
  0049e	5e		 pop	 esi
  0049f	5b		 pop	 ebx
  004a0	8b e5		 mov	 esp, ebp
  004a2	5d		 pop	 ebp
  004a3	c3		 ret	 0
__initdir ENDP
_TEXT	ENDS
EXTRN	_strncpy:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_dirp$ = 8						; size = 4
__setdirname PROC

; 658  : _setdirname (struct DIR *dirp) {

  004b0	55		 push	 ebp
  004b1	8b ec		 mov	 ebp, esp
  004b3	83 ec 40	 sub	 esp, 64			; 00000040H
  004b6	53		 push	 ebx
  004b7	56		 push	 esi
  004b8	57		 push	 edi

; 659  :   /* make sure that d_name is long enough */
; 660  :   assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
; 661  :   
; 662  :   strncpy (dirp->current.d_name,
; 663  :       _getdirname (&dirp->current),
; 664  :       NAME_MAX);

  004b9	68 04 01 00 00	 push	 260			; 00000104H
  004be	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  004c1	83 c0 04	 add	 eax, 4
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 __getdirname
  004ca	83 c4 04	 add	 esp, 4
  004cd	50		 push	 eax
  004ce	8b 4d 08	 mov	 ecx, DWORD PTR _dirp$[ebp]
  004d1	83 c1 04	 add	 ecx, 4
  004d4	51		 push	 ecx
  004d5	e8 00 00 00 00	 call	 _strncpy
  004da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 665  :   dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/

  004dd	8b 45 08	 mov	 eax, DWORD PTR _dirp$[ebp]
  004e0	c6 80 08 01 00
	00 00		 mov	 BYTE PTR [eax+264], 0

; 666  : }

  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi
  004e9	5b		 pop	 ebx
  004ea	8b e5		 mov	 esp, ebp
  004ec	5d		 pop	 ebp
  004ed	c3		 ret	 0
__setdirname ENDP
; Function compile flags: /Odtp /ZI
_dp$ = 8						; size = 4
__getdirname PROC

; 641  : {

  004f0	55		 push	 ebp
  004f1	8b ec		 mov	 ebp, esp
  004f3	83 ec 40	 sub	 esp, 64			; 00000040H
  004f6	53		 push	 ebx
  004f7	56		 push	 esi
  004f8	57		 push	 edi

; 642  : #if defined(DIRENT_WIN32_INTERFACE)
; 643  :   return dp->data.cFileName;

  004f9	8b 45 08	 mov	 eax, DWORD PTR _dp$[ebp]
  004fc	05 34 01 00 00	 add	 eax, 308		; 00000134H

; 644  :   
; 645  : #elif defined(DIRENT_USE_FFBLK)
; 646  :   return dp->data.ff_name;
; 647  :   
; 648  : #else
; 649  :   return dp->data.name;
; 650  : #endif  
; 651  : }

  00501	5f		 pop	 edi
  00502	5e		 pop	 esi
  00503	5b		 pop	 ebx
  00504	8b e5		 mov	 esp, ebp
  00506	5d		 pop	 ebp
  00507	c3		 ret	 0
__getdirname ENDP
_TEXT	ENDS
EXTRN	_strchr:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 215  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _strchr
  00016	83 c4 08	 add	 esp, 8
  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
END
