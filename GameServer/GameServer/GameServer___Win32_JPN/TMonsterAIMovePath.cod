; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\TMonsterAIMovePath.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?DelAllAIMonsterMovePath@TMonsterAIMovePath@@QAEHXZ ; TMonsterAIMovePath::DelAllAIMonsterMovePath
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0TMonsterAIMovePathInfo@@QAE@XZ		; TMonsterAIMovePathInfo::TMonsterAIMovePathInfo
PUBLIC	??_7TMonsterAIMovePath@@6B@			; TMonsterAIMovePath::`vftable'
PUBLIC	??0TMonsterAIMovePath@@QAE@XZ			; TMonsterAIMovePath::TMonsterAIMovePath
PUBLIC	??_R4TMonsterAIMovePath@@6B@			; TMonsterAIMovePath::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIMovePath@@@8			; TMonsterAIMovePath `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIMovePath@@8			; TMonsterAIMovePath::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIMovePath@@8			; TMonsterAIMovePath::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIMovePath@@8		; TMonsterAIMovePath::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAIMovePath@@UAEPAXI@Z:PROC		; TMonsterAIMovePath::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAIMovePath@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraimovepath.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIMovePath@@8 DD FLAT:??_R0?AVTMonsterAIMovePath@@@8 ; TMonsterAIMovePath::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIMovePath@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIMovePath@@8
rdata$r	SEGMENT
??_R2TMonsterAIMovePath@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIMovePath@@8 ; TMonsterAIMovePath::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIMovePath@@8
rdata$r	SEGMENT
??_R3TMonsterAIMovePath@@8 DD 00H			; TMonsterAIMovePath::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIMovePath@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIMovePath@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAIMovePath@@@8 DD FLAT:??_7type_info@@6B@ ; TMonsterAIMovePath `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIMovePath@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAIMovePath@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIMovePath@@6B@ DD 00H			; TMonsterAIMovePath::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIMovePath@@@8
	DD	FLAT:??_R3TMonsterAIMovePath@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIMovePath@@6B@
CONST	SEGMENT
??_7TMonsterAIMovePath@@6B@ DD FLAT:??_R4TMonsterAIMovePath@@6B@ ; TMonsterAIMovePath::`vftable'
	DD	FLAT:??_ETMonsterAIMovePath@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIMovePath@@QAE@XZ PROC			; TMonsterAIMovePath::TMonsterAIMovePath
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIMovePath@@6B@
  00015	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIMovePathInfo@@QAE@XZ ; TMonsterAIMovePathInfo::TMonsterAIMovePathInfo
  0001a	68 2c 01 00 00	 push	 300			; 0000012cH
  0001f	6a 10		 push	 16			; 00000010H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z

; 20   : 	this->DelAllAIMonsterMovePath();

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?DelAllAIMonsterMovePath@TMonsterAIMovePath@@QAEHXZ ; TMonsterAIMovePath::DelAllAIMonsterMovePath

; 21   : }

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0TMonsterAIMovePath@@QAE@XZ ENDP			; TMonsterAIMovePath::TMonsterAIMovePath
_TEXT	ENDS
PUBLIC	?Reset@TMonsterAIMovePathInfo@@QAEXXZ		; TMonsterAIMovePathInfo::Reset
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraimovepath.h
;	COMDAT ??0TMonsterAIMovePathInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIMovePathInfo@@QAE@XZ PROC			; TMonsterAIMovePathInfo::TMonsterAIMovePathInfo, COMDAT
; _this$ = ecx

; 29   : 	TMonsterAIMovePathInfo()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	{
; 31   : 		this->Reset();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Reset@TMonsterAIMovePathInfo@@QAEXXZ ; TMonsterAIMovePathInfo::Reset

; 32   : 	}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0TMonsterAIMovePathInfo@@QAE@XZ ENDP			; TMonsterAIMovePathInfo::TMonsterAIMovePathInfo
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?Reset@TMonsterAIMovePathInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@TMonsterAIMovePathInfo@@QAEXXZ PROC		; TMonsterAIMovePathInfo::Reset, COMDAT
; _this$ = ecx

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 36   : 		this->m_iType = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 37   : 		this->m_iMapNumber = -1;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 38   : 		this->m_iPathX = -1;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 39   : 		this->m_iPathY = -1;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 40   : 	}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?Reset@TMonsterAIMovePathInfo@@QAEXXZ ENDP		; TMonsterAIMovePathInfo::Reset
_TEXT	ENDS
PUBLIC	??1TMonsterAIMovePath@@UAE@XZ			; TMonsterAIMovePath::~TMonsterAIMovePath
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GTMonsterAIMovePath@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTMonsterAIMovePath@@UAEPAXI@Z PROC			; TMonsterAIMovePath::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1TMonsterAIMovePath@@UAE@XZ ; TMonsterAIMovePath::~TMonsterAIMovePath
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GTMonsterAIMovePath@@UAEPAXI@Z ENDP			; TMonsterAIMovePath::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraimovepath.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TMonsterAIMovePath@@UAE@XZ PROC			; TMonsterAIMovePath::~TMonsterAIMovePath
; _this$ = ecx

; 26   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIMovePath@@6B@

; 27   : 	return;
; 28   : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??1TMonsterAIMovePath@@UAE@XZ ENDP			; TMonsterAIMovePath::~TMonsterAIMovePath
_TEXT	ENDS
PUBLIC	??_C@_0DM@HJPPMNFP@?$FLMonster?5AI?5MovePath?$FN?5?9?5Loading?5@ ; `string'
PUBLIC	??_C@_0CL@MAJLAOIC@?$FLMonster?5AI?5MovePath?5?$FN?5?9?5?$CFs?5file@ ; `string'
PUBLIC	??_C@_0DB@MNPFCJHE@?$FLMonster?5AI?5MovePath?$FN?5Exceed?5Max@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CH@NMMPFHPL@?$FLMonster?5AI?5MovePath?$FN?5?9?5Can?8t?5Op@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0DK@EMCNCDEG@?$FLMonster?5AI?5MovePath?$FN?5?9?5File?5loa@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?LoadData@TMonsterAIMovePath@@QAEHPAD@Z		; TMonsterAIMovePath::LoadData
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_strcmp:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DM@HJPPMNFP@?$FLMonster?5AI?5MovePath?$FN?5?9?5Loading?5@
CONST	SEGMENT
??_C@_0DM@HJPPMNFP@?$FLMonster?5AI?5MovePath?$FN?5?9?5Loading?5@ DB '[Mon'
	DB	'ster AI MovePath] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MAJLAOIC@?$FLMonster?5AI?5MovePath?5?$FN?5?9?5?$CFs?5file@
CONST	SEGMENT
??_C@_0CL@MAJLAOIC@?$FLMonster?5AI?5MovePath?5?$FN?5?9?5?$CFs?5file@ DB '['
	DB	'Monster AI MovePath ] - %s file is Loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MNPFCJHE@?$FLMonster?5AI?5MovePath?$FN?5Exceed?5Max@
CONST	SEGMENT
??_C@_0DB@MNPFCJHE@?$FLMonster?5AI?5MovePath?$FN?5Exceed?5Max@ DB '[Monst'
	DB	'er AI MovePath] Exceed Max Move Path-Spot ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NMMPFHPL@?$FLMonster?5AI?5MovePath?$FN?5?9?5Can?8t?5Op@
CONST	SEGMENT
??_C@_0CH@NMMPFHPL@?$FLMonster?5AI?5MovePath?$FN?5?9?5Can?8t?5Op@ DB '[Mo'
	DB	'nster AI MovePath] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EMCNCDEG@?$FLMonster?5AI?5MovePath?$FN?5?9?5File?5loa@
CONST	SEGMENT
??_C@_0DK@EMCNCDEG@?$FLMonster?5AI?5MovePath?$FN?5?9?5File?5loa@ DB '[Mon'
	DB	'ster AI MovePath] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z$0
__unwindtable$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv167 = -112						; size = 4
tv166 = -112						; size = 4
tv165 = -112						; size = 4
tv164 = -112						; size = 4
tv163 = -112						; size = 4
_iY$204600 = -44					; size = 4
_iX$204599 = -40					; size = 4
_iMapNumber$204598 = -36				; size = 4
_iSpotType$204597 = -32					; size = 4
_iType$204587 = -28					; size = 4
_Token$204583 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterAIMovePath@@QAEHPAD@Z PROC		; TMonsterAIMovePath::LoadData
; _this$ = ecx

; 34   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	6a ff		 push	 -1
  00065	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z
  0006a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00070	50		 push	 eax
  00071	51		 push	 ecx
  00072	83 ec 60	 sub	 esp, 96			; 00000060H
  00075	53		 push	 ebx
  00076	56		 push	 esi
  00077	57		 push	 edi
  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0007d	33 c5		 xor	 eax, ebp
  0007f	50		 push	 eax
  00080	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00083	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00089	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	this->m_bDataLoad = FALSE;

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00092	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 36   : 
; 37   : 	if ( !lpszFileName || !strcmp(lpszFileName, ""))

  00099	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  0009d	74 15		 je	 SHORT $LN11@LoadData
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000a4	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _strcmp
  000ad	83 c4 08	 add	 esp, 8
  000b0	85 c0		 test	 eax, eax
  000b2	75 14		 jne	 SHORT $LN12@LoadData
$LN11@LoadData:

; 38   : 	{
; 39   : 		MsgBox("[Monster AI MovePath] - File load error : File Name Error");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EMCNCDEG@?$FLMonster?5AI?5MovePath?$FN?5?9?5File?5loa@
  000b9	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000be	83 c4 04	 add	 esp, 4

; 40   : 		return FALSE;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 33 02 00 00	 jmp	 $LN13@LoadData
$LN12@LoadData:

; 41   : 	}
; 42   : 
; 43   : 	try
; 44   : 	{

  000c8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 45   : 		SMDToken Token;
; 46   : 		SMDFile = fopen(lpszFileName, "r");

  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000d4	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _fopen
  000dd	83 c4 08	 add	 esp, 8
  000e0	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 47   : 
; 48   : 		if ( SMDFile == NULL )

  000e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  000ec	75 18		 jne	 SHORT $LN9@LoadData

; 49   : 		{
; 50   : 			MsgBox("[Monster AI MovePath] - Can't Open %s ", lpszFileName);

  000ee	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NMMPFHPL@?$FLMonster?5AI?5MovePath?$FN?5?9?5Can?8t?5Op@
  000f7	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000fc	83 c4 08	 add	 esp, 8

; 51   : 			return FALSE;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 f5 01 00 00	 jmp	 $LN13@LoadData
$LN9@LoadData:

; 52   : 		}
; 53   : 
; 54   : 		this->DelAllAIMonsterMovePath();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?DelAllAIMonsterMovePath@TMonsterAIMovePath@@QAEHXZ ; TMonsterAIMovePath::DelAllAIMonsterMovePath

; 55   : 		int iType = -1;

  0010e	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _iType$204587[ebp], -1
$LN8@LoadData:

; 56   : 
; 57   : 		while ( true )

  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	85 c0		 test	 eax, eax
  0011c	0f 84 84 01 00
	00		 je	 $LN7@LoadData

; 58   : 		{
; 59   : 			Token = GetToken();

  00122	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00127	89 45 90	 mov	 DWORD PTR tv163[ebp], eax
  0012a	8b 45 90	 mov	 eax, DWORD PTR tv163[ebp]
  0012d	89 45 e8	 mov	 DWORD PTR _Token$204583[ebp], eax

; 60   : 
; 61   : 			if ( Token == END )

  00130	83 7d e8 02	 cmp	 DWORD PTR _Token$204583[ebp], 2
  00134	75 05		 jne	 SHORT $LN6@LoadData

; 62   : 				break;

  00136	e9 6b 01 00 00	 jmp	 $LN7@LoadData
$LN6@LoadData:

; 63   : 
; 64   : 			iType = (int)TokenNumber;

  0013b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00141	e8 00 00 00 00	 call	 __ftol2_sse
  00146	89 45 e4	 mov	 DWORD PTR _iType$204587[ebp], eax
$LN5@LoadData:

; 65   : 
; 66   : 			while ( true )

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	85 c0		 test	 eax, eax
  00150	0f 84 4b 01 00
	00		 je	 $LN4@LoadData

; 67   : 			{
; 68   : 				if ( iType == 2 )

  00156	83 7d e4 02	 cmp	 DWORD PTR _iType$204587[ebp], 2
  0015a	0f 85 3c 01 00
	00		 jne	 $LN1@LoadData

; 69   : 				{
; 70   : 					int iSpotType = -1;

  00160	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _iSpotType$204597[ebp], -1

; 71   : 					int iMapNumber = -1;

  00167	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _iMapNumber$204598[ebp], -1

; 72   : 					int iX = -1;

  0016e	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _iX$204599[ebp], -1

; 73   : 					int iY = -1;

  00175	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _iY$204600[ebp], -1

; 74   : 
; 75   : 					Token = GetToken();

  0017c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00181	89 45 90	 mov	 DWORD PTR tv164[ebp], eax
  00184	8b 45 90	 mov	 eax, DWORD PTR tv164[ebp]
  00187	89 45 e8	 mov	 DWORD PTR _Token$204583[ebp], eax

; 76   : 
; 77   : 					if ( !strcmp("end", TokenString))

  0018a	68 00 00 00 00	 push	 OFFSET _TokenString
  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00194	e8 00 00 00 00	 call	 _strcmp
  00199	83 c4 08	 add	 esp, 8
  0019c	85 c0		 test	 eax, eax
  0019e	75 05		 jne	 SHORT $LN2@LoadData

; 78   : 						break;

  001a0	e9 fc 00 00 00	 jmp	 $LN4@LoadData
$LN2@LoadData:

; 79   : 
; 80   : 					iSpotType = (int)TokenNumber;

  001a5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ab	e8 00 00 00 00	 call	 __ftol2_sse
  001b0	89 45 e0	 mov	 DWORD PTR _iSpotType$204597[ebp], eax

; 81   : 
; 82   : 					Token = GetToken();

  001b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001b8	89 45 90	 mov	 DWORD PTR tv165[ebp], eax
  001bb	8b 45 90	 mov	 eax, DWORD PTR tv165[ebp]
  001be	89 45 e8	 mov	 DWORD PTR _Token$204583[ebp], eax

; 83   : 					iMapNumber = (int)TokenNumber;

  001c1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001c7	e8 00 00 00 00	 call	 __ftol2_sse
  001cc	89 45 dc	 mov	 DWORD PTR _iMapNumber$204598[ebp], eax

; 84   : 
; 85   : 					Token = GetToken();

  001cf	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001d4	89 45 90	 mov	 DWORD PTR tv166[ebp], eax
  001d7	8b 45 90	 mov	 eax, DWORD PTR tv166[ebp]
  001da	89 45 e8	 mov	 DWORD PTR _Token$204583[ebp], eax

; 86   : 					iX = (int)TokenNumber;

  001dd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e3	e8 00 00 00 00	 call	 __ftol2_sse
  001e8	89 45 d8	 mov	 DWORD PTR _iX$204599[ebp], eax

; 87   : 
; 88   : 					Token = GetToken();

  001eb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001f0	89 45 90	 mov	 DWORD PTR tv167[ebp], eax
  001f3	8b 45 90	 mov	 eax, DWORD PTR tv167[ebp]
  001f6	89 45 e8	 mov	 DWORD PTR _Token$204583[ebp], eax

; 89   : 					iY = (int)TokenNumber;

  001f9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ff	e8 00 00 00 00	 call	 __ftol2_sse
  00204	89 45 d4	 mov	 DWORD PTR _iY$204600[ebp], eax

; 90   : 
; 91   : 					this->m_MovePathInfo[this->m_iMovePathSpotCount].m_iType = iSpotType;

  00207	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0020a	8b 88 c8 12 00
	00		 mov	 ecx, DWORD PTR [eax+4808]
  00210	c1 e1 04	 shl	 ecx, 4
  00213	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00216	8b 45 e0	 mov	 eax, DWORD PTR _iSpotType$204597[ebp]
  00219	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 92   : 					this->m_MovePathInfo[this->m_iMovePathSpotCount].m_iMapNumber = iMapNumber;

  0021d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00220	8b 88 c8 12 00
	00		 mov	 ecx, DWORD PTR [eax+4808]
  00226	c1 e1 04	 shl	 ecx, 4
  00229	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0022c	8b 45 dc	 mov	 eax, DWORD PTR _iMapNumber$204598[ebp]
  0022f	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 93   : 					this->m_MovePathInfo[this->m_iMovePathSpotCount].m_iPathX = iX;

  00233	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00236	8b 88 c8 12 00
	00		 mov	 ecx, DWORD PTR [eax+4808]
  0023c	c1 e1 04	 shl	 ecx, 4
  0023f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00242	8b 45 d8	 mov	 eax, DWORD PTR _iX$204599[ebp]
  00245	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 94   : 					this->m_MovePathInfo[this->m_iMovePathSpotCount].m_iPathY = iY;

  00249	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0024c	8b 88 c8 12 00
	00		 mov	 ecx, DWORD PTR [eax+4808]
  00252	c1 e1 04	 shl	 ecx, 4
  00255	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00258	8b 45 d4	 mov	 eax, DWORD PTR _iY$204600[ebp]
  0025b	89 44 0a 14	 mov	 DWORD PTR [edx+ecx+20], eax

; 95   : 
; 96   : 					this->m_iMovePathSpotCount++;

  0025f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00262	8b 88 c8 12 00
	00		 mov	 ecx, DWORD PTR [eax+4808]
  00268	83 c1 01	 add	 ecx, 1
  0026b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0026e	89 8a c8 12 00
	00		 mov	 DWORD PTR [edx+4808], ecx

; 97   : 
; 98   : 					if ( this->m_iMovePathSpotCount > MAX_MONSTER_AI_MOVE_PATH )

  00274	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00277	81 b8 c8 12 00
	00 2c 01 00 00	 cmp	 DWORD PTR [eax+4808], 300 ; 0000012cH
  00281	7e 19		 jle	 SHORT $LN1@LoadData

; 99   : 					{
; 100  : 						MsgBox("[Monster AI MovePath] Exceed Max Move Path-Spot ");

  00283	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MNPFCJHE@?$FLMonster?5AI?5MovePath?$FN?5Exceed?5Max@
  00288	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0028d	83 c4 04	 add	 esp, 4

; 101  : 						this->DelAllAIMonsterMovePath();

  00290	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00293	e8 00 00 00 00	 call	 ?DelAllAIMonsterMovePath@TMonsterAIMovePath@@QAEHXZ ; TMonsterAIMovePath::DelAllAIMonsterMovePath

; 102  : 
; 103  : 						return FALSE;

  00298	33 c0		 xor	 eax, eax
  0029a	eb 5f		 jmp	 SHORT $LN13@LoadData
$LN1@LoadData:

; 104  : 					}
; 105  : 				}
; 106  : 			}

  0029c	e9 a8 fe ff ff	 jmp	 $LN5@LoadData
$LN4@LoadData:

; 107  : 		}

  002a1	e9 6f fe ff ff	 jmp	 $LN8@LoadData
$LN7@LoadData:

; 108  : 
; 109  : 		fclose(SMDFile);

  002a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 _fclose
  002b1	83 c4 04	 add	 esp, 4

; 110  : 
; 111  : 		LogAddC(2, "[Monster AI MovePath ] - %s file is Loaded", lpszFileName);

  002b4	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  002b7	50		 push	 eax
  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MAJLAOIC@?$FLMonster?5AI?5MovePath?5?$FN?5?9?5?$CFs?5file@
  002bd	6a 02		 push	 2
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : 
; 113  : 		this->m_bDataLoad = TRUE;

  002c8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002cb	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 114  : 	}

  002d2	eb 1e		 jmp	 SHORT $LN15@LoadData
__catch$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z$0:

; 115  : 	catch(...)
; 116  : 	{
; 117  : 		MsgBox("[Monster AI MovePath] - Loading Exception Error (%s) File. ", lpszFileName);

  002d4	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  002d7	50		 push	 eax
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HJPPMNFP@?$FLMonster?5AI?5MovePath?$FN?5?9?5Loading?5@
  002dd	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002e2	83 c4 08	 add	 esp, 8

; 118  : 	}

  002e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002ec	b8 00 00 00 00	 mov	 eax, $LN18@LoadData
  002f1	c3		 ret	 0
$LN15@LoadData:
  002f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN18@LoadData:

; 119  : 
; 120  : 	return FALSE;

  002f9	33 c0		 xor	 eax, eax
$LN13@LoadData:

; 121  : }

  002fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00305	59		 pop	 ecx
  00306	5f		 pop	 edi
  00307	5e		 pop	 esi
  00308	5b		 pop	 ebx
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterAIMovePath@@QAEHPAD@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterAIMovePath@@QAEHPAD@Z ENDP		; TMonsterAIMovePath::LoadData
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00319	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0031e	33 c5		 xor	 eax, ebp
  00320	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00323	53		 push	 ebx
  00324	56		 push	 esi
  00325	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00326	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0032d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 _fgetc
  00338	83 c4 04	 add	 esp, 4
  0033b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0033e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00342	83 f9 ff	 cmp	 ecx, -1
  00345	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00347	b8 02 00 00 00	 mov	 eax, 2
  0034c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00351	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00353	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00357	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0035a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0035c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00361	50		 push	 eax
  00362	e8 00 00 00 00	 call	 _fgetc
  00367	83 c4 04	 add	 esp, 4
  0036a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0036d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00371	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00374	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00376	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0037a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0037d	74 1c		 je	 SHORT $LN23@GetToken
  0037f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00383	83 f8 ff	 cmp	 eax, -1
  00386	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00388	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0038d	50		 push	 eax
  0038e	e8 00 00 00 00	 call	 _fgetc
  00393	83 c4 04	 add	 esp, 4
  00396	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00399	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0039b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0039f	83 f8 ff	 cmp	 eax, -1
  003a2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  003a4	b8 02 00 00 00	 mov	 eax, 2
  003a9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  003ae	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003b2	50		 push	 eax
  003b3	e8 00 00 00 00	 call	 _isspace
  003b8	83 c4 04	 add	 esp, 4
  003bb	85 c0		 test	 eax, eax
  003bd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  003c3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003c7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  003cd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  003d3	83 e9 22	 sub	 ecx, 34			; 00000022H
  003d6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  003dc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  003e3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  003e9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  003ef	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  003f6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  003fd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00407	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0040c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00411	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00416	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00420	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00425	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0042a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0042f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00439	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0043e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00443	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00448	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00452	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00457	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0045c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00461	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0046b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00470	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00475	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0047a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0047f	50		 push	 eax
  00480	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00484	51		 push	 ecx
  00485	e8 00 00 00 00	 call	 _ungetc
  0048a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0048d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00490	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00493	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00498	50		 push	 eax
  00499	e8 00 00 00 00	 call	 _getc
  0049e	83 c4 04	 add	 esp, 4
  004a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004a4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004a8	83 f9 ff	 cmp	 ecx, -1
  004ab	74 36		 je	 SHORT $LN12@GetToken
  004ad	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004b1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  004b4	74 1a		 je	 SHORT $LN11@GetToken
  004b6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 _isdigit
  004c0	83 c4 04	 add	 esp, 4
  004c3	85 c0		 test	 eax, eax
  004c5	75 09		 jne	 SHORT $LN11@GetToken
  004c7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004cb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  004ce	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  004d0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004d3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  004d6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  004d8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004db	83 c0 01	 add	 eax, 1
  004de	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  004e1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  004e3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004e6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  004e9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  004ec	50		 push	 eax
  004ed	e8 00 00 00 00	 call	 _atof
  004f2	83 c4 04	 add	 esp, 4
  004f5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  004fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00505	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0050a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0050f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00514	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0051b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00520	50		 push	 eax
  00521	e8 00 00 00 00	 call	 _getc
  00526	83 c4 04	 add	 esp, 4
  00529	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0052c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00530	83 f9 ff	 cmp	 ecx, -1
  00533	74 1c		 je	 SHORT $LN8@GetToken
  00535	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00539	83 f8 22	 cmp	 eax, 34			; 00000022H
  0053c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0053e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00541	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00544	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00546	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00549	83 c0 01	 add	 eax, 1
  0054c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0054f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00551	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00555	83 f8 22	 cmp	 eax, 34			; 00000022H
  00558	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0055a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0055f	50		 push	 eax
  00560	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00564	51		 push	 ecx
  00565	e8 00 00 00 00	 call	 _ungetc
  0056a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0056d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00570	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00573	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0057d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00582	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00587	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0058c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00590	50		 push	 eax
  00591	e8 00 00 00 00	 call	 _isalpha
  00596	83 c4 04	 add	 esp, 4
  00599	85 c0		 test	 eax, eax
  0059b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  005a1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  005a8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005ab	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005ae	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  005b0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005b3	83 c0 01	 add	 eax, 1
  005b6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  005b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005be	50		 push	 eax
  005bf	e8 00 00 00 00	 call	 _getc
  005c4	83 c4 04	 add	 esp, 4
  005c7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005ca	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005ce	83 f9 ff	 cmp	 ecx, -1
  005d1	74 36		 je	 SHORT $LN3@GetToken
  005d3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005d7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  005da	74 1a		 je	 SHORT $LN2@GetToken
  005dc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005e0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  005e3	74 11		 je	 SHORT $LN2@GetToken
  005e5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005e9	50		 push	 eax
  005ea	e8 00 00 00 00	 call	 _isalnum
  005ef	83 c4 04	 add	 esp, 4
  005f2	85 c0		 test	 eax, eax
  005f4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  005f6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005f9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005fc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  005fe	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00601	83 c0 01	 add	 eax, 1
  00604	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00607	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00609	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0060e	50		 push	 eax
  0060f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00613	51		 push	 ecx
  00614	e8 00 00 00 00	 call	 _ungetc
  00619	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0061c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0061f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00622	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0062c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00631	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00633	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00635	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0063f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00644	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00646	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00648	5f		 pop	 edi
  00649	5e		 pop	 esi
  0064a	5b		 pop	 ebx
  0064b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0064e	33 cd		 xor	 ecx, ebp
  00650	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00655	8b e5		 mov	 esp, ebp
  00657	5d		 pop	 ebp
  00658	c3		 ret	 0
  00659	8d 49 00	 npad	 3
$LN35@GetToken:
  0065c	00 00 00 00	 DD	 $LN10@GetToken
  00660	00 00 00 00	 DD	 $LN19@GetToken
  00664	00 00 00 00	 DD	 $LN17@GetToken
  00668	00 00 00 00	 DD	 $LN14@GetToken
  0066c	00 00 00 00	 DD	 $LN18@GetToken
  00670	00 00 00 00	 DD	 $LN16@GetToken
  00674	00 00 00 00	 DD	 $LN15@GetToken
  00678	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0067c	00		 DB	 0
  0067d	01		 DB	 1
  0067e	07		 DB	 7
  0067f	07		 DB	 7
  00680	07		 DB	 7
  00681	07		 DB	 7
  00682	07		 DB	 7
  00683	07		 DB	 7
  00684	07		 DB	 7
  00685	07		 DB	 7
  00686	02		 DB	 2
  00687	03		 DB	 3
  00688	03		 DB	 3
  00689	07		 DB	 7
  0068a	03		 DB	 3
  0068b	03		 DB	 3
  0068c	03		 DB	 3
  0068d	03		 DB	 3
  0068e	03		 DB	 3
  0068f	03		 DB	 3
  00690	03		 DB	 3
  00691	03		 DB	 3
  00692	03		 DB	 3
  00693	03		 DB	 3
  00694	07		 DB	 7
  00695	04		 DB	 4
  00696	07		 DB	 7
  00697	07		 DB	 7
  00698	07		 DB	 7
  00699	07		 DB	 7
  0069a	07		 DB	 7
  0069b	07		 DB	 7
  0069c	07		 DB	 7
  0069d	07		 DB	 7
  0069e	07		 DB	 7
  0069f	07		 DB	 7
  006a0	07		 DB	 7
  006a1	07		 DB	 7
  006a2	07		 DB	 7
  006a3	07		 DB	 7
  006a4	07		 DB	 7
  006a5	07		 DB	 7
  006a6	07		 DB	 7
  006a7	07		 DB	 7
  006a8	07		 DB	 7
  006a9	07		 DB	 7
  006aa	07		 DB	 7
  006ab	07		 DB	 7
  006ac	07		 DB	 7
  006ad	07		 DB	 7
  006ae	07		 DB	 7
  006af	07		 DB	 7
  006b0	07		 DB	 7
  006b1	07		 DB	 7
  006b2	07		 DB	 7
  006b3	07		 DB	 7
  006b4	07		 DB	 7
  006b5	07		 DB	 7
  006b6	07		 DB	 7
  006b7	07		 DB	 7
  006b8	07		 DB	 7
  006b9	07		 DB	 7
  006ba	07		 DB	 7
  006bb	07		 DB	 7
  006bc	07		 DB	 7
  006bd	07		 DB	 7
  006be	07		 DB	 7
  006bf	07		 DB	 7
  006c0	07		 DB	 7
  006c1	07		 DB	 7
  006c2	07		 DB	 7
  006c3	07		 DB	 7
  006c4	07		 DB	 7
  006c5	07		 DB	 7
  006c6	07		 DB	 7
  006c7	07		 DB	 7
  006c8	07		 DB	 7
  006c9	07		 DB	 7
  006ca	07		 DB	 7
  006cb	07		 DB	 7
  006cc	07		 DB	 7
  006cd	07		 DB	 7
  006ce	07		 DB	 7
  006cf	07		 DB	 7
  006d0	07		 DB	 7
  006d1	07		 DB	 7
  006d2	07		 DB	 7
  006d3	07		 DB	 7
  006d4	07		 DB	 7
  006d5	05		 DB	 5
  006d6	07		 DB	 7
  006d7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraimovepath.cpp
_i$204614 = -8						; size = 4
_this$ = -4						; size = 4
?DelAllAIMonsterMovePath@TMonsterAIMovePath@@QAEHXZ PROC ; TMonsterAIMovePath::DelAllAIMonsterMovePath
; _this$ = ecx

; 126  : {

  006e0	55		 push	 ebp
  006e1	8b ec		 mov	 ebp, esp
  006e3	83 ec 48	 sub	 esp, 72			; 00000048H
  006e6	53		 push	 ebx
  006e7	56		 push	 esi
  006e8	57		 push	 edi
  006e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 	for ( int i=0;i<MAX_MONSTER_AI_MOVE_PATH;i++)

  006ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$204614[ebp], 0
  006f3	eb 09		 jmp	 SHORT $LN3@DelAllAIMo
$LN2@DelAllAIMo:
  006f5	8b 45 f8	 mov	 eax, DWORD PTR _i$204614[ebp]
  006f8	83 c0 01	 add	 eax, 1
  006fb	89 45 f8	 mov	 DWORD PTR _i$204614[ebp], eax
$LN3@DelAllAIMo:
  006fe	81 7d f8 2c 01
	00 00		 cmp	 DWORD PTR _i$204614[ebp], 300 ; 0000012cH
  00705	7d 14		 jge	 SHORT $LN1@DelAllAIMo

; 128  : 	{
; 129  : 		this->m_MovePathInfo[i].Reset();

  00707	8b 45 f8	 mov	 eax, DWORD PTR _i$204614[ebp]
  0070a	c1 e0 04	 shl	 eax, 4
  0070d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00710	8d 4c 01 08	 lea	 ecx, DWORD PTR [ecx+eax+8]
  00714	e8 00 00 00 00	 call	 ?Reset@TMonsterAIMovePathInfo@@QAEXXZ ; TMonsterAIMovePathInfo::Reset

; 130  : 	}

  00719	eb da		 jmp	 SHORT $LN2@DelAllAIMo
$LN1@DelAllAIMo:

; 131  : 
; 132  : 	this->m_iMovePathSpotCount = 0;

  0071b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0071e	c7 80 c8 12 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+4808], 0

; 133  : 	this->m_bDataLoad = FALSE;

  00728	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0072b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 134  : 
; 135  : 	return FALSE;

  00732	33 c0		 xor	 eax, eax

; 136  : }

  00734	5f		 pop	 edi
  00735	5e		 pop	 esi
  00736	5b		 pop	 ebx
  00737	8b e5		 mov	 esp, ebp
  00739	5d		 pop	 ebp
  0073a	c3		 ret	 0
?DelAllAIMonsterMovePath@TMonsterAIMovePath@@QAEHXZ ENDP ; TMonsterAIMovePath::DelAllAIMonsterMovePath
_TEXT	ENDS
END
