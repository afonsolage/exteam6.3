; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\CustomBoxDrop.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?sortCustomBoxDrop@@YA_NABUCustomBoxGroup@@0@Z	; sortCustomBoxDrop
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\customboxdrop.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?sortCustomBoxDrop@@YA_NABUCustomBoxGroup@@0@Z PROC	; sortCustomBoxDrop

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11   : 	return a.rate < b.rate;

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	33 c0		 xor	 eax, eax
  00013	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00015	0f 9c c0	 setl	 al

; 12   : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?sortCustomBoxDrop@@YA_NABUCustomBoxGroup@@0@Z ENDP	; sortCustomBoxDrop
_TEXT	ENDS
PUBLIC	??0?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >
PUBLIC	??_7CCustomBoxDrop@@6B@				; CCustomBoxDrop::`vftable'
PUBLIC	??0CCustomBoxDrop@@QAE@XZ			; CCustomBoxDrop::CCustomBoxDrop
PUBLIC	??_R4CCustomBoxDrop@@6B@			; CCustomBoxDrop::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCustomBoxDrop@@@8			; CCustomBoxDrop `RTTI Type Descriptor'
PUBLIC	??_R3CCustomBoxDrop@@8				; CCustomBoxDrop::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCustomBoxDrop@@8				; CCustomBoxDrop::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCustomBoxDrop@@8			; CCustomBoxDrop::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECCustomBoxDrop@@UAEPAXI@Z:PROC		; CCustomBoxDrop::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCustomBoxDrop@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCustomBoxDrop@@8 DD FLAT:??_R0?AVCCustomBoxDrop@@@8 ; CCustomBoxDrop::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCustomBoxDrop@@8
rdata$r	ENDS
;	COMDAT ??_R2CCustomBoxDrop@@8
rdata$r	SEGMENT
??_R2CCustomBoxDrop@@8 DD FLAT:??_R1A@?0A@EA@CCustomBoxDrop@@8 ; CCustomBoxDrop::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CCustomBoxDrop@@8
rdata$r	SEGMENT
??_R3CCustomBoxDrop@@8 DD 00H				; CCustomBoxDrop::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CCustomBoxDrop@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCustomBoxDrop@@@8
_DATA	SEGMENT
??_R0?AVCCustomBoxDrop@@@8 DD FLAT:??_7type_info@@6B@	; CCustomBoxDrop `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCustomBoxDrop@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCustomBoxDrop@@6B@
rdata$r	SEGMENT
??_R4CCustomBoxDrop@@6B@ DD 00H				; CCustomBoxDrop::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCustomBoxDrop@@@8
	DD	FLAT:??_R3CCustomBoxDrop@@8
rdata$r	ENDS
;	COMDAT ??_7CCustomBoxDrop@@6B@
CONST	SEGMENT
??_7CCustomBoxDrop@@6B@ DD FLAT:??_R4CCustomBoxDrop@@6B@ ; CCustomBoxDrop::`vftable'
	DD	FLAT:??_ECCustomBoxDrop@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CCustomBoxDrop@@QAE@XZ PROC				; CCustomBoxDrop::CCustomBoxDrop
; _this$ = ecx

; 16   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCustomBoxDrop@@6B@
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0003e	e8 00 00 00 00	 call	 ??0?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >

; 17   : }

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??0CCustomBoxDrop@@QAE@XZ ENDP				; CCustomBoxDrop::CCustomBoxDrop
_TEXT	ENDS
PUBLIC	??1CCustomBoxDrop@@UAE@XZ			; CCustomBoxDrop::~CCustomBoxDrop
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCCustomBoxDrop@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCustomBoxDrop@@UAEPAXI@Z PROC			; CCustomBoxDrop::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CCustomBoxDrop@@UAE@XZ ; CCustomBoxDrop::~CCustomBoxDrop
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCCustomBoxDrop@@UAEPAXI@Z ENDP			; CCustomBoxDrop::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CCustomBoxDrop@@UAE@XZ PROC				; CCustomBoxDrop::~CCustomBoxDrop
; _this$ = ecx

; 21   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 44	 sub	 esp, 68			; 00000044H
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCustomBoxDrop@@6B@

; 22   : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0006e	e8 00 00 00 00	 call	 ??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
??1CCustomBoxDrop@@UAE@XZ ENDP				; CCustomBoxDrop::~CCustomBoxDrop
_TEXT	ENDS
PUBLIC	?clear@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::clear
PUBLIC	?Init@CCustomBoxDrop@@QAEXXZ			; CCustomBoxDrop::Init
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CCustomBoxDrop@@QAEXXZ PROC			; CCustomBoxDrop::Init
; _this$ = ecx

; 25   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 44	 sub	 esp, 68			; 00000044H
  00086	53		 push	 ebx
  00087	56		 push	 esi
  00088	57		 push	 edi
  00089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 	memset(m_sName, 0, 255);

  0008c	68 ff 00 00 00	 push	 255			; 000000ffH
  00091	6a 00		 push	 0
  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	83 c0 04	 add	 eax, 4
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memset
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27   : 	m_iDropZen = 0;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+264], 0

; 28   : 	m_groups.clear();

  000af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  000b8	e8 00 00 00 00	 call	 ?clear@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::clear

; 29   : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?Init@CCustomBoxDrop@@QAEXXZ ENDP			; CCustomBoxDrop::Init
_TEXT	ENDS
PUBLIC	?back@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::back
PUBLIC	__real@40c3880000000000
PUBLIC	??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
PUBLIC	?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@P6A_NABUCustomBoxGroup@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@0P6A_NABUCustomBoxGroup@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	?begin@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::begin
PUBLIC	?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::end
PUBLIC	?empty@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE_NXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::empty
PUBLIC	??$emplace_back@AAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXAAUCustomBoxGroup@@@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::emplace_back<CustomBoxGroup &>
PUBLIC	??1CustomBoxGroup@@QAE@XZ			; CustomBoxGroup::~CustomBoxGroup
PUBLIC	?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
PUBLIC	?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::push_back
PUBLIC	??$make_pair@AAHAAH@std@@YA?AU?$pair@HH@0@AAH0@Z ; std::make_pair<int &,int &>
PUBLIC	??0CustomBoxGroup@@QAE@XZ			; CustomBoxGroup::CustomBoxGroup
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?LoadItem@CCustomBoxDrop@@QAEXPAD@Z		; CCustomBoxDrop::LoadItem
EXTRN	_fclose:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_strcmp:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z$0
__ehfuncinfo$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
$T230900 = -184						; size = 8
$T230901 = -176						; size = 4
$T230902 = -172						; size = 4
_n$228296 = -104					; size = 4
_lastRate$228295 = -100					; size = 4
_n$228291 = -96						; size = 4
_totalRate$228290 = -92					; size = 4
_item_index$227950 = -88				; size = 4
_item_type$227948 = -84					; size = 4
_group$227932 = -80					; size = 56
_section_type$227918 = -24				; size = 4
_Token$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_script_file$ = 8					; size = 4
?LoadItem@CCustomBoxDrop@@QAEXPAD@Z PROC		; CCustomBoxDrop::LoadItem
; _this$ = ecx

; 32   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	6a ff		 push	 -1
  000d5	68 00 00 00 00	 push	 __ehhandler$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z
  000da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  000e0	50		 push	 eax
  000e1	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  000e7	53		 push	 ebx
  000e8	56		 push	 esi
  000e9	57		 push	 edi
  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000ef	33 c5		 xor	 eax, ebp
  000f1	50		 push	 eax
  000f2	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  000f5	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  000fb	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	this->Init();

  000fe	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	e8 00 00 00 00	 call	 ?Init@CCustomBoxDrop@@QAEXXZ ; CCustomBoxDrop::Init

; 34   : 
; 35   : 	int Token;
; 36   : 
; 37   : 	SMDFile = fopen(gDirPath.GetNewPath(script_file), "r");

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0010b	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  0010e	50		 push	 eax
  0010f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00114	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _fopen
  0011f	83 c4 08	 add	 esp, 8
  00122	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 38   : 
; 39   : 	if (SMDFile == NULL)

  00127	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  0012e	75 22		 jne	 SHORT $LN24@LoadItem

; 40   : 	{
; 41   : 		LogAdd(lMsg.Get(MSGGET(1, 197)), script_file);

  00130	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  00133	50		 push	 eax
  00134	68 c5 01 00 00	 push	 453			; 000001c5H
  00139	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0013e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0014a	83 c4 08	 add	 esp, 8

; 42   : 		return;

  0014d	e9 e9 03 00 00	 jmp	 $LN25@LoadItem
$LN24@LoadItem:

; 43   : 	}
; 44   : 
; 45   : 	while (true)

  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	85 c0		 test	 eax, eax
  00159	0f 84 af 02 00
	00		 je	 $LN22@LoadItem

; 46   : 	{
; 47   : 		Token = GetToken();

  0015f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00164	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 48   : 
; 49   : 		if (Token == END)

  00167	83 7d ec 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0016b	75 05		 jne	 SHORT $LN21@LoadItem

; 50   : 		{
; 51   : 			break;

  0016d	e9 9c 02 00 00	 jmp	 $LN22@LoadItem
$LN21@LoadItem:

; 52   : 		}
; 53   : 
; 54   : 		if (Token == 1)

  00172	83 7d ec 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00176	0f 85 8d 02 00
	00		 jne	 $LN14@LoadItem

; 55   : 		{
; 56   : 			int section_type = (int)TokenNumber;

  0017c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00182	e8 00 00 00 00	 call	 __ftol2_sse
  00187	89 45 e8	 mov	 DWORD PTR _section_type$227918[ebp], eax

; 57   : 
; 58   : 			if (section_type == 1)

  0018a	83 7d e8 01	 cmp	 DWORD PTR _section_type$227918[ebp], 1
  0018e	0f 85 c4 00 00
	00		 jne	 $LN17@LoadItem
$LN18@LoadItem:

; 59   : 			{
; 60   : 				while(true)

  00194	b8 01 00 00 00	 mov	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	0f 84 b7 00 00
	00		 je	 $LN17@LoadItem

; 61   : 				{
; 62   : 					Token = GetToken();

  001a1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001a6	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 63   : 
; 64   : 					if ( Token == 0 )

  001a9	83 7d ec 00	 cmp	 DWORD PTR _Token$[ebp], 0
  001ad	75 1b		 jne	 SHORT $LN15@LoadItem

; 65   : 					{
; 66   : 						if ( strcmp("end", TokenString) == 0 )

  001af	68 00 00 00 00	 push	 OFFSET _TokenString
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  001b9	e8 00 00 00 00	 call	 _strcmp
  001be	83 c4 08	 add	 esp, 8
  001c1	85 c0		 test	 eax, eax
  001c3	75 05		 jne	 SHORT $LN15@LoadItem

; 67   : 						{
; 68   : 							break;

  001c5	e9 8e 00 00 00	 jmp	 $LN17@LoadItem
$LN15@LoadItem:

; 69   : 						}
; 70   : 					}
; 71   : 
; 72   : 					strcpy_s(this->m_sName, 255, TokenString);

  001ca	68 00 00 00 00	 push	 OFFSET _TokenString
  001cf	68 ff 00 00 00	 push	 255			; 000000ffH
  001d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	83 c0 04	 add	 eax, 4
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _strcpy_s
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   : 
; 74   : 					Token = GetToken();

  001e3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001e8	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 75   : 					this->m_iCode = (int)TokenNumber;

  001eb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f1	e8 00 00 00 00	 call	 __ftol2_sse
  001f6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 76   : 
; 77   : 					Token = GetToken();

  001ff	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00204	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 78   : 					this->m_iDropZen = (int)TokenNumber;

  00207	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0020d	e8 00 00 00 00	 call	 __ftol2_sse
  00212	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00215	89 81 08 01 00
	00		 mov	 DWORD PTR [ecx+264], eax

; 79   : 
; 80   : 					Token = GetToken();

  0021b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00220	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 81   : 					this->m_iMinZen = (int)TokenNumber;

  00223	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00229	e8 00 00 00 00	 call	 __ftol2_sse
  0022e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	89 81 0c 01 00
	00		 mov	 DWORD PTR [ecx+268], eax

; 82   : 
; 83   : 					Token = GetToken();

  00237	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0023c	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 84   : 					this->m_iMaxZen = (int)TokenNumber;

  0023f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00245	e8 00 00 00 00	 call	 __ftol2_sse
  0024a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	89 81 10 01 00
	00		 mov	 DWORD PTR [ecx+272], eax

; 85   : 				}

  00253	e9 3c ff ff ff	 jmp	 $LN18@LoadItem
$LN17@LoadItem:

; 86   : 			}
; 87   : 
; 88   : 			if (section_type == 2)

  00258	83 7d e8 02	 cmp	 DWORD PTR _section_type$227918[ebp], 2
  0025c	0f 85 a7 01 00
	00		 jne	 $LN14@LoadItem

; 89   : 			{
; 90   : 				CustomBoxGroup group;

  00262	8d 4d b0	 lea	 ecx, DWORD PTR _group$227932[ebp]
  00265	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@XZ
  0026a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 
; 92   : 				Token = GetToken();

  00271	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00276	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 93   : 				group.rate = (int)TokenNumber;

  00279	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0027f	e8 00 00 00 00	 call	 __ftol2_sse
  00284	89 45 b0	 mov	 DWORD PTR _group$227932[ebp], eax

; 94   : 				Token = GetToken();

  00287	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0028c	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 95   : 				group.min_lvl = (int)TokenNumber;

  0028f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00295	e8 00 00 00 00	 call	 __ftol2_sse
  0029a	89 45 b4	 mov	 DWORD PTR _group$227932[ebp+4], eax

; 96   : 				Token = GetToken();

  0029d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002a2	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 97   : 				group.max_lvl = (int)TokenNumber;

  002a5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002ab	e8 00 00 00 00	 call	 __ftol2_sse
  002b0	89 45 b8	 mov	 DWORD PTR _group$227932[ebp+8], eax

; 98   : 				Token = GetToken();

  002b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002b8	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 99   : 				group.skill_rate = (int)TokenNumber;

  002bb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002c1	e8 00 00 00 00	 call	 __ftol2_sse
  002c6	89 45 bc	 mov	 DWORD PTR _group$227932[ebp+12], eax

; 100  : 				Token = GetToken();

  002c9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002ce	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 101  : 				group.luck_rate = (int)TokenNumber;

  002d1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002d7	e8 00 00 00 00	 call	 __ftol2_sse
  002dc	89 45 c0	 mov	 DWORD PTR _group$227932[ebp+16], eax

; 102  : 				Token = GetToken();

  002df	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002e4	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 103  : 				group.opt4_rate = (int)TokenNumber;

  002e7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002ed	e8 00 00 00 00	 call	 __ftol2_sse
  002f2	89 45 c4	 mov	 DWORD PTR _group$227932[ebp+20], eax

; 104  : 				Token = GetToken();

  002f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002fa	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 105  : 				group.opt8_rate = (int)TokenNumber;

  002fd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00303	e8 00 00 00 00	 call	 __ftol2_sse
  00308	89 45 c8	 mov	 DWORD PTR _group$227932[ebp+24], eax

; 106  : 				Token = GetToken();

  0030b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00310	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 107  : 				group.opt12_rate = (int)TokenNumber;

  00313	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00319	e8 00 00 00 00	 call	 __ftol2_sse
  0031e	89 45 cc	 mov	 DWORD PTR _group$227932[ebp+28], eax

; 108  : 				Token = GetToken();

  00321	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00326	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 109  : 				group.opt16_rate= (int)TokenNumber;

  00329	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0032f	e8 00 00 00 00	 call	 __ftol2_sse
  00334	89 45 d0	 mov	 DWORD PTR _group$227932[ebp+32], eax

; 110  : 				Token = GetToken();

  00337	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0033c	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 111  : 				group.exc_rate = (int)TokenNumber;

  0033f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00345	e8 00 00 00 00	 call	 __ftol2_sse
  0034a	89 45 d4	 mov	 DWORD PTR _group$227932[ebp+36], eax
$LN13@LoadItem:

; 112  : 
; 113  : 				while(true)

  0034d	b8 01 00 00 00	 mov	 eax, 1
  00352	85 c0		 test	 eax, eax
  00354	74 6c		 je	 SHORT $LN12@LoadItem

; 114  : 				{
; 115  : 					Token = GetToken();

  00356	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0035b	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 116  : 
; 117  : 					if ( Token == 0 )

  0035e	83 7d ec 00	 cmp	 DWORD PTR _Token$[ebp], 0
  00362	75 18		 jne	 SHORT $LN10@LoadItem

; 118  : 					{
; 119  : 						if ( strcmp("end", TokenString) == 0 )

  00364	68 00 00 00 00	 push	 OFFSET _TokenString
  00369	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0036e	e8 00 00 00 00	 call	 _strcmp
  00373	83 c4 08	 add	 esp, 8
  00376	85 c0		 test	 eax, eax
  00378	75 02		 jne	 SHORT $LN10@LoadItem

; 120  : 						{
; 121  : 							break;

  0037a	eb 46		 jmp	 SHORT $LN12@LoadItem
$LN10@LoadItem:

; 122  : 						}
; 123  : 					}
; 124  : 
; 125  : 					int item_type = (int)TokenNumber;

  0037c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00382	e8 00 00 00 00	 call	 __ftol2_sse
  00387	89 45 ac	 mov	 DWORD PTR _item_type$227948[ebp], eax

; 126  : 					Token = GetToken();

  0038a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0038f	89 45 ec	 mov	 DWORD PTR _Token$[ebp], eax

; 127  : 					int item_index = (int)TokenNumber;

  00392	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00398	e8 00 00 00 00	 call	 __ftol2_sse
  0039d	89 45 a8	 mov	 DWORD PTR _item_index$227950[ebp], eax

; 128  : 
; 129  : 					group.items.push_back(std::make_pair(item_type, item_index));

  003a0	8d 45 a8	 lea	 eax, DWORD PTR _item_index$227950[ebp]
  003a3	50		 push	 eax
  003a4	8d 4d ac	 lea	 ecx, DWORD PTR _item_type$227948[ebp]
  003a7	51		 push	 ecx
  003a8	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T230900[ebp]
  003ae	52		 push	 edx
  003af	e8 00 00 00 00	 call	 ??$make_pair@AAHAAH@std@@YA?AU?$pair@HH@0@AAH0@Z ; std::make_pair<int &,int &>
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b7	50		 push	 eax
  003b8	8d 4d d8	 lea	 ecx, DWORD PTR _group$227932[ebp+40]
  003bb	e8 00 00 00 00	 call	 ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::push_back

; 130  : 				}

  003c0	eb 8b		 jmp	 SHORT $LN13@LoadItem
$LN12@LoadItem:

; 131  : 
; 132  : 				if (group.rate == 0 || group.items.size() == 0)

  003c2	83 7d b0 00	 cmp	 DWORD PTR _group$227932[ebp], 0
  003c6	74 0c		 je	 SHORT $LN8@LoadItem
  003c8	8d 4d d8	 lea	 ecx, DWORD PTR _group$227932[ebp+40]
  003cb	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  003d0	85 c0		 test	 eax, eax
  003d2	75 14		 jne	 SHORT $LN9@LoadItem
$LN8@LoadItem:

; 133  : 					continue;

  003d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003db	8d 4d b0	 lea	 ecx, DWORD PTR _group$227932[ebp]
  003de	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
  003e3	e9 6a fd ff ff	 jmp	 $LN24@LoadItem
$LN9@LoadItem:

; 134  : 
; 135  : 				this->m_groups.emplace_back(group);

  003e8	8d 45 b0	 lea	 eax, DWORD PTR _group$227932[ebp]
  003eb	50		 push	 eax
  003ec	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  003f5	e8 00 00 00 00	 call	 ??$emplace_back@AAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXAAUCustomBoxGroup@@@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::emplace_back<CustomBoxGroup &>

; 136  : 			}

  003fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00401	8d 4d b0	 lea	 ecx, DWORD PTR _group$227932[ebp]
  00404	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
$LN14@LoadItem:

; 137  : 		}
; 138  : 	}

  00409	e9 44 fd ff ff	 jmp	 $LN24@LoadItem
$LN22@LoadItem:

; 139  : 
; 140  : 	if (!this->m_groups.empty())

  0040e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00411	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00417	e8 00 00 00 00	 call	 ?empty@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE_NXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::empty
  0041c	0f b6 c0	 movzx	 eax, al
  0041f	85 c0		 test	 eax, eax
  00421	0f 85 06 01 00
	00		 jne	 $LN7@LoadItem

; 141  : 	{
; 142  : 		std::sort(this->m_groups.begin(), this->m_groups.end(), sortCustomBoxDrop);

  00427	68 00 00 00 00	 push	 OFFSET ?sortCustomBoxDrop@@YA_NABUCustomBoxGroup@@0@Z ; sortCustomBoxDrop
  0042c	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T230901[ebp]
  00432	50		 push	 eax
  00433	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00436	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0043c	e8 00 00 00 00	 call	 ?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::end
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	51		 push	 ecx
  00444	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T230902[ebp]
  0044a	52		 push	 edx
  0044b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0044e	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00454	e8 00 00 00 00	 call	 ?begin@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::begin
  00459	8b 00		 mov	 eax, DWORD PTR [eax]
  0045b	50		 push	 eax
  0045c	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@P6A_NABUCustomBoxGroup@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@0P6A_NABUCustomBoxGroup@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00461	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  : 
; 144  : 		int totalRate = 0;

  00464	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _totalRate$228290[ebp], 0

; 145  : 		for(int n = 0; n < this->m_groups.size(); n++)

  0046b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _n$228291[ebp], 0
  00472	eb 09		 jmp	 SHORT $LN6@LoadItem
$LN5@LoadItem:
  00474	8b 45 a0	 mov	 eax, DWORD PTR _n$228291[ebp]
  00477	83 c0 01	 add	 eax, 1
  0047a	89 45 a0	 mov	 DWORD PTR _n$228291[ebp], eax
$LN6@LoadItem:
  0047d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00480	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00486	e8 00 00 00 00	 call	 ?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
  0048b	39 45 a0	 cmp	 DWORD PTR _n$228291[ebp], eax
  0048e	73 1c		 jae	 SHORT $LN4@LoadItem

; 146  : 		{
; 147  : 			totalRate += this->m_groups[n].rate;

  00490	8b 45 a0	 mov	 eax, DWORD PTR _n$228291[ebp]
  00493	50		 push	 eax
  00494	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00497	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0049d	e8 00 00 00 00	 call	 ??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
  004a2	8b 4d a4	 mov	 ecx, DWORD PTR _totalRate$228290[ebp]
  004a5	03 08		 add	 ecx, DWORD PTR [eax]
  004a7	89 4d a4	 mov	 DWORD PTR _totalRate$228290[ebp], ecx

; 148  : 		}

  004aa	eb c8		 jmp	 SHORT $LN5@LoadItem
$LN4@LoadItem:

; 149  : 
; 150  : 		//Recompute the indivual rate of group
; 151  : 		int lastRate = 0;

  004ac	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _lastRate$228295[ebp], 0

; 152  : 		for(int n = 0; n < this->m_groups.size(); n++)

  004b3	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _n$228296[ebp], 0
  004ba	eb 09		 jmp	 SHORT $LN3@LoadItem
$LN2@LoadItem:
  004bc	8b 45 98	 mov	 eax, DWORD PTR _n$228296[ebp]
  004bf	83 c0 01	 add	 eax, 1
  004c2	89 45 98	 mov	 DWORD PTR _n$228296[ebp], eax
$LN3@LoadItem:
  004c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  004c8	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  004ce	e8 00 00 00 00	 call	 ?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
  004d3	39 45 98	 cmp	 DWORD PTR _n$228296[ebp], eax
  004d6	73 41		 jae	 SHORT $LN1@LoadItem

; 153  : 		{
; 154  : 			lastRate= (int)(((float)this->m_groups[n].rate / (float)totalRate) * 10000) + lastRate;

  004d8	8b 45 98	 mov	 eax, DWORD PTR _n$228296[ebp]
  004db	50		 push	 eax
  004dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  004df	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  004e5	e8 00 00 00 00	 call	 ??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
  004ea	db 00		 fild	 DWORD PTR [eax]
  004ec	da 75 a4	 fidiv	 DWORD PTR _totalRate$228290[ebp]
  004ef	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@40c3880000000000
  004f5	e8 00 00 00 00	 call	 __ftol2_sse
  004fa	03 45 9c	 add	 eax, DWORD PTR _lastRate$228295[ebp]
  004fd	89 45 9c	 mov	 DWORD PTR _lastRate$228295[ebp], eax

; 155  : 			this->m_groups[n].rate = lastRate;

  00500	8b 45 98	 mov	 eax, DWORD PTR _n$228296[ebp]
  00503	50		 push	 eax
  00504	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00507	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0050d	e8 00 00 00 00	 call	 ??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
  00512	8b 4d 9c	 mov	 ecx, DWORD PTR _lastRate$228295[ebp]
  00515	89 08		 mov	 DWORD PTR [eax], ecx

; 156  : 		}

  00517	eb a3		 jmp	 SHORT $LN2@LoadItem
$LN1@LoadItem:

; 157  : 
; 158  : 		this->m_groups.back().rate = 10000;

  00519	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0051c	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00522	e8 00 00 00 00	 call	 ?back@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::back
  00527	c7 00 10 27 00
	00		 mov	 DWORD PTR [eax], 10000	; 00002710H
$LN7@LoadItem:

; 159  : 	}
; 160  : 
; 161  : 	fclose(SMDFile);

  0052d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00532	50		 push	 eax
  00533	e8 00 00 00 00	 call	 _fclose
  00538	83 c4 04	 add	 esp, 4
$LN25@LoadItem:

; 162  : }

  0053b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0053e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00545	59		 pop	 ecx
  00546	5f		 pop	 edi
  00547	5e		 pop	 esi
  00548	5b		 pop	 ebx
  00549	8b e5		 mov	 esp, ebp
  0054b	5d		 pop	 ebp
  0054c	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _group$227932[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CustomBoxGroup@@QAE@XZ
__ehhandler$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadItem@CCustomBoxDrop@@QAEXPAD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadItem@CCustomBoxDrop@@QAEXPAD@Z ENDP		; CCustomBoxDrop::LoadItem
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00550	55		 push	 ebp
  00551	8b ec		 mov	 ebp, esp
  00553	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00559	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0055e	33 c5		 xor	 eax, ebp
  00560	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00563	53		 push	 ebx
  00564	56		 push	 esi
  00565	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00566	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0056d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00572	50		 push	 eax
  00573	e8 00 00 00 00	 call	 _fgetc
  00578	83 c4 04	 add	 esp, 4
  0057b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0057e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00582	83 f9 ff	 cmp	 ecx, -1
  00585	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00587	b8 02 00 00 00	 mov	 eax, 2
  0058c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00591	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00593	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00597	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0059a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0059c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005a1	50		 push	 eax
  005a2	e8 00 00 00 00	 call	 _fgetc
  005a7	83 c4 04	 add	 esp, 4
  005aa	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005ad	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005b1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  005b4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  005b6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005ba	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  005bd	74 1c		 je	 SHORT $LN23@GetToken
  005bf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005c3	83 f8 ff	 cmp	 eax, -1
  005c6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  005c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005cd	50		 push	 eax
  005ce	e8 00 00 00 00	 call	 _fgetc
  005d3	83 c4 04	 add	 esp, 4
  005d6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  005d9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  005db	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005df	83 f8 ff	 cmp	 eax, -1
  005e2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  005e4	b8 02 00 00 00	 mov	 eax, 2
  005e9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  005ee	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005f2	50		 push	 eax
  005f3	e8 00 00 00 00	 call	 _isspace
  005f8	83 c4 04	 add	 esp, 4
  005fb	85 c0		 test	 eax, eax
  005fd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00603	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00607	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0060d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00613	83 e9 22	 sub	 ecx, 34			; 00000022H
  00616	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0061c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00623	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00629	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0062f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00636	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0063d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00647	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0064c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00651	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00656	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00660	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00665	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0066a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0066f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00679	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0067e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00683	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00688	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00692	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00697	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0069c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  006a1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  006ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006b0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  006b5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  006ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006bf	50		 push	 eax
  006c0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006c4	51		 push	 ecx
  006c5	e8 00 00 00 00	 call	 _ungetc
  006ca	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  006cd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  006d0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  006d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006d8	50		 push	 eax
  006d9	e8 00 00 00 00	 call	 _getc
  006de	83 c4 04	 add	 esp, 4
  006e1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  006e4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006e8	83 f9 ff	 cmp	 ecx, -1
  006eb	74 36		 je	 SHORT $LN12@GetToken
  006ed	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006f1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  006f4	74 1a		 je	 SHORT $LN11@GetToken
  006f6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006fa	50		 push	 eax
  006fb	e8 00 00 00 00	 call	 _isdigit
  00700	83 c4 04	 add	 esp, 4
  00703	85 c0		 test	 eax, eax
  00705	75 09		 jne	 SHORT $LN11@GetToken
  00707	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0070b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0070e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00710	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00713	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00716	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00718	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0071b	83 c0 01	 add	 eax, 1
  0071e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00721	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00723	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00726	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00729	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0072c	50		 push	 eax
  0072d	e8 00 00 00 00	 call	 _atof
  00732	83 c4 04	 add	 esp, 4
  00735	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0073b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00745	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0074a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0074f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00754	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0075b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00760	50		 push	 eax
  00761	e8 00 00 00 00	 call	 _getc
  00766	83 c4 04	 add	 esp, 4
  00769	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0076c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00770	83 f9 ff	 cmp	 ecx, -1
  00773	74 1c		 je	 SHORT $LN8@GetToken
  00775	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00779	83 f8 22	 cmp	 eax, 34			; 00000022H
  0077c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0077e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00781	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00784	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00786	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00789	83 c0 01	 add	 eax, 1
  0078c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0078f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00791	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00795	83 f8 22	 cmp	 eax, 34			; 00000022H
  00798	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0079a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0079f	50		 push	 eax
  007a0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  007a4	51		 push	 ecx
  007a5	e8 00 00 00 00	 call	 _ungetc
  007aa	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  007ad	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  007b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  007bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007c2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  007c7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  007cc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  007d0	50		 push	 eax
  007d1	e8 00 00 00 00	 call	 _isalpha
  007d6	83 c4 04	 add	 esp, 4
  007d9	85 c0		 test	 eax, eax
  007db	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  007e1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  007e8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007eb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  007ee	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  007f0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007f3	83 c0 01	 add	 eax, 1
  007f6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  007f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007fe	50		 push	 eax
  007ff	e8 00 00 00 00	 call	 _getc
  00804	83 c4 04	 add	 esp, 4
  00807	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0080a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0080e	83 f9 ff	 cmp	 ecx, -1
  00811	74 36		 je	 SHORT $LN3@GetToken
  00813	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00817	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0081a	74 1a		 je	 SHORT $LN2@GetToken
  0081c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00820	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00823	74 11		 je	 SHORT $LN2@GetToken
  00825	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00829	50		 push	 eax
  0082a	e8 00 00 00 00	 call	 _isalnum
  0082f	83 c4 04	 add	 esp, 4
  00832	85 c0		 test	 eax, eax
  00834	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00836	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00839	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0083c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0083e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00841	83 c0 01	 add	 eax, 1
  00844	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00847	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00849	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0084e	50		 push	 eax
  0084f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00853	51		 push	 ecx
  00854	e8 00 00 00 00	 call	 _ungetc
  00859	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0085c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0085f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00862	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0086c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00871	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00873	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00875	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0087f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00884	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00886	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00888	5f		 pop	 edi
  00889	5e		 pop	 esi
  0088a	5b		 pop	 ebx
  0088b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0088e	33 cd		 xor	 ecx, ebp
  00890	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00895	8b e5		 mov	 esp, ebp
  00897	5d		 pop	 ebp
  00898	c3		 ret	 0
  00899	8d 49 00	 npad	 3
$LN35@GetToken:
  0089c	00 00 00 00	 DD	 $LN10@GetToken
  008a0	00 00 00 00	 DD	 $LN19@GetToken
  008a4	00 00 00 00	 DD	 $LN17@GetToken
  008a8	00 00 00 00	 DD	 $LN14@GetToken
  008ac	00 00 00 00	 DD	 $LN18@GetToken
  008b0	00 00 00 00	 DD	 $LN16@GetToken
  008b4	00 00 00 00	 DD	 $LN15@GetToken
  008b8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  008bc	00		 DB	 0
  008bd	01		 DB	 1
  008be	07		 DB	 7
  008bf	07		 DB	 7
  008c0	07		 DB	 7
  008c1	07		 DB	 7
  008c2	07		 DB	 7
  008c3	07		 DB	 7
  008c4	07		 DB	 7
  008c5	07		 DB	 7
  008c6	02		 DB	 2
  008c7	03		 DB	 3
  008c8	03		 DB	 3
  008c9	07		 DB	 7
  008ca	03		 DB	 3
  008cb	03		 DB	 3
  008cc	03		 DB	 3
  008cd	03		 DB	 3
  008ce	03		 DB	 3
  008cf	03		 DB	 3
  008d0	03		 DB	 3
  008d1	03		 DB	 3
  008d2	03		 DB	 3
  008d3	03		 DB	 3
  008d4	07		 DB	 7
  008d5	04		 DB	 4
  008d6	07		 DB	 7
  008d7	07		 DB	 7
  008d8	07		 DB	 7
  008d9	07		 DB	 7
  008da	07		 DB	 7
  008db	07		 DB	 7
  008dc	07		 DB	 7
  008dd	07		 DB	 7
  008de	07		 DB	 7
  008df	07		 DB	 7
  008e0	07		 DB	 7
  008e1	07		 DB	 7
  008e2	07		 DB	 7
  008e3	07		 DB	 7
  008e4	07		 DB	 7
  008e5	07		 DB	 7
  008e6	07		 DB	 7
  008e7	07		 DB	 7
  008e8	07		 DB	 7
  008e9	07		 DB	 7
  008ea	07		 DB	 7
  008eb	07		 DB	 7
  008ec	07		 DB	 7
  008ed	07		 DB	 7
  008ee	07		 DB	 7
  008ef	07		 DB	 7
  008f0	07		 DB	 7
  008f1	07		 DB	 7
  008f2	07		 DB	 7
  008f3	07		 DB	 7
  008f4	07		 DB	 7
  008f5	07		 DB	 7
  008f6	07		 DB	 7
  008f7	07		 DB	 7
  008f8	07		 DB	 7
  008f9	07		 DB	 7
  008fa	07		 DB	 7
  008fb	07		 DB	 7
  008fc	07		 DB	 7
  008fd	07		 DB	 7
  008fe	07		 DB	 7
  008ff	07		 DB	 7
  00900	07		 DB	 7
  00901	07		 DB	 7
  00902	07		 DB	 7
  00903	07		 DB	 7
  00904	07		 DB	 7
  00905	07		 DB	 7
  00906	07		 DB	 7
  00907	07		 DB	 7
  00908	07		 DB	 7
  00909	07		 DB	 7
  0090a	07		 DB	 7
  0090b	07		 DB	 7
  0090c	07		 DB	 7
  0090d	07		 DB	 7
  0090e	07		 DB	 7
  0090f	07		 DB	 7
  00910	07		 DB	 7
  00911	07		 DB	 7
  00912	07		 DB	 7
  00913	07		 DB	 7
  00914	07		 DB	 7
  00915	05		 DB	 5
  00916	07		 DB	 7
  00917	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0CustomBoxGroup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CustomBoxGroup@@QAE@XZ PROC				; CustomBoxGroup::CustomBoxGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 28	 add	 ecx, 40			; 00000028H
  00012	e8 00 00 00 00	 call	 ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CustomBoxGroup@@QAE@XZ ENDP				; CustomBoxGroup::CustomBoxGroup
_TEXT	ENDS
PUBLIC	??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1CustomBoxGroup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CustomBoxGroup@@QAE@XZ PROC				; CustomBoxGroup::~CustomBoxGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 28	 add	 ecx, 40			; 00000028H
  00012	e8 00 00 00 00	 call	 ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1CustomBoxGroup@@QAE@XZ ENDP				; CustomBoxGroup::~CustomBoxGroup
_TEXT	ENDS
PUBLIC	?GetGroup@CCustomBoxDrop@@AAEPAUCustomBoxGroup@@H@Z ; CCustomBoxDrop::GetGroup
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\customboxdrop.cpp
_TEXT	SEGMENT
_n$228311 = -8						; size = 4
_this$ = -4						; size = 4
_rnd$ = 8						; size = 4
?GetGroup@CCustomBoxDrop@@AAEPAUCustomBoxGroup@@H@Z PROC ; CCustomBoxDrop::GetGroup
; _this$ = ecx

; 165  : {

  00920	55		 push	 ebp
  00921	8b ec		 mov	 ebp, esp
  00923	83 ec 48	 sub	 esp, 72			; 00000048H
  00926	53		 push	 ebx
  00927	56		 push	 esi
  00928	57		 push	 edi
  00929	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 	for(int n = 0; n < m_groups.size(); n++)

  0092c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$228311[ebp], 0
  00933	eb 09		 jmp	 SHORT $LN4@GetGroup
$LN3@GetGroup:
  00935	8b 45 f8	 mov	 eax, DWORD PTR _n$228311[ebp]
  00938	83 c0 01	 add	 eax, 1
  0093b	89 45 f8	 mov	 DWORD PTR _n$228311[ebp], eax
$LN4@GetGroup:
  0093e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00941	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00947	e8 00 00 00 00	 call	 ?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
  0094c	39 45 f8	 cmp	 DWORD PTR _n$228311[ebp], eax
  0094f	73 2f		 jae	 SHORT $LN2@GetGroup

; 167  : 	{
; 168  : 		if (rnd < m_groups[n].rate)

  00951	8b 45 f8	 mov	 eax, DWORD PTR _n$228311[ebp]
  00954	50		 push	 eax
  00955	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00958	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0095e	e8 00 00 00 00	 call	 ??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
  00963	8b 4d 08	 mov	 ecx, DWORD PTR _rnd$[ebp]
  00966	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00968	7d 14		 jge	 SHORT $LN1@GetGroup

; 169  : 		{
; 170  : 			return &m_groups[n];

  0096a	8b 45 f8	 mov	 eax, DWORD PTR _n$228311[ebp]
  0096d	50		 push	 eax
  0096e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00971	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00977	e8 00 00 00 00	 call	 ??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
  0097c	eb 10		 jmp	 SHORT $LN5@GetGroup
$LN1@GetGroup:

; 171  : 		}
; 172  : 	}

  0097e	eb b5		 jmp	 SHORT $LN3@GetGroup
$LN2@GetGroup:

; 173  : 
; 174  : 	return &m_groups.back();

  00980	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00983	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00989	e8 00 00 00 00	 call	 ?back@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::back
$LN5@GetGroup:

; 175  : }

  0098e	5f		 pop	 edi
  0098f	5e		 pop	 esi
  00990	5b		 pop	 ebx
  00991	8b e5		 mov	 esp, ebp
  00993	5d		 pop	 ebp
  00994	c2 04 00	 ret	 4
?GetGroup@CCustomBoxDrop@@AAEPAUCustomBoxGroup@@H@Z ENDP ; CCustomBoxDrop::GetGroup
_TEXT	ENDS
PUBLIC	?RndRange@CCustomBoxDrop@@AAEHHH@Z		; CCustomBoxDrop::RndRange
EXTRN	_rand:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?RndRange@CCustomBoxDrop@@AAEHHH@Z PROC			; CCustomBoxDrop::RndRange
; _this$ = ecx

; 178  : {

  009a0	55		 push	 ebp
  009a1	8b ec		 mov	 ebp, esp
  009a3	83 ec 44	 sub	 esp, 68			; 00000044H
  009a6	53		 push	 ebx
  009a7	56		 push	 esi
  009a8	57		 push	 edi
  009a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : 	 return (rand() % ((max - min) + 1)) + min;

  009ac	e8 00 00 00 00	 call	 _rand
  009b1	8b 4d 0c	 mov	 ecx, DWORD PTR _max$[ebp]
  009b4	2b 4d 08	 sub	 ecx, DWORD PTR _min$[ebp]
  009b7	83 c1 01	 add	 ecx, 1
  009ba	99		 cdq
  009bb	f7 f9		 idiv	 ecx
  009bd	03 55 08	 add	 edx, DWORD PTR _min$[ebp]
  009c0	8b c2		 mov	 eax, edx

; 180  : }

  009c2	5f		 pop	 edi
  009c3	5e		 pop	 esi
  009c4	5b		 pop	 ebx
  009c5	8b e5		 mov	 esp, ebp
  009c7	5d		 pop	 ebp
  009c8	c2 08 00	 ret	 8
?RndRange@CCustomBoxDrop@@AAEHHH@Z ENDP			; CCustomBoxDrop::RndRange
_TEXT	ENDS
PUBLIC	?IsProcRnd@CCustomBoxDrop@@AAEHHH@Z		; CCustomBoxDrop::IsProcRnd
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_proc$ = 8						; size = 4
_max$ = 12						; size = 4
?IsProcRnd@CCustomBoxDrop@@AAEHHH@Z PROC		; CCustomBoxDrop::IsProcRnd
; _this$ = ecx

; 183  : {

  009d0	55		 push	 ebp
  009d1	8b ec		 mov	 ebp, esp
  009d3	83 ec 44	 sub	 esp, 68			; 00000044H
  009d6	53		 push	 ebx
  009d7	56		 push	 esi
  009d8	57		 push	 edi
  009d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	return rand() % max < proc;

  009dc	e8 00 00 00 00	 call	 _rand
  009e1	99		 cdq
  009e2	f7 7d 0c	 idiv	 DWORD PTR _max$[ebp]
  009e5	33 c0		 xor	 eax, eax
  009e7	3b 55 08	 cmp	 edx, DWORD PTR _proc$[ebp]
  009ea	0f 9c c0	 setl	 al

; 185  : }

  009ed	5f		 pop	 edi
  009ee	5e		 pop	 esi
  009ef	5b		 pop	 ebx
  009f0	8b e5		 mov	 esp, ebp
  009f2	5d		 pop	 ebp
  009f3	c2 08 00	 ret	 8
?IsProcRnd@CCustomBoxDrop@@AAEHHH@Z ENDP		; CCustomBoxDrop::IsProcRnd
_TEXT	ENDS
PUBLIC	??_C@_0FI@OCLOLHIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@ ; `string'
PUBLIC	__real@00000000
PUBLIC	?GetRandomItem@CustomBoxGroup@@QAE?AU?$pair@HH@std@@XZ ; CustomBoxGroup::GetRandomItem
PUBLIC	??_C@_0EG@HLFBCKGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DropItem@CCustomBoxDrop@@QAEHPAUOBJECTSTRUCT@@@Z ; CCustomBoxDrop::DropItem
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z:PROC	; CItem::Convert
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	_srand:PROC
EXTRN	?LuckboxItemBag@@3PAVCItemBag@@A:DWORD		; LuckboxItemBag
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0FI@OCLOLHIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@
CONST	SEGMENT
??_C@_0FI@OCLOLHIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@ DB '['
	DB	'%s][%s][CustomBoxDrop][%s] : (%d)(X:%d/Y:%d) Item:%s(%d) Leve'
	DB	'l:%d Op1:%d Op2:%d Op3:%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0EG@HLFBCKGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@
CONST	SEGMENT
??_C@_0EG@HLFBCKGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@ DB '['
	DB	'%s][%s][CustomBoxDrop][%s] : (%d)(X:%d/Y:%d) Invalid group at'
	DB	' rnd %d', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv366 = -360						; size = 4
tv364 = -356						; size = 4
tv361 = -350						; size = 2
_EventItem$ = -284					; size = 212
_optRnd$ = -72						; size = 4
_item$ = -68						; size = 8
_lpGroup$ = -60						; size = 4
_zen$228344 = -56					; size = 4
_rnd$ = -52						; size = 4
_v$ = -48						; size = 4
_Option3$ = -40						; size = 4
_Option2$ = -36						; size = 4
_Option1$ = -32						; size = 4
_y$ = -28						; size = 4
_x$ = -24						; size = 4
_level$ = -20						; size = 4
_type$ = -16						; size = 4
_dur$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DropItem@CCustomBoxDrop@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CCustomBoxDrop::DropItem
; _this$ = ecx

; 188  : {

  00a00	55		 push	 ebp
  00a01	8b ec		 mov	 ebp, esp
  00a03	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00a09	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00a0e	33 c5		 xor	 eax, ebp
  00a10	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00a13	53		 push	 ebx
  00a14	56		 push	 esi
  00a15	57		 push	 edi
  00a16	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 	float dur;
; 190  : 	int type;
; 191  : 	int level;
; 192  : 	int x;
; 193  : 	int y;
; 194  : 	int Option1=0;

  00a19	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 195  : 	int Option2=0;

  00a20	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 196  : 	int Option3=0;

  00a27	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 197  : 	int DropItemNum;
; 198  : 
; 199  : 	if ( !LuckboxItemBag )

  00a2e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A, 0 ; LuckboxItemBag
  00a35	75 07		 jne	 SHORT $LN12@DropItem

; 200  : 		return FALSE;

  00a37	33 c0		 xor	 eax, eax
  00a39	e9 7e 03 00 00	 jmp	 $LN13@DropItem
$LN12@DropItem:

; 201  : 
; 202  : 	srand((unsigned int)(time(NULL) * lpObj->m_Index));

  00a3e	6a 00		 push	 0
  00a40	e8 00 00 00 00	 call	 _time
  00a45	83 c4 04	 add	 esp, 4
  00a48	8b c8		 mov	 ecx, eax
  00a4a	8b f2		 mov	 esi, edx
  00a4c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a4f	8b 02		 mov	 eax, DWORD PTR [edx]
  00a51	99		 cdq
  00a52	52		 push	 edx
  00a53	50		 push	 eax
  00a54	56		 push	 esi
  00a55	51		 push	 ecx
  00a56	e8 00 00 00 00	 call	 __allmul
  00a5b	50		 push	 eax
  00a5c	e8 00 00 00 00	 call	 _srand
  00a61	83 c4 04	 add	 esp, 4

; 203  : 
; 204  : 	int v = rand();

  00a64	e8 00 00 00 00	 call	 _rand
  00a69	89 45 d0	 mov	 DWORD PTR _v$[ebp], eax

; 205  : 
; 206  : 	int rnd = v%10000;

  00a6c	8b 45 d0	 mov	 eax, DWORD PTR _v$[ebp]
  00a6f	99		 cdq
  00a70	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00a75	f7 f9		 idiv	 ecx
  00a77	89 55 cc	 mov	 DWORD PTR _rnd$[ebp], edx

; 207  : 
; 208  : 	if (m_iDropZen > 0 && rnd < m_iDropZen)

  00a7a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a7d	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00a84	0f 8e a8 00 00
	00		 jle	 $LN11@DropItem
  00a8a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a8d	8b 4d cc	 mov	 ecx, DWORD PTR _rnd$[ebp]
  00a90	3b 88 08 01 00
	00		 cmp	 ecx, DWORD PTR [eax+264]
  00a96	0f 8d 96 00 00
	00		 jge	 $LN11@DropItem

; 209  : 	{
; 210  : 		int zen = this->RndRange(m_iMinZen, m_iMaxZen);

  00a9c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a9f	8b 88 10 01 00
	00		 mov	 ecx, DWORD PTR [eax+272]
  00aa5	51		 push	 ecx
  00aa6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00aa9	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  00aaf	50		 push	 eax
  00ab0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ab3	e8 00 00 00 00	 call	 ?RndRange@CCustomBoxDrop@@AAEHHH@Z ; CCustomBoxDrop::RndRange
  00ab8	89 45 c8	 mov	 DWORD PTR _zen$228344[ebp], eax

; 211  : 		x = lpObj->X-2;

  00abb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00abe	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00ac5	83 e9 02	 sub	 ecx, 2
  00ac8	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 212  : 		y = lpObj->Y-2;

  00acb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ace	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00ad5	83 e9 02	 sub	 ecx, 2
  00ad8	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 213  : 		x+= rand()%3;

  00adb	e8 00 00 00 00	 call	 _rand
  00ae0	99		 cdq
  00ae1	b9 03 00 00 00	 mov	 ecx, 3
  00ae6	f7 f9		 idiv	 ecx
  00ae8	03 55 e8	 add	 edx, DWORD PTR _x$[ebp]
  00aeb	89 55 e8	 mov	 DWORD PTR _x$[ebp], edx

; 214  : 		y+= rand()%3;

  00aee	e8 00 00 00 00	 call	 _rand
  00af3	99		 cdq
  00af4	b9 03 00 00 00	 mov	 ecx, 3
  00af9	f7 f9		 idiv	 ecx
  00afb	03 55 e4	 add	 edx, DWORD PTR _y$[ebp]
  00afe	89 55 e4	 mov	 DWORD PTR _y$[ebp], edx

; 215  : 		MapC[lpObj->MapNumber].MoneyItemDrop(zen, x, y);

  00b01	8b 45 e4	 mov	 eax, DWORD PTR _y$[ebp]
  00b04	50		 push	 eax
  00b05	8b 4d e8	 mov	 ecx, DWORD PTR _x$[ebp]
  00b08	51		 push	 ecx
  00b09	8b 55 c8	 mov	 edx, DWORD PTR _zen$228344[ebp]
  00b0c	52		 push	 edx
  00b0d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b10	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00b17	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  00b1d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00b23	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 216  : 		return TRUE;

  00b28	b8 01 00 00 00	 mov	 eax, 1
  00b2d	e9 8a 02 00 00	 jmp	 $LN13@DropItem
$LN11@DropItem:

; 217  : 	}
; 218  : 
; 219  : 	CustomBoxGroup* lpGroup = GetGroup(rnd);

  00b32	8b 45 cc	 mov	 eax, DWORD PTR _rnd$[ebp]
  00b35	50		 push	 eax
  00b36	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b39	e8 00 00 00 00	 call	 ?GetGroup@CCustomBoxDrop@@AAEPAUCustomBoxGroup@@H@Z ; CCustomBoxDrop::GetGroup
  00b3e	89 45 c4	 mov	 DWORD PTR _lpGroup$[ebp], eax

; 220  : 
; 221  : 	if (lpGroup == NULL || lpGroup->rate == 0 || lpGroup->items.size() == 0)

  00b41	83 7d c4 00	 cmp	 DWORD PTR _lpGroup$[ebp], 0
  00b45	74 17		 je	 SHORT $LN9@DropItem
  00b47	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00b4a	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b4d	74 0f		 je	 SHORT $LN9@DropItem
  00b4f	8b 4d c4	 mov	 ecx, DWORD PTR _lpGroup$[ebp]
  00b52	83 c1 28	 add	 ecx, 40			; 00000028H
  00b55	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00b5a	85 c0		 test	 eax, eax
  00b5c	75 4f		 jne	 SHORT $LN10@DropItem
$LN9@DropItem:

; 222  : 	{
; 223  : 		LogAddTD("[%s][%s][CustomBoxDrop][%s] : (%d)(X:%d/Y:%d) Invalid group at rnd %d",
; 224  : 			lpObj->AccountID, lpObj->Name, this->m_sName, lpObj->MapNumber, lpObj->X, lpObj->Y, rnd);

  00b5e	8b 45 cc	 mov	 eax, DWORD PTR _rnd$[ebp]
  00b61	50		 push	 eax
  00b62	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b65	0f bf 91 46 01
	00 00		 movsx	 edx, WORD PTR [ecx+326]
  00b6c	52		 push	 edx
  00b6d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b70	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00b77	51		 push	 ecx
  00b78	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b7b	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00b82	50		 push	 eax
  00b83	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b86	83 c1 04	 add	 ecx, 4
  00b89	51		 push	 ecx
  00b8a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b8d	83 c2 77	 add	 edx, 119		; 00000077H
  00b90	52		 push	 edx
  00b91	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b94	83 c0 6c	 add	 eax, 108		; 0000006cH
  00b97	50		 push	 eax
  00b98	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@HLFBCKGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@
  00b9d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ba3	83 c4 20	 add	 esp, 32			; 00000020H

; 225  : 		return FALSE;

  00ba6	33 c0		 xor	 eax, eax
  00ba8	e9 0f 02 00 00	 jmp	 $LN13@DropItem
$LN10@DropItem:

; 226  : 	}
; 227  : 
; 228  : 	std::pair<int, int> item = lpGroup->GetRandomItem();

  00bad	8d 45 bc	 lea	 eax, DWORD PTR _item$[ebp]
  00bb0	50		 push	 eax
  00bb1	8b 4d c4	 mov	 ecx, DWORD PTR _lpGroup$[ebp]
  00bb4	e8 00 00 00 00	 call	 ?GetRandomItem@CustomBoxGroup@@QAE?AU?$pair@HH@std@@XZ ; CustomBoxGroup::GetRandomItem

; 229  : 
; 230  : 	type = ItemGetNumberMake(item.first, item.second);

  00bb9	8b 45 c0	 mov	 eax, DWORD PTR _item$[ebp+4]
  00bbc	50		 push	 eax
  00bbd	8b 4d bc	 mov	 ecx, DWORD PTR _item$[ebp]
  00bc0	51		 push	 ecx
  00bc1	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00bc6	83 c4 08	 add	 esp, 8
  00bc9	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 231  : 	level = this->RndRange(lpGroup->min_lvl, lpGroup->max_lvl);

  00bcc	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00bcf	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00bd2	51		 push	 ecx
  00bd3	8b 55 c4	 mov	 edx, DWORD PTR _lpGroup$[ebp]
  00bd6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00bd9	50		 push	 eax
  00bda	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bdd	e8 00 00 00 00	 call	 ?RndRange@CCustomBoxDrop@@AAEHHH@Z ; CCustomBoxDrop::RndRange
  00be2	89 45 ec	 mov	 DWORD PTR _level$[ebp], eax

; 232  : 	x = lpObj->X;

  00be5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00be8	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00bef	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 233  : 	y = lpObj->Y;

  00bf2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bf5	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00bfc	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 234  : 	dur = 0;

  00bff	d9 ee		 fldz
  00c01	d9 5d f4	 fstp	 DWORD PTR _dur$[ebp]

; 235  : 	Option1 = IsProcRnd(lpGroup->skill_rate, 10000);

  00c04	68 10 27 00 00	 push	 10000			; 00002710H
  00c09	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00c0c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c0f	51		 push	 ecx
  00c10	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c13	e8 00 00 00 00	 call	 ?IsProcRnd@CCustomBoxDrop@@AAEHHH@Z ; CCustomBoxDrop::IsProcRnd
  00c18	89 45 e0	 mov	 DWORD PTR _Option1$[ebp], eax

; 236  : 	Option2 = IsProcRnd(lpGroup->luck_rate, 10000);

  00c1b	68 10 27 00 00	 push	 10000			; 00002710H
  00c20	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00c23	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00c26	51		 push	 ecx
  00c27	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c2a	e8 00 00 00 00	 call	 ?IsProcRnd@CCustomBoxDrop@@AAEHHH@Z ; CCustomBoxDrop::IsProcRnd
  00c2f	89 45 dc	 mov	 DWORD PTR _Option2$[ebp], eax

; 237  : 
; 238  : 	v = rand();

  00c32	e8 00 00 00 00	 call	 _rand
  00c37	89 45 d0	 mov	 DWORD PTR _v$[ebp], eax

; 239  : 	int optRnd = v % 10000;

  00c3a	8b 45 d0	 mov	 eax, DWORD PTR _v$[ebp]
  00c3d	99		 cdq
  00c3e	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00c43	f7 f9		 idiv	 ecx
  00c45	89 55 b8	 mov	 DWORD PTR _optRnd$[ebp], edx

; 240  : 
; 241  : 	if (optRnd < lpGroup->opt16_rate)

  00c48	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00c4b	8b 4d b8	 mov	 ecx, DWORD PTR _optRnd$[ebp]
  00c4e	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00c51	7d 09		 jge	 SHORT $LN8@DropItem

; 242  : 		Option3 = 4;

  00c53	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 4
  00c5a	eb 43		 jmp	 SHORT $LN1@DropItem
$LN8@DropItem:

; 243  : 	else if (optRnd < lpGroup->opt12_rate)

  00c5c	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00c5f	8b 4d b8	 mov	 ecx, DWORD PTR _optRnd$[ebp]
  00c62	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00c65	7d 09		 jge	 SHORT $LN6@DropItem

; 244  : 		Option3 = 3;

  00c67	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
  00c6e	eb 2f		 jmp	 SHORT $LN1@DropItem
$LN6@DropItem:

; 245  : 	else if (optRnd < lpGroup->opt8_rate)

  00c70	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00c73	8b 4d b8	 mov	 ecx, DWORD PTR _optRnd$[ebp]
  00c76	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00c79	7d 09		 jge	 SHORT $LN4@DropItem

; 246  : 		Option3 = 2;

  00c7b	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
  00c82	eb 1b		 jmp	 SHORT $LN1@DropItem
$LN4@DropItem:

; 247  : 	else if (optRnd < lpGroup->opt4_rate)

  00c84	8b 45 c4	 mov	 eax, DWORD PTR _lpGroup$[ebp]
  00c87	8b 4d b8	 mov	 ecx, DWORD PTR _optRnd$[ebp]
  00c8a	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00c8d	7d 09		 jge	 SHORT $LN2@DropItem

; 248  : 		Option3 = 1;

  00c8f	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1

; 249  : 	else

  00c96	eb 07		 jmp	 SHORT $LN1@DropItem
$LN2@DropItem:

; 250  : 		Option3 = 0;

  00c98	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0
$LN1@DropItem:

; 251  : 
; 252  : 	ItemSerialCreateSend(lpObj->m_Index, (BYTE)lpObj->MapNumber, (BYTE)x, (BYTE)y, type, (BYTE)level, (BYTE)dur,
; 253  : 	(BYTE)Option1, (BYTE)Option2, (BYTE)Option3, lpObj->m_Index, 0, 0);

  00c9f	6a 00		 push	 0
  00ca1	6a 00		 push	 0
  00ca3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ca6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ca8	51		 push	 ecx
  00ca9	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option3$[ebp]
  00cad	52		 push	 edx
  00cae	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00cb2	50		 push	 eax
  00cb3	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00cb7	51		 push	 ecx
  00cb8	d9 45 f4	 fld	 DWORD PTR _dur$[ebp]
  00cbb	d9 bd a2 fe ff
	ff		 fnstcw	 WORD PTR tv361[ebp]
  00cc1	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR tv361[ebp]
  00cc8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00ccd	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv364[ebp], eax
  00cd3	d9 ad 9c fe ff
	ff		 fldcw	 WORD PTR tv364[ebp]
  00cd9	db 9d 98 fe ff
	ff		 fistp	 DWORD PTR tv366[ebp]
  00cdf	d9 ad a2 fe ff
	ff		 fldcw	 WORD PTR tv361[ebp]
  00ce5	0f b6 95 98 fe
	ff ff		 movzx	 edx, BYTE PTR tv366[ebp]
  00cec	52		 push	 edx
  00ced	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  00cf1	50		 push	 eax
  00cf2	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00cf5	51		 push	 ecx
  00cf6	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  00cfa	52		 push	 edx
  00cfb	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  00cff	50		 push	 eax
  00d00	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d03	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  00d0a	52		 push	 edx
  00d0b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d0e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d10	51		 push	 ecx
  00d11	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00d16	83 c4 34	 add	 esp, 52			; 00000034H

; 254  : 
; 255  : 	CItem EventItem;

  00d19	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _EventItem$[ebp]
  00d1f	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 256  : 
; 257  : 	EventItem.Convert(type, Option1, Option2, Option3, 0, 1, 0, NULL, 0xFF, 0, 3);

  00d24	6a 03		 push	 3
  00d26	6a 00		 push	 0
  00d28	68 ff 00 00 00	 push	 255			; 000000ffH
  00d2d	6a 00		 push	 0
  00d2f	6a 00		 push	 0
  00d31	6a 01		 push	 1
  00d33	6a 00		 push	 0
  00d35	0f b6 45 d8	 movzx	 eax, BYTE PTR _Option3$[ebp]
  00d39	50		 push	 eax
  00d3a	0f b6 4d dc	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  00d3e	51		 push	 ecx
  00d3f	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option1$[ebp]
  00d43	52		 push	 edx
  00d44	8b 45 f0	 mov	 eax, DWORD PTR _type$[ebp]
  00d47	50		 push	 eax
  00d48	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _EventItem$[ebp]
  00d4e	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 258  : 
; 259  : 	LogAddTD("[%s][%s][CustomBoxDrop][%s] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 260  : 		lpObj->AccountID, lpObj->Name, this->m_sName, lpObj->MapNumber, lpObj->X, lpObj->Y, EventItem.GetName(),
; 261  : 		type, level, Option1, Option2, Option3);

  00d53	8b 45 d8	 mov	 eax, DWORD PTR _Option3$[ebp]
  00d56	50		 push	 eax
  00d57	8b 4d dc	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00d5a	51		 push	 ecx
  00d5b	8b 55 e0	 mov	 edx, DWORD PTR _Option1$[ebp]
  00d5e	52		 push	 edx
  00d5f	8b 45 ec	 mov	 eax, DWORD PTR _level$[ebp]
  00d62	50		 push	 eax
  00d63	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00d66	51		 push	 ecx
  00d67	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _EventItem$[ebp]
  00d6d	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00d72	50		 push	 eax
  00d73	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d76	0f bf 82 46 01
	00 00		 movsx	 eax, WORD PTR [edx+326]
  00d7d	50		 push	 eax
  00d7e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d81	0f bf 91 44 01
	00 00		 movsx	 edx, WORD PTR [ecx+324]
  00d88	52		 push	 edx
  00d89	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d8c	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00d93	51		 push	 ecx
  00d94	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00d97	83 c2 04	 add	 edx, 4
  00d9a	52		 push	 edx
  00d9b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d9e	83 c0 77	 add	 eax, 119		; 00000077H
  00da1	50		 push	 eax
  00da2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00da5	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00da8	51		 push	 ecx
  00da9	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@OCLOLHIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLCustomBoxDrop?$FN?$FL?$CFs?$FN?5?3?5?$CI?$CF@
  00dae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00db4	83 c4 34	 add	 esp, 52			; 00000034H

; 262  : 
; 263  : 	return TRUE;

  00db7	b8 01 00 00 00	 mov	 eax, 1
$LN13@DropItem:

; 264  : }

  00dbc	5f		 pop	 edi
  00dbd	5e		 pop	 esi
  00dbe	5b		 pop	 ebx
  00dbf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00dc2	33 cd		 xor	 ecx, ebp
  00dc4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dc9	8b e5		 mov	 esp, ebp
  00dcb	5d		 pop	 ebp
  00dcc	c2 04 00	 ret	 4
?DropItem@CCustomBoxDrop@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CCustomBoxDrop::DropItem
_TEXT	ENDS
PUBLIC	??$?0HH@?$pair@HH@std@@QAE@AAU01@@Z		; std::pair<int,int>::pair<int,int><int,int>
PUBLIC	??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator[]
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\customboxdrop.h
;	COMDAT ?GetRandomItem@CustomBoxGroup@@QAE?AU?$pair@HH@std@@XZ
_TEXT	SEGMENT
_n$ = -12						; size = 4
_rnd$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRandomItem@CustomBoxGroup@@QAE?AU?$pair@HH@std@@XZ PROC ; CustomBoxGroup::GetRandomItem, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 		int rnd = rand();

  0000c	e8 00 00 00 00	 call	 _rand
  00011	89 45 f8	 mov	 DWORD PTR _rnd$[ebp], eax

; 24   : 		int n = rnd % items.size();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 28	 add	 ecx, 40			; 00000028H
  0001a	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  0001f	8b c8		 mov	 ecx, eax
  00021	8b 45 f8	 mov	 eax, DWORD PTR _rnd$[ebp]
  00024	33 d2		 xor	 edx, edx
  00026	f7 f1		 div	 ecx
  00028	89 55 f4	 mov	 DWORD PTR _n$[ebp], edx

; 25   : 		return items[n];

  0002b	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 28	 add	 ecx, 40			; 00000028H
  00035	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator[]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	e8 00 00 00 00	 call	 ??$?0HH@?$pair@HH@std@@QAE@AAU01@@Z ; std::pair<int,int>::pair<int,int><int,int>
  00043	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 26   : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?GetRandomItem@CustomBoxGroup@@QAE?AU?$pair@HH@std@@XZ ENDP ; CustomBoxGroup::GetRandomItem
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

  00dd0	55		 push	 ebp
  00dd1	8b ec		 mov	 ebp, esp
  00dd3	83 ec 40	 sub	 esp, 64			; 00000040H
  00dd6	53		 push	 ebx
  00dd7	56		 push	 esi
  00dd8	57		 push	 edi

; 133  :     return _time64(_Time);

  00dd9	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00ddc	50		 push	 eax
  00ddd	e8 00 00 00 00	 call	 __time64
  00de2	83 c4 04	 add	 esp, 4

; 134  : }

  00de5	5f		 pop	 edi
  00de6	5e		 pop	 esi
  00de7	5b		 pop	 ebx
  00de8	8b e5		 mov	 esp, ebp
  00dea	5d		 pop	 ebp
  00deb	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@V?$allocator@U?$pair@HH@std@@@1@@Z ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
PUBLIC	??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T230940 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T230940[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ ; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@V?$allocator@U?$pair@HH@std@@@1@@Z ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> >
PUBLIC	??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
PUBLIC	?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Orphan_range
PUBLIC	?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Reserve
PUBLIC	?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Inside
PUBLIC	??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z ; std::addressof<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z
_TEXT	SEGMENT
__Idx$228389 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z ; std::addressof<std::pair<int,int> >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 81 00 00
	00		 je	 $LN4@push_back

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z ; std::addressof<std::pair<int,int> >
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	c1 f8 03	 sar	 eax, 3
  00040	89 45 f8	 mov	 DWORD PTR __Idx$228389[ebp], eax

; 635  : 			if (this->_Mylast == this->_Myend)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004f	75 0a		 jne	 SHORT $LN3@push_back

; 636  : 				_Reserve(1);

  00051	6a 01		 push	 1
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Reserve
$LN3@push_back:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Orphan_range

; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	8b 55 f8	 mov	 edx, DWORD PTR __Idx$228389[ebp]
  00079	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  00082	83 c4 04	 add	 esp, 4
  00085	50		 push	 eax
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008c	52		 push	 edx
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	83 c0 0c	 add	 eax, 12			; 0000000cH
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> >
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 			++this->_Mylast;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	83 c1 08	 add	 ecx, 8
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 642  : 			}
; 643  : 		else

  000ab	eb 60		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b9	75 0a		 jne	 SHORT $LN1@push_back

; 646  : 				_Reserve(1);

  000bb	6a 01		 push	 1
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Reserve
$LN1@push_back:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	51		 push	 ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Orphan_range

; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  000db	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  000e4	83 c4 04	 add	 esp, 4
  000e7	50		 push	 eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ee	52		 push	 edx
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	83 c0 0c	 add	 eax, 12			; 0000000cH
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> >
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00104	83 c1 08	 add	 ecx, 8
  00107	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 652  : 			}
; 653  : 		}

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 04 00	 ret	 4
?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
PUBLIC	?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
__ehhandler$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@V?$allocator@UCustomBoxGroup@@@1@@Z ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >
PUBLIC	??0?$allocator@UCustomBoxGroup@@@std@@QAE@XZ	; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T230959 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T230959[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UCustomBoxGroup@@@std@@QAE@XZ ; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@V?$allocator@UCustomBoxGroup@@@1@@Z ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >
PUBLIC	?_Tidy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >
__ehhandler$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE_NXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::empty
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 38	 imul	 eax, 56			; 00000038H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@I@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEAAUCustomBoxGroup@@XZ ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
; Function compile flags: /Odtp /ZI
;	COMDAT ?back@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@XZ
_TEXT	SEGMENT
$T230982 = -76						; size = 4
$T230983 = -72						; size = 4
_this$ = -4						; size = 4
?back@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@XZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::back, COMDAT
; _this$ = ecx

; 966  : 		{	// return last element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 967  : 		return (*(end() - 1));

  0000c	6a 01		 push	 1
  0000e	8d 45 b8	 lea	 eax, DWORD PTR $T230983[ebp]
  00011	50		 push	 eax
  00012	8d 4d b4	 lea	 ecx, DWORD PTR $T230982[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::end
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 ??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEAAUCustomBoxGroup@@XZ ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*

; 968  : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?back@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEAAUCustomBoxGroup@@XZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T230986 = -88						; size = 4
$T230987 = -84						; size = 4
$T230988 = -80						; size = 4
$T230989 = -76						; size = 4
$T230990 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T230987[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T230986[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T230989[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@XZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T230988[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T230986[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T230988[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T230990[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::reserve
PUBLIC	?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Grow_to
PUBLIC	?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity
PUBLIC	?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Xlen
PUBLIC	?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::deallocate
PUBLIC	?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@HH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@V?$allocator@U?$pair@HH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@V?$allocator@U?$pair@HH@std@@@1@@Z PROC ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@HH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@V?$allocator@U?$pair@HH@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Destroy
PUBLIC	??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Make_iter
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T231009 = -84						; size = 4
__Ptr$228506 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@0@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$228506[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$228506[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$228506[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T231009[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T231009[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@0@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::erase
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z ; std::allocator<CustomBoxGroup>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z ; std::allocator<CustomBoxGroup>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@UCustomBoxGroup@@@std@@QAE@ABV01@@Z ; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@V?$allocator@UCustomBoxGroup@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@V?$allocator@UCustomBoxGroup@@@1@@Z PROC ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCustomBoxGroup@@@std@@QAE@ABV01@@Z ; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@V?$allocator@UCustomBoxGroup@@@1@@Z ENDP ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >::~_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCustomBoxGroup@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCustomBoxGroup@@@std@@QAE@XZ PROC	; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UCustomBoxGroup@@@std@@QAE@XZ ENDP	; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEABUCustomBoxGroup@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEAAUCustomBoxGroup@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEAAUCustomBoxGroup@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEABUCustomBoxGroup@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEAAUCustomBoxGroup@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-=
; Function compile flags: /Odtp /ZI
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-, COMDAT
; _this$ = ecx

; 374  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 375  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 376  : 		return (_Tmp -= _Off);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00017	50		 push	 eax
  00018	8d 4d f8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0001b	e8 00 00 00 00	 call	 ??Z?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-=
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 377  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
_TEXT	ENDS
PUBLIC	??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Umove<std::pair<int,int> *>
PUBLIC	?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$228547 = -28					; size = 4
__Ptr$228540 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$228540[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$228540[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Umove<std::pair<int,int> *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228540[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$228547[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228540[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$228547[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228540[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228540[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int,int> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int,int> >::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,int> > >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@HH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@HH@std@@@std@@QAE@ABV01@@Z PROC	; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@HH@std@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z PROC ; std::allocator<std::pair<int,int> >::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ENDP ; std::allocator<std::pair<int,int> >::deallocate
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@2@@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@@Z ; std::_Destroy_range<std::allocator<CustomBoxGroup> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@@Z ; std::_Destroy_range<std::allocator<CustomBoxGroup> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCustomBoxGroup@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCustomBoxGroup@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UCustomBoxGroup@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CustomBoxGroup>::allocator<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z PROC ; std::allocator<CustomBoxGroup>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z ENDP ; std::allocator<CustomBoxGroup>::deallocate
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-=, COMDAT
; _this$ = ecx

; 369  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 		return (*this += -_Off);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000f	f7 d8		 neg	 eax
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=

; 371  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-=
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAE@PAUCustomBoxGroup@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEABUCustomBoxGroup@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEABUCustomBoxGroup@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEABUCustomBoxGroup@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator*
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z ; std::_Allocate<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z PROC ; std::allocator<std::pair<int,int> >::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z ; std::_Allocate<std::pair<int,int> >
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z ENDP ; std::allocator<std::pair<int,int> >::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ PROC	; std::allocator<std::pair<int,int> >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ ENDP	; std::allocator<std::pair<int,int> >::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=, COMDAT
; _this$ = ecx

; 357  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 358  : 		*(_Mybase *)this += _Off;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=

; 359  : 		return (*this);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 360  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=, COMDAT
; _this$ = ecx

; 151  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 		if (this->_Getcont() == 0
; 154  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 155  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 156  : 			{	// report error
; 157  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 158  : 			_SCL_SECURE_OUT_OF_RANGE;
; 159  : 			}
; 160  : 
; 161  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 162  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 163  : 		_SCL_SECURE_VALIDATE_RANGE(
; 164  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 165  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 166  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 167  : 
; 168  : 		_Ptr += _Off;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000f	6b c0 38	 imul	 eax, 56			; 00000038H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 02		 mov	 DWORD PTR [edx], eax

; 169  : 		return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 170  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator+=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Compat
_TEXT	ENDS
PUBLIC	??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z	; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HH@?$pair@HH@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HH@?$pair@HH@std@@QAE@AAU01@@Z PROC		; std::pair<int,int>::pair<int,int><int,int>, COMDAT
; _this$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00016	51		 push	 ecx
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z ; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>

; 196  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0HH@?$pair@HH@std@@QAE@AAU01@@Z ENDP		; std::pair<int,int>::pair<int,int><int,int>
_TEXT	ENDS
PUBLIC	??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z		; std::pair<int,int>::pair<int,int><int &,int &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$make_pair@AAHAAH@std@@YA?AU?$pair@HH@0@AAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAHAAH@std@@YA?AU?$pair@HH@0@AAH0@Z PROC	; std::make_pair<int &,int &>, COMDAT

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00009	8b 45 10	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z ; std::pair<int,int>::pair<int,int><int &,int &>
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$make_pair@AAHAAH@std@@YA?AU?$pair@HH@0@AAH0@Z ENDP	; std::make_pair<int &,int &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@AAU3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@AAU2@@Z ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup &>
PUBLIC	??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup &>
PUBLIC	?_Orphan_range@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXPAUCustomBoxGroup@@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXI@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Reserve
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$emplace_back@AAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXAAUCustomBoxGroup@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$emplace_back@AAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXAAUCustomBoxGroup@@@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::emplace_back<CustomBoxGroup &>, COMDAT
; _this$ = ecx

; 661  : 		void emplace_back(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		{	// insert element at end
; 663  : 		if (this->_Mylast == this->_Myend)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00015	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00018	75 0a		 jne	 SHORT $LN1@emplace_ba

; 664  : 			_Reserve(1);

  0001a	6a 01		 push	 1
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXI@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Reserve
$LN1@emplace_ba:

; 665  : 		_Orphan_range(this->_Mylast, this->_Mylast);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002a	51		 push	 ecx
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXPAUCustomBoxGroup@@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Orphan_range

; 666  : 		_Cons_val(this->_Alval,
; 667  : 			this->_Mylast,
; 668  : 			_STD forward<_Valty>(_Val));

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup &>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	52		 push	 edx
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 c0 0c	 add	 eax, 12			; 0000000cH
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@AAU3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@AAU2@@Z ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup &>
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 669  : 		++this->_Mylast;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	83 c1 38	 add	 ecx, 56			; 00000038H
  00066	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00069	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 670  : 		}

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
??$emplace_back@AAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXAAUCustomBoxGroup@@@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::emplace_back<CustomBoxGroup &>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z ; std::_Sort<CustomBoxGroup *,int,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$_Unchecked@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@YAPAUCustomBoxGroup@@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@P6A_NABUCustomBoxGroup@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@0P6A_NABUCustomBoxGroup@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@P6A_NABUCustomBoxGroup@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@0P6A_NABUCustomBoxGroup@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 3803 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3804 : 	_DEBUG_RANGE(_First, _Last);
; 3805 : 	_DEBUG_POINTER(_Pred);
; 3806 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00014	e8 00 00 00 00	 call	 ??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
  00019	50		 push	 eax
  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@YAPAUCustomBoxGroup@@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@YAPAUCustomBoxGroup@@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z ; std::_Sort<CustomBoxGroup *,int,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 3807 : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@P6A_NABUCustomBoxGroup@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@0P6A_NABUCustomBoxGroup@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z PROC ; std::addressof<std::pair<int,int> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z ENDP ; std::addressof<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z PROC ; std::forward<std::pair<int,int> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ENDP ; std::forward<std::pair<int,int> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z ; std::allocator<std::pair<int,int> >::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z ; std::allocator<std::pair<int,int> >::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>
PUBLIC	??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z
_TEXT	SEGMENT
$T231102 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z PROC ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231102[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231102[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z ENDP ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Umove<std::pair<int,int> *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Umove<std::pair<int,int> *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,int> > >
PUBLIC	??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@@Z
_TEXT	SEGMENT
$T231107 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<int,int> > >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231107[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231107[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<int,int> > >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<int,int> > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CustomBoxGroup> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@@Z
_TEXT	SEGMENT
$T231110 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CustomBoxGroup> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231110[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231110[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CustomBoxGroup> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CustomBoxGroup> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z
_TEXT	SEGMENT
$T231113 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<int,int> >, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T231113[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T231113[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$?0HH@?$pair@HH@std@@QAE@$$QAU01@@Z		; std::pair<int,int>::pair<int,int><int,int>
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T231116 = -88						; size = 4
$T231117 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z PROC ; std::allocator<std::pair<int,int> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231117[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231117[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T231117[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HH@?$pair@HH@std@@QAE@$$QAU01@@Z ; std::pair<int,int>::pair<int,int><int,int>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T231116[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231117[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<int,int> >::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::reserve
PUBLIC	?_Grow_to@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEII@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Grow_to
PUBLIC	?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::capacity
PUBLIC	?_Xlen@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Xlen
PUBLIC	?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXI@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEII@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXPAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXPAUCustomBoxGroup@@0@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXPAUCustomBoxGroup@@0@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
; Function compile flags: /Odtp /ZI
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-, COMDAT
; _this$ = ecx

; 380  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 381  : 		return (*(_Mybase *)this - _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??G?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-

; 382  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEPAUCustomBoxGroup@@PAU2@00@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Umove<CustomBoxGroup *>
PUBLIC	?allocate@?$allocator@UCustomBoxGroup@@@std@@QAEPAUCustomBoxGroup@@I@Z ; std::allocator<CustomBoxGroup>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$229246 = -28					; size = 4
__Ptr$229239 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCustomBoxGroup@@@std@@QAEPAUCustomBoxGroup@@I@Z ; std::allocator<CustomBoxGroup>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$229239[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$229239[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEPAUCustomBoxGroup@@PAU2@00@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Umove<CustomBoxGroup *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229239[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z ; std::allocator<CustomBoxGroup>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$229246[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEXPAUCustomBoxGroup@@0@Z ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@I@Z ; std::allocator<CustomBoxGroup>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 38	 imul	 eax, 56			; 00000038H
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$229239[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$229246[ebp]
  00125	6b c0 38	 imul	 eax, 56			; 00000038H
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$229239[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229239[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCustomBoxGroup@@@std@@QBEIXZ ; std::allocator<CustomBoxGroup>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UCustomBoxGroup@@@std@@QBEIXZ ; std::allocator<CustomBoxGroup>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEII@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@QBEIXZ ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEII@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXXZ PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IBEXXZ ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Xlen
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-, COMDAT
; _this$ = ecx

; 190  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Compat

; 192  : 		return (this->_Ptr - _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	2b 01		 sub	 eax, DWORD PTR [ecx]
  00022	99		 cdq
  00023	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00028	f7 f9		 idiv	 ecx

; 193  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::operator-
_TEXT	ENDS
PUBLIC	??$_Allocate@UCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@IPAU1@@Z ; std::_Allocate<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UCustomBoxGroup@@@std@@QAEPAUCustomBoxGroup@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCustomBoxGroup@@@std@@QAEPAUCustomBoxGroup@@I@Z PROC ; std::allocator<CustomBoxGroup>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@IPAU1@@Z ; std::_Allocate<CustomBoxGroup>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UCustomBoxGroup@@@std@@QAEPAUCustomBoxGroup@@I@Z ENDP ; std::allocator<CustomBoxGroup>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCustomBoxGroup@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UCustomBoxGroup@@@std@@QBEIXZ PROC ; std::allocator<CustomBoxGroup>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 24 49
	92 04		 mov	 DWORD PTR __Count$[ebp], 76695844 ; 04924924H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UCustomBoxGroup@@@std@@QBEIXZ ENDP ; std::allocator<CustomBoxGroup>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z PROC	; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z ENDP	; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z PROC		; std::pair<int,int>::pair<int,int><int &,int &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z ; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z ENDP		; std::pair<int,int>::pair<int,int><int &,int &>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@HH@std@@QAE@$$QAH0@Z		; std::_Pair_base<int,int>::_Pair_base<int,int>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0HH@?$pair@HH@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HH@?$pair@HH@std@@QAE@$$QAU01@@Z PROC		; std::pair<int,int>::pair<int,int><int,int>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$_Pair_base@HH@std@@QAE@$$QAH0@Z ; std::_Pair_base<int,int>::_Pair_base<int,int>

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HH@?$pair@HH@std@@QAE@$$QAU01@@Z ENDP		; std::pair<int,int>::pair<int,int><int,int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z PROC ; std::forward<CustomBoxGroup &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z ENDP ; std::forward<CustomBoxGroup &>
_TEXT	ENDS
PUBLIC	??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z ; std::allocator<CustomBoxGroup>::construct<CustomBoxGroup &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@AAU3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@AAU3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z ; std::allocator<CustomBoxGroup>::construct<CustomBoxGroup &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@AAU3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup &>
_TEXT	ENDS
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEPAUCustomBoxGroup@@XZ ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Unchecked
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@YAPAUCustomBoxGroup@@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@YAPAUCustomBoxGroup@@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >, COMDAT

; 393  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 394  : 	return (_Iter._Unchecked());

  00009	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEPAUCustomBoxGroup@@XZ ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Unchecked

; 395  : 	}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@YAPAUCustomBoxGroup@@V?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::_Insertion_sort<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$make_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::make_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$_Unguarded_partition@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YA?AU?$pair@PAUCustomBoxGroup@@PAU1@@0@PAUCustomBoxGroup@@0P6A_NABU2@1@Z@Z ; std::_Unguarded_partition<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__Mid$229457 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z PROC ; std::_Sort<CustomBoxGroup *,int,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 3771 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN7@Sort:

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	99		 cdq
  00010	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00015	f7 f9		 idiv	 ecx
  00017	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
  0001a	83 7d fc 20	 cmp	 DWORD PTR __Count$[ebp], 32 ; 00000020H
  0001e	0f 8e a0 00 00
	00		 jle	 $LN6@Sort
  00024	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  00028	0f 8e 96 00 00
	00		 jle	 $LN6@Sort

; 3774 : 		{	// divide and conquer by quicksort
; 3775 : 		_STD pair<_RanIt, _RanIt> _Mid =
; 3776 : 			_Unguarded_partition(_First, _Last, _Pred);

  0002e	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00039	52		 push	 edx
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __Mid$229457[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YA?AU?$pair@PAUCustomBoxGroup@@PAU1@@0@PAUCustomBoxGroup@@0P6A_NABU2@1@Z@Z ; std::_Unguarded_partition<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 3777 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00046	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	d1 f8		 sar	 eax, 1
  0004e	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax
  00051	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00054	99		 cdq
  00055	2b c2		 sub	 eax, edx
  00057	d1 f8		 sar	 eax, 1
  00059	03 45 10	 add	 eax, DWORD PTR __Ideal$[ebp]
  0005c	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 3778 : 
; 3779 : 		if (_Mid.first - _First < _Last - _Mid.second)

  0005f	8b 45 f4	 mov	 eax, DWORD PTR __Mid$229457[ebp]
  00062	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00065	99		 cdq
  00066	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0006b	f7 f9		 idiv	 ecx
  0006d	8b c8		 mov	 ecx, eax
  0006f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00072	2b 45 f8	 sub	 eax, DWORD PTR __Mid$229457[ebp+4]
  00075	99		 cdq
  00076	be 38 00 00 00	 mov	 esi, 56			; 00000038H
  0007b	f7 fe		 idiv	 esi
  0007d	3b c8		 cmp	 ecx, eax
  0007f	7d 20		 jge	 SHORT $LN5@Sort

; 3780 : 			{	// loop on second half
; 3781 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  00081	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 f4	 mov	 edx, DWORD PTR __Mid$229457[ebp]
  0008c	52		 push	 edx
  0008d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z ; std::_Sort<CustomBoxGroup *,int,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00096	83 c4 10	 add	 esp, 16			; 00000010H

; 3782 : 			_First = _Mid.second;

  00099	8b 45 f8	 mov	 eax, DWORD PTR __Mid$229457[ebp+4]
  0009c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 3783 : 			}
; 3784 : 		else

  0009f	eb 1e		 jmp	 SHORT $LN4@Sort
$LN5@Sort:

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  000a1	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 f8	 mov	 eax, DWORD PTR __Mid$229457[ebp+4]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z ; std::_Sort<CustomBoxGroup *,int,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000b6	83 c4 10	 add	 esp, 16			; 00000010H

; 3787 : 			_Last = _Mid.first;

  000b9	8b 45 f4	 mov	 eax, DWORD PTR __Mid$229457[ebp]
  000bc	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN4@Sort:

; 3788 : 			}
; 3789 : 		}

  000bf	e9 45 ff ff ff	 jmp	 $LN7@Sort
$LN6@Sort:

; 3790 : 
; 3791 : 	if (_ISORT_MAX < _Count)

  000c4	83 7d fc 20	 cmp	 DWORD PTR __Count$[ebp], 32 ; 00000020H
  000c8	7e 2a		 jle	 SHORT $LN3@Sort

; 3792 : 		{	// heap sort if too many divisions
; 3793 : 		_STD make_heap(_First, _Last, _Pred);

  000ca	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000cd	50		 push	 eax
  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ??$make_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::make_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3794 : 		_STD sort_heap(_First, _Last, _Pred);

  000de	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000e5	51		 push	 ecx
  000e6	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 ??$sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	eb 1a		 jmp	 SHORT $LN8@Sort
$LN3@Sort:

; 3795 : 		}
; 3796 : 	else if (1 < _Count)

  000f4	83 7d fc 01	 cmp	 DWORD PTR __Count$[ebp], 1
  000f8	7e 14		 jle	 SHORT $LN8@Sort

; 3797 : 		_Insertion_sort(_First, _Last, _Pred);	// small

  000fa	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00101	51		 push	 ecx
  00102	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 ??$_Insertion_sort@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::_Insertion_sort<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@Sort:

; 3798 : 	}

  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
??$_Sort@PAUCustomBoxGroup@@HP6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0HP6A_NABU1@1@Z@Z ENDP ; std::_Sort<CustomBoxGroup *,int,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z PROC ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z ENDP ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>
_TEXT	ENDS
PUBLIC	??4CustomBoxGroup@@QAEAAU0@ABU0@@Z		; CustomBoxGroup::operator=
PUBLIC	??$move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::move<CustomBoxGroup &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 38	 add	 eax, 56			; 00000038H
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 38	 add	 ecx, 56			; 00000038H
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 17		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::move<CustomBoxGroup &>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z
  0003a	eb cf		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Move@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CustomBoxGroup *,CustomBoxGroup *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> >,std::pair<int,int> >
PUBLIC	??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ; std::_Val_type<std::pair<int,int> *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z
_TEXT	SEGMENT
$T231192 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z PROC ; std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231192[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231192[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ; std::_Val_type<std::pair<int,int> *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> >,std::pair<int,int> >
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z PROC ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ENDP ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<int,int> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@U?$pair@HH@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<int,int> > >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@@Z ; std::_Dest_val<std::allocator<CustomBoxGroup>,CustomBoxGroup>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CustomBoxGroup> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 38	 add	 eax, 56			; 00000038H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@@Z ; std::_Dest_val<std::allocator<CustomBoxGroup>,CustomBoxGroup>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAXPAUCustomBoxGroup@@0AAV?$allocator@UCustomBoxGroup@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CustomBoxGroup> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@@Z ; std::_Uninitialized_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEPAUCustomBoxGroup@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEPAUCustomBoxGroup@@PAU2@00@Z PROC ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Umove<CustomBoxGroup *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@@Z ; std::_Uninitialized_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCustomBoxGroup@@@?$vector@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@IAEPAUCustomBoxGroup@@PAU2@00@Z ENDP ; std::vector<CustomBoxGroup,std::allocator<CustomBoxGroup> >::_Umove<CustomBoxGroup *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@IPAU1@@Z
_TEXT	SEGMENT
$T231203 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@IPAU1@@Z PROC ; std::_Allocate<CustomBoxGroup>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 24 49
	92 04		 cmp	 DWORD PTR __Count$[ebp], 76695844 ; 04924924H
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 38	 imul	 eax, 56			; 00000038H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T231203[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T231203[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@IPAU1@@Z ENDP ; std::_Allocate<CustomBoxGroup>
_TEXT	ENDS
PUBLIC	??4?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator=
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CustomBoxGroup@@QAEAAU0@ABU0@@Z PROC			; CustomBoxGroup::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 10		 mov	 DWORD PTR [eax], edx
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00028	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002b	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00034	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00037	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00040	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00043	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0004c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004f	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00058	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005b	89 50 18	 mov	 DWORD PTR [eax+24], edx
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00064	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00067	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00070	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00073	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0007c	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0007f	89 50 24	 mov	 DWORD PTR [eax+36], edx
  00082	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00085	83 c0 28	 add	 eax, 40			; 00000028H
  00088	50		 push	 eax
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	83 c1 28	 add	 ecx, 40			; 00000028H
  0008f	e8 00 00 00 00	 call	 ??4?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator=
  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
??4CustomBoxGroup@@QAEAAU0@ABU0@@Z ENDP			; CustomBoxGroup::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Buy
PUBLIC	??$_Ucopy@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::pair<int,int> *>
PUBLIC	??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
PUBLIC	?clear@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::clear
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??4?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Ptr$229663 = -12					; size = 4
__Ptr$229653 = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator=, COMDAT
; _this$ = ecx

; 709  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 710  : 		if (this != &_Right)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00012	0f 84 5c 01 00
	00		 je	 $LN9@operator@2

; 711  : 			{	// worth doing
; 712  : 			this->_Orphan_all();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 713  : 
; 714  : 			if (_Right.size() == 0)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00023	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00028	85 c0		 test	 eax, eax
  0002a	75 0d		 jne	 SHORT $LN8@operator@2

; 715  : 				clear();	// new sequence empty, erase existing sequence

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?clear@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::clear
  00034	e9 3b 01 00 00	 jmp	 $LN9@operator@2
$LN8@operator@2:

; 716  : 			else if (_Right.size() <= size())

  00039	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00041	8b f0		 mov	 esi, eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  0004b	3b f0		 cmp	 esi, eax
  0004d	77 4c		 ja	 SHORT $LN6@operator@2

; 717  : 				{	// enough elements, copy new and destroy old
; 718  : 				pointer _Ptr = _STD _Copy_impl(_Right._Myfirst, _Right._Mylast,
; 719  : 					this->_Myfirst);	// copy new

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00058	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005b	50		 push	 eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	89 45 f8	 mov	 DWORD PTR __Ptr$229653[ebp], eax

; 720  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	51		 push	 ecx
  00074	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$229653[ebp]
  00077	52		 push	 edx
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy

; 721  : 				this->_Mylast = this->_Myfirst + _Right.size();

  00080	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00083	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008d	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00096	e9 d9 00 00 00	 jmp	 $LN9@operator@2
$LN6@operator@2:

; 722  : 				}
; 723  : 			else if (_Right.size() <= capacity())

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009e	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  000a3	8b f0		 mov	 esi, eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::capacity
  000ad	3b f0		 cmp	 esi, eax
  000af	77 4d		 ja	 SHORT $LN4@operator@2

; 724  : 				{	// enough room, copy and construct new
; 725  : 				pointer _Ptr = _Right._Myfirst + size();

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000be	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  000c1	89 45 f4	 mov	 DWORD PTR __Ptr$229663[ebp], eax

; 726  : 				_STD _Copy_impl(_Right._Myfirst, _Ptr, this->_Myfirst);

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c9	51		 push	 ecx
  000ca	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$229663[ebp]
  000cd	52		 push	 edx
  000ce	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 727  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e2	51		 push	 ecx
  000e3	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  000e6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e9	50		 push	 eax
  000ea	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$229663[ebp]
  000ed	51		 push	 ecx
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	e8 00 00 00 00	 call	 ??$_Ucopy@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::pair<int,int> *>
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 728  : 				}
; 729  : 			else

  000fc	eb 76		 jmp	 SHORT $LN9@operator@2
$LN4@operator@2:

; 730  : 				{	// not enough room, allocate new array and construct new
; 731  : 				if (this->_Myfirst != 0)

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	83 38 00	 cmp	 DWORD PTR [eax], 0
  00104	74 35		 je	 SHORT $LN2@operator@2

; 732  : 					{	// discard old array
; 733  : 					_Destroy(this->_Myfirst, this->_Mylast);

  00106	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00109	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010c	51		 push	 ecx
  0010d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00110	8b 02		 mov	 eax, DWORD PTR [edx]
  00112	50		 push	 eax
  00113	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy

; 734  : 					this->_Alval.deallocate(this->_Myfirst,
; 735  : 						this->_Myend - this->_Myfirst);

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00124	2b 11		 sub	 edx, DWORD PTR [ecx]
  00126	c1 fa 03	 sar	 edx, 3
  00129	52		 push	 edx
  0012a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	51		 push	 ecx
  00130	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00136	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::deallocate
$LN2@operator@2:

; 736  : 					}
; 737  : 				if (_Buy(_Right.size()))

  0013b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013e	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00143	50		 push	 eax
  00144	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	e8 00 00 00 00	 call	 ?_Buy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Buy
  0014c	0f b6 c0	 movzx	 eax, al
  0014f	85 c0		 test	 eax, eax
  00151	74 21		 je	 SHORT $LN9@operator@2

; 738  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 739  : 						this->_Myfirst);

  00153	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00156	8b 08		 mov	 ecx, DWORD PTR [eax]
  00158	51		 push	 ecx
  00159	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0015c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0015f	50		 push	 eax
  00160	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00163	8b 11		 mov	 edx, DWORD PTR [ecx]
  00165	52		 push	 edx
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	e8 00 00 00 00	 call	 ??$_Ucopy@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::pair<int,int> *>
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN9@operator@2:

; 740  : 				}
; 741  : 			}
; 742  : 		return (*this);

  00174	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 743  : 		}

  00177	5f		 pop	 edi
  00178	5e		 pop	 esi
  00179	5b		 pop	 ebx
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c2 04 00	 ret	 4
??4?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::operator=
_TEXT	ENDS
PUBLIC	??$move@AAH@std@@YA$$QAHAAH@Z			; std::move<int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@HH@std@@QAE@$$QAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@HH@std@@QAE@$$QAH0@Z PROC		; std::_Pair_base<int,int>::_Pair_base<int,int>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@HH@std@@QAE@$$QAH0@Z ENDP		; std::_Pair_base<int,int>::_Pair_base<int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEPAUCustomBoxGroup@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEPAUCustomBoxGroup@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Unchecked, COMDAT
; _this$ = ecx

; 316  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 		return (_Unchecked_type(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 318  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@UCustomBoxGroup@@V?$allocator@UCustomBoxGroup@@@std@@@std@@@std@@QBEPAUCustomBoxGroup@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CustomBoxGroup,std::allocator<CustomBoxGroup> > >::_Unchecked
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::erase
PUBLIC	?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin
PUBLIC	?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T231214 = -88						; size = 4
$T231215 = -84						; size = 4
$T231216 = -80						; size = 4
$T231217 = -76						; size = 4
$T231218 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T231215[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T231214[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T231217[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T231216[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T231214[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T231216[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T231218[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::clear
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Buy, COMDAT
; _this$ = ecx

; 1250 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1251 : 		this->_Myfirst = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1252 : 		this->_Mylast = 0;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1253 : 		this->_Myend = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1254 : 
; 1255 : 		if (_Capacity == 0)

  00029	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  0002d	75 06		 jne	 SHORT $LN4@Buy

; 1256 : 			return (false);

  0002f	32 c0		 xor	 al, al
  00031	eb 4b		 jmp	 SHORT $LN6@Buy
  00033	eb 47		 jmp	 SHORT $LN3@Buy
$LN4@Buy:

; 1257 : 		else if (max_size() < _Capacity)

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::max_size
  0003d	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00040	73 0a		 jae	 SHORT $LN2@Buy

; 1258 : 			_Xlen();	// result too long

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Xlen

; 1259 : 		else

  0004a	eb 30		 jmp	 SHORT $LN3@Buy
$LN2@Buy:

; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00056	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int> >::allocate
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00073	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@Buy:

; 1264 : 			}
; 1265 : 		return (true);

  0007c	b0 01		 mov	 al, 1
$LN6@Buy:

; 1266 : 		}

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?_Buy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Buy
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end
_TEXT	ENDS
PUBLIC	??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator!=
PUBLIC	?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
$T231227 = -84						; size = 4
__Ptr$229852 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$229852[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$229852[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$229852[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T231227[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T231227[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator!=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
PUBLIC	??0CustomBoxGroup@@QAE@ABU0@@Z			; CustomBoxGroup::CustomBoxGroup
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T231244 = -88						; size = 4
$T231245 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z PROC ; std::allocator<CustomBoxGroup>::construct<CustomBoxGroup &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 38		 push	 56			; 00000038H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231245[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231245[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUCustomBoxGroup@@@std@@YAAAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup &>
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T231245[ebp]
  00059	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@ABU0@@Z
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@2:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T231244[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231245[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUCustomBoxGroup@@@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@AAU2@@Z ENDP ; std::allocator<CustomBoxGroup>::construct<CustomBoxGroup &>
PUBLIC	??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$pair@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z ; std::pair<CustomBoxGroup *,CustomBoxGroup *>::pair<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>
PUBLIC	??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
PUBLIC	??$_Median@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Median<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YA?AU?$pair@PAUCustomBoxGroup@@PAU1@@0@PAUCustomBoxGroup@@0P6A_NABU2@1@Z@Z
_TEXT	SEGMENT
tv181 = -92						; size = 4
tv195 = -88						; size = 4
tv178 = -88						; size = 4
tv147 = -88						; size = 4
__Glast$ = -20						; size = 4
__Gfirst$ = -16						; size = 4
__Plast$ = -12						; size = 4
__Pfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Unguarded_partition@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YA?AU?$pair@PAUCustomBoxGroup@@PAU1@@0@PAUCustomBoxGroup@@0P6A_NABU2@1@Z@Z PROC ; std::_Unguarded_partition<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 3712 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3713 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00009	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 0c	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	99		 cdq
  00010	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00015	f7 f9		 idiv	 ecx
  00017	99		 cdq
  00018	2b c2		 sub	 eax, edx
  0001a	d1 f8		 sar	 eax, 1
  0001c	6b c0 38	 imul	 eax, 56			; 00000038H
  0001f	03 45 0c	 add	 eax, DWORD PTR __First$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR __Mid$[ebp], eax

; 3714 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00025	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002c	83 e9 38	 sub	 ecx, 56			; 00000038H
  0002f	51		 push	 ecx
  00030	8b 55 fc	 mov	 edx, DWORD PTR __Mid$[ebp]
  00033	52		 push	 edx
  00034	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Median@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Median<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 3715 : 	_RanIt _Pfirst = _Mid;

  00040	8b 45 fc	 mov	 eax, DWORD PTR __Mid$[ebp]
  00043	89 45 f8	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 3716 : 	_RanIt _Plast = _Pfirst + 1;

  00046	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00049	83 c0 38	 add	 eax, 56			; 00000038H
  0004c	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax
$LN27@Unguarded_:

; 3717 : 
; 3718 : 	while (_First < _Pfirst
; 3719 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3720 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0004f	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00052	3b 45 f8	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00055	73 3b		 jae	 SHORT $LN25@Unguarded_
  00057	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0005e	83 e9 38	 sub	 ecx, 56			; 00000038H
  00061	51		 push	 ecx
  00062	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00065	83 c4 08	 add	 esp, 8
  00068	0f b6 d0	 movzx	 edx, al
  0006b	85 d2		 test	 edx, edx
  0006d	75 23		 jne	 SHORT $LN25@Unguarded_
  0006f	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00072	83 e8 38	 sub	 eax, 56			; 00000038H
  00075	50		 push	 eax
  00076	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00079	51		 push	 ecx
  0007a	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  0007d	83 c4 08	 add	 esp, 8
  00080	0f b6 d0	 movzx	 edx, al
  00083	85 d2		 test	 edx, edx
  00085	75 0b		 jne	 SHORT $LN25@Unguarded_

; 3721 : 		--_Pfirst;

  00087	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0008a	83 e8 38	 sub	 eax, 56			; 00000038H
  0008d	89 45 f8	 mov	 DWORD PTR __Pfirst$[ebp], eax
  00090	eb bd		 jmp	 SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  00092	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  00095	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00098	73 35		 jae	 SHORT $LN24@Unguarded_
  0009a	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __Plast$[ebp]
  000a1	51		 push	 ecx
  000a2	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  000a5	83 c4 08	 add	 esp, 8
  000a8	0f b6 d0	 movzx	 edx, al
  000ab	85 d2		 test	 edx, edx
  000ad	75 20		 jne	 SHORT $LN24@Unguarded_
  000af	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000b6	51		 push	 ecx
  000b7	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  000ba	83 c4 08	 add	 esp, 8
  000bd	0f b6 d0	 movzx	 edx, al
  000c0	85 d2		 test	 edx, edx
  000c2	75 0b		 jne	 SHORT $LN24@Unguarded_

; 3725 : 		++_Plast;

  000c4	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  000c7	83 c0 38	 add	 eax, 56			; 00000038H
  000ca	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax
  000cd	eb c3		 jmp	 SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3726 : 
; 3727 : 	_RanIt _Gfirst = _Plast;

  000cf	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  000d2	89 45 f0	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 3728 : 	_RanIt _Glast = _Pfirst;

  000d5	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000d8	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000db	eb 09		 jmp	 SHORT $LN21@Unguarded_
$LN20@Unguarded_:
  000dd	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000e0	83 c0 38	 add	 eax, 56			; 00000038H
  000e3	89 45 f0	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN21@Unguarded_:
  000e6	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000e9	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  000ec	73 51		 jae	 SHORT $LN19@Unguarded_

; 3733 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  000ee	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000f5	51		 push	 ecx
  000f6	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  000f9	83 c4 08	 add	 esp, 8
  000fc	0f b6 d0	 movzx	 edx, al
  000ff	85 d2		 test	 edx, edx
  00101	74 02		 je	 SHORT $LN18@Unguarded_
  00103	eb 38		 jmp	 SHORT $LN17@Unguarded_
$LN18@Unguarded_:

; 3734 : 				;
; 3735 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  00105	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00108	50		 push	 eax
  00109	8b 4d f0	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  0010c	51		 push	 ecx
  0010d	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00110	83 c4 08	 add	 esp, 8
  00113	0f b6 d0	 movzx	 edx, al
  00116	85 d2		 test	 edx, edx
  00118	74 04		 je	 SHORT $LN16@Unguarded_

; 3736 : 				break;

  0011a	eb 23		 jmp	 SHORT $LN19@Unguarded_

; 3737 : 			else

  0011c	eb 1f		 jmp	 SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3738 : 				_STD iter_swap(_Plast++, _Gfirst);

  0011e	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  00121	89 45 a8	 mov	 DWORD PTR tv147[ebp], eax
  00124	8b 4d f4	 mov	 ecx, DWORD PTR __Plast$[ebp]
  00127	83 c1 38	 add	 ecx, 56			; 00000038H
  0012a	89 4d f4	 mov	 DWORD PTR __Plast$[ebp], ecx
  0012d	8b 55 f0	 mov	 edx, DWORD PTR __Gfirst$[ebp]
  00130	52		 push	 edx
  00131	8b 45 a8	 mov	 eax, DWORD PTR tv147[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  0013a	83 c4 08	 add	 esp, 8
$LN17@Unguarded_:
  0013d	eb 9e		 jmp	 SHORT $LN20@Unguarded_
$LN19@Unguarded_:

; 3739 : 		for (; _First < _Glast; --_Glast)

  0013f	eb 09		 jmp	 SHORT $LN14@Unguarded_
$LN13@Unguarded_:
  00141	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  00144	83 e8 38	 sub	 eax, 56			; 00000038H
  00147	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
  0014a	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0014d	3b 45 ec	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00150	73 54		 jae	 SHORT $LN12@Unguarded_

; 3740 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  00152	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00155	50		 push	 eax
  00156	8b 4d ec	 mov	 ecx, DWORD PTR __Glast$[ebp]
  00159	83 e9 38	 sub	 ecx, 56			; 00000038H
  0015c	51		 push	 ecx
  0015d	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00160	83 c4 08	 add	 esp, 8
  00163	0f b6 d0	 movzx	 edx, al
  00166	85 d2		 test	 edx, edx
  00168	74 02		 je	 SHORT $LN11@Unguarded_
  0016a	eb 38		 jmp	 SHORT $LN10@Unguarded_
$LN11@Unguarded_:

; 3741 : 				;
; 3742 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  0016c	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  0016f	83 e8 38	 sub	 eax, 56			; 00000038H
  00172	50		 push	 eax
  00173	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00176	51		 push	 ecx
  00177	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  0017a	83 c4 08	 add	 esp, 8
  0017d	0f b6 d0	 movzx	 edx, al
  00180	85 d2		 test	 edx, edx
  00182	74 04		 je	 SHORT $LN9@Unguarded_

; 3743 : 				break;

  00184	eb 20		 jmp	 SHORT $LN12@Unguarded_

; 3744 : 			else

  00186	eb 1c		 jmp	 SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3745 : 				_STD iter_swap(--_Pfirst, _Glast - 1);

  00188	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0018b	83 e8 38	 sub	 eax, 56			; 00000038H
  0018e	89 45 f8	 mov	 DWORD PTR __Pfirst$[ebp], eax
  00191	8b 4d ec	 mov	 ecx, DWORD PTR __Glast$[ebp]
  00194	83 e9 38	 sub	 ecx, 56			; 00000038H
  00197	51		 push	 ecx
  00198	8b 55 f8	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  001a1	83 c4 08	 add	 esp, 8
$LN10@Unguarded_:
  001a4	eb 9b		 jmp	 SHORT $LN13@Unguarded_
$LN12@Unguarded_:

; 3746 : 		if (_Glast == _First && _Gfirst == _Last)

  001a6	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  001a9	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  001ac	75 20		 jne	 SHORT $LN7@Unguarded_
  001ae	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001b1	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  001b4	75 18		 jne	 SHORT $LN7@Unguarded_

; 3747 : 			return (_STD pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  001b6	8d 45 f4	 lea	 eax, DWORD PTR __Plast$[ebp]
  001b9	50		 push	 eax
  001ba	8d 4d f8	 lea	 ecx, DWORD PTR __Pfirst$[ebp]
  001bd	51		 push	 ecx
  001be	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001c1	e8 00 00 00 00	 call	 ??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$pair@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z ; std::pair<CustomBoxGroup *,CustomBoxGroup *>::pair<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>
  001c6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001c9	e9 d3 00 00 00	 jmp	 $LN28@Unguarded_
$LN7@Unguarded_:

; 3748 : 
; 3749 : 		if (_Glast == _First)

  001ce	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  001d1	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  001d4	75 51		 jne	 SHORT $LN6@Unguarded_

; 3750 : 			{	// no room at bottom, rotate pivot upward
; 3751 : 			if (_Plast != _Gfirst)

  001d6	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  001d9	3b 45 f0	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  001dc	74 10		 je	 SHORT $LN5@Unguarded_

; 3752 : 				_STD iter_swap(_Pfirst, _Plast);

  001de	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  001e1	50		 push	 eax
  001e2	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  001e5	51		 push	 ecx
  001e6	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  001eb	83 c4 08	 add	 esp, 8
$LN5@Unguarded_:

; 3753 : 			++_Plast;

  001ee	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  001f1	83 c0 38	 add	 eax, 56			; 00000038H
  001f4	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax

; 3754 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  001f7	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001fa	89 45 a8	 mov	 DWORD PTR tv178[ebp], eax
  001fd	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00200	89 4d a4	 mov	 DWORD PTR tv181[ebp], ecx
  00203	8b 55 f8	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  00206	83 c2 38	 add	 edx, 56			; 00000038H
  00209	89 55 f8	 mov	 DWORD PTR __Pfirst$[ebp], edx
  0020c	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0020f	83 c0 38	 add	 eax, 56			; 00000038H
  00212	89 45 f0	 mov	 DWORD PTR __Gfirst$[ebp], eax
  00215	8b 4d a8	 mov	 ecx, DWORD PTR tv178[ebp]
  00218	51		 push	 ecx
  00219	8b 55 a4	 mov	 edx, DWORD PTR tv181[ebp]
  0021c	52		 push	 edx
  0021d	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  00222	83 c4 08	 add	 esp, 8
  00225	eb 75		 jmp	 SHORT $LN4@Unguarded_
$LN6@Unguarded_:

; 3755 : 			}
; 3756 : 		else if (_Gfirst == _Last)

  00227	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0022a	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  0022d	75 45		 jne	 SHORT $LN3@Unguarded_

; 3757 : 			{	// no room at top, rotate pivot downward
; 3758 : 			if (--_Glast != --_Pfirst)

  0022f	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  00232	83 e8 38	 sub	 eax, 56			; 00000038H
  00235	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
  00238	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0023b	83 e9 38	 sub	 ecx, 56			; 00000038H
  0023e	89 4d f8	 mov	 DWORD PTR __Pfirst$[ebp], ecx
  00241	8b 55 ec	 mov	 edx, DWORD PTR __Glast$[ebp]
  00244	3b 55 f8	 cmp	 edx, DWORD PTR __Pfirst$[ebp]
  00247	74 10		 je	 SHORT $LN2@Unguarded_

; 3759 : 				_STD iter_swap(_Glast, _Pfirst);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d ec	 mov	 ecx, DWORD PTR __Glast$[ebp]
  00250	51		 push	 ecx
  00251	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  00256	83 c4 08	 add	 esp, 8
$LN2@Unguarded_:

; 3760 : 			_STD iter_swap(_Pfirst, --_Plast);

  00259	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  0025c	83 e8 38	 sub	 eax, 56			; 00000038H
  0025f	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax
  00262	8b 4d f4	 mov	 ecx, DWORD PTR __Plast$[ebp]
  00265	51		 push	 ecx
  00266	8b 55 f8	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  00269	52		 push	 edx
  0026a	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  0026f	83 c4 08	 add	 esp, 8

; 3761 : 			}
; 3762 : 		else

  00272	eb 28		 jmp	 SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3763 : 			_STD iter_swap(_Gfirst++, --_Glast);

  00274	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  00277	83 e8 38	 sub	 eax, 56			; 00000038H
  0027a	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
  0027d	8b 4d f0	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00280	89 4d a8	 mov	 DWORD PTR tv195[ebp], ecx
  00283	8b 55 ec	 mov	 edx, DWORD PTR __Glast$[ebp]
  00286	52		 push	 edx
  00287	8b 45 a8	 mov	 eax, DWORD PTR tv195[ebp]
  0028a	50		 push	 eax
  0028b	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  00290	83 c4 08	 add	 esp, 8
  00293	8b 4d f0	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00296	83 c1 38	 add	 ecx, 56			; 00000038H
  00299	89 4d f0	 mov	 DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3764 : 		}

  0029c	e9 3a fe ff ff	 jmp	 $LN23@Unguarded_
$LN28@Unguarded_:

; 3765 : 	}

  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi
  002a3	5b		 pop	 ebx
  002a4	8b e5		 mov	 esp, ebp
  002a6	5d		 pop	 ebp
  002a7	c3		 ret	 0
??$_Unguarded_partition@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YA?AU?$pair@PAUCustomBoxGroup@@PAU1@@0@PAUCustomBoxGroup@@0P6A_NABU2@1@Z@Z ENDP ; std::_Unguarded_partition<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z ; std::_Make_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
PUBLIC	??$_Dist_type@PAUCustomBoxGroup@@@std@@YAPAHPAUCustomBoxGroup@@@Z ; std::_Dist_type<CustomBoxGroup *>
PUBLIC	??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Val_type<CustomBoxGroup *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$make_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$make_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z PROC ; std::make_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2672 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2673 : 	_DEBUG_RANGE(_First, _Last);
; 2674 : 	_DEBUG_POINTER(_Pred);
; 2675 : 	if (1 < _Last - _First)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	99		 cdq
  00010	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00015	f7 f9		 idiv	 ecx
  00017	83 f8 01	 cmp	 eax, 1
  0001a	7e 40		 jle	 SHORT $LN2@make_heap

; 2676 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2677 : 			_Dist_type(_First), _Val_type(_First));

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Val_type<CustomBoxGroup *>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??$_Dist_type@PAUCustomBoxGroup@@@std@@YAPAHPAUCustomBoxGroup@@@Z ; std::_Dist_type<CustomBoxGroup *>
  00032	83 c4 04	 add	 esp, 4
  00035	50		 push	 eax
  00036	8b 55 10	 mov	 edx, DWORD PTR __Pred$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
  00050	83 c4 04	 add	 esp, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z ; std::_Make_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00059	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@make_heap:

; 2678 : 	}

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$make_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ENDP ; std::make_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::_Sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z PROC ; std::sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2708 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2709 : 	_DEBUG_RANGE(_First, _Last);
; 2710 : 	_DEBUG_POINTER(_Pred);
; 2711 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2712 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
  00016	83 c4 04	 add	 esp, 4
  00019	50		 push	 eax
  0001a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$_Sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::_Sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 : 	}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ENDP ; std::sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z ; std::_Insertion_sort1<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &),CustomBoxGroup>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Insertion_sort@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z PROC ; std::_Insertion_sort<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 3676 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3677 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Val_type<CustomBoxGroup *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z ; std::_Insertion_sort1<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &),CustomBoxGroup>
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 3678 : 	}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Insertion_sort@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ENDP ; std::_Insertion_sort<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z PROC ; std::move<CustomBoxGroup &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ENDP ; std::move<CustomBoxGroup &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z PROC ; std::_Val_type<std::pair<int,int> *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ENDP ; std::_Val_type<std::pair<int,int> *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> >,std::pair<int,int> >, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@U32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> >
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> >,std::pair<int,int> >
PUBLIC	?destroy@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@@Z ; std::allocator<std::pair<int,int> >::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@@Z ; std::allocator<std::pair<int,int> >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@@Z ; std::allocator<CustomBoxGroup>::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@@Z PROC ; std::_Dest_val<std::allocator<CustomBoxGroup>,CustomBoxGroup>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@@Z ; std::allocator<CustomBoxGroup>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@@Z ENDP ; std::_Dest_val<std::allocator<CustomBoxGroup>,CustomBoxGroup>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup>,CustomBoxGroup>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@@Z
_TEXT	SEGMENT
$T231288 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@@Z PROC ; std::_Uninitialized_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231288[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231288[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Val_type<CustomBoxGroup *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup>,CustomBoxGroup>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@@Z ENDP ; std::_Uninitialized_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup> >
_TEXT	ENDS
PUBLIC	??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z
_TEXT	SEGMENT
$T231291 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z PROC ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>, COMDAT

; 2163 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2164 : 	return (_Copy_impl(_First, _Last,
; 2165 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231291[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231291[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2166 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ENDP ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Uninitialized_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::pair<int,int> *>, COMDAT
; _this$ = ecx

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Uninitialized_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1319 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::pair<int,int> *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
PUBLIC	??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z
_TEXT	SEGMENT
$T231298 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z PROC ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231298[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231298[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00@Z ENDP ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>
_TEXT	ENDS
PUBLIC	??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0CustomBoxGroup@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CustomBoxGroup@@QAE@ABU0@@Z PROC			; CustomBoxGroup::CustomBoxGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 10		 mov	 DWORD PTR [eax], edx
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00028	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002b	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00034	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00037	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00040	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00043	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0004c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004f	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00058	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005b	89 50 18	 mov	 DWORD PTR [eax+24], edx
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00064	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00067	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00070	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00073	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0007c	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0007f	89 50 24	 mov	 DWORD PTR [eax+36], edx
  00082	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00085	83 c0 28	 add	 eax, 40			; 00000028H
  00088	50		 push	 eax
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	83 c1 28	 add	 ecx, 40			; 00000028H
  0008f	e8 00 00 00 00	 call	 ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
??0CustomBoxGroup@@QAE@ABU0@@Z ENDP			; CustomBoxGroup::CustomBoxGroup
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@1@0PAU21@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > > >
PUBLIC	?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin
PUBLIC	?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv157 = -108						; size = 4
tv156 = -104						; size = 4
tv69 = -100						; size = 4
$T231304 = -96						; size = 4
$T231305 = -92						; size = 4
$T231306 = -88						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >, COMDAT
; _this$ = ecx

; 535  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	83 c0 0c	 add	 eax, 12			; 0000000cH
  00035	51		 push	 ecx
  00036	8b cc		 mov	 ecx, esp
  00038	89 65 a0	 mov	 DWORD PTR $T231304[ebp], esp
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@HH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int,int> >::allocator<std::pair<int,int> >
  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@V?$allocator@U?$pair@HH@std@@@1@@Z ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 536  : 		if (_Buy(_Right.size()))

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00053	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::size
  00058	50		 push	 eax
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Buy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Buy
  00061	0f b6 c0	 movzx	 eax, al
  00064	85 c0		 test	 eax, eax
  00066	74 6f		 je	 SHORT $LN3@vector@2

; 537  : 			_TRY_BEGIN

  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

  0006c	8d 45 a4	 lea	 eax, DWORD PTR $T231305[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00073	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end
  00078	89 45 9c	 mov	 DWORD PTR tv69[ebp], eax
  0007b	8d 4d a8	 lea	 ecx, DWORD PTR $T231306[ebp]
  0007e	51		 push	 ecx
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00082	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin
  00087	89 45 98	 mov	 DWORD PTR tv156[ebp], eax
  0008a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	50		 push	 eax
  00090	8b 4d 9c	 mov	 ecx, DWORD PTR tv69[ebp]
  00093	8b 11		 mov	 edx, DWORD PTR [ecx]
  00095	52		 push	 edx
  00096	8b 45 98	 mov	 eax, DWORD PTR tv156[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	51		 push	 ecx
  0009c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@1@0PAU21@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > > >
  000a4	89 45 94	 mov	 DWORD PTR tv157[ebp], eax
  000a7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	8b 45 94	 mov	 eax, DWORD PTR tv157[ebp]
  000ad	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000b0	eb 1e		 jmp	 SHORT $LN5@vector@2
__catch$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Tidy

; 542  : 			_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8

; 543  : 			_CATCH_END

  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ca	b8 00 00 00 00	 mov	 eax, $LN3@vector@2
  000cf	c3		 ret	 0
$LN5@vector@2:
  000d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@2:

; 544  : 		}

  000d7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000de	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >::~_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > >
__ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >
PUBLIC	??$_Destroy@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@@Z ; std::_Destroy<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@@Z PROC ; std::allocator<std::pair<int,int> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@@Z ; std::_Destroy<std::pair<int,int> >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@@Z ENDP ; std::allocator<std::pair<int,int> >::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCustomBoxGroup@@@std@@YAXPAUCustomBoxGroup@@@Z ; std::_Destroy<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@@Z PROC ; std::allocator<CustomBoxGroup>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UCustomBoxGroup@@@std@@YAXPAUCustomBoxGroup@@@Z ; std::_Destroy<CustomBoxGroup>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@@Z ENDP ; std::allocator<CustomBoxGroup>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		return (const_iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 788  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 797  : 		return (const_iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@PAU?$pair@HH@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 798  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::end
_TEXT	ENDS
PUBLIC	??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__Step$230162 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Median@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z PROC ; std::_Median<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 3695 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3696 : 	if (40 < _Last - _First)

  00009	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	99		 cdq
  00010	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00015	f7 f9		 idiv	 ecx
  00017	83 f8 28	 cmp	 eax, 40			; 00000028H
  0001a	0f 8e bb 00 00
	00		 jle	 $LN2@Median

; 3697 : 		{	// median of nine
; 3698 : 		size_t _Step = (_Last - _First + 1) / 8;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00023	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00026	99		 cdq
  00027	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0002c	f7 f9		 idiv	 ecx
  0002e	83 c0 01	 add	 eax, 1
  00031	99		 cdq
  00032	83 e2 07	 and	 edx, 7
  00035	03 c2		 add	 eax, edx
  00037	c1 f8 03	 sar	 eax, 3
  0003a	89 45 fc	 mov	 DWORD PTR __Step$230162[ebp], eax

; 3699 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  0003d	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230162[ebp]
  00044	d1 e1		 shl	 ecx, 1
  00046	6b c9 38	 imul	 ecx, 56			; 00000038H
  00049	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 fc	 mov	 edx, DWORD PTR __Step$230162[ebp]
  00050	6b d2 38	 imul	 edx, 56			; 00000038H
  00053	03 55 08	 add	 edx, DWORD PTR __First$[ebp]
  00056	52		 push	 edx
  00057	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00060	83 c4 10	 add	 esp, 16			; 00000010H

; 3700 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00063	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230162[ebp]
  0006a	6b c9 38	 imul	 ecx, 56			; 00000038H
  0006d	03 4d 0c	 add	 ecx, DWORD PTR __Mid$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  00074	52		 push	 edx
  00075	8b 45 fc	 mov	 eax, DWORD PTR __Step$230162[ebp]
  00078	6b c0 38	 imul	 eax, 56			; 00000038H
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0007e	2b c8		 sub	 ecx, eax
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00086	83 c4 10	 add	 esp, 16			; 00000010H

; 3701 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00089	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 fc	 mov	 edx, DWORD PTR __Step$230162[ebp]
  00094	6b d2 38	 imul	 edx, 56			; 00000038H
  00097	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0009a	2b c2		 sub	 eax, edx
  0009c	50		 push	 eax
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230162[ebp]
  000a0	d1 e1		 shl	 ecx, 1
  000a2	6b c9 38	 imul	 ecx, 56			; 00000038H
  000a5	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  000a8	2b d1		 sub	 edx, ecx
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 3702 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  000b3	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230162[ebp]
  000ba	6b c9 38	 imul	 ecx, 56			; 00000038H
  000bd	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  000c0	2b d1		 sub	 edx, ecx
  000c2	52		 push	 edx
  000c3	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230162[ebp]
  000ca	6b c9 38	 imul	 ecx, 56			; 00000038H
  000cd	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000d6	83 c4 10	 add	 esp, 16			; 00000010H

; 3703 : 		}
; 3704 : 	else

  000d9	eb 18		 jmp	 SHORT $LN3@Median
$LN2@Median:

; 3705 : 		_Med3(_First, _Mid, _Last, _Pred);

  000db	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000de	50		 push	 eax
  000df	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000e2	51		 push	 ecx
  000e3	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  000e6	52		 push	 edx
  000e7	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000f0	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@Median:

; 3706 : 	}

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
??$_Median@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ENDP ; std::_Median<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z ; std::swap<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z PROC ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>, COMDAT

; 2133 : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2134 : 	swap(*_Left, *_Right);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z ; std::swap<CustomBoxGroup>
  00016	83 c4 08	 add	 esp, 8

; 2135 : 	}

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ENDP ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
_TEXT	ENDS
PUBLIC	??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$_Pair_base@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z ; std::_Pair_base<CustomBoxGroup *,CustomBoxGroup *>::_Pair_base<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>
PUBLIC	??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z ; std::forward<CustomBoxGroup * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$pair@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$pair@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z PROC ; std::pair<CustomBoxGroup *,CustomBoxGroup *>::pair<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z ; std::forward<CustomBoxGroup * &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z ; std::forward<CustomBoxGroup * &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$_Pair_base@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z ; std::_Pair_base<CustomBoxGroup *,CustomBoxGroup *>::_Pair_base<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$pair@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z ENDP ; std::pair<CustomBoxGroup *,CustomBoxGroup *>::pair<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z PROC ; std::_Unchecked<CustomBoxGroup *>, COMDAT

; 266  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 267  : 	return (_Src);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 268  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ENDP ; std::_Unchecked<CustomBoxGroup *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Dist_type@PAUCustomBoxGroup@@@std@@YAPAHPAUCustomBoxGroup@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUCustomBoxGroup@@@std@@YAPAHPAUCustomBoxGroup@@@Z PROC ; std::_Dist_type<CustomBoxGroup *>, COMDAT

; 849  : 	{	// return distance type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 850  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 851  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Dist_type@PAUCustomBoxGroup@@@std@@YAPAHPAUCustomBoxGroup@@@Z ENDP ; std::_Dist_type<CustomBoxGroup *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z PROC ; std::_Val_type<CustomBoxGroup *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ENDP ; std::_Val_type<CustomBoxGroup *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ; std::_Adjust_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	SEGMENT
__unwindtable$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z$0
__ehfuncinfo$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z
_TEXT	SEGMENT
__Val$230212 = -76					; size = 56
__Hole$230208 = -20					; size = 4
__Bottom$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z PROC ; std::_Make_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2658 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2659 : 	_Diff _Bottom = _Last - _First;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00031	99		 cdq
  00032	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00037	f7 f9		 idiv	 ecx
  00039	89 45 f0	 mov	 DWORD PTR __Bottom$[ebp], eax

; 2660 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  0003c	8b 45 f0	 mov	 eax, DWORD PTR __Bottom$[ebp]
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	89 45 ec	 mov	 DWORD PTR __Hole$230208[ebp], eax
$LN2@Make_heap:
  00047	83 7d ec 00	 cmp	 DWORD PTR __Hole$230208[ebp], 0
  0004b	7e 61		 jle	 SHORT $LN3@Make_heap

; 2661 : 		{	// reheap top half, bottom to top
; 2662 : 		--_Hole;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR __Hole$230208[ebp]
  00050	83 e8 01	 sub	 eax, 1
  00053	89 45 ec	 mov	 DWORD PTR __Hole$230208[ebp], eax

; 2663 : 		_Ty _Val = _Move(*(_First + _Hole));

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Hole$230208[ebp]
  00059	6b c0 38	 imul	 eax, 56			; 00000038H
  0005c	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00065	83 c4 04	 add	 esp, 4
  00068	50		 push	 eax
  00069	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230212[ebp]
  0006c	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@ABU0@@Z
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2664 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2665 : 			_Move(_Val), _Pred);

  00078	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0007b	50		 push	 eax
  0007c	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230212[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00085	83 c4 04	 add	 esp, 4
  00088	50		 push	 eax
  00089	8b 55 f0	 mov	 edx, DWORD PTR __Bottom$[ebp]
  0008c	52		 push	 edx
  0008d	8b 45 ec	 mov	 eax, DWORD PTR __Hole$230208[ebp]
  00090	50		 push	 eax
  00091	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ; std::_Adjust_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  0009a	83 c4 14	 add	 esp, 20			; 00000014H

; 2666 : 		}

  0009d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a4	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230212[ebp]
  000a7	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
  000ac	eb 99		 jmp	 SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2667 : 	}

  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230212[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CustomBoxGroup@@QAE@XZ
__ehhandler$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Make_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@ZPAH0@Z ENDP ; std::_Make_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
PUBLIC	??$_Pop_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::_Pop_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z PROC ; std::_Sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2700 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2701 : 	for (; 1 < _Last - _First; --_Last)

  00009	eb 09		 jmp	 SHORT $LN3@Sort_heap
$LN2@Sort_heap:
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	83 e8 38	 sub	 eax, 56			; 00000038H
  00011	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN3@Sort_heap:
  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0001a	99		 cdq
  0001b	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00020	f7 f9		 idiv	 ecx
  00022	83 f8 01	 cmp	 eax, 1
  00025	7e 16		 jle	 SHORT $LN4@Sort_heap

; 2702 : 		_Pop_heap(_First, _Last, _Pred);

  00027	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$_Pop_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ; std::_Pop_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	eb ce		 jmp	 SHORT $LN2@Sort_heap
$LN4@Sort_heap:

; 2703 : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Sort_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ENDP ; std::_Sort_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z$0
__ehfuncinfo$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
_TEXT	SEGMENT
__First1$230257 = -80					; size = 4
__Val$230247 = -76					; size = 56
__Next1$230246 = -20					; size = 4
__Next$230242 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z PROC ; std::_Insertion_sort1<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &),CustomBoxGroup>, COMDAT

; 3650 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 3651 : 	if (_First != _Last)

  0002b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00031	0f 84 f2 00 00
	00		 je	 $LN9@Insertion_

; 3652 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00037	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003a	89 45 f0	 mov	 DWORD PTR __Next$230242[ebp], eax
$LN7@Insertion_:
  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Next$230242[ebp]
  00040	83 c0 38	 add	 eax, 56			; 00000038H
  00043	89 45 f0	 mov	 DWORD PTR __Next$230242[ebp], eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR __Next$230242[ebp]
  00049	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0004c	0f 84 d7 00 00
	00		 je	 $LN9@Insertion_

; 3653 : 			{	// order next element
; 3654 : 			_BidIt _Next1 = _Next;

  00052	8b 45 f0	 mov	 eax, DWORD PTR __Next$230242[ebp]
  00055	89 45 ec	 mov	 DWORD PTR __Next1$230246[ebp], eax

; 3655 : 			_Ty _Val = _Move(*_Next);

  00058	8b 45 f0	 mov	 eax, DWORD PTR __Next$230242[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00061	83 c4 04	 add	 esp, 4
  00064	50		 push	 eax
  00065	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230247[ebp]
  00068	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@ABU0@@Z
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3656 : 
; 3657 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  00074	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00077	50		 push	 eax
  00078	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230247[ebp]
  0007b	51		 push	 ecx
  0007c	ff 55 10	 call	 DWORD PTR __Pred$[ebp]
  0007f	83 c4 08	 add	 esp, 8
  00082	0f b6 d0	 movzx	 edx, al
  00085	85 d2		 test	 edx, edx
  00087	74 34		 je	 SHORT $LN5@Insertion_

; 3658 : 				{	// found new earliest element, move to front
; 3659 : 				_Move_backward(_First, _Next, ++_Next1);

  00089	8b 45 ec	 mov	 eax, DWORD PTR __Next1$230246[ebp]
  0008c	83 c0 38	 add	 eax, 56			; 00000038H
  0008f	89 45 ec	 mov	 DWORD PTR __Next1$230246[ebp], eax
  00092	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$230246[ebp]
  00095	51		 push	 ecx
  00096	8b 55 f0	 mov	 edx, DWORD PTR __Next$230242[ebp]
  00099	52		 push	 edx
  0009a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3660 : 				*_First = _Move(_Val);

  000a6	8d 45 b4	 lea	 eax, DWORD PTR __Val$230247[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  000af	83 c4 04	 add	 esp, 4
  000b2	50		 push	 eax
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b6	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 3661 : 				}
; 3662 : 			else

  000bb	eb 58		 jmp	 SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;

  000bd	8b 45 ec	 mov	 eax, DWORD PTR __Next1$230246[ebp]
  000c0	89 45 b0	 mov	 DWORD PTR __First1$230257[ebp], eax
  000c3	eb 06		 jmp	 SHORT $LN3@Insertion_
$LN2@Insertion_:

; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  000c5	8b 45 b0	 mov	 eax, DWORD PTR __First1$230257[ebp]
  000c8	89 45 ec	 mov	 DWORD PTR __Next1$230246[ebp], eax
$LN3@Insertion_:
  000cb	8b 45 b0	 mov	 eax, DWORD PTR __First1$230257[ebp]
  000ce	83 e8 38	 sub	 eax, 56			; 00000038H
  000d1	89 45 b0	 mov	 DWORD PTR __First1$230257[ebp], eax
  000d4	8b 4d b0	 mov	 ecx, DWORD PTR __First1$230257[ebp]
  000d7	51		 push	 ecx
  000d8	8d 55 b4	 lea	 edx, DWORD PTR __Val$230247[ebp]
  000db	52		 push	 edx
  000dc	ff 55 10	 call	 DWORD PTR __Pred$[ebp]
  000df	83 c4 08	 add	 esp, 8
  000e2	0f b6 c0	 movzx	 eax, al
  000e5	85 c0		 test	 eax, eax
  000e7	74 17		 je	 SHORT $LN1@Insertion_

; 3667 : 					*_Next1 = _Move(*_First1);	// move hole down

  000e9	8b 45 b0	 mov	 eax, DWORD PTR __First1$230257[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  000f2	83 c4 04	 add	 esp, 4
  000f5	50		 push	 eax
  000f6	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$230246[ebp]
  000f9	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z
  000fe	eb c5		 jmp	 SHORT $LN2@Insertion_
$LN1@Insertion_:

; 3668 : 				*_Next1 = _Move(_Val);	// insert element in hole

  00100	8d 45 b4	 lea	 eax, DWORD PTR __Val$230247[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00109	83 c4 04	 add	 esp, 4
  0010c	50		 push	 eax
  0010d	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$230246[ebp]
  00110	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z
$LN4@Insertion_:

; 3669 : 				}
; 3670 : 			}

  00115	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011c	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230247[ebp]
  0011f	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
  00124	e9 14 ff ff ff	 jmp	 $LN7@Insertion_
$LN9@Insertion_:

; 3671 : 	}

  00129	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00133	59		 pop	 ecx
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5b		 pop	 ebx
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Val$230247[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CustomBoxGroup@@QAE@XZ
__ehhandler$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort1@PAUCustomBoxGroup@@P6A_NABU1@0@ZU1@@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z ENDP ; std::_Insertion_sort1<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &),CustomBoxGroup>
PUBLIC	??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@U3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup>,CustomBoxGroup>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 38	 add	 eax, 56			; 00000038H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 38	 add	 ecx, 56			; 00000038H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@U3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 38	 add	 eax, 56			; 00000038H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@@Z ; std::_Dest_val<std::allocator<CustomBoxGroup>,CustomBoxGroup>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUCustomBoxGroup@@PAU1@V?$allocator@UCustomBoxGroup@@@std@@U1@@std@@YAPAUCustomBoxGroup@@PAU1@00AAV?$allocator@UCustomBoxGroup@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CustomBoxGroup *,CustomBoxGroup *,std::allocator<CustomBoxGroup>,CustomBoxGroup>
PUBLIC	??4?$pair@HH@std@@QAEAAU01@ABU01@@Z		; std::pair<int,int>::operator=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>, COMDAT

; 2142 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2143 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Copy_impl
$LN2@Copy_impl:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Copy_impl:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 0e		 je	 SHORT $LN1@Copy_impl

; 2144 : 		*_Dest = *_First;

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002c	e8 00 00 00 00	 call	 ??4?$pair@HH@std@@QAEAAU01@ABU01@@Z ; std::pair<int,int>::operator=
  00031	eb d8		 jmp	 SHORT $LN2@Copy_impl
$LN1@Copy_impl:

; 2145 : 	return (_Dest);

  00033	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2146 : 	}

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Copy_impl@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<std::pair<int,int> *,std::pair<int,int> *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z
_TEXT	SEGMENT
$T231380 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int> >
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231380[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231380[ebp]
  00020	52		 push	 edx
  00021	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
  00036	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Uninitialized_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
_TEXT	ENDS
PUBLIC	??4?$pair@HH@std@@QAEAAU01@$$QAU01@@Z		; std::pair<int,int>::operator=
PUBLIC	??$move@AAU?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::move<std::pair<int,int> &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@2
$LN2@Move@2:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@2:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 17		 je	 SHORT $LN1@Move@2

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAU?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::move<std::pair<int,int> &>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	e8 00 00 00 00	 call	 ??4?$pair@HH@std@@QAEAAU01@$$QAU01@@Z ; std::pair<int,int>::operator=
  0003a	eb cf		 jmp	 SHORT $LN2@Move@2
$LN1@Move@2:

; 2515 : 	return (_Dest);

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Move@PAU?$pair@HH@std@@PAU12@@std@@YAPAU?$pair@HH@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::pair<int,int> *,std::pair<int,int> *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@1@0PAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@1@0PAU21@@Z PROC ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > > >, COMDAT
; _this$ = ecx

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1319 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@1@0PAU21@@Z ENDP ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@@Z PROC ; std::_Destroy<std::pair<int,int> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@@Z ENDP ; std::_Destroy<std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??_GCustomBoxGroup@@QAEPAXI@Z			; CustomBoxGroup::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy@UCustomBoxGroup@@@std@@YAXPAUCustomBoxGroup@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCustomBoxGroup@@@std@@YAXPAUCustomBoxGroup@@@Z PROC ; std::_Destroy<CustomBoxGroup>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();

  00009	6a 00		 push	 0
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	e8 00 00 00 00	 call	 ??_GCustomBoxGroup@@QAEPAXI@Z

; 64   : 	}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Destroy@UCustomBoxGroup@@@std@@YAXPAUCustomBoxGroup@@@Z ENDP ; std::_Destroy<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_GCustomBoxGroup@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCustomBoxGroup@@QAEPAXI@Z PROC			; CustomBoxGroup::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCustomBoxGroup@@QAEPAXI@Z ENDP			; CustomBoxGroup::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??4?$pair@HH@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$pair@HH@std@@QAEAAU01@ABU01@@Z PROC		; std::pair<int,int>::operator=, COMDAT
; _this$ = ecx

; 215  : 		{	// assign from copied pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 		this->first = _Right.first;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 10		 mov	 DWORD PTR [eax], edx

; 217  : 		this->second = _Right.second;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 218  : 		return (*this);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 219  : 		}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4?$pair@HH@std@@QAEAAU01@ABU01@@Z ENDP		; std::pair<int,int>::operator=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??4?$pair@HH@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$pair@HH@std@@QAEAAU01@$$QAU01@@Z PROC		; std::pair<int,int>::operator=, COMDAT
; _this$ = ecx

; 259  : 		{	// assign from moved pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 260  : 		this->first = _STD move(_Right.first);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx

; 261  : 		this->second = _STD move(_Right.second);

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00022	83 c0 04	 add	 eax, 4
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 262  : 		return (*this);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 263  : 		}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??4?$pair@HH@std@@QAEAAU01@$$QAU01@@Z ENDP		; std::pair<int,int>::operator=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z PROC ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 3683 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3684 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00010	51		 push	 ecx
  00011	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00014	83 c4 08	 add	 esp, 8
  00017	0f b6 d0	 movzx	 edx, al
  0001a	85 d2		 test	 edx, edx
  0001c	74 10		 je	 SHORT $LN3@Med3

; 3685 : 		_STD iter_swap(_Mid, _First);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  0002b	83 c4 08	 add	 esp, 8
$LN3@Med3:

; 3686 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00035	51		 push	 ecx
  00036	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00039	83 c4 08	 add	 esp, 8
  0003c	0f b6 d0	 movzx	 edx, al
  0003f	85 d2		 test	 edx, edx
  00041	74 10		 je	 SHORT $LN2@Med3

; 3687 : 		_STD iter_swap(_Last, _Mid);

  00043	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  00050	83 c4 08	 add	 esp, 8
$LN2@Med3:

; 3688 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00053	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0005a	51		 push	 ecx
  0005b	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  0005e	83 c4 08	 add	 esp, 8
  00061	0f b6 d0	 movzx	 edx, al
  00064	85 d2		 test	 edx, edx
  00066	74 10		 je	 SHORT $LN4@Med3

; 3689 : 		_STD iter_swap(_Mid, _First);

  00068	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ??$iter_swap@PAUCustomBoxGroup@@PAU1@@std@@YAXPAUCustomBoxGroup@@0@Z ; std::iter_swap<CustomBoxGroup *,CustomBoxGroup *>
  00075	83 c4 08	 add	 esp, 8
$LN4@Med3:

; 3690 : 	}

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
??$_Med3@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00P6A_NABU1@1@Z@Z ENDP ; std::_Med3<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z$0
__ehfuncinfo$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
__Tmp$ = -68						; size = 56
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z PROC ; std::swap<CustomBoxGroup>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8d 4d bc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00038	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@ABU0@@Z
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 103  : 	_Left = _Move(_Right);

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  0004d	83 c4 04	 add	 esp, 4
  00050	50		 push	 eax
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00054	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 104  : 	_Right = _Move(_Tmp);

  00059	8d 45 bc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00069	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 105  : 	}

  0006e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00075	8d 4d bc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00078	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CustomBoxGroup@@QAE@XZ
__ehhandler$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$swap@UCustomBoxGroup@@@std@@YAXAAUCustomBoxGroup@@0@Z ENDP ; std::swap<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z PROC ; std::forward<CustomBoxGroup * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z ENDP ; std::forward<CustomBoxGroup * &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$_Pair_base@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$_Pair_base@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z PROC ; std::_Pair_base<CustomBoxGroup *,CustomBoxGroup *>::_Pair_base<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z ; std::forward<CustomBoxGroup * &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAPAUCustomBoxGroup@@@std@@YAAAPAUCustomBoxGroup@@AAPAU1@@Z ; std::forward<CustomBoxGroup * &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAPAUCustomBoxGroup@@AAPAU0@@?$_Pair_base@PAUCustomBoxGroup@@PAU1@@std@@QAE@AAPAUCustomBoxGroup@@0@Z ENDP ; std::_Pair_base<CustomBoxGroup *,CustomBoxGroup *>::_Pair_base<CustomBoxGroup *,CustomBoxGroup *><CustomBoxGroup * &,CustomBoxGroup * &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z PROC ; std::_Move<CustomBoxGroup &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ENDP ; std::_Move<CustomBoxGroup &>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ; std::_Push_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z
_TEXT	SEGMENT
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Adjust_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z PROC ; std::_Adjust_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2565 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2566 : 	_Diff _Top = _Hole;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Top$[ebp], eax

; 2567 : 	_Diff _Idx = 2 * _Hole + 2;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00012	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00016	89 4d f8	 mov	 DWORD PTR __Idx$[ebp], ecx
  00019	eb 0a		 jmp	 SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:

; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001e	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00022	89 4d f8	 mov	 DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
  00025	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00028	3b 45 10	 cmp	 eax, DWORD PTR __Bottom$[ebp]
  0002b	7d 56		 jge	 SHORT $LN3@Adjust_hea

; 2570 : 		{	// move _Hole down to larger child
; 2571 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00030	83 e8 01	 sub	 eax, 1
  00033	6b c0 38	 imul	 eax, 56			; 00000038H
  00036	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR __Idx$[ebp]
  0003d	6b c9 38	 imul	 ecx, 56			; 00000038H
  00040	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00043	51		 push	 ecx
  00044	ff 55 18	 call	 DWORD PTR __Pred$[ebp]
  00047	83 c4 08	 add	 esp, 8
  0004a	0f b6 d0	 movzx	 edx, al
  0004d	85 d2		 test	 edx, edx
  0004f	74 09		 je	 SHORT $LN2@Adjust_hea

; 2572 : 			--_Idx;

  00051	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00054	83 e8 01	 sub	 eax, 1
  00057	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2573 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0005d	6b c0 38	 imul	 eax, 56			; 00000038H
  00060	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00069	83 c4 04	 add	 esp, 4
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  00070	6b c9 38	 imul	 ecx, 56			; 00000038H
  00073	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00076	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 2574 : 		_Hole = _Idx;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0007e	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 2575 : 		}

  00081	eb 98		 jmp	 SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2576 : 
; 2577 : 	if (_Idx == _Bottom)

  00083	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00086	3b 45 10	 cmp	 eax, DWORD PTR __Bottom$[ebp]
  00089	75 2d		 jne	 SHORT $LN1@Adjust_hea

; 2578 : 		{	// only child at bottom, move _Hole down to it
; 2579 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  0008b	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  0008e	83 e8 01	 sub	 eax, 1
  00091	6b c0 38	 imul	 eax, 56			; 00000038H
  00094	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  0009d	83 c4 04	 add	 esp, 4
  000a0	50		 push	 eax
  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  000a4	6b c9 38	 imul	 ecx, 56			; 00000038H
  000a7	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  000aa	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 2580 : 		_Hole = _Bottom - 1;

  000af	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000b2	83 e8 01	 sub	 eax, 1
  000b5	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN1@Adjust_hea:

; 2581 : 		}
; 2582 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  000b8	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 fc	 mov	 edx, DWORD PTR __Top$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ??$_Push_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ; std::_Push_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  000da	83 c4 14	 add	 esp, 20			; 00000014H

; 2583 : 	}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
??$_Adjust_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ENDP ; std::_Adjust_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z ; std::_Pop_heap_0<CustomBoxGroup *,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Pop_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z PROC ; std::_Pop_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2610 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2611 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2612 : 		_Val_type(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Val_type@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Val_type<CustomBoxGroup *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unchecked@PAUCustomBoxGroup@@@std@@YAPAUCustomBoxGroup@@PAU1@@Z ; std::_Unchecked<CustomBoxGroup *>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z ; std::_Pop_heap_0<CustomBoxGroup *,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 2613 : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$_Pop_heap@PAUCustomBoxGroup@@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z@Z ENDP ; std::_Pop_heap<CustomBoxGroup *,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z
_TEXT	SEGMENT
$T231418 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z PROC ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>, COMDAT

; 2638 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2639 : 	return (_Move_backward(_First, _Last,
; 2640 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCustomBoxGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCustomBoxGroup@@0@Z ; std::_Ptr_cat<CustomBoxGroup,CustomBoxGroup>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231418[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231418[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2641 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00@Z ENDP ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z ; std::allocator<CustomBoxGroup>::construct
PUBLIC	??$forward@UCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@U3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@U3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z ; std::allocator<CustomBoxGroup>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCustomBoxGroup@@@std@@UCustomBoxGroup@@U3@@std@@YAXAAV?$allocator@UCustomBoxGroup@@@0@PAUCustomBoxGroup@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CustomBoxGroup>,CustomBoxGroup,CustomBoxGroup>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> &>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >, COMDAT

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 373  : 
; 374  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:

; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_cop:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_cop

; 376  : 		_Cons_val(_Al, _Dest, *_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 377  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:

; 378  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_cop

; 379  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 380  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 381  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_cop:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 382  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 383  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAU?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z PROC ; std::move<std::pair<int,int> &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAU?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ENDP ; std::move<std::pair<int,int> &>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@AAPAU?$pair@HH@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@@Z
_TEXT	SEGMENT
$T231440 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00009	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@AAPAU?$pair@HH@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231440[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231440[ebp]
  00020	52		 push	 edx
  00021	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
  00036	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T231443 = -88						; size = 4
$T231444 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z PROC ; std::allocator<CustomBoxGroup>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 38		 push	 56			; 00000038H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231444[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231444[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::forward<CustomBoxGroup>
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T231444[ebp]
  00059	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@ABU0@@Z
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@3:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T231443[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231444[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UCustomBoxGroup@@@std@@QAEXPAUCustomBoxGroup@@$$QAU3@@Z ENDP ; std::allocator<CustomBoxGroup>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z
_TEXT	SEGMENT
__Idx$230496 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Push_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z PROC ; std::_Push_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2455 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2456 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	89 45 fc	 mov	 DWORD PTR __Idx$230496[ebp], eax
  00017	eb 0e		 jmp	 SHORT $LN3@Push_heap
$LN2@Push_heap:

; 2457 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2458 : 		_Idx = (_Hole - 1) / 2)

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0001c	83 e8 01	 sub	 eax, 1
  0001f	99		 cdq
  00020	2b c2		 sub	 eax, edx
  00022	d1 f8		 sar	 eax, 1
  00024	89 45 fc	 mov	 DWORD PTR __Idx$230496[ebp], eax
$LN3@Push_heap:
  00027	8b 45 10	 mov	 eax, DWORD PTR __Top$[ebp]
  0002a	3b 45 0c	 cmp	 eax, DWORD PTR __Hole$[ebp]
  0002d	7d 44		 jge	 SHORT $LN1@Push_heap
  0002f	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR __Idx$230496[ebp]
  00036	6b c9 38	 imul	 ecx, 56			; 00000038H
  00039	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0003c	51		 push	 ecx
  0003d	ff 55 18	 call	 DWORD PTR __Pred$[ebp]
  00040	83 c4 08	 add	 esp, 8
  00043	0f b6 d0	 movzx	 edx, al
  00046	85 d2		 test	 edx, edx
  00048	74 29		 je	 SHORT $LN1@Push_heap

; 2459 : 		{	// move _Hole up to parent
; 2460 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0004a	8b 45 fc	 mov	 eax, DWORD PTR __Idx$230496[ebp]
  0004d	6b c0 38	 imul	 eax, 56			; 00000038H
  00050	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00059	83 c4 04	 add	 esp, 4
  0005c	50		 push	 eax
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  00060	6b c9 38	 imul	 ecx, 56			; 00000038H
  00063	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 2461 : 		_Hole = _Idx;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR __Idx$230496[ebp]
  0006e	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 2462 : 		}

  00071	eb a6		 jmp	 SHORT $LN2@Push_heap
$LN1@Push_heap:

; 2463 : 
; 2464 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00073	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  0007c	83 c4 04	 add	 esp, 4
  0007f	50		 push	 eax
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  00083	6b c9 38	 imul	 ecx, 56			; 00000038H
  00086	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00089	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 2465 : 	}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
??$_Push_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ENDP ; std::_Push_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00$$QAU1@P6A_NABU1@2@ZPAH@Z ; std::_Pop_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z$0
__ehfuncinfo$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
_TEXT	SEGMENT
__Val$ = -68						; size = 56
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z PROC ; std::_Pop_heap_0<CustomBoxGroup *,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2601 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2602 : 	_Ty _Val = _Move(*(_Last - 1));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	83 e8 38	 sub	 eax, 56			; 00000038H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8d 4d bc	 lea	 ecx, DWORD PTR __Val$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0CustomBoxGroup@@QAE@ABU0@@Z
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2603 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2604 : 		_Move(_Val), _Pred, _Dist_type(_First));

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ??$_Dist_type@PAUCustomBoxGroup@@@std@@YAPAHPAUCustomBoxGroup@@@Z ; std::_Dist_type<CustomBoxGroup *>
  00050	83 c4 04	 add	 esp, 4
  00053	50		 push	 eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00057	51		 push	 ecx
  00058	8d 55 bc	 lea	 edx, DWORD PTR __Val$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00061	83 c4 04	 add	 esp, 4
  00064	50		 push	 eax
  00065	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00068	83 e8 38	 sub	 eax, 56			; 00000038H
  0006b	50		 push	 eax
  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0006f	83 e9 38	 sub	 ecx, 56			; 00000038H
  00072	51		 push	 ecx
  00073	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ??$_Pop_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00$$QAU1@P6A_NABU1@2@ZPAH@Z ; std::_Pop_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  0007c	83 c4 18	 add	 esp, 24			; 00000018H

; 2605 : 	}

  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8d 4d bc	 lea	 ecx, DWORD PTR __Val$[ebp]
  00089	e8 00 00 00 00	 call	 ??1CustomBoxGroup@@QAE@XZ
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR __Val$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CustomBoxGroup@@QAE@XZ
__ehhandler$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pop_heap_0@PAUCustomBoxGroup@@U1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@0P6A_NABU1@1@Z0@Z ENDP ; std::_Pop_heap_0<CustomBoxGroup *,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>, COMDAT

; 2617 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Move_backw:

; 2618 : 	while (_First != _Last)

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000f	74 29		 je	 SHORT $LN1@Move_backw

; 2619 : 		*--_Dest = _STD move(*--_Last);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	83 e8 38	 sub	 eax, 56			; 00000038H
  00017	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001d	83 e9 38	 sub	 ecx, 56			; 00000038H
  00020	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::move<CustomBoxGroup &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00033	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z
  00038	eb cf		 jmp	 SHORT $LN2@Move_backw
$LN1@Move_backw:

; 2620 : 	return (_Dest);

  0003a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2621 : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Move_backward@PAUCustomBoxGroup@@PAU1@@std@@YAPAUCustomBoxGroup@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<CustomBoxGroup *,CustomBoxGroup *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@UCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z PROC ; std::forward<CustomBoxGroup>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ENDP ; std::forward<CustomBoxGroup>
_TEXT	ENDS
PUBLIC	??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z ; std::allocator<std::pair<int,int> >::construct<std::pair<int,int> &>
PUBLIC	??$forward@AAU?$pair@HH@std@@@std@@YAAAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@AAU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@AAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAU?$pair@HH@std@@@std@@YAAAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z ; std::allocator<std::pair<int,int> >::construct<std::pair<int,int> &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@AAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@AAPAU?$pair@HH@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@AAPAU?$pair@HH@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 488  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@AAPAU?$pair@HH@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@ABU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@ABU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> const &>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEABU?$pair@HH@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator++
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv83 = -85						; size = 1
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >, COMDAT

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 48	 sub	 esp, 72			; 00000048H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 373  : 
; 374  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 11		 jmp	 SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:

; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00047	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator++
$LN6@Uninit_cop@2:
  0004c	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00053	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator!=
  00058	88 45 ab	 mov	 BYTE PTR tv83[ebp], al
  0005b	0f b6 4d ab	 movzx	 ecx, BYTE PTR tv83[ebp]
  0005f	85 c9		 test	 ecx, ecx
  00061	74 21		 je	 SHORT $LN4@Uninit_cop@2

; 376  : 		_Cons_val(_Al, _Dest, *_First);

  00063	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEABU?$pair@HH@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator*
  0006b	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  0006e	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  00071	50		 push	 eax
  00072	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@ABU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@ABU20@@Z ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> const &>
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	eb b7		 jmp	 SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
  00084	eb 3b		 jmp	 SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 377  : 	_CATCH_ALL

  00086	eb 09		 jmp	 SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:

; 378  : 	for (; _Next != _Dest; ++_Next)

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0008b	83 c0 08	 add	 eax, 8
  0008e	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
  00091	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00094	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  00097	74 12		 je	 SHORT $LN1@Uninit_cop@2

; 379  : 		_Dest_val(_Al, _Next);

  00099	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int,int> >,std::pair<int,int> >
  000a6	83 c4 08	 add	 esp, 8
  000a9	eb dd		 jmp	 SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 380  : 	_RERAISE;

  000ab	6a 00		 push	 0
  000ad	6a 00		 push	 0
  000af	e8 00 00 00 00	 call	 __CxxThrowException@8

; 381  : 	_CATCH_END

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000bb	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000c0	c3		 ret	 0
$LN10@Uninit_cop@2:
  000c1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 382  : 	return (_Dest);

  000c8	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 383  : 	}

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@PAU?$pair@HH@2@V?$allocator@U?$pair@HH@std@@@2@@std@@YAPAU?$pair@HH@0@V?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@0@0PAU10@AAV?$allocator@U?$pair@HH@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >,std::pair<int,int> *,std::allocator<std::pair<int,int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEABU?$pair@HH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEABU?$pair@HH@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@3:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@3

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBEABU?$pair@HH@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Pop_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00$$QAU1@P6A_NABU1@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
___formal$ = 28						; size = 4
??$_Pop_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00$$QAU1@P6A_NABU1@2@ZPAH@Z PROC ; std::_Pop_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>, COMDAT

; 2591 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2592 : 	*_Dest = _Move(*_First);

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00019	e8 00 00 00 00	 call	 ??4CustomBoxGroup@@QAEAAU0@ABU0@@Z

; 2593 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2594 : 		_Move(_Val), _Pred);

  0001e	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Move@AAUCustomBoxGroup@@@std@@YA$$QAUCustomBoxGroup@@AAU1@@Z ; std::_Move<CustomBoxGroup &>
  0002b	83 c4 04	 add	 esp, 4
  0002e	50		 push	 eax
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00032	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00035	99		 cdq
  00036	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0003b	f7 f9		 idiv	 ecx
  0003d	50		 push	 eax
  0003e	6a 00		 push	 0
  00040	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@HH$$QAU1@P6A_NABU1@2@Z@Z ; std::_Adjust_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
  00049	83 c4 14	 add	 esp, 20			; 00000014H

; 2595 : 	}

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$_Pop_heap@PAUCustomBoxGroup@@HU1@P6A_NABU1@0@Z@std@@YAXPAUCustomBoxGroup@@00$$QAU1@P6A_NABU1@2@ZPAH@Z ENDP ; std::_Pop_heap<CustomBoxGroup *,int,CustomBoxGroup,bool (__cdecl*)(CustomBoxGroup const &,CustomBoxGroup const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAU?$pair@HH@std@@@std@@YAAAU?$pair@HH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@HH@std@@@std@@YAAAU?$pair@HH@0@AAU10@@Z PROC ; std::forward<std::pair<int,int> &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAU?$pair@HH@std@@@std@@YAAAU?$pair@HH@0@AAU10@@Z ENDP ; std::forward<std::pair<int,int> &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z$0
__ehfuncinfo$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T231498 = -88						; size = 4
$T231499 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z PROC ; std::allocator<std::pair<int,int> >::construct<std::pair<int,int> &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231499[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231499[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAU?$pair@HH@std@@@std@@YAAAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> &>
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T231499[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HH@?$pair@HH@std@@QAE@AAU01@@Z ; std::pair<int,int>::pair<int,int><int,int>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@4:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T231498[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231499[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAU?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@AAU21@@Z ENDP ; std::allocator<std::pair<int,int> >::construct<std::pair<int,int> &>
PUBLIC	?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@ABU32@@Z ; std::allocator<std::pair<int,int> >::construct
PUBLIC	??$forward@ABU?$pair@HH@std@@@std@@YAABU?$pair@HH@0@ABU10@@Z ; std::forward<std::pair<int,int> const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@ABU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@ABU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@ABU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@ABU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABU?$pair@HH@std@@@std@@YAABU?$pair@HH@0@ABU10@@Z ; std::forward<std::pair<int,int> const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@ABU32@@Z ; std::allocator<std::pair<int,int> >::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@HH@std@@@std@@U?$pair@HH@2@ABU32@@std@@YAXAAV?$allocator@U?$pair@HH@std@@@0@PAU?$pair@HH@0@ABU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int,int> >,std::pair<int,int>,std::pair<int,int> const &>
_TEXT	ENDS
PUBLIC	??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z ; std::_Construct<std::pair<int,int>,std::pair<int,int> const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@ABU32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@ABU32@@Z PROC ; std::allocator<std::pair<int,int> >::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z ; std::_Construct<std::pair<int,int>,std::pair<int,int> const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@ABU32@@Z ENDP ; std::allocator<std::pair<int,int> >::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABU?$pair@HH@std@@@std@@YAABU?$pair@HH@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$pair@HH@std@@@std@@YAABU?$pair@HH@0@ABU10@@Z PROC ; std::forward<std::pair<int,int> const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABU?$pair@HH@std@@@std@@YAABU?$pair@HH@0@ABU10@@Z ENDP ; std::forward<std::pair<int,int> const &>
_TEXT	ENDS
PUBLIC	??0?$pair@HH@std@@QAE@ABU01@@Z			; std::pair<int,int>::pair<int,int>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z$0
__ehfuncinfo$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T231517 = -88						; size = 4
$T231518 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z PROC ; std::_Construct<std::pair<int,int>,std::pair<int,int> const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T231518[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T231518[ebp], 0
  0004a	74 1a		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABU?$pair@HH@std@@@std@@YAABU?$pair@HH@0@ABU10@@Z ; std::forward<std::pair<int,int> const &>
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	8b 4d ac	 mov	 ecx, DWORD PTR $T231518[ebp]
  0005c	e8 00 00 00 00	 call	 ??0?$pair@HH@std@@QAE@ABU01@@Z
  00061	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00064	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00066	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Construct:
  0006d	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  00070	89 55 a8	 mov	 DWORD PTR $T231517[ebp], edx
  00073	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231518[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@U?$pair@HH@std@@ABU12@@std@@YAXPAU?$pair@HH@0@ABU10@@Z ENDP ; std::_Construct<std::pair<int,int>,std::pair<int,int> const &>
PUBLIC	??0?$_Pair_base@HH@std@@QAE@ABU01@@Z		; std::_Pair_base<int,int>::_Pair_base<int,int>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$pair@HH@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$pair@HH@std@@QAE@ABU01@@Z PROC			; std::pair<int,int>::pair<int,int>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$_Pair_base@HH@std@@QAE@ABU01@@Z ; std::_Pair_base<int,int>::_Pair_base<int,int>
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0?$pair@HH@std@@QAE@ABU01@@Z ENDP			; std::pair<int,int>::pair<int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@HH@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Pair_base@HH@std@@QAE@ABU01@@Z PROC		; std::_Pair_base<int,int>::_Pair_base<int,int>, COMDAT
; _this$ = ecx

; 131  : 		{	// construct by copying _Pair_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 10		 mov	 DWORD PTR [eax], edx
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 132  : 		}

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0?$_Pair_base@HH@std@@QAE@ABU01@@Z ENDP		; std::_Pair_base<int,int>::_Pair_base<int,int>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@3
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@3:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
