; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MonsterHerd.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >
PUBLIC	??_7MonsterHerd@@6B@				; MonsterHerd::`vftable'
PUBLIC	??0MonsterHerd@@QAE@XZ				; MonsterHerd::MonsterHerd
PUBLIC	??_R4MonsterHerd@@6B@				; MonsterHerd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMonsterHerd@@@8				; MonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3MonsterHerd@@8				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MonsterHerd@@8				; MonsterHerd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MonsterHerd@@8			; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z		; MonsterHerd::SetTotalInfo
PUBLIC	?AddMonster@MonsterHerd@@UAEHHHH@Z		; MonsterHerd::AddMonster
PUBLIC	?SetRadius@MonsterHerd@@UAEXH@Z			; MonsterHerd::SetRadius
PUBLIC	?SetPosition@MonsterHerd@@UAEXEE@Z		; MonsterHerd::SetPosition
PUBLIC	?Start@MonsterHerd@@UAEHXZ			; MonsterHerd::Start
PUBLIC	?Stop@MonsterHerd@@UAEXXZ			; MonsterHerd::Stop
PUBLIC	?CheckInRadius@MonsterHerd@@UAEHH@Z		; MonsterHerd::CheckInRadius
PUBLIC	?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z	; MonsterHerd::GetCurrentLocation
PUBLIC	?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z	; MonsterHerd::GetRandomLocation
PUBLIC	?CheckLocation@MonsterHerd@@UAEHAAE0@Z		; MonsterHerd::CheckLocation
PUBLIC	?MoveHerd@MonsterHerd@@UAEHEE@Z			; MonsterHerd::MoveHerd
PUBLIC	?MonsterHerdItemDrop@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ; MonsterHerd::MonsterHerdItemDrop
PUBLIC	?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z ; MonsterHerd::GetMonsterData
PUBLIC	?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z ; MonsterHerd::BeenAttacked
PUBLIC	?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z ; MonsterHerd::OrderAttack
PUBLIC	?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z ; MonsterHerd::MonsterBaseAct
PUBLIC	?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z ; MonsterHerd::MonsterMoveAction
PUBLIC	?MonsterAttackAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z ; MonsterHerd::MonsterAttackAction
PUBLIC	?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z ; MonsterHerd::MonsterDieAction
PUBLIC	?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ; MonsterHerd::MonsterRegenAction
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EMonsterHerd@@UAEPAXI@Z:PROC			; MonsterHerd::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@MonsterHerd@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\monsterherd.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@MonsterHerd@@8 DD FLAT:??_R0?AVMonsterHerd@@@8 ; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R2MonsterHerd@@8
rdata$r	SEGMENT
??_R2MonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@MonsterHerd@@8 ; MonsterHerd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MonsterHerd@@8
rdata$r	SEGMENT
??_R3MonsterHerd@@8 DD 00H				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMonsterHerd@@@8
_DATA	SEGMENT
??_R0?AVMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; MonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMonsterHerd@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MonsterHerd@@6B@
rdata$r	SEGMENT
??_R4MonsterHerd@@6B@ DD 00H				; MonsterHerd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMonsterHerd@@@8
	DD	FLAT:??_R3MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_7MonsterHerd@@6B@
CONST	SEGMENT
??_7MonsterHerd@@6B@ DD FLAT:??_R4MonsterHerd@@6B@	; MonsterHerd::`vftable'
	DD	FLAT:??_EMonsterHerd@@UAEPAXI@Z
	DD	FLAT:?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z
	DD	FLAT:?AddMonster@MonsterHerd@@UAEHHHH@Z
	DD	FLAT:?SetRadius@MonsterHerd@@UAEXH@Z
	DD	FLAT:?SetPosition@MonsterHerd@@UAEXEE@Z
	DD	FLAT:?Start@MonsterHerd@@UAEHXZ
	DD	FLAT:?Stop@MonsterHerd@@UAEXXZ
	DD	FLAT:?CheckInRadius@MonsterHerd@@UAEHH@Z
	DD	FLAT:?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?CheckLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?MoveHerd@MonsterHerd@@UAEHEE@Z
	DD	FLAT:?MonsterHerdItemDrop@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z
	DD	FLAT:?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z
	DD	FLAT:?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z
	DD	FLAT:?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterAttackAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z
	DD	FLAT:?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MonsterHerd@@QAE@XZ PROC				; MonsterHerd::MonsterHerd
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MonsterHerd@@6B@
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 20	 add	 ecx, 32			; 00000020H
  0001b	e8 00 00 00 00	 call	 ??0?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >

; 11   : 	this->m_iMapNumber =-1;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 12   : 	this->m_iCUR_X =0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 13   : 	this->m_iCUR_Y =0;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 14   : 	this->m_iRADIUS =0;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 15   : 	this->m_bHerdActive =0;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 16   : 	this->m_bHasInfo=0;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 17   : 	
; 18   : 	InitializeCriticalSection(&this->m_critMonsterHerd);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 c0 30	 add	 eax, 48			; 00000030H
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 19   : }

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??0MonsterHerd@@QAE@XZ ENDP				; MonsterHerd::MonsterHerd
_TEXT	ENDS
PUBLIC	??1MonsterHerd@@UAE@XZ				; MonsterHerd::~MonsterHerd
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GMonsterHerd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMonsterHerd@@UAEPAXI@Z PROC				; MonsterHerd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1MonsterHerd@@UAE@XZ	; MonsterHerd::~MonsterHerd
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GMonsterHerd@@UAEPAXI@Z ENDP				; MonsterHerd::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::~map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MonsterHerd@@UAE@XZ PROC				; MonsterHerd::~MonsterHerd
; _this$ = ecx

; 22   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 44	 sub	 esp, 68			; 00000044H
  00086	53		 push	 ebx
  00087	56		 push	 esi
  00088	57		 push	 edi
  00089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MonsterHerd@@6B@

; 23   : 	DeleteCriticalSection(&this->m_critMonsterHerd);

  00095	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00098	83 c0 30	 add	 eax, 48			; 00000030H
  0009b	50		 push	 eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 24   : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 20	 add	 ecx, 32			; 00000020H
  000a8	e8 00 00 00 00	 call	 ??1?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
??1MonsterHerd@@UAE@XZ ENDP				; MonsterHerd::~MonsterHerd
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::~map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::~map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >
_TEXT	ENDS
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv129 = -76						; size = 4
tv77 = -76						; size = 4
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_btMapAttr$ = -5					; size = 1
_this$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
_iRadius$ = 12						; size = 4
_iStartX$ = 16						; size = 4
_iStartY$ = 20						; size = 4
?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z PROC		; MonsterHerd::SetTotalInfo
; _this$ = ecx

; 27   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	57		 push	 edi
  000c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 	if ( MAX_MAP_RANGE(iMapNumber) == FALSE ) 

  000cc	83 7d 08 00	 cmp	 DWORD PTR _iMapNumber$[ebp], 0
  000d0	7d 09		 jge	 SHORT $LN9@SetTotalIn
  000d2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  000d9	eb 0c		 jmp	 SHORT $LN10@SetTotalIn
$LN9@SetTotalIn:
  000db	33 c0		 xor	 eax, eax
  000dd	83 7d 08 59	 cmp	 DWORD PTR _iMapNumber$[ebp], 89 ; 00000059H
  000e1	0f 9e c0	 setle	 al
  000e4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@SetTotalIn:
  000e7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  000eb	75 07		 jne	 SHORT $LN6@SetTotalIn

; 29   : 	{
; 30   : 		return FALSE;

  000ed	33 c0		 xor	 eax, eax
  000ef	e9 e5 00 00 00	 jmp	 $LN7@SetTotalIn
$LN6@SetTotalIn:

; 31   : 	}
; 32   : 
; 33   : 	if ( ((iStartX < 0)? FALSE : (iStartX > 254 )? FALSE : TRUE ) == FALSE || ( ( iStartY < 0)?FALSE : (iStartY > 254)? FALSE : TRUE) == FALSE)

  000f4	83 7d 10 00	 cmp	 DWORD PTR _iStartX$[ebp], 0
  000f8	7d 09		 jge	 SHORT $LN11@SetTotalIn
  000fa	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  00101	eb 0f		 jmp	 SHORT $LN12@SetTotalIn
$LN11@SetTotalIn:
  00103	33 c0		 xor	 eax, eax
  00105	81 7d 10 fe 00
	00 00		 cmp	 DWORD PTR _iStartX$[ebp], 254 ; 000000feH
  0010c	0f 9e c0	 setle	 al
  0010f	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN12@SetTotalIn:
  00112	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  00116	74 24		 je	 SHORT $LN4@SetTotalIn
  00118	83 7d 14 00	 cmp	 DWORD PTR _iStartY$[ebp], 0
  0011c	7d 09		 jge	 SHORT $LN13@SetTotalIn
  0011e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00125	eb 0f		 jmp	 SHORT $LN14@SetTotalIn
$LN13@SetTotalIn:
  00127	33 c0		 xor	 eax, eax
  00129	81 7d 14 fe 00
	00 00		 cmp	 DWORD PTR _iStartY$[ebp], 254 ; 000000feH
  00130	0f 9e c0	 setle	 al
  00133	89 45 b4	 mov	 DWORD PTR tv77[ebp], eax
$LN14@SetTotalIn:
  00136	83 7d b4 00	 cmp	 DWORD PTR tv77[ebp], 0
  0013a	75 07		 jne	 SHORT $LN5@SetTotalIn
$LN4@SetTotalIn:

; 34   : 	{
; 35   : 		return FALSE;

  0013c	33 c0		 xor	 eax, eax
  0013e	e9 96 00 00 00	 jmp	 $LN7@SetTotalIn
$LN5@SetTotalIn:

; 36   : 	}
; 37   : 
; 38   : 	BYTE btMapAttr = MapC[iMapNumber].GetAttr(iStartX, iStartY);

  00143	8b 45 14	 mov	 eax, DWORD PTR _iStartY$[ebp]
  00146	50		 push	 eax
  00147	8b 4d 10	 mov	 ecx, DWORD PTR _iStartX$[ebp]
  0014a	51		 push	 ecx
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  0014e	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  00154	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0015a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0015f	88 45 fb	 mov	 BYTE PTR _btMapAttr$[ebp], al

; 39   : 
; 40   : 	if ( ( btMapAttr & 1) == 1  || (btMapAttr & 4) == 4 || (btMapAttr&8)==8)

  00162	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  00166	83 e0 01	 and	 eax, 1
  00169	75 12		 jne	 SHORT $LN2@SetTotalIn
  0016b	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  0016f	83 e0 04	 and	 eax, 4
  00172	75 09		 jne	 SHORT $LN2@SetTotalIn
  00174	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  00178	83 e0 08	 and	 eax, 8
  0017b	74 04		 je	 SHORT $LN3@SetTotalIn
$LN2@SetTotalIn:

; 41   : 	{
; 42   : 		return FALSE;

  0017d	33 c0		 xor	 eax, eax
  0017f	eb 58		 jmp	 SHORT $LN7@SetTotalIn
$LN3@SetTotalIn:

; 43   : 	}
; 44   : 
; 45   : 	if ( ( ( iRadius < 0 )? FALSE : ( iRadius > 15 )? FALSE : TRUE ) == FALSE )

  00181	83 7d 0c 00	 cmp	 DWORD PTR _iRadius$[ebp], 0
  00185	7d 09		 jge	 SHORT $LN15@SetTotalIn
  00187	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
  0018e	eb 0c		 jmp	 SHORT $LN16@SetTotalIn
$LN15@SetTotalIn:
  00190	33 c0		 xor	 eax, eax
  00192	83 7d 0c 0f	 cmp	 DWORD PTR _iRadius$[ebp], 15 ; 0000000fH
  00196	0f 9e c0	 setle	 al
  00199	89 45 b4	 mov	 DWORD PTR tv129[ebp], eax
$LN16@SetTotalIn:
  0019c	83 7d b4 00	 cmp	 DWORD PTR tv129[ebp], 0
  001a0	75 04		 jne	 SHORT $LN1@SetTotalIn

; 46   : 	{
; 47   : 		return FALSE;

  001a2	33 c0		 xor	 eax, eax
  001a4	eb 33		 jmp	 SHORT $LN7@SetTotalIn
$LN1@SetTotalIn:

; 48   : 	}
; 49   : 
; 50   : 	this->m_iMapNumber = iMapNumber;

  001a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  001ac	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 51   : 	this->m_iCUR_X = iStartX;

  001af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	8b 4d 10	 mov	 ecx, DWORD PTR _iStartX$[ebp]
  001b5	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 52   : 	this->m_iCUR_Y = iStartY;

  001b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	8b 4d 14	 mov	 ecx, DWORD PTR _iStartY$[ebp]
  001be	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 53   : 	this->m_iRADIUS = iRadius;

  001c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c4	8b 4d 0c	 mov	 ecx, DWORD PTR _iRadius$[ebp]
  001c7	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 54   : 	this->m_bHasInfo = 1;

  001ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001cd	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 55   : 	return TRUE;

  001d4	b8 01 00 00 00	 mov	 eax, 1
$LN7@SetTotalIn:

; 56   : }

  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c2 10 00	 ret	 16			; 00000010H
?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z ENDP		; MonsterHerd::SetTotalInfo
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::insert<std::pair<int,_MONSTER_HERD_DATA> >
PUBLIC	??$?0AAHAAU_MONSTER_HERD_DATA@@@?$pair@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z ; std::pair<int,_MONSTER_HERD_DATA>::pair<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>
PUBLIC	??0_MONSTER_HERD_DATA@@QAE@XZ			; _MONSTER_HERD_DATA::_MONSTER_HERD_DATA
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	_rand:PROC
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T230219 = -124						; size = 20
$T230220 = -104						; size = 8
_pMonsterData$228374 = -32				; size = 16
_iAttr$228372 = -16					; size = 4
_cY$ = -11						; size = 1
_cX$ = -10						; size = 1
_btMapNumber$ = -9					; size = 1
_iIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_iMonsterType$ = 8					; size = 4
_bRegen$ = 12						; size = 4
_bAttackFirst$ = 16					; size = 4
?AddMonster@MonsterHerd@@UAEHHHH@Z PROC			; MonsterHerd::AddMonster
; _this$ = ecx

; 59   : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	83 ec 7c	 sub	 esp, 124		; 0000007cH
  001f6	53		 push	 ebx
  001f7	56		 push	 esi
  001f8	57		 push	 edi
  001f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 	if ( this->m_bHasInfo == 0 )

  001fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ff	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00203	75 07		 jne	 SHORT $LN5@AddMonster

; 61   : 	{
; 62   : 		return false;

  00205	33 c0		 xor	 eax, eax
  00207	e9 1e 03 00 00	 jmp	 $LN6@AddMonster
$LN5@AddMonster:

; 63   : 	}
; 64   : 
; 65   : 	int iIndex;
; 66   : 	BYTE btMapNumber = this->m_iMapNumber;

  0020c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0020f	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  00212	88 4d f7	 mov	 BYTE PTR _btMapNumber$[ebp], cl

; 67   : 	BYTE cX=0;

  00215	c6 45 f6 00	 mov	 BYTE PTR _cX$[ebp], 0

; 68   : 	BYTE cY=0;

  00219	c6 45 f5 00	 mov	 BYTE PTR _cY$[ebp], 0

; 69   : 
; 70   : 	if (this->GetRandomLocation(cX, cY) == FALSE )

  0021d	8d 45 f5	 lea	 eax, DWORD PTR _cY$[ebp]
  00220	50		 push	 eax
  00221	8d 4d f6	 lea	 ecx, DWORD PTR _cX$[ebp]
  00224	51		 push	 ecx
  00225	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00228	8b 02		 mov	 eax, DWORD PTR [edx]
  0022a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022d	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00230	ff d2		 call	 edx
  00232	85 c0		 test	 eax, eax
  00234	75 07		 jne	 SHORT $LN4@AddMonster

; 71   : 	{
; 72   : 		return false;

  00236	33 c0		 xor	 eax, eax
  00238	e9 ed 02 00 00	 jmp	 $LN6@AddMonster
$LN4@AddMonster:

; 73   : 	}
; 74   : 
; 75   : 	iIndex = gObjAddMonster(this->m_iMapNumber);

  0023d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00240	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00243	51		 push	 ecx
  00244	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00249	83 c4 04	 add	 esp, 4
  0024c	0f bf d0	 movsx	 edx, ax
  0024f	89 55 f8	 mov	 DWORD PTR _iIndex$[ebp], edx

; 76   : 
; 77   : 	if ( iIndex >= 0 )

  00252	83 7d f8 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00256	0f 8c c5 02 00
	00		 jl	 $LN3@AddMonster

; 78   : 	{
; 79   : 		gObj[iIndex].m_PosNum = -1;

  0025c	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0025f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00265	83 c9 ff	 or	 ecx, -1
  00268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026e	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 80   : 		gObj[iIndex].X = cX;

  00276	66 0f b6 45 f6	 movzx	 ax, BYTE PTR _cX$[ebp]
  0027b	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0027e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00284	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028a	66 89 84 0a 44
	01 00 00	 mov	 WORD PTR [edx+ecx+324], ax

; 81   : 		gObj[iIndex].Y = cY;

  00292	66 0f b6 45 f5	 movzx	 ax, BYTE PTR _cY$[ebp]
  00297	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0029a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  002a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a6	66 89 84 0a 46
	01 00 00	 mov	 WORD PTR [edx+ecx+326], ax

; 82   : 		gObj[iIndex].MapNumber = this->m_iMapNumber;

  002ae	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002b1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002c0	8a 52 08	 mov	 dl, BYTE PTR [edx+8]
  002c3	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 83   : 		gObj[iIndex].TX = gObj[iIndex].X;

  002ca	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002cd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002d3	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  002d6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  002dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e8	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  002f0	66 89 84 0a 7c
	01 00 00	 mov	 WORD PTR [edx+ecx+380], ax

; 84   : 		gObj[iIndex].TY = gObj[iIndex].Y;

  002f8	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002fb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00301	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00304	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0030a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00310	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00316	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  0031e	66 89 84 0a 7e
	01 00 00	 mov	 WORD PTR [edx+ecx+382], ax

; 85   : 		gObj[iIndex].m_OldX = gObj[iIndex].X;

  00326	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00329	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0032f	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00332	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00338	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00344	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  0034c	66 89 84 0a 78
	01 00 00	 mov	 WORD PTR [edx+ecx+376], ax

; 86   : 		gObj[iIndex].m_OldY = gObj[iIndex].Y;

  00354	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00357	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0035d	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00360	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00366	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00372	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  0037a	66 89 84 0a 7a
	01 00 00	 mov	 WORD PTR [edx+ecx+378], ax

; 87   : 		gObj[iIndex].StartX = gObj[iIndex].X;

  00382	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00385	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0038b	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0038e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00394	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0039a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a0	8a 84 06 44 01
	00 00		 mov	 al, BYTE PTR [esi+eax+324]
  003a7	88 84 0a 76 01
	00 00		 mov	 BYTE PTR [edx+ecx+374], al

; 88   : 		gObj[iIndex].StartY = gObj[iIndex].Y;

  003ae	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  003b1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003b7	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  003ba	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  003c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003cc	8a 84 06 46 01
	00 00		 mov	 al, BYTE PTR [esi+eax+326]
  003d3	88 84 0a 77 01
	00 00		 mov	 BYTE PTR [edx+ecx+375], al

; 89   : 
; 90   : 		LPMONSTER_ATTRIBUTE iAttr = gMAttr.GetAttr(iMonsterType);

  003da	8b 45 08	 mov	 eax, DWORD PTR _iMonsterType$[ebp]
  003dd	50		 push	 eax
  003de	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  003e3	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  003e8	89 45 f0	 mov	 DWORD PTR _iAttr$228372[ebp], eax

; 91   : 
; 92   : 		if ( iAttr == NULL )

  003eb	83 7d f0 00	 cmp	 DWORD PTR _iAttr$228372[ebp], 0
  003ef	75 13		 jne	 SHORT $LN2@AddMonster

; 93   : 		{
; 94   : 			gObjDel(iIndex);

  003f1	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  003fa	83 c4 04	 add	 esp, 4

; 95   : 			return false;

  003fd	33 c0		 xor	 eax, eax
  003ff	e9 26 01 00 00	 jmp	 $LN6@AddMonster
$LN2@AddMonster:

; 96   : 		}
; 97   : 
; 98   : 		gObj[iIndex].Level = iAttr->m_Level;

  00404	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00407	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0040d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00413	8b 55 f0	 mov	 edx, DWORD PTR _iAttr$228372[ebp]
  00416	66 8b 52 1c	 mov	 dx, WORD PTR [edx+28]
  0041a	66 89 94 01 be
	00 00 00	 mov	 WORD PTR [ecx+eax+190], dx

; 99   : 		gObjSetMonster(iIndex, iMonsterType);

  00422	8b 45 08	 mov	 eax, DWORD PTR _iMonsterType$[ebp]
  00425	50		 push	 eax
  00426	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00429	51		 push	 ecx
  0042a	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  0042f	83 c4 08	 add	 esp, 8

; 100  : 		gObj[iIndex].MaxRegenTime = 1000;

  00432	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00435	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0043b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00441	c7 84 01 ac 03
	00 00 e8 03 00
	00		 mov	 DWORD PTR [ecx+eax+940], 1000 ; 000003e8H

; 101  : 		gObj[iIndex].Dir = rand() % 8;

  0044c	e8 00 00 00 00	 call	 _rand
  00451	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00456	79 05		 jns	 SHORT $LN8@AddMonster
  00458	48		 dec	 eax
  00459	83 c8 f8	 or	 eax, -8			; fffffff8H
  0045c	40		 inc	 eax
$LN8@AddMonster:
  0045d	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00460	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00466	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046c	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 102  : 		gObj[iIndex].m_bIsInMonsterHerd = 1;

  00473	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00476	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0047c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00482	c7 84 01 e8 10
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+4328], 1

; 103  : 		gObj[iIndex].m_bIsMonsterAttackFirst = bAttackFirst;

  0048d	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00490	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0049c	8b 55 10	 mov	 edx, DWORD PTR _bAttackFirst$[ebp]
  0049f	89 94 01 ec 10
	00 00		 mov	 DWORD PTR [ecx+eax+4332], edx

; 104  : 		gObj[iIndex].m_lpMonsterHerd = this;

  004a6	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004a9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004b8	89 94 01 f0 10
	00 00		 mov	 DWORD PTR [ecx+eax+4336], edx

; 105  : 
; 106  : 		EnterCriticalSection(&this->m_critMonsterHerd);

  004bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004c2	83 c0 30	 add	 eax, 48			; 00000030H
  004c5	50		 push	 eax
  004c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 107  : 
; 108  : 		_MONSTER_HERD_DATA pMonsterData;

  004cc	8d 4d e0	 lea	 ecx, DWORD PTR _pMonsterData$228374[ebp]
  004cf	e8 00 00 00 00	 call	 ??0_MONSTER_HERD_DATA@@QAE@XZ ; _MONSTER_HERD_DATA::_MONSTER_HERD_DATA

; 109  : 		pMonsterData.m_iIndex = iIndex;

  004d4	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004d7	89 45 e0	 mov	 DWORD PTR _pMonsterData$228374[ebp], eax

; 110  : 		pMonsterData.m_iType = iMonsterType;

  004da	8b 45 08	 mov	 eax, DWORD PTR _iMonsterType$[ebp]
  004dd	89 45 e4	 mov	 DWORD PTR _pMonsterData$228374[ebp+4], eax

; 111  : 		pMonsterData.m_iX = cX;

  004e0	8a 45 f6	 mov	 al, BYTE PTR _cX$[ebp]
  004e3	88 45 e8	 mov	 BYTE PTR _pMonsterData$228374[ebp+8], al

; 112  : 		pMonsterData.m_iX = cY;

  004e6	8a 45 f5	 mov	 al, BYTE PTR _cY$[ebp]
  004e9	88 45 e8	 mov	 BYTE PTR _pMonsterData$228374[ebp+8], al

; 113  : 		pMonsterData.m_bRegen = bRegen;

  004ec	8b 45 0c	 mov	 eax, DWORD PTR _bRegen$[ebp]
  004ef	89 45 ec	 mov	 DWORD PTR _pMonsterData$228374[ebp+12], eax

; 114  : 
; 115  : 		this->m_mapMonsterHerd.insert( std::pair<int, _MONSTER_HERD_DATA>(iIndex, pMonsterData) );

  004f2	8d 45 e0	 lea	 eax, DWORD PTR _pMonsterData$228374[ebp]
  004f5	50		 push	 eax
  004f6	8d 4d f8	 lea	 ecx, DWORD PTR _iIndex$[ebp]
  004f9	51		 push	 ecx
  004fa	8d 4d 84	 lea	 ecx, DWORD PTR $T230219[ebp]
  004fd	e8 00 00 00 00	 call	 ??$?0AAHAAU_MONSTER_HERD_DATA@@@?$pair@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z ; std::pair<int,_MONSTER_HERD_DATA>::pair<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>
  00502	50		 push	 eax
  00503	8d 55 98	 lea	 edx, DWORD PTR $T230220[ebp]
  00506	52		 push	 edx
  00507	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050a	83 c1 20	 add	 ecx, 32			; 00000020H
  0050d	e8 00 00 00 00	 call	 ??$insert@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::insert<std::pair<int,_MONSTER_HERD_DATA> >

; 116  : 
; 117  : 		LeaveCriticalSection(&this->m_critMonsterHerd);

  00512	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00515	83 c0 30	 add	 eax, 48			; 00000030H
  00518	50		 push	 eax
  00519	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 118  : 	}
; 119  : 	else

  0051f	eb 04		 jmp	 SHORT $LN1@AddMonster
$LN3@AddMonster:

; 120  : 	{
; 121  : 		return FALSE;

  00521	33 c0		 xor	 eax, eax
  00523	eb 05		 jmp	 SHORT $LN6@AddMonster
$LN1@AddMonster:

; 122  : 	}
; 123  : 
; 124  : 	return TRUE;

  00525	b8 01 00 00 00	 mov	 eax, 1
$LN6@AddMonster:

; 125  : 
; 126  : }

  0052a	5f		 pop	 edi
  0052b	5e		 pop	 esi
  0052c	5b		 pop	 ebx
  0052d	8b e5		 mov	 esp, ebp
  0052f	5d		 pop	 ebp
  00530	c2 0c 00	 ret	 12			; 0000000cH
?AddMonster@MonsterHerd@@UAEHHHH@Z ENDP			; MonsterHerd::AddMonster
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monsterherd.h
_TEXT	ENDS
;	COMDAT ??0_MONSTER_HERD_DATA@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_MONSTER_HERD_DATA@@QAE@XZ PROC			; _MONSTER_HERD_DATA::_MONSTER_HERD_DATA, COMDAT
; _this$ = ecx

; 18   : 	_MONSTER_HERD_DATA()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{
; 20   : 		this->m_iIndex = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 21   : 		this->m_iType = -1;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 22   : 		this->m_iX = -1;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c6 40 08 ff	 mov	 BYTE PTR [eax+8], 255	; 000000ffH

; 23   : 		this->m_iY = -1;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c6 40 09 ff	 mov	 BYTE PTR [eax+9], 255	; 000000ffH

; 24   : 		this->m_bRegen = FALSE;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 25   : 	}

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??0_MONSTER_HERD_DATA@@QAE@XZ ENDP			; _MONSTER_HERD_DATA::_MONSTER_HERD_DATA
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monsterherd.cpp
_TEXT	ENDS
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iRadius$ = 8						; size = 4
?SetRadius@MonsterHerd@@UAEXH@Z PROC			; MonsterHerd::SetRadius
; _this$ = ecx

; 129  : {

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	83 ec 48	 sub	 esp, 72			; 00000048H
  00546	53		 push	 ebx
  00547	56		 push	 esi
  00548	57		 push	 edi
  00549	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	if ( ((iRadius<0)?FALSE:(iRadius>15)?FALSE:TRUE) != FALSE )

  0054c	83 7d 08 00	 cmp	 DWORD PTR _iRadius$[ebp], 0
  00550	7d 09		 jge	 SHORT $LN4@SetRadius
  00552	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00559	eb 0c		 jmp	 SHORT $LN5@SetRadius
$LN4@SetRadius:
  0055b	33 c0		 xor	 eax, eax
  0055d	83 7d 08 0f	 cmp	 DWORD PTR _iRadius$[ebp], 15 ; 0000000fH
  00561	0f 9e c0	 setle	 al
  00564	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@SetRadius:
  00567	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0056b	74 02		 je	 SHORT $LN1@SetRadius

; 131  : 	{
; 132  : 		return;

  0056d	eb 09		 jmp	 SHORT $LN2@SetRadius
$LN1@SetRadius:

; 133  : 	}
; 134  : 
; 135  : 	this->m_iRADIUS = iRadius;

  0056f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00572	8b 4d 08	 mov	 ecx, DWORD PTR _iRadius$[ebp]
  00575	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN2@SetRadius:

; 136  : }

  00578	5f		 pop	 edi
  00579	5e		 pop	 esi
  0057a	5b		 pop	 ebx
  0057b	8b e5		 mov	 esp, ebp
  0057d	5d		 pop	 ebp
  0057e	c2 04 00	 ret	 4
?SetRadius@MonsterHerd@@UAEXH@Z ENDP			; MonsterHerd::SetRadius
; Function compile flags: /Odtp /ZI
_btMapAttr$ = -5					; size = 1
_this$ = -4						; size = 4
_iTX$ = 8						; size = 1
_iTY$ = 12						; size = 1
?SetPosition@MonsterHerd@@UAEXEE@Z PROC			; MonsterHerd::SetPosition
; _this$ = ecx

; 139  : {

  00590	55		 push	 ebp
  00591	8b ec		 mov	 ebp, esp
  00593	83 ec 48	 sub	 esp, 72			; 00000048H
  00596	53		 push	 ebx
  00597	56		 push	 esi
  00598	57		 push	 edi
  00599	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	if ( this->m_bHasInfo == 0 )

  0059c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0059f	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  005a3	75 02		 jne	 SHORT $LN3@SetPositio

; 141  : 	{
; 142  : 		return;

  005a5	eb 55		 jmp	 SHORT $LN4@SetPositio
$LN3@SetPositio:

; 143  : 	}
; 144  : 
; 145  : 	BYTE btMapAttr = MapC[this->m_iMapNumber].GetAttr(iTX, iTY);

  005a7	0f b6 45 0c	 movzx	 eax, BYTE PTR _iTY$[ebp]
  005ab	50		 push	 eax
  005ac	0f b6 4d 08	 movzx	 ecx, BYTE PTR _iTX$[ebp]
  005b0	51		 push	 ecx
  005b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005b4	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  005b7	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  005bd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  005c3	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  005c8	88 45 fb	 mov	 BYTE PTR _btMapAttr$[ebp], al

; 146  : 
; 147  : 	if ( (btMapAttr&1) == 1 || (btMapAttr&4)==4 || (btMapAttr&8) == 8 )

  005cb	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  005cf	83 e0 01	 and	 eax, 1
  005d2	75 12		 jne	 SHORT $LN1@SetPositio
  005d4	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  005d8	83 e0 04	 and	 eax, 4
  005db	75 09		 jne	 SHORT $LN1@SetPositio
  005dd	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  005e1	83 e0 08	 and	 eax, 8
  005e4	74 02		 je	 SHORT $LN2@SetPositio
$LN1@SetPositio:

; 148  : 	{
; 149  : 		return;

  005e6	eb 14		 jmp	 SHORT $LN4@SetPositio
$LN2@SetPositio:

; 150  : 	}
; 151  : 
; 152  : 	this->m_iCUR_X = iTX;

  005e8	0f b6 45 08	 movzx	 eax, BYTE PTR _iTX$[ebp]
  005ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005ef	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 153  : 	this->m_iCUR_Y = iTY;

  005f2	0f b6 45 0c	 movzx	 eax, BYTE PTR _iTY$[ebp]
  005f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f9	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN4@SetPositio:

; 154  : }

  005fc	5f		 pop	 edi
  005fd	5e		 pop	 esi
  005fe	5b		 pop	 ebx
  005ff	8b e5		 mov	 esp, ebp
  00601	5d		 pop	 ebp
  00602	c2 08 00	 ret	 8
?SetPosition@MonsterHerd@@UAEXEE@Z ENDP			; MonsterHerd::SetPosition
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?Start@MonsterHerd@@UAEHXZ PROC				; MonsterHerd::Start
; _this$ = ecx

; 157  : {

  00610	55		 push	 ebp
  00611	8b ec		 mov	 ebp, esp
  00613	83 ec 44	 sub	 esp, 68			; 00000044H
  00616	53		 push	 ebx
  00617	56		 push	 esi
  00618	57		 push	 edi
  00619	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 158  : 	if ( this->m_bHerdActive != 0 )

  0061c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0061f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00623	74 04		 je	 SHORT $LN2@Start

; 159  : 	{
; 160  : 		return FALSE;

  00625	33 c0		 xor	 eax, eax
  00627	eb 1c		 jmp	 SHORT $LN3@Start
$LN2@Start:

; 161  : 	}
; 162  : 
; 163  : 	if ( this->m_bHasInfo == 0 )

  00629	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0062c	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00630	75 04		 jne	 SHORT $LN1@Start

; 164  : 	{
; 165  : 		return FALSE;

  00632	33 c0		 xor	 eax, eax
  00634	eb 0f		 jmp	 SHORT $LN3@Start
$LN1@Start:

; 166  : 	}
; 167  : 
; 168  : 	this->m_bHerdActive = 1;

  00636	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00639	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1

; 169  : 	return TRUE;

  00640	b8 01 00 00 00	 mov	 eax, 1
$LN3@Start:

; 170  : }

  00645	5f		 pop	 edi
  00646	5e		 pop	 esi
  00647	5b		 pop	 ebx
  00648	8b e5		 mov	 esp, ebp
  0064a	5d		 pop	 ebp
  0064b	c3		 ret	 0
?Start@MonsterHerd@@UAEHXZ ENDP				; MonsterHerd::Start
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::empty
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T230230 = -104						; size = 4
$T230231 = -100						; size = 4
$T230232 = -96						; size = 4
$T230233 = -92						; size = 4
$T230234 = -88						; size = 4
$T230235 = -84						; size = 4
$T230236 = -80						; size = 4
_pMH_DATA$229023 = -12					; size = 4
__Iter$229000 = -8					; size = 4
_this$ = -4						; size = 4
?Stop@MonsterHerd@@UAEXXZ PROC				; MonsterHerd::Stop
; _this$ = ecx

; 173  : {

  00650	55		 push	 ebp
  00651	8b ec		 mov	 ebp, esp
  00653	83 ec 68	 sub	 esp, 104		; 00000068H
  00656	53		 push	 ebx
  00657	56		 push	 esi
  00658	57		 push	 edi
  00659	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 	this->m_bHerdActive = 0;

  0065c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0065f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 175  : 	this->m_bHasInfo = 0; //season 4.5 add-on

  00666	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00669	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 176  : 
; 177  : 	if ( this->m_mapMonsterHerd.empty() == false )

  00670	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00673	83 c1 20	 add	 ecx, 32			; 00000020H
  00676	e8 00 00 00 00	 call	 ?empty@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::empty
  0067b	0f b6 c0	 movzx	 eax, al
  0067e	85 c0		 test	 eax, eax
  00680	0f 85 d9 00 00
	00		 jne	 $LN7@Stop

; 178  : 	{
; 179  : 		EnterCriticalSection(&this->m_critMonsterHerd);

  00686	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00689	83 c0 30	 add	 eax, 48			; 00000030H
  0068c	50		 push	 eax
  0068d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 180  : 
; 181  : 		if ( this->m_mapMonsterHerd.empty() != false )

  00693	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00696	83 c1 20	 add	 ecx, 32			; 00000020H
  00699	e8 00 00 00 00	 call	 ?empty@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::empty
  0069e	0f b6 c0	 movzx	 eax, al
  006a1	85 c0		 test	 eax, eax
  006a3	74 12		 je	 SHORT $LN5@Stop

; 182  : 		{
; 183  : 			LeaveCriticalSection(&this->m_critMonsterHerd);

  006a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006a8	83 c0 30	 add	 eax, 48			; 00000030H
  006ab	50		 push	 eax
  006ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 184  : 		}
; 185  : 		else

  006b2	e9 a8 00 00 00	 jmp	 $LN7@Stop
$LN5@Stop:

; 186  : 		{
; 187  : 			for ( std::map<int, _MONSTER_HERD_DATA>::iterator _Iter = this->m_mapMonsterHerd.begin() ; _Iter != this->m_mapMonsterHerd.end() ; _Iter++)

  006b7	8d 45 f8	 lea	 eax, DWORD PTR __Iter$229000[ebp]
  006ba	50		 push	 eax
  006bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006be	83 c1 20	 add	 ecx, 32			; 00000020H
  006c1	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  006c6	eb 0e		 jmp	 SHORT $LN3@Stop
$LN2@Stop:
  006c8	6a 00		 push	 0
  006ca	8d 45 98	 lea	 eax, DWORD PTR $T230230[ebp]
  006cd	50		 push	 eax
  006ce	8d 4d f8	 lea	 ecx, DWORD PTR __Iter$229000[ebp]
  006d1	e8 00 00 00 00	 call	 ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
$LN3@Stop:
  006d6	8d 45 9c	 lea	 eax, DWORD PTR $T230231[ebp]
  006d9	50		 push	 eax
  006da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006dd	83 c1 20	 add	 ecx, 32			; 00000020H
  006e0	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  006e5	50		 push	 eax
  006e6	8d 4d f8	 lea	 ecx, DWORD PTR __Iter$229000[ebp]
  006e9	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
  006ee	0f b6 c8	 movzx	 ecx, al
  006f1	85 c9		 test	 ecx, ecx
  006f3	74 1e		 je	 SHORT $LN1@Stop

; 188  : 			{
; 189  : 				_MONSTER_HERD_DATA & pMH_DATA = _Iter->second;

  006f5	8d 4d f8	 lea	 ecx, DWORD PTR __Iter$229000[ebp]
  006f8	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->
  006fd	83 c0 04	 add	 eax, 4
  00700	89 45 f4	 mov	 DWORD PTR _pMH_DATA$229023[ebp], eax

; 190  : 				gObjDel(pMH_DATA.m_iIndex);

  00703	8b 45 f4	 mov	 eax, DWORD PTR _pMH_DATA$229023[ebp]
  00706	8b 08		 mov	 ecx, DWORD PTR [eax]
  00708	51		 push	 ecx
  00709	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0070e	83 c4 04	 add	 esp, 4

; 191  : 			}

  00711	eb b5		 jmp	 SHORT $LN2@Stop
$LN1@Stop:

; 192  : 
; 193  : 			this->m_mapMonsterHerd.erase( this->m_mapMonsterHerd.begin(), this->m_mapMonsterHerd.end() );

  00713	8d 45 a4	 lea	 eax, DWORD PTR $T230233[ebp]
  00716	50		 push	 eax
  00717	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0071a	83 c1 20	 add	 ecx, 32			; 00000020H
  0071d	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  00722	8b 08		 mov	 ecx, DWORD PTR [eax]
  00724	89 4d a0	 mov	 DWORD PTR $T230232[ebp], ecx
  00727	8d 55 ac	 lea	 edx, DWORD PTR $T230235[ebp]
  0072a	52		 push	 edx
  0072b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0072e	83 c1 20	 add	 ecx, 32			; 00000020H
  00731	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  00736	8b 00		 mov	 eax, DWORD PTR [eax]
  00738	89 45 a8	 mov	 DWORD PTR $T230234[ebp], eax
  0073b	8b 4d a0	 mov	 ecx, DWORD PTR $T230232[ebp]
  0073e	51		 push	 ecx
  0073f	8b 55 a8	 mov	 edx, DWORD PTR $T230234[ebp]
  00742	52		 push	 edx
  00743	8d 45 b0	 lea	 eax, DWORD PTR $T230236[ebp]
  00746	50		 push	 eax
  00747	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074a	83 c1 20	 add	 ecx, 32			; 00000020H
  0074d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase

; 194  : 			LeaveCriticalSection(&this->m_critMonsterHerd);

  00752	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00755	83 c0 30	 add	 eax, 48			; 00000030H
  00758	50		 push	 eax
  00759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN7@Stop:

; 195  : 		}
; 196  : 	}
; 197  : 
; 198  : }

  0075f	5f		 pop	 edi
  00760	5e		 pop	 esi
  00761	5b		 pop	 ebx
  00762	8b e5		 mov	 esp, ebp
  00764	5d		 pop	 ebp
  00765	c3		 ret	 0
?Stop@MonsterHerd@@UAEXXZ ENDP				; MonsterHerd::Stop
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::find
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -92						; size = 4
$T230240 = -88						; size = 4
_it$ = -20						; size = 4
_lpMHD_RETURN$ = -16					; size = 4
_lpMH$ = -12						; size = 4
_lpOBJ$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z PROC ; MonsterHerd::GetMonsterData
; _this$ = ecx

; 201  : {

  00770	55		 push	 ebp
  00771	8b ec		 mov	 ebp, esp
  00773	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00776	53		 push	 ebx
  00777	56		 push	 esi
  00778	57		 push	 edi
  00779	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0077c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00780	7d 09		 jge	 SHORT $LN8@GetMonster
  00782	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00789	eb 0f		 jmp	 SHORT $LN9@GetMonster
$LN8@GetMonster:
  0078b	33 c0		 xor	 eax, eax
  0078d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  00794	0f 9e c0	 setle	 al
  00797	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@GetMonster:
  0079a	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0079e	75 07		 jne	 SHORT $LN5@GetMonster

; 203  : 	{
; 204  : 		return NULL;

  007a0	33 c0		 xor	 eax, eax
  007a2	e9 a5 00 00 00	 jmp	 $LN6@GetMonster
$LN5@GetMonster:

; 205  : 	}
; 206  : 
; 207  : 	LPOBJ lpOBJ = &gObj[iIndex];

  007a7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  007aa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  007b0	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007b6	89 45 f8	 mov	 DWORD PTR _lpOBJ$[ebp], eax

; 208  : 
; 209  : 	if ( lpOBJ->Connected < PLAYER_PLAYING || lpOBJ->Type != OBJ_MONSTER )

  007b9	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  007bc	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  007c0	7c 0c		 jl	 SHORT $LN3@GetMonster
  007c2	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  007c5	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  007c9	83 f9 02	 cmp	 ecx, 2
  007cc	74 04		 je	 SHORT $LN4@GetMonster
$LN3@GetMonster:

; 210  : 	{
; 211  : 		return NULL;

  007ce	33 c0		 xor	 eax, eax
  007d0	eb 7a		 jmp	 SHORT $LN6@GetMonster
$LN4@GetMonster:

; 212  : 	}
; 213  : 
; 214  : 	MonsterHerd * lpMH = (MonsterHerd *)lpOBJ->m_lpMonsterHerd;

  007d2	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  007d5	8b 88 f0 10 00
	00		 mov	 ecx, DWORD PTR [eax+4336]
  007db	89 4d f4	 mov	 DWORD PTR _lpMH$[ebp], ecx

; 215  : 
; 216  : 	if ( lpMH == NULL )

  007de	83 7d f4 00	 cmp	 DWORD PTR _lpMH$[ebp], 0
  007e2	75 04		 jne	 SHORT $LN2@GetMonster

; 217  : 	{
; 218  : 		return NULL;

  007e4	33 c0		 xor	 eax, eax
  007e6	eb 64		 jmp	 SHORT $LN6@GetMonster
$LN2@GetMonster:

; 219  : 	}
; 220  : 
; 221  : 	_MONSTER_HERD_DATA * lpMHD_RETURN = NULL;

  007e8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _lpMHD_RETURN$[ebp], 0

; 222  : 
; 223  : 	EnterCriticalSection(&lpMH->m_critMonsterHerd);

  007ef	8b 45 f4	 mov	 eax, DWORD PTR _lpMH$[ebp]
  007f2	83 c0 30	 add	 eax, 48			; 00000030H
  007f5	50		 push	 eax
  007f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 224  : 	
; 225  : 	std::map<int, _MONSTER_HERD_DATA>::iterator it = lpMH->m_mapMonsterHerd.find(iIndex);

  007fc	8d 45 08	 lea	 eax, DWORD PTR _iIndex$[ebp]
  007ff	50		 push	 eax
  00800	8d 4d ec	 lea	 ecx, DWORD PTR _it$[ebp]
  00803	51		 push	 ecx
  00804	8b 4d f4	 mov	 ecx, DWORD PTR _lpMH$[ebp]
  00807	83 c1 20	 add	 ecx, 32			; 00000020H
  0080a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::find

; 226  : 
; 227  : 	if ( it != lpMH->m_mapMonsterHerd.end() )

  0080f	8d 45 a8	 lea	 eax, DWORD PTR $T230240[ebp]
  00812	50		 push	 eax
  00813	8b 4d f4	 mov	 ecx, DWORD PTR _lpMH$[ebp]
  00816	83 c1 20	 add	 ecx, 32			; 00000020H
  00819	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  0081e	50		 push	 eax
  0081f	8d 4d ec	 lea	 ecx, DWORD PTR _it$[ebp]
  00822	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
  00827	0f b6 c8	 movzx	 ecx, al
  0082a	85 c9		 test	 ecx, ecx
  0082c	74 0e		 je	 SHORT $LN1@GetMonster

; 228  : 	{
; 229  : 		lpMHD_RETURN = &it->second;

  0082e	8d 4d ec	 lea	 ecx, DWORD PTR _it$[ebp]
  00831	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->
  00836	83 c0 04	 add	 eax, 4
  00839	89 45 f0	 mov	 DWORD PTR _lpMHD_RETURN$[ebp], eax
$LN1@GetMonster:

; 230  : 	}
; 231  : 
; 232  : 	LeaveCriticalSection(&lpMH->m_critMonsterHerd);

  0083c	8b 45 f4	 mov	 eax, DWORD PTR _lpMH$[ebp]
  0083f	83 c0 30	 add	 eax, 48			; 00000030H
  00842	50		 push	 eax
  00843	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 233  : 
; 234  : 	return lpMHD_RETURN;

  00849	8b 45 f0	 mov	 eax, DWORD PTR _lpMHD_RETURN$[ebp]
$LN6@GetMonster:

; 235  : }

  0084c	5f		 pop	 edi
  0084d	5e		 pop	 esi
  0084e	5b		 pop	 ebx
  0084f	8b e5		 mov	 esp, ebp
  00851	5d		 pop	 ebp
  00852	c2 04 00	 ret	 4
?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z ENDP ; MonsterHerd::GetMonsterData
; Function compile flags: /Odtp /ZI
tv147 = -88						; size = 4
$T230242 = -84						; size = 4
$T230243 = -80						; size = 4
_lpMHD$229088 = -12					; size = 4
_it$229081 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z PROC ; MonsterHerd::BeenAttacked
; _this$ = ecx

; 238  : {

  00860	55		 push	 ebp
  00861	8b ec		 mov	 ebp, esp
  00863	83 ec 58	 sub	 esp, 88			; 00000058H
  00866	53		 push	 ebx
  00867	56		 push	 esi
  00868	57		 push	 edi
  00869	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	if ( lpObj == NULL )

  0086c	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  00870	75 05		 jne	 SHORT $LN17@BeenAttack

; 240  : 	{
; 241  : 		return;

  00872	e9 a7 02 00 00	 jmp	 $LN18@BeenAttack
$LN17@BeenAttack:

; 242  : 	}
; 243  : 
; 244  : 	if ( lpObj->Connected < PLAYER_PLAYING || lpObj->Type != OBJ_MONSTER )

  00877	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0087a	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0087e	7c 0c		 jl	 SHORT $LN15@BeenAttack
  00880	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00883	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  00887	83 f9 02	 cmp	 ecx, 2
  0088a	74 05		 je	 SHORT $LN16@BeenAttack
$LN15@BeenAttack:

; 245  : 	{
; 246  : 		return;

  0088c	e9 8d 02 00 00	 jmp	 $LN18@BeenAttack
$LN16@BeenAttack:

; 247  : 	}
; 248  : 
; 249  : 	if ( lpTargetObj->Connected < PLAYER_PLAYING )

  00891	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00894	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00898	7d 05		 jge	 SHORT $LN14@BeenAttack

; 250  : 	{
; 251  : 		return;

  0089a	e9 7f 02 00 00	 jmp	 $LN18@BeenAttack
$LN14@BeenAttack:

; 252  : 	}
; 253  : 
; 254  : 	if ( this->m_bHerdActive == 0 )

  0089f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008a2	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  008a6	75 05		 jne	 SHORT $LN13@BeenAttack

; 255  : 	{
; 256  : 		return;

  008a8	e9 71 02 00 00	 jmp	 $LN18@BeenAttack
$LN13@BeenAttack:

; 257  : 	}
; 258  : 
; 259  : 	for ( std::map<int, _MONSTER_HERD_DATA>::iterator it = this->m_mapMonsterHerd.begin(); it != this->m_mapMonsterHerd.end() ; it++)

  008ad	8d 45 f8	 lea	 eax, DWORD PTR _it$229081[ebp]
  008b0	50		 push	 eax
  008b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008b4	83 c1 20	 add	 ecx, 32			; 00000020H
  008b7	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  008bc	eb 0e		 jmp	 SHORT $LN12@BeenAttack
$LN11@BeenAttack:
  008be	6a 00		 push	 0
  008c0	8d 45 ac	 lea	 eax, DWORD PTR $T230242[ebp]
  008c3	50		 push	 eax
  008c4	8d 4d f8	 lea	 ecx, DWORD PTR _it$229081[ebp]
  008c7	e8 00 00 00 00	 call	 ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
$LN12@BeenAttack:
  008cc	8d 45 b0	 lea	 eax, DWORD PTR $T230243[ebp]
  008cf	50		 push	 eax
  008d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008d3	83 c1 20	 add	 ecx, 32			; 00000020H
  008d6	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  008db	50		 push	 eax
  008dc	8d 4d f8	 lea	 ecx, DWORD PTR _it$229081[ebp]
  008df	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
  008e4	0f b6 c8	 movzx	 ecx, al
  008e7	85 c9		 test	 ecx, ecx
  008e9	0f 84 2f 02 00
	00		 je	 $LN18@BeenAttack

; 260  : 	{
; 261  : 		_MONSTER_HERD_DATA * lpMHD = &it->second;

  008ef	8d 4d f8	 lea	 ecx, DWORD PTR _it$229081[ebp]
  008f2	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->
  008f7	83 c0 04	 add	 eax, 4
  008fa	89 45 f4	 mov	 DWORD PTR _lpMHD$229088[ebp], eax

; 262  : 
; 263  : 		if (  OBJMAX_RANGE(lpMHD->m_iIndex)== FALSE )

  008fd	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00900	83 38 00	 cmp	 DWORD PTR [eax], 0
  00903	7d 09		 jge	 SHORT $LN20@BeenAttack
  00905	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
  0090c	eb 11		 jmp	 SHORT $LN21@BeenAttack
$LN20@BeenAttack:
  0090e	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229088[ebp]
  00911	33 d2		 xor	 edx, edx
  00913	81 39 97 3a 00
	00		 cmp	 DWORD PTR [ecx], 14999	; 00003a97H
  00919	0f 9e c2	 setle	 dl
  0091c	89 55 a8	 mov	 DWORD PTR tv147[ebp], edx
$LN21@BeenAttack:
  0091f	83 7d a8 00	 cmp	 DWORD PTR tv147[ebp], 0
  00923	75 02		 jne	 SHORT $LN9@BeenAttack

; 264  : 		{
; 265  : 			continue;

  00925	eb 97		 jmp	 SHORT $LN11@BeenAttack
$LN9@BeenAttack:

; 266  : 		}
; 267  : 
; 268  : 		if ( gObj[lpMHD->m_iIndex].Live == FALSE || gObj[lpMHD->m_iIndex].m_State != 2 )

  00927	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  0092a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0092c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00932	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00938	0f b6 44 0a 6a	 movzx	 eax, BYTE PTR [edx+ecx+106]
  0093d	85 c0		 test	 eax, eax
  0093f	74 1b		 je	 SHORT $LN7@BeenAttack
  00941	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00944	8b 08		 mov	 ecx, DWORD PTR [eax]
  00946	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0094c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00952	83 bc 0a 20 02
	00 00 02	 cmp	 DWORD PTR [edx+ecx+544], 2
  0095a	74 05		 je	 SHORT $LN8@BeenAttack
$LN7@BeenAttack:

; 269  : 		{
; 270  : 			continue;

  0095c	e9 5d ff ff ff	 jmp	 $LN11@BeenAttack
$LN8@BeenAttack:

; 271  : 		}
; 272  : 
; 273  : 		if ( gObj[lpMHD->m_iIndex].m_lpMonsterHerd != lpObj->m_lpMonsterHerd )

  00961	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00964	8b 08		 mov	 ecx, DWORD PTR [eax]
  00966	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0096c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00972	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00975	8b 8c 0a f0 10
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+4336]
  0097c	3b 88 f0 10 00
	00		 cmp	 ecx, DWORD PTR [eax+4336]
  00982	74 05		 je	 SHORT $LN6@BeenAttack

; 274  : 		{
; 275  : 			continue;

  00984	e9 35 ff ff ff	 jmp	 $LN11@BeenAttack
$LN6@BeenAttack:

; 276  : 		}
; 277  : 
; 278  : 		if ( lpMHD->m_iIndex == lpObj->m_Index )

  00989	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  0098c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0098f	8b 10		 mov	 edx, DWORD PTR [eax]
  00991	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00993	75 05		 jne	 SHORT $LN5@BeenAttack

; 279  : 		{
; 280  : 			continue;

  00995	e9 24 ff ff ff	 jmp	 $LN11@BeenAttack
$LN5@BeenAttack:

; 281  : 		}
; 282  : 
; 283  : 		if ( gObj[lpMHD->m_iIndex].TargetNumber == -1 )

  0099a	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  0099d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0099f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  009a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009ab	0f bf 84 0a 58
	04 00 00	 movsx	 eax, WORD PTR [edx+ecx+1112]
  009b3	83 f8 ff	 cmp	 eax, -1
  009b6	0f 85 b1 00 00
	00		 jne	 $LN4@BeenAttack

; 284  : 		{
; 285  : 			if ( (rand()%100) < 70 )

  009bc	e8 00 00 00 00	 call	 _rand
  009c1	99		 cdq
  009c2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  009c7	f7 f9		 idiv	 ecx
  009c9	83 fa 46	 cmp	 edx, 70			; 00000046H
  009cc	0f 8d 96 00 00
	00		 jge	 $LN3@BeenAttack

; 286  : 			{
; 287  : 				gObj[lpMHD->m_iIndex].TargetNumber = lpTargetObj->m_Index;

  009d2	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  009d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  009dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009e3	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  009e6	66 8b 00	 mov	 ax, WORD PTR [eax]
  009e9	66 89 84 0a 58
	04 00 00	 mov	 WORD PTR [edx+ecx+1112], ax

; 288  : 				gObj[lpMHD->m_iIndex].m_ActState.Emotion = 1;

  009f1	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  009f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  009f6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  009fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a02	8b 84 0a 18 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+536]
  00a09	25 0f ff ff ff	 and	 eax, -241		; ffffff0fH
  00a0e	83 c8 10	 or	 eax, 16			; 00000010H
  00a11	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229088[ebp]
  00a14	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a16	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00a1c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a22	89 84 11 18 02
	00 00		 mov	 DWORD PTR [ecx+edx+536], eax

; 289  : 				gObj[lpMHD->m_iIndex].m_ActState.EmotionCount = 50;

  00a29	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00a2c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a2e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00a34	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a3a	8b 84 0a 18 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+536]
  00a41	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  00a46	0d 00 32 00 00	 or	 eax, 12800		; 00003200H
  00a4b	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229088[ebp]
  00a4e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a50	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00a56	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a5c	89 84 11 18 02
	00 00		 mov	 DWORD PTR [ecx+edx+536], eax

; 290  : 				continue;

  00a63	e9 56 fe ff ff	 jmp	 $LN11@BeenAttack
$LN3@BeenAttack:

; 291  : 			}
; 292  : 		}

  00a68	e9 ac 00 00 00	 jmp	 $LN2@BeenAttack
$LN4@BeenAttack:

; 293  : 		else if ( (rand()%100) < 30 )

  00a6d	e8 00 00 00 00	 call	 _rand
  00a72	99		 cdq
  00a73	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a78	f7 f9		 idiv	 ecx
  00a7a	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  00a7d	0f 8d 96 00 00
	00		 jge	 $LN2@BeenAttack

; 294  : 		{
; 295  : 			gObj[lpMHD->m_iIndex].TargetNumber = lpTargetObj->m_Index;

  00a83	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00a86	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a88	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00a8e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a94	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a97	66 8b 00	 mov	 ax, WORD PTR [eax]
  00a9a	66 89 84 0a 58
	04 00 00	 mov	 WORD PTR [edx+ecx+1112], ax

; 296  : 			gObj[lpMHD->m_iIndex].m_ActState.Emotion = 1;

  00aa2	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00aa5	8b 08		 mov	 ecx, DWORD PTR [eax]
  00aa7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00aad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab3	8b 84 0a 18 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+536]
  00aba	25 0f ff ff ff	 and	 eax, -241		; ffffff0fH
  00abf	83 c8 10	 or	 eax, 16			; 00000010H
  00ac2	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229088[ebp]
  00ac5	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ac7	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00acd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ad3	89 84 11 18 02
	00 00		 mov	 DWORD PTR [ecx+edx+536], eax

; 297  : 			gObj[lpMHD->m_iIndex].m_ActState.EmotionCount = 50;

  00ada	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229088[ebp]
  00add	8b 08		 mov	 ecx, DWORD PTR [eax]
  00adf	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00ae5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00aeb	8b 84 0a 18 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+536]
  00af2	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  00af7	0d 00 32 00 00	 or	 eax, 12800		; 00003200H
  00afc	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229088[ebp]
  00aff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b01	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00b07	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b0d	89 84 11 18 02
	00 00		 mov	 DWORD PTR [ecx+edx+536], eax

; 298  : 			continue;

  00b14	e9 a5 fd ff ff	 jmp	 $LN11@BeenAttack
$LN2@BeenAttack:

; 299  : 		}
; 300  : 	}

  00b19	e9 a0 fd ff ff	 jmp	 $LN11@BeenAttack
$LN18@BeenAttack:

; 301  : }

  00b1e	5f		 pop	 edi
  00b1f	5e		 pop	 esi
  00b20	5b		 pop	 ebx
  00b21	8b e5		 mov	 esp, ebp
  00b23	5d		 pop	 ebp
  00b24	c2 08 00	 ret	 8
?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z ENDP ; MonsterHerd::BeenAttacked
; Function compile flags: /Odtp /ZI
tv152 = -88						; size = 4
tv77 = -88						; size = 4
$T230249 = -84						; size = 4
$T230250 = -80						; size = 4
_lpMHD$229130 = -12					; size = 4
_it$229123 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_iAttackPercent$ = 16					; size = 4
?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z PROC ; MonsterHerd::OrderAttack
; _this$ = ecx

; 304  : {

  00b30	55		 push	 ebp
  00b31	8b ec		 mov	 ebp, esp
  00b33	83 ec 58	 sub	 esp, 88			; 00000058H
  00b36	53		 push	 ebx
  00b37	56		 push	 esi
  00b38	57		 push	 edi
  00b39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 305  : 	if ( lpObj == NULL )

  00b3c	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  00b40	75 05		 jne	 SHORT $LN15@OrderAttac

; 306  : 	{
; 307  : 		return;

  00b42	e9 fa 01 00 00	 jmp	 $LN16@OrderAttac
$LN15@OrderAttac:

; 308  : 	}
; 309  : 
; 310  : 	if ( lpObj->Connected < PLAYER_PLAYING || lpObj->Type != OBJ_MONSTER )

  00b47	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4a	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00b4e	7c 0c		 jl	 SHORT $LN13@OrderAttac
  00b50	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b53	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  00b57	83 f9 02	 cmp	 ecx, 2
  00b5a	74 05		 je	 SHORT $LN14@OrderAttac
$LN13@OrderAttac:

; 311  : 	{
; 312  : 		return;

  00b5c	e9 e0 01 00 00	 jmp	 $LN16@OrderAttac
$LN14@OrderAttac:

; 313  : 	}
; 314  : 
; 315  : 	if ( lpTargetObj->Connected < PLAYER_PLAYING )

  00b61	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b64	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00b68	7d 05		 jge	 SHORT $LN12@OrderAttac

; 316  : 	{
; 317  : 		return;

  00b6a	e9 d2 01 00 00	 jmp	 $LN16@OrderAttac
$LN12@OrderAttac:

; 318  : 	}
; 319  : 
; 320  : 	if ( this->m_bHerdActive == 0 )

  00b6f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b72	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00b76	75 05		 jne	 SHORT $LN11@OrderAttac

; 321  : 	{
; 322  : 		return;

  00b78	e9 c4 01 00 00	 jmp	 $LN16@OrderAttac
$LN11@OrderAttac:

; 323  : 	}
; 324  : 
; 325  : 	if ( ((iAttackPercent<0)?FALSE:(iAttackPercent>100)?FALSE:TRUE) == FALSE )

  00b7d	83 7d 10 00	 cmp	 DWORD PTR _iAttackPercent$[ebp], 0
  00b81	7d 09		 jge	 SHORT $LN18@OrderAttac
  00b83	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00b8a	eb 0c		 jmp	 SHORT $LN19@OrderAttac
$LN18@OrderAttac:
  00b8c	33 c0		 xor	 eax, eax
  00b8e	83 7d 10 64	 cmp	 DWORD PTR _iAttackPercent$[ebp], 100 ; 00000064H
  00b92	0f 9e c0	 setle	 al
  00b95	89 45 a8	 mov	 DWORD PTR tv77[ebp], eax
$LN19@OrderAttac:
  00b98	83 7d a8 00	 cmp	 DWORD PTR tv77[ebp], 0
  00b9c	75 05		 jne	 SHORT $LN10@OrderAttac

; 326  : 	{
; 327  : 		return;

  00b9e	e9 9e 01 00 00	 jmp	 $LN16@OrderAttac
$LN10@OrderAttac:

; 328  : 	}
; 329  : 
; 330  : 	for ( std::map<int, _MONSTER_HERD_DATA>::iterator it = this->m_mapMonsterHerd.begin(); it != this->m_mapMonsterHerd.end() ; it++)

  00ba3	8d 45 f8	 lea	 eax, DWORD PTR _it$229123[ebp]
  00ba6	50		 push	 eax
  00ba7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00baa	83 c1 20	 add	 ecx, 32			; 00000020H
  00bad	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  00bb2	eb 0e		 jmp	 SHORT $LN9@OrderAttac
$LN8@OrderAttac:
  00bb4	6a 00		 push	 0
  00bb6	8d 45 ac	 lea	 eax, DWORD PTR $T230249[ebp]
  00bb9	50		 push	 eax
  00bba	8d 4d f8	 lea	 ecx, DWORD PTR _it$229123[ebp]
  00bbd	e8 00 00 00 00	 call	 ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
$LN9@OrderAttac:
  00bc2	8d 45 b0	 lea	 eax, DWORD PTR $T230250[ebp]
  00bc5	50		 push	 eax
  00bc6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc9	83 c1 20	 add	 ecx, 32			; 00000020H
  00bcc	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  00bd1	50		 push	 eax
  00bd2	8d 4d f8	 lea	 ecx, DWORD PTR _it$229123[ebp]
  00bd5	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
  00bda	0f b6 c8	 movzx	 ecx, al
  00bdd	85 c9		 test	 ecx, ecx
  00bdf	0f 84 5c 01 00
	00		 je	 $LN16@OrderAttac

; 331  : 	{
; 332  : 		_MONSTER_HERD_DATA * lpMHD = &it->second;

  00be5	8d 4d f8	 lea	 ecx, DWORD PTR _it$229123[ebp]
  00be8	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->
  00bed	83 c0 04	 add	 eax, 4
  00bf0	89 45 f4	 mov	 DWORD PTR _lpMHD$229130[ebp], eax

; 333  : 
; 334  : 		if ( OBJMAX_RANGE(lpMHD->m_iIndex)  == FALSE )

  00bf3	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00bf6	83 38 00	 cmp	 DWORD PTR [eax], 0
  00bf9	7d 09		 jge	 SHORT $LN20@OrderAttac
  00bfb	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv152[ebp], 0
  00c02	eb 11		 jmp	 SHORT $LN21@OrderAttac
$LN20@OrderAttac:
  00c04	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229130[ebp]
  00c07	33 d2		 xor	 edx, edx
  00c09	81 39 97 3a 00
	00		 cmp	 DWORD PTR [ecx], 14999	; 00003a97H
  00c0f	0f 9e c2	 setle	 dl
  00c12	89 55 a8	 mov	 DWORD PTR tv152[ebp], edx
$LN21@OrderAttac:
  00c15	83 7d a8 00	 cmp	 DWORD PTR tv152[ebp], 0
  00c19	75 02		 jne	 SHORT $LN6@OrderAttac

; 335  : 		{
; 336  : 			continue;

  00c1b	eb 97		 jmp	 SHORT $LN8@OrderAttac
$LN6@OrderAttac:

; 337  : 		}
; 338  : 
; 339  : 		if ( gObj[lpMHD->m_iIndex].Live == FALSE || gObj[lpMHD->m_iIndex].m_State != 2 )

  00c1d	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00c20	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c22	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00c28	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c2e	0f b6 44 0a 6a	 movzx	 eax, BYTE PTR [edx+ecx+106]
  00c33	85 c0		 test	 eax, eax
  00c35	74 1b		 je	 SHORT $LN4@OrderAttac
  00c37	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00c3a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c3c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00c42	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c48	83 bc 0a 20 02
	00 00 02	 cmp	 DWORD PTR [edx+ecx+544], 2
  00c50	74 05		 je	 SHORT $LN5@OrderAttac
$LN4@OrderAttac:

; 340  : 		{
; 341  : 			continue;

  00c52	e9 5d ff ff ff	 jmp	 $LN8@OrderAttac
$LN5@OrderAttac:

; 342  : 		}
; 343  : 
; 344  : 		if ( gObj[lpMHD->m_iIndex].m_lpMonsterHerd != lpObj->m_lpMonsterHerd )

  00c57	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00c5a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c5c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00c62	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c68	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c6b	8b 8c 0a f0 10
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+4336]
  00c72	3b 88 f0 10 00
	00		 cmp	 ecx, DWORD PTR [eax+4336]
  00c78	74 05		 je	 SHORT $LN3@OrderAttac

; 345  : 		{
; 346  : 			continue;

  00c7a	e9 35 ff ff ff	 jmp	 $LN8@OrderAttac
$LN3@OrderAttac:

; 347  : 		}
; 348  : 
; 349  : 		if ( lpMHD->m_iIndex == lpObj->m_Index )

  00c7f	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00c82	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c85	8b 10		 mov	 edx, DWORD PTR [eax]
  00c87	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00c89	75 05		 jne	 SHORT $LN2@OrderAttac

; 350  : 		{
; 351  : 			continue;

  00c8b	e9 24 ff ff ff	 jmp	 $LN8@OrderAttac
$LN2@OrderAttac:

; 352  : 		}
; 353  : 
; 354  : 		if ( (rand()%100) < iAttackPercent )

  00c90	e8 00 00 00 00	 call	 _rand
  00c95	99		 cdq
  00c96	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00c9b	f7 f9		 idiv	 ecx
  00c9d	3b 55 10	 cmp	 edx, DWORD PTR _iAttackPercent$[ebp]
  00ca0	0f 8d 96 00 00
	00		 jge	 $LN1@OrderAttac

; 355  : 		{
; 356  : 			gObj[lpMHD->m_iIndex].TargetNumber = lpTargetObj->m_Index;

  00ca6	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00ca9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cab	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00cb1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cb7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cba	66 8b 00	 mov	 ax, WORD PTR [eax]
  00cbd	66 89 84 0a 58
	04 00 00	 mov	 WORD PTR [edx+ecx+1112], ax

; 357  : 			gObj[lpMHD->m_iIndex].m_ActState.Emotion = 1;

  00cc5	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00cc8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cca	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00cd0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cd6	8b 84 0a 18 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+536]
  00cdd	25 0f ff ff ff	 and	 eax, -241		; ffffff0fH
  00ce2	83 c8 10	 or	 eax, 16			; 00000010H
  00ce5	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229130[ebp]
  00ce8	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cea	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00cf0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cf6	89 84 11 18 02
	00 00		 mov	 DWORD PTR [ecx+edx+536], eax

; 358  : 			gObj[lpMHD->m_iIndex].m_ActState.EmotionCount = 50;

  00cfd	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$229130[ebp]
  00d00	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d02	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00d08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d0e	8b 84 0a 18 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+536]
  00d15	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  00d1a	0d 00 32 00 00	 or	 eax, 12800		; 00003200H
  00d1f	8b 4d f4	 mov	 ecx, DWORD PTR _lpMHD$229130[ebp]
  00d22	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d24	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00d2a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d30	89 84 11 18 02
	00 00		 mov	 DWORD PTR [ecx+edx+536], eax

; 359  : 
; 360  : 			continue;

  00d37	e9 78 fe ff ff	 jmp	 $LN8@OrderAttac
$LN1@OrderAttac:

; 361  : 		}
; 362  : 	}

  00d3c	e9 73 fe ff ff	 jmp	 $LN8@OrderAttac
$LN16@OrderAttac:

; 363  : }

  00d41	5f		 pop	 edi
  00d42	5e		 pop	 esi
  00d43	5b		 pop	 ebx
  00d44	8b e5		 mov	 esp, ebp
  00d46	5d		 pop	 ebp
  00d47	c2 0c 00	 ret	 12			; 0000000cH
?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z ENDP ; MonsterHerd::OrderAttack
; Function compile flags: /Odtp /ZI
tv67 = -84						; size = 4
_iY2$ = -16						; size = 4
_iX2$ = -12						; size = 4
_lpOBJ$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckInRadius@MonsterHerd@@UAEHH@Z PROC		; MonsterHerd::CheckInRadius
; _this$ = ecx

; 366  : {

  00d50	55		 push	 ebp
  00d51	8b ec		 mov	 ebp, esp
  00d53	83 ec 54	 sub	 esp, 84			; 00000054H
  00d56	53		 push	 ebx
  00d57	56		 push	 esi
  00d58	57		 push	 edi
  00d59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 367  : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00d5c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00d60	7d 09		 jge	 SHORT $LN7@CheckInRad
  00d62	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00d69	eb 0f		 jmp	 SHORT $LN8@CheckInRad
$LN7@CheckInRad:
  00d6b	33 c0		 xor	 eax, eax
  00d6d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  00d74	0f 9e c0	 setle	 al
  00d77	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN8@CheckInRad:
  00d7a	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  00d7e	75 07		 jne	 SHORT $LN4@CheckInRad

; 368  : 	{
; 369  : 		return FALSE;

  00d80	33 c0		 xor	 eax, eax
  00d82	e9 97 00 00 00	 jmp	 $LN5@CheckInRad
$LN4@CheckInRad:

; 370  : 	}
; 371  : 
; 372  : 	LPOBJ lpOBJ = &gObj[iIndex];

  00d87	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00d8a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00d90	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d96	89 45 f8	 mov	 DWORD PTR _lpOBJ$[ebp], eax

; 373  : 
; 374  : 	if ( lpOBJ->Connected < PLAYER_PLAYING || lpOBJ->Type != OBJ_MONSTER )

  00d99	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  00d9c	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00da0	7c 0c		 jl	 SHORT $LN2@CheckInRad
  00da2	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  00da5	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  00da9	83 f9 02	 cmp	 ecx, 2
  00dac	74 04		 je	 SHORT $LN3@CheckInRad
$LN2@CheckInRad:

; 375  : 	{
; 376  : 		return FALSE;

  00dae	33 c0		 xor	 eax, eax
  00db0	eb 6c		 jmp	 SHORT $LN5@CheckInRad
$LN3@CheckInRad:

; 377  : 	}
; 378  : 
; 379  : 	int iX2 = (lpOBJ->X - this->m_iCUR_X) * (lpOBJ->X - this->m_iCUR_X);

  00db2	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  00db5	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00dbc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00dbf	2b 4a 0c	 sub	 ecx, DWORD PTR [edx+12]
  00dc2	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  00dc5	0f bf 90 44 01
	00 00		 movsx	 edx, WORD PTR [eax+324]
  00dcc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00dcf	2b 50 0c	 sub	 edx, DWORD PTR [eax+12]
  00dd2	0f af ca	 imul	 ecx, edx
  00dd5	89 4d f4	 mov	 DWORD PTR _iX2$[ebp], ecx

; 380  : 	int iY2 = (lpOBJ->Y - this->m_iCUR_Y) * (lpOBJ->Y - this->m_iCUR_Y);

  00dd8	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  00ddb	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00de2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00de5	2b 4a 10	 sub	 ecx, DWORD PTR [edx+16]
  00de8	8b 45 f8	 mov	 eax, DWORD PTR _lpOBJ$[ebp]
  00deb	0f bf 90 46 01
	00 00		 movsx	 edx, WORD PTR [eax+326]
  00df2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00df5	2b 50 10	 sub	 edx, DWORD PTR [eax+16]
  00df8	0f af ca	 imul	 ecx, edx
  00dfb	89 4d f0	 mov	 DWORD PTR _iY2$[ebp], ecx

; 381  : 
; 382  : 	if ( (this->m_iRADIUS * this->m_iRADIUS) < (iX2+iY2) )

  00dfe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e01	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e04	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00e07	0f af 51 14	 imul	 edx, DWORD PTR [ecx+20]
  00e0b	8b 45 f4	 mov	 eax, DWORD PTR _iX2$[ebp]
  00e0e	03 45 f0	 add	 eax, DWORD PTR _iY2$[ebp]
  00e11	3b d0		 cmp	 edx, eax
  00e13	7d 04		 jge	 SHORT $LN1@CheckInRad

; 383  : 	{
; 384  : 		return FALSE;

  00e15	33 c0		 xor	 eax, eax
  00e17	eb 05		 jmp	 SHORT $LN5@CheckInRad
$LN1@CheckInRad:

; 385  : 	}
; 386  : 
; 387  : 	return TRUE;

  00e19	b8 01 00 00 00	 mov	 eax, 1
$LN5@CheckInRad:

; 388  : }

  00e1e	5f		 pop	 edi
  00e1f	5e		 pop	 esi
  00e20	5b		 pop	 ebx
  00e21	8b e5		 mov	 esp, ebp
  00e23	5d		 pop	 ebp
  00e24	c2 04 00	 ret	 4
?CheckInRadius@MonsterHerd@@UAEHH@Z ENDP		; MonsterHerd::CheckInRadius
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_cX$ = 8						; size = 4
_cY$ = 12						; size = 4
?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z PROC	; MonsterHerd::GetCurrentLocation
; _this$ = ecx

; 391  : {

  00e30	55		 push	 ebp
  00e31	8b ec		 mov	 ebp, esp
  00e33	83 ec 44	 sub	 esp, 68			; 00000044H
  00e36	53		 push	 ebx
  00e37	56		 push	 esi
  00e38	57		 push	 edi
  00e39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 	if ( this->m_bHasInfo == 0 )

  00e3c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e3f	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00e43	75 04		 jne	 SHORT $LN1@GetCurrent

; 393  : 	{
; 394  : 		return FALSE;

  00e45	33 c0		 xor	 eax, eax
  00e47	eb 1b		 jmp	 SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 395  : 	}
; 396  : 
; 397  : 	cX = this->m_iCUR_X;

  00e49	8b 45 08	 mov	 eax, DWORD PTR _cX$[ebp]
  00e4c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e4f	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  00e52	88 10		 mov	 BYTE PTR [eax], dl

; 398  : 	cY = this->m_iCUR_Y ;

  00e54	8b 45 0c	 mov	 eax, DWORD PTR _cY$[ebp]
  00e57	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e5a	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00e5d	88 10		 mov	 BYTE PTR [eax], dl

; 399  : 
; 400  : 	return TRUE;

  00e5f	b8 01 00 00 00	 mov	 eax, 1
$LN2@GetCurrent:

; 401  : }

  00e64	5f		 pop	 edi
  00e65	5e		 pop	 esi
  00e66	5b		 pop	 ebx
  00e67	8b e5		 mov	 esp, ebp
  00e69	5d		 pop	 ebp
  00e6a	c2 08 00	 ret	 8
?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z ENDP	; MonsterHerd::GetCurrentLocation
; Function compile flags: /Odtp /ZI
_attr$229164 = -9					; size = 1
_iCount$ = -8						; size = 4
_this$ = -4						; size = 4
_cX$ = 8						; size = 4
_cY$ = 12						; size = 4
?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z PROC		; MonsterHerd::GetRandomLocation
; _this$ = ecx

; 404  : {

  00e70	55		 push	 ebp
  00e71	8b ec		 mov	 ebp, esp
  00e73	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00e76	53		 push	 ebx
  00e77	56		 push	 esi
  00e78	57		 push	 edi
  00e79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 405  : 	if ( this->m_bHasInfo == 0 )

  00e7c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e7f	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00e83	75 07		 jne	 SHORT $LN4@GetRandomL

; 406  : 	{
; 407  : 		return FALSE;

  00e85	33 c0		 xor	 eax, eax
  00e87	e9 d1 00 00 00	 jmp	 $LN5@GetRandomL
$LN4@GetRandomL:

; 408  : 	}
; 409  : 
; 410  : 	int iCount = 100;

  00e8c	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 100 ; 00000064H
$LN3@GetRandomL:

; 411  : 
; 412  : 	while ( iCount-- != 0)

  00e93	8b 45 f8	 mov	 eax, DWORD PTR _iCount$[ebp]
  00e96	8b 4d f8	 mov	 ecx, DWORD PTR _iCount$[ebp]
  00e99	83 e9 01	 sub	 ecx, 1
  00e9c	89 4d f8	 mov	 DWORD PTR _iCount$[ebp], ecx
  00e9f	85 c0		 test	 eax, eax
  00ea1	0f 84 b4 00 00
	00		 je	 $LN2@GetRandomL

; 413  : 	{
; 414  : 		cX = rand()%(this->m_iRADIUS+1) * (((rand()%2==0)?-1:1)) + this->m_iCUR_X;

  00ea7	e8 00 00 00 00	 call	 _rand
  00eac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eaf	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00eb2	83 c1 01	 add	 ecx, 1
  00eb5	99		 cdq
  00eb6	f7 f9		 idiv	 ecx
  00eb8	8b da		 mov	 ebx, edx
  00eba	e8 00 00 00 00	 call	 _rand
  00ebf	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00ec4	79 05		 jns	 SHORT $LN7@GetRandomL
  00ec6	48		 dec	 eax
  00ec7	83 c8 fe	 or	 eax, -2			; fffffffeH
  00eca	40		 inc	 eax
$LN7@GetRandomL:
  00ecb	f7 d8		 neg	 eax
  00ecd	1b c0		 sbb	 eax, eax
  00ecf	83 e0 02	 and	 eax, 2
  00ed2	83 c0 ff	 add	 eax, -1
  00ed5	0f af d8	 imul	 ebx, eax
  00ed8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00edb	03 5a 0c	 add	 ebx, DWORD PTR [edx+12]
  00ede	8b 45 08	 mov	 eax, DWORD PTR _cX$[ebp]
  00ee1	88 18		 mov	 BYTE PTR [eax], bl

; 415  : 		cY = rand()%(this->m_iRADIUS+1) * (((!(rand()%2)))?-1:1) + this->m_iCUR_Y;

  00ee3	e8 00 00 00 00	 call	 _rand
  00ee8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eeb	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00eee	83 c1 01	 add	 ecx, 1
  00ef1	99		 cdq
  00ef2	f7 f9		 idiv	 ecx
  00ef4	8b da		 mov	 ebx, edx
  00ef6	e8 00 00 00 00	 call	 _rand
  00efb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00f00	79 05		 jns	 SHORT $LN8@GetRandomL
  00f02	48		 dec	 eax
  00f03	83 c8 fe	 or	 eax, -2			; fffffffeH
  00f06	40		 inc	 eax
$LN8@GetRandomL:
  00f07	f7 d8		 neg	 eax
  00f09	1b c0		 sbb	 eax, eax
  00f0b	83 e0 02	 and	 eax, 2
  00f0e	83 c0 ff	 add	 eax, -1
  00f11	0f af d8	 imul	 ebx, eax
  00f14	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f17	03 5a 10	 add	 ebx, DWORD PTR [edx+16]
  00f1a	8b 45 0c	 mov	 eax, DWORD PTR _cY$[ebp]
  00f1d	88 18		 mov	 BYTE PTR [eax], bl

; 416  : 
; 417  : 		BYTE attr = MapC[this->m_iMapNumber].GetAttr(cX, cY);

  00f1f	8b 45 0c	 mov	 eax, DWORD PTR _cY$[ebp]
  00f22	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00f25	51		 push	 ecx
  00f26	8b 55 08	 mov	 edx, DWORD PTR _cX$[ebp]
  00f29	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00f2c	50		 push	 eax
  00f2d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f30	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00f33	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  00f39	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00f3f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00f44	88 45 f7	 mov	 BYTE PTR _attr$229164[ebp], al

; 418  : 
; 419  : 		if ( attr == 0 )

  00f47	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$229164[ebp]
  00f4b	85 c0		 test	 eax, eax
  00f4d	75 07		 jne	 SHORT $LN1@GetRandomL

; 420  : 		{
; 421  : 			return TRUE;

  00f4f	b8 01 00 00 00	 mov	 eax, 1
  00f54	eb 07		 jmp	 SHORT $LN5@GetRandomL
$LN1@GetRandomL:

; 422  : 		}
; 423  : 	}

  00f56	e9 38 ff ff ff	 jmp	 $LN3@GetRandomL
$LN2@GetRandomL:

; 424  : 
; 425  : 	return FALSE;

  00f5b	33 c0		 xor	 eax, eax
$LN5@GetRandomL:

; 426  : }

  00f5d	5f		 pop	 edi
  00f5e	5e		 pop	 esi
  00f5f	5b		 pop	 ebx
  00f60	8b e5		 mov	 esp, ebp
  00f62	5d		 pop	 ebp
  00f63	c2 08 00	 ret	 8
?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z ENDP		; MonsterHerd::GetRandomLocation
; Function compile flags: /Odtp /ZI
_btMapAttr$ = -5					; size = 1
_this$ = -4						; size = 4
_cX$ = 8						; size = 4
_cY$ = 12						; size = 4
?CheckLocation@MonsterHerd@@UAEHAAE0@Z PROC		; MonsterHerd::CheckLocation
; _this$ = ecx

; 429  : {

  00f70	55		 push	 ebp
  00f71	8b ec		 mov	 ebp, esp
  00f73	83 ec 48	 sub	 esp, 72			; 00000048H
  00f76	53		 push	 ebx
  00f77	56		 push	 esi
  00f78	57		 push	 edi
  00f79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 430  : 	BYTE btMapAttr = MapC[this->m_iMapNumber].GetAttr(cX, cY);

  00f7c	8b 45 0c	 mov	 eax, DWORD PTR _cY$[ebp]
  00f7f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00f82	51		 push	 ecx
  00f83	8b 55 08	 mov	 edx, DWORD PTR _cX$[ebp]
  00f86	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00f89	50		 push	 eax
  00f8a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f8d	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00f90	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  00f96	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00f9c	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00fa1	88 45 fb	 mov	 BYTE PTR _btMapAttr$[ebp], al

; 431  : 
; 432  : 	if ( (btMapAttr&1) == 1 || (btMapAttr&4) == 4 || (btMapAttr&8) == 8 )

  00fa4	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  00fa8	83 e0 01	 and	 eax, 1
  00fab	75 12		 jne	 SHORT $LN1@CheckLocat
  00fad	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  00fb1	83 e0 04	 and	 eax, 4
  00fb4	75 09		 jne	 SHORT $LN1@CheckLocat
  00fb6	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  00fba	83 e0 08	 and	 eax, 8
  00fbd	74 04		 je	 SHORT $LN2@CheckLocat
$LN1@CheckLocat:

; 433  : 	{
; 434  : 		return FALSE;

  00fbf	33 c0		 xor	 eax, eax
  00fc1	eb 05		 jmp	 SHORT $LN3@CheckLocat
$LN2@CheckLocat:

; 435  : 	}
; 436  : 
; 437  : 	return TRUE;

  00fc3	b8 01 00 00 00	 mov	 eax, 1
$LN3@CheckLocat:

; 438  : }

  00fc8	5f		 pop	 edi
  00fc9	5e		 pop	 esi
  00fca	5b		 pop	 ebx
  00fcb	8b e5		 mov	 esp, ebp
  00fcd	5d		 pop	 ebp
  00fce	c2 08 00	 ret	 8
?CheckLocation@MonsterHerd@@UAEHAAE0@Z ENDP		; MonsterHerd::CheckLocation
; Function compile flags: /Odtp /ZI
_btMapAttr$ = -5					; size = 1
_this$ = -4						; size = 4
_iTX$ = 8						; size = 1
_iTY$ = 12						; size = 1
?MoveHerd@MonsterHerd@@UAEHEE@Z PROC			; MonsterHerd::MoveHerd
; _this$ = ecx

; 441  : {

  00fe0	55		 push	 ebp
  00fe1	8b ec		 mov	 ebp, esp
  00fe3	83 ec 48	 sub	 esp, 72			; 00000048H
  00fe6	53		 push	 ebx
  00fe7	56		 push	 esi
  00fe8	57		 push	 edi
  00fe9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 442  : 	if ( this->m_bHasInfo == 0 )

  00fec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fef	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00ff3	75 04		 jne	 SHORT $LN3@MoveHerd

; 443  : 	{
; 444  : 		return FALSE;

  00ff5	33 c0		 xor	 eax, eax
  00ff7	eb 5c		 jmp	 SHORT $LN4@MoveHerd
$LN3@MoveHerd:

; 445  : 	}
; 446  : 
; 447  : 	BYTE btMapAttr = MapC[this->m_iMapNumber].GetAttr(iTX, iTY);

  00ff9	0f b6 45 0c	 movzx	 eax, BYTE PTR _iTY$[ebp]
  00ffd	50		 push	 eax
  00ffe	0f b6 4d 08	 movzx	 ecx, BYTE PTR _iTX$[ebp]
  01002	51		 push	 ecx
  01003	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01006	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  01009	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0100f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  01015	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0101a	88 45 fb	 mov	 BYTE PTR _btMapAttr$[ebp], al

; 448  : 
; 449  : 	if ( (btMapAttr&1) == 1 || (btMapAttr&4) == 4 || (btMapAttr&8) == 8 )

  0101d	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  01021	83 e0 01	 and	 eax, 1
  01024	75 12		 jne	 SHORT $LN1@MoveHerd
  01026	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  0102a	83 e0 04	 and	 eax, 4
  0102d	75 09		 jne	 SHORT $LN1@MoveHerd
  0102f	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  01033	83 e0 08	 and	 eax, 8
  01036	74 04		 je	 SHORT $LN2@MoveHerd
$LN1@MoveHerd:

; 450  : 	{
; 451  : 		return FALSE;

  01038	33 c0		 xor	 eax, eax
  0103a	eb 19		 jmp	 SHORT $LN4@MoveHerd
$LN2@MoveHerd:

; 452  : 	}
; 453  : 
; 454  : 	this->m_iCUR_X = iTX;

  0103c	0f b6 45 08	 movzx	 eax, BYTE PTR _iTX$[ebp]
  01040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01043	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 455  : 	this->m_iCUR_Y = iTY;

  01046	0f b6 45 0c	 movzx	 eax, BYTE PTR _iTY$[ebp]
  0104a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0104d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 456  : 
; 457  : 	return TRUE;

  01050	b8 01 00 00 00	 mov	 eax, 1
$LN4@MoveHerd:

; 458  : }

  01055	5f		 pop	 edi
  01056	5e		 pop	 esi
  01057	5b		 pop	 ebx
  01058	8b e5		 mov	 esp, ebp
  0105a	5d		 pop	 ebp
  0105b	c2 08 00	 ret	 8
?MoveHerd@MonsterHerd@@UAEHEE@Z ENDP			; MonsterHerd::MoveHerd
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterHerdItemDrop@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z PROC ; MonsterHerd::MonsterHerdItemDrop
; _this$ = ecx

; 461  : {

  01060	55		 push	 ebp
  01061	8b ec		 mov	 ebp, esp
  01063	83 ec 44	 sub	 esp, 68			; 00000044H
  01066	53		 push	 ebx
  01067	56		 push	 esi
  01068	57		 push	 edi
  01069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 462  : 	return FALSE;

  0106c	33 c0		 xor	 eax, eax

; 463  : }

  0106e	5f		 pop	 edi
  0106f	5e		 pop	 esi
  01070	5b		 pop	 ebx
  01071	8b e5		 mov	 esp, ebp
  01073	5d		 pop	 ebp
  01074	c2 04 00	 ret	 4
?MonsterHerdItemDrop@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ENDP ; MonsterHerd::MonsterHerdItemDrop
_TEXT	ENDS
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_ret$229201 = -16					; size = 4
_tpy$ = -10						; size = 1
_tpx$ = -9						; size = 1
_searchc$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z PROC ; MonsterHerd::MonsterMoveAction
; _this$ = ecx

; 466  : {

  01080	55		 push	 ebp
  01081	8b ec		 mov	 ebp, esp
  01083	83 ec 50	 sub	 esp, 80			; 00000050H
  01086	53		 push	 ebx
  01087	56		 push	 esi
  01088	57		 push	 edi
  01089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 467  : 	if( gObjSearchActiveEffect(lpObj, AT_ICE_ARROW) == 1)

  0108c	6a 39		 push	 57			; 00000039H
  0108e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01091	50		 push	 eax
  01092	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  01097	83 c4 08	 add	 esp, 8
  0109a	0f b6 c8	 movzx	 ecx, al
  0109d	83 f9 01	 cmp	 ecx, 1
  010a0	75 05		 jne	 SHORT $LN7@MonsterMov

; 468  : 	{
; 469  : 		return;

  010a2	e9 ec 00 00 00	 jmp	 $LN8@MonsterMov
$LN7@MonsterMov:

; 470  : 	}
; 471  : 
; 472  : 	if ( lpObj == NULL )

  010a7	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  010ab	75 05		 jne	 SHORT $LN6@MonsterMov

; 473  : 	{
; 474  : 		return;

  010ad	e9 e1 00 00 00	 jmp	 $LN8@MonsterMov
$LN6@MonsterMov:

; 475  : 	}
; 476  : 
; 477  : 	if ( lpObj->Connected < PLAYER_PLAYING || lpObj->Type != OBJ_MONSTER )

  010b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010b5	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  010b9	7c 0c		 jl	 SHORT $LN4@MonsterMov
  010bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010be	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  010c2	83 f9 02	 cmp	 ecx, 2
  010c5	74 05		 je	 SHORT $LN5@MonsterMov
$LN4@MonsterMov:

; 478  : 	{
; 479  : 		return;

  010c7	e9 c7 00 00 00	 jmp	 $LN8@MonsterMov
$LN5@MonsterMov:

; 480  : 	}
; 481  : 
; 482  : 	int searchc = 10;

  010cc	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _searchc$[ebp], 10 ; 0000000aH

; 483  : 	BYTE tpx;
; 484  : 	BYTE tpy;
; 485  : 
; 486  : 	lpObj->NextActionTime = 1000;

  010d3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010d6	c7 80 bc 03 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+956], 1000 ; 000003e8H
$LN3@MonsterMov:

; 487  : 
; 488  : 	while ( searchc-- != 0 )

  010e0	8b 45 f8	 mov	 eax, DWORD PTR _searchc$[ebp]
  010e3	8b 4d f8	 mov	 ecx, DWORD PTR _searchc$[ebp]
  010e6	83 e9 01	 sub	 ecx, 1
  010e9	89 4d f8	 mov	 DWORD PTR _searchc$[ebp], ecx
  010ec	85 c0		 test	 eax, eax
  010ee	0f 84 9f 00 00
	00		 je	 $LN8@MonsterMov

; 489  : 	{
; 490  : 		BOOL ret = this->GetRandomLocation(tpx, tpy);

  010f4	8d 45 f6	 lea	 eax, DWORD PTR _tpy$[ebp]
  010f7	50		 push	 eax
  010f8	8d 4d f7	 lea	 ecx, DWORD PTR _tpx$[ebp]
  010fb	51		 push	 ecx
  010fc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  010ff	8b 02		 mov	 eax, DWORD PTR [edx]
  01101	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01104	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  01107	ff d2		 call	 edx
  01109	89 45 f0	 mov	 DWORD PTR _ret$229201[ebp], eax

; 491  : 
; 492  : 		if ( ret != FALSE )

  0110c	83 7d f0 00	 cmp	 DWORD PTR _ret$229201[ebp], 0
  01110	74 7c		 je	 SHORT $LN1@MonsterMov

; 493  : 		{
; 494  : 			lpObj->TargetNumber = -1;

  01112	83 c8 ff	 or	 eax, -1
  01115	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01118	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 495  : 			lpObj->m_ActState.Attack = 0;

  0111f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01122	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01128	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0112b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0112e	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 496  : 			lpObj->NextActionTime = 500;

  01134	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01137	c7 80 bc 03 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+956], 500 ; 000001f4H

; 497  : 			lpObj->m_ActState.Emotion = 0;

  01141	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01144	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0114a	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  01150	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01153	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 498  : 			lpObj->MTX = tpx;

  01159	66 0f b6 45 f7	 movzx	 ax, BYTE PTR _tpx$[ebp]
  0115e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01161	66 89 81 80 01
	00 00		 mov	 WORD PTR [ecx+384], ax

; 499  : 			lpObj->MTY = tpy;

  01168	66 0f b6 45 f6	 movzx	 ax, BYTE PTR _tpy$[ebp]
  0116d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01170	66 89 81 82 01
	00 00		 mov	 WORD PTR [ecx+386], ax

; 500  : 			lpObj->m_ActState.Move = 1;

  01177	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0117a	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01180	83 c9 04	 or	 ecx, 4
  01183	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01186	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 501  : 
; 502  : 			break;

  0118c	eb 05		 jmp	 SHORT $LN8@MonsterMov
$LN1@MonsterMov:

; 503  : 		}
; 504  : 	}

  0118e	e9 4d ff ff ff	 jmp	 $LN3@MonsterMov
$LN8@MonsterMov:

; 505  : }

  01193	5f		 pop	 edi
  01194	5e		 pop	 esi
  01195	5b		 pop	 ebx
  01196	8b e5		 mov	 esp, ebp
  01198	5d		 pop	 ebp
  01199	c2 04 00	 ret	 4
?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z ENDP ; MonsterHerd::MonsterMoveAction
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?MonsterAttackAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z PROC ; MonsterHerd::MonsterAttackAction
; _this$ = ecx

; 508  : {

  011a0	55		 push	 ebp
  011a1	8b ec		 mov	 ebp, esp
  011a3	83 ec 44	 sub	 esp, 68			; 00000044H
  011a6	53		 push	 ebx
  011a7	56		 push	 esi
  011a8	57		 push	 edi
  011a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 509  : 	if( gObjSearchActiveEffect(lpObj, AT_ICE_ARROW) == 1)

  011ac	6a 39		 push	 57			; 00000039H
  011ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011b1	50		 push	 eax
  011b2	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  011b7	83 c4 08	 add	 esp, 8

; 510  : 	{
; 511  : 		return;
; 512  : 	}
; 513  : }

  011ba	5f		 pop	 edi
  011bb	5e		 pop	 esi
  011bc	5b		 pop	 ebx
  011bd	8b e5		 mov	 esp, ebp
  011bf	5d		 pop	 ebp
  011c0	c2 08 00	 ret	 8
?MonsterAttackAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z ENDP ; MonsterHerd::MonsterAttackAction
_TEXT	ENDS
EXTRN	?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterGetTargetPos
EXTRN	?GetPathPacketDirPos@@YAEHH@Z:PROC		; GetPathPacketDirPos
EXTRN	?CheckWall@MapClass@@QAEHHHHH@Z:PROC		; MapClass::CheckWall
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z:PROC ; gObjMonsterSearchEnemy
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv257 = -100						; size = 4
tv79 = -100						; size = 4
_attr$229241 = -29					; size = 1
_map$229239 = -28					; size = 4
_tuser$229238 = -24					; size = 4
_attackRange$229234 = -20				; size = 4
_dis$229233 = -16					; size = 4
_actcode1$229222 = -12					; size = 4
_lpTargetObj$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z PROC ; MonsterHerd::MonsterBaseAct
; _this$ = ecx

; 516  : {

  011d0	55		 push	 ebp
  011d1	8b ec		 mov	 ebp, esp
  011d3	83 ec 64	 sub	 esp, 100		; 00000064H
  011d6	53		 push	 ebx
  011d7	56		 push	 esi
  011d8	57		 push	 edi
  011d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 517  : 	LPOBJ lpTargetObj = NULL;

  011dc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lpTargetObj$[ebp], 0

; 518  : 
; 519  : 	if ( lpObj->TargetNumber >= 0 )

  011e3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011e6	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  011ed	85 c9		 test	 ecx, ecx
  011ef	7c 1b		 jl	 SHORT $LN30@MonsterBas

; 520  : 	{
; 521  : 		lpTargetObj = &gObj[lpObj->TargetNumber];

  011f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011f4	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  011fb	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01201	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01207	89 4d f8	 mov	 DWORD PTR _lpTargetObj$[ebp], ecx

; 522  : 	}
; 523  : 	else

  0120a	eb 18		 jmp	 SHORT $LN29@MonsterBas
$LN30@MonsterBas:

; 524  : 	{
; 525  : 		lpObj->m_ActState.Emotion = 0;

  0120c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0120f	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01215	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0121b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0121e	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN29@MonsterBas:

; 526  : 	}
; 527  : 
; 528  : 	switch ( lpObj->m_ActState.Emotion )

  01224	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01227	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0122d	c1 e9 04	 shr	 ecx, 4
  01230	83 e1 0f	 and	 ecx, 15			; 0000000fH
  01233	89 4d 9c	 mov	 DWORD PTR tv79[ebp], ecx
  01236	74 19		 je	 SHORT $LN26@MonsterBas
  01238	83 7d 9c 01	 cmp	 DWORD PTR tv79[ebp], 1
  0123c	0f 84 30 01 00
	00		 je	 $LN18@MonsterBas
  01242	83 7d 9c 03	 cmp	 DWORD PTR tv79[ebp], 3
  01246	0f 84 21 05 00
	00		 je	 $LN3@MonsterBas
  0124c	e9 b8 05 00 00	 jmp	 $LN31@MonsterBas
$LN26@MonsterBas:

; 529  : 	{
; 530  : 		case 0:
; 531  : 			{
; 532  : 				if ( lpObj->m_ActState.Attack != 0 )

  01251	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01254	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0125a	d1 e9		 shr	 ecx, 1
  0125c	83 e1 01	 and	 ecx, 1
  0125f	74 2f		 je	 SHORT $LN25@MonsterBas

; 533  : 				{
; 534  : 					lpObj->m_ActState.Attack = 0;

  01261	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01264	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0126a	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0126d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01270	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 535  : 					lpObj->TargetNumber = -1;

  01276	83 c8 ff	 or	 eax, -1
  01279	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0127c	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 536  : 					lpObj->NextActionTime = 500;

  01283	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01286	c7 80 bc 03 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+956], 500 ; 000001f4H
$LN25@MonsterBas:

; 537  : 				}
; 538  : 
; 539  : 				int actcode1 = rand() % 2;

  01290	e8 00 00 00 00	 call	 _rand
  01295	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0129a	79 05		 jns	 SHORT $LN33@MonsterBas
  0129c	48		 dec	 eax
  0129d	83 c8 fe	 or	 eax, -2			; fffffffeH
  012a0	40		 inc	 eax
$LN33@MonsterBas:
  012a1	89 45 f4	 mov	 DWORD PTR _actcode1$229222[ebp], eax

; 540  : 
; 541  : 				if ( actcode1 == 0 )

  012a4	83 7d f4 00	 cmp	 DWORD PTR _actcode1$229222[ebp], 0
  012a8	75 24		 jne	 SHORT $LN24@MonsterBas

; 542  : 				{
; 543  : 					lpObj->m_ActState.Rest = 1;

  012aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012ad	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  012b3	83 c9 01	 or	 ecx, 1
  012b6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012b9	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 544  : 					lpObj->NextActionTime = 500;

  012bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012c2	c7 80 bc 03 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+956], 500 ; 000001f4H
  012cc	eb 34		 jmp	 SHORT $LN23@MonsterBas
$LN24@MonsterBas:

; 545  : 				}
; 546  : 				else if ( lpObj->m_MoveRange > 0 )

  012ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012d1	0f bf 88 ae 04
	00 00		 movsx	 ecx, WORD PTR [eax+1198]
  012d8	85 c9		 test	 ecx, ecx
  012da	7e 26		 jle	 SHORT $LN23@MonsterBas

; 547  : 				{
; 548  : 					if( gObjSearchActiveEffect(lpObj, AT_ICE_ARROW) == 0)

  012dc	6a 39		 push	 57			; 00000039H
  012de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012e1	50		 push	 eax
  012e2	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  012e7	83 c4 08	 add	 esp, 8
  012ea	0f b6 c8	 movzx	 ecx, al
  012ed	85 c9		 test	 ecx, ecx
  012ef	75 11		 jne	 SHORT $LN23@MonsterBas

; 549  : 					{
; 550  : 						this->MonsterMoveAction(lpObj);

  012f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012f4	50		 push	 eax
  012f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  012fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012fd	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  01300	ff d0		 call	 eax
$LN23@MonsterBas:

; 551  : 					}
; 552  : 				}
; 553  : 
; 554  : 				if ( lpObj->m_bIsMonsterAttackFirst != false )

  01302	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01305	83 b8 ec 10 00
	00 00		 cmp	 DWORD PTR [eax+4332], 0
  0130c	74 5f		 je	 SHORT $LN20@MonsterBas

; 555  : 				{
; 556  : 					lpObj->TargetNumber = gObjMonsterSearchEnemy(lpObj, OBJ_USER);

  0130e	6a 01		 push	 1
  01310	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01313	50		 push	 eax
  01314	e8 00 00 00 00	 call	 ?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z ; gObjMonsterSearchEnemy
  01319	83 c4 08	 add	 esp, 8
  0131c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0131f	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 557  : 
; 558  : 					if ( lpObj->TargetNumber >= 0 )

  01326	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01329	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  01330	85 c9		 test	 ecx, ecx
  01332	7c 39		 jl	 SHORT $LN20@MonsterBas

; 559  : 					{
; 560  : 						lpObj->m_ActState.EmotionCount = 30;

  01334	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01337	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0133d	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  01343	81 c9 00 1e 00
	00		 or	 ecx, 7680		; 00001e00H
  01349	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0134c	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 561  : 						lpObj->m_ActState.Emotion = 1;

  01352	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01355	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0135b	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  01361	83 c9 10	 or	 ecx, 16			; 00000010H
  01364	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01367	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN20@MonsterBas:

; 562  : 					}
; 563  : 				}
; 564  : 			}
; 565  : 			break;

  0136d	e9 97 04 00 00	 jmp	 $LN31@MonsterBas
$LN18@MonsterBas:

; 566  : 
; 567  : 		case 1:
; 568  : 
; 569  : 			if ( lpObj->m_ActState.EmotionCount > 0 )

  01372	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01375	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0137b	c1 e9 08	 shr	 ecx, 8
  0137e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01384	76 39		 jbe	 SHORT $LN17@MonsterBas

; 570  : 			{
; 571  : 				lpObj->m_ActState.EmotionCount --;

  01386	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01389	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0138f	c1 e9 08	 shr	 ecx, 8
  01392	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01398	83 e9 01	 sub	 ecx, 1
  0139b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  013a1	c1 e1 08	 shl	 ecx, 8
  013a4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  013a7	8b 82 18 02 00
	00		 mov	 eax, DWORD PTR [edx+536]
  013ad	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  013b2	0b c1		 or	 eax, ecx
  013b4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013b7	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 572  : 			}
; 573  : 			else

  013bd	eb 18		 jmp	 SHORT $LN16@MonsterBas
$LN17@MonsterBas:

; 574  : 			{
; 575  : 				lpObj->m_ActState.Emotion = 0;

  013bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013c2	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  013c8	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  013ce	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  013d1	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN16@MonsterBas:

; 576  : 			}
; 577  : 
; 578  : 			if ( lpObj->TargetNumber >= 0 && lpObj->PathStartEnd == 0 )

  013d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013da	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  013e1	85 c9		 test	 ecx, ecx
  013e3	0f 8c 7f 03 00
	00		 jl	 $LN15@MonsterBas
  013e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013ec	0f be 88 8c 01
	00 00		 movsx	 ecx, BYTE PTR [eax+396]
  013f3	85 c9		 test	 ecx, ecx
  013f5	0f 85 6d 03 00
	00		 jne	 $LN15@MonsterBas

; 579  : 			{
; 580  : 				int dis = gObjCalDistance(lpObj, lpTargetObj);

  013fb	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  013fe	50		 push	 eax
  013ff	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01402	51		 push	 ecx
  01403	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  01408	83 c4 08	 add	 esp, 8
  0140b	89 45 f0	 mov	 DWORD PTR _dis$229233[ebp], eax

; 581  : 				int attackRange;
; 582  : 
; 583  : 				if ( lpObj->m_AttackType >= 100 )

  0140e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01411	0f bf 88 b2 04
	00 00		 movsx	 ecx, WORD PTR [eax+1202]
  01418	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0141b	7c 12		 jl	 SHORT $LN14@MonsterBas

; 584  : 				{
; 585  : 					attackRange = lpObj->m_AttackRange + 2;

  0141d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01420	0f bf 88 b0 04
	00 00		 movsx	 ecx, WORD PTR [eax+1200]
  01427	83 c1 02	 add	 ecx, 2
  0142a	89 4d ec	 mov	 DWORD PTR _attackRange$229234[ebp], ecx

; 586  : 				}
; 587  : 				else

  0142d	eb 0d		 jmp	 SHORT $LN13@MonsterBas
$LN14@MonsterBas:

; 588  : 				{
; 589  : 					attackRange = lpObj->m_AttackRange;

  0142f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01432	0f bf 88 b0 04
	00 00		 movsx	 ecx, WORD PTR [eax+1200]
  01439	89 4d ec	 mov	 DWORD PTR _attackRange$229234[ebp], ecx
$LN13@MonsterBas:

; 590  : 				}
; 591  : 
; 592  : 				if ( dis <= attackRange )

  0143c	8b 45 f0	 mov	 eax, DWORD PTR _dis$229233[ebp]
  0143f	3b 45 ec	 cmp	 eax, DWORD PTR _attackRange$229234[ebp]
  01442	0f 8f c6 01 00
	00		 jg	 $LN12@MonsterBas

; 593  : 				{
; 594  : 					int tuser = lpObj->TargetNumber;

  01448	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0144b	0f bf 88 58 04
	00 00		 movsx	 ecx, WORD PTR [eax+1112]
  01452	89 4d e8	 mov	 DWORD PTR _tuser$229238[ebp], ecx

; 595  : 					int map = gObj[tuser].MapNumber;

  01455	8b 45 e8	 mov	 eax, DWORD PTR _tuser$229238[ebp]
  01458	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0145e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01464	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0146c	89 55 e4	 mov	 DWORD PTR _map$229239[ebp], edx

; 596  : 
; 597  : 					if ( MapC[map].CheckWall(lpObj->X, lpObj->Y, gObj[tuser].X, gObj[tuser].Y) == TRUE )

  0146f	8b 45 e8	 mov	 eax, DWORD PTR _tuser$229238[ebp]
  01472	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01478	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0147e	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  01486	52		 push	 edx
  01487	8b 45 e8	 mov	 eax, DWORD PTR _tuser$229238[ebp]
  0148a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01490	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01496	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  0149e	52		 push	 edx
  0149f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014a2	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  014a9	51		 push	 ecx
  014aa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014ad	0f bf 82 44 01
	00 00		 movsx	 eax, WORD PTR [edx+324]
  014b4	50		 push	 eax
  014b5	8b 4d e4	 mov	 ecx, DWORD PTR _map$229239[ebp]
  014b8	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  014be	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  014c4	e8 00 00 00 00	 call	 ?CheckWall@MapClass@@QAEHHHHH@Z ; MapClass::CheckWall
  014c9	83 f8 01	 cmp	 eax, 1
  014cc	0f 85 37 01 00
	00		 jne	 $LN11@MonsterBas

; 598  : 					{
; 599  : 						BYTE attr = MapC[map].GetAttr(gObj[tuser].X, gObj[tuser].Y);

  014d2	8b 45 e8	 mov	 eax, DWORD PTR _tuser$229238[ebp]
  014d5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  014db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014e1	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  014e9	52		 push	 edx
  014ea	8b 45 e8	 mov	 eax, DWORD PTR _tuser$229238[ebp]
  014ed	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  014f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014f9	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  01501	52		 push	 edx
  01502	8b 4d e4	 mov	 ecx, DWORD PTR _map$229239[ebp]
  01505	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0150b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  01511	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  01516	88 45 e3	 mov	 BYTE PTR _attr$229241[ebp], al

; 600  : 
; 601  : 						if ( (attr&1) != 1 )

  01519	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$229241[ebp]
  0151d	83 e0 01	 and	 eax, 1
  01520	75 50		 jne	 SHORT $LN10@MonsterBas

; 602  : 						{
; 603  : 							lpObj->m_ActState.Attack = 1;

  01522	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01525	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0152b	83 c9 02	 or	 ecx, 2
  0152e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01531	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 604  : 							lpObj->m_ActState.EmotionCount = (rand()%30+20);

  01537	e8 00 00 00 00	 call	 _rand
  0153c	89 45 9c	 mov	 DWORD PTR tv257[ebp], eax
  0153f	8b 45 9c	 mov	 eax, DWORD PTR tv257[ebp]
  01542	99		 cdq
  01543	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  01548	f7 f9		 idiv	 ecx
  0154a	83 c2 14	 add	 edx, 20			; 00000014H
  0154d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01553	c1 e2 08	 shl	 edx, 8
  01556	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01559	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0155f	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  01565	0b ca		 or	 ecx, edx
  01567	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0156a	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 605  : 						}
; 606  : 						else

  01570	eb 46		 jmp	 SHORT $LN9@MonsterBas
$LN10@MonsterBas:

; 607  : 						{
; 608  : 							lpObj->TargetNumber = -1;

  01572	83 c8 ff	 or	 eax, -1
  01575	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01578	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 609  : 							lpObj->m_ActState.EmotionCount = 30;

  0157f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01582	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01588	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  0158e	81 c9 00 1e 00
	00		 or	 ecx, 7680		; 00001e00H
  01594	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01597	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 610  : 							lpObj->m_ActState.Emotion = 1;

  0159d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015a0	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  015a6	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  015ac	83 c9 10	 or	 ecx, 16			; 00000010H
  015af	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015b2	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN9@MonsterBas:

; 611  : 						}
; 612  : 
; 613  : 						lpObj->Dir = GetPathPacketDirPos(lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y);

  015b8	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  015bb	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  015c2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015c5	0f bf 82 46 01
	00 00		 movsx	 eax, WORD PTR [edx+326]
  015cc	2b c8		 sub	 ecx, eax
  015ce	51		 push	 ecx
  015cf	8b 4d f8	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  015d2	0f bf 91 44 01
	00 00		 movsx	 edx, WORD PTR [ecx+324]
  015d9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015dc	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  015e3	2b d1		 sub	 edx, ecx
  015e5	52		 push	 edx
  015e6	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  015eb	83 c4 08	 add	 esp, 8
  015ee	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015f1	88 82 48 01 00
	00		 mov	 BYTE PTR [edx+328], al

; 614  : 						lpObj->NextActionTime = lpObj->m_AttackSpeed;

  015f7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015fa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  015fd	8b 91 8c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1164]
  01603	89 90 bc 03 00
	00		 mov	 DWORD PTR [eax+956], edx
$LN11@MonsterBas:

; 615  : 					}
; 616  : 				}
; 617  : 				else

  01609	e9 5a 01 00 00	 jmp	 $LN15@MonsterBas
$LN12@MonsterBas:

; 618  : 				{
; 619  : 					if ( gObjMonsterGetTargetPos(lpObj) == TRUE )

  0160e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01611	50		 push	 eax
  01612	e8 00 00 00 00	 call	 ?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterGetTargetPos
  01617	83 c4 04	 add	 esp, 4
  0161a	83 f8 01	 cmp	 eax, 1
  0161d	0f 85 fb 00 00
	00		 jne	 $LN7@MonsterBas

; 620  : 					{
; 621  : 						if ( MapC[lpObj->MapNumber].CheckWall(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY) == TRUE )

  01623	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01626	0f bf 88 82 01
	00 00		 movsx	 ecx, WORD PTR [eax+386]
  0162d	51		 push	 ecx
  0162e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01631	0f bf 82 80 01
	00 00		 movsx	 eax, WORD PTR [edx+384]
  01638	50		 push	 eax
  01639	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0163c	0f bf 91 46 01
	00 00		 movsx	 edx, WORD PTR [ecx+326]
  01643	52		 push	 edx
  01644	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01647	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  0164e	51		 push	 ecx
  0164f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01652	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  01659	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0165f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  01665	e8 00 00 00 00	 call	 ?CheckWall@MapClass@@QAEHHHHH@Z ; MapClass::CheckWall
  0166a	83 f8 01	 cmp	 eax, 1
  0166d	75 63		 jne	 SHORT $LN6@MonsterBas

; 622  : 						{
; 623  : 							lpObj->m_ActState.Move = 1;

  0166f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01672	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01678	83 c9 04	 or	 ecx, 4
  0167b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0167e	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 624  : 							lpObj->NextActionTime = 400;

  01684	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01687	c7 80 bc 03 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+956], 400 ; 00000190H

; 625  : 							lpObj->Dir = GetPathPacketDirPos(lpTargetObj->X - lpObj->X, lpTargetObj->Y-lpObj->Y);

  01691	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01694	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  0169b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0169e	0f bf 82 46 01
	00 00		 movsx	 eax, WORD PTR [edx+326]
  016a5	2b c8		 sub	 ecx, eax
  016a7	51		 push	 ecx
  016a8	8b 4d f8	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  016ab	0f bf 91 44 01
	00 00		 movsx	 edx, WORD PTR [ecx+324]
  016b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016b5	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  016bc	2b d1		 sub	 edx, ecx
  016be	52		 push	 edx
  016bf	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  016c4	83 c4 08	 add	 esp, 8
  016c7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016ca	88 82 48 01 00
	00		 mov	 BYTE PTR [edx+328], al

; 626  : 						}
; 627  : 						else

  016d0	eb 4a		 jmp	 SHORT $LN5@MonsterBas
$LN6@MonsterBas:

; 628  : 						{
; 629  : 							this->MonsterMoveAction(lpObj);

  016d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016d5	50		 push	 eax
  016d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  016db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016de	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  016e1	ff d0		 call	 eax

; 630  : 							lpObj->m_ActState.Emotion = 3;

  016e3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016e6	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  016ec	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  016f2	83 c9 30	 or	 ecx, 48			; 00000030H
  016f5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016f8	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 631  : 							lpObj->m_ActState.EmotionCount = 10;

  016fe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01701	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01707	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  0170d	81 c9 00 0a 00
	00		 or	 ecx, 2560		; 00000a00H
  01713	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01716	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN5@MonsterBas:

; 632  : 						}
; 633  : 					}
; 634  : 					else

  0171c	eb 4a		 jmp	 SHORT $LN15@MonsterBas
$LN7@MonsterBas:

; 635  : 					{
; 636  : 						this->MonsterMoveAction(lpObj);

  0171e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01721	50		 push	 eax
  01722	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01725	8b 11		 mov	 edx, DWORD PTR [ecx]
  01727	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0172a	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0172d	ff d0		 call	 eax

; 637  : 						lpObj->m_ActState.Emotion = 3;

  0172f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01732	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01738	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0173e	83 c9 30	 or	 ecx, 48			; 00000030H
  01741	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01744	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 638  : 						lpObj->m_ActState.EmotionCount = 10;

  0174a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0174d	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01753	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  01759	81 c9 00 0a 00
	00		 or	 ecx, 2560		; 00000a00H
  0175f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01762	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN15@MonsterBas:

; 639  : 					}
; 640  : 				}
; 641  : 			}
; 642  : 
; 643  : 			break;

  01768	e9 9c 00 00 00	 jmp	 $LN31@MonsterBas
$LN3@MonsterBas:

; 644  : 
; 645  : 		case 3:
; 646  : 
; 647  : 			if ( lpObj->m_ActState.EmotionCount > 0 )

  0176d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01770	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01776	c1 e9 08	 shr	 ecx, 8
  01779	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0177f	76 39		 jbe	 SHORT $LN2@MonsterBas

; 648  : 			{
; 649  : 				lpObj->m_ActState.EmotionCount--;

  01781	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01784	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  0178a	c1 e9 08	 shr	 ecx, 8
  0178d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01793	83 e9 01	 sub	 ecx, 1
  01796	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0179c	c1 e1 08	 shl	 ecx, 8
  0179f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017a2	8b 82 18 02 00
	00		 mov	 eax, DWORD PTR [edx+536]
  017a8	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  017ad	0b c1		 or	 eax, ecx
  017af	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  017b2	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 650  : 			}
; 651  : 			else

  017b8	eb 18		 jmp	 SHORT $LN1@MonsterBas
$LN2@MonsterBas:

; 652  : 			{
; 653  : 				lpObj->m_ActState.Emotion = 0;

  017ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017bd	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  017c3	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  017c9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017cc	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN1@MonsterBas:

; 654  : 			}
; 655  : 
; 656  : 			lpObj->m_ActState.Move = 0;

  017d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017d5	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  017db	83 e1 fb	 and	 ecx, -5			; fffffffbH
  017de	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017e1	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 657  : 			lpObj->m_ActState.Attack = 0;

  017e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017ea	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  017f0	83 e1 fd	 and	 ecx, -3			; fffffffdH
  017f3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017f6	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 658  : 			lpObj->NextActionTime = 400;

  017fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017ff	c7 80 bc 03 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+956], 400 ; 00000190H
$LN31@MonsterBas:

; 659  : 
; 660  : 			break;
; 661  : 	}
; 662  : }

  01809	5f		 pop	 edi
  0180a	5e		 pop	 esi
  0180b	5b		 pop	 ebx
  0180c	8b e5		 mov	 esp, ebp
  0180e	5d		 pop	 ebp
  0180f	c2 04 00	 ret	 4
?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z ENDP ; MonsterHerd::MonsterBaseAct
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z PROC ; MonsterHerd::MonsterDieAction
; _this$ = ecx

; 665  : {

  01820	55		 push	 ebp
  01821	8b ec		 mov	 ebp, esp
  01823	83 ec 44	 sub	 esp, 68			; 00000044H
  01826	53		 push	 ebx
  01827	56		 push	 esi
  01828	57		 push	 edi
  01829	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 666  : 	return;
; 667  : }

  0182c	5f		 pop	 edi
  0182d	5e		 pop	 esi
  0182e	5b		 pop	 ebx
  0182f	8b e5		 mov	 esp, ebp
  01831	5d		 pop	 ebp
  01832	c2 04 00	 ret	 4
?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z ENDP ; MonsterHerd::MonsterDieAction
_TEXT	ENDS
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageInit
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjViewportClose
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjTimeCheckSelfDefense
EXTRN	?gObjClearStandardBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjClearStandardBuffEffect
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_bGetPosition$ = -28					; size = 4
_iCount$ = -24						; size = 4
_cY$ = -18						; size = 1
_cX$ = -17						; size = 1
_i$229269 = -16						; size = 4
_lpMHD$ = -12						; size = 4
_lpMH$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z PROC ; MonsterHerd::MonsterRegenAction
; _this$ = ecx

; 670  : {

  01840	55		 push	 ebp
  01841	8b ec		 mov	 ebp, esp
  01843	83 ec 5c	 sub	 esp, 92			; 0000005cH
  01846	53		 push	 ebx
  01847	56		 push	 esi
  01848	57		 push	 edi
  01849	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 671  : 	if ( lpObj == NULL )

  0184c	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  01850	75 07		 jne	 SHORT $LN13@MonsterReg

; 672  : 	{
; 673  : 		return FALSE;

  01852	33 c0		 xor	 eax, eax
  01854	e9 2f 03 00 00	 jmp	 $LN14@MonsterReg
$LN13@MonsterReg:

; 674  : 	}
; 675  : 
; 676  : 	if ( lpObj->Connected < PLAYER_PLAYING || lpObj->Type != OBJ_MONSTER )

  01859	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0185c	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  01860	7c 0c		 jl	 SHORT $LN11@MonsterReg
  01862	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01865	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  01869	83 f9 02	 cmp	 ecx, 2
  0186c	74 07		 je	 SHORT $LN12@MonsterReg
$LN11@MonsterReg:

; 677  : 	{
; 678  : 		return FALSE;

  0186e	33 c0		 xor	 eax, eax
  01870	e9 13 03 00 00	 jmp	 $LN14@MonsterReg
$LN12@MonsterReg:

; 679  : 	}
; 680  : 
; 681  : 	MonsterHerd * lpMH = (MonsterHerd *)lpObj->m_lpMonsterHerd;

  01875	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01878	8b 88 f0 10 00
	00		 mov	 ecx, DWORD PTR [eax+4336]
  0187e	89 4d f8	 mov	 DWORD PTR _lpMH$[ebp], ecx

; 682  : 
; 683  : 	if ( lpMH == NULL )

  01881	83 7d f8 00	 cmp	 DWORD PTR _lpMH$[ebp], 0
  01885	75 07		 jne	 SHORT $LN10@MonsterReg

; 684  : 	{
; 685  : 		return FALSE;

  01887	33 c0		 xor	 eax, eax
  01889	e9 fa 02 00 00	 jmp	 $LN14@MonsterReg
$LN10@MonsterReg:

; 686  : 	}
; 687  : 
; 688  : 	_MONSTER_HERD_DATA * lpMHD = lpMH->GetMonsterData(lpObj->m_Index);

  0188e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01891	8b 08		 mov	 ecx, DWORD PTR [eax]
  01893	51		 push	 ecx
  01894	8b 55 f8	 mov	 edx, DWORD PTR _lpMH$[ebp]
  01897	8b 02		 mov	 eax, DWORD PTR [edx]
  01899	8b 4d f8	 mov	 ecx, DWORD PTR _lpMH$[ebp]
  0189c	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0189f	ff d2		 call	 edx
  018a1	89 45 f4	 mov	 DWORD PTR _lpMHD$[ebp], eax

; 689  : 
; 690  : 	if ( lpMHD == NULL || lpMHD->m_bRegen == FALSE )

  018a4	83 7d f4 00	 cmp	 DWORD PTR _lpMHD$[ebp], 0
  018a8	74 09		 je	 SHORT $LN8@MonsterReg
  018aa	8b 45 f4	 mov	 eax, DWORD PTR _lpMHD$[ebp]
  018ad	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  018b1	75 07		 jne	 SHORT $LN9@MonsterReg
$LN8@MonsterReg:

; 691  : 	{
; 692  : 		return FALSE;

  018b3	33 c0		 xor	 eax, eax
  018b5	e9 ce 02 00 00	 jmp	 $LN14@MonsterReg
$LN9@MonsterReg:

; 693  : 	}
; 694  : 
; 695  : 	lpObj->Life = lpObj->AddLife + lpObj->MaxLife;

  018ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018bd	db 80 4c 01 00
	00		 fild	 DWORD PTR [eax+332]
  018c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  018c6	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  018cc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  018cf	d9 9a fc 00 00
	00		 fstp	 DWORD PTR [edx+252]

; 696  : 	lpObj->Mana = lpObj->AddMana + lpObj->MaxMana;

  018d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018d8	db 80 50 01 00
	00		 fild	 DWORD PTR [eax+336]
  018de	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  018e1	d8 81 14 01 00
	00		 fadd	 DWORD PTR [ecx+276]
  018e7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  018ea	d9 9a 10 01 00
	00		 fstp	 DWORD PTR [edx+272]

; 697  : 	lpObj->Live = TRUE;

  018f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018f3	c6 40 6a 01	 mov	 BYTE PTR [eax+106], 1

; 698  : 
; 699  : 	gObjClearStandardBuffEffect(lpObj, AT_MONSTER_GENERAL);

  018f7	6a 01		 push	 1
  018f9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018fc	50		 push	 eax
  018fd	e8 00 00 00 00	 call	 ?gObjClearStandardBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjClearStandardBuffEffect
  01902	83 c4 08	 add	 esp, 8

; 700  : 
; 701  : 	lpObj->m_ViewState = 0;

  01905	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01908	c6 80 26 02 00
	00 00		 mov	 BYTE PTR [eax+550], 0

; 702  : 	lpObj->Teleport = 0;

  0190f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01912	c6 80 a0 03 00
	00 00		 mov	 BYTE PTR [eax+928], 0

; 703  : 
; 704  : 	for ( int i=0;i<MAX_SELF_DEFENSE;i++)

  01919	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$229269[ebp], 0
  01920	eb 09		 jmp	 SHORT $LN7@MonsterReg
$LN6@MonsterReg:
  01922	8b 45 f0	 mov	 eax, DWORD PTR _i$229269[ebp]
  01925	83 c0 01	 add	 eax, 1
  01928	89 45 f0	 mov	 DWORD PTR _i$229269[ebp], eax
$LN7@MonsterReg:
  0192b	83 7d f0 07	 cmp	 DWORD PTR _i$229269[ebp], 7
  0192f	7d 13		 jge	 SHORT $LN5@MonsterReg

; 705  : 	{
; 706  : 		lpObj->SelfDefenseTime[i] = 0;

  01931	8b 45 f0	 mov	 eax, DWORD PTR _i$229269[ebp]
  01934	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01937	c7 84 81 00 04
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+1024], 0

; 707  : 	}

  01942	eb de		 jmp	 SHORT $LN6@MonsterReg
$LN5@MonsterReg:

; 708  : 
; 709  : 	gObjTimeCheckSelfDefense(lpObj);

  01944	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01947	50		 push	 eax
  01948	e8 00 00 00 00	 call	 ?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
  0194d	83 c4 04	 add	 esp, 4

; 710  : 
; 711  : 	gObjRemoveBuffEffect(lpObj, AT_POISON); //S3 Addition -> Poison

  01950	6a 37		 push	 55			; 00000037H
  01952	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01955	50		 push	 eax
  01956	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0195b	83 c4 08	 add	 esp, 8

; 712  : 	gObjRemoveBuffEffect(lpObj, AT_ICE); //S3 Addition -> Ice

  0195e	6a 38		 push	 56			; 00000038H
  01960	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01963	50		 push	 eax
  01964	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  01969	83 c4 08	 add	 esp, 8

; 713  : 
; 714  : 	gObjClearViewport(lpObj);

  0196c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0196f	50		 push	 eax
  01970	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport
  01975	83 c4 04	 add	 esp, 4

; 715  : 	gObjViewportListProtocolDestroy(lpObj);

  01978	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0197b	50		 push	 eax
  0197c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  01981	83 c4 04	 add	 esp, 4

; 716  : 	gObjViewportClose(lpObj);

  01984	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01987	50		 push	 eax
  01988	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose
  0198d	83 c4 04	 add	 esp, 4

; 717  : 
; 718  : 	lpObj->m_ActState.Attack = 0;

  01990	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01993	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01999	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0199c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0199f	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 719  : 	lpObj->m_ActState.EmotionCount = 0;

  019a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019a8	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  019ae	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  019b4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  019b7	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 720  : 	lpObj->m_ActState.Escape = 0;

  019bd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019c0	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  019c6	83 e1 f7	 and	 ecx, -9			; fffffff7H
  019c9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  019cc	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 721  : 	lpObj->m_ActState.Move = 0;

  019d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019d5	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  019db	83 e1 fb	 and	 ecx, -5			; fffffffbH
  019de	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  019e1	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 722  : 	lpObj->m_ActState.Rest = 0;

  019e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019ea	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  019f0	83 e1 fe	 and	 ecx, -2			; fffffffeH
  019f3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  019f6	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 723  : 	lpObj->m_ActState.Emotion = 0;

  019fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019ff	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  01a05	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  01a0b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01a0e	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx

; 724  : 	lpObj->TargetNumber = -1;

  01a14	83 c8 ff	 or	 eax, -1
  01a17	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01a1a	66 89 81 58 04
	00 00		 mov	 WORD PTR [ecx+1112], ax

; 725  : 	lpObj->NextActionTime = 5000;

  01a21	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a24	c7 80 bc 03 00
	00 88 13 00 00	 mov	 DWORD PTR [eax+956], 5000 ; 00001388H

; 726  : 
; 727  : 	BYTE cX;
; 728  : 	BYTE cY;
; 729  : 	int iCount = 100;

  01a2e	c7 45 e8 64 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 100 ; 00000064H

; 730  : 	BOOL bGetPosition = FALSE;

  01a35	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bGetPosition$[ebp], 0
$LN4@MonsterReg:

; 731  : 
; 732  : 	while ( iCount-- != 0 )

  01a3c	8b 45 e8	 mov	 eax, DWORD PTR _iCount$[ebp]
  01a3f	8b 4d e8	 mov	 ecx, DWORD PTR _iCount$[ebp]
  01a42	83 e9 01	 sub	 ecx, 1
  01a45	89 4d e8	 mov	 DWORD PTR _iCount$[ebp], ecx
  01a48	85 c0		 test	 eax, eax
  01a4a	74 24		 je	 SHORT $LN3@MonsterReg

; 733  : 	{
; 734  : 		if ( lpMH->GetRandomLocation(cX, cY) != FALSE )

  01a4c	8d 45 ee	 lea	 eax, DWORD PTR _cY$[ebp]
  01a4f	50		 push	 eax
  01a50	8d 4d ef	 lea	 ecx, DWORD PTR _cX$[ebp]
  01a53	51		 push	 ecx
  01a54	8b 55 f8	 mov	 edx, DWORD PTR _lpMH$[ebp]
  01a57	8b 02		 mov	 eax, DWORD PTR [edx]
  01a59	8b 4d f8	 mov	 ecx, DWORD PTR _lpMH$[ebp]
  01a5c	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  01a5f	ff d2		 call	 edx
  01a61	85 c0		 test	 eax, eax
  01a63	74 09		 je	 SHORT $LN2@MonsterReg

; 735  : 		{
; 736  : 			bGetPosition = TRUE;

  01a65	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bGetPosition$[ebp], 1

; 737  : 			break;

  01a6c	eb 02		 jmp	 SHORT $LN3@MonsterReg
$LN2@MonsterReg:

; 738  : 		}
; 739  : 	}

  01a6e	eb cc		 jmp	 SHORT $LN4@MonsterReg
$LN3@MonsterReg:

; 740  : 
; 741  : 	if ( bGetPosition == FALSE )

  01a70	83 7d e4 00	 cmp	 DWORD PTR _bGetPosition$[ebp], 0
  01a74	75 34		 jne	 SHORT $LN1@MonsterReg

; 742  : 	{
; 743  : 		lpObj->Live = FALSE;

  01a76	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a79	c6 40 6a 00	 mov	 BYTE PTR [eax+106], 0

; 744  : 		lpObj->m_State = 4;

  01a7d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a80	c7 80 20 02 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+544], 4

; 745  : 		lpObj->RegenTime = GetTickCount();

  01a8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01a90	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01a93	89 81 a8 03 00
	00		 mov	 DWORD PTR [ecx+936], eax

; 746  : 		lpObj->DieRegen = TRUE;

  01a99	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a9c	c6 80 a2 03 00
	00 01		 mov	 BYTE PTR [eax+930], 1

; 747  : 
; 748  : 		return FALSE;

  01aa3	33 c0		 xor	 eax, eax
  01aa5	e9 de 00 00 00	 jmp	 $LN14@MonsterReg
$LN1@MonsterReg:

; 749  : 	}
; 750  : 
; 751  : 	lpObj->X = cX;

  01aaa	66 0f b6 45 ef	 movzx	 ax, BYTE PTR _cX$[ebp]
  01aaf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01ab2	66 89 81 44 01
	00 00		 mov	 WORD PTR [ecx+324], ax

; 752  : 	lpObj->Y = cY;

  01ab9	66 0f b6 45 ee	 movzx	 ax, BYTE PTR _cY$[ebp]
  01abe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01ac1	66 89 81 46 01
	00 00		 mov	 WORD PTR [ecx+326], ax

; 753  : 	lpObj->MTX = lpObj->X;

  01ac8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01acb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01ace	66 8b 91 44 01
	00 00		 mov	 dx, WORD PTR [ecx+324]
  01ad5	66 89 90 80 01
	00 00		 mov	 WORD PTR [eax+384], dx

; 754  : 	lpObj->MTY = lpObj->Y;

  01adc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01adf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01ae2	66 8b 91 46 01
	00 00		 mov	 dx, WORD PTR [ecx+326]
  01ae9	66 89 90 82 01
	00 00		 mov	 WORD PTR [eax+386], dx

; 755  : 	lpObj->TX = lpObj->X;

  01af0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01af3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01af6	66 8b 91 44 01
	00 00		 mov	 dx, WORD PTR [ecx+324]
  01afd	66 89 90 7c 01
	00 00		 mov	 WORD PTR [eax+380], dx

; 756  : 	lpObj->TY = lpObj->Y;

  01b04	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b07	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b0a	66 8b 91 46 01
	00 00		 mov	 dx, WORD PTR [ecx+326]
  01b11	66 89 90 7e 01
	00 00		 mov	 WORD PTR [eax+382], dx

; 757  : 	lpObj->StartX = lpObj->X;

  01b18	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b1b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b1e	8a 91 44 01 00
	00		 mov	 dl, BYTE PTR [ecx+324]
  01b24	88 90 76 01 00
	00		 mov	 BYTE PTR [eax+374], dl

; 758  : 	lpObj->StartY = lpObj->Y;

  01b2a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b2d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b30	8a 91 46 01 00
	00		 mov	 dl, BYTE PTR [ecx+326]
  01b36	88 90 77 01 00
	00		 mov	 BYTE PTR [eax+375], dl

; 759  : 
; 760  : 	gObjMonsterHitDamageInit(lpObj);

  01b3c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b3f	50		 push	 eax
  01b40	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit
  01b45	83 c4 04	 add	 esp, 4

; 761  : 	CreateFrustrum(lpObj->X, lpObj->Y, lpObj->m_Index);

  01b48	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b4b	8b 08		 mov	 ecx, DWORD PTR [eax]
  01b4d	51		 push	 ecx
  01b4e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b51	0f bf 82 46 01
	00 00		 movsx	 eax, WORD PTR [edx+326]
  01b58	50		 push	 eax
  01b59	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b5c	0f bf 91 44 01
	00 00		 movsx	 edx, WORD PTR [ecx+324]
  01b63	52		 push	 edx
  01b64	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  01b69	83 c4 0c	 add	 esp, 12			; 0000000cH

; 762  : 
; 763  : 	lpObj->DieRegen = FALSE;

  01b6c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b6f	c6 80 a2 03 00
	00 00		 mov	 BYTE PTR [eax+930], 0

; 764  : 	lpObj->m_State = 1;

  01b76	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b79	c7 80 20 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+544], 1

; 765  : 
; 766  : 	return TRUE;

  01b83	b8 01 00 00 00	 mov	 eax, 1
$LN14@MonsterReg:

; 767  : }

  01b88	5f		 pop	 edi
  01b89	5e		 pop	 esi
  01b8a	5b		 pop	 ebx
  01b8b	8b e5		 mov	 esp, ebp
  01b8d	5d		 pop	 ebp
  01b8e	c2 04 00	 ret	 4
?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ENDP ; MonsterHerd::MonsterRegenAction
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T230271 = -70						; size = 1
$T230272 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T230271[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T230272[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >::map<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tidy
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::empty, COMDAT
; _this$ = ecx

; 878  : 		{	// return true only if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (size() == 0);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::size
  00014	f7 d8		 neg	 eax
  00016	1b c0		 sbb	 eax, eax
  00018	83 c0 01	 add	 eax, 1

; 880  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::empty
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::clear
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T230296 = -84						; size = 4
$T230297 = -80						; size = 4
$T230298 = -76						; size = 4
$T230299 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T230296[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T230297[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase
$LN2@erase:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T230298[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T230299[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase
$LN1@erase:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
tv137 = -88						; size = 4
$T230302 = -84						; size = 4
$T230303 = -80						; size = 4
$T230305 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::lower_bound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0001c	8d 45 b0	 lea	 eax, DWORD PTR $T230303[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 2d		 jne	 SHORT $LN3@find
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN3@find
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00060	89 4d a8	 mov	 DWORD PTR tv137[ebp], ecx
  00063	eb 0f		 jmp	 SHORT $LN4@find
$LN3@find:
  00065	8d 55 b4	 lea	 edx, DWORD PTR $T230305[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  00071	89 45 a8	 mov	 DWORD PTR tv137[ebp], eax
$LN4@find:
  00074	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  00077	89 45 ac	 mov	 DWORD PTR $T230302[ebp], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T230302[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00082	89 10		 mov	 DWORD PTR [eax], edx
  00084	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : 		}

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::find
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 413  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++

; 414  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 415  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator!=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		return (_Left < _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 9c c0	 setl	 al

; 126  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z
_TEXT	SEGMENT
$T230317 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T230317[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::size, COMDAT
; _this$ = ecx

; 868  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 		return (this->_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 870  : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >
PUBLIC	??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Max
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Min
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase@2

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase@2:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase@2

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase@2
$LN39@erase@2:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase@2

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase@2
$LN37@erase@2:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@2:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase@2

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase@2

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase@2:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase@2

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase@2
$LN33@erase@2:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase@2

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase@2
$LN31@erase@2:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase@2:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase@2

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase@2
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase@2
$LN43@erase@2:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase@2:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@2:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase@2

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase@2
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase@2
$LN45@erase@2:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase@2:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase@2:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase@2
$LN35@erase@2:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase@2

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase@2
$LN26@erase@2:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase@2

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase@2:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase@2:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase@2

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase@2
$LN23@erase@2:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase@2

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase@2
$LN21@erase@2:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase@2:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase@2:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase@2
  00392	eb 11		 jmp	 SHORT $LN18@erase@2
$LN17@erase@2:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@2:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase@2
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase@2

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase@2

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase@2

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@2:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase@2

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase@2
$LN13@erase@2:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase@2
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase@2

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase@2
$LN11@erase@2:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase@2

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase@2:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase@2
$LN12@erase@2:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase@2
$LN15@erase@2:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase@2

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase@2:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase@2

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase@2
$LN6@erase@2:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase@2
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase@2

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase@2
$LN4@erase@2:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase@2

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@2:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase@2
$LN8@erase@2:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase@2
$LN16@erase@2:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase@2:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase@2

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase@2:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@2:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lbound
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1451 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T230335 = -88						; size = 4
$T230336 = -84						; size = 4
$T230337 = -80						; size = 4
$T230338 = -76						; size = 4
$T230339 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T230336[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T230335[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T230338[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T230337[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T230335[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T230337[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T230339[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 405  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 406  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++

; 407  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 408  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$229488 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$229488[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase
$LN2@Erase:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229488[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229488[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229488[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229488[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$229488[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase
$LN4@Erase:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Wherenode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1742 : 		_Nodeptr _Pnode = _Root();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Wherenode$[ebp], ecx
$LN4@Lbound:

; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0002b	83 c4 04	 add	 esp, 4
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	85 c9		 test	 ecx, ecx
  00033	75 4c		 jne	 SHORT $LN3@Lbound

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 13		 je	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1748 : 			else

  00066	eb 17		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1752 : 				}

  0007f	eb a1		 jmp	 SHORT $LN4@Lbound
$LN3@Lbound:

; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1755 : 		}

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 20	 add	 eax, 32			; 00000020H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 21	 add	 eax, 33			; 00000021H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max
$LN1@Max:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min
$LN1@Min:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node><std::pair<int const ,_MONSTER_HERD_DATA> >
PUBLIC	??0?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node><std::pair<int const ,_MONSTER_HERD_DATA> >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$229590 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator
$LN6@operator:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator
$LN2@operator:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$229590[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229590[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229590[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$229590[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator
$LN1@operator:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$229590[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_MONSTER_HERD_DATA@@@?$_Pair_base@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z ; std::_Pair_base<int,_MONSTER_HERD_DATA>::_Pair_base<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$forward@AAU_MONSTER_HERD_DATA@@@std@@YAAAU_MONSTER_HERD_DATA@@AAU1@@Z ; std::forward<_MONSTER_HERD_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAU_MONSTER_HERD_DATA@@@?$pair@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_HERD_DATA@@@?$pair@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z PROC ; std::pair<int,_MONSTER_HERD_DATA>::pair<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAU_MONSTER_HERD_DATA@@@std@@YAAAU_MONSTER_HERD_DATA@@AAU1@@Z ; std::forward<_MONSTER_HERD_DATA &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAU_MONSTER_HERD_DATA@@@?$_Pair_base@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z ; std::_Pair_base<int,_MONSTER_HERD_DATA>::_Pair_base<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_HERD_DATA@@@?$pair@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z ENDP ; std::pair<int,_MONSTER_HERD_DATA>::pair<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Linsert
PUBLIC	??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode<std::pair<int,_MONSTER_HERD_DATA> >
PUBLIC	??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::insert<std::pair<int,_MONSTER_HERD_DATA> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  0000c	6a 00		 push	 0
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode<std::pair<int,_MONSTER_HERD_DATA> >
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Linsert
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??$insert@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::insert<std::pair<int,_MONSTER_HERD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00012	83 c4 04	 add	 esp, 4
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	88 11		 mov	 BYTE PTR [ecx], dl

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	88 11		 mov	 BYTE PTR [ecx], dl

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node><std::pair<int const ,_MONSTER_HERD_DATA> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node><std::pair<int const ,_MONSTER_HERD_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T230425 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 c7 71
	1c 07		 cmp	 DWORD PTR __Count$[ebp], 119304647 ; 071c71c7H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 24	 imul	 eax, 36			; 00000024H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T230425[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T230425[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Insert
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T230431 = -117						; size = 1
$T230432 = -116						; size = 4
$T230433 = -112						; size = 4
$T230434 = -105						; size = 1
$T230435 = -104						; size = 4
$T230436 = -97						; size = 1
$T230437 = -96						; size = 4
$T230438 = -89						; size = 1
__Where$229749 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert
$LN11@Linsert:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T230431[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T230431[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T230432[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert
$LN8@Linsert:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$229749[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert
$LN6@Linsert:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T230433[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$229749[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T230434[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T230434[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T230435[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert
$LN4@Linsert:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$229749[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--
$LN5@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_MONSTER_HERD_DATA@@@?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0>::_Kfn<int const ,_MONSTER_HERD_DATA>
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$229749[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T230436[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T230436[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T230437[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert
$LN2@Linsert:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T230438[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T230438[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$229749[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Destroy<std::pair<int const ,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Destroy<std::pair<int const ,_MONSTER_HERD_DATA> >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::destroy
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::max_size
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$229788 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA> >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$229788[ebp], eax
$LN10@Insert:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$229788[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$229788[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$229788[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$229788[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate
$LN5@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate
$LN6@Insert:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$229788[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$229788[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$229788[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Rrotate
$LN1@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229788[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Lrotate
$LN4@Insert:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert
$LN9@Insert:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 cc cc
	cc 0c		 mov	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$229857 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@2

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@2
$LN8@operator@2:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@2
$LN4@operator@2:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$229857[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229857[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@2
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$229857[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@2

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$229857[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@2
$LN3@operator@2:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@2

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@2
$LN2@operator@2:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$229857[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@2:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAU_MONSTER_HERD_DATA@@@std@@YAAAU_MONSTER_HERD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_MONSTER_HERD_DATA@@@std@@YAAAU_MONSTER_HERD_DATA@@AAU1@@Z PROC ; std::forward<_MONSTER_HERD_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAU_MONSTER_HERD_DATA@@@std@@YAAAU_MONSTER_HERD_DATA@@AAU1@@Z ENDP ; std::forward<_MONSTER_HERD_DATA &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAHAAU_MONSTER_HERD_DATA@@@?$_Pair_base@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_HERD_DATA@@@?$_Pair_base@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z PROC ; std::_Pair_base<int,_MONSTER_HERD_DATA>::_Pair_base<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAU_MONSTER_HERD_DATA@@@std@@YAAAU_MONSTER_HERD_DATA@@AAU1@@Z ; std::forward<_MONSTER_HERD_DATA &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 04	 add	 ecx, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00041	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00044	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 164  : 		}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_HERD_DATA@@@?$_Pair_base@HU_MONSTER_HERD_DATA@@@std@@QAE@AAHAAU_MONSTER_HERD_DATA@@@Z ENDP ; std::_Pair_base<int,_MONSTER_HERD_DATA>::_Pair_base<int,_MONSTER_HERD_DATA><int &,_MONSTER_HERD_DATA &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@U?$pair@HU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA>,std::pair<int,_MONSTER_HERD_DATA> >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode<std::pair<int,_MONSTER_HERD_DATA> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_HERD_DATA> >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@U?$pair@HU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA>,std::pair<int,_MONSTER_HERD_DATA> >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode
__catch$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode<std::pair<int,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,_MONSTER_HERD_DATA> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::construct<std::pair<int,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@U?$pair@HU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@U?$pair@HU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA>,std::pair<int,_MONSTER_HERD_DATA> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::construct<std::pair<int,_MONSTER_HERD_DATA> >

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@2@U?$pair@HU_MONSTER_HERD_DATA@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@0@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,std::pair<int const ,_MONSTER_HERD_DATA>,std::pair<int,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_HERD_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_HERD_DATA,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$?0HU_MONSTER_HERD_DATA@@@?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::pair<int const ,_MONSTER_HERD_DATA>::pair<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T230504 = -88						; size = 4
$T230505 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::construct<std::pair<int,_MONSTER_HERD_DATA> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 14		 push	 20			; 00000014H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T230505[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T230505[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_HERD_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_HERD_DATA> >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T230505[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HU_MONSTER_HERD_DATA@@@?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ; std::pair<int const ,_MONSTER_HERD_DATA>::pair<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T230504[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T230505[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@HU_MONSTER_HERD_DATA@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_HERD_DATA@@@1@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_HERD_DATA> >::construct<std::pair<int,_MONSTER_HERD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$?0HU_MONSTER_HERD_DATA@@@?$_Pair_base@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAH$$QAU_MONSTER_HERD_DATA@@@Z ; std::_Pair_base<int const ,_MONSTER_HERD_DATA>::_Pair_base<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$forward@U_MONSTER_HERD_DATA@@@std@@YA$$QAU_MONSTER_HERD_DATA@@AAU1@@Z ; std::forward<_MONSTER_HERD_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HU_MONSTER_HERD_DATA@@@?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HU_MONSTER_HERD_DATA@@@?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z PROC ; std::pair<int const ,_MONSTER_HERD_DATA>::pair<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@U_MONSTER_HERD_DATA@@@std@@YA$$QAU_MONSTER_HERD_DATA@@AAU1@@Z ; std::forward<_MONSTER_HERD_DATA>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$?0HU_MONSTER_HERD_DATA@@@?$_Pair_base@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAH$$QAU_MONSTER_HERD_DATA@@@Z ; std::_Pair_base<int const ,_MONSTER_HERD_DATA>::_Pair_base<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HU_MONSTER_HERD_DATA@@@?$pair@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAU?$pair@HU_MONSTER_HERD_DATA@@@1@@Z ENDP ; std::pair<int const ,_MONSTER_HERD_DATA>::pair<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U_MONSTER_HERD_DATA@@@std@@YA$$QAU_MONSTER_HERD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_MONSTER_HERD_DATA@@@std@@YA$$QAU_MONSTER_HERD_DATA@@AAU1@@Z PROC ; std::forward<_MONSTER_HERD_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U_MONSTER_HERD_DATA@@@std@@YA$$QAU_MONSTER_HERD_DATA@@AAU1@@Z ENDP ; std::forward<_MONSTER_HERD_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0HU_MONSTER_HERD_DATA@@@?$_Pair_base@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAH$$QAU_MONSTER_HERD_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HU_MONSTER_HERD_DATA@@@?$_Pair_base@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAH$$QAU_MONSTER_HERD_DATA@@@Z PROC ; std::_Pair_base<int const ,_MONSTER_HERD_DATA>::_Pair_base<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@U_MONSTER_HERD_DATA@@@std@@YA$$QAU_MONSTER_HERD_DATA@@AAU1@@Z ; std::forward<_MONSTER_HERD_DATA>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 04	 add	 ecx, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00041	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00044	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 164  : 		}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
??$?0HU_MONSTER_HERD_DATA@@@?$_Pair_base@$$CBHU_MONSTER_HERD_DATA@@@std@@QAE@$$QAH$$QAU_MONSTER_HERD_DATA@@@Z ENDP ; std::_Pair_base<int const ,_MONSTER_HERD_DATA>::_Pair_base<int const ,_MONSTER_HERD_DATA><int,_MONSTER_HERD_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
