; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\Smithy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >
PUBLIC	?Init@CSmithy@@QAEXXZ				; CSmithy::Init
PUBLIC	??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >
PUBLIC	??0CSmithy@@QAE@XZ				; CSmithy::CSmithy
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0CSmithy@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CSmithy@@QAE@XZ$0
__ehfuncinfo$??0CSmithy@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CSmithy@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\smithy.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CSmithy@@QAE@XZ PROC					; CSmithy::CSmithy
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CSmithy@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 18	 add	 ecx, 24			; 00000018H
  00031	e8 00 00 00 00	 call	 ??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 17   : 	this->Init();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?Init@CSmithy@@QAEXXZ	; CSmithy::Init

; 18   : }

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CSmithy@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 18	 add	 ecx, 24			; 00000018H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >
__ehhandler$??0CSmithy@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CSmithy@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CSmithy@@QAE@XZ ENDP					; CSmithy::CSmithy
PUBLIC	??1CSmithy@@QAE@XZ				; CSmithy::~CSmithy
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSmithy@@QAE@XZ PROC					; CSmithy::~CSmithy
; _this$ = ecx

; 21   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	83 ec 44	 sub	 esp, 68			; 00000044H
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 22   : }

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 18	 add	 ecx, 24			; 00000018H
  00082	e8 00 00 00 00	 call	 ??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
??1CSmithy@@QAE@XZ ENDP					; CSmithy::~CSmithy
_TEXT	ENDS
PUBLIC	?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CSmithy@@QAEXXZ PROC				; CSmithy::Init
; _this$ = ecx

; 25   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	83 ec 44	 sub	 esp, 68			; 00000044H
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 	this->itemdata.clear();

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	83 c1 18	 add	 ecx, 24			; 00000018H
  000a2	e8 00 00 00 00	 call	 ?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear

; 27   : 	this->MaxLevel = 0;

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	c6 00 00	 mov	 BYTE PTR [eax], 0

; 28   : 	this->LevelPrice = 0;

  000ad	33 c0		 xor	 eax, eax
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 29   : 	this->LuckPrice = 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 30   : 	this->AddPrice = 0;

  000bf	33 c0		 xor	 eax, eax
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 31   : 	this->Opt1Price = 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 32   : 	this->Opt2Price = 0;

  000d1	33 c0		 xor	 eax, eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 33   : 	this->Opt3Price = 0;

  000da	33 c0		 xor	 eax, eax
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 34   : 	this->Opt4Price = 0;

  000e3	33 c0		 xor	 eax, eax
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 35   : 	this->Opt5Price = 0;

  000ec	33 c0		 xor	 eax, eax
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 36   : 	this->Opt6Price = 0;

  000f5	33 c0		 xor	 eax, eax
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 37   : 	this->MaxExlOpt = 6;

  000fe	b8 06 00 00 00	 mov	 eax, 6
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 38   : }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?Init@CSmithy@@QAEXXZ ENDP				; CSmithy::Init
_TEXT	ENDS
PUBLIC	?Read@CSmithy@@QAEXPAD@Z			; CSmithy::Read
PUBLIC	??_C@_0BC@BLCIHBHF@ExData?2Smithy?4ini?$AA@	; `string'
PUBLIC	?Load@CSmithy@@QAEXXZ				; CSmithy::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0BC@BLCIHBHF@ExData?2Smithy?4ini?$AA@
CONST	SEGMENT
??_C@_0BC@BLCIHBHF@ExData?2Smithy?4ini?$AA@ DB 'ExData\Smithy.ini', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CSmithy@@QAEXXZ PROC				; CSmithy::Load
; _this$ = ecx

; 41   : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	83 ec 44	 sub	 esp, 68			; 00000044H
  00126	53		 push	 ebx
  00127	56		 push	 esi
  00128	57		 push	 edi
  00129	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	if(!g_ExLicense.user.Smithy)

  0012c	0f b6 05 dc 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+220
  00133	85 c0		 test	 eax, eax
  00135	75 02		 jne	 SHORT $LN1@Load

; 43   : 	{
; 44   : 		return;

  00137	eb 20		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 45   : 	}
; 46   : 	this->Init();

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	e8 00 00 00 00	 call	 ?Init@CSmithy@@QAEXXZ	; CSmithy::Init

; 47   : 	this->Read(gDirPath.GetNewPath("ExData\\Smithy.ini"));

  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLCIHBHF@ExData?2Smithy?4ini?$AA@
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0014b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00150	50		 push	 eax
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	e8 00 00 00 00	 call	 ?Read@CSmithy@@QAEXPAD@Z ; CSmithy::Read
$LN2@Load:

; 48   : }

  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
?Load@CSmithy@@QAEXXZ ENDP				; CSmithy::Load
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@ DB '[Smit'
	DB	'hy] %s file not found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv626 = -152						; size = 8
tv595 = -152						; size = 8
tv564 = -152						; size = 8
tv533 = -152						; size = 8
tv502 = -152						; size = 8
tv471 = -152						; size = 8
tv440 = -152						; size = 8
tv616 = -148						; size = 4
tv607 = -148						; size = 4
tv585 = -148						; size = 4
tv576 = -148						; size = 4
tv554 = -148						; size = 4
tv545 = -148						; size = 4
tv523 = -148						; size = 4
tv514 = -148						; size = 4
tv492 = -148						; size = 4
tv483 = -148						; size = 4
tv461 = -148						; size = 4
tv452 = -148						; size = 4
tv430 = -148						; size = 4
tv421 = -148						; size = 4
tv410 = -148						; size = 4
tv400 = -148						; size = 4
tv390 = -148						; size = 4
tv380 = -148						; size = 4
tv370 = -148						; size = 4
tv360 = -148						; size = 4
tv350 = -148						; size = 4
tv340 = -148						; size = 4
tv330 = -148						; size = 4
tv320 = -148						; size = 4
tv310 = -148						; size = 4
tv624 = -144						; size = 4
tv614 = -144						; size = 4
tv605 = -144						; size = 4
tv593 = -144						; size = 4
tv583 = -144						; size = 4
tv574 = -144						; size = 4
tv562 = -144						; size = 4
tv552 = -144						; size = 4
tv543 = -144						; size = 4
tv531 = -144						; size = 4
tv521 = -144						; size = 4
tv512 = -144						; size = 4
tv500 = -144						; size = 4
tv490 = -144						; size = 4
tv481 = -144						; size = 4
tv469 = -144						; size = 4
tv459 = -144						; size = 4
tv450 = -144						; size = 4
tv438 = -144						; size = 4
tv428 = -144						; size = 4
tv419 = -144						; size = 4
tv408 = -144						; size = 4
tv398 = -144						; size = 4
tv388 = -144						; size = 4
tv378 = -144						; size = 4
tv368 = -144						; size = 4
tv358 = -144						; size = 4
tv348 = -144						; size = 4
tv338 = -144						; size = 4
tv328 = -144						; size = 4
tv318 = -144						; size = 4
tv308 = -144						; size = 4
tv621 = -138						; size = 2
tv611 = -138						; size = 2
tv602 = -138						; size = 2
tv590 = -138						; size = 2
tv580 = -138						; size = 2
tv571 = -138						; size = 2
tv559 = -138						; size = 2
tv549 = -138						; size = 2
tv540 = -138						; size = 2
tv528 = -138						; size = 2
tv518 = -138						; size = 2
tv509 = -138						; size = 2
tv497 = -138						; size = 2
tv487 = -138						; size = 2
tv478 = -138						; size = 2
tv466 = -138						; size = 2
tv456 = -138						; size = 2
tv447 = -138						; size = 2
tv435 = -138						; size = 2
tv425 = -138						; size = 2
tv416 = -138						; size = 2
tv405 = -138						; size = 2
tv395 = -138						; size = 2
tv385 = -138						; size = 2
tv375 = -138						; size = 2
tv365 = -138						; size = 2
tv355 = -138						; size = 2
tv345 = -138						; size = 2
tv335 = -138						; size = 2
tv325 = -138						; size = 2
tv315 = -138						; size = 2
tv305 = -138						; size = 2
_lpData$228762 = -72					; size = 8
_lpData$228758 = -64					; size = 8
_lpData$228754 = -56					; size = 8
_lpData$228750 = -48					; size = 8
_lpData$228746 = -40					; size = 8
_lpData$228742 = -32					; size = 8
_lpData$228738 = -24					; size = 8
_Type$228728 = -16					; size = 4
_Token$228710 = -12					; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Read@CSmithy@@QAEXPAD@Z PROC				; CSmithy::Read
; _this$ = ecx

; 51   : {

  00160	55		 push	 ebp
  00161	8b ec		 mov	 ebp, esp
  00163	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00169	53		 push	 ebx
  0016a	56		 push	 esi
  0016b	57		 push	 edi
  0016c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   : 	SMDToken Token;
; 53   : 	SMDFile = fopen(filename, "r");

  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00174	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _fopen
  0017d	83 c4 08	 add	 esp, 8
  00180	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 54   : 
; 55   : 	if(!SMDFile)

  00185	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  0018c	75 16		 jne	 SHORT $LN28@Read

; 56   : 	{
; 57   : 		MsgBox("[Smithy] %s file not found", filename);

  0018e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00191	50		 push	 eax
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@
  00197	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0019c	83 c4 08	 add	 esp, 8

; 58   : 		return;

  0019f	e9 a7 0a 00 00	 jmp	 $LN29@Read
$LN28@Read:

; 59   : 	}
; 60   : 
; 61   : 	while(true)

  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	85 c0		 test	 eax, eax
  001ab	0f 84 7a 0a 00
	00		 je	 $LN26@Read

; 62   : 	{
; 63   : 		SMDToken Token = GetToken();

  001b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001b6	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 64   : 
; 65   : 		if( Token == END )

  001b9	83 7d f4 02	 cmp	 DWORD PTR _Token$228710[ebp], 2
  001bd	75 05		 jne	 SHORT $LN25@Read

; 66   : 		{
; 67   : 			break;

  001bf	e9 67 0a 00 00	 jmp	 $LN26@Read
$LN25@Read:

; 68   : 		}
; 69   : 
; 70   : 		int Type = (int)TokenNumber;

  001c4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ca	e8 00 00 00 00	 call	 __ftol2_sse
  001cf	89 45 f0	 mov	 DWORD PTR _Type$228728[ebp], eax
$LN24@Read:

; 71   : 
; 72   : 		while(true)

  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	85 c0		 test	 eax, eax
  001d9	0f 84 47 0a 00
	00		 je	 $LN23@Read

; 73   : 		{
; 74   : 			if(Type == 0)

  001df	83 7d f0 00	 cmp	 DWORD PTR _Type$228728[ebp], 0
  001e3	0f 85 1a 03 00
	00		 jne	 $LN22@Read

; 75   : 			{
; 76   : 				Token = GetToken();

  001e9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001ee	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 77   : 				if(!strcmp("end", TokenString))

  001f1	68 00 00 00 00	 push	 OFFSET _TokenString
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  001fb	e8 00 00 00 00	 call	 _strcmp
  00200	83 c4 08	 add	 esp, 8
  00203	85 c0		 test	 eax, eax
  00205	75 05		 jne	 SHORT $LN21@Read

; 78   : 				{
; 79   : 					break;

  00207	e9 1a 0a 00 00	 jmp	 $LN23@Read
$LN21@Read:

; 80   : 				}
; 81   : 				this->MaxLevel = TokenNumber;

  0020c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00212	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv305[ebp]
  00218	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv305[ebp]
  0021f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00224	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv308[ebp], eax
  0022a	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv308[ebp]
  00230	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv310[ebp]
  00236	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv305[ebp]
  0023c	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv310[ebp]
  00242	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	88 01		 mov	 BYTE PTR [ecx], al

; 82   : 				Token = GetToken();

  00247	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0024c	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 83   : 				this->LevelPrice = TokenNumber;

  0024f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00255	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv315[ebp]
  0025b	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv315[ebp]
  00262	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00267	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv318[ebp], eax
  0026d	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv318[ebp]
  00273	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv320[ebp]
  00279	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv315[ebp]
  0027f	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv320[ebp]
  00286	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00289	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 84   : 				Token = GetToken();

  0028d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00292	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 85   : 				this->LuckPrice = TokenNumber;

  00295	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0029b	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv325[ebp]
  002a1	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv325[ebp]
  002a8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002ad	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv328[ebp], eax
  002b3	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv328[ebp]
  002b9	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv330[ebp]
  002bf	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv325[ebp]
  002c5	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv330[ebp]
  002cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 86   : 				Token = GetToken();

  002d3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d8	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 87   : 				this->AddPrice = TokenNumber;

  002db	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002e1	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv335[ebp]
  002e7	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv335[ebp]
  002ee	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002f3	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv338[ebp], eax
  002f9	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv338[ebp]
  002ff	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv340[ebp]
  00305	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv335[ebp]
  0030b	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv340[ebp]
  00312	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00315	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 88   : 				Token = GetToken();

  00319	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0031e	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 89   : 				this->Opt1Price = TokenNumber;

  00321	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00327	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv345[ebp]
  0032d	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv345[ebp]
  00334	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00339	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv348[ebp], eax
  0033f	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv348[ebp]
  00345	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv350[ebp]
  0034b	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv345[ebp]
  00351	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv350[ebp]
  00358	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0035b	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 90   : 				Token = GetToken();

  0035f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00364	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 91   : 				this->Opt2Price = TokenNumber;

  00367	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0036d	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv355[ebp]
  00373	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv355[ebp]
  0037a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0037f	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv358[ebp], eax
  00385	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv358[ebp]
  0038b	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv360[ebp]
  00391	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv355[ebp]
  00397	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv360[ebp]
  0039e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a1	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 92   : 				Token = GetToken();

  003a5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003aa	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 93   : 				this->Opt3Price = TokenNumber;

  003ad	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003b3	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv365[ebp]
  003b9	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv365[ebp]
  003c0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003c5	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv368[ebp], eax
  003cb	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv368[ebp]
  003d1	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv370[ebp]
  003d7	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv365[ebp]
  003dd	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv370[ebp]
  003e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e7	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 94   : 				Token = GetToken();

  003eb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003f0	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 95   : 				this->Opt4Price = TokenNumber;

  003f3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003f9	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv375[ebp]
  003ff	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv375[ebp]
  00406	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0040b	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv378[ebp], eax
  00411	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv378[ebp]
  00417	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv380[ebp]
  0041d	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv375[ebp]
  00423	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv380[ebp]
  0042a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0042d	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 96   : 				Token = GetToken();

  00431	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00436	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 97   : 				this->Opt5Price = TokenNumber;

  00439	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0043f	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv385[ebp]
  00445	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv385[ebp]
  0044c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00451	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv388[ebp], eax
  00457	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv388[ebp]
  0045d	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv390[ebp]
  00463	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv385[ebp]
  00469	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv390[ebp]
  00470	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00473	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 98   : 				Token = GetToken();

  00477	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0047c	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 99   : 				this->Opt6Price = TokenNumber;

  0047f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00485	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv395[ebp]
  0048b	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv395[ebp]
  00492	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00497	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv398[ebp], eax
  0049d	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv398[ebp]
  004a3	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv400[ebp]
  004a9	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv395[ebp]
  004af	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv400[ebp]
  004b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004b9	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 100  : 				Token = GetToken();

  004bd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004c2	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 101  : 				this->MaxExlOpt = TokenNumber;

  004c5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004cb	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv405[ebp]
  004d1	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv405[ebp]
  004d8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004dd	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv408[ebp], eax
  004e3	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv408[ebp]
  004e9	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv410[ebp]
  004ef	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv405[ebp]
  004f5	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR tv410[ebp]
  004fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ff	66 89 41 14	 mov	 WORD PTR [ecx+20], ax
$LN22@Read:

; 102  : 			}
; 103  : 			if(Type == 1)

  00503	83 7d f0 01	 cmp	 DWORD PTR _Type$228728[ebp], 1
  00507	0f 85 fb 00 00
	00		 jne	 $LN20@Read

; 104  : 			{
; 105  : 				Token = GetToken();

  0050d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00512	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 106  : 				if(!strcmp("end", TokenString))

  00515	68 00 00 00 00	 push	 OFFSET _TokenString
  0051a	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0051f	e8 00 00 00 00	 call	 _strcmp
  00524	83 c4 08	 add	 esp, 8
  00527	85 c0		 test	 eax, eax
  00529	75 05		 jne	 SHORT $LN19@Read

; 107  : 				{
; 108  : 					break;

  0052b	e9 f6 06 00 00	 jmp	 $LN23@Read
$LN19@Read:

; 109  : 				}
; 110  : 				SmithyDATA lpData;
; 111  : 				lpData.Type = TokenNumber;

  00530	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00536	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv416[ebp]
  0053c	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv416[ebp]
  00543	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00548	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv419[ebp], eax
  0054e	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv419[ebp]
  00554	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv421[ebp]
  0055a	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv416[ebp]
  00560	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv421[ebp]
  00566	88 45 e9	 mov	 BYTE PTR _lpData$228738[ebp+1], al

; 112  : 				Token = GetToken();

  00569	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0056e	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 113  : 				lpData.Index = TokenNumber;

  00571	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00577	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv425[ebp]
  0057d	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv425[ebp]
  00584	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00589	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv428[ebp], eax
  0058f	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv428[ebp]
  00595	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv430[ebp]
  0059b	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv425[ebp]
  005a1	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv430[ebp]
  005a7	88 45 ea	 mov	 BYTE PTR _lpData$228738[ebp+2], al

; 114  : 				lpData.Class = Type-1;

  005aa	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  005ad	83 e8 01	 sub	 eax, 1
  005b0	88 45 e8	 mov	 BYTE PTR _lpData$228738[ebp], al

; 115  : 				Token = GetToken();

  005b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005b8	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 116  : 				lpData.Price = TokenNumber;

  005bb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005c1	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv435[ebp]
  005c7	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv435[ebp]
  005ce	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005d3	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv438[ebp], eax
  005d9	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv438[ebp]
  005df	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv440[ebp]
  005e5	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv435[ebp]
  005eb	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv440[ebp]
  005f1	89 45 ec	 mov	 DWORD PTR _lpData$228738[ebp+4], eax

; 117  : 				this->itemdata.push_back(lpData);

  005f4	8d 45 e8	 lea	 eax, DWORD PTR _lpData$228738[ebp]
  005f7	50		 push	 eax
  005f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005fb	83 c1 18	 add	 ecx, 24			; 00000018H
  005fe	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00603	e9 19 06 00 00	 jmp	 $LN2@Read
$LN20@Read:

; 118  : 			}
; 119  : 			else if(Type == 2)

  00608	83 7d f0 02	 cmp	 DWORD PTR _Type$228728[ebp], 2
  0060c	0f 85 fb 00 00
	00		 jne	 $LN17@Read

; 120  : 			{
; 121  : 				Token = GetToken();

  00612	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00617	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 122  : 				if(!strcmp("end", TokenString))

  0061a	68 00 00 00 00	 push	 OFFSET _TokenString
  0061f	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00624	e8 00 00 00 00	 call	 _strcmp
  00629	83 c4 08	 add	 esp, 8
  0062c	85 c0		 test	 eax, eax
  0062e	75 05		 jne	 SHORT $LN16@Read

; 123  : 				{
; 124  : 					break;

  00630	e9 f1 05 00 00	 jmp	 $LN23@Read
$LN16@Read:

; 125  : 				}
; 126  : 				SmithyDATA lpData;
; 127  : 				lpData.Type = TokenNumber;

  00635	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0063b	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv447[ebp]
  00641	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv447[ebp]
  00648	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0064d	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv450[ebp], eax
  00653	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv450[ebp]
  00659	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv452[ebp]
  0065f	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv447[ebp]
  00665	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv452[ebp]
  0066b	88 45 e1	 mov	 BYTE PTR _lpData$228742[ebp+1], al

; 128  : 				Token = GetToken();

  0066e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00673	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 129  : 				lpData.Index = TokenNumber;

  00676	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0067c	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv456[ebp]
  00682	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv456[ebp]
  00689	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0068e	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  00694	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv459[ebp]
  0069a	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv461[ebp]
  006a0	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv456[ebp]
  006a6	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv461[ebp]
  006ac	88 45 e2	 mov	 BYTE PTR _lpData$228742[ebp+2], al

; 130  : 				lpData.Class = Type-1;

  006af	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  006b2	83 e8 01	 sub	 eax, 1
  006b5	88 45 e0	 mov	 BYTE PTR _lpData$228742[ebp], al

; 131  : 				Token = GetToken();

  006b8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006bd	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 132  : 				lpData.Price = TokenNumber;

  006c0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006c6	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv466[ebp]
  006cc	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv466[ebp]
  006d3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  006d8	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv469[ebp], eax
  006de	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv469[ebp]
  006e4	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv471[ebp]
  006ea	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv466[ebp]
  006f0	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv471[ebp]
  006f6	89 45 e4	 mov	 DWORD PTR _lpData$228742[ebp+4], eax

; 133  : 				this->itemdata.push_back(lpData);

  006f9	8d 45 e0	 lea	 eax, DWORD PTR _lpData$228742[ebp]
  006fc	50		 push	 eax
  006fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00700	83 c1 18	 add	 ecx, 24			; 00000018H
  00703	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00708	e9 14 05 00 00	 jmp	 $LN2@Read
$LN17@Read:

; 134  : 			}
; 135  : 			else if(Type == 3)

  0070d	83 7d f0 03	 cmp	 DWORD PTR _Type$228728[ebp], 3
  00711	0f 85 fb 00 00
	00		 jne	 $LN14@Read

; 136  : 			{
; 137  : 				Token = GetToken();

  00717	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0071c	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 138  : 				if(!strcmp("end", TokenString))

  0071f	68 00 00 00 00	 push	 OFFSET _TokenString
  00724	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00729	e8 00 00 00 00	 call	 _strcmp
  0072e	83 c4 08	 add	 esp, 8
  00731	85 c0		 test	 eax, eax
  00733	75 05		 jne	 SHORT $LN13@Read

; 139  : 				{
; 140  : 					break;

  00735	e9 ec 04 00 00	 jmp	 $LN23@Read
$LN13@Read:

; 141  : 				}
; 142  : 				SmithyDATA lpData;
; 143  : 				lpData.Type = TokenNumber;

  0073a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00740	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv478[ebp]
  00746	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv478[ebp]
  0074d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00752	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv481[ebp], eax
  00758	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv481[ebp]
  0075e	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv483[ebp]
  00764	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv478[ebp]
  0076a	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv483[ebp]
  00770	88 45 d9	 mov	 BYTE PTR _lpData$228746[ebp+1], al

; 144  : 				Token = GetToken();

  00773	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00778	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 145  : 				lpData.Index = TokenNumber;

  0077b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00781	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv487[ebp]
  00787	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv487[ebp]
  0078e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00793	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv490[ebp], eax
  00799	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv490[ebp]
  0079f	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv492[ebp]
  007a5	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv487[ebp]
  007ab	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv492[ebp]
  007b1	88 45 da	 mov	 BYTE PTR _lpData$228746[ebp+2], al

; 146  : 				lpData.Class = Type-1;

  007b4	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  007b7	83 e8 01	 sub	 eax, 1
  007ba	88 45 d8	 mov	 BYTE PTR _lpData$228746[ebp], al

; 147  : 				Token = GetToken();

  007bd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007c2	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 148  : 				lpData.Price = TokenNumber;

  007c5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007cb	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv497[ebp]
  007d1	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv497[ebp]
  007d8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  007dd	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv500[ebp], eax
  007e3	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv500[ebp]
  007e9	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv502[ebp]
  007ef	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv497[ebp]
  007f5	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv502[ebp]
  007fb	89 45 dc	 mov	 DWORD PTR _lpData$228746[ebp+4], eax

; 149  : 				this->itemdata.push_back(lpData);

  007fe	8d 45 d8	 lea	 eax, DWORD PTR _lpData$228746[ebp]
  00801	50		 push	 eax
  00802	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00805	83 c1 18	 add	 ecx, 24			; 00000018H
  00808	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  0080d	e9 0f 04 00 00	 jmp	 $LN2@Read
$LN14@Read:

; 150  : 			}
; 151  : 			else if(Type == 4)

  00812	83 7d f0 04	 cmp	 DWORD PTR _Type$228728[ebp], 4
  00816	0f 85 fb 00 00
	00		 jne	 $LN11@Read

; 152  : 			{
; 153  : 				Token = GetToken();

  0081c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00821	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 154  : 				if(!strcmp("end", TokenString))

  00824	68 00 00 00 00	 push	 OFFSET _TokenString
  00829	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0082e	e8 00 00 00 00	 call	 _strcmp
  00833	83 c4 08	 add	 esp, 8
  00836	85 c0		 test	 eax, eax
  00838	75 05		 jne	 SHORT $LN10@Read

; 155  : 				{
; 156  : 					break;

  0083a	e9 e7 03 00 00	 jmp	 $LN23@Read
$LN10@Read:

; 157  : 				}
; 158  : 				SmithyDATA lpData;
; 159  : 				lpData.Type = TokenNumber;

  0083f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00845	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv509[ebp]
  0084b	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv509[ebp]
  00852	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00857	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv512[ebp], eax
  0085d	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv512[ebp]
  00863	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv514[ebp]
  00869	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv509[ebp]
  0086f	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv514[ebp]
  00875	88 45 d1	 mov	 BYTE PTR _lpData$228750[ebp+1], al

; 160  : 				Token = GetToken();

  00878	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0087d	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 161  : 				lpData.Index = TokenNumber;

  00880	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00886	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv518[ebp]
  0088c	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv518[ebp]
  00893	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00898	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv521[ebp], eax
  0089e	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv521[ebp]
  008a4	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv523[ebp]
  008aa	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv518[ebp]
  008b0	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv523[ebp]
  008b6	88 45 d2	 mov	 BYTE PTR _lpData$228750[ebp+2], al

; 162  : 				lpData.Class = Type-1;

  008b9	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  008bc	83 e8 01	 sub	 eax, 1
  008bf	88 45 d0	 mov	 BYTE PTR _lpData$228750[ebp], al

; 163  : 				Token = GetToken();

  008c2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  008c7	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 164  : 				lpData.Price = TokenNumber;

  008ca	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  008d0	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv528[ebp]
  008d6	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv528[ebp]
  008dd	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  008e2	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv531[ebp], eax
  008e8	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv531[ebp]
  008ee	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv533[ebp]
  008f4	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv528[ebp]
  008fa	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv533[ebp]
  00900	89 45 d4	 mov	 DWORD PTR _lpData$228750[ebp+4], eax

; 165  : 				this->itemdata.push_back(lpData);

  00903	8d 45 d0	 lea	 eax, DWORD PTR _lpData$228750[ebp]
  00906	50		 push	 eax
  00907	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0090a	83 c1 18	 add	 ecx, 24			; 00000018H
  0090d	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00912	e9 0a 03 00 00	 jmp	 $LN2@Read
$LN11@Read:

; 166  : 			}
; 167  : 			else if(Type == 5)

  00917	83 7d f0 05	 cmp	 DWORD PTR _Type$228728[ebp], 5
  0091b	0f 85 fb 00 00
	00		 jne	 $LN8@Read

; 168  : 			{
; 169  : 				Token = GetToken();

  00921	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00926	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 170  : 				if(!strcmp("end", TokenString))

  00929	68 00 00 00 00	 push	 OFFSET _TokenString
  0092e	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00933	e8 00 00 00 00	 call	 _strcmp
  00938	83 c4 08	 add	 esp, 8
  0093b	85 c0		 test	 eax, eax
  0093d	75 05		 jne	 SHORT $LN7@Read

; 171  : 				{
; 172  : 					break;

  0093f	e9 e2 02 00 00	 jmp	 $LN23@Read
$LN7@Read:

; 173  : 				}
; 174  : 				SmithyDATA lpData;
; 175  : 				lpData.Type = TokenNumber;

  00944	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0094a	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv540[ebp]
  00950	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv540[ebp]
  00957	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0095c	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv543[ebp], eax
  00962	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv543[ebp]
  00968	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv545[ebp]
  0096e	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv540[ebp]
  00974	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv545[ebp]
  0097a	88 45 c9	 mov	 BYTE PTR _lpData$228754[ebp+1], al

; 176  : 				Token = GetToken();

  0097d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00982	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 177  : 				lpData.Index = TokenNumber;

  00985	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0098b	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv549[ebp]
  00991	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv549[ebp]
  00998	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0099d	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv552[ebp], eax
  009a3	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv552[ebp]
  009a9	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv554[ebp]
  009af	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv549[ebp]
  009b5	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv554[ebp]
  009bb	88 45 ca	 mov	 BYTE PTR _lpData$228754[ebp+2], al

; 178  : 				lpData.Class = Type-1;

  009be	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  009c1	83 e8 01	 sub	 eax, 1
  009c4	88 45 c8	 mov	 BYTE PTR _lpData$228754[ebp], al

; 179  : 				Token = GetToken();

  009c7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009cc	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 180  : 				lpData.Price = TokenNumber;

  009cf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009d5	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv559[ebp]
  009db	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv559[ebp]
  009e2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  009e7	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv562[ebp], eax
  009ed	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv562[ebp]
  009f3	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv564[ebp]
  009f9	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv559[ebp]
  009ff	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv564[ebp]
  00a05	89 45 cc	 mov	 DWORD PTR _lpData$228754[ebp+4], eax

; 181  : 				this->itemdata.push_back(lpData);

  00a08	8d 45 c8	 lea	 eax, DWORD PTR _lpData$228754[ebp]
  00a0b	50		 push	 eax
  00a0c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a0f	83 c1 18	 add	 ecx, 24			; 00000018H
  00a12	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00a17	e9 05 02 00 00	 jmp	 $LN2@Read
$LN8@Read:

; 182  : 			}
; 183  : 			else if(Type == 6)

  00a1c	83 7d f0 06	 cmp	 DWORD PTR _Type$228728[ebp], 6
  00a20	0f 85 fb 00 00
	00		 jne	 $LN5@Read

; 184  : 			{
; 185  : 				Token = GetToken();

  00a26	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00a2b	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 186  : 				if(!strcmp("end", TokenString))

  00a2e	68 00 00 00 00	 push	 OFFSET _TokenString
  00a33	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00a38	e8 00 00 00 00	 call	 _strcmp
  00a3d	83 c4 08	 add	 esp, 8
  00a40	85 c0		 test	 eax, eax
  00a42	75 05		 jne	 SHORT $LN4@Read

; 187  : 				{
; 188  : 					break;

  00a44	e9 dd 01 00 00	 jmp	 $LN23@Read
$LN4@Read:

; 189  : 				}
; 190  : 				SmithyDATA lpData;
; 191  : 				lpData.Type = TokenNumber;

  00a49	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00a4f	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv571[ebp]
  00a55	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv571[ebp]
  00a5c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a61	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv574[ebp], eax
  00a67	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv574[ebp]
  00a6d	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv576[ebp]
  00a73	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv571[ebp]
  00a79	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv576[ebp]
  00a7f	88 45 c1	 mov	 BYTE PTR _lpData$228758[ebp+1], al

; 192  : 				Token = GetToken();

  00a82	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00a87	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 193  : 				lpData.Index = TokenNumber;

  00a8a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00a90	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv580[ebp]
  00a96	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv580[ebp]
  00a9d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00aa2	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv583[ebp], eax
  00aa8	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv583[ebp]
  00aae	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv585[ebp]
  00ab4	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv580[ebp]
  00aba	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv585[ebp]
  00ac0	88 45 c2	 mov	 BYTE PTR _lpData$228758[ebp+2], al

; 194  : 				lpData.Class = Type-1;

  00ac3	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  00ac6	83 e8 01	 sub	 eax, 1
  00ac9	88 45 c0	 mov	 BYTE PTR _lpData$228758[ebp], al

; 195  : 				Token = GetToken();

  00acc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00ad1	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 196  : 				lpData.Price = TokenNumber;

  00ad4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00ada	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv590[ebp]
  00ae0	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv590[ebp]
  00ae7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00aec	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv593[ebp], eax
  00af2	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv593[ebp]
  00af8	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv595[ebp]
  00afe	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv590[ebp]
  00b04	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv595[ebp]
  00b0a	89 45 c4	 mov	 DWORD PTR _lpData$228758[ebp+4], eax

; 197  : 				this->itemdata.push_back(lpData);

  00b0d	8d 45 c0	 lea	 eax, DWORD PTR _lpData$228758[ebp]
  00b10	50		 push	 eax
  00b11	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b14	83 c1 18	 add	 ecx, 24			; 00000018H
  00b17	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00b1c	e9 00 01 00 00	 jmp	 $LN2@Read
$LN5@Read:

; 198  : 			}
; 199  : 			else if(Type == 7)

  00b21	83 7d f0 07	 cmp	 DWORD PTR _Type$228728[ebp], 7
  00b25	0f 85 f6 00 00
	00		 jne	 $LN2@Read

; 200  : 			{
; 201  : 				Token = GetToken();

  00b2b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00b30	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 202  : 				if(!strcmp("end", TokenString))

  00b33	68 00 00 00 00	 push	 OFFSET _TokenString
  00b38	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00b3d	e8 00 00 00 00	 call	 _strcmp
  00b42	83 c4 08	 add	 esp, 8
  00b45	85 c0		 test	 eax, eax
  00b47	75 05		 jne	 SHORT $LN1@Read

; 203  : 				{
; 204  : 					break;

  00b49	e9 d8 00 00 00	 jmp	 $LN23@Read
$LN1@Read:

; 205  : 				}
; 206  : 				SmithyDATA lpData;
; 207  : 				lpData.Type = TokenNumber;

  00b4e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00b54	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv602[ebp]
  00b5a	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv602[ebp]
  00b61	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00b66	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv605[ebp], eax
  00b6c	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv605[ebp]
  00b72	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv607[ebp]
  00b78	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv602[ebp]
  00b7e	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv607[ebp]
  00b84	88 45 b9	 mov	 BYTE PTR _lpData$228762[ebp+1], al

; 208  : 				Token = GetToken();

  00b87	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00b8c	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 209  : 				lpData.Index = TokenNumber;

  00b8f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00b95	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv611[ebp]
  00b9b	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv611[ebp]
  00ba2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00ba7	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv614[ebp], eax
  00bad	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv614[ebp]
  00bb3	db 9d 6c ff ff
	ff		 fistp	 DWORD PTR tv616[ebp]
  00bb9	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv611[ebp]
  00bbf	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv616[ebp]
  00bc5	88 45 ba	 mov	 BYTE PTR _lpData$228762[ebp+2], al

; 210  : 				lpData.Class = Type-1;

  00bc8	8b 45 f0	 mov	 eax, DWORD PTR _Type$228728[ebp]
  00bcb	83 e8 01	 sub	 eax, 1
  00bce	88 45 b8	 mov	 BYTE PTR _lpData$228762[ebp], al

; 211  : 				Token = GetToken();

  00bd1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00bd6	89 45 f4	 mov	 DWORD PTR _Token$228710[ebp], eax

; 212  : 				lpData.Price = TokenNumber;

  00bd9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00bdf	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv621[ebp]
  00be5	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv621[ebp]
  00bec	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00bf1	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv624[ebp], eax
  00bf7	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv624[ebp]
  00bfd	df bd 68 ff ff
	ff		 fistp	 QWORD PTR tv626[ebp]
  00c03	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv621[ebp]
  00c09	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv626[ebp]
  00c0f	89 45 bc	 mov	 DWORD PTR _lpData$228762[ebp+4], eax

; 213  : 				this->itemdata.push_back(lpData);

  00c12	8d 45 b8	 lea	 eax, DWORD PTR _lpData$228762[ebp]
  00c15	50		 push	 eax
  00c16	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c19	83 c1 18	 add	 ecx, 24			; 00000018H
  00c1c	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
$LN2@Read:

; 214  : 			}
; 215  : 		}

  00c21	e9 ac f5 ff ff	 jmp	 $LN24@Read
$LN23@Read:

; 216  : 	}

  00c26	e9 79 f5 ff ff	 jmp	 $LN28@Read
$LN26@Read:

; 217  : 
; 218  : 	fclose(SMDFile);

  00c2b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c30	50		 push	 eax
  00c31	e8 00 00 00 00	 call	 _fclose
  00c36	83 c4 04	 add	 esp, 4

; 219  : 	LogAdd("%s file load!", filename);

  00c39	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00c3c	50		 push	 eax
  00c3d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00c42	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00c48	83 c4 08	 add	 esp, 8
$LN29@Read:

; 220  : }

  00c4b	5f		 pop	 edi
  00c4c	5e		 pop	 esi
  00c4d	5b		 pop	 ebx
  00c4e	8b e5		 mov	 esp, ebp
  00c50	5d		 pop	 ebp
  00c51	c2 04 00	 ret	 4
?Read@CSmithy@@QAEXPAD@Z ENDP				; CSmithy::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00c60	55		 push	 ebp
  00c61	8b ec		 mov	 ebp, esp
  00c63	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00c69	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00c6e	33 c5		 xor	 eax, ebp
  00c70	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00c73	53		 push	 ebx
  00c74	56		 push	 esi
  00c75	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00c76	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00c7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c82	50		 push	 eax
  00c83	e8 00 00 00 00	 call	 _fgetc
  00c88	83 c4 04	 add	 esp, 4
  00c8b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00c8e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c92	83 f9 ff	 cmp	 ecx, -1
  00c95	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00c97	b8 02 00 00 00	 mov	 eax, 2
  00c9c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00ca1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00ca3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ca7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00caa	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  00cac	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00cb1	50		 push	 eax
  00cb2	e8 00 00 00 00	 call	 _fgetc
  00cb7	83 c4 04	 add	 esp, 4
  00cba	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00cbd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00cc1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00cc4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00cc6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00cca	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00ccd	74 1c		 je	 SHORT $LN23@GetToken
  00ccf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00cd3	83 f8 ff	 cmp	 eax, -1
  00cd6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00cd8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00cdd	50		 push	 eax
  00cde	e8 00 00 00 00	 call	 _fgetc
  00ce3	83 c4 04	 add	 esp, 4
  00ce6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00ce9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  00ceb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00cef	83 f8 ff	 cmp	 eax, -1
  00cf2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00cf4	b8 02 00 00 00	 mov	 eax, 2
  00cf9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  00cfe	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d02	50		 push	 eax
  00d03	e8 00 00 00 00	 call	 _isspace
  00d08	83 c4 04	 add	 esp, 4
  00d0b	85 c0		 test	 eax, eax
  00d0d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00d13	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d17	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  00d1d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00d23	83 e9 22	 sub	 ecx, 34			; 00000022H
  00d26	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  00d2c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00d33	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00d39	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  00d3f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00d46	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  00d4d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00d57	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d5c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00d61	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00d66	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00d70	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d75	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  00d7a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  00d7f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00d89	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d8e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00d93	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00d98	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00da2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00da7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  00dac	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00db1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  00dbb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00dc0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00dc5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00dca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00dcf	50		 push	 eax
  00dd0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00dd4	51		 push	 ecx
  00dd5	e8 00 00 00 00	 call	 _ungetc
  00dda	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  00ddd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00de0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00de3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00de8	50		 push	 eax
  00de9	e8 00 00 00 00	 call	 _getc
  00dee	83 c4 04	 add	 esp, 4
  00df1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00df4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00df8	83 f9 ff	 cmp	 ecx, -1
  00dfb	74 36		 je	 SHORT $LN12@GetToken
  00dfd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e01	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00e04	74 1a		 je	 SHORT $LN11@GetToken
  00e06	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e0a	50		 push	 eax
  00e0b	e8 00 00 00 00	 call	 _isdigit
  00e10	83 c4 04	 add	 esp, 4
  00e13	85 c0		 test	 eax, eax
  00e15	75 09		 jne	 SHORT $LN11@GetToken
  00e17	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e1b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00e1e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00e20	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e23	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00e26	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00e28	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e2b	83 c0 01	 add	 eax, 1
  00e2e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00e31	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00e33	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e36	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00e39	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00e3c	50		 push	 eax
  00e3d	e8 00 00 00 00	 call	 _atof
  00e42	83 c4 04	 add	 esp, 4
  00e45	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00e4b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00e55	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e5a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00e5f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00e64	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00e6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00e70	50		 push	 eax
  00e71	e8 00 00 00 00	 call	 _getc
  00e76	83 c4 04	 add	 esp, 4
  00e79	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00e7c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00e80	83 f9 ff	 cmp	 ecx, -1
  00e83	74 1c		 je	 SHORT $LN8@GetToken
  00e85	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e89	83 f8 22	 cmp	 eax, 34			; 00000022H
  00e8c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00e8e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e91	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00e94	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00e96	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e99	83 c0 01	 add	 eax, 1
  00e9c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00e9f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00ea1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ea5	83 f8 22	 cmp	 eax, 34			; 00000022H
  00ea8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00eaa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00eaf	50		 push	 eax
  00eb0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00eb4	51		 push	 ecx
  00eb5	e8 00 00 00 00	 call	 _ungetc
  00eba	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00ebd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ec0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00ec3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00ecd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00ed2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00ed7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00edc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ee0	50		 push	 eax
  00ee1	e8 00 00 00 00	 call	 _isalpha
  00ee6	83 c4 04	 add	 esp, 4
  00ee9	85 c0		 test	 eax, eax
  00eeb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00ef1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00ef8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00efb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00efe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00f00	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f03	83 c0 01	 add	 eax, 1
  00f06	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00f09	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f0e	50		 push	 eax
  00f0f	e8 00 00 00 00	 call	 _getc
  00f14	83 c4 04	 add	 esp, 4
  00f17	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00f1a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f1e	83 f9 ff	 cmp	 ecx, -1
  00f21	74 36		 je	 SHORT $LN3@GetToken
  00f23	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f27	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00f2a	74 1a		 je	 SHORT $LN2@GetToken
  00f2c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f30	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00f33	74 11		 je	 SHORT $LN2@GetToken
  00f35	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f39	50		 push	 eax
  00f3a	e8 00 00 00 00	 call	 _isalnum
  00f3f	83 c4 04	 add	 esp, 4
  00f42	85 c0		 test	 eax, eax
  00f44	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00f46	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f49	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00f4c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00f4e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f51	83 c0 01	 add	 eax, 1
  00f54	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00f57	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00f59	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f5e	50		 push	 eax
  00f5f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f63	51		 push	 ecx
  00f64	e8 00 00 00 00	 call	 _ungetc
  00f69	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  00f6c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f6f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00f72	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  00f7c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f81	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00f83	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00f85	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00f8f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f94	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00f96	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00f98	5f		 pop	 edi
  00f99	5e		 pop	 esi
  00f9a	5b		 pop	 ebx
  00f9b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f9e	33 cd		 xor	 ecx, ebp
  00fa0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fa5	8b e5		 mov	 esp, ebp
  00fa7	5d		 pop	 ebp
  00fa8	c3		 ret	 0
  00fa9	8d 49 00	 npad	 3
$LN35@GetToken:
  00fac	00 00 00 00	 DD	 $LN10@GetToken
  00fb0	00 00 00 00	 DD	 $LN19@GetToken
  00fb4	00 00 00 00	 DD	 $LN17@GetToken
  00fb8	00 00 00 00	 DD	 $LN14@GetToken
  00fbc	00 00 00 00	 DD	 $LN18@GetToken
  00fc0	00 00 00 00	 DD	 $LN16@GetToken
  00fc4	00 00 00 00	 DD	 $LN15@GetToken
  00fc8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00fcc	00		 DB	 0
  00fcd	01		 DB	 1
  00fce	07		 DB	 7
  00fcf	07		 DB	 7
  00fd0	07		 DB	 7
  00fd1	07		 DB	 7
  00fd2	07		 DB	 7
  00fd3	07		 DB	 7
  00fd4	07		 DB	 7
  00fd5	07		 DB	 7
  00fd6	02		 DB	 2
  00fd7	03		 DB	 3
  00fd8	03		 DB	 3
  00fd9	07		 DB	 7
  00fda	03		 DB	 3
  00fdb	03		 DB	 3
  00fdc	03		 DB	 3
  00fdd	03		 DB	 3
  00fde	03		 DB	 3
  00fdf	03		 DB	 3
  00fe0	03		 DB	 3
  00fe1	03		 DB	 3
  00fe2	03		 DB	 3
  00fe3	03		 DB	 3
  00fe4	07		 DB	 7
  00fe5	04		 DB	 4
  00fe6	07		 DB	 7
  00fe7	07		 DB	 7
  00fe8	07		 DB	 7
  00fe9	07		 DB	 7
  00fea	07		 DB	 7
  00feb	07		 DB	 7
  00fec	07		 DB	 7
  00fed	07		 DB	 7
  00fee	07		 DB	 7
  00fef	07		 DB	 7
  00ff0	07		 DB	 7
  00ff1	07		 DB	 7
  00ff2	07		 DB	 7
  00ff3	07		 DB	 7
  00ff4	07		 DB	 7
  00ff5	07		 DB	 7
  00ff6	07		 DB	 7
  00ff7	07		 DB	 7
  00ff8	07		 DB	 7
  00ff9	07		 DB	 7
  00ffa	07		 DB	 7
  00ffb	07		 DB	 7
  00ffc	07		 DB	 7
  00ffd	07		 DB	 7
  00ffe	07		 DB	 7
  00fff	07		 DB	 7
  01000	07		 DB	 7
  01001	07		 DB	 7
  01002	07		 DB	 7
  01003	07		 DB	 7
  01004	07		 DB	 7
  01005	07		 DB	 7
  01006	07		 DB	 7
  01007	07		 DB	 7
  01008	07		 DB	 7
  01009	07		 DB	 7
  0100a	07		 DB	 7
  0100b	07		 DB	 7
  0100c	07		 DB	 7
  0100d	07		 DB	 7
  0100e	07		 DB	 7
  0100f	07		 DB	 7
  01010	07		 DB	 7
  01011	07		 DB	 7
  01012	07		 DB	 7
  01013	07		 DB	 7
  01014	07		 DB	 7
  01015	07		 DB	 7
  01016	07		 DB	 7
  01017	07		 DB	 7
  01018	07		 DB	 7
  01019	07		 DB	 7
  0101a	07		 DB	 7
  0101b	07		 DB	 7
  0101c	07		 DB	 7
  0101d	07		 DB	 7
  0101e	07		 DB	 7
  0101f	07		 DB	 7
  01020	07		 DB	 7
  01021	07		 DB	 7
  01022	07		 DB	 7
  01023	07		 DB	 7
  01024	07		 DB	 7
  01025	05		 DB	 5
  01026	07		 DB	 7
  01027	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	?GCInitItem@CSmithy@@QAEXH@Z			; CSmithy::GCInitItem
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\smithy.cpp
_TEXT	SEGMENT
tv67 = -80						; size = 4
_pMsg$ = -12						; size = 5
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?GCInitItem@CSmithy@@QAEXH@Z PROC			; CSmithy::GCInitItem
; _this$ = ecx

; 223  : {

  01030	55		 push	 ebp
  01031	8b ec		 mov	 ebp, esp
  01033	83 ec 50	 sub	 esp, 80			; 00000050H
  01036	53		 push	 ebx
  01037	56		 push	 esi
  01038	57		 push	 edi
  01039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 224  : 	if(OBJMAX_RANGE(aIndex) == 0)

  0103c	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01040	7d 09		 jge	 SHORT $LN4@GCInitItem
  01042	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  01049	eb 0f		 jmp	 SHORT $LN5@GCInitItem
$LN4@GCInitItem:
  0104b	33 c0		 xor	 eax, eax
  0104d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  01054	0f 9e c0	 setle	 al
  01057	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GCInitItem:
  0105a	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0105e	75 02		 jne	 SHORT $LN1@GCInitItem

; 225  : 	{
; 226  : 		return;

  01060	eb 2b		 jmp	 SHORT $LN2@GCInitItem
$LN1@GCInitItem:

; 227  : 	}
; 228  : 
; 229  : 	GC_SmithyInit pMsg;
; 230  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x1E,  sizeof(pMsg));

  01062	6a 05		 push	 5
  01064	6a 1e		 push	 30			; 0000001eH
  01066	68 fb 00 00 00	 push	 251			; 000000fbH
  0106b	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0106e	50		 push	 eax
  0106f	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01072	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 231  : 	pMsg.result = true;

  01077	c6 45 f8 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 232  : 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  0107b	6a 05		 push	 5
  0107d	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01080	50		 push	 eax
  01081	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01084	51		 push	 ecx
  01085	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0108a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCInitItem:

; 233  : }

  0108d	5f		 pop	 edi
  0108e	5e		 pop	 esi
  0108f	5b		 pop	 ebx
  01090	8b e5		 mov	 esp, ebp
  01092	5d		 pop	 ebp
  01093	c2 04 00	 ret	 4
?GCInitItem@CSmithy@@QAEXH@Z ENDP			; CSmithy::GCInitItem
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
PUBLIC	?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
PUBLIC	?GCSettingsSend@CSmithy@@QAEXH@Z		; CSmithy::GCSettingsSend
PUBLIC	__$ArrayPad$
PUBLIC	?GCIemSend@CSmithy@@QAEXH@Z			; CSmithy::GCIemSend
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\smithy.cpp
_TEXT	SEGMENT
tv69 = -92						; size = 4
_pMsg$228782 = -24					; size = 12
_i$228778 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCIemSend@CSmithy@@QAEXH@Z PROC			; CSmithy::GCIemSend
; _this$ = ecx

; 236  : {

  010a0	55		 push	 ebp
  010a1	8b ec		 mov	 ebp, esp
  010a3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  010a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  010ab	33 c5		 xor	 eax, ebp
  010ad	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  010b0	53		 push	 ebx
  010b1	56		 push	 esi
  010b2	57		 push	 edi
  010b3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 	if(!g_ExLicense.user.Smithy)

  010b6	0f b6 05 dc 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+220
  010bd	85 c0		 test	 eax, eax
  010bf	75 05		 jne	 SHORT $LN5@GCIemSend

; 238  : 	{
; 239  : 		return;

  010c1	e9 e2 00 00 00	 jmp	 $LN6@GCIemSend
$LN5@GCIemSend:

; 240  : 	}
; 241  : 
; 242  : 	if(OBJMAX_RANGE(aIndex) == 0)

  010c6	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  010ca	7d 09		 jge	 SHORT $LN8@GCIemSend
  010cc	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  010d3	eb 0f		 jmp	 SHORT $LN9@GCIemSend
$LN8@GCIemSend:
  010d5	33 c0		 xor	 eax, eax
  010d7	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  010de	0f 9e c0	 setle	 al
  010e1	89 45 a4	 mov	 DWORD PTR tv69[ebp], eax
$LN9@GCIemSend:
  010e4	83 7d a4 00	 cmp	 DWORD PTR tv69[ebp], 0
  010e8	75 05		 jne	 SHORT $LN4@GCIemSend

; 243  : 	{
; 244  : 		return;

  010ea	e9 b9 00 00 00	 jmp	 $LN6@GCIemSend
$LN4@GCIemSend:

; 245  : 	}
; 246  : 
; 247  : 	this->GCSettingsSend(aIndex);

  010ef	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010f2	50		 push	 eax
  010f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  010f6	e8 00 00 00 00	 call	 ?GCSettingsSend@CSmithy@@QAEXH@Z ; CSmithy::GCSettingsSend

; 248  : 	this->GCInitItem(aIndex);

  010fb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010fe	50		 push	 eax
  010ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01102	e8 00 00 00 00	 call	 ?GCInitItem@CSmithy@@QAEXH@Z ; CSmithy::GCInitItem

; 249  : 	for(int i = 0; i < itemdata.size(); i++)

  01107	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$228778[ebp], 0
  0110e	eb 09		 jmp	 SHORT $LN3@GCIemSend
$LN2@GCIemSend:
  01110	8b 45 f4	 mov	 eax, DWORD PTR _i$228778[ebp]
  01113	83 c0 01	 add	 eax, 1
  01116	89 45 f4	 mov	 DWORD PTR _i$228778[ebp], eax
$LN3@GCIemSend:
  01119	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0111c	83 c1 18	 add	 ecx, 24			; 00000018H
  0111f	e8 00 00 00 00	 call	 ?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
  01124	39 45 f4	 cmp	 DWORD PTR _i$228778[ebp], eax
  01127	73 7f		 jae	 SHORT $LN6@GCIemSend

; 250  : 	{
; 251  : 		GC_SmithyDATA pMsg;
; 252  : 		pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x1D,  sizeof(pMsg));

  01129	6a 0c		 push	 12			; 0000000cH
  0112b	6a 1d		 push	 29			; 0000001dH
  0112d	68 fb 00 00 00	 push	 251			; 000000fbH
  01132	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$228782[ebp]
  01135	50		 push	 eax
  01136	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$228782[ebp]
  01139	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 253  : 		pMsg.Class = itemdata[i].Class;

  0113e	8b 45 f4	 mov	 eax, DWORD PTR _i$228778[ebp]
  01141	50		 push	 eax
  01142	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01145	83 c1 18	 add	 ecx, 24			; 00000018H
  01148	e8 00 00 00 00	 call	 ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
  0114d	8a 08		 mov	 cl, BYTE PTR [eax]
  0114f	88 4d ec	 mov	 BYTE PTR _pMsg$228782[ebp+4], cl

; 254  : 		pMsg.Type = itemdata[i].Type;

  01152	8b 45 f4	 mov	 eax, DWORD PTR _i$228778[ebp]
  01155	50		 push	 eax
  01156	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01159	83 c1 18	 add	 ecx, 24			; 00000018H
  0115c	e8 00 00 00 00	 call	 ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
  01161	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01164	88 4d ed	 mov	 BYTE PTR _pMsg$228782[ebp+5], cl

; 255  : 		pMsg.Index = itemdata[i].Index;

  01167	8b 45 f4	 mov	 eax, DWORD PTR _i$228778[ebp]
  0116a	50		 push	 eax
  0116b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0116e	83 c1 18	 add	 ecx, 24			; 00000018H
  01171	e8 00 00 00 00	 call	 ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
  01176	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  01179	88 4d ee	 mov	 BYTE PTR _pMsg$228782[ebp+6], cl

; 256  : 		pMsg.Price = itemdata[i].Price;

  0117c	8b 45 f4	 mov	 eax, DWORD PTR _i$228778[ebp]
  0117f	50		 push	 eax
  01180	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01183	83 c1 18	 add	 ecx, 24			; 00000018H
  01186	e8 00 00 00 00	 call	 ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
  0118b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0118e	89 4d f0	 mov	 DWORD PTR _pMsg$228782[ebp+8], ecx

; 257  : 		DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  01191	6a 0c		 push	 12			; 0000000cH
  01193	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$228782[ebp]
  01196	50		 push	 eax
  01197	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0119a	51		 push	 ecx
  0119b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  011a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 258  : 	}

  011a3	e9 68 ff ff ff	 jmp	 $LN2@GCIemSend
$LN6@GCIemSend:

; 259  : }

  011a8	5f		 pop	 edi
  011a9	5e		 pop	 esi
  011aa	5b		 pop	 ebx
  011ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011ae	33 cd		 xor	 ecx, ebp
  011b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011b5	8b e5		 mov	 esp, ebp
  011b7	5d		 pop	 ebp
  011b8	c2 04 00	 ret	 4
?GCIemSend@CSmithy@@QAEXH@Z ENDP			; CSmithy::GCIemSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -104						; size = 4
_pMsg$ = -36						; size = 26
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCSettingsSend@CSmithy@@QAEXH@Z PROC			; CSmithy::GCSettingsSend
; _this$ = ecx

; 262  : {

  011c0	55		 push	 ebp
  011c1	8b ec		 mov	 ebp, esp
  011c3	83 ec 68	 sub	 esp, 104		; 00000068H
  011c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  011cb	33 c5		 xor	 eax, ebp
  011cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  011d0	53		 push	 ebx
  011d1	56		 push	 esi
  011d2	57		 push	 edi
  011d3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 263  : 	if(OBJMAX_RANGE(aIndex) == 0)

  011d6	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  011da	7d 09		 jge	 SHORT $LN4@GCSettings
  011dc	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  011e3	eb 0f		 jmp	 SHORT $LN5@GCSettings
$LN4@GCSettings:
  011e5	33 c0		 xor	 eax, eax
  011e7	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  011ee	0f 9e c0	 setle	 al
  011f1	89 45 98	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GCSettings:
  011f4	83 7d 98 00	 cmp	 DWORD PTR tv67[ebp], 0
  011f8	75 05		 jne	 SHORT $LN1@GCSettings

; 264  : 	{
; 265  : 		return;

  011fa	e9 9d 00 00 00	 jmp	 $LN2@GCSettings
$LN1@GCSettings:

; 266  : 	}
; 267  : 
; 268  : 	GC_SmithySettings pMsg;
; 269  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x1C,  sizeof(pMsg));

  011ff	6a 1a		 push	 26			; 0000001aH
  01201	6a 1c		 push	 28			; 0000001cH
  01203	68 fb 00 00 00	 push	 251			; 000000fbH
  01208	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0120b	50		 push	 eax
  0120c	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0120f	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 270  : 	pMsg.MaxLevel = this->MaxLevel;

  01214	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01217	8a 08		 mov	 cl, BYTE PTR [eax]
  01219	88 4d e0	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 271  : 	pMsg.LevelPrice = this->LevelPrice;

  0121c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0121f	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  01223	66 89 4d e2	 mov	 WORD PTR _pMsg$[ebp+6], cx

; 272  : 	pMsg.LuckPrice = this->LuckPrice;

  01227	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0122a	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0122e	66 89 4d e4	 mov	 WORD PTR _pMsg$[ebp+8], cx

; 273  : 	pMsg.AddPrice = this->AddPrice;

  01232	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01235	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  01239	66 89 4d e6	 mov	 WORD PTR _pMsg$[ebp+10], cx

; 274  : 	pMsg.Opt1Price = this->Opt1Price;

  0123d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01240	66 8b 48 08	 mov	 cx, WORD PTR [eax+8]
  01244	66 89 4d e8	 mov	 WORD PTR _pMsg$[ebp+12], cx

; 275  : 	pMsg.Opt2Price = this->Opt2Price;

  01248	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0124b	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  0124f	66 89 4d ea	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 276  : 	pMsg.Opt3Price = this->Opt3Price;

  01253	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01256	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  0125a	66 89 4d ec	 mov	 WORD PTR _pMsg$[ebp+16], cx

; 277  : 	pMsg.Opt4Price = this->Opt4Price;

  0125e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01261	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  01265	66 89 4d ee	 mov	 WORD PTR _pMsg$[ebp+18], cx

; 278  : 	pMsg.Opt5Price = this->Opt5Price;

  01269	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0126c	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  01270	66 89 4d f0	 mov	 WORD PTR _pMsg$[ebp+20], cx

; 279  : 	pMsg.Opt6Price = this->Opt6Price;

  01274	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01277	66 8b 48 12	 mov	 cx, WORD PTR [eax+18]
  0127b	66 89 4d f2	 mov	 WORD PTR _pMsg$[ebp+22], cx

; 280  : 	pMsg.MaxExlOpt = this->MaxExlOpt;

  0127f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01282	66 8b 48 14	 mov	 cx, WORD PTR [eax+20]
  01286	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+24], cx

; 281  : 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  0128a	6a 1a		 push	 26			; 0000001aH
  0128c	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0128f	50		 push	 eax
  01290	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01293	51		 push	 ecx
  01294	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01299	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCSettings:

; 282  : }

  0129c	5f		 pop	 edi
  0129d	5e		 pop	 esi
  0129e	5b		 pop	 ebx
  0129f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012a2	33 cd		 xor	 ecx, ebp
  012a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012a9	8b e5		 mov	 esp, ebp
  012ab	5d		 pop	 ebp
  012ac	c2 04 00	 ret	 4
?GCSettingsSend@CSmithy@@QAEXH@Z ENDP			; CSmithy::GCSettingsSend
_TEXT	ENDS
PUBLIC	??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@ ; `string'
PUBLIC	??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@ ; `string'
PUBLIC	?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z ; CSmithy::CGCreateItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ExUserDataSend@@YAXH@Z:PROC			; ExUserDataSend
EXTRN	?BuyDonateShopItem@CAchievements@@QAEXHH@Z:PROC	; CAchievements::BuyDonateShopItem
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; CheckInventoryEmptySpace
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@
CONST	SEGMENT
??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@ DB '[Smithy]: Crea'
	DB	'te Item', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@ DB '[Smithy]: Pr'
	DB	'ice: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@
CONST	SEGMENT
??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@ DB '[Smi'
	DB	'thy]: Need space in the inventory (%dx%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv69 = -112						; size = 4
_iWidth$ = -44						; size = 4
_iHeight$ = -40						; size = 4
_NewOption$ = -33					; size = 1
_result$ = -32						; size = 4
_iType$ = -28						; size = 2
_smItem$ = -24						; size = 8
_id$ = -16						; size = 2
_lpUser$ = -12						; size = 4
_iTotalExlOpt$ = -8					; size = 4
_this$ = -4						; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z PROC ; CSmithy::CGCreateItem
; _this$ = ecx

; 285  : {

  012b0	55		 push	 ebp
  012b1	8b ec		 mov	 ebp, esp
  012b3	83 ec 70	 sub	 esp, 112		; 00000070H
  012b6	53		 push	 ebx
  012b7	56		 push	 esi
  012b8	57		 push	 edi
  012b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 	if(!g_ExLicense.user.Smithy)

  012bc	0f b6 05 dc 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+220
  012c3	85 c0		 test	 eax, eax
  012c5	75 05		 jne	 SHORT $LN20@CGCreateIt

; 287  : 	{
; 288  : 		return;

  012c7	e9 f7 03 00 00	 jmp	 $LN21@CGCreateIt
$LN20@CGCreateIt:

; 289  : 	}
; 290  : 	
; 291  : 	if(OBJMAX_RANGE(aIndex) == 0)

  012cc	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  012d0	7d 09		 jge	 SHORT $LN23@CGCreateIt
  012d2	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  012d9	eb 0f		 jmp	 SHORT $LN24@CGCreateIt
$LN23@CGCreateIt:
  012db	33 c0		 xor	 eax, eax
  012dd	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  012e4	0f 9e c0	 setle	 al
  012e7	89 45 90	 mov	 DWORD PTR tv69[ebp], eax
$LN24@CGCreateIt:
  012ea	83 7d 90 00	 cmp	 DWORD PTR tv69[ebp], 0
  012ee	75 05		 jne	 SHORT $LN19@CGCreateIt

; 292  : 	{
; 293  : 		return;

  012f0	e9 ce 03 00 00	 jmp	 $LN21@CGCreateIt
$LN19@CGCreateIt:

; 294  : 	}
; 295  : 
; 296  : 	int iTotalExlOpt = aRecv->ItemOpt1 + aRecv->ItemOpt2 + aRecv->ItemOpt3 + aRecv->ItemOpt4 + aRecv->ItemOpt5 + aRecv->ItemOpt6;

  012f5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  012f8	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  012fc	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  012ff	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  01303	03 c8		 add	 ecx, eax
  01305	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01308	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  0130c	03 c8		 add	 ecx, eax
  0130e	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01311	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  01315	03 c8		 add	 ecx, eax
  01317	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0131a	0f b6 42 0d	 movzx	 eax, BYTE PTR [edx+13]
  0131e	03 c8		 add	 ecx, eax
  01320	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01323	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  01327	03 c8		 add	 ecx, eax
  01329	89 4d f8	 mov	 DWORD PTR _iTotalExlOpt$[ebp], ecx

; 297  : 
; 298  : 	if(iTotalExlOpt > this->MaxExlOpt)

  0132c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0132f	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  01333	39 4d f8	 cmp	 DWORD PTR _iTotalExlOpt$[ebp], ecx
  01336	7e 05		 jle	 SHORT $LN18@CGCreateIt

; 299  : 	{
; 300  : 		return;

  01338	e9 86 03 00 00	 jmp	 $LN21@CGCreateIt
$LN18@CGCreateIt:

; 301  : 	}
; 302  : 
; 303  : 	LPOBJ lpUser = &gObj[aIndex];

  0133d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01340	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01346	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0134c	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 304  : 
; 305  : 	if(lpUser->Connected < PLAYER_PLAYING)

  0134f	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01352	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  01356	7d 05		 jge	 SHORT $LN17@CGCreateIt

; 306  : 	{
; 307  : 		return;

  01358	e9 66 03 00 00	 jmp	 $LN21@CGCreateIt
$LN17@CGCreateIt:

; 308  : 	}
; 309  : 
; 310  : 	unsigned short id = aRecv->Item;

  0135d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01360	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  01364	66 89 4d f0	 mov	 WORD PTR _id$[ebp], cx

; 311  : 
; 312  : 	if(id > itemdata.size())

  01368	0f b7 75 f0	 movzx	 esi, WORD PTR _id$[ebp]
  0136c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0136f	83 c1 18	 add	 ecx, 24			; 00000018H
  01372	e8 00 00 00 00	 call	 ?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
  01377	3b f0		 cmp	 esi, eax
  01379	76 05		 jbe	 SHORT $LN16@CGCreateIt

; 313  : 	{
; 314  : 		return;

  0137b	e9 43 03 00 00	 jmp	 $LN21@CGCreateIt
$LN16@CGCreateIt:

; 315  : 	}
; 316  : 
; 317  : 	SmithyDATA smItem =  this->itemdata[id];

  01380	0f b7 45 f0	 movzx	 eax, WORD PTR _id$[ebp]
  01384	50		 push	 eax
  01385	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01388	83 c1 18	 add	 ecx, 24			; 00000018H
  0138b	e8 00 00 00 00	 call	 ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
  01390	8b 08		 mov	 ecx, DWORD PTR [eax]
  01392	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01395	89 4d e8	 mov	 DWORD PTR _smItem$[ebp], ecx
  01398	89 55 ec	 mov	 DWORD PTR _smItem$[ebp+4], edx

; 318  : 
; 319  : 	short iType = ITEMGET(smItem.Type,smItem.Index);

  0139b	0f b6 45 e9	 movzx	 eax, BYTE PTR _smItem$[ebp+1]
  0139f	c1 e0 09	 shl	 eax, 9
  013a2	0f b6 4d ea	 movzx	 ecx, BYTE PTR _smItem$[ebp+2]
  013a6	03 c1		 add	 eax, ecx
  013a8	66 89 45 e4	 mov	 WORD PTR _iType$[ebp], ax

; 320  : 
; 321  : 	int result = smItem.Price;

  013ac	8b 45 ec	 mov	 eax, DWORD PTR _smItem$[ebp+4]
  013af	89 45 e0	 mov	 DWORD PTR _result$[ebp], eax

; 322  : 	result += aRecv->ItemLevel * this->LevelPrice;

  013b2	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  013b5	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  013b9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013bc	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  013c0	0f af c8	 imul	 ecx, eax
  013c3	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  013c6	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 323  : 	result += aRecv->ItemAdd * this->AddPrice;

  013c9	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  013cc	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  013d0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013d3	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  013d7	0f af c8	 imul	 ecx, eax
  013da	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  013dd	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 324  : 	BYTE NewOption = 0;

  013e0	c6 45 df 00	 mov	 BYTE PTR _NewOption$[ebp], 0

; 325  : 
; 326  : 	if(aRecv->ItemLuck)

  013e4	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  013e7	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  013eb	85 c9		 test	 ecx, ecx
  013ed	74 0d		 je	 SHORT $LN15@CGCreateIt

; 327  : 	{
; 328  : 		result += this->LuckPrice;

  013ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013f2	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  013f6	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  013f9	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx
$LN15@CGCreateIt:

; 329  : 	}
; 330  : 	if(aRecv->ItemOpt1)

  013fc	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  013ff	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  01403	85 c9		 test	 ecx, ecx
  01405	74 17		 je	 SHORT $LN14@CGCreateIt

; 331  : 	{
; 332  : 		result += this->Opt1Price;

  01407	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0140a	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  0140e	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  01411	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 333  : 		 NewOption |= 0x20;

  01414	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  01418	83 c8 20	 or	 eax, 32			; 00000020H
  0141b	88 45 df	 mov	 BYTE PTR _NewOption$[ebp], al
$LN14@CGCreateIt:

; 334  : 	}
; 335  : 	if(aRecv->ItemOpt2)

  0141e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01421	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  01425	85 c9		 test	 ecx, ecx
  01427	74 17		 je	 SHORT $LN13@CGCreateIt

; 336  : 	{
; 337  : 		result += this->Opt2Price;

  01429	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0142c	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  01430	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  01433	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 338  : 		NewOption |= 0x10;

  01436	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  0143a	83 c8 10	 or	 eax, 16			; 00000010H
  0143d	88 45 df	 mov	 BYTE PTR _NewOption$[ebp], al
$LN13@CGCreateIt:

; 339  : 	}
; 340  : 	if(aRecv->ItemOpt3)

  01440	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01443	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  01447	85 c9		 test	 ecx, ecx
  01449	74 17		 je	 SHORT $LN12@CGCreateIt

; 341  : 	{
; 342  : 		result += this->Opt3Price;

  0144b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0144e	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  01452	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  01455	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 343  : 		NewOption |= 0x08;

  01458	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  0145c	83 c8 08	 or	 eax, 8
  0145f	88 45 df	 mov	 BYTE PTR _NewOption$[ebp], al
$LN12@CGCreateIt:

; 344  : 	}
; 345  : 	if(aRecv->ItemOpt4)

  01462	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01465	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  01469	85 c9		 test	 ecx, ecx
  0146b	74 17		 je	 SHORT $LN11@CGCreateIt

; 346  : 	{
; 347  : 		result += this->Opt4Price;

  0146d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01470	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  01474	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  01477	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 348  : 		NewOption |= 0x04;

  0147a	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  0147e	83 c8 04	 or	 eax, 4
  01481	88 45 df	 mov	 BYTE PTR _NewOption$[ebp], al
$LN11@CGCreateIt:

; 349  : 	}
; 350  : 	if(aRecv->ItemOpt5)

  01484	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01487	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  0148b	85 c9		 test	 ecx, ecx
  0148d	74 17		 je	 SHORT $LN10@CGCreateIt

; 351  : 	{
; 352  : 		result += this->Opt5Price;

  0148f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01492	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  01496	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  01499	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 353  : 		NewOption |= 0x02;

  0149c	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  014a0	83 c8 02	 or	 eax, 2
  014a3	88 45 df	 mov	 BYTE PTR _NewOption$[ebp], al
$LN10@CGCreateIt:

; 354  : 	}
; 355  : 	if(aRecv->ItemOpt6)

  014a6	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  014a9	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  014ad	85 c9		 test	 ecx, ecx
  014af	74 17		 je	 SHORT $LN9@CGCreateIt

; 356  : 	{
; 357  : 		result += this->Opt6Price;

  014b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014b4	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  014b8	03 4d e0	 add	 ecx, DWORD PTR _result$[ebp]
  014bb	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx

; 358  : 		NewOption |= 0x01;

  014be	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  014c2	83 c8 01	 or	 eax, 1
  014c5	88 45 df	 mov	 BYTE PTR _NewOption$[ebp], al
$LN9@CGCreateIt:

; 359  : 	}
; 360  : 
; 361  : 	int iHeight = ItemAttribute[iType].Height;

  014c8	0f bf 45 e4	 movsx	 eax, WORD PTR _iType$[ebp]
  014cc	6b c0 70	 imul	 eax, 112		; 00000070H
  014cf	0f b6 88 24 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+36]
  014d6	89 4d d8	 mov	 DWORD PTR _iHeight$[ebp], ecx

; 362  : 	int iWidth = ItemAttribute[iType].Width;

  014d9	0f bf 45 e4	 movsx	 eax, WORD PTR _iType$[ebp]
  014dd	6b c0 70	 imul	 eax, 112		; 00000070H
  014e0	0f b6 88 23 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+35]
  014e7	89 4d d4	 mov	 DWORD PTR _iWidth$[ebp], ecx

; 363  : 					
; 364  : 	if(CheckInventoryEmptySpace(lpUser,iHeight,iWidth) == false)

  014ea	8b 45 d4	 mov	 eax, DWORD PTR _iWidth$[ebp]
  014ed	50		 push	 eax
  014ee	8b 4d d8	 mov	 ecx, DWORD PTR _iHeight$[ebp]
  014f1	51		 push	 ecx
  014f2	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  014f5	52		 push	 edx
  014f6	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  014fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  014fe	85 c0		 test	 eax, eax
  01500	75 1e		 jne	 SHORT $LN8@CGCreateIt

; 365  : 	{
; 366  : 		MsgOutput(aIndex, "[Smithy]: Need space in the inventory (%dx%d)", iHeight, iWidth);

  01502	8b 45 d4	 mov	 eax, DWORD PTR _iWidth$[ebp]
  01505	50		 push	 eax
  01506	8b 4d d8	 mov	 ecx, DWORD PTR _iHeight$[ebp]
  01509	51		 push	 ecx
  0150a	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@
  0150f	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01512	52		 push	 edx
  01513	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  01518	83 c4 10	 add	 esp, 16			; 00000010H

; 367  : 		return;

  0151b	e9 a3 01 00 00	 jmp	 $LN21@CGCreateIt
$LN8@CGCreateIt:

; 368  : 	}
; 369  : 
; 370  : 	if(g_ExLicense.CheckUser(eExUB::Local)		  || 
; 371  : 		g_ExLicense.CheckUser(eExUB::SILVER1)	  || 
; 372  : 		g_ExLicense.CheckUser(eExUB::SILVER2)	  ||	
; 373  : 		g_ExLicense.CheckUser(eExUB::SILVER_Local) )

  01520	6a 00		 push	 0
  01522	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01527	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0152c	0f b6 c0	 movzx	 eax, al
  0152f	85 c0		 test	 eax, eax
  01531	75 39		 jne	 SHORT $LN6@CGCreateIt
  01533	6a 07		 push	 7
  01535	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0153a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0153f	0f b6 c0	 movzx	 eax, al
  01542	85 c0		 test	 eax, eax
  01544	75 26		 jne	 SHORT $LN6@CGCreateIt
  01546	6a 08		 push	 8
  01548	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0154d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01552	0f b6 c0	 movzx	 eax, al
  01555	85 c0		 test	 eax, eax
  01557	75 13		 jne	 SHORT $LN6@CGCreateIt
  01559	6a 2b		 push	 43			; 0000002bH
  0155b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01560	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01565	0f b6 c0	 movzx	 eax, al
  01568	85 c0		 test	 eax, eax
  0156a	74 46		 je	 SHORT $LN7@CGCreateIt
$LN6@CGCreateIt:

; 374  : 	{
; 375  : 		if(result > lpUser->ExCred)

  0156c	db 45 e0	 fild	 DWORD PTR _result$[ebp]
  0156f	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01572	d9 80 a8 22 00
	00		 fld	 DWORD PTR [eax+8872]
  01578	de d9		 fcompp
  0157a	df e0		 fnstsw	 ax
  0157c	f6 c4 05	 test	 ah, 5
  0157f	7a 1a		 jp	 SHORT $LN5@CGCreateIt

; 376  : 		{
; 377  : 			MsgOutput(aIndex, "[Smithy]: Price: %d", result);

  01581	8b 45 e0	 mov	 eax, DWORD PTR _result$[ebp]
  01584	50		 push	 eax
  01585	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@
  0158a	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0158d	51		 push	 ecx
  0158e	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  01593	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 			return;

  01596	e9 28 01 00 00	 jmp	 $LN21@CGCreateIt
$LN5@CGCreateIt:

; 379  : 		}
; 380  : 		lpUser->ExCred -= result;

  0159b	db 45 e0	 fild	 DWORD PTR _result$[ebp]
  0159e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  015a1	d8 a8 a8 22 00
	00		 fsubr	 DWORD PTR [eax+8872]
  015a7	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  015aa	d9 99 a8 22 00
	00		 fstp	 DWORD PTR [ecx+8872]

; 381  : 	}
; 382  : 	else

  015b0	eb 52		 jmp	 SHORT $LN4@CGCreateIt
$LN7@CGCreateIt:

; 383  : 	{
; 384  : 		if(result > lpUser->GameShop.WCoinC)

  015b2	db 45 e0	 fild	 DWORD PTR _result$[ebp]
  015b5	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  015b8	dc 98 00 23 00
	00		 fcomp	 QWORD PTR [eax+8960]
  015be	df e0		 fnstsw	 ax
  015c0	f6 c4 41	 test	 ah, 65			; 00000041H
  015c3	75 1a		 jne	 SHORT $LN3@CGCreateIt

; 385  : 		{
; 386  : 			MsgOutput(aIndex, "[Smithy]: Price: %d", result);

  015c5	8b 45 e0	 mov	 eax, DWORD PTR _result$[ebp]
  015c8	50		 push	 eax
  015c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@
  015ce	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  015d1	51		 push	 ecx
  015d2	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  015d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 387  : 			return;

  015da	e9 e4 00 00 00	 jmp	 $LN21@CGCreateIt
$LN3@CGCreateIt:

; 388  : 		}
; 389  : 		lpUser->GameShop.WCoinC -= result;

  015df	db 45 e0	 fild	 DWORD PTR _result$[ebp]
  015e2	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  015e5	dc a8 00 23 00
	00		 fsubr	 QWORD PTR [eax+8960]
  015eb	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  015ee	dd 99 00 23 00
	00		 fstp	 QWORD PTR [ecx+8960]

; 390  : 		gGameShop.GDSaveUserInfo(lpUser->m_Index);

  015f4	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  015f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  015f9	51		 push	 ecx
  015fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  015ff	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN4@CGCreateIt:

; 391  : 	}
; 392  : 
; 393  : #if(SYSTEM_ACHIEVEMENTS)
; 394  : 	if(g_ExLicense.CheckUser(eExUB::Gredy) || g_ExLicense.CheckUser(eExUB::Gredy2) || g_ExLicense.CheckUser(eExUB::GredyLocal))

  01604	6a 20		 push	 32			; 00000020H
  01606	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0160b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01610	0f b6 c0	 movzx	 eax, al
  01613	85 c0		 test	 eax, eax
  01615	75 26		 jne	 SHORT $LN1@CGCreateIt
  01617	6a 22		 push	 34			; 00000022H
  01619	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0161e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01623	0f b6 c0	 movzx	 eax, al
  01626	85 c0		 test	 eax, eax
  01628	75 13		 jne	 SHORT $LN1@CGCreateIt
  0162a	6a 21		 push	 33			; 00000021H
  0162c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01631	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01636	0f b6 c0	 movzx	 eax, al
  01639	85 c0		 test	 eax, eax
  0163b	74 12		 je	 SHORT $LN2@CGCreateIt
$LN1@CGCreateIt:

; 395  : 	{
; 396  : 		g_Achievements.BuyDonateShopItem(aIndex, result);

  0163d	8b 45 e0	 mov	 eax, DWORD PTR _result$[ebp]
  01640	50		 push	 eax
  01641	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01644	51		 push	 ecx
  01645	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  0164a	e8 00 00 00 00	 call	 ?BuyDonateShopItem@CAchievements@@QAEXHH@Z ; CAchievements::BuyDonateShopItem
$LN2@CGCreateIt:

; 397  : 	}
; 398  : #endif
; 399  : 
; 400  : 	ExUserDataSend(aIndex);

  0164f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01652	50		 push	 eax
  01653	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  01658	83 c4 04	 add	 esp, 4

; 401  : 	ItemSerialCreateSend(aIndex, 235, lpUser->X, lpUser->Y, iType, aRecv->ItemLevel, 0, 1, aRecv->ItemLuck, aRecv->ItemAdd, aIndex, NewOption, 0);

  0165b	6a 00		 push	 0
  0165d	0f b6 45 df	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  01661	50		 push	 eax
  01662	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01665	51		 push	 ecx
  01666	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01669	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  0166d	50		 push	 eax
  0166e	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01671	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  01675	52		 push	 edx
  01676	6a 01		 push	 1
  01678	6a 00		 push	 0
  0167a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0167d	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  01681	51		 push	 ecx
  01682	0f bf 55 e4	 movsx	 edx, WORD PTR _iType$[ebp]
  01686	52		 push	 edx
  01687	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0168a	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  01691	51		 push	 ecx
  01692	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  01695	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  0169c	50		 push	 eax
  0169d	68 eb 00 00 00	 push	 235			; 000000ebH
  016a2	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  016a5	51		 push	 ecx
  016a6	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  016ab	83 c4 34	 add	 esp, 52			; 00000034H

; 402  : 	MsgOutput(aIndex, "[Smithy]: Create Item", result);

  016ae	8b 45 e0	 mov	 eax, DWORD PTR _result$[ebp]
  016b1	50		 push	 eax
  016b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@
  016b7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  016ba	51		 push	 ecx
  016bb	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  016c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@CGCreateIt:

; 403  : }

  016c3	5f		 pop	 edi
  016c4	5e		 pop	 esi
  016c5	5b		 pop	 ebx
  016c6	8b e5		 mov	 esp, ebp
  016c8	5d		 pop	 ebp
  016c9	c2 08 00	 ret	 8
?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z ENDP ; CSmithy::CGCreateItem
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
PUBLIC	??0?$allocator@USmithyDATA@@@std@@QAE@XZ	; std::allocator<SmithyDATA>::allocator<SmithyDATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T229855 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T229855[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@USmithyDATA@@@std@@QAE@XZ ; std::allocator<SmithyDATA>::allocator<SmithyDATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
PUBLIC	?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
__ehhandler$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
PUBLIC	??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>
PUBLIC	?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
PUBLIC	?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside
PUBLIC	??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z ; std::addressof<SmithyDATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z
_TEXT	SEGMENT
__Idx$228853 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z ; std::addressof<SmithyDATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z ; std::addressof<SmithyDATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$228853[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$228853[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase
PUBLIC	?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin
PUBLIC	?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T229874 = -88						; size = 4
$T229875 = -84						; size = 4
$T229876 = -80						; size = 4
$T229877 = -76						; size = 4
$T229878 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T229875[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T229874[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T229877[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T229876[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T229874[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T229876[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T229878[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy
PUBLIC	??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z ; std::_Move<SmithyDATA *,SmithyDATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T229885 = -84						; size = 4
__Ptr$229044 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z ; std::_Move<SmithyDATA *,SmithyDATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$229044[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$229044[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$229044[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T229885[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T229885[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
PUBLIC	?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to
PUBLIC	?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
PUBLIC	?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen
PUBLIC	?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z	; std::allocator<SmithyDATA>::allocator<SmithyDATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z PROC ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z ; std::allocator<SmithyDATA>::allocator<SmithyDATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z ENDP ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@USmithyDATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@USmithyDATA@@@std@@QAE@XZ PROC		; std::allocator<SmithyDATA>::allocator<SmithyDATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@USmithyDATA@@@std@@QAE@XZ ENDP		; std::allocator<SmithyDATA>::allocator<SmithyDATA>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>
PUBLIC	?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$229086 = -28					; size = 4
__Ptr$229079 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$229079[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$229079[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229079[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$229086[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229079[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$229086[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229079[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229079[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ	; std::allocator<SmithyDATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ ; std::allocator<SmithyDATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z ; std::_Destroy_range<std::allocator<SmithyDATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z ; std::_Destroy_range<std::allocator<SmithyDATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<SmithyDATA>::allocator<SmithyDATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<SmithyDATA>::allocator<SmithyDATA>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z PROC ; std::allocator<SmithyDATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ENDP ; std::allocator<SmithyDATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z ; std::_Allocate<SmithyDATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z PROC ; std::allocator<SmithyDATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z ; std::_Allocate<SmithyDATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z ENDP ; std::allocator<SmithyDATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ PROC	; std::allocator<SmithyDATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ ENDP	; std::allocator<SmithyDATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z PROC ; std::addressof<SmithyDATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z ENDP ; std::addressof<SmithyDATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z ; std::allocator<SmithyDATA>::construct<SmithyDATA &>
PUBLIC	??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z ; std::allocator<SmithyDATA>::construct<SmithyDATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z ; std::allocator<SmithyDATA>::construct
PUBLIC	??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z ; std::forward<SmithyDATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z ; std::forward<SmithyDATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z ; std::allocator<SmithyDATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<SmithyDATA *,SmithyDATA *>
PUBLIC	??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z
_TEXT	SEGMENT
$T229960 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z PROC ; std::_Move<SmithyDATA *,SmithyDATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T229960[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T229960[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<SmithyDATA *,SmithyDATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z ENDP ; std::_Move<SmithyDATA *,SmithyDATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<SmithyDATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z
_TEXT	SEGMENT
$T229965 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SmithyDATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T229965[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T229965[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<SmithyDATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z
_TEXT	SEGMENT
$T229968 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z PROC ; std::_Allocate<SmithyDATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T229968[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T229968[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z ENDP ; std::_Allocate<SmithyDATA>
_TEXT	ENDS
PUBLIC	??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z ; std::_Construct<SmithyDATA,SmithyDATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z PROC ; std::allocator<SmithyDATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z ; std::_Construct<SmithyDATA,SmithyDATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z ENDP ; std::allocator<SmithyDATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z PROC ; std::forward<SmithyDATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z ENDP ; std::forward<SmithyDATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T229975 = -88						; size = 4
$T229976 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z PROC ; std::allocator<SmithyDATA>::construct<SmithyDATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T229976[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T229976[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T229976[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T229976[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T229975[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T229976[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z ENDP ; std::allocator<SmithyDATA>::construct<SmithyDATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z PROC ; std::forward<SmithyDATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z ENDP ; std::forward<SmithyDATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z PROC ; std::_Ptr_cat<SmithyDATA,SmithyDATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ENDP ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
_TEXT	ENDS
PUBLIC	??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::move<SmithyDATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<SmithyDATA *,SmithyDATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::move<SmithyDATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<SmithyDATA *,SmithyDATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
PUBLIC	??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z ; std::_Val_type<SmithyDATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z
_TEXT	SEGMENT
$T229998 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z PROC ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T229998[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T229998[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z ; std::_Val_type<SmithyDATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z ENDP ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<SmithyDATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<SmithyDATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T230003 = -88						; size = 4
$T230004 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z PROC ; std::_Construct<SmithyDATA,SmithyDATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T230004[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T230004[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z ; std::forward<SmithyDATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T230004[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T230004[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T230003[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T230004[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z ENDP ; std::_Construct<SmithyDATA,SmithyDATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z PROC ; std::move<SmithyDATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ENDP ; std::move<SmithyDATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z PROC ; std::_Val_type<SmithyDATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z ENDP ; std::_Val_type<SmithyDATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
PUBLIC	?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z ; std::allocator<SmithyDATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z PROC ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z ; std::allocator<SmithyDATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z ENDP ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z ; std::_Destroy<SmithyDATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z PROC ; std::allocator<SmithyDATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z ; std::_Destroy<SmithyDATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z ENDP ; std::allocator<SmithyDATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z ; std::allocator<SmithyDATA>::construct
PUBLIC	??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z ; std::allocator<SmithyDATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z PROC ; std::_Destroy<SmithyDATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z ENDP ; std::_Destroy<SmithyDATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T230043 = -88						; size = 4
$T230044 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z PROC ; std::allocator<SmithyDATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T230044[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T230044[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T230044[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T230044[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T230043[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T230044[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z ENDP ; std::allocator<SmithyDATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z PROC ; std::forward<SmithyDATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ENDP ; std::forward<SmithyDATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\smithy.cpp
;	COMDAT ??__Eg_Smithy@@YAXXZ
text$yc	SEGMENT
??__Eg_Smithy@@YAXXZ PROC				; `dynamic initializer for 'g_Smithy'', COMDAT

; 13   : CSmithy g_Smithy;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Smithy@@3VCSmithy@@A ; g_Smithy
  0000e	e8 00 00 00 00	 call	 ??0CSmithy@@QAE@XZ	; CSmithy::CSmithy
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_Smithy@@YAXXZ ; `dynamic atexit destructor for 'g_Smithy''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_Smithy@@YAXXZ ENDP				; `dynamic initializer for 'g_Smithy''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_Smithy@@YAXXZ
text$yd	SEGMENT
??__Fg_Smithy@@YAXXZ PROC				; `dynamic atexit destructor for 'g_Smithy'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Smithy@@3VCSmithy@@A ; g_Smithy
  0000e	e8 00 00 00 00	 call	 ??1CSmithy@@QAE@XZ	; CSmithy::~CSmithy
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_Smithy@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_Smithy''
text$yd	ENDS
PUBLIC	?g_Smithy@@3VCSmithy@@A				; g_Smithy
_BSS	SEGMENT
?g_Smithy@@3VCSmithy@@A DB 028H DUP (?)			; g_Smithy
_BSS	ENDS
CRT$XCU	SEGMENT
_g_Smithy$initializer$ DD FLAT:??__Eg_Smithy@@YAXXZ
CRT$XCU	ENDS
END
