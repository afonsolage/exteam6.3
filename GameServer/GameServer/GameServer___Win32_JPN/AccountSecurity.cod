; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\AccountSecurity.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Init@CAccountSecurity@@QAEXXZ			; CAccountSecurity::Init
PUBLIC	??0CAccountSecurity@@QAE@XZ			; CAccountSecurity::CAccountSecurity
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\accountsecurity.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAccountSecurity@@QAE@XZ PROC			; CAccountSecurity::CAccountSecurity
; _this$ = ecx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 16   : 	this->Init();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Init@CAccountSecurity@@QAEXXZ ; CAccountSecurity::Init

; 17   : }

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CAccountSecurity@@QAE@XZ ENDP			; CAccountSecurity::CAccountSecurity
_TEXT	ENDS
PUBLIC	??1CAccountSecurity@@QAE@XZ			; CAccountSecurity::~CAccountSecurity
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CAccountSecurity@@QAE@XZ PROC			; CAccountSecurity::~CAccountSecurity
; _this$ = ecx

; 20   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1CAccountSecurity@@QAE@XZ ENDP			; CAccountSecurity::~CAccountSecurity
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?Init@CAccountSecurity@@QAEXXZ PROC			; CAccountSecurity::Init
; _this$ = ecx

; 24   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 	this->m_bEnable = false;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 26   : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?Init@CAccountSecurity@@QAEXXZ ENDP			; CAccountSecurity::Init
_TEXT	ENDS
PUBLIC	??_C@_06MLPMCPDE@ExTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0BL@NBLNDCPB@ExData?2AccountSecurity?4ini?$AA@ ; `string'
PUBLIC	?Load@CAccountSecurity@@QAEXXZ			; CAccountSecurity::Load
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_06MLPMCPDE@ExTeam?$AA@
CONST	SEGMENT
??_C@_06MLPMCPDE@ExTeam?$AA@ DB 'ExTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NBLNDCPB@ExData?2AccountSecurity?4ini?$AA@
CONST	SEGMENT
??_C@_0BL@NBLNDCPB@ExData?2AccountSecurity?4ini?$AA@ DB 'ExData\AccountSe'
	DB	'curity.ini', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CAccountSecurity@@QAEXXZ PROC			; CAccountSecurity::Load
; _this$ = ecx

; 29   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	83 ec 44	 sub	 esp, 68			; 00000044H
  00066	53		 push	 ebx
  00067	56		 push	 esi
  00068	57		 push	 edi
  00069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	this->Init();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?Init@CAccountSecurity@@QAEXXZ ; CAccountSecurity::Init

; 31   : 
; 32   : 	if(!g_ExLicense.user.AccSecurity)

  00074	0f b6 05 eb 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+235
  0007b	85 c0		 test	 eax, eax
  0007d	75 02		 jne	 SHORT $LN1@Load

; 33   : 	{
; 34   : 		return;

  0007f	eb 2c		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 35   : 	}
; 36   : 
; 37   : 	this->m_bEnable = GetPrivateProfileInt("ExTeam", "Enable", 0, gDirPath.GetNewPath("ExData\\AccountSecurity.ini"));

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NBLNDCPB@ExData?2AccountSecurity?4ini?$AA@
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0008b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00090	50		 push	 eax
  00091	6a 00		 push	 0
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000a3	85 c0		 test	 eax, eax
  000a5	0f 95 c0	 setne	 al
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	88 01		 mov	 BYTE PTR [ecx], al
$LN2@Load:

; 38   : 
; 39   : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?Load@CAccountSecurity@@QAEXXZ ENDP			; CAccountSecurity::Load
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqLoad@CAccountSecurity@@QAEXH@Z		; CAccountSecurity::GDReqLoad
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	_memcpy:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -100						; size = 4
_pMsg$ = -32						; size = 18
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqLoad@CAccountSecurity@@QAEXH@Z PROC		; CAccountSecurity::GDReqLoad
; _this$ = ecx

; 42   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 64	 sub	 esp, 100		; 00000064H
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000cb	33 c5		 xor	 eax, ebp
  000cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000d0	53		 push	 ebx
  000d1	56		 push	 esi
  000d2	57		 push	 edi
  000d3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 	if(!this->m_bEnable)

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000dc	85 c9		 test	 ecx, ecx
  000de	75 02		 jne	 SHORT $LN2@GDReqLoad

; 44   : 	{
; 45   : 		return;

  000e0	eb 7e		 jmp	 SHORT $LN3@GDReqLoad
$LN2@GDReqLoad:

; 46   : 	}
; 47   : 
; 48   : 	if(!OBJMAX_RANGE(aIndex))

  000e2	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  000e6	7d 09		 jge	 SHORT $LN5@GDReqLoad
  000e8	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  000ef	eb 0f		 jmp	 SHORT $LN6@GDReqLoad
$LN5@GDReqLoad:
  000f1	33 c0		 xor	 eax, eax
  000f3	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  000fa	0f 9e c0	 setle	 al
  000fd	89 45 9c	 mov	 DWORD PTR tv69[ebp], eax
$LN6@GDReqLoad:
  00100	83 7d 9c 00	 cmp	 DWORD PTR tv69[ebp], 0
  00104	75 02		 jne	 SHORT $LN1@GDReqLoad

; 49   : 	{
; 50   : 		return;

  00106	eb 58		 jmp	 SHORT $LN3@GDReqLoad
$LN1@GDReqLoad:

; 51   : 	}
; 52   : 
; 53   : 	LPOBJ lpUser = &gObj[aIndex];

  00108	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0010b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00111	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00117	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 54   : 
; 55   : 	PMSG_REQ_ACC_DATABASE_LOAD pMsg;
; 56   : 	pMsg.h.set((LPBYTE)&pMsg, 0xEF, 0x00, sizeof(pMsg));

  0011a	6a 12		 push	 18			; 00000012H
  0011c	6a 00		 push	 0
  0011e	68 ef 00 00 00	 push	 239			; 000000efH
  00123	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00126	50		 push	 eax
  00127	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0012a	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 57   : 	pMsg.aIndex = aIndex;

  0012f	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  00133	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 58   : 	pMsg.Account[10] = 0;

  00137	c6 45 f0 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0

; 59   : 	memcpy(pMsg.Account, lpUser->AccountID, sizeof(pMsg.Account)-1);

  0013b	6a 0a		 push	 10			; 0000000aH
  0013d	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00140	83 c0 6c	 add	 eax, 108		; 0000006cH
  00143	50		 push	 eax
  00144	8d 4d e6	 lea	 ecx, DWORD PTR _pMsg$[ebp+6]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 _memcpy
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  00150	6a 12		 push	 18			; 00000012H
  00152	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00155	50		 push	 eax
  00156	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0015b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqLoad:

; 61   : }

  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 04 00	 ret	 4
?GDReqLoad@CAccountSecurity@@QAEXH@Z ENDP		; CAccountSecurity::GDReqLoad
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z	; CAccountSecurity::GCSendAccountInfo
PUBLIC	?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckOnlyMyPC
PUBLIC	?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z ; CAccountSecurity::DGAnsLoad
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\accountsecurity.cpp
_TEXT	SEGMENT
tv69 = -80						; size = 4
_lpUser$ = -12						; size = 4
_aIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z PROC ; CAccountSecurity::DGAnsLoad
; _this$ = ecx

; 64   : {

  00180	55		 push	 ebp
  00181	8b ec		 mov	 ebp, esp
  00183	83 ec 50	 sub	 esp, 80			; 00000050H
  00186	53		 push	 ebx
  00187	56		 push	 esi
  00188	57		 push	 edi
  00189	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 	int aIndex = lpMsg->aIndex;

  0018c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0018f	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00193	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 66   : 
; 67   : 	if(!OBJMAX_RANGE(aIndex))

  00196	83 7d f8 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0019a	7d 09		 jge	 SHORT $LN5@DGAnsLoad
  0019c	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  001a3	eb 0f		 jmp	 SHORT $LN6@DGAnsLoad
$LN5@DGAnsLoad:
  001a5	33 c0		 xor	 eax, eax
  001a7	81 7d f8 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  001ae	0f 9e c0	 setle	 al
  001b1	89 45 b0	 mov	 DWORD PTR tv69[ebp], eax
$LN6@DGAnsLoad:
  001b4	83 7d b0 00	 cmp	 DWORD PTR tv69[ebp], 0
  001b8	75 05		 jne	 SHORT $LN2@DGAnsLoad

; 68   : 	{
; 69   : 		return;

  001ba	e9 e4 00 00 00	 jmp	 $LN3@DGAnsLoad
$LN2@DGAnsLoad:

; 70   : 	}
; 71   : 
; 72   : 	LPOBJ lpUser = &gObj[aIndex];

  001bf	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001c2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001c8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ce	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 73   : 
; 74   : 	lpUser->AccountSecurity.ActivePCID = lpMsg->ActivePCID;

  001d1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001d4	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  001d8	0f 95 c1	 setne	 cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001de	88 8a fc 29 00
	00		 mov	 BYTE PTR [edx+10748], cl

; 75   : 	lpUser->AccountSecurity.ProtectPCID = lpMsg->ProtectPCID;

  001e4	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001e7	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001ea	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ed	89 90 04 2a 00
	00		 mov	 DWORD PTR [eax+10756], edx

; 76   : 	lpUser->AccountSecurity.SecretNumber = lpMsg->SecretNumber;

  001f3	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001f6	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001f9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001fc	89 90 08 2a 00
	00		 mov	 DWORD PTR [eax+10760], edx

; 77   : 	lpUser->AccountSecurity.OnlyMyPC = lpMsg->OnlyMyPC;

  00202	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00205	80 78 10 00	 cmp	 BYTE PTR [eax+16], 0
  00209	0f 95 c1	 setne	 cl
  0020c	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0020f	88 8a 0c 2a 00
	00		 mov	 BYTE PTR [edx+10764], cl

; 78   : 	lpUser->AccountSecurity.Trade = lpMsg->Trade;

  00215	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00218	80 78 11 00	 cmp	 BYTE PTR [eax+17], 0
  0021c	0f 95 c1	 setne	 cl
  0021f	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00222	88 8a 0d 2a 00
	00		 mov	 BYTE PTR [edx+10765], cl

; 79   : 	lpUser->AccountSecurity.Inventory = lpMsg->Inventory;

  00228	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0022b	80 78 12 00	 cmp	 BYTE PTR [eax+18], 0
  0022f	0f 95 c1	 setne	 cl
  00232	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00235	88 8a 0e 2a 00
	00		 mov	 BYTE PTR [edx+10766], cl

; 80   : 	lpUser->AccountSecurity.Werehouse = lpMsg->Werehouse;

  0023b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0023e	80 78 13 00	 cmp	 BYTE PTR [eax+19], 0
  00242	0f 95 c1	 setne	 cl
  00245	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00248	88 8a 0f 2a 00
	00		 mov	 BYTE PTR [edx+10767], cl

; 81   : 	lpUser->AccountSecurity.DisconnectFriend = lpMsg->DisconnectFriend;

  0024e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00251	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00255	0f 95 c1	 setne	 cl
  00258	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0025b	88 8a 10 2a 00
	00		 mov	 BYTE PTR [edx+10768], cl

; 82   : 	lpUser->AccountSecurity.SellChar = lpMsg->SellChar;

  00261	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00264	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00268	0f 95 c1	 setne	 cl
  0026b	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0026e	88 8a 11 2a 00
	00		 mov	 BYTE PTR [edx+10769], cl

; 83   : 
; 84   : #if(!DEBUG_ACCOUNT_SECURITY)
; 85   : 
; 86   : 	if(this->CheckOnlyMyPC(aIndex) == false)

  00274	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00277	50		 push	 eax
  00278	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027b	e8 00 00 00 00	 call	 ?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckOnlyMyPC
  00280	0f b6 c8	 movzx	 ecx, al
  00283	85 c9		 test	 ecx, ecx
  00285	75 10		 jne	 SHORT $LN1@DGAnsLoad

; 87   : 	{
; 88   : 		//GCServerMsgStringSend("[Account Security] Only Owner PC", aIndex, 0);
; 89   : 		//GCServerMsgStringSend("[Account Security] Only Owner PC", aIndex, 1);
; 90   : 		//GCJoinResult(0, aIndex);
; 91   : 		//gObjCloseSet(aIndex, 2);
; 92   : 		//Sleep(1000);
; 93   : 		GCCloseMsgSend(aIndex, 2);

  00287	6a 02		 push	 2
  00289	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00292	83 c4 08	 add	 esp, 8

; 94   : 
; 95   : 		//CloseClient(aIndex);
; 96   : 
; 97   : 		return;	

  00295	eb 0c		 jmp	 SHORT $LN3@DGAnsLoad
$LN1@DGAnsLoad:

; 98   : 	}
; 99   : 
; 100  : 	this->GCSendAccountInfo(aIndex);

  00297	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0029a	50		 push	 eax
  0029b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	e8 00 00 00 00	 call	 ?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GCSendAccountInfo
$LN3@DGAnsLoad:

; 101  : 
; 102  : #else
; 103  : 
; 104  : 	this->GCReqAccountConnect(aIndex);
; 105  : 
; 106  : #endif
; 107  : 
; 108  : }

  002a3	5f		 pop	 edi
  002a4	5e		 pop	 esi
  002a5	5b		 pop	 ebx
  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c2 04 00	 ret	 4
?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z ENDP ; CAccountSecurity::DGAnsLoad
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqSave@CAccountSecurity@@QAEXH@Z		; CAccountSecurity::GDReqSave
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -116						; size = 4
_pMsg$ = -48						; size = 36
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqSave@CAccountSecurity@@QAEXH@Z PROC		; CAccountSecurity::GDReqSave
; _this$ = ecx

; 111  : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	83 ec 74	 sub	 esp, 116		; 00000074H
  002b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  002bb	33 c5		 xor	 eax, ebp
  002bd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  002c0	53		 push	 ebx
  002c1	56		 push	 esi
  002c2	57		 push	 edi
  002c3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	if(!this->m_bEnable)

  002c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002c9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002cc	85 c9		 test	 ecx, ecx
  002ce	75 05		 jne	 SHORT $LN2@GDReqSave

; 113  : 	{
; 114  : 		return;

  002d0	e9 ed 00 00 00	 jmp	 $LN3@GDReqSave
$LN2@GDReqSave:

; 115  : 	}
; 116  : 
; 117  : 	if(!OBJMAX_RANGE(aIndex))

  002d5	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  002d9	7d 09		 jge	 SHORT $LN5@GDReqSave
  002db	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  002e2	eb 0f		 jmp	 SHORT $LN6@GDReqSave
$LN5@GDReqSave:
  002e4	33 c0		 xor	 eax, eax
  002e6	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  002ed	0f 9e c0	 setle	 al
  002f0	89 45 8c	 mov	 DWORD PTR tv69[ebp], eax
$LN6@GDReqSave:
  002f3	83 7d 8c 00	 cmp	 DWORD PTR tv69[ebp], 0
  002f7	75 05		 jne	 SHORT $LN1@GDReqSave

; 118  : 	{
; 119  : 		return;

  002f9	e9 c4 00 00 00	 jmp	 $LN3@GDReqSave
$LN1@GDReqSave:

; 120  : 	}
; 121  : 
; 122  : 	LPOBJ lpUser = &gObj[aIndex];

  002fe	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00301	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00307	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0030d	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 123  : 	PMSG_REQ_ACC_DATABASE_SAVE pMsg;
; 124  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEF, 0x01, sizeof(pMsg));

  00310	6a 24		 push	 36			; 00000024H
  00312	6a 01		 push	 1
  00314	68 ef 00 00 00	 push	 239			; 000000efH
  00319	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0031c	50		 push	 eax
  0031d	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00320	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 125  : 	pMsg.aIndex = aIndex;

  00325	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  00329	66 89 45 d4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 126  : 	pMsg.Account[10] = 0;

  0032d	c6 45 e0 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0

; 127  : 	memcpy(pMsg.Account, lpUser->AccountID, sizeof(pMsg.Account)-1);

  00331	6a 0a		 push	 10			; 0000000aH
  00333	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00336	83 c0 6c	 add	 eax, 108		; 0000006cH
  00339	50		 push	 eax
  0033a	8d 4d d6	 lea	 ecx, DWORD PTR _pMsg$[ebp+6]
  0033d	51		 push	 ecx
  0033e	e8 00 00 00 00	 call	 _memcpy
  00343	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 
; 129  : 	pMsg.ActivePCID = lpUser->AccountSecurity.ActivePCID;

  00346	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00349	8a 88 fc 29 00
	00		 mov	 cl, BYTE PTR [eax+10748]
  0034f	88 4d e1	 mov	 BYTE PTR _pMsg$[ebp+17], cl

; 130  : 	pMsg.ProtectPCID = lpUser->AccountSecurity.ProtectPCID;

  00352	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00355	8b 88 04 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10756]
  0035b	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+20], ecx

; 131  : 	pMsg.SecretNumber = lpUser->AccountSecurity.SecretNumber;

  0035e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00361	8b 88 08 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10760]
  00367	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+24], ecx

; 132  : 	pMsg.OnlyMyPC = lpUser->AccountSecurity.OnlyMyPC;

  0036a	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0036d	8a 88 0c 2a 00
	00		 mov	 cl, BYTE PTR [eax+10764]
  00373	88 4d ec	 mov	 BYTE PTR _pMsg$[ebp+28], cl

; 133  : 	pMsg.Trade = lpUser->AccountSecurity.Trade;

  00376	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00379	8a 88 0d 2a 00
	00		 mov	 cl, BYTE PTR [eax+10765]
  0037f	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+29], cl

; 134  : 	pMsg.Inventory = lpUser->AccountSecurity.Inventory;

  00382	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00385	8a 88 0e 2a 00
	00		 mov	 cl, BYTE PTR [eax+10766]
  0038b	88 4d ee	 mov	 BYTE PTR _pMsg$[ebp+30], cl

; 135  : 	pMsg.Werehouse = lpUser->AccountSecurity.Werehouse;

  0038e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00391	8a 88 0f 2a 00
	00		 mov	 cl, BYTE PTR [eax+10767]
  00397	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+31], cl

; 136  : 	pMsg.DisconnectFriend = lpUser->AccountSecurity.DisconnectFriend;

  0039a	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0039d	8a 88 10 2a 00
	00		 mov	 cl, BYTE PTR [eax+10768]
  003a3	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+32], cl

; 137  : 	pMsg.SellChar = lpUser->AccountSecurity.SellChar;

  003a6	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  003a9	8a 88 11 2a 00
	00		 mov	 cl, BYTE PTR [eax+10769]
  003af	88 4d f1	 mov	 BYTE PTR _pMsg$[ebp+33], cl

; 138  : 
; 139  : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  003b2	6a 24		 push	 36			; 00000024H
  003b4	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003b7	50		 push	 eax
  003b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  003bd	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqSave:

; 140  : }

  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c2 04 00	 ret	 4
?GDReqSave@CAccountSecurity@@QAEXH@Z ENDP		; CAccountSecurity::GDReqSave
_TEXT	ENDS
PUBLIC	?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z ; CAccountSecurity::DGAnsSave
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -76						; size = 4
_aIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z PROC ; CAccountSecurity::DGAnsSave
; _this$ = ecx

; 143  : {

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  003e6	53		 push	 ebx
  003e7	56		 push	 esi
  003e8	57		 push	 edi
  003e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 	int aIndex = lpMsg->aIndex;

  003ec	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003ef	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  003f3	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 145  : 
; 146  : 	if(!OBJMAX_RANGE(aIndex))

  003f6	83 7d f8 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  003fa	7d 09		 jge	 SHORT $LN5@DGAnsSave
  003fc	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00403	eb 0f		 jmp	 SHORT $LN6@DGAnsSave
$LN5@DGAnsSave:
  00405	33 c0		 xor	 eax, eax
  00407	81 7d f8 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0040e	0f 9e c0	 setle	 al
  00411	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN6@DGAnsSave:
  00414	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  00418	75 02		 jne	 SHORT $LN2@DGAnsSave

; 147  : 	{
; 148  : 		return;

  0041a	eb 17		 jmp	 SHORT $LN3@DGAnsSave
$LN2@DGAnsSave:

; 149  : 	}
; 150  : 
; 151  : 	if(lpMsg->Result)

  0041c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0041f	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00423	85 c9		 test	 ecx, ecx
  00425	74 0c		 je	 SHORT $LN3@DGAnsSave

; 152  : 	{
; 153  : 		this->GCSendAccountInfo(aIndex);

  00427	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0042a	50		 push	 eax
  0042b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0042e	e8 00 00 00 00	 call	 ?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GCSendAccountInfo
$LN3@DGAnsSave:

; 154  : 	}
; 155  : }

  00433	5f		 pop	 edi
  00434	5e		 pop	 esi
  00435	5b		 pop	 ebx
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	c2 04 00	 ret	 4
?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z ENDP ; CAccountSecurity::DGAnsSave
_TEXT	ENDS
PUBLIC	?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z ; CAccountSecurity::CGRecvAccountConnect
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z PROC ; CAccountSecurity::CGRecvAccountConnect
; _this$ = ecx

; 158  : {

  00440	55		 push	 ebp
  00441	8b ec		 mov	 ebp, esp
  00443	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00446	53		 push	 ebx
  00447	56		 push	 esi
  00448	57		 push	 edi
  00449	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 159  : 	if(!this->m_bEnable)

  0044c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0044f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00452	85 c9		 test	 ecx, ecx
  00454	75 02		 jne	 SHORT $LN2@CGRecvAcco

; 160  : 	{
; 161  : 		return;

  00456	eb 47		 jmp	 SHORT $LN3@CGRecvAcco
$LN2@CGRecvAcco:

; 162  : 	}
; 163  : 
; 164  : 	if(!OBJMAX_RANGE(aIndex))

  00458	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0045c	7d 09		 jge	 SHORT $LN5@CGRecvAcco
  0045e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00465	eb 0f		 jmp	 SHORT $LN6@CGRecvAcco
$LN5@CGRecvAcco:
  00467	33 c0		 xor	 eax, eax
  00469	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00470	0f 9e c0	 setle	 al
  00473	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN6@CGRecvAcco:
  00476	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  0047a	75 02		 jne	 SHORT $LN1@CGRecvAcco

; 165  : 	{
; 166  : 		return;

  0047c	eb 21		 jmp	 SHORT $LN3@CGRecvAcco
$LN1@CGRecvAcco:

; 167  : 	}
; 168  : 
; 169  : 	LPOBJ lpUser = &gObj[aIndex];

  0047e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00481	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00487	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0048d	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 170  : 
; 171  : 	lpUser->AccountSecurity.ClientPCID = lpMsg->PCID;

  00490	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00493	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00496	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00499	89 90 00 2a 00
	00		 mov	 DWORD PTR [eax+10752], edx
$LN3@CGRecvAcco:

; 172  : 
; 173  : #if(DEBUG_ACCOUNT_SECURITY)
; 174  : 
; 175  : 	BYTE bResult = 1;
; 176  : 
; 177  : 	if(this->CheckOnlyMyPC(aIndex) == true)
; 178  : 	{
; 179  : 		gObj[aIndex].UserNumber = gObj[aIndex].Join_aUserNumber;
; 180  : 		gObj[aIndex].DBNumber = gObj[aIndex].Join_aDBNumber;
; 181  : 		gObj[aIndex].Connected = PLAYER_LOGGED;
; 182  : 		strcpy(gObj[aIndex].LastJoominNumber, gObj[aIndex].Join_JoominNumber);
; 183  : 		gObj[aIndex].ukn_30 = gObj[aIndex].Join_ukn_30;
; 184  : 		gObj[aIndex].m_iPcBangRoom = gObj[aIndex].Join_PcBangRoom;
; 185  : 	}
; 186  : 	else
; 187  : 	{
; 188  : 		GJPAccountFail(aIndex, gObj[aIndex].AccountID, gObj[aIndex].DBNumber , gObj[aIndex].UserNumber  );
; 189  : 		bResult  = 5;	//5 - blocked, 7 - Connection Error
; 190  : 	}
; 191  : 
; 192  : 	GCJoinResult(bResult , aIndex);
; 193  : 
; 194  : 	if(bResult == 1)
; 195  : 	{
; 196  : 		if(gObj[aIndex].LoginMsgCount > 3)
; 197  : 		{
; 198  : 			CloseClient(aIndex);
; 199  : 		}
; 200  : 
; 201  : 		return;
; 202  : 	}
; 203  : 
; 204  : 	this->GCSendAccountInfo(aIndex);
; 205  : 
; 206  : #endif
; 207  : 
; 208  : }

  0049f	5f		 pop	 edi
  004a0	5e		 pop	 esi
  004a1	5b		 pop	 ebx
  004a2	8b e5		 mov	 esp, ebp
  004a4	5d		 pop	 ebp
  004a5	c2 08 00	 ret	 8
?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z ENDP ; CAccountSecurity::CGRecvAccountConnect
_TEXT	ENDS
PUBLIC	?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z ; CAccountSecurity::CGRecvSettingPC
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -84						; size = 4
_pMsg$ = -16						; size = 5
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z PROC ; CAccountSecurity::CGRecvSettingPC
; _this$ = ecx

; 211  : {

  004b0	55		 push	 ebp
  004b1	8b ec		 mov	 ebp, esp
  004b3	83 ec 54	 sub	 esp, 84			; 00000054H
  004b6	53		 push	 ebx
  004b7	56		 push	 esi
  004b8	57		 push	 edi
  004b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 212  : 	if(!this->m_bEnable)

  004bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004bf	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  004c2	85 c9		 test	 ecx, ecx
  004c4	75 05		 jne	 SHORT $LN5@CGRecvSett

; 213  : 	{
; 214  : 		return;

  004c6	e9 c3 00 00 00	 jmp	 $LN6@CGRecvSett
$LN5@CGRecvSett:

; 215  : 	}
; 216  : 
; 217  : 	if(!OBJMAX_RANGE(aIndex))

  004cb	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  004cf	7d 09		 jge	 SHORT $LN8@CGRecvSett
  004d1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  004d8	eb 0f		 jmp	 SHORT $LN9@CGRecvSett
$LN8@CGRecvSett:
  004da	33 c0		 xor	 eax, eax
  004dc	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  004e3	0f 9e c0	 setle	 al
  004e6	89 45 ac	 mov	 DWORD PTR tv69[ebp], eax
$LN9@CGRecvSett:
  004e9	83 7d ac 00	 cmp	 DWORD PTR tv69[ebp], 0
  004ed	75 05		 jne	 SHORT $LN4@CGRecvSett

; 218  : 	{
; 219  : 		return;

  004ef	e9 9a 00 00 00	 jmp	 $LN6@CGRecvSett
$LN4@CGRecvSett:

; 220  : 	}
; 221  : 
; 222  : 	LPOBJ lpUser = &gObj[aIndex];

  004f4	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004f7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004fd	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00503	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 223  : 
; 224  : 	PMSG_ANS_ACC_SETTING_PC pMsg;
; 225  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB1, sizeof(pMsg));

  00506	6a 05		 push	 5
  00508	68 b1 00 00 00	 push	 177			; 000000b1H
  0050d	68 fb 00 00 00	 push	 251			; 000000fbH
  00512	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00515	50		 push	 eax
  00516	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00519	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 226  : 
; 227  : 	pMsg.Result = 0;

  0051e	c6 45 f4 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 228  : 
; 229  : 	if(lpUser->AccountSecurity.SecretNumber == lpMsg->SecretNumber)

  00522	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00525	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00528	8b 90 08 2a 00
	00		 mov	 edx, DWORD PTR [eax+10760]
  0052e	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00531	75 34		 jne	 SHORT $LN3@CGRecvSett

; 230  : 	{
; 231  : 		pMsg.Result = 1;

  00533	c6 45 f4 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 232  : 
; 233  : 		lpUser->AccountSecurity.ActivePCID = lpMsg->ActivePCID;

  00537	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0053a	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  0053e	0f 95 c1	 setne	 cl
  00541	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00544	88 8a fc 29 00
	00		 mov	 BYTE PTR [edx+10748], cl

; 234  : 
; 235  : 		if(lpMsg->ChangePCID)

  0054a	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0054d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00551	85 c9		 test	 ecx, ecx
  00553	74 12		 je	 SHORT $LN3@CGRecvSett

; 236  : 		{
; 237  : 			lpUser->AccountSecurity.ProtectPCID = lpUser->AccountSecurity.ClientPCID;

  00555	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00558	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0055b	8b 91 00 2a 00
	00		 mov	 edx, DWORD PTR [ecx+10752]
  00561	89 90 04 2a 00
	00		 mov	 DWORD PTR [eax+10756], edx
$LN3@CGRecvSett:

; 238  : 		}
; 239  : 	}
; 240  : 
; 241  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00567	6a 05		 push	 5
  00569	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0056c	50		 push	 eax
  0056d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00570	51		 push	 ecx
  00571	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00576	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	if(pMsg.Result == 1)

  00579	0f b6 45 f4	 movzx	 eax, BYTE PTR _pMsg$[ebp+4]
  0057d	83 f8 01	 cmp	 eax, 1
  00580	75 0c		 jne	 SHORT $LN6@CGRecvSett

; 244  : 	{
; 245  : 		this->GDReqSave(aIndex);

  00582	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00585	50		 push	 eax
  00586	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00589	e8 00 00 00 00	 call	 ?GDReqSave@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqSave
$LN6@CGRecvSett:

; 246  : 	}
; 247  : }

  0058e	5f		 pop	 edi
  0058f	5e		 pop	 esi
  00590	5b		 pop	 ebx
  00591	8b e5		 mov	 esp, ebp
  00593	5d		 pop	 ebp
  00594	c2 08 00	 ret	 8
?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z ENDP ; CAccountSecurity::CGRecvSettingPC
_TEXT	ENDS
PUBLIC	?CheckPCID@CAccountSecurity@@QAE_NH@Z		; CAccountSecurity::CheckPCID
PUBLIC	?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z ; CAccountSecurity::CGRecvAccountOption
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z PROC ; CAccountSecurity::CGRecvAccountOption
; _this$ = ecx

; 250  : {

  005a0	55		 push	 ebp
  005a1	8b ec		 mov	 ebp, esp
  005a3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  005a6	53		 push	 ebx
  005a7	56		 push	 esi
  005a8	57		 push	 edi
  005a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  : 	if(!this->m_bEnable)

  005ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005af	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  005b2	85 c9		 test	 ecx, ecx
  005b4	75 05		 jne	 SHORT $LN3@CGRecvAcco@2

; 252  : 	{
; 253  : 		return;

  005b6	e9 d1 00 00 00	 jmp	 $LN4@CGRecvAcco@2
$LN3@CGRecvAcco@2:

; 254  : 	}
; 255  : 
; 256  : 	if(!OBJMAX_RANGE(aIndex))

  005bb	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  005bf	7d 09		 jge	 SHORT $LN6@CGRecvAcco@2
  005c1	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  005c8	eb 0f		 jmp	 SHORT $LN7@CGRecvAcco@2
$LN6@CGRecvAcco@2:
  005ca	33 c0		 xor	 eax, eax
  005cc	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  005d3	0f 9e c0	 setle	 al
  005d6	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN7@CGRecvAcco@2:
  005d9	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  005dd	75 05		 jne	 SHORT $LN2@CGRecvAcco@2

; 257  : 	{
; 258  : 		return;

  005df	e9 a8 00 00 00	 jmp	 $LN4@CGRecvAcco@2
$LN2@CGRecvAcco@2:

; 259  : 	}
; 260  : 
; 261  : 	if(!this->CheckPCID(aIndex))

  005e4	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005e7	50		 push	 eax
  005e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005eb	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  005f0	0f b6 c8	 movzx	 ecx, al
  005f3	85 c9		 test	 ecx, ecx
  005f5	75 05		 jne	 SHORT $LN1@CGRecvAcco@2

; 262  : 	{
; 263  : 		return;

  005f7	e9 90 00 00 00	 jmp	 $LN4@CGRecvAcco@2
$LN1@CGRecvAcco@2:

; 264  : 	}
; 265  : 
; 266  : 	LPOBJ lpUser = &gObj[aIndex];

  005fc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005ff	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00605	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0060b	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 267  : 
; 268  : 	lpUser->AccountSecurity.OnlyMyPC = lpMsg->OnlyMyPC;

  0060e	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00611	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  00615	0f 95 c1	 setne	 cl
  00618	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0061b	88 8a 0c 2a 00
	00		 mov	 BYTE PTR [edx+10764], cl

; 269  : 	lpUser->AccountSecurity.Trade = lpMsg->Trade;

  00621	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00624	80 78 05 00	 cmp	 BYTE PTR [eax+5], 0
  00628	0f 95 c1	 setne	 cl
  0062b	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0062e	88 8a 0d 2a 00
	00		 mov	 BYTE PTR [edx+10765], cl

; 270  : 	lpUser->AccountSecurity.Inventory = lpMsg->Inventory;

  00634	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00637	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  0063b	0f 95 c1	 setne	 cl
  0063e	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00641	88 8a 0e 2a 00
	00		 mov	 BYTE PTR [edx+10766], cl

; 271  : 	lpUser->AccountSecurity.Werehouse = lpMsg->Werehouse;

  00647	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0064a	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  0064e	0f 95 c1	 setne	 cl
  00651	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00654	88 8a 0f 2a 00
	00		 mov	 BYTE PTR [edx+10767], cl

; 272  : 	lpUser->AccountSecurity.DisconnectFriend = lpMsg->DisconnectFriend;

  0065a	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0065d	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00661	0f 95 c1	 setne	 cl
  00664	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00667	88 8a 10 2a 00
	00		 mov	 BYTE PTR [edx+10768], cl

; 273  : 	lpUser->AccountSecurity.SellChar = lpMsg->SellChar;

  0066d	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00670	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  00674	0f 95 c1	 setne	 cl
  00677	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0067a	88 8a 11 2a 00
	00		 mov	 BYTE PTR [edx+10769], cl

; 274  : 
; 275  : 	this->GDReqSave(aIndex);

  00680	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00683	50		 push	 eax
  00684	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00687	e8 00 00 00 00	 call	 ?GDReqSave@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqSave
$LN4@CGRecvAcco@2:

; 276  : }

  0068c	5f		 pop	 edi
  0068d	5e		 pop	 esi
  0068e	5b		 pop	 ebx
  0068f	8b e5		 mov	 esp, ebp
  00691	5d		 pop	 ebp
  00692	c2 08 00	 ret	 8
?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z ENDP ; CAccountSecurity::CGRecvAccountOption
_TEXT	ENDS
PUBLIC	?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z ; CAccountSecurity::CGRecvSaveNumber
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z PROC ; CAccountSecurity::CGRecvSaveNumber
; _this$ = ecx

; 279  : {

  006a0	55		 push	 ebp
  006a1	8b ec		 mov	 ebp, esp
  006a3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  006a6	53		 push	 ebx
  006a7	56		 push	 esi
  006a8	57		 push	 edi
  006a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 280  : 	if(!this->m_bEnable)

  006ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006af	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  006b2	85 c9		 test	 ecx, ecx
  006b4	75 02		 jne	 SHORT $LN2@CGRecvSave

; 281  : 	{
; 282  : 		return;

  006b6	eb 53		 jmp	 SHORT $LN3@CGRecvSave
$LN2@CGRecvSave:

; 283  : 	}
; 284  : 
; 285  : 	if(!OBJMAX_RANGE(aIndex))

  006b8	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  006bc	7d 09		 jge	 SHORT $LN5@CGRecvSave
  006be	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  006c5	eb 0f		 jmp	 SHORT $LN6@CGRecvSave
$LN5@CGRecvSave:
  006c7	33 c0		 xor	 eax, eax
  006c9	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  006d0	0f 9e c0	 setle	 al
  006d3	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN6@CGRecvSave:
  006d6	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  006da	75 02		 jne	 SHORT $LN1@CGRecvSave

; 286  : 	{
; 287  : 		return;

  006dc	eb 2d		 jmp	 SHORT $LN3@CGRecvSave
$LN1@CGRecvSave:

; 288  : 	}
; 289  : 
; 290  : 	LPOBJ lpUser = &gObj[aIndex];

  006de	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006e1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  006e7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006ed	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 291  : 
; 292  : 	lpUser->AccountSecurity.SecretNumber = lpMsg->SecretNumber;

  006f0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  006f3	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  006f6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  006f9	89 90 08 2a 00
	00		 mov	 DWORD PTR [eax+10760], edx

; 293  : 
; 294  : 	this->GDReqSave(aIndex);

  006ff	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?GDReqSave@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqSave
$LN3@CGRecvSave:

; 295  : }

  0070b	5f		 pop	 edi
  0070c	5e		 pop	 esi
  0070d	5b		 pop	 ebx
  0070e	8b e5		 mov	 esp, ebp
  00710	5d		 pop	 ebp
  00711	c2 08 00	 ret	 8
?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z ENDP ; CAccountSecurity::CGRecvSaveNumber
_TEXT	ENDS
PUBLIC	?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckNewSecretNumber
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -28						; size = 13
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z PROC	; CAccountSecurity::GCSendAccountInfo
; _this$ = ecx

; 298  : {

  00720	55		 push	 ebp
  00721	8b ec		 mov	 ebp, esp
  00723	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00726	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0072b	33 c5		 xor	 eax, ebp
  0072d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00730	53		 push	 ebx
  00731	56		 push	 esi
  00732	57		 push	 edi
  00733	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 299  : 	LPOBJ lpUser = &gObj[aIndex];

  00736	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00739	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0073f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00745	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 300  : 
; 301  : 	PMSG_REQ_ACC_INFO pMsg;
; 302  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB0, sizeof(pMsg));

  00748	6a 0d		 push	 13			; 0000000dH
  0074a	68 b0 00 00 00	 push	 176			; 000000b0H
  0074f	68 fb 00 00 00	 push	 251			; 000000fbH
  00754	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00757	50		 push	 eax
  00758	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0075b	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 303  : 	pMsg.ActivePCID = lpUser->AccountSecurity.ActivePCID;

  00760	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00763	8a 88 fc 29 00
	00		 mov	 cl, BYTE PTR [eax+10748]
  00769	88 4d e8	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 304  : 	pMsg.NewSecretNumber = this->CheckNewSecretNumber(aIndex);

  0076c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0076f	50		 push	 eax
  00770	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00773	e8 00 00 00 00	 call	 ?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckNewSecretNumber
  00778	88 45 e9	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 305  : 	pMsg.CheckPCID = this->CheckPCID(aIndex);

  0077b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0077e	50		 push	 eax
  0077f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00782	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00787	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 306  : 	pMsg.OnlyMyPC = lpUser->AccountSecurity.OnlyMyPC;

  0078a	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0078d	8a 88 0c 2a 00
	00		 mov	 cl, BYTE PTR [eax+10764]
  00793	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 307  : 	pMsg.Trade = lpUser->AccountSecurity.Trade;

  00796	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00799	8a 88 0d 2a 00
	00		 mov	 cl, BYTE PTR [eax+10765]
  0079f	88 4d ec	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 308  : 	pMsg.Inventory = lpUser->AccountSecurity.Inventory;

  007a2	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  007a5	8a 88 0e 2a 00
	00		 mov	 cl, BYTE PTR [eax+10766]
  007ab	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 309  : 	pMsg.Werehouse = lpUser->AccountSecurity.Werehouse;

  007ae	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  007b1	8a 88 0f 2a 00
	00		 mov	 cl, BYTE PTR [eax+10767]
  007b7	88 4d ee	 mov	 BYTE PTR _pMsg$[ebp+10], cl

; 310  : 	pMsg.DisconnectFriend = lpUser->AccountSecurity.DisconnectFriend;

  007ba	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  007bd	8a 88 10 2a 00
	00		 mov	 cl, BYTE PTR [eax+10768]
  007c3	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 311  : 	pMsg.SellChar = lpUser->AccountSecurity.SellChar;

  007c6	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  007c9	8a 88 11 2a 00
	00		 mov	 cl, BYTE PTR [eax+10769]
  007cf	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+12], cl

; 312  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  007d2	6a 0d		 push	 13			; 0000000dH
  007d4	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  007d7	50		 push	 eax
  007d8	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  007db	51		 push	 ecx
  007dc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : }

  007e4	5f		 pop	 edi
  007e5	5e		 pop	 esi
  007e6	5b		 pop	 ebx
  007e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ea	33 cd		 xor	 ecx, ebp
  007ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f1	8b e5		 mov	 esp, ebp
  007f3	5d		 pop	 ebp
  007f4	c2 04 00	 ret	 4
?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z ENDP	; CAccountSecurity::GCSendAccountInfo
; Function compile flags: /Odtp /ZI
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z PROC	; CAccountSecurity::CheckNewSecretNumber
; _this$ = ecx

; 316  : {

  00800	55		 push	 ebp
  00801	8b ec		 mov	 ebp, esp
  00803	83 ec 48	 sub	 esp, 72			; 00000048H
  00806	53		 push	 ebx
  00807	56		 push	 esi
  00808	57		 push	 edi
  00809	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 	if(!this->m_bEnable)

  0080c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0080f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00812	85 c9		 test	 ecx, ecx
  00814	75 04		 jne	 SHORT $LN2@CheckNewSe

; 318  : 	{
; 319  : 		return true;

  00816	b0 01		 mov	 al, 1
  00818	eb 24		 jmp	 SHORT $LN3@CheckNewSe
$LN2@CheckNewSe:

; 320  : 	}
; 321  : 
; 322  : 	LPOBJ lpUser = &gObj[aIndex];

  0081a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0081d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00823	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00829	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 323  : 
; 324  : 	if(lpUser->AccountSecurity.SecretNumber == 0)

  0082c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0082f	83 b8 08 2a 00
	00 00		 cmp	 DWORD PTR [eax+10760], 0
  00836	75 04		 jne	 SHORT $LN1@CheckNewSe

; 325  : 	{
; 326  : 		return true;

  00838	b0 01		 mov	 al, 1
  0083a	eb 02		 jmp	 SHORT $LN3@CheckNewSe
$LN1@CheckNewSe:

; 327  : 	}
; 328  : 
; 329  : 	return false;

  0083c	32 c0		 xor	 al, al
$LN3@CheckNewSe:

; 330  : }

  0083e	5f		 pop	 edi
  0083f	5e		 pop	 esi
  00840	5b		 pop	 ebx
  00841	8b e5		 mov	 esp, ebp
  00843	5d		 pop	 ebp
  00844	c2 04 00	 ret	 4
?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z ENDP	; CAccountSecurity::CheckNewSecretNumber
; Function compile flags: /Odtp /ZI
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckPCID@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckPCID
; _this$ = ecx

; 333  : {

  00850	55		 push	 ebp
  00851	8b ec		 mov	 ebp, esp
  00853	83 ec 48	 sub	 esp, 72			; 00000048H
  00856	53		 push	 ebx
  00857	56		 push	 esi
  00858	57		 push	 edi
  00859	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 334  : 	if(!this->m_bEnable)

  0085c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0085f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00862	85 c9		 test	 ecx, ecx
  00864	75 04		 jne	 SHORT $LN2@CheckPCID

; 335  : 	{
; 336  : 		return true;

  00866	b0 01		 mov	 al, 1
  00868	eb 2c		 jmp	 SHORT $LN3@CheckPCID
$LN2@CheckPCID:

; 337  : 	}
; 338  : 
; 339  : 	LPOBJ lpUser = &gObj[aIndex];

  0086a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0086d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00873	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00879	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 340  : 
; 341  : 	if(lpUser->AccountSecurity.ClientPCID == lpUser->AccountSecurity.ProtectPCID)

  0087c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0087f	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00882	8b 90 00 2a 00
	00		 mov	 edx, DWORD PTR [eax+10752]
  00888	3b 91 04 2a 00
	00		 cmp	 edx, DWORD PTR [ecx+10756]
  0088e	75 04		 jne	 SHORT $LN1@CheckPCID

; 342  : 	{
; 343  : 		return true;

  00890	b0 01		 mov	 al, 1
  00892	eb 02		 jmp	 SHORT $LN3@CheckPCID
$LN1@CheckPCID:

; 344  : 	}
; 345  : 
; 346  : 	return false;

  00894	32 c0		 xor	 al, al
$LN3@CheckPCID:

; 347  : }

  00896	5f		 pop	 edi
  00897	5e		 pop	 esi
  00898	5b		 pop	 ebx
  00899	8b e5		 mov	 esp, ebp
  0089b	5d		 pop	 ebp
  0089c	c2 04 00	 ret	 4
?CheckPCID@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckPCID
; Function compile flags: /Odtp /ZI
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckOnlyMyPC
; _this$ = ecx

; 350  : {

  008a0	55		 push	 ebp
  008a1	8b ec		 mov	 ebp, esp
  008a3	83 ec 48	 sub	 esp, 72			; 00000048H
  008a6	53		 push	 ebx
  008a7	56		 push	 esi
  008a8	57		 push	 edi
  008a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  : 	if(!this->m_bEnable)

  008ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008af	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  008b2	85 c9		 test	 ecx, ecx
  008b4	75 04		 jne	 SHORT $LN2@CheckOnlyM

; 352  : 	{
; 353  : 		return true;

  008b6	b0 01		 mov	 al, 1
  008b8	eb 49		 jmp	 SHORT $LN3@CheckOnlyM
$LN2@CheckOnlyM:

; 354  : 	}
; 355  : 
; 356  : 	LPOBJ lpUser = &gObj[aIndex];

  008ba	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008bd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  008c3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008c9	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 357  : 
; 358  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.OnlyMyPC == true)

  008cc	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  008cf	0f b6 88 fc 29
	00 00		 movzx	 ecx, BYTE PTR [eax+10748]
  008d6	83 f9 01	 cmp	 ecx, 1
  008d9	75 26		 jne	 SHORT $LN1@CheckOnlyM
  008db	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008de	50		 push	 eax
  008df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008e2	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  008e7	0f b6 c8	 movzx	 ecx, al
  008ea	85 c9		 test	 ecx, ecx
  008ec	75 13		 jne	 SHORT $LN1@CheckOnlyM
  008ee	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  008f1	0f b6 88 0c 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10764]
  008f8	83 f9 01	 cmp	 ecx, 1
  008fb	75 04		 jne	 SHORT $LN1@CheckOnlyM

; 359  : 	{
; 360  : 		return false;	

  008fd	32 c0		 xor	 al, al
  008ff	eb 02		 jmp	 SHORT $LN3@CheckOnlyM
$LN1@CheckOnlyM:

; 361  : 	}
; 362  : 
; 363  : 	return true;

  00901	b0 01		 mov	 al, 1
$LN3@CheckOnlyM:

; 364  : }

  00903	5f		 pop	 edi
  00904	5e		 pop	 esi
  00905	5b		 pop	 ebx
  00906	8b e5		 mov	 esp, ebp
  00908	5d		 pop	 ebp
  00909	c2 04 00	 ret	 4
?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckOnlyMyPC
_TEXT	ENDS
PUBLIC	??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@ ; `string'
PUBLIC	?CheckTrade@CAccountSecurity@@QAE_NH@Z		; CAccountSecurity::CheckTrade
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
;	COMDAT ??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@
CONST	SEGMENT
??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@ DB '[Accoun'
	DB	't Security] Trade Blocked', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckTrade@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckTrade
; _this$ = ecx

; 367  : {

  00910	55		 push	 ebp
  00911	8b ec		 mov	 ebp, esp
  00913	83 ec 48	 sub	 esp, 72			; 00000048H
  00916	53		 push	 ebx
  00917	56		 push	 esi
  00918	57		 push	 edi
  00919	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 	if(!this->m_bEnable)

  0091c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0091f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00922	85 c9		 test	 ecx, ecx
  00924	75 04		 jne	 SHORT $LN2@CheckTrade

; 369  : 	{
; 370  : 		return true;

  00926	b0 01		 mov	 al, 1
  00928	eb 5b		 jmp	 SHORT $LN3@CheckTrade
$LN2@CheckTrade:

; 371  : 	}
; 372  : 
; 373  : 	LPOBJ lpUser = &gObj[aIndex];

  0092a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0092d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00933	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00939	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 374  : 
; 375  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.Trade == false)

  0093c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0093f	0f b6 88 fc 29
	00 00		 movzx	 ecx, BYTE PTR [eax+10748]
  00946	83 f9 01	 cmp	 ecx, 1
  00949	75 38		 jne	 SHORT $LN1@CheckTrade
  0094b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0094e	50		 push	 eax
  0094f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00952	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00957	0f b6 c8	 movzx	 ecx, al
  0095a	85 c9		 test	 ecx, ecx
  0095c	75 25		 jne	 SHORT $LN1@CheckTrade
  0095e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00961	0f b6 88 0d 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10765]
  00968	85 c9		 test	 ecx, ecx
  0096a	75 17		 jne	 SHORT $LN1@CheckTrade

; 376  : 	{
; 377  : 		GCServerMsgStringSend("[Account Security] Trade Blocked", aIndex, 0);

  0096c	6a 00		 push	 0
  0096e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00971	50		 push	 eax
  00972	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@
  00977	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0097c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 
; 379  : 		return false;	

  0097f	32 c0		 xor	 al, al
  00981	eb 02		 jmp	 SHORT $LN3@CheckTrade
$LN1@CheckTrade:

; 380  : 	}
; 381  : 
; 382  : 	return true;

  00983	b0 01		 mov	 al, 1
$LN3@CheckTrade:

; 383  : }

  00985	5f		 pop	 edi
  00986	5e		 pop	 esi
  00987	5b		 pop	 ebx
  00988	8b e5		 mov	 esp, ebp
  0098a	5d		 pop	 ebp
  0098b	c2 04 00	 ret	 4
?CheckTrade@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckTrade
_TEXT	ENDS
PUBLIC	??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@ ; `string'
PUBLIC	?CheckInventory@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckInventory
;	COMDAT ??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@
CONST	SEGMENT
??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@ DB '[Accoun'
	DB	't Security] Inventory Blocked', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckInventory@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckInventory
; _this$ = ecx

; 386  : {

  00990	55		 push	 ebp
  00991	8b ec		 mov	 ebp, esp
  00993	83 ec 48	 sub	 esp, 72			; 00000048H
  00996	53		 push	 ebx
  00997	56		 push	 esi
  00998	57		 push	 edi
  00999	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 	if(!this->m_bEnable)

  0099c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0099f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  009a2	85 c9		 test	 ecx, ecx
  009a4	75 04		 jne	 SHORT $LN2@CheckInven

; 388  : 	{
; 389  : 		return true;

  009a6	b0 01		 mov	 al, 1
  009a8	eb 5b		 jmp	 SHORT $LN3@CheckInven
$LN2@CheckInven:

; 390  : 	}
; 391  : 
; 392  : 	LPOBJ lpUser = &gObj[aIndex];

  009aa	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009ad	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  009b3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009b9	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 393  : 
; 394  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.Inventory == false)

  009bc	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  009bf	0f b6 88 fc 29
	00 00		 movzx	 ecx, BYTE PTR [eax+10748]
  009c6	83 f9 01	 cmp	 ecx, 1
  009c9	75 38		 jne	 SHORT $LN1@CheckInven
  009cb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009ce	50		 push	 eax
  009cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009d2	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  009d7	0f b6 c8	 movzx	 ecx, al
  009da	85 c9		 test	 ecx, ecx
  009dc	75 25		 jne	 SHORT $LN1@CheckInven
  009de	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  009e1	0f b6 88 0e 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10766]
  009e8	85 c9		 test	 ecx, ecx
  009ea	75 17		 jne	 SHORT $LN1@CheckInven

; 395  : 	{
; 396  : 		GCServerMsgStringSend("[Account Security] Inventory Blocked", aIndex, 0);

  009ec	6a 00		 push	 0
  009ee	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009f1	50		 push	 eax
  009f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@
  009f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  009fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 397  : 
; 398  : 		return false;	

  009ff	32 c0		 xor	 al, al
  00a01	eb 02		 jmp	 SHORT $LN3@CheckInven
$LN1@CheckInven:

; 399  : 	}
; 400  : 
; 401  : 	return true;

  00a03	b0 01		 mov	 al, 1
$LN3@CheckInven:

; 402  : }

  00a05	5f		 pop	 edi
  00a06	5e		 pop	 esi
  00a07	5b		 pop	 ebx
  00a08	8b e5		 mov	 esp, ebp
  00a0a	5d		 pop	 ebp
  00a0b	c2 04 00	 ret	 4
?CheckInventory@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckInventory
_TEXT	ENDS
PUBLIC	??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@ ; `string'
PUBLIC	?CheckWerehouse@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckWerehouse
;	COMDAT ??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@
CONST	SEGMENT
??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@ DB '[Accoun'
	DB	't Security] Werehouse Blocked', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckWerehouse@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckWerehouse
; _this$ = ecx

; 405  : {

  00a10	55		 push	 ebp
  00a11	8b ec		 mov	 ebp, esp
  00a13	83 ec 48	 sub	 esp, 72			; 00000048H
  00a16	53		 push	 ebx
  00a17	56		 push	 esi
  00a18	57		 push	 edi
  00a19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 406  : 	if(!this->m_bEnable)

  00a1c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a1f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00a22	85 c9		 test	 ecx, ecx
  00a24	75 04		 jne	 SHORT $LN2@CheckWereh

; 407  : 	{
; 408  : 		return true;

  00a26	b0 01		 mov	 al, 1
  00a28	eb 5b		 jmp	 SHORT $LN3@CheckWereh
$LN2@CheckWereh:

; 409  : 	}
; 410  : 
; 411  : 	LPOBJ lpUser = &gObj[aIndex];

  00a2a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a2d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a33	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a39	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 412  : 
; 413  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.Werehouse == false)

  00a3c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00a3f	0f b6 88 fc 29
	00 00		 movzx	 ecx, BYTE PTR [eax+10748]
  00a46	83 f9 01	 cmp	 ecx, 1
  00a49	75 38		 jne	 SHORT $LN1@CheckWereh
  00a4b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a4e	50		 push	 eax
  00a4f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a52	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00a57	0f b6 c8	 movzx	 ecx, al
  00a5a	85 c9		 test	 ecx, ecx
  00a5c	75 25		 jne	 SHORT $LN1@CheckWereh
  00a5e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00a61	0f b6 88 0f 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10767]
  00a68	85 c9		 test	 ecx, ecx
  00a6a	75 17		 jne	 SHORT $LN1@CheckWereh

; 414  : 	{
; 415  : 		GCServerMsgStringSend("[Account Security] Werehouse Blocked", aIndex, 0);

  00a6c	6a 00		 push	 0
  00a6e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a71	50		 push	 eax
  00a72	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@
  00a77	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00a7c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 
; 417  : 		return false;	

  00a7f	32 c0		 xor	 al, al
  00a81	eb 02		 jmp	 SHORT $LN3@CheckWereh
$LN1@CheckWereh:

; 418  : 	}
; 419  : 
; 420  : 	return true;

  00a83	b0 01		 mov	 al, 1
$LN3@CheckWereh:

; 421  : }

  00a85	5f		 pop	 edi
  00a86	5e		 pop	 esi
  00a87	5b		 pop	 ebx
  00a88	8b e5		 mov	 esp, ebp
  00a8a	5d		 pop	 ebp
  00a8b	c2 04 00	 ret	 4
?CheckWerehouse@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckWerehouse
_TEXT	ENDS
PUBLIC	??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@ ; `string'
PUBLIC	?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z ; CAccountSecurity::CheckDisconnectFriend
;	COMDAT ??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@
CONST	SEGMENT
??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@ DB '[Accoun'
	DB	't Security] Disconnect Friend Blocked', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aFriendIndex$ = 12					; size = 4
?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z PROC	; CAccountSecurity::CheckDisconnectFriend
; _this$ = ecx

; 424  : {

  00a90	55		 push	 ebp
  00a91	8b ec		 mov	 ebp, esp
  00a93	83 ec 48	 sub	 esp, 72			; 00000048H
  00a96	53		 push	 ebx
  00a97	56		 push	 esi
  00a98	57		 push	 edi
  00a99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 425  : 	if(!this->m_bEnable)

  00a9c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a9f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00aa2	85 c9		 test	 ecx, ecx
  00aa4	75 04		 jne	 SHORT $LN2@CheckDisco

; 426  : 	{
; 427  : 		return true;

  00aa6	b0 01		 mov	 al, 1
  00aa8	eb 5b		 jmp	 SHORT $LN3@CheckDisco
$LN2@CheckDisco:

; 428  : 	}
; 429  : 
; 430  : 	LPOBJ lpUser = &gObj[aIndex];

  00aaa	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aad	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00ab3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab9	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 431  : 
; 432  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.DisconnectFriend == false)

  00abc	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00abf	0f b6 88 fc 29
	00 00		 movzx	 ecx, BYTE PTR [eax+10748]
  00ac6	83 f9 01	 cmp	 ecx, 1
  00ac9	75 38		 jne	 SHORT $LN1@CheckDisco
  00acb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ace	50		 push	 eax
  00acf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad2	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00ad7	0f b6 c8	 movzx	 ecx, al
  00ada	85 c9		 test	 ecx, ecx
  00adc	75 25		 jne	 SHORT $LN1@CheckDisco
  00ade	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ae1	0f b6 88 10 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10768]
  00ae8	85 c9		 test	 ecx, ecx
  00aea	75 17		 jne	 SHORT $LN1@CheckDisco

; 433  : 	{
; 434  : 		GCServerMsgStringSend("[Account Security] Disconnect Friend Blocked", aFriendIndex, 0);

  00aec	6a 00		 push	 0
  00aee	8b 45 0c	 mov	 eax, DWORD PTR _aFriendIndex$[ebp]
  00af1	50		 push	 eax
  00af2	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@
  00af7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00afc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 
; 436  : 		return false;	

  00aff	32 c0		 xor	 al, al
  00b01	eb 02		 jmp	 SHORT $LN3@CheckDisco
$LN1@CheckDisco:

; 437  : 	}
; 438  : 
; 439  : 	return true;

  00b03	b0 01		 mov	 al, 1
$LN3@CheckDisco:

; 440  : }

  00b05	5f		 pop	 edi
  00b06	5e		 pop	 esi
  00b07	5b		 pop	 ebx
  00b08	8b e5		 mov	 esp, ebp
  00b0a	5d		 pop	 ebp
  00b0b	c2 08 00	 ret	 8
?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z ENDP	; CAccountSecurity::CheckDisconnectFriend
_TEXT	ENDS
PUBLIC	?CheckSellChar@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckSellChar
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckSellChar@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckSellChar
; _this$ = ecx

; 443  : {

  00b10	55		 push	 ebp
  00b11	8b ec		 mov	 ebp, esp
  00b13	83 ec 48	 sub	 esp, 72			; 00000048H
  00b16	53		 push	 ebx
  00b17	56		 push	 esi
  00b18	57		 push	 edi
  00b19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 444  : 	if(!this->m_bEnable)

  00b1c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b1f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00b22	85 c9		 test	 ecx, ecx
  00b24	75 04		 jne	 SHORT $LN2@CheckSellC

; 445  : 	{
; 446  : 		return true;

  00b26	b0 01		 mov	 al, 1
  00b28	eb 48		 jmp	 SHORT $LN3@CheckSellC
$LN2@CheckSellC:

; 447  : 	}
; 448  : 
; 449  : 	LPOBJ lpUser = &gObj[aIndex];

  00b2a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b2d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b33	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b39	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 450  : 
; 451  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.SellChar == false)

  00b3c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00b3f	0f b6 88 fc 29
	00 00		 movzx	 ecx, BYTE PTR [eax+10748]
  00b46	83 f9 01	 cmp	 ecx, 1
  00b49	75 25		 jne	 SHORT $LN1@CheckSellC
  00b4b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b4e	50		 push	 eax
  00b4f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b52	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00b57	0f b6 c8	 movzx	 ecx, al
  00b5a	85 c9		 test	 ecx, ecx
  00b5c	75 12		 jne	 SHORT $LN1@CheckSellC
  00b5e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00b61	0f b6 88 11 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10769]
  00b68	85 c9		 test	 ecx, ecx
  00b6a	75 04		 jne	 SHORT $LN1@CheckSellC

; 452  : 	{
; 453  : 		return false;	

  00b6c	32 c0		 xor	 al, al
  00b6e	eb 02		 jmp	 SHORT $LN3@CheckSellC
$LN1@CheckSellC:

; 454  : 	}
; 455  : 
; 456  : 	return true;

  00b70	b0 01		 mov	 al, 1
$LN3@CheckSellC:

; 457  : }

  00b72	5f		 pop	 edi
  00b73	5e		 pop	 esi
  00b74	5b		 pop	 ebx
  00b75	8b e5		 mov	 esp, ebp
  00b77	5d		 pop	 ebp
  00b78	c2 04 00	 ret	 4
?CheckSellChar@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckSellChar
_TEXT	ENDS
PUBLIC	?SelectCharacter@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::SelectCharacter
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?SelectCharacter@CAccountSecurity@@QAE_NH@Z PROC	; CAccountSecurity::SelectCharacter
; _this$ = ecx

; 460  : {

  00b80	55		 push	 ebp
  00b81	8b ec		 mov	 ebp, esp
  00b83	83 ec 48	 sub	 esp, 72			; 00000048H
  00b86	53		 push	 ebx
  00b87	56		 push	 esi
  00b88	57		 push	 edi
  00b89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 461  : 	if(!this->m_bEnable)

  00b8c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b8f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00b92	85 c9		 test	 ecx, ecx
  00b94	75 04		 jne	 SHORT $LN3@SelectChar

; 462  : 	{
; 463  : 		return true;

  00b96	b0 01		 mov	 al, 1
  00b98	eb 4f		 jmp	 SHORT $LN4@SelectChar
$LN3@SelectChar:

; 464  : 	}
; 465  : 
; 466  : 	if(!OBJMAX_RANGE(aIndex))

  00b9a	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00b9e	7d 09		 jge	 SHORT $LN6@SelectChar
  00ba0	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00ba7	eb 0f		 jmp	 SHORT $LN7@SelectChar
$LN6@SelectChar:
  00ba9	33 c0		 xor	 eax, eax
  00bab	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00bb2	0f 9e c0	 setle	 al
  00bb5	89 45 b8	 mov	 DWORD PTR tv69[ebp], eax
$LN7@SelectChar:
  00bb8	83 7d b8 00	 cmp	 DWORD PTR tv69[ebp], 0
  00bbc	75 04		 jne	 SHORT $LN2@SelectChar

; 467  : 	{
; 468  : 		return true;

  00bbe	b0 01		 mov	 al, 1
  00bc0	eb 27		 jmp	 SHORT $LN4@SelectChar
$LN2@SelectChar:

; 469  : 	}
; 470  : 
; 471  : 	if(this->CheckOnlyMyPC(aIndex) == false)

  00bc2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bc5	50		 push	 eax
  00bc6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc9	e8 00 00 00 00	 call	 ?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckOnlyMyPC
  00bce	0f b6 c8	 movzx	 ecx, al
  00bd1	85 c9		 test	 ecx, ecx
  00bd3	75 12		 jne	 SHORT $LN1@SelectChar

; 472  : 	{
; 473  : 		GCCloseMsgSend(aIndex, 2);

  00bd5	6a 02		 push	 2
  00bd7	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bda	50		 push	 eax
  00bdb	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00be0	83 c4 08	 add	 esp, 8

; 474  : 
; 475  : 		return false;	

  00be3	32 c0		 xor	 al, al
  00be5	eb 02		 jmp	 SHORT $LN4@SelectChar
$LN1@SelectChar:

; 476  : 	}
; 477  : 
; 478  : 	return true;

  00be7	b0 01		 mov	 al, 1
$LN4@SelectChar:

; 479  : }

  00be9	5f		 pop	 edi
  00bea	5e		 pop	 esi
  00beb	5b		 pop	 ebx
  00bec	8b e5		 mov	 esp, ebp
  00bee	5d		 pop	 ebp
  00bef	c2 04 00	 ret	 4
?SelectCharacter@CAccountSecurity@@QAE_NH@Z ENDP	; CAccountSecurity::SelectCharacter
_TEXT	ENDS
PUBLIC	?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z	; CAccountSecurity::CheckJoinLogin
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
_JoinResult$ = 16					; size = 1
?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z PROC	; CAccountSecurity::CheckJoinLogin
; _this$ = ecx

; 482  : {

  00c00	55		 push	 ebp
  00c01	8b ec		 mov	 ebp, esp
  00c03	83 ec 44	 sub	 esp, 68			; 00000044H
  00c06	53		 push	 ebx
  00c07	56		 push	 esi
  00c08	57		 push	 edi
  00c09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 483  : 	if(!this->m_bEnable)

  00c0c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c0f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00c12	85 c9		 test	 ecx, ecx
  00c14	75 04		 jne	 SHORT $LN3@CheckJoinL

; 484  : 	{
; 485  : 		return false;

  00c16	32 c0		 xor	 al, al
  00c18	eb 27		 jmp	 SHORT $LN4@CheckJoinL
$LN3@CheckJoinL:

; 486  : 	}
; 487  : 
; 488  : 	if(Result != 1)

  00c1a	0f b6 45 0c	 movzx	 eax, BYTE PTR _Result$[ebp]
  00c1e	83 f8 01	 cmp	 eax, 1
  00c21	74 04		 je	 SHORT $LN2@CheckJoinL

; 489  : 	{
; 490  : 		return false;

  00c23	32 c0		 xor	 al, al
  00c25	eb 1a		 jmp	 SHORT $LN4@CheckJoinL
$LN2@CheckJoinL:

; 491  : 	}
; 492  : 
; 493  : 	if(JoinResult == false)

  00c27	0f b6 45 10	 movzx	 eax, BYTE PTR _JoinResult$[ebp]
  00c2b	85 c0		 test	 eax, eax
  00c2d	75 04		 jne	 SHORT $LN1@CheckJoinL

; 494  : 	{
; 495  : 		return false;

  00c2f	32 c0		 xor	 al, al
  00c31	eb 0e		 jmp	 SHORT $LN4@CheckJoinL
$LN1@CheckJoinL:

; 496  : 	}
; 497  : 
; 498  : 	this->GDReqLoad(aIndex);

  00c33	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c36	50		 push	 eax
  00c37	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c3a	e8 00 00 00 00	 call	 ?GDReqLoad@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqLoad

; 499  : 
; 500  : 	return true;

  00c3f	b0 01		 mov	 al, 1
$LN4@CheckJoinL:

; 501  : }

  00c41	5f		 pop	 edi
  00c42	5e		 pop	 esi
  00c43	5b		 pop	 ebx
  00c44	8b e5		 mov	 esp, ebp
  00c46	5d		 pop	 ebp
  00c47	c2 0c 00	 ret	 12			; 0000000cH
?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z ENDP	; CAccountSecurity::CheckJoinLogin
_TEXT	ENDS
PUBLIC	?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z	; CAccountSecurity::GCReqAccountConnect
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z PROC	; CAccountSecurity::GCReqAccountConnect
; _this$ = ecx

; 504  : {

  00c50	55		 push	 ebp
  00c51	8b ec		 mov	 ebp, esp
  00c53	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00c56	53		 push	 ebx
  00c57	56		 push	 esi
  00c58	57		 push	 edi
  00c59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 505  : 	PMSG_REQ_ACC_LOGIN pMsg;
; 506  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB4, sizeof(pMsg));

  00c5c	6a 05		 push	 5
  00c5e	68 b4 00 00 00	 push	 180			; 000000b4H
  00c63	68 fb 00 00 00	 push	 251			; 000000fbH
  00c68	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00c6b	50		 push	 eax
  00c6c	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00c6f	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 507  : 	pMsg.Result = true;

  00c74	c6 45 f8 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 508  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00c78	6a 05		 push	 5
  00c7a	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00c7d	50		 push	 eax
  00c7e	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00c81	51		 push	 ecx
  00c82	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00c87	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  : }

  00c8a	5f		 pop	 edi
  00c8b	5e		 pop	 esi
  00c8c	5b		 pop	 ebx
  00c8d	8b e5		 mov	 esp, ebp
  00c8f	5d		 pop	 ebp
  00c90	c2 04 00	 ret	 4
?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z ENDP	; CAccountSecurity::GCReqAccountConnect
_TEXT	ENDS
PUBLIC	?GetActivePC@CAccountSecurity@@QAE_NH@Z		; CAccountSecurity::GetActivePC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv69 = -76						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?GetActivePC@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::GetActivePC
; _this$ = ecx

; 512  : {

  00ca0	55		 push	 ebp
  00ca1	8b ec		 mov	 ebp, esp
  00ca3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00ca6	53		 push	 ebx
  00ca7	56		 push	 esi
  00ca8	57		 push	 edi
  00ca9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 513  : 	if(!this->m_bEnable)

  00cac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00caf	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00cb2	85 c9		 test	 ecx, ecx
  00cb4	75 04		 jne	 SHORT $LN2@GetActiveP

; 514  : 	{
; 515  : 		return false;

  00cb6	32 c0		 xor	 al, al
  00cb8	eb 43		 jmp	 SHORT $LN3@GetActiveP
$LN2@GetActiveP:

; 516  : 	}
; 517  : 
; 518  : 	if(!OBJMAX_RANGE(aIndex))

  00cba	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00cbe	7d 09		 jge	 SHORT $LN5@GetActiveP
  00cc0	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00cc7	eb 0f		 jmp	 SHORT $LN6@GetActiveP
$LN5@GetActiveP:
  00cc9	33 c0		 xor	 eax, eax
  00ccb	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00cd2	0f 9e c0	 setle	 al
  00cd5	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
$LN6@GetActiveP:
  00cd8	83 7d b4 00	 cmp	 DWORD PTR tv69[ebp], 0
  00cdc	75 04		 jne	 SHORT $LN1@GetActiveP

; 519  : 	{
; 520  : 		return false;

  00cde	32 c0		 xor	 al, al
  00ce0	eb 1b		 jmp	 SHORT $LN3@GetActiveP
$LN1@GetActiveP:

; 521  : 	}
; 522  : 
; 523  : 	LPOBJ lpUser = &gObj[aIndex];

  00ce2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ce5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00ceb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cf1	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 524  : 
; 525  : 	return lpUser->AccountSecurity.ActivePCID;

  00cf4	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00cf7	8a 80 fc 29 00
	00		 mov	 al, BYTE PTR [eax+10748]
$LN3@GetActiveP:

; 526  : }

  00cfd	5f		 pop	 edi
  00cfe	5e		 pop	 esi
  00cff	5b		 pop	 ebx
  00d00	8b e5		 mov	 esp, ebp
  00d02	5d		 pop	 ebp
  00d03	c2 04 00	 ret	 4
?GetActivePC@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::GetActivePC
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Eg_AccountSecurity@@YAXXZ
text$yc	SEGMENT
??__Eg_AccountSecurity@@YAXXZ PROC			; `dynamic initializer for 'g_AccountSecurity'', COMDAT

; 12   : CAccountSecurity g_AccountSecurity;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  0000e	e8 00 00 00 00	 call	 ??0CAccountSecurity@@QAE@XZ ; CAccountSecurity::CAccountSecurity
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_AccountSecurity@@YAXXZ ; `dynamic atexit destructor for 'g_AccountSecurity''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_AccountSecurity@@YAXXZ ENDP			; `dynamic initializer for 'g_AccountSecurity''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_AccountSecurity@@YAXXZ
text$yd	SEGMENT
??__Fg_AccountSecurity@@YAXXZ PROC			; `dynamic atexit destructor for 'g_AccountSecurity'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  0000e	e8 00 00 00 00	 call	 ??1CAccountSecurity@@QAE@XZ ; CAccountSecurity::~CAccountSecurity
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_AccountSecurity@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_AccountSecurity''
text$yd	ENDS
PUBLIC	?g_AccountSecurity@@3VCAccountSecurity@@A	; g_AccountSecurity
_BSS	SEGMENT
?g_AccountSecurity@@3VCAccountSecurity@@A DB 014H DUP (?) ; g_AccountSecurity
_BSS	ENDS
CRT$XCU	SEGMENT
_g_AccountSecurity$initializer$ DD FLAT:??__Eg_AccountSecurity@@YAXXZ
CRT$XCU	ENDS
END
