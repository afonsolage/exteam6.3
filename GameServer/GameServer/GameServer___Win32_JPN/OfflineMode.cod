; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\OfflineMode.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
PUBLIC	??0OfflineMode@@QAE@XZ				; OfflineMode::OfflineMode
; Function compile flags: /Odtp /ZI /ZX
; File d:\projects\exteam6.3\source\gameserver\gameserver\offlinemode.cpp
;	COMDAT ??0OfflineMode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0OfflineMode@@QAE@XZ PROC				; OfflineMode::OfflineMode, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 28	 add	 ecx, 40			; 00000028H
  00012	e8 00 00 00 00	 call	 ??0?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >

; 36   : 	this->StartBonusPay = 0;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 37   : 	this->HourCredit = 0;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 38   : 	this->m_bLoadedDB = false;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c6 40 19 00	 mov	 BYTE PTR [eax+25], 0

; 39   : }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??0OfflineMode@@QAE@XZ ENDP				; OfflineMode::OfflineMode
_TEXT	ENDS
PUBLIC	??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
PUBLIC	??1OfflineMode@@QAE@XZ				; OfflineMode::~OfflineMode
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??1OfflineMode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1OfflineMode@@QAE@XZ PROC				; OfflineMode::~OfflineMode, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   : }

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 28	 add	 ecx, 40			; 00000028H
  00012	e8 00 00 00 00	 call	 ??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1OfflineMode@@QAE@XZ ENDP				; OfflineMode::~OfflineMode
_TEXT	ENDS
PUBLIC	?Read@OfflineMode@@QAEXPAD@Z			; OfflineMode::Read
PUBLIC	??_C@_0BH@MEHKKMCN@ExData?2OfflineMode?4ini?$AA@ ; `string'
PUBLIC	?Load@OfflineMode@@QAEXXZ			; OfflineMode::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0BH@MEHKKMCN@ExData?2OfflineMode?4ini?$AA@
CONST	SEGMENT
??_C@_0BH@MEHKKMCN@ExData?2OfflineMode?4ini?$AA@ DB 'ExData\OfflineMode.i'
	DB	'ni', 00H					; `string'
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ?Load@OfflineMode@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@OfflineMode@@QAEXXZ PROC				; OfflineMode::Load, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 	this->Read(gDirPath.GetNewPath("ExData\\OfflineMode.ini"));

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MEHKKMCN@ExData?2OfflineMode?4ini?$AA@
  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00016	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Read@OfflineMode@@QAEXPAD@Z ; OfflineMode::Read

; 50   : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?Load@OfflineMode@@QAEXXZ ENDP				; OfflineMode::Load
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXABUOFFMODE_BLOCK_MAP@@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::push_back
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?clear@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::clear
PUBLIC	??_C@_0BF@ILJJBLEP@PremiumPlayerMaxTime?$AA@	; `string'
PUBLIC	??_C@_0BD@FGMGOFJI@OtherPlayerMaxTime?$AA@	; `string'
PUBLIC	??_C@_0BD@NEOBABLC@StandartPlayerTime?$AA@	; `string'
PUBLIC	??_C@_0BA@NMLGBFAO@OnlyLorenMarket?$AA@		; `string'
PUBLIC	??_C@_0L@FGJEOOCJ@HourCredit?$AA@		; `string'
PUBLIC	??_C@_0L@HJHEFBHG@PriceWcoin?$AA@		; `string'
PUBLIC	??_C@_06MLPMCPDE@ExTeam?$AA@			; `string'
PUBLIC	??_C@_08FFJPBABB@PriceZen?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Ex_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Ex_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ILJJBLEP@PremiumPlayerMaxTime?$AA@
CONST	SEGMENT
??_C@_0BF@ILJJBLEP@PremiumPlayerMaxTime?$AA@ DB 'PremiumPlayerMaxTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FGMGOFJI@OtherPlayerMaxTime?$AA@
CONST	SEGMENT
??_C@_0BD@FGMGOFJI@OtherPlayerMaxTime?$AA@ DB 'OtherPlayerMaxTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NEOBABLC@StandartPlayerTime?$AA@
CONST	SEGMENT
??_C@_0BD@NEOBABLC@StandartPlayerTime?$AA@ DB 'StandartPlayerTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NMLGBFAO@OnlyLorenMarket?$AA@
CONST	SEGMENT
??_C@_0BA@NMLGBFAO@OnlyLorenMarket?$AA@ DB 'OnlyLorenMarket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FGJEOOCJ@HourCredit?$AA@
CONST	SEGMENT
??_C@_0L@FGJEOOCJ@HourCredit?$AA@ DB 'HourCredit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HJHEFBHG@PriceWcoin?$AA@
CONST	SEGMENT
??_C@_0L@HJHEFBHG@PriceWcoin?$AA@ DB 'PriceWcoin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLPMCPDE@ExTeam?$AA@
CONST	SEGMENT
??_C@_06MLPMCPDE@ExTeam?$AA@ DB 'ExTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFJPBABB@PriceZen?$AA@
CONST	SEGMENT
??_C@_08FFJPBABB@PriceZen?$AA@ DB 'PriceZen', 00H	; `string'
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ?Read@OfflineMode@@QAEXPAD@Z
_TEXT	SEGMENT
_List$233217 = -280					; size = 4
_n$233216 = -276					; size = 4
_Flag$233208 = -272					; size = 4
_Buff$233207 = -268					; size = 256
_file$233203 = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?Read@OfflineMode@@QAEXPAD@Z PROC			; OfflineMode::Read, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 55   : 	//this->StartBonusPay = GetPrivateProfileInt("ExTeam", "StartBonusPay", 0, filename);
; 56   : 	//this->HourZenPay = GetPrivateProfileInt("ExTeam", "HourZenPay", 0, filename);
; 57   : 	this->PriceZen = GetPrivateProfileInt("ExTeam", "PriceZen", 0, filename);

  00019	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0001c	50		 push	 eax
  0001d	6a 00		 push	 0
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08FFJPBABB@PriceZen?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 58   : 	this->PriceWcoin = GetPrivateProfileInt("ExTeam", "PriceWcoin", 0, filename);

  00035	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00038	50		 push	 eax
  00039	6a 00		 push	 0
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HJHEFBHG@PriceWcoin?$AA@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 59   : 	this->HourCredit = GetPrivateProfileInt("ExTeam", "HourCredit", 0, filename);

  00051	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FGJEOOCJ@HourCredit?$AA@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 60   : 	this->bOnlyLorenMarket = GetPrivateProfileInt("ExTeam", "OnlyLorenMarket", 0, filename);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00070	50		 push	 eax
  00071	6a 00		 push	 0
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NMLGBFAO@OnlyLorenMarket?$AA@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00083	85 c0		 test	 eax, eax
  00085	0f 95 c1	 setne	 cl
  00088	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008b	88 4a 18	 mov	 BYTE PTR [edx+24], cl

; 61   : 
; 62   : 	#if(ADD_OFFMODE_TIMER)
; 63   : 	if(g_ExLicense.CheckUser(eExUB::eternalmu))

  0008e	6a 4f		 push	 79			; 0000004fH
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00095	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0009a	0f b6 c0	 movzx	 eax, al
  0009d	85 c0		 test	 eax, eax
  0009f	74 54		 je	 SHORT $LN10@Read

; 64   : 	{
; 65   : 		this->m_StandartPlayerTime = GetPrivateProfileInt("ExTeam", "StandartPlayerTime", 12, filename);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000a4	50		 push	 eax
  000a5	6a 0c		 push	 12			; 0000000cH
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NEOBABLC@StandartPlayerTime?$AA@
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 66   : 		this->m_OtherPlayerMaxTime = GetPrivateProfileInt("ExTeam", "OtherPlayerMaxTime", 24, filename);

  000bd	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000c0	50		 push	 eax
  000c1	6a 18		 push	 24			; 00000018H
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FGMGOFJI@OtherPlayerMaxTime?$AA@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 67   : 		this->m_PremiumPlayerMaxTime = GetPrivateProfileInt("ExTeam", "PremiumPlayerMaxTime", 72, filename);

  000d9	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000dc	50		 push	 eax
  000dd	6a 48		 push	 72			; 00000048H
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ILJJBLEP@PremiumPlayerMaxTime?$AA@
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN10@Read:

; 68   : 	}
; 69   : 	#endif
; 70   : 
; 71   : 	this->m_BlockMap.clear();

  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	83 c1 28	 add	 ecx, 40			; 00000028H
  000fb	e8 00 00 00 00	 call	 ?clear@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::clear

; 72   : 
; 73   : 	if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 74   : 		g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 75   : 		g_ExLicense.CheckUser(eExUB::SILVER2) )

  00100	6a 00		 push	 0
  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00107	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0010c	0f b6 c0	 movzx	 eax, al
  0010f	85 c0		 test	 eax, eax
  00111	75 2a		 jne	 SHORT $LN8@Read
  00113	6a 07		 push	 7
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0011a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0011f	0f b6 c0	 movzx	 eax, al
  00122	85 c0		 test	 eax, eax
  00124	75 17		 jne	 SHORT $LN8@Read
  00126	6a 08		 push	 8
  00128	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0012d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00132	0f b6 c0	 movzx	 eax, al
  00135	85 c0		 test	 eax, eax
  00137	0f 84 0e 01 00
	00		 je	 $LN11@Read
$LN8@Read:

; 76   : 	{
; 77   : 
; 78   : 		FILE * file = fopen(filename,"r");

  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00142	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _fopen
  0014b	83 c4 08	 add	 esp, 8
  0014e	89 45 f4	 mov	 DWORD PTR _file$233203[ebp], eax

; 79   : 
; 80   : 		if(file == NULL)

  00151	83 7d f4 00	 cmp	 DWORD PTR _file$233203[ebp], 0
  00155	75 13		 jne	 SHORT $LN7@Read

; 81   : 		{
; 82   : 			MessageBoxA(0,filename,"LOAD FILE ERROR",0);

  00157	6a 00		 push	 0
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  0015e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00161	50		 push	 eax
  00162	6a 00		 push	 0
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN7@Read:

; 83   : 		}
; 84   : 
; 85   : 		char Buff[256];
; 86   : 		int Flag = 0;

  0016a	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _Flag$233208[ebp], 0
$LN6@Read:

; 87   : 
; 88   : 		while(!feof(file))

  00174	8b 45 f4	 mov	 eax, DWORD PTR _file$233203[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _feof
  0017d	83 c4 04	 add	 esp, 4
  00180	85 c0		 test	 eax, eax
  00182	0f 85 b7 00 00
	00		 jne	 $LN5@Read

; 89   : 		{
; 90   : 			fgets(Buff,256,file);

  00188	8b 45 f4	 mov	 eax, DWORD PTR _file$233203[ebp]
  0018b	50		 push	 eax
  0018c	68 00 01 00 00	 push	 256			; 00000100H
  00191	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$233207[ebp]
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _fgets
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 			if(Ex_IsBadFileLine(Buff, Flag))

  001a0	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Flag$233208[ebp]
  001a6	50		 push	 eax
  001a7	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$233207[ebp]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 ?Ex_IsBadFileLine@@YA_NPADAAH@Z ; Ex_IsBadFileLine
  001b3	83 c4 08	 add	 esp, 8
  001b6	0f b6 d0	 movzx	 edx, al
  001b9	85 d2		 test	 edx, edx
  001bb	74 02		 je	 SHORT $LN4@Read

; 92   : 				continue;

  001bd	eb b5		 jmp	 SHORT $LN6@Read
$LN4@Read:

; 93   : 
; 94   : 			if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 95   : 				g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 96   : 				g_ExLicense.CheckUser(eExUB::SILVER2) )

  001bf	6a 00		 push	 0
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001c6	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001cb	0f b6 c0	 movzx	 eax, al
  001ce	85 c0		 test	 eax, eax
  001d0	75 26		 jne	 SHORT $LN2@Read
  001d2	6a 07		 push	 7
  001d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001d9	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001de	0f b6 c0	 movzx	 eax, al
  001e1	85 c0		 test	 eax, eax
  001e3	75 13		 jne	 SHORT $LN2@Read
  001e5	6a 08		 push	 8
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001ec	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001f1	0f b6 c0	 movzx	 eax, al
  001f4	85 c0		 test	 eax, eax
  001f6	74 42		 je	 SHORT $LN3@Read
$LN2@Read:

; 97   : 			{
; 98   : 				if(Flag == 1)

  001f8	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR _Flag$233208[ebp], 1
  001ff	75 39		 jne	 SHORT $LN3@Read

; 99   : 				{
; 100  : 					int n;
; 101  : 					sscanf(Buff, "%d", &n);

  00201	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _n$233216[ebp]
  00207	50		 push	 eax
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0020d	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$233207[ebp]
  00213	51		 push	 ecx
  00214	e8 00 00 00 00	 call	 _sscanf
  00219	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  : 					OFFMODE_BLOCK_MAP List;			
; 103  : 					List.MapNumber = n;

  0021c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _n$233216[ebp]
  00222	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _List$233217[ebp], eax

; 104  : 					this->m_BlockMap.push_back(List);

  00228	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _List$233217[ebp]
  0022e	50		 push	 eax
  0022f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	83 c1 28	 add	 ecx, 40			; 00000028H
  00235	e8 00 00 00 00	 call	 ?push_back@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXABUOFFMODE_BLOCK_MAP@@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::push_back
$LN3@Read:

; 105  : 				}
; 106  : 			}
; 107  : 		}

  0023a	e9 35 ff ff ff	 jmp	 $LN6@Read
$LN5@Read:

; 108  : 
; 109  : 		fclose(file);

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _file$233203[ebp]
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 _fclose
  00248	83 c4 04	 add	 esp, 4
$LN11@Read:

; 110  : 	}
; 111  : }

  0024b	5f		 pop	 edi
  0024c	5e		 pop	 esi
  0024d	5b		 pop	 ebx
  0024e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00251	33 cd		 xor	 ecx, ebp
  00253	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 04 00	 ret	 4
?Read@OfflineMode@@QAEXPAD@Z ENDP			; OfflineMode::Read
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	??_C@_0CF@OAEPPEMH@?$FLOfflineMode?$FN?5work?5only?5special?5@ ; `string'
PUBLIC	?CheckBlockMap@OfflineMode@@QAE_NH@Z		; OfflineMode::CheckBlockMap
PUBLIC	__$ArrayPad$
PUBLIC	?Start@OfflineMode@@QAEXPAUCG_OFFMODE_RESULT@@H@Z ; OfflineMode::Start
EXTRN	?SendClose@ConnectEx@@QAEXHH@Z:PROC		; ConnectEx::SendClose
EXTRN	?g_ConnectEx@@3VConnectEx@@A:QWORD		; g_ConnectEx
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
EXTRN	?GetText@CExText@@QAEPADH@Z:PROC		; CExText::GetText
EXTRN	?g_ExText@@3VCExText@@A:BYTE			; g_ExText
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnectedEx@@YA_NH@Z:PROC		; gObjIsConnectedEx
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CF@OAEPPEMH@?$FLOfflineMode?$FN?5work?5only?5special?5@
CONST	SEGMENT
??_C@_0CF@OAEPPEMH@?$FLOfflineMode?$FN?5work?5only?5special?5@ DB '[Offli'
	DB	'neMode] work only special maps', 00H	; `string'
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ?Start@OfflineMode@@QAEXPAUCG_OFFMODE_RESULT@@H@Z
_TEXT	SEGMENT
_szBuff$233246 = -268					; size = 256
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_UserIndex$ = 12					; size = 4
?Start@OfflineMode@@QAEXPAUCG_OFFMODE_RESULT@@H@Z PROC	; OfflineMode::Start, COMDAT
; _this$ = ecx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	if(!g_ExLicense.user.OfflineMode)

  00019	0f b6 05 e2 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+226
  00020	85 c0		 test	 eax, eax
  00022	75 07		 jne	 SHORT $LN7@Start

; 116  : 	{
; 117  : 		g_ExLicense.user.OfflineMode = true;

  00024	c6 05 e2 00 00
	00 01		 mov	 BYTE PTR ?g_ExLicense@@3VCExLicense@@A+226, 1
$LN7@Start:

; 118  : 	}
; 119  : 
; 120  : 	if(!gObjIsConnectedEx(UserIndex))

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00034	83 c4 04	 add	 esp, 4
  00037	0f b6 c8	 movzx	 ecx, al
  0003a	85 c9		 test	 ecx, ecx
  0003c	75 05		 jne	 SHORT $LN6@Start

; 121  : 	{
; 122  : 		return;

  0003e	e9 9a 01 00 00	 jmp	 $LN8@Start
$LN6@Start:

; 123  : 	}
; 124  : 	
; 125  : 	LPOBJ lpUser = &gObj[UserIndex];

  00043	8b 45 0c	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00046	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0004c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 126  : 
; 127  : 	if(lpUser->MapNumber == MAP_INDEX_CASTLESIEGE)

  00055	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00058	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0005f	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00062	75 1e		 jne	 SHORT $LN5@Start

; 128  : 	{
; 129  : 		MsgNormal(UserIndex,g_ExText.GetText(42));

  00064	6a 2a		 push	 42			; 0000002aH
  00066	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  0006b	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00070	50		 push	 eax
  00071	8b 45 0c	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0007a	83 c4 08	 add	 esp, 8

; 130  : 		return;

  0007d	e9 5b 01 00 00	 jmp	 $LN8@Start
$LN5@Start:

; 131  : 	}
; 132  : 
; 133  : 	if(!this->CheckBlockMap(lpUser->MapNumber))

  00082	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00085	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0008c	51		 push	 ecx
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?CheckBlockMap@OfflineMode@@QAE_NH@Z ; OfflineMode::CheckBlockMap
  00095	0f b6 d0	 movzx	 edx, al
  00098	85 d2		 test	 edx, edx
  0009a	75 16		 jne	 SHORT $LN4@Start

; 134  : 	{
; 135  : 		MsgNormal(UserIndex,"[OfflineMode] work only special maps");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OAEPPEMH@?$FLOfflineMode?$FN?5work?5only?5special?5@
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000aa	83 c4 08	 add	 esp, 8

; 136  : 		return;

  000ad	e9 2b 01 00 00	 jmp	 $LN8@Start
$LN4@Start:

; 137  : 	}
; 138  : 
; 139  : 	if(/*g_ExUser.InSafeZone(UserIndex) && */lpUser->m_bPShopOpen == true)

  000b2	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000b5	0f b6 88 c4 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3780]
  000bc	83 f9 01	 cmp	 ecx, 1
  000bf	0f 85 89 00 00
	00		 jne	 $LN3@Start

; 140  : 	{
; 141  : 		char szBuff[256] = { 0 };

  000c5	c6 85 f4 fe ff
	ff 00		 mov	 BYTE PTR _szBuff$233246[ebp], 0
  000cc	68 ff 00 00 00	 push	 255			; 000000ffH
  000d1	6a 00		 push	 0
  000d3	8d 85 f5 fe ff
	ff		 lea	 eax, DWORD PTR _szBuff$233246[ebp+1]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _memset
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 142  : 		if(this->bOnlyLorenMarket && lpUser->MapNumber != 79)

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  000e9	85 c9		 test	 ecx, ecx
  000eb	74 2f		 je	 SHORT $LN2@Start
  000ed	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000f0	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  000f7	83 f9 4f	 cmp	 ecx, 79			; 0000004fH
  000fa	74 20		 je	 SHORT $LN2@Start

; 143  : 		{
; 144  : 			MsgNormal(UserIndex,g_ExText.GetText(43));

  000fc	6a 2b		 push	 43			; 0000002bH
  000fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00103	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00108	50		 push	 eax
  00109	8b 45 0c	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00112	83 c4 08	 add	 esp, 8

; 145  : 			return;

  00115	e9 c3 00 00 00	 jmp	 $LN8@Start

; 146  : 		}
; 147  : 		else

  0011a	eb 32		 jmp	 SHORT $LN3@Start
$LN2@Start:

; 148  : 		{
; 149  : 			sprintf_s(szBuff,g_ExText.GetText(44),lpUser->Name);

  0011c	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0011f	83 c0 77	 add	 eax, 119		; 00000077H
  00122	50		 push	 eax
  00123	6a 2c		 push	 44			; 0000002cH
  00125	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  0012a	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0012f	50		 push	 eax
  00130	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szBuff$233246[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 			AllSendServerMsg(szBuff);

  0013f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szBuff$233246[ebp]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  0014b	83 c4 04	 add	 esp, 4
$LN3@Start:

; 151  : 		}
; 152  : 	}
; 153  : 
; 154  : 	lpUser->m_OfflineSkill = aRecv->Result;

  0014e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00151	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00154	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00158	66 89 90 d6 28
	00 00		 mov	 WORD PTR [eax+10454], dx

; 155  : 	lpUser->m_OfflineAutoBuff = aRecv->BuffResult;

  0015f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00162	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00166	0f 95 c1	 setne	 cl
  00169	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0016c	88 8a d9 28 00
	00		 mov	 BYTE PTR [edx+10457], cl

; 156  : #if(ADD_OFFMODE_PICKUP==TRUE)
; 157  : 	lpUser->m_OfflinePickZen = aRecv->bPickZen;

  00172	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00175	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00179	0f 95 c1	 setne	 cl
  0017c	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0017f	88 8a e0 28 00
	00		 mov	 BYTE PTR [edx+10464], cl

; 158  : 	lpUser->m_OfflinePickJewel = aRecv->bPickJewel;

  00185	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00188	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  0018c	0f 95 c1	 setne	 cl
  0018f	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00192	88 8a e1 28 00
	00		 mov	 BYTE PTR [edx+10465], cl

; 159  : 	lpUser->m_OfflinePickExel = aRecv->bPickExel;

  00198	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0019b	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  0019f	0f 95 c1	 setne	 cl
  001a2	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001a5	88 8a e2 28 00
	00		 mov	 BYTE PTR [edx+10466], cl

; 160  : 	lpUser->m_OfflinePickAnc = aRecv->bPickAnc;

  001ab	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001ae	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  001b2	0f 95 c1	 setne	 cl
  001b5	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001b8	88 8a e3 28 00
	00		 mov	 BYTE PTR [edx+10467], cl

; 161  : #endif
; 162  : 
; 163  : 	#if(ADD_OFFMODE_TIMER)
; 164  : 	lpUser->m_OfflineTimerMax = aRecv->TimerMax;

  001be	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001c1	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  001c4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001c7	89 90 e8 28 00
	00		 mov	 DWORD PTR [eax+10472], edx

; 165  : 	#endif
; 166  : 	
; 167  : 	/*
; 168  : 	if(lpUser->PremiumType <= 0 || lpUser->PremiumTime <= 0)
; 169  : 	{
; 170  : 		if(!g_ExUser.InSafeZone(UserIndex))
; 171  : 		{
; 172  : 			if(this->StartBonusPay > lpUser->Bonus)
; 173  : 			{
; 174  : 				lpUser->m_OfflineMode = false;
; 175  : 				return;
; 176  : 			}
; 177  : 			lpUser->Bonus -= this->StartBonusPay;
; 178  : 		}
; 179  : 	}
; 180  : 	*/
; 181  : #if(_RECONNECT_==TRUE)
; 182  : 	g_ConnectEx.SendClose(UserIndex, TRUE);

  001cd	6a 01		 push	 1
  001cf	8b 45 0c	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  001d2	50		 push	 eax
  001d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectEx@@3VConnectEx@@A ; g_ConnectEx
  001d8	e8 00 00 00 00	 call	 ?SendClose@ConnectEx@@QAEXHH@Z ; ConnectEx::SendClose
$LN8@Start:

; 183  : #else
; 184  : 	CloseClient(UserIndex);
; 185  : 	lpObj->m_OfflineMode = true;
; 186  : #endif
; 187  : }

  001dd	5f		 pop	 edi
  001de	5e		 pop	 esi
  001df	5b		 pop	 ebx
  001e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e3	33 cd		 xor	 ecx, ebp
  001e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c2 08 00	 ret	 8
?Start@OfflineMode@@QAEXPAUCG_OFFMODE_RESULT@@H@Z ENDP	; OfflineMode::Start
_TEXT	ENDS
PUBLIC	?PickUP@OfflineMode@@QAEXH@Z			; OfflineMode::PickUP
PUBLIC	?Fighter@OfflineMode@@QAEXH@Z			; OfflineMode::Fighter
PUBLIC	?Summoner@OfflineMode@@QAEXH@Z			; OfflineMode::Summoner
PUBLIC	?DarkLord@OfflineMode@@QAEXH@Z			; OfflineMode::DarkLord
PUBLIC	?MagicGladiator@OfflineMode@@QAEXH@Z		; OfflineMode::MagicGladiator
PUBLIC	?FairyElf@OfflineMode@@QAEXH@Z			; OfflineMode::FairyElf
PUBLIC	?DarkKnight@OfflineMode@@QAEXH@Z		; OfflineMode::DarkKnight
PUBLIC	?DarkWizard@OfflineMode@@QAEXH@Z		; OfflineMode::DarkWizard
PUBLIC	?Attack@OfflineMode@@QAEXH@Z			; OfflineMode::Attack
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?g_PremiumSystemEx@@3VPremiumSystemEx@@A:BYTE	; g_PremiumSystemEx
EXTRN	?InSafeZone@ÑExUser@@QAE_NH@Z:PROC		; ÑExUser::InSafeZone
EXTRN	?g_ExUser@@3VÑExUser@@A:BYTE			; g_ExUser
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?Attack@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv214 = -80						; size = 4
tv69 = -80						; size = 4
_PremiumResult$ = -10					; size = 1
_AttackFree$ = -9					; size = 1
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?Attack@OfflineMode@@QAEXH@Z PROC			; OfflineMode::Attack, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  : 	if(!g_ExLicense.user.OfflineMode)

  0000c	0f b6 05 e2 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+226
  00013	85 c0		 test	 eax, eax
  00015	75 05		 jne	 SHORT $LN32@Attack

; 193  : 	{
; 194  : 		return;

  00017	e9 1e 03 00 00	 jmp	 $LN33@Attack
$LN32@Attack:

; 195  : 	}
; 196  : 
; 197  : 	if ( OBJMAX_RANGE(UserIndex) == FALSE )

  0001c	83 7d 08 00	 cmp	 DWORD PTR _UserIndex$[ebp], 0
  00020	7d 09		 jge	 SHORT $LN35@Attack
  00022	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00029	eb 0f		 jmp	 SHORT $LN36@Attack
$LN35@Attack:
  0002b	33 c0		 xor	 eax, eax
  0002d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _UserIndex$[ebp], 14999 ; 00003a97H
  00034	0f 9e c0	 setle	 al
  00037	89 45 b0	 mov	 DWORD PTR tv69[ebp], eax
$LN36@Attack:
  0003a	83 7d b0 00	 cmp	 DWORD PTR tv69[ebp], 0
  0003e	75 05		 jne	 SHORT $LN31@Attack

; 198  : 	{
; 199  : 		return;

  00040	e9 f5 02 00 00	 jmp	 $LN33@Attack
$LN31@Attack:

; 200  : 	}
; 201  : 
; 202  : 	if(!gObjIsConnectedEx(UserIndex))

  00045	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  0004e	83 c4 04	 add	 esp, 4
  00051	0f b6 c8	 movzx	 ecx, al
  00054	85 c9		 test	 ecx, ecx
  00056	75 05		 jne	 SHORT $LN30@Attack

; 203  : 	{
; 204  : 		return;

  00058	e9 dd 02 00 00	 jmp	 $LN33@Attack
$LN30@Attack:

; 205  : 	}
; 206  : 
; 207  : 	LPOBJ lpUser = &gObj[UserIndex];

  0005d	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00060	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00066	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006c	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 208  : 
; 209  : 	if(lpUser->m_OfflineMode == false) 

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00072	0f b6 88 d4 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10452]
  00079	85 c9		 test	 ecx, ecx
  0007b	75 05		 jne	 SHORT $LN29@Attack

; 210  : 	{
; 211  : 		return;

  0007d	e9 b8 02 00 00	 jmp	 $LN33@Attack
$LN29@Attack:

; 212  : 	}
; 213  : 
; 214  : 	if(g_ExUser.InSafeZone(UserIndex) == true)

  00082	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00085	50		 push	 eax
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  0008b	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  00090	0f b6 c8	 movzx	 ecx, al
  00093	83 f9 01	 cmp	 ecx, 1
  00096	75 05		 jne	 SHORT $LN28@Attack

; 215  : 	{
; 216  : 		return;

  00098	e9 9d 02 00 00	 jmp	 $LN33@Attack
$LN28@Attack:

; 217  : 	}
; 218  : 
; 219  : 	if(!lpUser->m_OfflineSkill && !lpUser->m_OfflineAutoBuff)

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000a0	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000a7	85 c9		 test	 ecx, ecx
  000a9	75 13		 jne	 SHORT $LN27@Attack
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000ae	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  000b5	85 c9		 test	 ecx, ecx
  000b7	75 05		 jne	 SHORT $LN27@Attack

; 220  : 	{
; 221  : 		return;

  000b9	e9 7c 02 00 00	 jmp	 $LN33@Attack
$LN27@Attack:

; 222  : 	}
; 223  : 
; 224  : 	/*
; 225  : 	if(lpUser->PremiumType <= 0 || lpUser->PremiumTime <= 0)
; 226  : 	{
; 227  : 		lpUser->m_OfflineAttackTime++;
; 228  : 		if(lpUser->m_OfflineAttackTime >= (3600*2))
; 229  : 		{
; 230  : 			if(this->HourZenPay > lpUser->Money)
; 231  : 			{
; 232  : 				lpUser->m_OfflineMode = false;
; 233  : 				return;
; 234  : 			}
; 235  : 			lpUser->Money -= this->HourZenPay;
; 236  : 			lpUser->m_OfflineAttackTime = 0;
; 237  : 		}
; 238  : 	}
; 239  : 	*/
; 240  : 
; 241  : 	bool AttackFree = false;

  000be	c6 45 f7 00	 mov	 BYTE PTR _AttackFree$[ebp], 0

; 242  : 
; 243  : 	if(g_ExLicense.CheckUser(eExUB::SILVER1) || g_ExLicense.CheckUser(eExUB::SILVER2))

  000c2	6a 07		 push	 7
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  000c9	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  000ce	0f b6 c0	 movzx	 eax, al
  000d1	85 c0		 test	 eax, eax
  000d3	75 13		 jne	 SHORT $LN25@Attack
  000d5	6a 08		 push	 8
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  000dc	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  000e1	0f b6 c0	 movzx	 eax, al
  000e4	85 c0		 test	 eax, eax
  000e6	74 21		 je	 SHORT $LN24@Attack
$LN25@Attack:

; 244  : 	{
; 245  : 		if(lpUser->PremiumTimeType == g_PremiumSystemEx.m_iOfflineModeAttackFreePremiumRang && lpUser->PremiumTime > 0)

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000eb	8b 88 bc 22 00
	00		 mov	 ecx, DWORD PTR [eax+8892]
  000f1	3b 0d 4c 00 00
	00		 cmp	 ecx, DWORD PTR ?g_PremiumSystemEx@@3VPremiumSystemEx@@A+76
  000f7	75 10		 jne	 SHORT $LN24@Attack
  000f9	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000fc	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  00103	7e 04		 jle	 SHORT $LN24@Attack

; 246  : 		{
; 247  : 			AttackFree = true;

  00105	c6 45 f7 01	 mov	 BYTE PTR _AttackFree$[ebp], 1
$LN24@Attack:

; 248  : 		}		
; 249  : 	}
; 250  : 
; 251  : 	if(AttackFree == false)

  00109	0f b6 45 f7	 movzx	 eax, BYTE PTR _AttackFree$[ebp]
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 19 01 00
	00		 jne	 $LN15@Attack

; 252  : 	{
; 253  : 		if(this->PriceZen > lpUser->Money || this->PriceWcoin > lpUser->GameShop.WCoinC)

  00115	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00118	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0011b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0011e	3b 91 f0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+240]
  00124	7f 16		 jg	 SHORT $LN21@Attack
  00126	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00129	db 40 10	 fild	 DWORD PTR [eax+16]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0012f	dc 99 00 23 00
	00		 fcomp	 QWORD PTR [ecx+8960]
  00135	df e0		 fnstsw	 ax
  00137	f6 c4 41	 test	 ah, 65			; 00000041H
  0013a	75 05		 jne	 SHORT $LN22@Attack
$LN21@Attack:

; 254  : 		{
; 255  : 			return;

  0013c	e9 f9 01 00 00	 jmp	 $LN33@Attack
$LN22@Attack:

; 256  : 		}
; 257  : 
; 258  : 		if(lpUser->m_OfflineAttackTime == 0)

  00141	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00144	83 b8 dc 28 00
	00 00		 cmp	 DWORD PTR [eax+10460], 0
  0014b	0f 85 dd 00 00
	00		 jne	 $LN15@Attack

; 259  : 		{
; 260  : 			if(this->PriceZen > 0)

  00151	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00154	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00158	7e 38		 jle	 SHORT $LN19@Attack

; 261  : 			{
; 262  : 				if(this->PriceZen > lpUser->Money)

  0015a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00160	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00163	3b 91 f0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+240]
  00169	7e 0f		 jle	 SHORT $LN18@Attack

; 263  : 				{
; 264  : 					lpUser->m_OfflineMode = false;

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0016e	c6 80 d4 28 00
	00 00		 mov	 BYTE PTR [eax+10452], 0

; 265  : 					return;

  00175	e9 c0 01 00 00	 jmp	 $LN33@Attack
$LN18@Attack:

; 266  : 				}
; 267  : 				lpUser->Money -= this->PriceZen;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0017d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	8b 90 f0 00 00
	00		 mov	 edx, DWORD PTR [eax+240]
  00186	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  00189	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0018c	89 90 f0 00 00
	00		 mov	 DWORD PTR [eax+240], edx
$LN19@Attack:

; 268  : 			}
; 269  : 
; 270  : 			if(this->PriceWcoin > 0)

  00192	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00195	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00199	7e 4b		 jle	 SHORT $LN17@Attack

; 271  : 			{
; 272  : 				if(this->PriceWcoin > lpUser->GameShop.WCoinC)

  0019b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019e	db 40 10	 fild	 DWORD PTR [eax+16]
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001a4	dc 99 00 23 00
	00		 fcomp	 QWORD PTR [ecx+8960]
  001aa	df e0		 fnstsw	 ax
  001ac	f6 c4 41	 test	 ah, 65			; 00000041H
  001af	75 0f		 jne	 SHORT $LN16@Attack

; 273  : 				{
; 274  : 					lpUser->m_OfflineMode = false;

  001b1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001b4	c6 80 d4 28 00
	00 00		 mov	 BYTE PTR [eax+10452], 0

; 275  : 					return;

  001bb	e9 7a 01 00 00	 jmp	 $LN33@Attack
$LN16@Attack:

; 276  : 				}
; 277  : 				lpUser->GameShop.WCoinC -= this->PriceWcoin;

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	db 40 10	 fild	 DWORD PTR [eax+16]
  001c6	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001c9	dc a9 00 23 00
	00		 fsubr	 QWORD PTR [ecx+8960]
  001cf	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001d2	dd 9a 00 23 00
	00		 fstp	 QWORD PTR [edx+8960]

; 278  : 				gGameShop.GDSaveUserInfo(UserIndex);

  001d8	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  001db	50		 push	 eax
  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  001e1	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN17@Attack:

; 279  : 			}
; 280  : 
; 281  : 			if(this->HourCredit > 0)

  001e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e9	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  001ed	7e 3f		 jle	 SHORT $LN15@Attack

; 282  : 			{
; 283  : 				if(this->HourCredit > lpUser->ExCred)

  001ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f2	db 40 14	 fild	 DWORD PTR [eax+20]
  001f5	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001f8	d9 81 a8 22 00
	00		 fld	 DWORD PTR [ecx+8872]
  001fe	de d9		 fcompp
  00200	df e0		 fnstsw	 ax
  00202	f6 c4 05	 test	 ah, 5
  00205	7a 0f		 jp	 SHORT $LN14@Attack

; 284  : 				{
; 285  : 					lpUser->m_OfflineMode = false;

  00207	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0020a	c6 80 d4 28 00
	00 00		 mov	 BYTE PTR [eax+10452], 0

; 286  : 					return;

  00211	e9 24 01 00 00	 jmp	 $LN33@Attack
$LN14@Attack:

; 287  : 				}
; 288  : 				lpUser->ExCred -= this->HourCredit;

  00216	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00219	db 40 14	 fild	 DWORD PTR [eax+20]
  0021c	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0021f	d8 a9 a8 22 00
	00		 fsubr	 DWORD PTR [ecx+8872]
  00225	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00228	d9 9a a8 22 00
	00		 fstp	 DWORD PTR [edx+8872]
$LN15@Attack:

; 289  : 			}
; 290  : 		}
; 291  : 	}
; 292  : 
; 293  : 	lpUser->m_OfflineAttackTime++;

  0022e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00231	8b 88 dc 28 00
	00		 mov	 ecx, DWORD PTR [eax+10460]
  00237	83 c1 01	 add	 ecx, 1
  0023a	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0023d	89 8a dc 28 00
	00		 mov	 DWORD PTR [edx+10460], ecx

; 294  : 	if(lpUser->m_OfflineAttackTime >= (3600*2))

  00243	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00246	81 b8 dc 28 00
	00 20 1c 00 00	 cmp	 DWORD PTR [eax+10460], 7200 ; 00001c20H
  00250	7c 53		 jl	 SHORT $LN13@Attack

; 295  : 	{
; 296  : 		#if(ADD_OFFMODE_TIMER)
; 297  : 		if(g_ExLicense.CheckUser(eExUB::eternalmu))

  00252	6a 4f		 push	 79			; 0000004fH
  00254	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00259	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0025e	0f b6 c0	 movzx	 eax, al
  00261	85 c0		 test	 eax, eax
  00263	74 33		 je	 SHORT $LN11@Attack

; 298  : 		{
; 299  : 			lpUser->m_OfflineTimerUser++;

  00265	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00268	8b 88 e4 28 00
	00		 mov	 ecx, DWORD PTR [eax+10468]
  0026e	83 c1 01	 add	 ecx, 1
  00271	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00274	89 8a e4 28 00
	00		 mov	 DWORD PTR [edx+10468], ecx

; 300  : 			if(lpUser->m_OfflineTimerUser >= lpUser->m_OfflineTimerMax)

  0027a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0027d	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00280	8b 90 e4 28 00
	00		 mov	 edx, DWORD PTR [eax+10468]
  00286	3b 91 e8 28 00
	00		 cmp	 edx, DWORD PTR [ecx+10472]
  0028c	7c 0a		 jl	 SHORT $LN11@Attack

; 301  : 			{
; 302  : 			
; 303  : 				lpUser->m_OfflineMode = false;

  0028e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00291	c6 80 d4 28 00
	00 00		 mov	 BYTE PTR [eax+10452], 0
$LN11@Attack:

; 304  : 			}
; 305  : 		}
; 306  : 		#endif
; 307  : 		lpUser->m_OfflineAttackTime = 0;

  00298	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0029b	c7 80 dc 28 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+10460], 0
$LN13@Attack:

; 308  : 	}
; 309  : 
; 310  : 	switch(lpUser->Class)

  002a5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002a8	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  002af	89 4d b0	 mov	 DWORD PTR tv214[ebp], ecx
  002b2	83 7d b0 06	 cmp	 DWORD PTR tv214[ebp], 6
  002b6	77 6a		 ja	 SHORT $LN9@Attack
  002b8	8b 55 b0	 mov	 edx, DWORD PTR tv214[ebp]
  002bb	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN37@Attack[edx*4]
$LN8@Attack:

; 311  : 	{
; 312  : 		case 0:	this->DarkWizard(UserIndex);		break;

  002c2	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  002c5	50		 push	 eax
  002c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c9	e8 00 00 00 00	 call	 ?DarkWizard@OfflineMode@@QAEXH@Z ; OfflineMode::DarkWizard
  002ce	eb 52		 jmp	 SHORT $LN9@Attack
$LN7@Attack:

; 313  : 		case 1:	this->DarkKnight(UserIndex);		break;

  002d0	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  002d3	50		 push	 eax
  002d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d7	e8 00 00 00 00	 call	 ?DarkKnight@OfflineMode@@QAEXH@Z ; OfflineMode::DarkKnight
  002dc	eb 44		 jmp	 SHORT $LN9@Attack
$LN6@Attack:

; 314  : 		case 2:	this->FairyElf(UserIndex);			break;

  002de	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  002e1	50		 push	 eax
  002e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e5	e8 00 00 00 00	 call	 ?FairyElf@OfflineMode@@QAEXH@Z ; OfflineMode::FairyElf
  002ea	eb 36		 jmp	 SHORT $LN9@Attack
$LN5@Attack:

; 315  : 		case 3:	this->MagicGladiator(UserIndex);	break;

  002ec	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  002ef	50		 push	 eax
  002f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f3	e8 00 00 00 00	 call	 ?MagicGladiator@OfflineMode@@QAEXH@Z ; OfflineMode::MagicGladiator
  002f8	eb 28		 jmp	 SHORT $LN9@Attack
$LN4@Attack:

; 316  : 		case 4:	this->DarkLord(UserIndex);			break;

  002fa	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  002fd	50		 push	 eax
  002fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00301	e8 00 00 00 00	 call	 ?DarkLord@OfflineMode@@QAEXH@Z ; OfflineMode::DarkLord
  00306	eb 1a		 jmp	 SHORT $LN9@Attack
$LN3@Attack:

; 317  : 		case 5:	this->Summoner(UserIndex);			break;

  00308	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0030b	50		 push	 eax
  0030c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0030f	e8 00 00 00 00	 call	 ?Summoner@OfflineMode@@QAEXH@Z ; OfflineMode::Summoner
  00314	eb 0c		 jmp	 SHORT $LN9@Attack
$LN2@Attack:

; 318  : 		case 6: this->Fighter(UserIndex);			break;

  00316	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00319	50		 push	 eax
  0031a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	e8 00 00 00 00	 call	 ?Fighter@OfflineMode@@QAEXH@Z ; OfflineMode::Fighter
$LN9@Attack:

; 319  : 	}
; 320  : 
; 321  : #if(ADD_OFFMODE_PICKUP==TRUE)
; 322  : 
; 323  : 	bool PremiumResult = true;

  00322	c6 45 f6 01	 mov	 BYTE PTR _PremiumResult$[ebp], 1

; 324  : 
; 325  : 	//if(g_ExLicense.CheckUser(eExUB::SILVER1) || g_ExLicense.CheckUser(eExUB::SILVER2) || g_ExLicense.CheckUser(eExUB::MedoniAndrei))
; 326  : 	//{
; 327  : 	//	if(lpUser->PremiumTimeType == g_PremiumSystemEx.m_iOfflineModePickUpPremiumRang && lpUser->PremiumTime > 0)
; 328  : 	//	{
; 329  : 	//		PremiumResult = true;
; 330  : 	//	}		
; 331  : 	//}
; 332  : 	//else
; 333  : 	//{
; 334  : 	//	if(lpUser->PremiumTime > 0)
; 335  : 	//	{
; 336  : 	//		PremiumResult = true;
; 337  : 	//	}
; 338  : 	//}
; 339  : 
; 340  : 	//if(lpUser->PremiumTime > 0 /*&& lpUser->PremiumTime > 0*/)
; 341  : 	if(PremiumResult)

  00326	0f b6 45 f6	 movzx	 eax, BYTE PTR _PremiumResult$[ebp]
  0032a	85 c0		 test	 eax, eax
  0032c	74 0c		 je	 SHORT $LN1@Attack

; 342  : 	{
; 343  : 		this->PickUP(UserIndex);

  0032e	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00331	50		 push	 eax
  00332	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00335	e8 00 00 00 00	 call	 ?PickUP@OfflineMode@@QAEXH@Z ; OfflineMode::PickUP
$LN1@Attack:
$LN33@Attack:

; 344  : 	}
; 345  : #endif
; 346  : }

  0033a	5f		 pop	 edi
  0033b	5e		 pop	 esi
  0033c	5b		 pop	 ebx
  0033d	8b e5		 mov	 esp, ebp
  0033f	5d		 pop	 ebp
  00340	c2 04 00	 ret	 4
  00343	90		 npad	 1
$LN37@Attack:
  00344	00 00 00 00	 DD	 $LN8@Attack
  00348	00 00 00 00	 DD	 $LN7@Attack
  0034c	00 00 00 00	 DD	 $LN6@Attack
  00350	00 00 00 00	 DD	 $LN5@Attack
  00354	00 00 00 00	 DD	 $LN4@Attack
  00358	00 00 00 00	 DD	 $LN3@Attack
  0035c	00 00 00 00	 DD	 $LN2@Attack
?Attack@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::Attack
_TEXT	ENDS
PUBLIC	?SearchTarget@OfflineMode@@QAEHHH@Z		; OfflineMode::SearchTarget
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagicSearch
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?DarkWizard@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv237 = -120						; size = 4
tv90 = -120						; size = 4
_lpMonster$233349 = -52					; size = 4
_TargetIndex$233344 = -48				; size = 4
_n$233333 = -44						; size = 4
_MaxDis$ = -40						; size = 4
_tObjNum$ = -36						; size = 4
_j$233308 = -32						; size = 4
_lpPartyObj$233306 = -28				; size = 4
_number$233305 = -24					; size = 4
_partycount$233304 = -20				; size = 4
_partynum$233303 = -16					; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?DarkWizard@OfflineMode@@QAEXH@Z PROC			; OfflineMode::DarkWizard, COMDAT
; _this$ = ecx

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  : 	if(!gObjIsConnectedEx(UserIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00015	83 c4 04	 add	 esp, 4
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 05		 jne	 SHORT $LN39@DarkWizard

; 352  : 	{
; 353  : 		return;

  0001f	e9 b8 04 00 00	 jmp	 $LN40@DarkWizard
$LN39@DarkWizard:

; 354  : 	}
; 355  : 
; 356  : 	LPOBJ lpUser = &gObj[UserIndex];

  00024	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00027	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 357  : 
; 358  : 	CMagicInf *lpMagic;
; 359  : 
; 360  : 	//Buff Mana shield
; 361  : 	if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00039	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  00040	83 f9 01	 cmp	 ecx, 1
  00043	0f 85 13 02 00
	00		 jne	 $LN38@DarkWizard
  00049	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0004c	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00053	85 c9		 test	 ecx, ecx
  00055	0f 85 01 02 00
	00		 jne	 $LN38@DarkWizard

; 362  : 	{
; 363  : 		int partynum = -1;

  0005b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _partynum$233303[ebp], -1

; 364  : 		int partycount;
; 365  : 		int number;
; 366  : 
; 367  : 		LPOBJ lpPartyObj;
; 368  : 
; 369  : 		partynum = lpUser->PartyNumber;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00065	8b 88 2c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1068]
  0006b	89 4d f0	 mov	 DWORD PTR _partynum$233303[ebp], ecx

; 370  : 
; 371  : 		if(partynum != -1)

  0006e	83 7d f0 ff	 cmp	 DWORD PTR _partynum$233303[ebp], -1
  00072	0f 84 13 01 00
	00		 je	 $LN37@DarkWizard

; 372  : 		{
; 373  : 			partycount = gParty.m_PartyS[partynum].Count;

  00078	8b 45 f0	 mov	 eax, DWORD PTR _partynum$233303[ebp]
  0007b	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0007e	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+8]
  00084	89 4d ec	 mov	 DWORD PTR _partycount$233304[ebp], ecx

; 374  : 
; 375  : 			for(int j = 0; j < MAX_USER_IN_PARTY; j++)

  00087	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$233308[ebp], 0
  0008e	eb 09		 jmp	 SHORT $LN36@DarkWizard
$LN35@DarkWizard:
  00090	8b 45 e0	 mov	 eax, DWORD PTR _j$233308[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 e0	 mov	 DWORD PTR _j$233308[ebp], eax
$LN36@DarkWizard:
  00099	83 7d e0 0a	 cmp	 DWORD PTR _j$233308[ebp], 10 ; 0000000aH
  0009d	0f 8d e6 00 00
	00		 jge	 $LN34@DarkWizard

; 376  : 			{
; 377  : 				number = gParty.m_PartyS[partynum].Number[j];

  000a3	8b 45 f0	 mov	 eax, DWORD PTR _partynum$233303[ebp]
  000a6	6b c0 6c	 imul	 eax, 108		; 0000006cH
  000a9	8b 4d e0	 mov	 ecx, DWORD PTR _j$233308[ebp]
  000ac	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000b3	89 55 e8	 mov	 DWORD PTR _number$233305[ebp], edx

; 378  : 
; 379  : 				if ( OBJMAX_RANGE(number) == TRUE )

  000b6	83 7d e8 00	 cmp	 DWORD PTR _number$233305[ebp], 0
  000ba	7d 09		 jge	 SHORT $LN42@DarkWizard
  000bc	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  000c3	eb 0f		 jmp	 SHORT $LN43@DarkWizard
$LN42@DarkWizard:
  000c5	33 c0		 xor	 eax, eax
  000c7	81 7d e8 97 3a
	00 00		 cmp	 DWORD PTR _number$233305[ebp], 14999 ; 00003a97H
  000ce	0f 9e c0	 setle	 al
  000d1	89 45 88	 mov	 DWORD PTR tv90[ebp], eax
$LN43@DarkWizard:
  000d4	83 7d 88 01	 cmp	 DWORD PTR tv90[ebp], 1
  000d8	0f 85 a6 00 00
	00		 jne	 $LN33@DarkWizard

; 380  : 				{
; 381  : 					lpPartyObj = &gObj[number];

  000de	8b 45 e8	 mov	 eax, DWORD PTR _number$233305[ebp]
  000e1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  000e7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ed	89 45 e4	 mov	 DWORD PTR _lpPartyObj$233306[ebp], eax

; 382  : 
; 383  : 					if(lpUser->MapNumber == lpPartyObj->MapNumber)

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000f3	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _lpPartyObj$233306[ebp]
  000fd	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00104	3b c8		 cmp	 ecx, eax
  00106	75 7c		 jne	 SHORT $LN33@DarkWizard

; 384  : 					{
; 385  : 						if(gObjCalDistance(lpUser, lpPartyObj) < 6)

  00108	8b 45 e4	 mov	 eax, DWORD PTR _lpPartyObj$233306[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00115	83 c4 08	 add	 esp, 8
  00118	83 f8 06	 cmp	 eax, 6
  0011b	7d 67		 jge	 SHORT $LN33@DarkWizard

; 386  : 						{
; 387  : 							//MS
; 388  : 							lpMagic = gObjGetMagicSearch( lpUser, 16);

  0011d	6a 10		 push	 16			; 00000010H
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00128	83 c4 08	 add	 esp, 8
  0012b	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 389  : 							if(lpMagic != NULL) 

  0012e	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00132	74 1c		 je	 SHORT $LN30@DarkWizard

; 390  : 							{		
; 391  : 								gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  00134	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00137	50		 push	 eax
  00138	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233306[ebp]
  0013b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013d	52		 push	 edx
  0013e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00141	8b 08		 mov	 ecx, DWORD PTR [eax]
  00143	51		 push	 ecx
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00149	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 392  : 							}
; 393  : 							else

  0014e	eb 34		 jmp	 SHORT $LN33@DarkWizard
$LN30@DarkWizard:

; 394  : 							{	
; 395  : 								lpMagic = gObjGetMagicSearch(lpUser, 403);

  00150	68 93 01 00 00	 push	 403			; 00000193H
  00155	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0015e	83 c4 08	 add	 esp, 8
  00161	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 396  : 								if(lpMagic != NULL) 

  00164	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00168	74 1a		 je	 SHORT $LN33@DarkWizard

; 397  : 								{		
; 398  : 									gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  0016a	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00171	8b 11		 mov	 edx, DWORD PTR [ecx]
  00173	52		 push	 edx
  00174	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00177	8b 08		 mov	 ecx, DWORD PTR [eax]
  00179	51		 push	 ecx
  0017a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0017f	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN33@DarkWizard:

; 399  : 								}
; 400  : 							}
; 401  : 						}
; 402  : 					}
; 403  : 				}
; 404  : 			}

  00184	e9 07 ff ff ff	 jmp	 $LN35@DarkWizard
$LN34@DarkWizard:

; 405  : 		}
; 406  : 		else

  00189	eb 67		 jmp	 SHORT $LN27@DarkWizard
$LN37@DarkWizard:

; 407  : 		{
; 408  : 			//MS
; 409  : 			lpMagic = gObjGetMagicSearch(lpUser, 16);

  0018b	6a 10		 push	 16			; 00000010H
  0018d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00196	83 c4 08	 add	 esp, 8
  00199	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 410  : 			if(lpMagic != NULL) 

  0019c	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001a0	74 1c		 je	 SHORT $LN26@DarkWizard

; 411  : 			{		
; 412  : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  001a2	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001a5	50		 push	 eax
  001a6	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001a9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ab	52		 push	 edx
  001ac	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001af	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b1	51		 push	 ecx
  001b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001b7	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 413  : 			}
; 414  : 			else

  001bc	eb 34		 jmp	 SHORT $LN27@DarkWizard
$LN26@DarkWizard:

; 415  : 			{	
; 416  : 				lpMagic = gObjGetMagicSearch(lpUser, 403);

  001be	68 93 01 00 00	 push	 403			; 00000193H
  001c3	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  001cc	83 c4 08	 add	 esp, 8
  001cf	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 417  : 				if(lpMagic != NULL) 

  001d2	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001d6	74 1a		 je	 SHORT $LN27@DarkWizard

; 418  : 				{		
; 419  : 					gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  001d8	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001db	50		 push	 eax
  001dc	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001df	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e1	52		 push	 edx
  001e2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e7	51		 push	 ecx
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001ed	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN27@DarkWizard:

; 420  : 				}
; 421  : 			}
; 422  : 		}
; 423  : 
; 424  : 		// Wizard Buff Damage
; 425  : 		lpMagic = gObjGetMagicSearch(lpUser, 233);

  001f2	68 e9 00 00 00	 push	 233			; 000000e9H
  001f7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00200	83 c4 08	 add	 esp, 8
  00203	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 426  : 		if(lpMagic != NULL) 

  00206	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0020a	74 1c		 je	 SHORT $LN23@DarkWizard

; 427  : 		{		
; 428  : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  0020c	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0020f	50		 push	 eax
  00210	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00213	8b 11		 mov	 edx, DWORD PTR [ecx]
  00215	52		 push	 edx
  00216	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00219	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021b	51		 push	 ecx
  0021c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00221	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 429  : 		}
; 430  : 		else

  00226	eb 34		 jmp	 SHORT $LN38@DarkWizard
$LN23@DarkWizard:

; 431  : 		{
; 432  : 			lpMagic = gObjGetMagicSearch(lpUser, 380);

  00228	68 7c 01 00 00	 push	 380			; 0000017cH
  0022d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00236	83 c4 08	 add	 esp, 8
  00239	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 433  : 			if(lpMagic != NULL) 

  0023c	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00240	74 1a		 je	 SHORT $LN38@DarkWizard

; 434  : 			{		
; 435  : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00242	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00245	50		 push	 eax
  00246	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00249	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024b	52		 push	 edx
  0024c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0024f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00251	51		 push	 ecx
  00252	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00257	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN38@DarkWizard:

; 436  : 			}
; 437  : 		}
; 438  : 	}
; 439  : 
; 440  : 	lpUser->m_OfflineBuffTime++;

  0025c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0025f	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  00265	80 c1 01	 add	 cl, 1
  00268	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0026b	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 441  : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  00271	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00274	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  0027b	83 f9 14	 cmp	 ecx, 20			; 00000014H
  0027e	7c 0a		 jl	 SHORT $LN20@DarkWizard

; 442  : 	{
; 443  : 		lpUser->m_OfflineBuffTime = 0;

  00280	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00283	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN20@DarkWizard:

; 444  : 	}
; 445  : 
; 446  : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  0028a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0028d	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00294	51		 push	 ecx
  00295	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00298	52		 push	 edx
  00299	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0029e	83 c4 08	 add	 esp, 8
  002a1	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 447  : 
; 448  : 	if(!lpMagic)

  002a4	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  002a8	75 05		 jne	 SHORT $LN19@DarkWizard

; 449  : 	{
; 450  : 		return;

  002aa	e9 2d 02 00 00	 jmp	 $LN40@DarkWizard
$LN19@DarkWizard:

; 451  : 	}
; 452  : 
; 453  : 	int tObjNum;
; 454  : 	int MaxDis = 0;

  002af	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 0

; 455  : 
; 456  : 	if(lpUser->m_OfflineSkill == 9)

  002b6	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002b9	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  002c0	83 f9 09	 cmp	 ecx, 9
  002c3	75 09		 jne	 SHORT $LN18@DarkWizard

; 457  : 	{
; 458  : 		MaxDis = 6;

  002c5	c7 45 d8 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6

; 459  : 	}
; 460  : 	else

  002cc	eb 07		 jmp	 SHORT $LN17@DarkWizard
$LN18@DarkWizard:

; 461  : 	{
; 462  : 		MaxDis = 3;

  002ce	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 3
$LN17@DarkWizard:

; 463  : 	}
; 464  : 
; 465  : 	// Evil Spirit or Inferno
; 466  : 	if(lpUser->m_OfflineSkill == 9		|| 
; 467  : 		lpUser->m_OfflineSkill == 385	|| 
; 468  : 		lpUser->m_OfflineSkill == 14	||
; 469  : 		lpUser->m_OfflineSkill == 381)

  002d5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002d8	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  002df	83 f9 09	 cmp	 ecx, 9
  002e2	74 37		 je	 SHORT $LN15@DarkWizard
  002e4	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002e7	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  002ee	81 f9 81 01 00
	00		 cmp	 ecx, 385		; 00000181H
  002f4	74 25		 je	 SHORT $LN15@DarkWizard
  002f6	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002f9	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00300	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00303	74 16		 je	 SHORT $LN15@DarkWizard
  00305	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00308	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0030f	81 f9 7d 01 00
	00		 cmp	 ecx, 381		; 0000017dH
  00315	0f 85 28 01 00
	00		 jne	 $LN16@DarkWizard
$LN15@DarkWizard:

; 470  : 	{
; 471  : 		gObjUseSkill.UseSkill(UserIndex, lpMagic, lpUser->X, lpUser->Y, 0, 0, -1);

  0031b	6a ff		 push	 -1
  0031d	6a 00		 push	 0
  0031f	6a 00		 push	 0
  00321	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00324	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  0032b	51		 push	 ecx
  0032c	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0032f	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  00336	50		 push	 eax
  00337	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  0033a	51		 push	 ecx
  0033b	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  0033e	52		 push	 edx
  0033f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00344	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 472  : 
; 473  : 		for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  00349	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$233333[ebp], 0
  00350	eb 09		 jmp	 SHORT $LN14@DarkWizard
$LN13@DarkWizard:
  00352	8b 45 d4	 mov	 eax, DWORD PTR _n$233333[ebp]
  00355	83 c0 01	 add	 eax, 1
  00358	89 45 d4	 mov	 DWORD PTR _n$233333[ebp], eax
$LN14@DarkWizard:
  0035b	83 7d d4 4b	 cmp	 DWORD PTR _n$233333[ebp], 75 ; 0000004bH
  0035f	0f 8d d9 00 00
	00		 jge	 $LN12@DarkWizard

; 474  : 		{
; 475  : 			tObjNum = lpUser->VpPlayer2[n].number;

  00365	8b 45 d4	 mov	 eax, DWORD PTR _n$233333[ebp]
  00368	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0036b	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0036e	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  00376	89 55 dc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 476  : 
; 477  : 			if(lpUser->VpPlayer2[n].state == 0)

  00379	8b 45 d4	 mov	 eax, DWORD PTR _n$233333[ebp]
  0037c	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0037f	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00382	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  0038a	85 d2		 test	 edx, edx
  0038c	75 02		 jne	 SHORT $LN11@DarkWizard

; 478  : 			{
; 479  : 				continue;

  0038e	eb c2		 jmp	 SHORT $LN13@DarkWizard
$LN11@DarkWizard:

; 480  : 			}
; 481  : 			if (OBJMAX_RANGE(tObjNum) == FALSE)

  00390	83 7d dc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00394	7d 09		 jge	 SHORT $LN44@DarkWizard
  00396	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv237[ebp], 0
  0039d	eb 0f		 jmp	 SHORT $LN45@DarkWizard
$LN44@DarkWizard:
  0039f	33 c0		 xor	 eax, eax
  003a1	81 7d dc 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$[ebp], 14999 ; 00003a97H
  003a8	0f 9e c0	 setle	 al
  003ab	89 45 88	 mov	 DWORD PTR tv237[ebp], eax
$LN45@DarkWizard:
  003ae	83 7d 88 00	 cmp	 DWORD PTR tv237[ebp], 0
  003b2	75 02		 jne	 SHORT $LN10@DarkWizard

; 482  : 			{
; 483  : 				continue;

  003b4	eb 9c		 jmp	 SHORT $LN13@DarkWizard
$LN10@DarkWizard:

; 484  : 			}
; 485  : 			if ( gObj[tObjNum].Type != OBJ_MONSTER )

  003b6	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  003b9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c5	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  003ca	83 fa 02	 cmp	 edx, 2
  003cd	74 02		 je	 SHORT $LN9@DarkWizard

; 486  : 			{
; 487  : 				continue;

  003cf	eb 81		 jmp	 SHORT $LN13@DarkWizard
$LN9@DarkWizard:

; 488  : 			}
; 489  : 			if(g_ExUser.InSafeZone(tObjNum) == true)

  003d1	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  003d4	50		 push	 eax
  003d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  003da	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  003df	0f b6 c8	 movzx	 ecx, al
  003e2	83 f9 01	 cmp	 ecx, 1
  003e5	75 05		 jne	 SHORT $LN8@DarkWizard

; 490  : 			{
; 491  : 				continue;

  003e7	e9 66 ff ff ff	 jmp	 $LN13@DarkWizard
$LN8@DarkWizard:

; 492  : 			}
; 493  : 			if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  003ec	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  003ef	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003f5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003fb	50		 push	 eax
  003fc	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  003ff	51		 push	 ecx
  00400	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00405	83 c4 08	 add	 esp, 8
  00408	39 45 d8	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  0040b	7c 2c		 jl	 SHORT $LN7@DarkWizard

; 494  : 			{
; 495  : 				gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  0040d	6a 00		 push	 0
  0040f	6a 00		 push	 0
  00411	6a 00		 push	 0
  00413	6a 00		 push	 0
  00415	6a 01		 push	 1
  00417	6a 00		 push	 0
  00419	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0041c	50		 push	 eax
  0041d	8b 4d dc	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  00420	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00426	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042c	51		 push	 ecx
  0042d	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00430	52		 push	 edx
  00431	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00436	83 c4 24	 add	 esp, 36			; 00000024H
$LN7@DarkWizard:

; 496  : 			}
; 497  : 		}

  00439	e9 14 ff ff ff	 jmp	 $LN13@DarkWizard
$LN12@DarkWizard:

; 498  : 	}
; 499  : 	// Ice Shtorm
; 500  : 	else if(lpUser->m_OfflineSkill == 39)

  0043e	e9 99 00 00 00	 jmp	 $LN40@DarkWizard
$LN16@DarkWizard:
  00443	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00446	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0044d	83 f9 27	 cmp	 ecx, 39			; 00000027H
  00450	0f 85 86 00 00
	00		 jne	 $LN40@DarkWizard

; 501  : 	{
; 502  : 		int TargetIndex = this->SearchTarget(UserIndex, MaxDis);

  00456	8b 45 d8	 mov	 eax, DWORD PTR _MaxDis$[ebp]
  00459	50		 push	 eax
  0045a	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  0045d	51		 push	 ecx
  0045e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	e8 00 00 00 00	 call	 ?SearchTarget@OfflineMode@@QAEHHH@Z ; OfflineMode::SearchTarget
  00466	89 45 d0	 mov	 DWORD PTR _TargetIndex$233344[ebp], eax

; 503  : 
; 504  : 		if(TargetIndex == -1) 

  00469	83 7d d0 ff	 cmp	 DWORD PTR _TargetIndex$233344[ebp], -1
  0046d	75 02		 jne	 SHORT $LN4@DarkWizard

; 505  : 		{
; 506  : 			return;

  0046f	eb 6b		 jmp	 SHORT $LN40@DarkWizard
$LN4@DarkWizard:

; 507  : 		}
; 508  : 		if ( TargetIndex < 0 || TargetIndex > OBJMAX-1)

  00471	83 7d d0 00	 cmp	 DWORD PTR _TargetIndex$233344[ebp], 0
  00475	7c 09		 jl	 SHORT $LN2@DarkWizard
  00477	81 7d d0 97 3a
	00 00		 cmp	 DWORD PTR _TargetIndex$233344[ebp], 14999 ; 00003a97H
  0047e	7e 02		 jle	 SHORT $LN3@DarkWizard
$LN2@DarkWizard:

; 509  : 		{
; 510  : 			return;

  00480	eb 5a		 jmp	 SHORT $LN40@DarkWizard
$LN3@DarkWizard:

; 511  : 		}
; 512  : 		if ( gObj[TargetIndex].Connected < PLAYER_PLAYING )

  00482	8b 45 d0	 mov	 eax, DWORD PTR _TargetIndex$233344[ebp]
  00485	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0048b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00491	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00496	7d 02		 jge	 SHORT $LN1@DarkWizard

; 513  : 		{
; 514  : 			return;

  00498	eb 42		 jmp	 SHORT $LN40@DarkWizard
$LN1@DarkWizard:

; 515  : 		}
; 516  : 
; 517  : 		LPOBJ lpMonster = &gObj[TargetIndex];

  0049a	8b 45 d0	 mov	 eax, DWORD PTR _TargetIndex$233344[ebp]
  0049d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004a3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004a9	89 45 cc	 mov	 DWORD PTR _lpMonster$233349[ebp], eax

; 518  : 
; 519  : 		gObjUseSkill.UseSkill(UserIndex, lpMagic, lpMonster->X, lpMonster->Y, 0, 0, TargetIndex);

  004ac	8b 45 d0	 mov	 eax, DWORD PTR _TargetIndex$233344[ebp]
  004af	50		 push	 eax
  004b0	6a 00		 push	 0
  004b2	6a 00		 push	 0
  004b4	8b 4d cc	 mov	 ecx, DWORD PTR _lpMonster$233349[ebp]
  004b7	0f b6 91 46 01
	00 00		 movzx	 edx, BYTE PTR [ecx+326]
  004be	52		 push	 edx
  004bf	8b 45 cc	 mov	 eax, DWORD PTR _lpMonster$233349[ebp]
  004c2	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  004c9	51		 push	 ecx
  004ca	8b 55 f4	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  004cd	52		 push	 edx
  004ce	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  004d1	50		 push	 eax
  004d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  004d7	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill
$LN40@DarkWizard:

; 520  : 	}
; 521  : }

  004dc	5f		 pop	 edi
  004dd	5e		 pop	 esi
  004de	5b		 pop	 ebx
  004df	8b e5		 mov	 esp, ebp
  004e1	5d		 pop	 ebp
  004e2	c2 04 00	 ret	 4
?DarkWizard@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::DarkWizard
_TEXT	ENDS
PUBLIC	?OffTimer@OfflineMode@@QAE_NHH@Z		; OfflineMode::OffTimer
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?DarkKnight@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv283 = -104						; size = 4
tv214 = -104						; size = 4
_lpMonster$233406 = -36					; size = 4
_TargetIndex$233401 = -32				; size = 4
_n$233389 = -28						; size = 4
_n$233376 = -24						; size = 4
_MaxDis$ = -20						; size = 4
_tObjNum$ = -16						; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?DarkKnight@OfflineMode@@QAEXH@Z PROC			; OfflineMode::DarkKnight, COMDAT
; _this$ = ecx

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 526  : 	if(!gObjIsConnectedEx(UserIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00015	83 c4 04	 add	 esp, 4
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 05		 jne	 SHORT $LN45@DarkKnight

; 527  : 	{
; 528  : 		return;

  0001f	e9 bc 05 00 00	 jmp	 $LN46@DarkKnight
$LN45@DarkKnight:

; 529  : 	}
; 530  : 
; 531  : 	LPOBJ lpUser = &gObj[UserIndex];

  00024	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00027	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 532  : 
; 533  : 	CMagicInf *lpMagic;
; 534  : 
; 535  : 	// HP Buff
; 536  : 	if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00039	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  00040	83 f9 01	 cmp	 ecx, 1
  00043	75 75		 jne	 SHORT $LN44@DarkKnight
  00045	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00048	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  0004f	85 c9		 test	 ecx, ecx
  00051	75 67		 jne	 SHORT $LN44@DarkKnight

; 537  : 	{
; 538  : 		lpMagic = gObjGetMagicSearch( lpUser, 48);

  00053	6a 30		 push	 48			; 00000030H
  00055	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0005e	83 c4 08	 add	 esp, 8
  00061	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 539  : 		if(lpMagic != NULL) 

  00064	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00068	74 1c		 je	 SHORT $LN43@DarkKnight

; 540  : 		{		
; 541  : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	52		 push	 edx
  00074	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	51		 push	 ecx
  0007a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0007f	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 542  : 		}
; 543  : 		else

  00084	eb 34		 jmp	 SHORT $LN44@DarkKnight
$LN43@DarkKnight:

; 544  : 		{
; 545  : 			lpMagic = gObjGetMagicSearch(lpUser, 356);

  00086	68 64 01 00 00	 push	 356			; 00000164H
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00094	83 c4 08	 add	 esp, 8
  00097	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 546  : 			if(lpMagic != NULL) 

  0009a	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0009e	74 1a		 je	 SHORT $LN44@DarkKnight

; 547  : 			{		
; 548  : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a9	52		 push	 edx
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	51		 push	 ecx
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000b5	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN44@DarkKnight:

; 549  : 			}			
; 550  : 		}
; 551  : 	}
; 552  : 
; 553  : 	lpUser->m_OfflineBuffTime++;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000bd	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  000c3	80 c1 01	 add	 cl, 1
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000c9	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 554  : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000d2	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  000d9	83 f9 14	 cmp	 ecx, 20			; 00000014H
  000dc	7c 0a		 jl	 SHORT $LN40@DarkKnight

; 555  : 	{
; 556  : 		lpUser->m_OfflineBuffTime = 0;

  000de	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000e1	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN40@DarkKnight:

; 557  : 	}
; 558  : 
; 559  : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000eb	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000f2	51		 push	 ecx
  000f3	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000fc	83 c4 08	 add	 esp, 8
  000ff	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 560  : 
; 561  : 	if(!lpMagic)

  00102	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00106	75 05		 jne	 SHORT $LN39@DarkKnight

; 562  : 	{
; 563  : 		return;

  00108	e9 d3 04 00 00	 jmp	 $LN46@DarkKnight
$LN39@DarkKnight:

; 564  : 	}
; 565  : 
; 566  : 	int tObjNum;
; 567  : 	int MaxDis = 0;

  0010d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 0

; 568  : 
; 569  : 	if(lpUser->m_OfflineSkill == 41 || lpUser->m_OfflineSkill == 330 || lpUser->m_OfflineSkill == 332 || lpUser->m_OfflineSkill == 481)

  00114	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00117	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0011e	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00121	74 36		 je	 SHORT $LN37@DarkKnight
  00123	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00126	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0012d	81 f9 4a 01 00
	00		 cmp	 ecx, 330		; 0000014aH
  00133	74 24		 je	 SHORT $LN37@DarkKnight
  00135	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00138	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0013f	81 f9 4c 01 00
	00		 cmp	 ecx, 332		; 0000014cH
  00145	74 12		 je	 SHORT $LN37@DarkKnight
  00147	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0014a	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00151	81 f9 e1 01 00
	00		 cmp	 ecx, 481		; 000001e1H
  00157	75 0c		 jne	 SHORT $LN38@DarkKnight
$LN37@DarkKnight:

; 570  : 	{
; 571  : 		MaxDis = 2;

  00159	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 2
  00160	e9 8b 00 00 00	 jmp	 $LN36@DarkKnight
$LN38@DarkKnight:

; 572  : 	}
; 573  : 	else if(lpUser->m_OfflineSkill == 42 || lpUser->m_OfflineSkill == 331 || lpUser->m_OfflineSkill == 333)

  00165	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00168	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0016f	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00172	74 24		 je	 SHORT $LN34@DarkKnight
  00174	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00177	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0017e	81 f9 4b 01 00
	00		 cmp	 ecx, 331		; 0000014bH
  00184	74 12		 je	 SHORT $LN34@DarkKnight
  00186	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00189	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00190	81 f9 4d 01 00
	00		 cmp	 ecx, 333		; 0000014dH
  00196	75 09		 jne	 SHORT $LN35@DarkKnight
$LN34@DarkKnight:

; 574  : 	{
; 575  : 		MaxDis = 3;

  00198	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 3
  0019f	eb 4f		 jmp	 SHORT $LN36@DarkKnight
$LN35@DarkKnight:

; 576  : 	}
; 577  : 	else if(lpUser->m_OfflineSkill == 232 || lpUser->m_OfflineSkill == 337 || lpUser->m_OfflineSkill == 340 || lpUser->m_OfflineSkill == 343)

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001a4	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  001ab	81 f9 e8 00 00
	00		 cmp	 ecx, 232		; 000000e8H
  001b1	74 36		 je	 SHORT $LN31@DarkKnight
  001b3	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001b6	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  001bd	81 f9 51 01 00
	00		 cmp	 ecx, 337		; 00000151H
  001c3	74 24		 je	 SHORT $LN31@DarkKnight
  001c5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001c8	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  001cf	81 f9 54 01 00
	00		 cmp	 ecx, 340		; 00000154H
  001d5	74 12		 je	 SHORT $LN31@DarkKnight
  001d7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001da	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  001e1	81 f9 57 01 00
	00		 cmp	 ecx, 343		; 00000157H
  001e7	75 07		 jne	 SHORT $LN36@DarkKnight
$LN31@DarkKnight:

; 578  : 	{
; 579  : 		MaxDis = 5;

  001e9	c7 45 ec 05 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 5
$LN36@DarkKnight:

; 580  : 	}
; 581  : 
; 582  : 	// Twisting Slash
; 583  : 	if( lpUser->m_OfflineSkill == 41  || 
; 584  : 		lpUser->m_OfflineSkill == 330 ||
; 585  : 		lpUser->m_OfflineSkill == 332 ||
; 586  : 		lpUser->m_OfflineSkill == 481 )	//42 - óðåçàòü ñêîðîñòü â 2-3 ðàçà

  001f0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001f3	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  001fa	83 f9 29	 cmp	 ecx, 41			; 00000029H
  001fd	74 3a		 je	 SHORT $LN29@DarkKnight
  001ff	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00202	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00209	81 f9 4a 01 00
	00		 cmp	 ecx, 330		; 0000014aH
  0020f	74 28		 je	 SHORT $LN29@DarkKnight
  00211	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00214	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0021b	81 f9 4c 01 00
	00		 cmp	 ecx, 332		; 0000014cH
  00221	74 16		 je	 SHORT $LN29@DarkKnight
  00223	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00226	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0022d	81 f9 e1 01 00
	00		 cmp	 ecx, 481		; 000001e1H
  00233	0f 85 42 01 00
	00		 jne	 $LN30@DarkKnight
$LN29@DarkKnight:

; 587  : 	{
; 588  : 		if(this->OffTimer(UserIndex, 3) == true)	//3

  00239	6a 03		 push	 3
  0023b	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0023e	50		 push	 eax
  0023f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00242	e8 00 00 00 00	 call	 ?OffTimer@OfflineMode@@QAE_NHH@Z ; OfflineMode::OffTimer
  00247	0f b6 c8	 movzx	 ecx, al
  0024a	83 f9 01	 cmp	 ecx, 1
  0024d	0f 85 23 01 00
	00		 jne	 $LN28@DarkKnight

; 589  : 		{
; 590  : 			gObjUseSkill.UseSkill(UserIndex, lpMagic,lpUser->X, lpUser->Y,0,0,-1);

  00253	6a ff		 push	 -1
  00255	6a 00		 push	 0
  00257	6a 00		 push	 0
  00259	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0025c	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  00263	51		 push	 ecx
  00264	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00267	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  0026e	50		 push	 eax
  0026f	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00272	51		 push	 ecx
  00273	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  00276	52		 push	 edx
  00277	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0027c	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 591  : 
; 592  : 			for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  00281	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$233376[ebp], 0
  00288	eb 09		 jmp	 SHORT $LN27@DarkKnight
$LN26@DarkKnight:
  0028a	8b 45 e8	 mov	 eax, DWORD PTR _n$233376[ebp]
  0028d	83 c0 01	 add	 eax, 1
  00290	89 45 e8	 mov	 DWORD PTR _n$233376[ebp], eax
$LN27@DarkKnight:
  00293	83 7d e8 4b	 cmp	 DWORD PTR _n$233376[ebp], 75 ; 0000004bH
  00297	0f 8d d9 00 00
	00		 jge	 $LN28@DarkKnight

; 593  : 			{
; 594  : 				tObjNum = lpUser->VpPlayer2[n].number;

  0029d	8b 45 e8	 mov	 eax, DWORD PTR _n$233376[ebp]
  002a0	6b c0 0c	 imul	 eax, 12			; 0000000cH
  002a3	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  002a6	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  002ae	89 55 f0	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 595  : 
; 596  : 				if(lpUser->VpPlayer2[n].state == 0)

  002b1	8b 45 e8	 mov	 eax, DWORD PTR _n$233376[ebp]
  002b4	6b c0 0c	 imul	 eax, 12			; 0000000cH
  002b7	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  002ba	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  002c2	85 d2		 test	 edx, edx
  002c4	75 02		 jne	 SHORT $LN24@DarkKnight

; 597  : 				{
; 598  : 					continue;

  002c6	eb c2		 jmp	 SHORT $LN26@DarkKnight
$LN24@DarkKnight:

; 599  : 				}
; 600  : 				if (OBJMAX_RANGE(tObjNum) == FALSE)

  002c8	83 7d f0 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  002cc	7d 09		 jge	 SHORT $LN48@DarkKnight
  002ce	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv214[ebp], 0
  002d5	eb 0f		 jmp	 SHORT $LN49@DarkKnight
$LN48@DarkKnight:
  002d7	33 c0		 xor	 eax, eax
  002d9	81 7d f0 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$[ebp], 14999 ; 00003a97H
  002e0	0f 9e c0	 setle	 al
  002e3	89 45 98	 mov	 DWORD PTR tv214[ebp], eax
$LN49@DarkKnight:
  002e6	83 7d 98 00	 cmp	 DWORD PTR tv214[ebp], 0
  002ea	75 02		 jne	 SHORT $LN23@DarkKnight

; 601  : 				{
; 602  : 					continue;

  002ec	eb 9c		 jmp	 SHORT $LN26@DarkKnight
$LN23@DarkKnight:

; 603  : 				}
; 604  : 				if ( gObj[tObjNum].Type != OBJ_MONSTER )

  002ee	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  002f1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fd	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00302	83 fa 02	 cmp	 edx, 2
  00305	74 02		 je	 SHORT $LN22@DarkKnight

; 605  : 				{
; 606  : 					continue;

  00307	eb 81		 jmp	 SHORT $LN26@DarkKnight
$LN22@DarkKnight:

; 607  : 				}
; 608  : 				if(g_ExUser.InSafeZone(tObjNum) == true)

  00309	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0030c	50		 push	 eax
  0030d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  00312	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  00317	0f b6 c8	 movzx	 ecx, al
  0031a	83 f9 01	 cmp	 ecx, 1
  0031d	75 05		 jne	 SHORT $LN21@DarkKnight

; 609  : 				{
; 610  : 					continue;

  0031f	e9 66 ff ff ff	 jmp	 $LN26@DarkKnight
$LN21@DarkKnight:

; 611  : 				}
; 612  : 				if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  00324	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00327	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0032d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00333	50		 push	 eax
  00334	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00337	51		 push	 ecx
  00338	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0033d	83 c4 08	 add	 esp, 8
  00340	39 45 ec	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  00343	7c 2c		 jl	 SHORT $LN20@DarkKnight

; 613  : 				{
; 614  : 					gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  00345	6a 00		 push	 0
  00347	6a 00		 push	 0
  00349	6a 00		 push	 0
  0034b	6a 00		 push	 0
  0034d	6a 01		 push	 1
  0034f	6a 00		 push	 0
  00351	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00354	50		 push	 eax
  00355	8b 4d f0	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  00358	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0035e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00364	51		 push	 ecx
  00365	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00368	52		 push	 edx
  00369	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0036e	83 c4 24	 add	 esp, 36			; 00000024H
$LN20@DarkKnight:

; 615  : 				}
; 616  : 			}

  00371	e9 14 ff ff ff	 jmp	 $LN26@DarkKnight
$LN28@DarkKnight:

; 617  : 		}
; 618  : 	}
; 619  : 	// Rageful Blow
; 620  : 	else if( lpUser->m_OfflineSkill == 42  ||

  00376	e9 65 02 00 00	 jmp	 $LN46@DarkKnight
$LN30@DarkKnight:

; 621  : 		lpUser->m_OfflineSkill == 331 ||
; 622  : 		lpUser->m_OfflineSkill == 333 )	//42 - óðåçàòü ñêîðîñòü â 2-3 ðàçà

  0037b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0037e	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00385	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00388	74 28		 je	 SHORT $LN17@DarkKnight
  0038a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0038d	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00394	81 f9 4b 01 00
	00		 cmp	 ecx, 331		; 0000014bH
  0039a	74 16		 je	 SHORT $LN17@DarkKnight
  0039c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0039f	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  003a6	81 f9 4d 01 00
	00		 cmp	 ecx, 333		; 0000014dH
  003ac	0f 85 42 01 00
	00		 jne	 $LN18@DarkKnight
$LN17@DarkKnight:

; 623  : 	{
; 624  : 		if(this->OffTimer(UserIndex, 4) == true)

  003b2	6a 04		 push	 4
  003b4	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  003b7	50		 push	 eax
  003b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003bb	e8 00 00 00 00	 call	 ?OffTimer@OfflineMode@@QAE_NHH@Z ; OfflineMode::OffTimer
  003c0	0f b6 c8	 movzx	 ecx, al
  003c3	83 f9 01	 cmp	 ecx, 1
  003c6	0f 85 23 01 00
	00		 jne	 $LN16@DarkKnight

; 625  : 		{
; 626  : 			gObjUseSkill.UseSkill(UserIndex, lpMagic,lpUser->X, lpUser->Y,0,0,-1);

  003cc	6a ff		 push	 -1
  003ce	6a 00		 push	 0
  003d0	6a 00		 push	 0
  003d2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  003d5	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  003dc	51		 push	 ecx
  003dd	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  003e0	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  003e7	50		 push	 eax
  003e8	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  003eb	51		 push	 ecx
  003ec	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  003ef	52		 push	 edx
  003f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  003f5	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 627  : 
; 628  : 			for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  003fa	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _n$233389[ebp], 0
  00401	eb 09		 jmp	 SHORT $LN15@DarkKnight
$LN14@DarkKnight:
  00403	8b 45 e4	 mov	 eax, DWORD PTR _n$233389[ebp]
  00406	83 c0 01	 add	 eax, 1
  00409	89 45 e4	 mov	 DWORD PTR _n$233389[ebp], eax
$LN15@DarkKnight:
  0040c	83 7d e4 4b	 cmp	 DWORD PTR _n$233389[ebp], 75 ; 0000004bH
  00410	0f 8d d9 00 00
	00		 jge	 $LN16@DarkKnight

; 629  : 			{
; 630  : 				tObjNum = lpUser->VpPlayer2[n].number;

  00416	8b 45 e4	 mov	 eax, DWORD PTR _n$233389[ebp]
  00419	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0041c	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0041f	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  00427	89 55 f0	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 631  : 
; 632  : 				if(lpUser->VpPlayer2[n].state == 0)

  0042a	8b 45 e4	 mov	 eax, DWORD PTR _n$233389[ebp]
  0042d	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00430	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00433	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  0043b	85 d2		 test	 edx, edx
  0043d	75 02		 jne	 SHORT $LN12@DarkKnight

; 633  : 				{
; 634  : 					continue;

  0043f	eb c2		 jmp	 SHORT $LN14@DarkKnight
$LN12@DarkKnight:

; 635  : 				}
; 636  : 				if (OBJMAX_RANGE(tObjNum) == FALSE)

  00441	83 7d f0 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00445	7d 09		 jge	 SHORT $LN50@DarkKnight
  00447	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv283[ebp], 0
  0044e	eb 0f		 jmp	 SHORT $LN51@DarkKnight
$LN50@DarkKnight:
  00450	33 c0		 xor	 eax, eax
  00452	81 7d f0 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$[ebp], 14999 ; 00003a97H
  00459	0f 9e c0	 setle	 al
  0045c	89 45 98	 mov	 DWORD PTR tv283[ebp], eax
$LN51@DarkKnight:
  0045f	83 7d 98 00	 cmp	 DWORD PTR tv283[ebp], 0
  00463	75 02		 jne	 SHORT $LN11@DarkKnight

; 637  : 				{
; 638  : 					continue;

  00465	eb 9c		 jmp	 SHORT $LN14@DarkKnight
$LN11@DarkKnight:

; 639  : 				}
; 640  : 				if ( gObj[tObjNum].Type != OBJ_MONSTER )

  00467	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0046a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00470	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00476	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0047b	83 fa 02	 cmp	 edx, 2
  0047e	74 02		 je	 SHORT $LN10@DarkKnight

; 641  : 				{
; 642  : 					continue;

  00480	eb 81		 jmp	 SHORT $LN14@DarkKnight
$LN10@DarkKnight:

; 643  : 				}
; 644  : 				if(g_ExUser.InSafeZone(tObjNum) == true)

  00482	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00485	50		 push	 eax
  00486	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  0048b	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  00490	0f b6 c8	 movzx	 ecx, al
  00493	83 f9 01	 cmp	 ecx, 1
  00496	75 05		 jne	 SHORT $LN9@DarkKnight

; 645  : 				{
; 646  : 					continue;

  00498	e9 66 ff ff ff	 jmp	 $LN14@DarkKnight
$LN9@DarkKnight:

; 647  : 				}
; 648  : 				if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  0049d	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  004a0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004a6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ac	50		 push	 eax
  004ad	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  004b0	51		 push	 ecx
  004b1	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  004b6	83 c4 08	 add	 esp, 8
  004b9	39 45 ec	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  004bc	7c 2c		 jl	 SHORT $LN8@DarkKnight

; 649  : 				{
; 650  : 					gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  004be	6a 00		 push	 0
  004c0	6a 00		 push	 0
  004c2	6a 00		 push	 0
  004c4	6a 00		 push	 0
  004c6	6a 01		 push	 1
  004c8	6a 00		 push	 0
  004ca	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  004cd	50		 push	 eax
  004ce	8b 4d f0	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  004d1	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  004d7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004dd	51		 push	 ecx
  004de	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  004e1	52		 push	 edx
  004e2	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  004e7	83 c4 24	 add	 esp, 36			; 00000024H
$LN8@DarkKnight:

; 651  : 				}
; 652  : 			}

  004ea	e9 14 ff ff ff	 jmp	 $LN14@DarkKnight
$LN16@DarkKnight:

; 653  : 		}
; 654  : 	}
; 655  : 	// BK top skill
; 656  : 	else if(lpUser->m_OfflineSkill == 232 ||

  004ef	e9 ec 00 00 00	 jmp	 $LN46@DarkKnight
$LN18@DarkKnight:

; 657  : 			lpUser->m_OfflineSkill == 337 ||
; 658  : 			lpUser->m_OfflineSkill == 340 ||
; 659  : 			lpUser->m_OfflineSkill == 343 &&
; 660  : 			this->OffTimer(UserIndex, 4) == true)	//232 - óðåçàòü ñêîðîñòü â 3-4 ðàçà

  004f4	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  004f7	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  004fe	81 f9 e8 00 00
	00		 cmp	 ecx, 232		; 000000e8H
  00504	74 54		 je	 SHORT $LN5@DarkKnight
  00506	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00509	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00510	81 f9 51 01 00
	00		 cmp	 ecx, 337		; 00000151H
  00516	74 42		 je	 SHORT $LN5@DarkKnight
  00518	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0051b	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00522	81 f9 54 01 00
	00		 cmp	 ecx, 340		; 00000154H
  00528	74 30		 je	 SHORT $LN5@DarkKnight
  0052a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0052d	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00534	81 f9 57 01 00
	00		 cmp	 ecx, 343		; 00000157H
  0053a	0f 85 a0 00 00
	00		 jne	 $LN46@DarkKnight
  00540	6a 04		 push	 4
  00542	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00545	50		 push	 eax
  00546	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00549	e8 00 00 00 00	 call	 ?OffTimer@OfflineMode@@QAE_NHH@Z ; OfflineMode::OffTimer
  0054e	0f b6 c8	 movzx	 ecx, al
  00551	83 f9 01	 cmp	 ecx, 1
  00554	0f 85 86 00 00
	00		 jne	 $LN46@DarkKnight
$LN5@DarkKnight:

; 661  : 	{
; 662  : 		int TargetIndex = this->SearchTarget(UserIndex, MaxDis);

  0055a	8b 45 ec	 mov	 eax, DWORD PTR _MaxDis$[ebp]
  0055d	50		 push	 eax
  0055e	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00561	51		 push	 ecx
  00562	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00565	e8 00 00 00 00	 call	 ?SearchTarget@OfflineMode@@QAEHHH@Z ; OfflineMode::SearchTarget
  0056a	89 45 e0	 mov	 DWORD PTR _TargetIndex$233401[ebp], eax

; 663  : 
; 664  : 		if(TargetIndex == -1) 

  0056d	83 7d e0 ff	 cmp	 DWORD PTR _TargetIndex$233401[ebp], -1
  00571	75 02		 jne	 SHORT $LN4@DarkKnight

; 665  : 		{
; 666  : 			return;

  00573	eb 6b		 jmp	 SHORT $LN46@DarkKnight
$LN4@DarkKnight:

; 667  : 		}
; 668  : 		if (TargetIndex < 0 || TargetIndex > OBJMAX-1)

  00575	83 7d e0 00	 cmp	 DWORD PTR _TargetIndex$233401[ebp], 0
  00579	7c 09		 jl	 SHORT $LN2@DarkKnight
  0057b	81 7d e0 97 3a
	00 00		 cmp	 DWORD PTR _TargetIndex$233401[ebp], 14999 ; 00003a97H
  00582	7e 02		 jle	 SHORT $LN3@DarkKnight
$LN2@DarkKnight:

; 669  : 		{
; 670  : 			return;

  00584	eb 5a		 jmp	 SHORT $LN46@DarkKnight
$LN3@DarkKnight:

; 671  : 		}
; 672  : 		if (gObj[TargetIndex].Connected < PLAYER_PLAYING)

  00586	8b 45 e0	 mov	 eax, DWORD PTR _TargetIndex$233401[ebp]
  00589	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0058f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00595	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0059a	7d 02		 jge	 SHORT $LN1@DarkKnight

; 673  : 		{
; 674  : 			return;

  0059c	eb 42		 jmp	 SHORT $LN46@DarkKnight
$LN1@DarkKnight:

; 675  : 		}
; 676  : 
; 677  : 		LPOBJ lpMonster = &gObj[TargetIndex];

  0059e	8b 45 e0	 mov	 eax, DWORD PTR _TargetIndex$233401[ebp]
  005a1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  005a7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005ad	89 45 dc	 mov	 DWORD PTR _lpMonster$233406[ebp], eax

; 678  : 
; 679  : 		gObjUseSkill.UseSkill(UserIndex, lpMagic, lpMonster->X, lpMonster->Y, 0, 0, TargetIndex);

  005b0	8b 45 e0	 mov	 eax, DWORD PTR _TargetIndex$233401[ebp]
  005b3	50		 push	 eax
  005b4	6a 00		 push	 0
  005b6	6a 00		 push	 0
  005b8	8b 4d dc	 mov	 ecx, DWORD PTR _lpMonster$233406[ebp]
  005bb	0f b6 91 46 01
	00 00		 movzx	 edx, BYTE PTR [ecx+326]
  005c2	52		 push	 edx
  005c3	8b 45 dc	 mov	 eax, DWORD PTR _lpMonster$233406[ebp]
  005c6	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  005cd	51		 push	 ecx
  005ce	8b 55 f4	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  005d1	52		 push	 edx
  005d2	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  005d5	50		 push	 eax
  005d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  005db	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill
$LN46@DarkKnight:

; 680  : 	}
; 681  : }

  005e0	5f		 pop	 edi
  005e1	5e		 pop	 esi
  005e2	5b		 pop	 ebx
  005e3	8b e5		 mov	 esp, ebp
  005e5	5d		 pop	 ebp
  005e6	c2 04 00	 ret	 4
?DarkKnight@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::DarkKnight
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?FairyElf@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv281 = -128						; size = 4
tv90 = -128						; size = 4
_lpMonster$233478 = -60					; size = 4
_n$233461 = -56						; size = 4
_TargetIndex$ = -52					; size = 4
_MaxCount$ = -48					; size = 4
_AttackCount$ = -44					; size = 4
_MaxDis$ = -40						; size = 4
_tObjNum$ = -36						; size = 4
_j$233420 = -32						; size = 4
_lpPartyObj$233418 = -28				; size = 4
_number$233417 = -24					; size = 4
_partycount$233416 = -20				; size = 4
_partynum$233415 = -16					; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?FairyElf@OfflineMode@@QAEXH@Z PROC			; OfflineMode::FairyElf, COMDAT
; _this$ = ecx

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 686  : 	if(!gObjIsConnectedEx(UserIndex))

  0000f	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00018	83 c4 04	 add	 esp, 4
  0001b	0f b6 c8	 movzx	 ecx, al
  0001e	85 c9		 test	 ecx, ecx
  00020	75 05		 jne	 SHORT $LN54@FairyElf

; 687  : 	{
; 688  : 		return;

  00022	e9 86 06 00 00	 jmp	 $LN55@FairyElf
$LN54@FairyElf:

; 689  : 	}
; 690  : 
; 691  : 	LPOBJ lpUser = &gObj[UserIndex];

  00027	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0002a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 692  : 
; 693  : 	CMagicInf *lpMagic;
; 694  : 
; 695  : 	//Buff
; 696  : 	if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)

  00039	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0003c	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  00043	83 f9 01	 cmp	 ecx, 1
  00046	0f 85 57 03 00
	00		 jne	 $LN53@FairyElf
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0004f	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00056	85 c9		 test	 ecx, ecx
  00058	0f 85 45 03 00
	00		 jne	 $LN53@FairyElf

; 697  : 	{
; 698  : 		int partynum = -1;

  0005e	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _partynum$233415[ebp], -1

; 699  : 		int partycount;
; 700  : 		int number = -1;

  00065	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _number$233417[ebp], -1

; 701  : 
; 702  : 		LPOBJ lpPartyObj;
; 703  : 
; 704  : 		partynum = lpUser->PartyNumber;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0006f	8b 88 2c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1068]
  00075	89 4d f0	 mov	 DWORD PTR _partynum$233415[ebp], ecx

; 705  : 
; 706  : 		if(partynum != -1)

  00078	83 7d f0 ff	 cmp	 DWORD PTR _partynum$233415[ebp], -1
  0007c	0f 84 ec 01 00
	00		 je	 $LN52@FairyElf

; 707  : 		{
; 708  : 			partycount = gParty.m_PartyS[partynum].Count;

  00082	8b 45 f0	 mov	 eax, DWORD PTR _partynum$233415[ebp]
  00085	6b c0 6c	 imul	 eax, 108		; 0000006cH
  00088	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+8]
  0008e	89 4d ec	 mov	 DWORD PTR _partycount$233416[ebp], ecx

; 709  : 
; 710  : 			for(int j = 0; j < MAX_USER_IN_PARTY; j++)

  00091	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$233420[ebp], 0
  00098	eb 09		 jmp	 SHORT $LN51@FairyElf
$LN50@FairyElf:
  0009a	8b 45 e0	 mov	 eax, DWORD PTR _j$233420[ebp]
  0009d	83 c0 01	 add	 eax, 1
  000a0	89 45 e0	 mov	 DWORD PTR _j$233420[ebp], eax
$LN51@FairyElf:
  000a3	83 7d e0 0a	 cmp	 DWORD PTR _j$233420[ebp], 10 ; 0000000aH
  000a7	0f 8d bc 01 00
	00		 jge	 $LN49@FairyElf

; 711  : 			{
; 712  : 				number = gParty.m_PartyS[partynum].Number[j];

  000ad	8b 45 f0	 mov	 eax, DWORD PTR _partynum$233415[ebp]
  000b0	6b c0 6c	 imul	 eax, 108		; 0000006cH
  000b3	8b 4d e0	 mov	 ecx, DWORD PTR _j$233420[ebp]
  000b6	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000bd	89 55 e8	 mov	 DWORD PTR _number$233417[ebp], edx

; 713  : 
; 714  : 				if ( OBJMAX_RANGE(number) == TRUE )

  000c0	83 7d e8 00	 cmp	 DWORD PTR _number$233417[ebp], 0
  000c4	7d 09		 jge	 SHORT $LN57@FairyElf
  000c6	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  000cd	eb 0f		 jmp	 SHORT $LN58@FairyElf
$LN57@FairyElf:
  000cf	33 c0		 xor	 eax, eax
  000d1	81 7d e8 97 3a
	00 00		 cmp	 DWORD PTR _number$233417[ebp], 14999 ; 00003a97H
  000d8	0f 9e c0	 setle	 al
  000db	89 45 80	 mov	 DWORD PTR tv90[ebp], eax
$LN58@FairyElf:
  000de	83 7d 80 01	 cmp	 DWORD PTR tv90[ebp], 1
  000e2	0f 85 7c 01 00
	00		 jne	 $LN48@FairyElf

; 715  : 				{
; 716  : 					lpPartyObj = &gObj[number];

  000e8	8b 45 e8	 mov	 eax, DWORD PTR _number$233417[ebp]
  000eb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  000f1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f7	89 45 e4	 mov	 DWORD PTR _lpPartyObj$233418[ebp], eax

; 717  : 
; 718  : 					if(lpUser->MapNumber == lpPartyObj->MapNumber)

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000fd	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00104	8b 55 e4	 mov	 edx, DWORD PTR _lpPartyObj$233418[ebp]
  00107	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0010e	3b c8		 cmp	 ecx, eax
  00110	0f 85 4e 01 00
	00		 jne	 $LN48@FairyElf

; 719  : 					{
; 720  : 						if(gObjCalDistance(lpUser, lpPartyObj) < 6)

  00116	8b 45 e4	 mov	 eax, DWORD PTR _lpPartyObj$233418[ebp]
  00119	50		 push	 eax
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00123	83 c4 08	 add	 esp, 8
  00126	83 f8 06	 cmp	 eax, 6
  00129	0f 8d 35 01 00
	00		 jge	 $LN48@FairyElf

; 721  : 						{
; 722  : 							//Defence Baf
; 723  : 							lpMagic = gObjGetMagicSearch(lpUser, 27);

  0012f	6a 1b		 push	 27			; 0000001bH
  00131	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0013a	83 c4 08	 add	 esp, 8
  0013d	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 724  : 							if(lpMagic != NULL) 

  00140	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00144	74 1c		 je	 SHORT $LN45@FairyElf

; 725  : 							{		
; 726  : 								gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  00146	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233418[ebp]
  0014d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014f	52		 push	 edx
  00150	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00153	8b 08		 mov	 ecx, DWORD PTR [eax]
  00155	51		 push	 ecx
  00156	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0015b	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 727  : 							}
; 728  : 							else

  00160	eb 34		 jmp	 SHORT $LN44@FairyElf
$LN45@FairyElf:

; 729  : 							{
; 730  : 								lpMagic = gObjGetMagicSearch(lpUser, 417);

  00162	68 a1 01 00 00	 push	 417			; 000001a1H
  00167	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00170	83 c4 08	 add	 esp, 8
  00173	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 731  : 								if(lpMagic != NULL) 

  00176	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0017a	74 1a		 je	 SHORT $LN44@FairyElf

; 732  : 								{		
; 733  : 									gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  0017c	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233418[ebp]
  00183	8b 11		 mov	 edx, DWORD PTR [ecx]
  00185	52		 push	 edx
  00186	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	51		 push	 ecx
  0018c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00191	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN44@FairyElf:

; 734  : 								}
; 735  : 							}
; 736  : 							//Damage Baf
; 737  : 							lpMagic = gObjGetMagicSearch(lpUser, 28);

  00196	6a 1c		 push	 28			; 0000001cH
  00198	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  001a1	83 c4 08	 add	 esp, 8
  001a4	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 738  : 							if(lpMagic != NULL) 

  001a7	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001ab	74 1c		 je	 SHORT $LN42@FairyElf

; 739  : 							{		
; 740  : 								gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  001ad	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001b0	50		 push	 eax
  001b1	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233418[ebp]
  001b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b6	52		 push	 edx
  001b7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bc	51		 push	 ecx
  001bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001c2	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 741  : 							}
; 742  : 							else

  001c7	eb 34		 jmp	 SHORT $LN41@FairyElf
$LN42@FairyElf:

; 743  : 							{
; 744  : 								lpMagic = gObjGetMagicSearch(lpUser, 420);

  001c9	68 a4 01 00 00	 push	 420			; 000001a4H
  001ce	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  001d7	83 c4 08	 add	 esp, 8
  001da	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 745  : 								if(lpMagic != NULL) 

  001dd	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001e1	74 1a		 je	 SHORT $LN41@FairyElf

; 746  : 								{		
; 747  : 									gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  001e3	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001e6	50		 push	 eax
  001e7	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233418[ebp]
  001ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ec	52		 push	 edx
  001ed	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f2	51		 push	 ecx
  001f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001f8	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN41@FairyElf:

; 748  : 								}
; 749  : 							}
; 750  : 							//Heal Baf
; 751  : 							lpMagic = gObjGetMagicSearch(lpUser, 26);

  001fd	6a 1a		 push	 26			; 0000001aH
  001ff	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00208	83 c4 08	 add	 esp, 8
  0020b	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 752  : 							if(lpMagic != NULL) 

  0020e	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00212	74 1c		 je	 SHORT $LN39@FairyElf

; 753  : 							{		
; 754  : 								gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  00214	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00217	50		 push	 eax
  00218	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233418[ebp]
  0021b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021d	52		 push	 edx
  0021e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	51		 push	 ecx
  00224	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00229	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 755  : 							}
; 756  : 							else

  0022e	eb 34		 jmp	 SHORT $LN48@FairyElf
$LN39@FairyElf:

; 757  : 							{
; 758  : 								lpMagic = gObjGetMagicSearch(lpUser, 413);

  00230	68 9d 01 00 00	 push	 413			; 0000019dH
  00235	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0023e	83 c4 08	 add	 esp, 8
  00241	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 759  : 								if(lpMagic != NULL) 

  00244	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00248	74 1a		 je	 SHORT $LN48@FairyElf

; 760  : 								{		
; 761  : 									gObjUseSkill.UseSkill(lpUser->m_Index, lpPartyObj->m_Index, lpMagic);

  0024a	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0024d	50		 push	 eax
  0024e	8b 4d e4	 mov	 ecx, DWORD PTR _lpPartyObj$233418[ebp]
  00251	8b 11		 mov	 edx, DWORD PTR [ecx]
  00253	52		 push	 edx
  00254	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00257	8b 08		 mov	 ecx, DWORD PTR [eax]
  00259	51		 push	 ecx
  0025a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0025f	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN48@FairyElf:

; 762  : 								}
; 763  : 							}
; 764  : 						}
; 765  : 					}
; 766  : 				}
; 767  : 			}

  00264	e9 31 fe ff ff	 jmp	 $LN50@FairyElf
$LN49@FairyElf:

; 768  : 		}
; 769  : 		else

  00269	e9 35 01 00 00	 jmp	 $LN53@FairyElf
$LN52@FairyElf:

; 770  : 		{
; 771  : 			//Defence Baf
; 772  : 			lpMagic = gObjGetMagicSearch(lpUser, 27);

  0026e	6a 1b		 push	 27			; 0000001bH
  00270	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00279	83 c4 08	 add	 esp, 8
  0027c	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 773  : 			if(lpMagic != NULL) 

  0027f	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00283	74 1c		 je	 SHORT $LN35@FairyElf

; 774  : 			{		
; 775  : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00285	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00288	50		 push	 eax
  00289	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0028c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028e	52		 push	 edx
  0028f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00292	8b 08		 mov	 ecx, DWORD PTR [eax]
  00294	51		 push	 ecx
  00295	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0029a	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 776  : 			}
; 777  : 			else

  0029f	eb 34		 jmp	 SHORT $LN34@FairyElf
$LN35@FairyElf:

; 778  : 			{
; 779  : 				lpMagic = gObjGetMagicSearch(lpUser, 417);

  002a1	68 a1 01 00 00	 push	 417			; 000001a1H
  002a6	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  002af	83 c4 08	 add	 esp, 8
  002b2	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 780  : 				if(lpMagic != NULL) 

  002b5	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  002b9	74 1a		 je	 SHORT $LN34@FairyElf

; 781  : 				{		
; 782  : 					gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  002bb	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002be	50		 push	 eax
  002bf	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  002c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c4	52		 push	 edx
  002c5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ca	51		 push	 ecx
  002cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  002d0	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN34@FairyElf:

; 783  : 				}
; 784  : 			}
; 785  : 			//Damage Baf
; 786  : 			lpMagic = gObjGetMagicSearch(lpUser, 28);

  002d5	6a 1c		 push	 28			; 0000001cH
  002d7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  002e0	83 c4 08	 add	 esp, 8
  002e3	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 787  : 			if(lpMagic != NULL) 

  002e6	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  002ea	74 1c		 je	 SHORT $LN32@FairyElf

; 788  : 			{		
; 789  : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  002ec	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002ef	50		 push	 eax
  002f0	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  002f3	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f5	52		 push	 edx
  002f6	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fb	51		 push	 ecx
  002fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00301	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 790  : 			}
; 791  : 			else

  00306	eb 34		 jmp	 SHORT $LN31@FairyElf
$LN32@FairyElf:

; 792  : 			{
; 793  : 				lpMagic = gObjGetMagicSearch(lpUser, 420);

  00308	68 a4 01 00 00	 push	 420			; 000001a4H
  0030d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00310	50		 push	 eax
  00311	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00316	83 c4 08	 add	 esp, 8
  00319	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 794  : 				if(lpMagic != NULL) 

  0031c	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00320	74 1a		 je	 SHORT $LN31@FairyElf

; 795  : 				{		
; 796  : 					gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00322	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00325	50		 push	 eax
  00326	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00329	8b 11		 mov	 edx, DWORD PTR [ecx]
  0032b	52		 push	 edx
  0032c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0032f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00331	51		 push	 ecx
  00332	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00337	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN31@FairyElf:

; 797  : 				}
; 798  : 			}
; 799  : 			//Heal Baf
; 800  : 			lpMagic = gObjGetMagicSearch(lpUser, 26);

  0033c	6a 1a		 push	 26			; 0000001aH
  0033e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00347	83 c4 08	 add	 esp, 8
  0034a	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 801  : 			if(lpMagic != NULL) 

  0034d	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00351	74 1c		 je	 SHORT $LN29@FairyElf

; 802  : 			{		
; 803  : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00353	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00356	50		 push	 eax
  00357	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0035a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0035c	52		 push	 edx
  0035d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00360	8b 08		 mov	 ecx, DWORD PTR [eax]
  00362	51		 push	 ecx
  00363	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00368	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 804  : 			}
; 805  : 			else

  0036d	eb 34		 jmp	 SHORT $LN53@FairyElf
$LN29@FairyElf:

; 806  : 			{
; 807  : 				lpMagic = gObjGetMagicSearch(lpUser, 413);

  0036f	68 9d 01 00 00	 push	 413			; 0000019dH
  00374	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0037d	83 c4 08	 add	 esp, 8
  00380	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 808  : 				if(lpMagic != NULL) 

  00383	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00387	74 1a		 je	 SHORT $LN53@FairyElf

; 809  : 				{		
; 810  : 					gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00389	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0038c	50		 push	 eax
  0038d	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00390	8b 11		 mov	 edx, DWORD PTR [ecx]
  00392	52		 push	 edx
  00393	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00396	8b 08		 mov	 ecx, DWORD PTR [eax]
  00398	51		 push	 ecx
  00399	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0039e	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN53@FairyElf:

; 811  : 				}
; 812  : 			}
; 813  : 		}
; 814  : 	}
; 815  : 
; 816  : 	lpUser->m_OfflineBuffTime++;

  003a3	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  003a6	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  003ac	80 c1 01	 add	 cl, 1
  003af	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  003b2	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 817  : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  003b8	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  003bb	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  003c2	83 f9 14	 cmp	 ecx, 20			; 00000014H
  003c5	7c 0a		 jl	 SHORT $LN26@FairyElf

; 818  : 	{
; 819  : 		lpUser->m_OfflineBuffTime = 0;

  003c7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  003ca	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN26@FairyElf:

; 820  : 	}
; 821  : 
; 822  : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  003d1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  003d4	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  003db	51		 push	 ecx
  003dc	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  003df	52		 push	 edx
  003e0	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  003e5	83 c4 08	 add	 esp, 8
  003e8	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 823  : 
; 824  : 	if(!lpMagic)

  003eb	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  003ef	75 05		 jne	 SHORT $LN25@FairyElf

; 825  : 	{
; 826  : 		return;

  003f1	e9 b7 02 00 00	 jmp	 $LN55@FairyElf
$LN25@FairyElf:

; 827  : 	}
; 828  : 
; 829  : 	int tObjNum;
; 830  : 	int MaxDis = 0;

  003f6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 0

; 831  : 	int AttackCount = 0;

  003fd	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _AttackCount$[ebp], 0

; 832  : 	int MaxCount = 7;

  00404	c7 45 d0 07 00
	00 00		 mov	 DWORD PTR _MaxCount$[ebp], 7

; 833  : 	int TargetIndex = -1;

  0040b	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _TargetIndex$[ebp], -1

; 834  : 
; 835  : 	if(lpUser->m_OfflineSkill == 24 || lpUser->m_OfflineSkill == 414 || lpUser->m_OfflineSkill == 418)

  00412	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00415	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0041c	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0041f	74 24		 je	 SHORT $LN23@FairyElf
  00421	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00424	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0042b	81 f9 9e 01 00
	00		 cmp	 ecx, 414		; 0000019eH
  00431	74 12		 je	 SHORT $LN23@FairyElf
  00433	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00436	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0043d	81 f9 a2 01 00
	00		 cmp	 ecx, 418		; 000001a2H
  00443	75 09		 jne	 SHORT $LN24@FairyElf
$LN23@FairyElf:

; 836  : 	{
; 837  : 		MaxDis = 6;

  00445	c7 45 d8 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6
  0044c	eb 43		 jmp	 SHORT $LN22@FairyElf
$LN24@FairyElf:

; 838  : 	}
; 839  : 	else if(lpUser->m_OfflineSkill == 235)

  0044e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00451	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00458	81 f9 eb 00 00
	00		 cmp	 ecx, 235		; 000000ebH
  0045e	75 09		 jne	 SHORT $LN21@FairyElf

; 840  : 	{
; 841  : 		MaxDis = 6;

  00460	c7 45 d8 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6
  00467	eb 28		 jmp	 SHORT $LN22@FairyElf
$LN21@FairyElf:

; 842  : 	}
; 843  : 	else if(lpUser->m_OfflineSkill == 51 || lpUser->m_OfflineSkill == 424)

  00469	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0046c	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00473	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00476	74 12		 je	 SHORT $LN18@FairyElf
  00478	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0047b	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00482	81 f9 a8 01 00
	00		 cmp	 ecx, 424		; 000001a8H
  00488	75 07		 jne	 SHORT $LN22@FairyElf
$LN18@FairyElf:

; 844  : 	{
; 845  : 		MaxDis = 8;

  0048a	c7 45 d8 08 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 8
$LN22@FairyElf:

; 846  : 	}
; 847  : 
; 848  : 	// Multi Shot
; 849  : 	if( lpUser->m_OfflineSkill == 235)

  00491	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00494	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0049b	81 f9 eb 00 00
	00		 cmp	 ecx, 235		; 000000ebH
  004a1	0f 85 44 01 00
	00		 jne	 $LN17@FairyElf

; 850  : 	{
; 851  : 		for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  004a7	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _n$233461[ebp], 0
  004ae	eb 09		 jmp	 SHORT $LN16@FairyElf
$LN15@FairyElf:
  004b0	8b 45 c8	 mov	 eax, DWORD PTR _n$233461[ebp]
  004b3	83 c0 01	 add	 eax, 1
  004b6	89 45 c8	 mov	 DWORD PTR _n$233461[ebp], eax
$LN16@FairyElf:
  004b9	83 7d c8 4b	 cmp	 DWORD PTR _n$233461[ebp], 75 ; 0000004bH
  004bd	0f 8d f5 00 00
	00		 jge	 $LN14@FairyElf

; 852  : 		{
; 853  : 			tObjNum = lpUser->VpPlayer2[n].number;

  004c3	8b 45 c8	 mov	 eax, DWORD PTR _n$233461[ebp]
  004c6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  004c9	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  004cc	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  004d4	89 55 dc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 854  : 
; 855  : 			if(lpUser->VpPlayer2[n].state == 0)

  004d7	8b 45 c8	 mov	 eax, DWORD PTR _n$233461[ebp]
  004da	6b c0 0c	 imul	 eax, 12			; 0000000cH
  004dd	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  004e0	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  004e8	85 d2		 test	 edx, edx
  004ea	75 02		 jne	 SHORT $LN13@FairyElf

; 856  : 			{
; 857  : 				continue;

  004ec	eb c2		 jmp	 SHORT $LN15@FairyElf
$LN13@FairyElf:

; 858  : 			}
; 859  : 			if (OBJMAX_RANGE(tObjNum) == FALSE)

  004ee	83 7d dc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  004f2	7d 09		 jge	 SHORT $LN59@FairyElf
  004f4	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv281[ebp], 0
  004fb	eb 0f		 jmp	 SHORT $LN60@FairyElf
$LN59@FairyElf:
  004fd	33 c0		 xor	 eax, eax
  004ff	81 7d dc 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$[ebp], 14999 ; 00003a97H
  00506	0f 9e c0	 setle	 al
  00509	89 45 80	 mov	 DWORD PTR tv281[ebp], eax
$LN60@FairyElf:
  0050c	83 7d 80 00	 cmp	 DWORD PTR tv281[ebp], 0
  00510	75 02		 jne	 SHORT $LN12@FairyElf

; 860  : 			{
; 861  : 				continue;

  00512	eb 9c		 jmp	 SHORT $LN15@FairyElf
$LN12@FairyElf:

; 862  : 			}
; 863  : 			if ( gObj[tObjNum].Type != OBJ_MONSTER )

  00514	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00517	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0051d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00523	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00528	83 fa 02	 cmp	 edx, 2
  0052b	74 02		 je	 SHORT $LN11@FairyElf

; 864  : 			{
; 865  : 				continue;

  0052d	eb 81		 jmp	 SHORT $LN15@FairyElf
$LN11@FairyElf:

; 866  : 			}
; 867  : 			if(g_ExUser.InSafeZone(tObjNum) == true)

  0052f	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00532	50		 push	 eax
  00533	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  00538	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  0053d	0f b6 c8	 movzx	 ecx, al
  00540	83 f9 01	 cmp	 ecx, 1
  00543	75 05		 jne	 SHORT $LN10@FairyElf

; 868  : 			{
; 869  : 				continue;

  00545	e9 66 ff ff ff	 jmp	 $LN15@FairyElf
$LN10@FairyElf:

; 870  : 			}
; 871  : 			if(AttackCount >= MaxCount)

  0054a	8b 45 d4	 mov	 eax, DWORD PTR _AttackCount$[ebp]
  0054d	3b 45 d0	 cmp	 eax, DWORD PTR _MaxCount$[ebp]
  00550	7c 05		 jl	 SHORT $LN9@FairyElf

; 872  : 			{
; 873  : 				continue;

  00552	e9 59 ff ff ff	 jmp	 $LN15@FairyElf
$LN9@FairyElf:

; 874  : 			}
; 875  : 
; 876  : 			if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  00557	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0055a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00560	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00566	50		 push	 eax
  00567	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0056a	51		 push	 ecx
  0056b	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00570	83 c4 08	 add	 esp, 8
  00573	39 45 d8	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  00576	7c 3b		 jl	 SHORT $LN8@FairyElf

; 877  : 			{
; 878  : 				TargetIndex = tObjNum;

  00578	8b 45 dc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0057b	89 45 cc	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 879  : 				gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  0057e	6a 00		 push	 0
  00580	6a 00		 push	 0
  00582	6a 00		 push	 0
  00584	6a 00		 push	 0
  00586	6a 01		 push	 1
  00588	6a 00		 push	 0
  0058a	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0058d	50		 push	 eax
  0058e	8b 4d dc	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  00591	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00597	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0059d	51		 push	 ecx
  0059e	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  005a1	52		 push	 edx
  005a2	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  005a7	83 c4 24	 add	 esp, 36			; 00000024H

; 880  : 				AttackCount++;

  005aa	8b 45 d4	 mov	 eax, DWORD PTR _AttackCount$[ebp]
  005ad	83 c0 01	 add	 eax, 1
  005b0	89 45 d4	 mov	 DWORD PTR _AttackCount$[ebp], eax
$LN8@FairyElf:

; 881  : 			}
; 882  : 		}

  005b3	e9 f8 fe ff ff	 jmp	 $LN15@FairyElf
$LN14@FairyElf:

; 883  : 		gObjUseSkill.UseSkill(UserIndex, lpMagic,lpUser->X, lpUser->Y,0,0,-1);

  005b8	6a ff		 push	 -1
  005ba	6a 00		 push	 0
  005bc	6a 00		 push	 0
  005be	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  005c1	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  005c8	51		 push	 ecx
  005c9	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  005cc	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  005d3	50		 push	 eax
  005d4	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  005d7	51		 push	 ecx
  005d8	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  005db	52		 push	 edx
  005dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  005e1	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 884  : 	}
; 885  : 	// Triple Shot
; 886  : 	else if(lpUser->m_OfflineSkill == 24	|| 

  005e6	e9 c2 00 00 00	 jmp	 $LN55@FairyElf
$LN17@FairyElf:

; 887  : 			lpUser->m_OfflineSkill == 51	||
; 888  : 			lpUser->m_OfflineSkill == 414	|| 
; 889  : 			lpUser->m_OfflineSkill == 418	||
; 890  : 			lpUser->m_OfflineSkill == 424)

  005eb	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  005ee	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  005f5	83 f9 18	 cmp	 ecx, 24			; 00000018H
  005f8	74 45		 je	 SHORT $LN5@FairyElf
  005fa	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  005fd	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00604	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00607	74 36		 je	 SHORT $LN5@FairyElf
  00609	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0060c	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00613	81 f9 9e 01 00
	00		 cmp	 ecx, 414		; 0000019eH
  00619	74 24		 je	 SHORT $LN5@FairyElf
  0061b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0061e	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00625	81 f9 a2 01 00
	00		 cmp	 ecx, 418		; 000001a2H
  0062b	74 12		 je	 SHORT $LN5@FairyElf
  0062d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00630	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00637	81 f9 a8 01 00
	00		 cmp	 ecx, 424		; 000001a8H
  0063d	75 6e		 jne	 SHORT $LN55@FairyElf
$LN5@FairyElf:

; 891  : 	{
; 892  : 		TargetIndex = this->SearchTarget(UserIndex, MaxDis);

  0063f	8b 45 d8	 mov	 eax, DWORD PTR _MaxDis$[ebp]
  00642	50		 push	 eax
  00643	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00646	51		 push	 ecx
  00647	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0064a	e8 00 00 00 00	 call	 ?SearchTarget@OfflineMode@@QAEHHH@Z ; OfflineMode::SearchTarget
  0064f	89 45 cc	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 893  : 
; 894  : 		if(TargetIndex == -1) 

  00652	83 7d cc ff	 cmp	 DWORD PTR _TargetIndex$[ebp], -1
  00656	75 02		 jne	 SHORT $LN4@FairyElf

; 895  : 		{
; 896  : 			return;

  00658	eb 53		 jmp	 SHORT $LN55@FairyElf
$LN4@FairyElf:

; 897  : 		}
; 898  : 		if(TargetIndex < 0 || TargetIndex > OBJMAX-1)

  0065a	83 7d cc 00	 cmp	 DWORD PTR _TargetIndex$[ebp], 0
  0065e	7c 09		 jl	 SHORT $LN2@FairyElf
  00660	81 7d cc 97 3a
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 14999 ; 00003a97H
  00667	7e 02		 jle	 SHORT $LN3@FairyElf
$LN2@FairyElf:

; 899  : 		{
; 900  : 			return;

  00669	eb 42		 jmp	 SHORT $LN55@FairyElf
$LN3@FairyElf:

; 901  : 		}
; 902  : 		if(gObj[TargetIndex].Connected < PLAYER_PLAYING)

  0066b	8b 45 cc	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0066e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00674	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0067a	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0067f	7d 02		 jge	 SHORT $LN1@FairyElf

; 903  : 		{
; 904  : 			return;

  00681	eb 2a		 jmp	 SHORT $LN55@FairyElf
$LN1@FairyElf:

; 905  : 		}
; 906  : 
; 907  : 		LPOBJ lpMonster = &gObj[TargetIndex];

  00683	8b 45 cc	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00686	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0068c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00692	89 45 c4	 mov	 DWORD PTR _lpMonster$233478[ebp], eax

; 908  : 
; 909  : 		gObjUseSkill.UseSkill(lpUser->m_Index,TargetIndex,lpMagic);

  00695	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00698	50		 push	 eax
  00699	8b 4d cc	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  0069c	51		 push	 ecx
  0069d	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  006a0	8b 02		 mov	 eax, DWORD PTR [edx]
  006a2	50		 push	 eax
  006a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  006a8	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN55@FairyElf:

; 910  : 	}
; 911  : }

  006ad	5f		 pop	 edi
  006ae	5e		 pop	 esi
  006af	5b		 pop	 ebx
  006b0	8b e5		 mov	 esp, ebp
  006b2	5d		 pop	 ebp
  006b3	c2 04 00	 ret	 4
?FairyElf@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::FairyElf
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?MagicGladiator@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv183 = -92						; size = 4
_n$233500 = -24						; size = 4
_MaxDis$ = -20						; size = 4
_tObjNum$ = -16						; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?MagicGladiator@OfflineMode@@QAEXH@Z PROC		; OfflineMode::MagicGladiator, COMDAT
; _this$ = ecx

; 915  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 916  : 	if(!gObjIsConnectedEx(UserIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00015	83 c4 04	 add	 esp, 4
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 05		 jne	 SHORT $LN21@MagicGladi

; 917  : 	{
; 918  : 		return;

  0001f	e9 96 02 00 00	 jmp	 $LN22@MagicGladi
$LN21@MagicGladi:

; 919  : 	}
; 920  : 
; 921  : 	LPOBJ lpUser = &gObj[UserIndex];

  00024	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00027	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 922  : 
; 923  : 	CMagicInf *lpMagic;
; 924  : 
; 925  : 	// Ignore Buff
; 926  : 	/*if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)
; 927  : 	{
; 928  : 		lpMagic = gObjGetMagicSearch(lpUser, 266);
; 929  : 		if(lpMagic != NULL) 
; 930  : 		{		
; 931  : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);
; 932  : 		}
; 933  : 	}*/
; 934  : 
; 935  : 	lpUser->m_OfflineBuffTime++;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00039	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  0003f	80 c1 01	 add	 cl, 1
  00042	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00045	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 936  : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0004e	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00055	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00058	7c 0a		 jl	 SHORT $LN20@MagicGladi

; 937  : 	{
; 938  : 		lpUser->m_OfflineBuffTime = 0;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0005d	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN20@MagicGladi:

; 939  : 	}
; 940  : 
; 941  : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00067	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0006e	51		 push	 ecx
  0006f	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00078	83 c4 08	 add	 esp, 8
  0007b	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 942  : 
; 943  : 	if(!lpMagic)

  0007e	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00082	75 05		 jne	 SHORT $LN19@MagicGladi

; 944  : 	{
; 945  : 		return;

  00084	e9 31 02 00 00	 jmp	 $LN22@MagicGladi
$LN19@MagicGladi:

; 946  : 	}
; 947  : 
; 948  : 	int tObjNum;
; 949  : 	int MaxDis = 0;

  00089	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 0

; 950  : 
; 951  : 	if(lpUser->m_OfflineSkill == 9 || lpUser->m_OfflineSkill == 237 || lpUser->m_OfflineSkill == 487)

  00090	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00093	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0009a	83 f9 09	 cmp	 ecx, 9
  0009d	74 24		 je	 SHORT $LN17@MagicGladi
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000a2	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000a9	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  000af	74 12		 je	 SHORT $LN17@MagicGladi
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000b4	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000bb	81 f9 e7 01 00
	00		 cmp	 ecx, 487		; 000001e7H
  000c1	75 09		 jne	 SHORT $LN18@MagicGladi
$LN17@MagicGladi:

; 952  : 	{
; 953  : 		MaxDis = 6;

  000c3	c7 45 ec 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6
  000ca	eb 76		 jmp	 SHORT $LN16@MagicGladi
$LN18@MagicGladi:

; 954  : 	}
; 955  : 	else if(lpUser->m_OfflineSkill == 41 || lpUser->m_OfflineSkill == 330 || lpUser->m_OfflineSkill == 332 || lpUser->m_OfflineSkill == 481)

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000cf	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000d6	83 f9 29	 cmp	 ecx, 41			; 00000029H
  000d9	74 36		 je	 SHORT $LN14@MagicGladi
  000db	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000de	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000e5	81 f9 4a 01 00
	00		 cmp	 ecx, 330		; 0000014aH
  000eb	74 24		 je	 SHORT $LN14@MagicGladi
  000ed	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000f0	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000f7	81 f9 4c 01 00
	00		 cmp	 ecx, 332		; 0000014cH
  000fd	74 12		 je	 SHORT $LN14@MagicGladi
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00102	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00109	81 f9 e1 01 00
	00		 cmp	 ecx, 481		; 000001e1H
  0010f	75 09		 jne	 SHORT $LN15@MagicGladi
$LN14@MagicGladi:

; 956  : 	{
; 957  : 		MaxDis = 2;

  00111	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 2
  00118	eb 28		 jmp	 SHORT $LN16@MagicGladi
$LN15@MagicGladi:

; 958  : 	}
; 959  : 	else if(lpUser->m_OfflineSkill == 56 || lpUser->m_OfflineSkill == 482)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0011d	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00124	83 f9 38	 cmp	 ecx, 56			; 00000038H
  00127	74 12		 je	 SHORT $LN11@MagicGladi
  00129	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0012c	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00133	81 f9 e2 01 00
	00		 cmp	 ecx, 482		; 000001e2H
  00139	75 07		 jne	 SHORT $LN16@MagicGladi
$LN11@MagicGladi:

; 960  : 	{
; 961  : 		MaxDis = 5;

  0013b	c7 45 ec 05 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 5
$LN16@MagicGladi:

; 962  : 	}
; 963  : 
; 964  : 	// Evil Spirit or Inferno
; 965  : 	if(lpUser->m_OfflineSkill == 9 || lpUser->m_OfflineSkill == 41 || lpUser->m_OfflineSkill == 56 || lpUser->m_OfflineSkill == 237 || lpUser->m_OfflineSkill == 487)

  00142	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00145	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0014c	83 f9 09	 cmp	 ecx, 9
  0014f	74 46		 je	 SHORT $LN9@MagicGladi
  00151	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00154	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0015b	83 f9 29	 cmp	 ecx, 41			; 00000029H
  0015e	74 37		 je	 SHORT $LN9@MagicGladi
  00160	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00163	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0016a	83 f9 38	 cmp	 ecx, 56			; 00000038H
  0016d	74 28		 je	 SHORT $LN9@MagicGladi
  0016f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00172	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00179	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  0017f	74 16		 je	 SHORT $LN9@MagicGladi
  00181	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00184	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0018b	81 f9 e7 01 00
	00		 cmp	 ecx, 487		; 000001e7H
  00191	0f 85 23 01 00
	00		 jne	 $LN22@MagicGladi
$LN9@MagicGladi:

; 966  : 	{
; 967  : 		gObjUseSkill.UseSkill(UserIndex, lpMagic, lpUser->X, lpUser->Y, 0, 0, -1);

  00197	6a ff		 push	 -1
  00199	6a 00		 push	 0
  0019b	6a 00		 push	 0
  0019d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  001a0	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  001a7	51		 push	 ecx
  001a8	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001ab	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  001b2	50		 push	 eax
  001b3	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  001b6	51		 push	 ecx
  001b7	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  001ba	52		 push	 edx
  001bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001c0	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 968  : 
; 969  : 		for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  001c5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$233500[ebp], 0
  001cc	eb 09		 jmp	 SHORT $LN8@MagicGladi
$LN7@MagicGladi:
  001ce	8b 45 e8	 mov	 eax, DWORD PTR _n$233500[ebp]
  001d1	83 c0 01	 add	 eax, 1
  001d4	89 45 e8	 mov	 DWORD PTR _n$233500[ebp], eax
$LN8@MagicGladi:
  001d7	83 7d e8 4b	 cmp	 DWORD PTR _n$233500[ebp], 75 ; 0000004bH
  001db	0f 8d d9 00 00
	00		 jge	 $LN22@MagicGladi

; 970  : 		{
; 971  : 			tObjNum = lpUser->VpPlayer2[n].number;

  001e1	8b 45 e8	 mov	 eax, DWORD PTR _n$233500[ebp]
  001e4	6b c0 0c	 imul	 eax, 12			; 0000000cH
  001e7	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001ea	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  001f2	89 55 f0	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 972  : 
; 973  : 			if(lpUser->VpPlayer2[n].state == 0)

  001f5	8b 45 e8	 mov	 eax, DWORD PTR _n$233500[ebp]
  001f8	6b c0 0c	 imul	 eax, 12			; 0000000cH
  001fb	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001fe	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  00206	85 d2		 test	 edx, edx
  00208	75 02		 jne	 SHORT $LN5@MagicGladi

; 974  : 			{
; 975  : 				continue;

  0020a	eb c2		 jmp	 SHORT $LN7@MagicGladi
$LN5@MagicGladi:

; 976  : 			}
; 977  : 			if (OBJMAX_RANGE(tObjNum) == FALSE)

  0020c	83 7d f0 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00210	7d 09		 jge	 SHORT $LN24@MagicGladi
  00212	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
  00219	eb 0f		 jmp	 SHORT $LN25@MagicGladi
$LN24@MagicGladi:
  0021b	33 c0		 xor	 eax, eax
  0021d	81 7d f0 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$[ebp], 14999 ; 00003a97H
  00224	0f 9e c0	 setle	 al
  00227	89 45 a4	 mov	 DWORD PTR tv183[ebp], eax
$LN25@MagicGladi:
  0022a	83 7d a4 00	 cmp	 DWORD PTR tv183[ebp], 0
  0022e	75 02		 jne	 SHORT $LN4@MagicGladi

; 978  : 			{
; 979  : 				continue;

  00230	eb 9c		 jmp	 SHORT $LN7@MagicGladi
$LN4@MagicGladi:

; 980  : 			}
; 981  : 			if ( gObj[tObjNum].Type != OBJ_MONSTER )

  00232	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00235	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00241	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00246	83 fa 02	 cmp	 edx, 2
  00249	74 02		 je	 SHORT $LN3@MagicGladi

; 982  : 			{
; 983  : 				continue;

  0024b	eb 81		 jmp	 SHORT $LN7@MagicGladi
$LN3@MagicGladi:

; 984  : 			}
; 985  : 			if(g_ExUser.InSafeZone(tObjNum) == true)

  0024d	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00250	50		 push	 eax
  00251	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  00256	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  0025b	0f b6 c8	 movzx	 ecx, al
  0025e	83 f9 01	 cmp	 ecx, 1
  00261	75 05		 jne	 SHORT $LN2@MagicGladi

; 986  : 			{
; 987  : 				continue;

  00263	e9 66 ff ff ff	 jmp	 $LN7@MagicGladi
$LN2@MagicGladi:

; 988  : 			}
; 989  : 			if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  00268	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0026b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00271	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00277	50		 push	 eax
  00278	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0027b	51		 push	 ecx
  0027c	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00281	83 c4 08	 add	 esp, 8
  00284	39 45 ec	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  00287	7c 2c		 jl	 SHORT $LN1@MagicGladi

; 990  : 			{
; 991  : 				gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  00289	6a 00		 push	 0
  0028b	6a 00		 push	 0
  0028d	6a 00		 push	 0
  0028f	6a 00		 push	 0
  00291	6a 01		 push	 1
  00293	6a 00		 push	 0
  00295	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00298	50		 push	 eax
  00299	8b 4d f0	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  0029c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  002a2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a8	51		 push	 ecx
  002a9	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  002ac	52		 push	 edx
  002ad	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  002b2	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@MagicGladi:

; 992  : 			}
; 993  : 		}

  002b5	e9 14 ff ff ff	 jmp	 $LN7@MagicGladi
$LN22@MagicGladi:

; 994  : 	}
; 995  : }

  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi
  002bc	5b		 pop	 ebx
  002bd	8b e5		 mov	 esp, ebp
  002bf	5d		 pop	 ebp
  002c0	c2 04 00	 ret	 4
?MagicGladiator@OfflineMode@@QAEXH@Z ENDP		; OfflineMode::MagicGladiator
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?DarkLord@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv205 = -96						; size = 4
_tObjNum$233541 = -28					; size = 4
_n$233537 = -24						; size = 4
_TargetIndex$233529 = -20				; size = 4
_MaxDis$ = -16						; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?DarkLord@OfflineMode@@QAEXH@Z PROC			; OfflineMode::DarkLord, COMDAT
; _this$ = ecx

; 999  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1000 : 	if(!gObjIsConnectedEx(UserIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00015	83 c4 04	 add	 esp, 4
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 05		 jne	 SHORT $LN28@DarkLord

; 1001 : 	{
; 1002 : 		return;

  0001f	e9 25 03 00 00	 jmp	 $LN29@DarkLord
$LN28@DarkLord:

; 1003 : 	}
; 1004 : 
; 1005 : 	LPOBJ lpUser = &gObj[UserIndex];

  00024	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00027	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1006 : 
; 1007 : 	CMagicInf * lpMagic;
; 1008 : 	int MaxDis = 0;

  00036	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 0

; 1009 : 
; 1010 : 	if(lpUser->m_OfflineSkill == 61 || lpUser->m_OfflineSkill == 78)

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00040	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00047	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  0004a	74 0f		 je	 SHORT $LN26@DarkLord
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0004f	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00056	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  00059	75 09		 jne	 SHORT $LN27@DarkLord
$LN26@DarkLord:

; 1011 : 	{
; 1012 : 		MaxDis = 6;

  0005b	c7 45 f0 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6
  00062	eb 19		 jmp	 SHORT $LN25@DarkLord
$LN27@DarkLord:

; 1013 : 	}
; 1014 : 	else if(lpUser->m_OfflineSkill == 238)

  00064	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00067	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0006e	81 f9 ee 00 00
	00		 cmp	 ecx, 238		; 000000eeH
  00074	75 07		 jne	 SHORT $LN25@DarkLord

; 1015 : 	{
; 1016 : 		MaxDis = 4;

  00076	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 4
$LN25@DarkLord:

; 1017 : 	}
; 1018 : 
; 1019 : 	// Critical Buff
; 1020 : 	if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00080	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  00087	83 f9 01	 cmp	 ecx, 1
  0008a	75 75		 jne	 SHORT $LN23@DarkLord
  0008c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0008f	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00096	85 c9		 test	 ecx, ecx
  00098	75 67		 jne	 SHORT $LN23@DarkLord

; 1021 : 	{
; 1022 : 		lpMagic = gObjGetMagicSearch(lpUser, 64);

  0009a	6a 40		 push	 64			; 00000040H
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000a5	83 c4 08	 add	 esp, 8
  000a8	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1023 : 		if(lpMagic != NULL) 

  000ab	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  000af	74 1c		 je	 SHORT $LN22@DarkLord

; 1024 : 		{		
; 1025 : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000b8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ba	52		 push	 edx
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	51		 push	 ecx
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000c6	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 1026 : 		}
; 1027 : 		else

  000cb	eb 34		 jmp	 SHORT $LN23@DarkLord
$LN22@DarkLord:

; 1028 : 		{
; 1029 : 			lpMagic = gObjGetMagicSearch(lpUser, 511);

  000cd	68 ff 01 00 00	 push	 511			; 000001ffH
  000d2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000db	83 c4 08	 add	 esp, 8
  000de	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1030 : 			if(lpMagic != NULL) 

  000e1	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  000e5	74 1a		 je	 SHORT $LN23@DarkLord

; 1031 : 			{		
; 1032 : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  000e7	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f0	52		 push	 edx
  000f1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f6	51		 push	 ecx
  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000fc	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN23@DarkLord:

; 1033 : 			}
; 1034 : 		}
; 1035 : 	}
; 1036 : 
; 1037 : 	lpUser->m_OfflineBuffTime++;

  00101	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00104	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  0010a	80 c1 01	 add	 cl, 1
  0010d	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00110	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 1038 : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  00116	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00119	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00120	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00123	7c 0a		 jl	 SHORT $LN19@DarkLord

; 1039 : 	{
; 1040 : 		lpUser->m_OfflineBuffTime = 0;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00128	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN19@DarkLord:

; 1041 : 	}
; 1042 : 
; 1043 : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00132	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00139	51		 push	 ecx
  0013a	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00143	83 c4 08	 add	 esp, 8
  00146	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1044 : 
; 1045 : 	if(!lpMagic)

  00149	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0014d	75 05		 jne	 SHORT $LN18@DarkLord

; 1046 : 	{
; 1047 : 		return;

  0014f	e9 f5 01 00 00	 jmp	 $LN29@DarkLord
$LN18@DarkLord:

; 1048 : 	}
; 1049 : 
; 1050 : 	if( lpUser->m_OfflineSkill == 61 || 
; 1051 : 		lpUser->m_OfflineSkill == 508 || 
; 1052 : 		lpUser->m_OfflineSkill == 514 || 
; 1053 : 		lpUser->m_OfflineSkill == 238)

  00154	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00157	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0015e	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00161	74 36		 je	 SHORT $LN16@DarkLord
  00163	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00166	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0016d	81 f9 fc 01 00
	00		 cmp	 ecx, 508		; 000001fcH
  00173	74 24		 je	 SHORT $LN16@DarkLord
  00175	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00178	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0017f	81 f9 02 02 00
	00		 cmp	 ecx, 514		; 00000202H
  00185	74 12		 je	 SHORT $LN16@DarkLord
  00187	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0018a	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00191	81 f9 ee 00 00
	00		 cmp	 ecx, 238		; 000000eeH
  00197	75 68		 jne	 SHORT $LN17@DarkLord
$LN16@DarkLord:

; 1054 : 	{
; 1055 : 		int TargetIndex = this->SearchTarget(UserIndex, 6);

  00199	6a 06		 push	 6
  0019b	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	e8 00 00 00 00	 call	 ?SearchTarget@OfflineMode@@QAEHHH@Z ; OfflineMode::SearchTarget
  001a7	89 45 ec	 mov	 DWORD PTR _TargetIndex$233529[ebp], eax

; 1056 : 
; 1057 : 		if(TargetIndex == -1) 

  001aa	83 7d ec ff	 cmp	 DWORD PTR _TargetIndex$233529[ebp], -1
  001ae	75 05		 jne	 SHORT $LN15@DarkLord

; 1058 : 		{
; 1059 : 			return;

  001b0	e9 94 01 00 00	 jmp	 $LN29@DarkLord
$LN15@DarkLord:

; 1060 : 		}
; 1061 : 		if ( TargetIndex < 0 || TargetIndex > OBJMAX-1)

  001b5	83 7d ec 00	 cmp	 DWORD PTR _TargetIndex$233529[ebp], 0
  001b9	7c 09		 jl	 SHORT $LN13@DarkLord
  001bb	81 7d ec 97 3a
	00 00		 cmp	 DWORD PTR _TargetIndex$233529[ebp], 14999 ; 00003a97H
  001c2	7e 05		 jle	 SHORT $LN14@DarkLord
$LN13@DarkLord:

; 1062 : 		{
; 1063 : 			return;

  001c4	e9 80 01 00 00	 jmp	 $LN29@DarkLord
$LN14@DarkLord:

; 1064 : 		}
; 1065 : 		if ( gObj[TargetIndex].Connected < PLAYER_PLAYING )

  001c9	8b 45 ec	 mov	 eax, DWORD PTR _TargetIndex$233529[ebp]
  001cc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d8	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  001dd	7d 05		 jge	 SHORT $LN12@DarkLord

; 1066 : 		{
; 1067 : 			return;

  001df	e9 65 01 00 00	 jmp	 $LN29@DarkLord
$LN12@DarkLord:

; 1068 : 		}
; 1069 : 
; 1070 : 		gObjUseSkill.UseSkill(lpUser->m_Index, TargetIndex, lpMagic);

  001e4	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001e7	50		 push	 eax
  001e8	8b 4d ec	 mov	 ecx, DWORD PTR _TargetIndex$233529[ebp]
  001eb	51		 push	 ecx
  001ec	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001ef	8b 02		 mov	 eax, DWORD PTR [edx]
  001f1	50		 push	 eax
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001f7	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
  001fc	e9 48 01 00 00	 jmp	 $LN29@DarkLord
$LN17@DarkLord:

; 1071 : 	}
; 1072 : 	else if(lpUser->m_OfflineSkill == 78 || lpUser->m_OfflineSkill == 518)

  00201	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00204	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0020b	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  0020e	74 16		 je	 SHORT $LN9@DarkLord
  00210	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00213	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0021a	81 f9 06 02 00
	00		 cmp	 ecx, 518		; 00000206H
  00220	0f 85 23 01 00
	00		 jne	 $LN29@DarkLord
$LN9@DarkLord:

; 1073 : 	{
; 1074 : 		gObjUseSkill.UseSkill(UserIndex, lpMagic, lpUser->X, lpUser->Y, 0, 0, -1);

  00226	6a ff		 push	 -1
  00228	6a 00		 push	 0
  0022a	6a 00		 push	 0
  0022c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0022f	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  00236	51		 push	 ecx
  00237	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0023a	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  00241	50		 push	 eax
  00242	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00245	51		 push	 ecx
  00246	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  00249	52		 push	 edx
  0024a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0024f	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 1075 : 
; 1076 : 		for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  00254	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$233537[ebp], 0
  0025b	eb 09		 jmp	 SHORT $LN8@DarkLord
$LN7@DarkLord:
  0025d	8b 45 e8	 mov	 eax, DWORD PTR _n$233537[ebp]
  00260	83 c0 01	 add	 eax, 1
  00263	89 45 e8	 mov	 DWORD PTR _n$233537[ebp], eax
$LN8@DarkLord:
  00266	83 7d e8 4b	 cmp	 DWORD PTR _n$233537[ebp], 75 ; 0000004bH
  0026a	0f 8d d9 00 00
	00		 jge	 $LN29@DarkLord

; 1077 : 		{
; 1078 : 			int tObjNum = lpUser->VpPlayer2[n].number;

  00270	8b 45 e8	 mov	 eax, DWORD PTR _n$233537[ebp]
  00273	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00276	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00279	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  00281	89 55 e4	 mov	 DWORD PTR _tObjNum$233541[ebp], edx

; 1079 : 
; 1080 : 			if(lpUser->VpPlayer2[n].state == 0)

  00284	8b 45 e8	 mov	 eax, DWORD PTR _n$233537[ebp]
  00287	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0028a	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0028d	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  00295	85 d2		 test	 edx, edx
  00297	75 02		 jne	 SHORT $LN5@DarkLord

; 1081 : 			{
; 1082 : 				continue;

  00299	eb c2		 jmp	 SHORT $LN7@DarkLord
$LN5@DarkLord:

; 1083 : 			}
; 1084 : 			if (OBJMAX_RANGE(tObjNum) == FALSE)

  0029b	83 7d e4 00	 cmp	 DWORD PTR _tObjNum$233541[ebp], 0
  0029f	7d 09		 jge	 SHORT $LN31@DarkLord
  002a1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv205[ebp], 0
  002a8	eb 0f		 jmp	 SHORT $LN32@DarkLord
$LN31@DarkLord:
  002aa	33 c0		 xor	 eax, eax
  002ac	81 7d e4 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$233541[ebp], 14999 ; 00003a97H
  002b3	0f 9e c0	 setle	 al
  002b6	89 45 a0	 mov	 DWORD PTR tv205[ebp], eax
$LN32@DarkLord:
  002b9	83 7d a0 00	 cmp	 DWORD PTR tv205[ebp], 0
  002bd	75 02		 jne	 SHORT $LN4@DarkLord

; 1085 : 			{
; 1086 : 				continue;

  002bf	eb 9c		 jmp	 SHORT $LN7@DarkLord
$LN4@DarkLord:

; 1087 : 			}
; 1088 : 			if ( gObj[tObjNum].Type != OBJ_MONSTER )

  002c1	8b 45 e4	 mov	 eax, DWORD PTR _tObjNum$233541[ebp]
  002c4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d0	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  002d5	83 fa 02	 cmp	 edx, 2
  002d8	74 02		 je	 SHORT $LN3@DarkLord

; 1089 : 			{
; 1090 : 				continue;

  002da	eb 81		 jmp	 SHORT $LN7@DarkLord
$LN3@DarkLord:

; 1091 : 			}
; 1092 : 			if(g_ExUser.InSafeZone(tObjNum) == true)

  002dc	8b 45 e4	 mov	 eax, DWORD PTR _tObjNum$233541[ebp]
  002df	50		 push	 eax
  002e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  002e5	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  002ea	0f b6 c8	 movzx	 ecx, al
  002ed	83 f9 01	 cmp	 ecx, 1
  002f0	75 05		 jne	 SHORT $LN2@DarkLord

; 1093 : 			{
; 1094 : 				continue;

  002f2	e9 66 ff ff ff	 jmp	 $LN7@DarkLord
$LN2@DarkLord:

; 1095 : 			}
; 1096 : 			if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  002f7	8b 45 e4	 mov	 eax, DWORD PTR _tObjNum$233541[ebp]
  002fa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00300	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00306	50		 push	 eax
  00307	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0030a	51		 push	 ecx
  0030b	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00310	83 c4 08	 add	 esp, 8
  00313	39 45 f0	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  00316	7c 2c		 jl	 SHORT $LN1@DarkLord

; 1097 : 			{
; 1098 : 				gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  00318	6a 00		 push	 0
  0031a	6a 00		 push	 0
  0031c	6a 00		 push	 0
  0031e	6a 00		 push	 0
  00320	6a 01		 push	 1
  00322	6a 00		 push	 0
  00324	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00327	50		 push	 eax
  00328	8b 4d e4	 mov	 ecx, DWORD PTR _tObjNum$233541[ebp]
  0032b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00331	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00337	51		 push	 ecx
  00338	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0033b	52		 push	 edx
  0033c	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00341	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@DarkLord:

; 1099 : 			}
; 1100 : 		}

  00344	e9 14 ff ff ff	 jmp	 $LN7@DarkLord
$LN29@DarkLord:

; 1101 : 	}
; 1102 : 
; 1103 : }

  00349	5f		 pop	 edi
  0034a	5e		 pop	 esi
  0034b	5b		 pop	 ebx
  0034c	8b e5		 mov	 esp, ebp
  0034e	5d		 pop	 ebp
  0034f	c2 04 00	 ret	 4
?DarkLord@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::DarkLord
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?Summoner@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv169 = -108						; size = 4
_lpMonster$233590 = -40					; size = 4
_TargetIndex$233585 = -36				; size = 4
_lpMonster$233581 = -32					; size = 4
_TargetIndex$233576 = -28				; size = 4
_tObjNum$233567 = -24					; size = 4
_n$233563 = -20						; size = 4
_MaxDis$ = -16						; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?Summoner@OfflineMode@@QAEXH@Z PROC			; OfflineMode::Summoner, COMDAT
; _this$ = ecx

; 1107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1108 : 	if(!gObjIsConnectedEx(UserIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00015	83 c4 04	 add	 esp, 4
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 05		 jne	 SHORT $LN31@Summoner

; 1109 : 	{
; 1110 : 		return;

  0001f	e9 b3 03 00 00	 jmp	 $LN32@Summoner
$LN31@Summoner:

; 1111 : 	}
; 1112 : 
; 1113 : 	LPOBJ lpUser = &gObj[UserIndex];

  00024	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00027	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1114 : 
; 1115 : 	CMagicInf * lpMagic;
; 1116 : 
; 1117 : 	int MaxDis = 6;

  00036	c7 45 f0 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6

; 1118 : 
; 1119 : 	// Bersaker Buff
; 1120 : 	if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00040	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  00047	83 f9 01	 cmp	 ecx, 1
  0004a	75 78		 jne	 SHORT $LN30@Summoner
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0004f	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00056	85 c9		 test	 ecx, ecx
  00058	75 6a		 jne	 SHORT $LN30@Summoner

; 1121 : 	{
; 1122 : 		lpMagic = gObjGetMagicSearch(lpUser, 218);

  0005a	68 da 00 00 00	 push	 218			; 000000daH
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00068	83 c4 08	 add	 esp, 8
  0006b	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1123 : 		if(lpMagic != NULL) 

  0006e	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00072	74 1c		 je	 SHORT $LN29@Summoner

; 1124 : 		{		
; 1125 : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  00074	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0007b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007d	52		 push	 edx
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00089	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill

; 1126 : 		}
; 1127 : 		else

  0008e	eb 34		 jmp	 SHORT $LN30@Summoner
$LN29@Summoner:

; 1128 : 		{
; 1129 : 			lpMagic = gObjGetMagicSearch(lpUser, 469);

  00090	68 d5 01 00 00	 push	 469			; 000001d5H
  00095	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0009e	83 c4 08	 add	 esp, 8
  000a1	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1130 : 			if(lpMagic != NULL) 

  000a4	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  000a8	74 1a		 je	 SHORT $LN30@Summoner

; 1131 : 			{		
; 1132 : 				gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b3	52		 push	 edx
  000b4	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	51		 push	 ecx
  000ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000bf	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN30@Summoner:

; 1133 : 			}
; 1134 : 		}
; 1135 : 	}
; 1136 : 
; 1137 : 	lpUser->m_OfflineBuffTime++;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000c7	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  000cd	80 c1 01	 add	 cl, 1
  000d0	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000d3	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 1138 : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000dc	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  000e3	83 f9 14	 cmp	 ecx, 20			; 00000014H
  000e6	7c 0a		 jl	 SHORT $LN26@Summoner

; 1139 : 	{
; 1140 : 		lpUser->m_OfflineBuffTime = 0;

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000eb	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN26@Summoner:

; 1141 : 	}
; 1142 : 
; 1143 : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000f5	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  000fc	51		 push	 ecx
  000fd	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00106	83 c4 08	 add	 esp, 8
  00109	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1144 : 
; 1145 : 	if(!lpMagic)

  0010c	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00110	75 05		 jne	 SHORT $LN25@Summoner

; 1146 : 	{
; 1147 : 		return;

  00112	e9 c0 02 00 00	 jmp	 $LN32@Summoner
$LN25@Summoner:

; 1148 : 	}
; 1149 : 
; 1150 : 	if(lpUser->m_OfflineSkill == 230 || lpUser->m_OfflineSkill == 456)

  00117	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0011a	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00121	81 f9 e6 00 00
	00		 cmp	 ecx, 230		; 000000e6H
  00127	74 16		 je	 SHORT $LN23@Summoner
  00129	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0012c	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00133	81 f9 c8 01 00
	00		 cmp	 ecx, 456		; 000001c8H
  00139	0f 85 2a 01 00
	00		 jne	 $LN24@Summoner
$LN23@Summoner:

; 1151 : 	{
; 1152 : 		gObjUseSkill.UseSkill(lpUser->m_Index, lpMagic, lpUser->X, lpUser->Y,0,0,-1);

  0013f	6a ff		 push	 -1
  00141	6a 00		 push	 0
  00143	6a 00		 push	 0
  00145	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00148	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  0014f	51		 push	 ecx
  00150	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00153	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  0015a	50		 push	 eax
  0015b	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  0015e	51		 push	 ecx
  0015f	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00162	8b 02		 mov	 eax, DWORD PTR [edx]
  00164	50		 push	 eax
  00165	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0016a	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 1153 : 
; 1154 : 		for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  0016f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _n$233563[ebp], 0
  00176	eb 09		 jmp	 SHORT $LN22@Summoner
$LN21@Summoner:
  00178	8b 45 ec	 mov	 eax, DWORD PTR _n$233563[ebp]
  0017b	83 c0 01	 add	 eax, 1
  0017e	89 45 ec	 mov	 DWORD PTR _n$233563[ebp], eax
$LN22@Summoner:
  00181	83 7d ec 4b	 cmp	 DWORD PTR _n$233563[ebp], 75 ; 0000004bH
  00185	0f 8d d9 00 00
	00		 jge	 $LN20@Summoner

; 1155 : 		{
; 1156 : 			int tObjNum = lpUser->VpPlayer2[n].number;

  0018b	8b 45 ec	 mov	 eax, DWORD PTR _n$233563[ebp]
  0018e	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00191	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00194	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  0019c	89 55 e8	 mov	 DWORD PTR _tObjNum$233567[ebp], edx

; 1157 : 
; 1158 : 			if(lpUser->VpPlayer2[n].state == 0)

  0019f	8b 45 ec	 mov	 eax, DWORD PTR _n$233563[ebp]
  001a2	6b c0 0c	 imul	 eax, 12			; 0000000cH
  001a5	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001a8	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  001b0	85 d2		 test	 edx, edx
  001b2	75 02		 jne	 SHORT $LN19@Summoner

; 1159 : 			{
; 1160 : 				continue;

  001b4	eb c2		 jmp	 SHORT $LN21@Summoner
$LN19@Summoner:

; 1161 : 			}
; 1162 : 			if (OBJMAX_RANGE(tObjNum) == FALSE)

  001b6	83 7d e8 00	 cmp	 DWORD PTR _tObjNum$233567[ebp], 0
  001ba	7d 09		 jge	 SHORT $LN34@Summoner
  001bc	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
  001c3	eb 0f		 jmp	 SHORT $LN35@Summoner
$LN34@Summoner:
  001c5	33 c0		 xor	 eax, eax
  001c7	81 7d e8 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$233567[ebp], 14999 ; 00003a97H
  001ce	0f 9e c0	 setle	 al
  001d1	89 45 94	 mov	 DWORD PTR tv169[ebp], eax
$LN35@Summoner:
  001d4	83 7d 94 00	 cmp	 DWORD PTR tv169[ebp], 0
  001d8	75 02		 jne	 SHORT $LN18@Summoner

; 1163 : 			{
; 1164 : 				continue;

  001da	eb 9c		 jmp	 SHORT $LN21@Summoner
$LN18@Summoner:

; 1165 : 			}
; 1166 : 			if ( gObj[tObjNum].Type != OBJ_MONSTER )

  001dc	8b 45 e8	 mov	 eax, DWORD PTR _tObjNum$233567[ebp]
  001df	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001eb	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  001f0	83 fa 02	 cmp	 edx, 2
  001f3	74 02		 je	 SHORT $LN17@Summoner

; 1167 : 			{
; 1168 : 				continue;

  001f5	eb 81		 jmp	 SHORT $LN21@Summoner
$LN17@Summoner:

; 1169 : 			}
; 1170 : 			if(g_ExUser.InSafeZone(tObjNum) == true)

  001f7	8b 45 e8	 mov	 eax, DWORD PTR _tObjNum$233567[ebp]
  001fa	50		 push	 eax
  001fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  00200	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  00205	0f b6 c8	 movzx	 ecx, al
  00208	83 f9 01	 cmp	 ecx, 1
  0020b	75 05		 jne	 SHORT $LN16@Summoner

; 1171 : 			{
; 1172 : 				continue;

  0020d	e9 66 ff ff ff	 jmp	 $LN21@Summoner
$LN16@Summoner:

; 1173 : 			}
; 1174 : 			if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  00212	8b 45 e8	 mov	 eax, DWORD PTR _tObjNum$233567[ebp]
  00215	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0021b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00221	50		 push	 eax
  00222	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0022b	83 c4 08	 add	 esp, 8
  0022e	39 45 f0	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  00231	7c 2c		 jl	 SHORT $LN15@Summoner

; 1175 : 			{
; 1176 : 				gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  00233	6a 00		 push	 0
  00235	6a 00		 push	 0
  00237	6a 00		 push	 0
  00239	6a 00		 push	 0
  0023b	6a 01		 push	 1
  0023d	6a 00		 push	 0
  0023f	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00242	50		 push	 eax
  00243	8b 4d e8	 mov	 ecx, DWORD PTR _tObjNum$233567[ebp]
  00246	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0024c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00252	51		 push	 ecx
  00253	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00256	52		 push	 edx
  00257	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0025c	83 c4 24	 add	 esp, 36			; 00000024H
$LN15@Summoner:

; 1177 : 			}
; 1178 : 		}

  0025f	e9 14 ff ff ff	 jmp	 $LN21@Summoner
$LN20@Summoner:

; 1179 : 	}
; 1180 : 	else if(lpUser->m_OfflineSkill == 215 || lpUser->m_OfflineSkill == 455)

  00264	e9 6e 01 00 00	 jmp	 $LN32@Summoner
$LN24@Summoner:
  00269	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0026c	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00273	81 f9 d7 00 00
	00		 cmp	 ecx, 215		; 000000d7H
  00279	74 16		 je	 SHORT $LN12@Summoner
  0027b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0027e	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00285	81 f9 c7 01 00
	00		 cmp	 ecx, 455		; 000001c7H
  0028b	0f 85 92 00 00
	00		 jne	 $LN13@Summoner
$LN12@Summoner:

; 1181 : 	{
; 1182 : 		int TargetIndex = this->SearchTarget(UserIndex, 6);

  00291	6a 06		 push	 6
  00293	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00296	50		 push	 eax
  00297	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029a	e8 00 00 00 00	 call	 ?SearchTarget@OfflineMode@@QAEHHH@Z ; OfflineMode::SearchTarget
  0029f	89 45 e4	 mov	 DWORD PTR _TargetIndex$233576[ebp], eax

; 1183 : 
; 1184 : 		if(TargetIndex == -1) 

  002a2	83 7d e4 ff	 cmp	 DWORD PTR _TargetIndex$233576[ebp], -1
  002a6	75 05		 jne	 SHORT $LN11@Summoner

; 1185 : 		{
; 1186 : 			return;

  002a8	e9 2a 01 00 00	 jmp	 $LN32@Summoner
$LN11@Summoner:

; 1187 : 		}
; 1188 : 		if ( TargetIndex < 0 || TargetIndex > OBJMAX-1)

  002ad	83 7d e4 00	 cmp	 DWORD PTR _TargetIndex$233576[ebp], 0
  002b1	7c 09		 jl	 SHORT $LN9@Summoner
  002b3	81 7d e4 97 3a
	00 00		 cmp	 DWORD PTR _TargetIndex$233576[ebp], 14999 ; 00003a97H
  002ba	7e 05		 jle	 SHORT $LN10@Summoner
$LN9@Summoner:

; 1189 : 		{
; 1190 : 			return;

  002bc	e9 16 01 00 00	 jmp	 $LN32@Summoner
$LN10@Summoner:

; 1191 : 		}
; 1192 : 		if ( gObj[TargetIndex].Connected < PLAYER_PLAYING )

  002c1	8b 45 e4	 mov	 eax, DWORD PTR _TargetIndex$233576[ebp]
  002c4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d0	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  002d5	7d 05		 jge	 SHORT $LN8@Summoner

; 1193 : 		{
; 1194 : 			return;

  002d7	e9 fb 00 00 00	 jmp	 $LN32@Summoner
$LN8@Summoner:

; 1195 : 		}
; 1196 : 
; 1197 : 		LPOBJ lpMonster = &gObj[TargetIndex];

  002dc	8b 45 e4	 mov	 eax, DWORD PTR _TargetIndex$233576[ebp]
  002df	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002e5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002eb	89 45 e0	 mov	 DWORD PTR _lpMonster$233581[ebp], eax

; 1198 : 
; 1199 : 		gObjUseSkill.UseSkill(UserIndex, lpMagic, lpMonster->X, lpMonster->Y, 0, 0, TargetIndex);

  002ee	8b 45 e4	 mov	 eax, DWORD PTR _TargetIndex$233576[ebp]
  002f1	50		 push	 eax
  002f2	6a 00		 push	 0
  002f4	6a 00		 push	 0
  002f6	8b 4d e0	 mov	 ecx, DWORD PTR _lpMonster$233581[ebp]
  002f9	0f b6 91 46 01
	00 00		 movzx	 edx, BYTE PTR [ecx+326]
  00300	52		 push	 edx
  00301	8b 45 e0	 mov	 eax, DWORD PTR _lpMonster$233581[ebp]
  00304	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  0030b	51		 push	 ecx
  0030c	8b 55 f4	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  0030f	52		 push	 edx
  00310	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00313	50		 push	 eax
  00314	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00319	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill
  0031e	e9 b4 00 00 00	 jmp	 $LN32@Summoner
$LN13@Summoner:

; 1200 : 	}
; 1201 : 	else if(lpUser->m_OfflineSkill == 225)	//225 äîëæíà áûòü çàäåðæêà

  00323	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00326	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0032d	81 f9 e1 00 00
	00		 cmp	 ecx, 225		; 000000e1H
  00333	0f 85 9e 00 00
	00		 jne	 $LN32@Summoner

; 1202 : 	{
; 1203 : 		if(this->OffTimer(UserIndex, 6) == true)

  00339	6a 06		 push	 6
  0033b	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0033e	50		 push	 eax
  0033f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00342	e8 00 00 00 00	 call	 ?OffTimer@OfflineMode@@QAE_NHH@Z ; OfflineMode::OffTimer
  00347	0f b6 c8	 movzx	 ecx, al
  0034a	83 f9 01	 cmp	 ecx, 1
  0034d	0f 85 84 00 00
	00		 jne	 $LN32@Summoner

; 1204 : 		{
; 1205 : 			int TargetIndex = this->SearchTarget(UserIndex, 6);

  00353	6a 06		 push	 6
  00355	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00358	50		 push	 eax
  00359	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	e8 00 00 00 00	 call	 ?SearchTarget@OfflineMode@@QAEHHH@Z ; OfflineMode::SearchTarget
  00361	89 45 dc	 mov	 DWORD PTR _TargetIndex$233585[ebp], eax

; 1206 : 
; 1207 : 			if(TargetIndex == -1) 

  00364	83 7d dc ff	 cmp	 DWORD PTR _TargetIndex$233585[ebp], -1
  00368	75 02		 jne	 SHORT $LN4@Summoner

; 1208 : 			{
; 1209 : 				return;

  0036a	eb 6b		 jmp	 SHORT $LN32@Summoner
$LN4@Summoner:

; 1210 : 			}
; 1211 : 			if ( TargetIndex < 0 || TargetIndex > OBJMAX-1)

  0036c	83 7d dc 00	 cmp	 DWORD PTR _TargetIndex$233585[ebp], 0
  00370	7c 09		 jl	 SHORT $LN2@Summoner
  00372	81 7d dc 97 3a
	00 00		 cmp	 DWORD PTR _TargetIndex$233585[ebp], 14999 ; 00003a97H
  00379	7e 02		 jle	 SHORT $LN3@Summoner
$LN2@Summoner:

; 1212 : 			{
; 1213 : 				return;

  0037b	eb 5a		 jmp	 SHORT $LN32@Summoner
$LN3@Summoner:

; 1214 : 			}
; 1215 : 			if ( gObj[TargetIndex].Connected < PLAYER_PLAYING )

  0037d	8b 45 dc	 mov	 eax, DWORD PTR _TargetIndex$233585[ebp]
  00380	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0038c	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00391	7d 02		 jge	 SHORT $LN1@Summoner

; 1216 : 			{
; 1217 : 				return;

  00393	eb 42		 jmp	 SHORT $LN32@Summoner
$LN1@Summoner:

; 1218 : 			}
; 1219 : 
; 1220 : 			LPOBJ lpMonster = &gObj[TargetIndex];

  00395	8b 45 dc	 mov	 eax, DWORD PTR _TargetIndex$233585[ebp]
  00398	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0039e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a4	89 45 d8	 mov	 DWORD PTR _lpMonster$233590[ebp], eax

; 1221 : 
; 1222 : 			gObjUseSkill.UseSkill(UserIndex, lpMagic, lpMonster->X, lpMonster->Y, 0, 0, TargetIndex);

  003a7	8b 45 dc	 mov	 eax, DWORD PTR _TargetIndex$233585[ebp]
  003aa	50		 push	 eax
  003ab	6a 00		 push	 0
  003ad	6a 00		 push	 0
  003af	8b 4d d8	 mov	 ecx, DWORD PTR _lpMonster$233590[ebp]
  003b2	0f b6 91 46 01
	00 00		 movzx	 edx, BYTE PTR [ecx+326]
  003b9	52		 push	 edx
  003ba	8b 45 d8	 mov	 eax, DWORD PTR _lpMonster$233590[ebp]
  003bd	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  003c4	51		 push	 ecx
  003c5	8b 55 f4	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  003c8	52		 push	 edx
  003c9	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  003cc	50		 push	 eax
  003cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  003d2	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill
$LN32@Summoner:

; 1223 : 		}
; 1224 : 	}
; 1225 : }

  003d7	5f		 pop	 edi
  003d8	5e		 pop	 esi
  003d9	5b		 pop	 ebx
  003da	8b e5		 mov	 esp, ebp
  003dc	5d		 pop	 ebp
  003dd	c2 04 00	 ret	 4
?Summoner@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::Summoner
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?Fighter@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv243 = -100						; size = 4
tv183 = -100						; size = 4
_tObjNum$233625 = -32					; size = 4
_n$233621 = -28						; size = 4
_tObjNum$233612 = -24					; size = 4
_n$233608 = -20						; size = 4
_MaxDis$ = -16						; size = 4
_lpMagic$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
?Fighter@OfflineMode@@QAEXH@Z PROC			; OfflineMode::Fighter, COMDAT
; _this$ = ecx

; 1229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1230 : 	if(!gObjIsConnectedEx(UserIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00015	83 c4 04	 add	 esp, 4
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 05		 jne	 SHORT $LN29@Fighter

; 1231 : 	{
; 1232 : 		return;

  0001f	e9 e6 03 00 00	 jmp	 $LN30@Fighter
$LN29@Fighter:

; 1233 : 	}
; 1234 : 
; 1235 : 	LPOBJ lpUser = &gObj[UserIndex];

  00024	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00027	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1236 : 
; 1237 : 	CMagicInf * lpMagic;
; 1238 : 
; 1239 : 	int MaxDis = 6;

  00036	c7 45 f0 06 00
	00 00		 mov	 DWORD PTR _MaxDis$[ebp], 6

; 1240 : 
; 1241 : 	if(lpUser->m_OfflineAutoBuff == true && lpUser->m_OfflineBuffTime == 0)

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00040	0f b6 88 d9 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10457]
  00047	83 f9 01	 cmp	 ecx, 1
  0004a	0f 85 ae 00 00
	00		 jne	 $LN28@Fighter
  00050	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00053	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  0005a	85 c9		 test	 ecx, ecx
  0005c	0f 85 9c 00 00
	00		 jne	 $LN28@Fighter

; 1242 : 	{
; 1243 : 		lpMagic = gObjGetMagicSearch(lpUser, 266);//fix

  00062	68 0a 01 00 00	 push	 266			; 0000010aH
  00067	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00070	83 c4 08	 add	 esp, 8
  00073	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1244 : 		if(lpMagic != NULL) 

  00076	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0007a	74 1a		 je	 SHORT $LN27@Fighter

; 1245 : 		{		
; 1246 : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  0007c	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	52		 push	 edx
  00086	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	51		 push	 ecx
  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00091	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN27@Fighter:

; 1247 : 		}
; 1248 : 
; 1249 : 		lpMagic = gObjGetMagicSearch(lpUser, 267);//fix

  00096	68 0b 01 00 00	 push	 267			; 0000010bH
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000a4	83 c4 08	 add	 esp, 8
  000a7	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1250 : 		if(lpMagic != NULL) 

  000aa	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  000ae	74 1a		 je	 SHORT $LN26@Fighter

; 1251 : 		{		
; 1252 : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b9	52		 push	 edx
  000ba	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000c5	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN26@Fighter:

; 1253 : 		}
; 1254 : 
; 1255 : 		lpMagic = gObjGetMagicSearch(lpUser, 268);//fix

  000ca	68 0c 01 00 00	 push	 268			; 0000010cH
  000cf	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000d8	83 c4 08	 add	 esp, 8
  000db	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1256 : 		if(lpMagic != NULL) 

  000de	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  000e2	74 1a		 je	 SHORT $LN28@Fighter

; 1257 : 		{		
; 1258 : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpUser->m_Index, lpMagic);

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ed	52		 push	 edx
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	51		 push	 ecx
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000f9	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN28@Fighter:

; 1259 : 		}
; 1260 : 	}
; 1261 : 
; 1262 : 	lpUser->m_OfflineBuffTime++;

  000fe	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00101	8a 88 d8 28 00
	00		 mov	 cl, BYTE PTR [eax+10456]
  00107	80 c1 01	 add	 cl, 1
  0010a	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0010d	88 8a d8 28 00
	00		 mov	 BYTE PTR [edx+10456], cl

; 1263 : 	if(lpUser->m_OfflineBuffTime >= OFFMAXTIME_FOR_BUFF)

  00113	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00116	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  0011d	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00120	7c 0a		 jl	 SHORT $LN24@Fighter

; 1264 : 	{
; 1265 : 		lpUser->m_OfflineBuffTime = 0;

  00122	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00125	c6 80 d8 28 00
	00 00		 mov	 BYTE PTR [eax+10456], 0
$LN24@Fighter:

; 1266 : 	}
; 1267 : 
; 1268 : 	lpMagic = gObjGetMagicSearch(lpUser, lpUser->m_OfflineSkill);

  0012c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0012f	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00136	51		 push	 ecx
  00137	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00140	83 c4 08	 add	 esp, 8
  00143	89 45 f4	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1269 : 
; 1270 : 	if(!lpMagic)

  00146	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0014a	75 05		 jne	 SHORT $LN23@Fighter

; 1271 : 	{
; 1272 : 		return;

  0014c	e9 b9 02 00 00	 jmp	 $LN30@Fighter
$LN23@Fighter:

; 1273 : 	}
; 1274 : 
; 1275 : 	if(lpUser->m_OfflineSkill == 264 || lpUser->m_OfflineSkill == 560)

  00151	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00154	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0015b	81 f9 08 01 00
	00		 cmp	 ecx, 264		; 00000108H
  00161	74 16		 je	 SHORT $LN21@Fighter
  00163	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00166	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0016d	81 f9 30 02 00
	00		 cmp	 ecx, 560		; 00000230H
  00173	0f 85 44 01 00
	00		 jne	 $LN22@Fighter
$LN21@Fighter:

; 1276 : 	{
; 1277 : 		if(this->OffTimer(UserIndex, 4) == true)

  00179	6a 04		 push	 4
  0017b	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0017e	50		 push	 eax
  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	e8 00 00 00 00	 call	 ?OffTimer@OfflineMode@@QAE_NHH@Z ; OfflineMode::OffTimer
  00187	0f b6 c8	 movzx	 ecx, al
  0018a	83 f9 01	 cmp	 ecx, 1
  0018d	0f 85 25 01 00
	00		 jne	 $LN20@Fighter

; 1278 : 		{
; 1279 : 			gObjUseSkill.UseSkill(lpUser->m_Index, lpMagic, lpUser->X, lpUser->Y,0,0,-1);

  00193	6a ff		 push	 -1
  00195	6a 00		 push	 0
  00197	6a 00		 push	 0
  00199	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0019c	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  001a3	51		 push	 ecx
  001a4	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001a7	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  001ae	50		 push	 eax
  001af	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  001b2	51		 push	 ecx
  001b3	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  001b6	8b 02		 mov	 eax, DWORD PTR [edx]
  001b8	50		 push	 eax
  001b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001be	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 1280 : 
; 1281 : 			for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  001c3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _n$233608[ebp], 0
  001ca	eb 09		 jmp	 SHORT $LN19@Fighter
$LN18@Fighter:
  001cc	8b 45 ec	 mov	 eax, DWORD PTR _n$233608[ebp]
  001cf	83 c0 01	 add	 eax, 1
  001d2	89 45 ec	 mov	 DWORD PTR _n$233608[ebp], eax
$LN19@Fighter:
  001d5	83 7d ec 4b	 cmp	 DWORD PTR _n$233608[ebp], 75 ; 0000004bH
  001d9	0f 8d d9 00 00
	00		 jge	 $LN20@Fighter

; 1282 : 			{
; 1283 : 				int tObjNum = lpUser->VpPlayer2[n].number;

  001df	8b 45 ec	 mov	 eax, DWORD PTR _n$233608[ebp]
  001e2	6b c0 0c	 imul	 eax, 12			; 0000000cH
  001e5	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001e8	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  001f0	89 55 e8	 mov	 DWORD PTR _tObjNum$233612[ebp], edx

; 1284 : 
; 1285 : 				if(lpUser->VpPlayer2[n].state == 0)

  001f3	8b 45 ec	 mov	 eax, DWORD PTR _n$233608[ebp]
  001f6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  001f9	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001fc	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  00204	85 d2		 test	 edx, edx
  00206	75 02		 jne	 SHORT $LN16@Fighter

; 1286 : 				{
; 1287 : 					continue;

  00208	eb c2		 jmp	 SHORT $LN18@Fighter
$LN16@Fighter:

; 1288 : 				}
; 1289 : 				if (OBJMAX_RANGE(tObjNum) == FALSE)

  0020a	83 7d e8 00	 cmp	 DWORD PTR _tObjNum$233612[ebp], 0
  0020e	7d 09		 jge	 SHORT $LN32@Fighter
  00210	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
  00217	eb 0f		 jmp	 SHORT $LN33@Fighter
$LN32@Fighter:
  00219	33 c0		 xor	 eax, eax
  0021b	81 7d e8 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$233612[ebp], 14999 ; 00003a97H
  00222	0f 9e c0	 setle	 al
  00225	89 45 9c	 mov	 DWORD PTR tv183[ebp], eax
$LN33@Fighter:
  00228	83 7d 9c 00	 cmp	 DWORD PTR tv183[ebp], 0
  0022c	75 02		 jne	 SHORT $LN15@Fighter

; 1290 : 				{
; 1291 : 					continue;

  0022e	eb 9c		 jmp	 SHORT $LN18@Fighter
$LN15@Fighter:

; 1292 : 				}
; 1293 : 				if ( gObj[tObjNum].Type != OBJ_MONSTER )

  00230	8b 45 e8	 mov	 eax, DWORD PTR _tObjNum$233612[ebp]
  00233	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00239	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023f	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00244	83 fa 02	 cmp	 edx, 2
  00247	74 02		 je	 SHORT $LN14@Fighter

; 1294 : 				{
; 1295 : 					continue;

  00249	eb 81		 jmp	 SHORT $LN18@Fighter
$LN14@Fighter:

; 1296 : 				}
; 1297 : 				if(g_ExUser.InSafeZone(tObjNum) == true)

  0024b	8b 45 e8	 mov	 eax, DWORD PTR _tObjNum$233612[ebp]
  0024e	50		 push	 eax
  0024f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  00254	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  00259	0f b6 c8	 movzx	 ecx, al
  0025c	83 f9 01	 cmp	 ecx, 1
  0025f	75 05		 jne	 SHORT $LN13@Fighter

; 1298 : 				{
; 1299 : 					continue;

  00261	e9 66 ff ff ff	 jmp	 $LN18@Fighter
$LN13@Fighter:

; 1300 : 				}
; 1301 : 				if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  00266	8b 45 e8	 mov	 eax, DWORD PTR _tObjNum$233612[ebp]
  00269	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0026f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00275	50		 push	 eax
  00276	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00279	51		 push	 ecx
  0027a	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0027f	83 c4 08	 add	 esp, 8
  00282	39 45 f0	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  00285	7c 2c		 jl	 SHORT $LN12@Fighter

; 1302 : 				{
; 1303 : 					gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  00287	6a 00		 push	 0
  00289	6a 00		 push	 0
  0028b	6a 00		 push	 0
  0028d	6a 00		 push	 0
  0028f	6a 01		 push	 1
  00291	6a 00		 push	 0
  00293	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00296	50		 push	 eax
  00297	8b 4d e8	 mov	 ecx, DWORD PTR _tObjNum$233612[ebp]
  0029a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  002a0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a6	51		 push	 ecx
  002a7	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  002aa	52		 push	 edx
  002ab	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  002b0	83 c4 24	 add	 esp, 36			; 00000024H
$LN12@Fighter:

; 1304 : 				}
; 1305 : 			}

  002b3	e9 14 ff ff ff	 jmp	 $LN18@Fighter
$LN20@Fighter:

; 1306 : 		}
; 1307 : 	}

  002b8	e9 4d 01 00 00	 jmp	 $LN30@Fighter
$LN22@Fighter:

; 1308 : 	else if(lpUser->m_OfflineSkill == 263 || lpUser->m_OfflineSkill == 559)

  002bd	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002c0	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  002c7	81 f9 07 01 00
	00		 cmp	 ecx, 263		; 00000107H
  002cd	74 16		 je	 SHORT $LN9@Fighter
  002cf	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002d2	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  002d9	81 f9 2f 02 00
	00		 cmp	 ecx, 559		; 0000022fH
  002df	0f 85 25 01 00
	00		 jne	 $LN30@Fighter
$LN9@Fighter:

; 1309 : 	{
; 1310 : 		gObjUseSkill.UseSkill(lpUser->m_Index, lpMagic, lpUser->X, lpUser->Y,0,0,-1);

  002e5	6a ff		 push	 -1
  002e7	6a 00		 push	 0
  002e9	6a 00		 push	 0
  002eb	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002ee	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  002f5	51		 push	 ecx
  002f6	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  002f9	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  00300	50		 push	 eax
  00301	8b 4d f4	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00304	51		 push	 ecx
  00305	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00308	8b 02		 mov	 eax, DWORD PTR [edx]
  0030a	50		 push	 eax
  0030b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00310	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 1311 : 
; 1312 : 		for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  00315	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _n$233621[ebp], 0
  0031c	eb 09		 jmp	 SHORT $LN8@Fighter
$LN7@Fighter:
  0031e	8b 45 e4	 mov	 eax, DWORD PTR _n$233621[ebp]
  00321	83 c0 01	 add	 eax, 1
  00324	89 45 e4	 mov	 DWORD PTR _n$233621[ebp], eax
$LN8@Fighter:
  00327	83 7d e4 4b	 cmp	 DWORD PTR _n$233621[ebp], 75 ; 0000004bH
  0032b	0f 8d d9 00 00
	00		 jge	 $LN30@Fighter

; 1313 : 		{
; 1314 : 			int tObjNum = lpUser->VpPlayer2[n].number;

  00331	8b 45 e4	 mov	 eax, DWORD PTR _n$233621[ebp]
  00334	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00337	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0033a	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  00342	89 55 e0	 mov	 DWORD PTR _tObjNum$233625[ebp], edx

; 1315 : 
; 1316 : 			if(lpUser->VpPlayer2[n].state == 0)

  00345	8b 45 e4	 mov	 eax, DWORD PTR _n$233621[ebp]
  00348	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0034b	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0034e	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  00356	85 d2		 test	 edx, edx
  00358	75 02		 jne	 SHORT $LN5@Fighter

; 1317 : 			{
; 1318 : 				continue;

  0035a	eb c2		 jmp	 SHORT $LN7@Fighter
$LN5@Fighter:

; 1319 : 			}
; 1320 : 			if (OBJMAX_RANGE(tObjNum) == FALSE)

  0035c	83 7d e0 00	 cmp	 DWORD PTR _tObjNum$233625[ebp], 0
  00360	7d 09		 jge	 SHORT $LN34@Fighter
  00362	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv243[ebp], 0
  00369	eb 0f		 jmp	 SHORT $LN35@Fighter
$LN34@Fighter:
  0036b	33 c0		 xor	 eax, eax
  0036d	81 7d e0 97 3a
	00 00		 cmp	 DWORD PTR _tObjNum$233625[ebp], 14999 ; 00003a97H
  00374	0f 9e c0	 setle	 al
  00377	89 45 9c	 mov	 DWORD PTR tv243[ebp], eax
$LN35@Fighter:
  0037a	83 7d 9c 00	 cmp	 DWORD PTR tv243[ebp], 0
  0037e	75 02		 jne	 SHORT $LN4@Fighter

; 1321 : 			{
; 1322 : 				continue;

  00380	eb 9c		 jmp	 SHORT $LN7@Fighter
$LN4@Fighter:

; 1323 : 			}
; 1324 : 			if ( gObj[tObjNum].Type != OBJ_MONSTER )

  00382	8b 45 e0	 mov	 eax, DWORD PTR _tObjNum$233625[ebp]
  00385	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0038b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00391	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00396	83 fa 02	 cmp	 edx, 2
  00399	74 02		 je	 SHORT $LN3@Fighter

; 1325 : 			{
; 1326 : 				continue;

  0039b	eb 81		 jmp	 SHORT $LN7@Fighter
$LN3@Fighter:

; 1327 : 			}
; 1328 : 			if(g_ExUser.InSafeZone(tObjNum) == true)

  0039d	8b 45 e0	 mov	 eax, DWORD PTR _tObjNum$233625[ebp]
  003a0	50		 push	 eax
  003a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  003a6	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  003ab	0f b6 c8	 movzx	 ecx, al
  003ae	83 f9 01	 cmp	 ecx, 1
  003b1	75 05		 jne	 SHORT $LN2@Fighter

; 1329 : 			{
; 1330 : 				continue;

  003b3	e9 66 ff ff ff	 jmp	 $LN7@Fighter
$LN2@Fighter:

; 1331 : 			}
; 1332 : 			if(MaxDis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  003b8	8b 45 e0	 mov	 eax, DWORD PTR _tObjNum$233625[ebp]
  003bb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003c1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c7	50		 push	 eax
  003c8	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  003cb	51		 push	 ecx
  003cc	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  003d1	83 c4 08	 add	 esp, 8
  003d4	39 45 f0	 cmp	 DWORD PTR _MaxDis$[ebp], eax
  003d7	7c 2c		 jl	 SHORT $LN1@Fighter

; 1333 : 			{
; 1334 : 				gObjAttack(lpUser, &gObj[tObjNum], lpMagic, FALSE, 1, 0, FALSE, 0, 0);

  003d9	6a 00		 push	 0
  003db	6a 00		 push	 0
  003dd	6a 00		 push	 0
  003df	6a 00		 push	 0
  003e1	6a 01		 push	 1
  003e3	6a 00		 push	 0
  003e5	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  003e8	50		 push	 eax
  003e9	8b 4d e0	 mov	 ecx, DWORD PTR _tObjNum$233625[ebp]
  003ec	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  003f2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f8	51		 push	 ecx
  003f9	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  003fc	52		 push	 edx
  003fd	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00402	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@Fighter:

; 1335 : 			}
; 1336 : 		}

  00405	e9 14 ff ff ff	 jmp	 $LN7@Fighter
$LN30@Fighter:

; 1337 : 	}
; 1338 : }

  0040a	5f		 pop	 edi
  0040b	5e		 pop	 esi
  0040c	5b		 pop	 ebx
  0040d	8b e5		 mov	 esp, ebp
  0040f	5d		 pop	 ebp
  00410	c2 04 00	 ret	 4
?Fighter@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::Fighter
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_rand:PROC
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?SearchTarget@OfflineMode@@QAEHHH@Z
_TEXT	SEGMENT
tv85 = -400						; size = 4
_tObjNum$233646 = -332					; size = 4
_n$233642 = -328					; size = 4
_IndexNumber$ = -324					; size = 4
_TargetCount$ = -320					; size = 4
_TargetIndex$ = -316					; size = 300
_searchtarget$ = -16					; size = 4
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
_maxdis$ = 12						; size = 4
?SearchTarget@OfflineMode@@QAEHHH@Z PROC		; OfflineMode::SearchTarget, COMDAT
; _this$ = ecx

; 1342 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1343 : 	if(!gObjIsConnectedEx(UserIndex))

  00019	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00022	83 c4 04	 add	 esp, 4
  00025	0f b6 c8	 movzx	 ecx, al
  00028	85 c9		 test	 ecx, ecx
  0002a	75 08		 jne	 SHORT $LN10@SearchTarg

; 1344 : 	{
; 1345 : 		return -1;

  0002c	83 c8 ff	 or	 eax, -1
  0002f	e9 74 01 00 00	 jmp	 $LN11@SearchTarg
$LN10@SearchTarg:

; 1346 : 	}
; 1347 : 
; 1348 : 	LPOBJ lpUser = &gObj[UserIndex];

  00034	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00037	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0003d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1349 : 
; 1350 : 	int searchtarget = -1;

  00046	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _searchtarget$[ebp], -1

; 1351 : 	int TargetIndex[MAX_VIEWPORT_MONSTER];
; 1352 : 	int TargetCount = 0;

  0004d	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _TargetCount$[ebp], 0

; 1353 : 	int IndexNumber;
; 1354 : 
; 1355 : 	for (int n=0;n<MAX_VIEWPORT_MONSTER;n++)

  00057	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$233642[ebp], 0
  00061	eb 0f		 jmp	 SHORT $LN9@SearchTarg
$LN8@SearchTarg:
  00063	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _n$233642[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _n$233642[ebp], eax
$LN9@SearchTarg:
  00072	83 bd b8 fe ff
	ff 4b		 cmp	 DWORD PTR _n$233642[ebp], 75 ; 0000004bH
  00079	0f 8d f6 00 00
	00		 jge	 $LN7@SearchTarg

; 1356 : 	{
; 1357 : 		int tObjNum = lpUser->VpPlayer2[n].number;

  0007f	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _n$233642[ebp]
  00085	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00088	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0008b	0f bf 94 01 ae
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax+2222]
  00093	89 95 b4 fe ff
	ff		 mov	 DWORD PTR _tObjNum$233646[ebp], edx

; 1358 : 
; 1359 : 		if(lpUser->VpPlayer2[n].state == 0)

  00099	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _n$233642[ebp]
  0009f	6b c0 0c	 imul	 eax, 12			; 0000000cH
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  000a5	0f be 94 01 ac
	08 00 00	 movsx	 edx, BYTE PTR [ecx+eax+2220]
  000ad	85 d2		 test	 edx, edx
  000af	75 02		 jne	 SHORT $LN6@SearchTarg

; 1360 : 		{
; 1361 : 			continue;

  000b1	eb b0		 jmp	 SHORT $LN8@SearchTarg
$LN6@SearchTarg:

; 1362 : 		}
; 1363 : 		if (OBJMAX_RANGE(tObjNum) == FALSE)

  000b3	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR _tObjNum$233646[ebp], 0
  000ba	7d 0c		 jge	 SHORT $LN13@SearchTarg
  000bc	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
  000c6	eb 15		 jmp	 SHORT $LN14@SearchTarg
$LN13@SearchTarg:
  000c8	33 c0		 xor	 eax, eax
  000ca	81 bd b4 fe ff
	ff 97 3a 00 00	 cmp	 DWORD PTR _tObjNum$233646[ebp], 14999 ; 00003a97H
  000d4	0f 9e c0	 setle	 al
  000d7	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$LN14@SearchTarg:
  000dd	83 bd 70 fe ff
	ff 00		 cmp	 DWORD PTR tv85[ebp], 0
  000e4	75 05		 jne	 SHORT $LN5@SearchTarg

; 1364 : 		{
; 1365 : 			continue;

  000e6	e9 78 ff ff ff	 jmp	 $LN8@SearchTarg
$LN5@SearchTarg:

; 1366 : 		}
; 1367 : 		if ( gObj[tObjNum].Type != OBJ_MONSTER )

  000eb	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _tObjNum$233646[ebp]
  000f1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fd	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00102	83 fa 02	 cmp	 edx, 2
  00105	74 05		 je	 SHORT $LN4@SearchTarg

; 1368 : 		{
; 1369 : 			continue;

  00107	e9 57 ff ff ff	 jmp	 $LN8@SearchTarg
$LN4@SearchTarg:

; 1370 : 		}
; 1371 : 		if(g_ExUser.InSafeZone(tObjNum) == true)

  0010c	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _tObjNum$233646[ebp]
  00112	50		 push	 eax
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExUser@@3VÑExUser@@A ; g_ExUser
  00118	e8 00 00 00 00	 call	 ?InSafeZone@ÑExUser@@QAE_NH@Z ; ÑExUser::InSafeZone
  0011d	0f b6 c8	 movzx	 ecx, al
  00120	83 f9 01	 cmp	 ecx, 1
  00123	75 05		 jne	 SHORT $LN3@SearchTarg

; 1372 : 		{
; 1373 : 			continue;

  00125	e9 39 ff ff ff	 jmp	 $LN8@SearchTarg
$LN3@SearchTarg:

; 1374 : 		}
; 1375 : 		if(maxdis >= gObjCalDistance(lpUser, &gObj[tObjNum]))

  0012a	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _tObjNum$233646[ebp]
  00130	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00136	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013c	50		 push	 eax
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00146	83 c4 08	 add	 esp, 8
  00149	39 45 0c	 cmp	 DWORD PTR _maxdis$[ebp], eax
  0014c	7c 22		 jl	 SHORT $LN2@SearchTarg

; 1376 : 		{
; 1377 : 			TargetIndex[TargetCount] = tObjNum;

  0014e	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _TargetCount$[ebp]
  00154	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _tObjNum$233646[ebp]
  0015a	89 8c 85 c4 fe
	ff ff		 mov	 DWORD PTR _TargetIndex$[ebp+eax*4], ecx

; 1378 : 			TargetCount++;

  00161	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _TargetCount$[ebp]
  00167	83 c0 01	 add	 eax, 1
  0016a	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _TargetCount$[ebp], eax
$LN2@SearchTarg:

; 1379 : 		}
; 1380 : 	}

  00170	e9 ee fe ff ff	 jmp	 $LN8@SearchTarg
$LN7@SearchTarg:

; 1381 : 
; 1382 : 	if(TargetCount <= 0)

  00175	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR _TargetCount$[ebp], 0
  0017c	7f 05		 jg	 SHORT $LN1@SearchTarg

; 1383 : 	{
; 1384 : 		return -1;

  0017e	83 c8 ff	 or	 eax, -1
  00181	eb 25		 jmp	 SHORT $LN11@SearchTarg
$LN1@SearchTarg:

; 1385 : 	}
; 1386 : 	
; 1387 : 	IndexNumber = rand()%TargetCount;

  00183	e8 00 00 00 00	 call	 _rand
  00188	99		 cdq
  00189	f7 bd c0 fe ff
	ff		 idiv	 DWORD PTR _TargetCount$[ebp]
  0018f	89 95 bc fe ff
	ff		 mov	 DWORD PTR _IndexNumber$[ebp], edx

; 1388 : 
; 1389 : 	searchtarget = TargetIndex[IndexNumber];

  00195	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _IndexNumber$[ebp]
  0019b	8b 8c 85 c4 fe
	ff ff		 mov	 ecx, DWORD PTR _TargetIndex$[ebp+eax*4]
  001a2	89 4d f0	 mov	 DWORD PTR _searchtarget$[ebp], ecx

; 1390 : 
; 1391 : 	return searchtarget;

  001a5	8b 45 f0	 mov	 eax, DWORD PTR _searchtarget$[ebp]
$LN11@SearchTarg:

; 1392 : }

  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ae	33 cd		 xor	 ecx, ebp
  001b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	c2 08 00	 ret	 8
?SearchTarget@OfflineMode@@QAEHHH@Z ENDP		; OfflineMode::SearchTarget
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?OffTimer@OfflineMode@@QAE_NHH@Z
_TEXT	SEGMENT
tv67 = -84						; size = 4
_res$233665 = -16					; size = 4
_i$233661 = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
_DivTime$ = 12						; size = 4
?OffTimer@OfflineMode@@QAE_NHH@Z PROC			; OfflineMode::OffTimer, COMDAT
; _this$ = ecx

; 1396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1397 : 	if ( OBJMAX_RANGE(UserIndex) == FALSE )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _UserIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN9@OffTimer
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 0f		 jmp	 SHORT $LN10@OffTimer
$LN9@OffTimer:
  0001b	33 c0		 xor	 eax, eax
  0001d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _UserIndex$[ebp], 14999 ; 00003a97H
  00024	0f 9e c0	 setle	 al
  00027	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN10@OffTimer:
  0002a	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0002e	75 04		 jne	 SHORT $LN6@OffTimer

; 1398 : 	{
; 1399 : 		return false;

  00030	32 c0		 xor	 al, al
  00032	eb 62		 jmp	 SHORT $LN7@OffTimer
$LN6@OffTimer:

; 1400 : 	}
; 1401 : 
; 1402 : 	if(!gObjIsConnectedEx(UserIndex))

  00034	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  0003d	83 c4 04	 add	 esp, 4
  00040	0f b6 c8	 movzx	 ecx, al
  00043	85 c9		 test	 ecx, ecx
  00045	75 04		 jne	 SHORT $LN5@OffTimer

; 1403 : 	{
; 1404 : 		return false;

  00047	32 c0		 xor	 al, al
  00049	eb 4b		 jmp	 SHORT $LN7@OffTimer
$LN5@OffTimer:

; 1405 : 	}
; 1406 : 	
; 1407 : 	LPOBJ lpUser = &gObj[UserIndex];

  0004b	8b 45 08	 mov	 eax, DWORD PTR _UserIndex$[ebp]
  0004e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1408 : 
; 1409 : 	for(int i = 0; i < OFFMAXTIME_FOR_BUFF; i++)

  0005d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$233661[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN4@OffTimer
$LN3@OffTimer:
  00066	8b 45 f4	 mov	 eax, DWORD PTR _i$233661[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 45 f4	 mov	 DWORD PTR _i$233661[ebp], eax
$LN4@OffTimer:
  0006f	83 7d f4 14	 cmp	 DWORD PTR _i$233661[ebp], 20 ; 00000014H
  00073	7d 1f		 jge	 SHORT $LN2@OffTimer

; 1410 : 	{
; 1411 : 		int res = DivTime * i;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _DivTime$[ebp]
  00078	0f af 45 f4	 imul	 eax, DWORD PTR _i$233661[ebp]
  0007c	89 45 f0	 mov	 DWORD PTR _res$233665[ebp], eax

; 1412 : 		if(res == lpUser->m_OfflineBuffTime)

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00082	0f b6 88 d8 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10456]
  00089	39 4d f0	 cmp	 DWORD PTR _res$233665[ebp], ecx
  0008c	75 04		 jne	 SHORT $LN1@OffTimer

; 1413 : 		{
; 1414 : 			return true;

  0008e	b0 01		 mov	 al, 1
  00090	eb 04		 jmp	 SHORT $LN7@OffTimer
$LN1@OffTimer:

; 1415 : 		}
; 1416 : 	}

  00092	eb d2		 jmp	 SHORT $LN3@OffTimer
$LN2@OffTimer:

; 1417 : 
; 1418 : 	return false;

  00094	32 c0		 xor	 al, al
$LN7@OffTimer:

; 1419 : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 08 00	 ret	 8
?OffTimer@OfflineMode@@QAE_NHH@Z ENDP			; OfflineMode::OffTimer
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
PUBLIC	?__LINE__Var@?1??PickUP@OfflineMode@@QAEXH@Z@4JA ; `OfflineMode::PickUP'::`2'::__LINE__Var
EXTRN	?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z:PROC ; GCSendGetItemInfoForParty
EXTRN	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z:PROC ; gObjInventoryInsertItem
EXTRN	?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z:PROC ; gObjInventoryInsertItemTemp
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?ItemGive@MapClass@@QAEHHH_N@Z:PROC		; MapClass::ItemGive
EXTRN	?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z:PROC ; CQuestInfo::CountQuestItemInInventory
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@
CONST	SEGMENT
??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\offlinemode.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??PickUP@OfflineMode@@QAEXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??PickUP@OfflineMode@@QAEXH@Z@4JA DD 0590H ; `OfflineMode::PickUP'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI /ZX
_DATA	ENDS
;	COMDAT ?PickUP@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv347 = -108						; size = 4
tv87 = -108						; size = 4
tv67 = -108						; size = 4
_pos$233712 = -39					; size = 1
_result$233709 = -38					; size = 1
_PickItem$233694 = -37					; size = 1
_dis$233689 = -36					; size = 4
_ty$233688 = -32					; size = 4
_tx$233687 = -28					; size = 4
_item_num$233682 = -24					; size = 4
_map_num$ = -20						; size = 4
_lpUser$ = -16						; size = 4
_lpMapItem$ = -12					; size = 4
_distance$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?PickUP@OfflineMode@@QAEXH@Z PROC			; OfflineMode::PickUP, COMDAT
; _this$ = ecx

; 1424 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1425 : 	if(!OBJMAX_RANGE(aIndex))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN31@PickUP
  00012	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 0f		 jmp	 SHORT $LN32@PickUP
$LN31@PickUP:
  0001b	33 c0		 xor	 eax, eax
  0001d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00024	0f 9e c0	 setle	 al
  00027	89 45 94	 mov	 DWORD PTR tv67[ebp], eax
$LN32@PickUP:
  0002a	83 7d 94 00	 cmp	 DWORD PTR tv67[ebp], 0
  0002e	75 05		 jne	 SHORT $LN28@PickUP

; 1426 : 	{
; 1427 : 		return;

  00030	e9 aa 03 00 00	 jmp	 $LN29@PickUP
$LN28@PickUP:

; 1428 : 	}
; 1429 : 
; 1430 : 	if(!gObjIsConnectedEx(aIndex))

  00035	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  0003e	83 c4 04	 add	 esp, 4
  00041	0f b6 c8	 movzx	 ecx, al
  00044	85 c9		 test	 ecx, ecx
  00046	75 05		 jne	 SHORT $LN27@PickUP

; 1431 : 	{
; 1432 : 		return;

  00048	e9 92 03 00 00	 jmp	 $LN29@PickUP
$LN27@PickUP:

; 1433 : 	}
; 1434 : 	int distance = 3;

  0004d	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _distance$[ebp], 3

; 1435 : 	CMapItem * lpMapItem;
; 1436 : 	LPOBJ lpUser = &gObj[aIndex];

  00054	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00057	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0005d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	89 45 f0	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1437 : 	int map_num = gObj[aIndex].MapNumber;

  00066	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0007d	89 55 ec	 mov	 DWORD PTR _map_num$[ebp], edx

; 1438 : 
; 1439 : 	if(gObj[aIndex].DieRegen != 0)

  00080	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00083	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008f	0f be 94 01 a2
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+930]
  00097	85 d2		 test	 edx, edx
  00099	74 05		 je	 SHORT $LN26@PickUP

; 1440 : 	{
; 1441 : 		return;

  0009b	e9 3f 03 00 00	 jmp	 $LN29@PickUP
$LN26@PickUP:

; 1442 : 	}
; 1443 : 
; 1444 : 	if (MAX_MAP_RANGE(map_num) == FALSE)

  000a0	83 7d ec 00	 cmp	 DWORD PTR _map_num$[ebp], 0
  000a4	7d 09		 jge	 SHORT $LN33@PickUP
  000a6	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  000ad	eb 0c		 jmp	 SHORT $LN34@PickUP
$LN33@PickUP:
  000af	33 c0		 xor	 eax, eax
  000b1	83 7d ec 59	 cmp	 DWORD PTR _map_num$[ebp], 89 ; 00000059H
  000b5	0f 9e c0	 setle	 al
  000b8	89 45 94	 mov	 DWORD PTR tv87[ebp], eax
$LN34@PickUP:
  000bb	83 7d 94 00	 cmp	 DWORD PTR tv87[ebp], 0
  000bf	75 21		 jne	 SHORT $LN25@PickUP

; 1445 : 	{
; 1446 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??PickUP@OfflineMode@@QAEXH@Z@4JA
  000c6	83 c0 16	 add	 eax, 22			; 00000016H
  000c9	50		 push	 eax
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1447 : 		return;

  000dd	e9 fd 02 00 00	 jmp	 $LN29@PickUP
$LN25@PickUP:

; 1448 : 	}
; 1449 : 
; 1450 : 	for(int item_num = 0; item_num < MAX_MAPITEM; item_num++)

  000e2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _item_num$233682[ebp], 0
  000e9	eb 09		 jmp	 SHORT $LN24@PickUP
$LN23@PickUP:
  000eb	8b 45 e8	 mov	 eax, DWORD PTR _item_num$233682[ebp]
  000ee	83 c0 01	 add	 eax, 1
  000f1	89 45 e8	 mov	 DWORD PTR _item_num$233682[ebp], eax
$LN24@PickUP:
  000f4	81 7d e8 2c 01
	00 00		 cmp	 DWORD PTR _item_num$233682[ebp], 300 ; 0000012cH
  000fb	0f 8d de 02 00
	00		 jge	 $LN22@PickUP

; 1451 : 	{
; 1452 : 		lpMapItem = &MapC[map_num].m_cItem[item_num];

  00101	8b 45 ec	 mov	 eax, DWORD PTR _map_num$[ebp]
  00104	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  0010a	8b 4d e8	 mov	 ecx, DWORD PTR _item_num$233682[ebp]
  0010d	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  00113	8d 94 08 20 00
	00 00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+ecx+32]
  0011a	89 55 f4	 mov	 DWORD PTR _lpMapItem$[ebp], edx

; 1453 : 
; 1454 : 		if(lpMapItem->IsItem() == TRUE && lpMapItem->Give == false && lpMapItem->live == true)

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR _lpMapItem$[ebp]
  00120	83 c1 04	 add	 ecx, 4
  00123	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00128	83 f8 01	 cmp	 eax, 1
  0012b	0f 85 a9 02 00
	00		 jne	 $LN1@PickUP
  00131	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00134	0f b6 88 db 00
	00 00		 movzx	 ecx, BYTE PTR [eax+219]
  0013b	85 c9		 test	 ecx, ecx
  0013d	0f 85 97 02 00
	00		 jne	 $LN1@PickUP
  00143	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00146	0f b6 88 da 00
	00 00		 movzx	 ecx, BYTE PTR [eax+218]
  0014d	83 f9 01	 cmp	 ecx, 1
  00150	0f 85 84 02 00
	00		 jne	 $LN1@PickUP

; 1455 : 		{
; 1456 : 			int tx = lpUser->X - lpMapItem->px;

  00156	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00159	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00160	8b 55 f4	 mov	 edx, DWORD PTR _lpMapItem$[ebp]
  00163	0f b6 82 d8 00
	00 00		 movzx	 eax, BYTE PTR [edx+216]
  0016a	2b c8		 sub	 ecx, eax
  0016c	89 4d e4	 mov	 DWORD PTR _tx$233687[ebp], ecx

; 1457 : 			int ty = lpUser->Y - lpMapItem->py;

  0016f	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00172	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00179	8b 55 f4	 mov	 edx, DWORD PTR _lpMapItem$[ebp]
  0017c	0f b6 82 d9 00
	00 00		 movzx	 eax, BYTE PTR [edx+217]
  00183	2b c8		 sub	 ecx, eax
  00185	89 4d e0	 mov	 DWORD PTR _ty$233688[ebp], ecx

; 1458 : 					
; 1459 : 			int dis = sqrt((float) (tx*tx+ty*ty));	//ðàçîáðàòñÿ êàê ðàáîòàåò

  00188	8b 45 e4	 mov	 eax, DWORD PTR _tx$233687[ebp]
  0018b	0f af 45 e4	 imul	 eax, DWORD PTR _tx$233687[ebp]
  0018f	8b 4d e0	 mov	 ecx, DWORD PTR _ty$233688[ebp]
  00192	0f af 4d e0	 imul	 ecx, DWORD PTR _ty$233688[ebp]
  00196	03 c1		 add	 eax, ecx
  00198	89 45 94	 mov	 DWORD PTR tv347[ebp], eax
  0019b	db 45 94	 fild	 DWORD PTR tv347[ebp]
  0019e	51		 push	 ecx
  0019f	d9 1c 24	 fstp	 DWORD PTR [esp]
  001a2	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  001a7	83 c4 04	 add	 esp, 4
  001aa	e8 00 00 00 00	 call	 __ftol2_sse
  001af	89 45 dc	 mov	 DWORD PTR _dis$233689[ebp], eax

; 1460 : 
; 1461 : 			if(dis > distance)

  001b2	8b 45 dc	 mov	 eax, DWORD PTR _dis$233689[ebp]
  001b5	3b 45 f8	 cmp	 eax, DWORD PTR _distance$[ebp]
  001b8	7e 05		 jle	 SHORT $LN20@PickUP

; 1462 : 			{
; 1463 : 				continue;

  001ba	e9 2c ff ff ff	 jmp	 $LN23@PickUP
$LN20@PickUP:

; 1464 : 			}
; 1465 : 
; 1466 : 			//all items
; 1467 : 			if(lpMapItem->m_QuestItem != false )

  001bf	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  001c2	0f b6 88 b1 00
	00 00		 movzx	 ecx, BYTE PTR [eax+177]
  001c9	85 c9		 test	 ecx, ecx
  001cb	74 27		 je	 SHORT $LN18@PickUP

; 1468 : 			{
; 1469 : 				if(!g_QuestInfo.CountQuestItemInInventory(aIndex, lpMapItem->m_Type, lpMapItem->m_Level))

  001cd	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  001d0	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  001d4	51		 push	 ecx
  001d5	8b 55 f4	 mov	 edx, DWORD PTR _lpMapItem$[ebp]
  001d8	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  001dc	50		 push	 eax
  001dd	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001e0	51		 push	 ecx
  001e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  001e6	e8 00 00 00 00	 call	 ?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z ; CQuestInfo::CountQuestItemInInventory
  001eb	85 c0		 test	 eax, eax
  001ed	75 05		 jne	 SHORT $LN18@PickUP

; 1470 : 				{
; 1471 : 					continue;

  001ef	e9 f7 fe ff ff	 jmp	 $LN23@PickUP
$LN18@PickUP:

; 1472 : 				}
; 1473 : 			}
; 1474 : 
; 1475 : 			bool PickItem = false;

  001f4	c6 45 db 00	 mov	 BYTE PTR _PickItem$233694[ebp], 0

; 1476 : 
; 1477 : 			//zen item
; 1478 : 			if(lpMapItem->m_Type == ITEMGET(14,15))

  001f8	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  001fb	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  001ff	81 f9 0f 1c 00
	00		 cmp	 ecx, 7183		; 00001c0fH
  00205	0f 85 89 00 00
	00		 jne	 $LN16@PickUP

; 1479 : 			{
; 1480 : 				if(lpUser->m_OfflinePickZen == true)

  0020b	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0020e	0f b6 88 e0 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10464]
  00215	83 f9 01	 cmp	 ecx, 1
  00218	75 7a		 jne	 SHORT $LN16@PickUP

; 1481 : 				{
; 1482 : 					if(MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE)

  0021a	6a 00		 push	 0
  0021c	8b 45 e8	 mov	 eax, DWORD PTR _item_num$233682[ebp]
  0021f	50		 push	 eax
  00220	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00223	51		 push	 ecx
  00224	8b 4d ec	 mov	 ecx, DWORD PTR _map_num$[ebp]
  00227	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0022d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00233	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00238	83 f8 01	 cmp	 eax, 1
  0023b	75 52		 jne	 SHORT $LN12@PickUP

; 1483 : 					{
; 1484 : 						if(!gObjCheckMaxZen(aIndex, lpMapItem->m_BuyMoney))

  0023d	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00240	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00243	51		 push	 ecx
  00244	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00247	52		 push	 edx
  00248	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  0024d	83 c4 08	 add	 esp, 8
  00250	85 c0		 test	 eax, eax
  00252	75 23		 jne	 SHORT $LN14@PickUP

; 1485 : 						{
; 1486 : 							if(lpUser->Money < MAX_ZEN)

  00254	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00257	81 b8 f0 00 00
	00 00 94 35 77	 cmp	 DWORD PTR [eax+240], 2000000000 ; 77359400H
  00261	7d 12		 jge	 SHORT $LN13@PickUP

; 1487 : 							{
; 1488 : 								lpUser->Money = MAX_ZEN;

  00263	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00266	c7 80 f0 00 00
	00 00 94 35 77	 mov	 DWORD PTR [eax+240], 2000000000 ; 77359400H

; 1489 : 								continue;

  00270	e9 76 fe ff ff	 jmp	 $LN23@PickUP
$LN13@PickUP:

; 1490 : 							}
; 1491 : 						}
; 1492 : 						else

  00275	eb 18		 jmp	 SHORT $LN12@PickUP
$LN14@PickUP:

; 1493 : 						{
; 1494 : 							lpUser->Money += lpMapItem->m_BuyMoney;

  00277	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0027a	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00280	8b 55 f4	 mov	 edx, DWORD PTR _lpMapItem$[ebp]
  00283	03 4a 74	 add	 ecx, DWORD PTR [edx+116]
  00286	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00289	89 88 f0 00 00
	00		 mov	 DWORD PTR [eax+240], ecx
$LN12@PickUP:

; 1495 : 						}
; 1496 : 					}
; 1497 : 					continue;

  0028f	e9 57 fe ff ff	 jmp	 $LN23@PickUP
$LN16@PickUP:

; 1498 : 				}
; 1499 : 			}
; 1500 : 			//Exellent
; 1501 : 			if(lpMapItem->m_NewOption > 0)

  00294	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00297	0f b6 88 9b 00
	00 00		 movzx	 ecx, BYTE PTR [eax+155]
  0029e	85 c9		 test	 ecx, ecx
  002a0	7e 13		 jle	 SHORT $LN10@PickUP

; 1502 : 			{
; 1503 : 				if(lpUser->m_OfflinePickExel == true)

  002a2	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002a5	0f b6 88 e2 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10466]
  002ac	83 f9 01	 cmp	 ecx, 1
  002af	75 04		 jne	 SHORT $LN10@PickUP

; 1504 : 				{
; 1505 : 					PickItem = true;

  002b1	c6 45 db 01	 mov	 BYTE PTR _PickItem$233694[ebp], 1
$LN10@PickUP:

; 1506 : 				}
; 1507 : 			}
; 1508 : 			//Ancent
; 1509 : 			if(lpMapItem->m_SetOption > 0)

  002b5	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  002b8	0f b6 88 b2 00
	00 00		 movzx	 ecx, BYTE PTR [eax+178]
  002bf	85 c9		 test	 ecx, ecx
  002c1	7e 13		 jle	 SHORT $LN8@PickUP

; 1510 : 			{
; 1511 : 				if(lpUser->m_OfflinePickAnc == true)

  002c3	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002c6	0f b6 88 e3 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10467]
  002cd	83 f9 01	 cmp	 ecx, 1
  002d0	75 04		 jne	 SHORT $LN8@PickUP

; 1512 : 				{
; 1513 : 					PickItem = true;

  002d2	c6 45 db 01	 mov	 BYTE PTR _PickItem$233694[ebp], 1
$LN8@PickUP:

; 1514 : 				}
; 1515 : 			}
; 1516 : 			//Jewels
; 1517 : 			if(lpMapItem->m_Type == ITEMGET(12, 15) ||
; 1518 : 			   lpMapItem->m_Type == ITEMGET(14, 13) ||
; 1519 : 			   lpMapItem->m_Type == ITEMGET(14, 14) ||
; 1520 : 			   lpMapItem->m_Type == ITEMGET(14, 16) ||
; 1521 : 			   lpMapItem->m_Type == ITEMGET(14, 22) ||
; 1522 : 			   lpMapItem->m_Type == ITEMGET(14, 31) ||
; 1523 : 			   lpMapItem->m_Type == ITEMGET(14, 42))

  002d6	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  002d9	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  002dd	81 f9 0f 18 00
	00		 cmp	 ecx, 6159		; 0000180fH
  002e3	74 5a		 je	 SHORT $LN6@PickUP
  002e5	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  002e8	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  002ec	81 f9 0d 1c 00
	00		 cmp	 ecx, 7181		; 00001c0dH
  002f2	74 4b		 je	 SHORT $LN6@PickUP
  002f4	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  002f7	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  002fb	81 f9 0e 1c 00
	00		 cmp	 ecx, 7182		; 00001c0eH
  00301	74 3c		 je	 SHORT $LN6@PickUP
  00303	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00306	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  0030a	81 f9 10 1c 00
	00		 cmp	 ecx, 7184		; 00001c10H
  00310	74 2d		 je	 SHORT $LN6@PickUP
  00312	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00315	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00319	81 f9 16 1c 00
	00		 cmp	 ecx, 7190		; 00001c16H
  0031f	74 1e		 je	 SHORT $LN6@PickUP
  00321	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00324	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00328	81 f9 1f 1c 00
	00		 cmp	 ecx, 7199		; 00001c1fH
  0032e	74 0f		 je	 SHORT $LN6@PickUP
  00330	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00333	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00337	81 f9 2a 1c 00
	00		 cmp	 ecx, 7210		; 00001c2aH
  0033d	75 13		 jne	 SHORT $LN5@PickUP
$LN6@PickUP:

; 1524 : 			{
; 1525 : 				if(lpUser->m_OfflinePickJewel == true)

  0033f	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00342	0f b6 88 e1 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10465]
  00349	83 f9 01	 cmp	 ecx, 1
  0034c	75 04		 jne	 SHORT $LN5@PickUP

; 1526 : 				{
; 1527 : 					PickItem =  true;

  0034e	c6 45 db 01	 mov	 BYTE PTR _PickItem$233694[ebp], 1
$LN5@PickUP:

; 1528 : 				}
; 1529 : 			}
; 1530 : 			//PickUP
; 1531 : 			if(PickItem == false)

  00352	0f b6 45 db	 movzx	 eax, BYTE PTR _PickItem$233694[ebp]
  00356	85 c0		 test	 eax, eax
  00358	75 05		 jne	 SHORT $LN4@PickUP

; 1532 : 			{
; 1533 : 				continue;

  0035a	e9 8c fd ff ff	 jmp	 $LN23@PickUP
$LN4@PickUP:

; 1534 : 			}
; 1535 : 
; 1536 : 			BYTE result = ::gObjInventoryInsertItemTemp(&gObj[aIndex], lpMapItem);

  0035f	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  00362	50		 push	 eax
  00363	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00366	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0036c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
  00378	83 c4 08	 add	 esp, 8
  0037b	88 45 da	 mov	 BYTE PTR _result$233709[ebp], al

; 1537 : 			if (result != 0xFF)

  0037e	0f b6 45 da	 movzx	 eax, BYTE PTR _result$233709[ebp]
  00382	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00387	74 51		 je	 SHORT $LN1@PickUP

; 1538 : 			{
; 1539 : 				if(MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE)

  00389	6a 00		 push	 0
  0038b	8b 45 e8	 mov	 eax, DWORD PTR _item_num$233682[ebp]
  0038e	50		 push	 eax
  0038f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00392	51		 push	 ecx
  00393	8b 4d ec	 mov	 ecx, DWORD PTR _map_num$[ebp]
  00396	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0039c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  003a2	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  003a7	83 f8 01	 cmp	 eax, 1
  003aa	75 2e		 jne	 SHORT $LN1@PickUP

; 1540 : 				{
; 1541 : 					BYTE pos = ::gObjInventoryInsertItem(aIndex, lpMapItem);

  003ac	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  003af	50		 push	 eax
  003b0	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003b3	51		 push	 ecx
  003b4	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ; gObjInventoryInsertItem
  003b9	83 c4 08	 add	 esp, 8
  003bc	88 45 d9	 mov	 BYTE PTR _pos$233712[ebp], al

; 1542 : 					if(pos != 0xFF)

  003bf	0f b6 45 d9	 movzx	 eax, BYTE PTR _pos$233712[ebp]
  003c3	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  003c8	74 10		 je	 SHORT $LN1@PickUP

; 1543 : 					{
; 1544 : 						::GCSendGetItemInfoForParty(aIndex, lpMapItem);

  003ca	8b 45 f4	 mov	 eax, DWORD PTR _lpMapItem$[ebp]
  003cd	50		 push	 eax
  003ce	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003d1	51		 push	 ecx
  003d2	e8 00 00 00 00	 call	 ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ; GCSendGetItemInfoForParty
  003d7	83 c4 08	 add	 esp, 8
$LN1@PickUP:

; 1545 : 					}
; 1546 : 				}
; 1547 : 			}
; 1548 : 		}			
; 1549 : 	}

  003da	e9 0c fd ff ff	 jmp	 $LN23@PickUP
$LN22@PickUP:
$LN29@PickUP:

; 1550 : }

  003df	5f		 pop	 edi
  003e0	5e		 pop	 esi
  003e1	5b		 pop	 ebx
  003e2	8b e5		 mov	 esp, ebp
  003e4	5d		 pop	 ebp
  003e5	c2 04 00	 ret	 4
?PickUP@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::PickUP
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??GCConfig@OfflineMode@@QAEXH@Z@4JA ; `OfflineMode::GCConfig'::`2'::__LINE__Var
PUBLIC	__$ArrayPad$
PUBLIC	?GCConfig@OfflineMode@@QAEXH@Z			; OfflineMode::GCConfig
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GCConfig@OfflineMode@@QAEXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GCConfig@OfflineMode@@QAEXH@Z@4JA DD 0613H ; `OfflineMode::GCConfig'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI /ZX
_DATA	ENDS
;	COMDAT ?GCConfig@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv67 = -108						; size = 4
_pSend$ = -40						; size = 28
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCConfig@OfflineMode@@QAEXH@Z PROC			; OfflineMode::GCConfig, COMDAT
; _this$ = ecx

; 1555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1556 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00016	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $LN4@GCConfig
  0001c	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00023	eb 0f		 jmp	 SHORT $LN5@GCConfig
$LN4@GCConfig:
  00025	33 c0		 xor	 eax, eax
  00027	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0002e	0f 9e c0	 setle	 al
  00031	89 45 94	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GCConfig:
  00034	83 7d 94 00	 cmp	 DWORD PTR tv67[ebp], 0
  00038	75 1e		 jne	 SHORT $LN1@GCConfig

; 1557 : 	{
; 1558 : 		LogAdd("error : %s %d", __FILE__, __LINE__ );

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??GCConfig@OfflineMode@@QAEXH@Z@4JA
  0003f	83 c0 03	 add	 eax, 3
  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1559 : 		return;

  00056	eb 74		 jmp	 SHORT $LN2@GCConfig
$LN1@GCConfig:

; 1560 : 	}
; 1561 : 
; 1562 : 	LPOBJ lpUser = &gObj[aIndex];

  00058	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00061	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00067	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1563 : 
; 1564 : 	/*if(lpUser->Connected < PLAYER_PLAYING)
; 1565 : 	{
; 1566 : 		return;
; 1567 : 	}*/
; 1568 : 
; 1569 : 	GC_OFFMODE_CONFIG pSend;
; 1570 : 	pSend.h.set((LPBYTE)&pSend, 0xFB, 0x30, sizeof(pSend));

  0006a	6a 1c		 push	 28			; 0000001cH
  0006c	6a 30		 push	 48			; 00000030H
  0006e	68 fb 00 00 00	 push	 251			; 000000fbH
  00073	8d 45 d8	 lea	 eax, DWORD PTR _pSend$[ebp]
  00076	50		 push	 eax
  00077	8d 4d d8	 lea	 ecx, DWORD PTR _pSend$[ebp]
  0007a	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 1571 : 	pSend.PriceZen = this->PriceZen;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00082	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00085	89 4d dc	 mov	 DWORD PTR _pSend$[ebp+4], ecx

; 1572 : 	pSend.PriceWcoin = this->PriceWcoin;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0008e	89 4d e0	 mov	 DWORD PTR _pSend$[ebp+8], ecx

; 1573 : 	pSend.iHourCredit = this->HourCredit;

  00091	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00097	89 4d e4	 mov	 DWORD PTR _pSend$[ebp+12], ecx

; 1574 : 
; 1575 : 	#if(ADD_OFFMODE_TIMER)
; 1576 : 	pSend.StandartPlayerTime = this->m_StandartPlayerTime;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000a0	89 4d e8	 mov	 DWORD PTR _pSend$[ebp+16], ecx

; 1577 : 	pSend.OtherPlayerMaxTime = this->m_OtherPlayerMaxTime;

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000a9	89 4d ec	 mov	 DWORD PTR _pSend$[ebp+20], ecx

; 1578 : 	pSend.PremiumPlayerMaxTime = this->m_PremiumPlayerMaxTime;

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000b2	89 4d f0	 mov	 DWORD PTR _pSend$[ebp+24], ecx

; 1579 : 	#endif
; 1580 : 
; 1581 : 	DataSend(lpUser->m_Index, (LPBYTE)&pSend, pSend.h.size);

  000b5	0f b6 45 d9	 movzx	 eax, BYTE PTR _pSend$[ebp+1]
  000b9	50		 push	 eax
  000ba	8d 4d d8	 lea	 ecx, DWORD PTR _pSend$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000c1	8b 02		 mov	 eax, DWORD PTR [edx]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCConfig:

; 1582 : }

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d2	33 cd		 xor	 ecx, ebp
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
?GCConfig@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::GCConfig
; Function compile flags: /Odtp /ZI /ZX
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?AddIndexPlayer@OfflineMode@@QAEFXZ		; OfflineMode::AddIndexPlayer
EXTRN	?gObjCount@@3HA:DWORD				; gObjCount
EXTRN	?gServerMaxUser@@3HA:DWORD			; gServerMaxUser
EXTRN	?gObjTotalUser@@3HA:DWORD			; gObjTotalUser
EXTRN	?gDisconnect@@3HA:DWORD				; gDisconnect
; Function compile flags: /Odtp /ZI /ZX
; File d:\projects\exteam6.3\source\gameserver\gameserver\offlinemode.cpp
;	COMDAT ?AddIndexPlayer@OfflineMode@@QAEFXZ
_TEXT	SEGMENT
_count$ = -12						; size = 4
_totalcount$ = -8					; size = 4
_this$ = -4						; size = 4
?AddIndexPlayer@OfflineMode@@QAEFXZ PROC		; OfflineMode::AddIndexPlayer, COMDAT
; _this$ = ecx

; 1587 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1588 : 	#if(ENABLE_OPTIMIZATION)
; 1589 : 	return g_Optimization.AddObjectOffmoder();
; 1590 : 	#endif
; 1591 : 
; 1592 : 	if(gDisconnect == 1)

  0000c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  00013	75 05		 jne	 SHORT $LN7@AddIndexPl

; 1593 : 	{
; 1594 : 		return -1;

  00015	83 c8 ff	 or	 eax, -1
  00018	eb 7a		 jmp	 SHORT $LN8@AddIndexPl
$LN7@AddIndexPl:

; 1595 : 	}
; 1596 : 
; 1597 : 	if(gObjTotalUser >= gServerMaxUser)

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjTotalUser@@3HA ; gObjTotalUser
  0001f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gServerMaxUser@@3HA ; gServerMaxUser
  00025	7c 05		 jl	 SHORT $LN6@AddIndexPl

; 1598 : 	{
; 1599 : 		return -1;

  00027	83 c8 ff	 or	 eax, -1
  0002a	eb 68		 jmp	 SHORT $LN8@AddIndexPl
$LN6@AddIndexPl:

; 1600 : 	}
; 1601 : 
; 1602 : 	int totalcount = 0;

  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _totalcount$[ebp], 0

; 1603 : 	int count = gObjCount;

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCount@@3HA ; gObjCount
  00038	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax
$LN5@AddIndexPl:

; 1604 : 	
; 1605 : 	while(true)

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	85 c0		 test	 eax, eax
  00042	74 4d		 je	 SHORT $LN4@AddIndexPl

; 1606 : 	{
; 1607 : 		if(gObj[count].Connected == PLAYER_EMPTY)

  00044	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  00047	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00058	75 08		 jne	 SHORT $LN3@AddIndexPl

; 1608 : 		{
; 1609 : 			return count;

  0005a	66 8b 45 f4	 mov	 ax, WORD PTR _count$[ebp]
  0005e	eb 34		 jmp	 SHORT $LN8@AddIndexPl

; 1610 : 			break;

  00060	eb 2f		 jmp	 SHORT $LN4@AddIndexPl
$LN3@AddIndexPl:

; 1611 : 		}
; 1612 : 
; 1613 : 		count++;

  00062	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 1614 : 
; 1615 : 		if(count >= OBJMAX)

  0006b	81 7d f4 98 3a
	00 00		 cmp	 DWORD PTR _count$[ebp], 15000 ; 00003a98H
  00072	7c 07		 jl	 SHORT $LN2@AddIndexPl

; 1616 : 		{
; 1617 : 			count = OBJ_STARTUSERINDEX;

  00074	c7 45 f4 b0 36
	00 00		 mov	 DWORD PTR _count$[ebp], 14000 ; 000036b0H
$LN2@AddIndexPl:

; 1618 : 		}
; 1619 : 
; 1620 : 		totalcount++;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _totalcount$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 f8	 mov	 DWORD PTR _totalcount$[ebp], eax

; 1621 : 
; 1622 : 		if(totalcount >= OBJMAXUSER)

  00084	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _totalcount$[ebp], 1000 ; 000003e8H
  0008b	7c 02		 jl	 SHORT $LN1@AddIndexPl

; 1623 : 		{
; 1624 : 			break;

  0008d	eb 02		 jmp	 SHORT $LN4@AddIndexPl
$LN1@AddIndexPl:

; 1625 : 		}
; 1626 : 	}

  0008f	eb aa		 jmp	 SHORT $LN5@AddIndexPl
$LN4@AddIndexPl:

; 1627 : 
; 1628 : 	return -1;

  00091	83 c8 ff	 or	 eax, -1
$LN8@AddIndexPl:

; 1629 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?AddIndexPlayer@OfflineMode@@QAEFXZ ENDP		; OfflineMode::AddIndexPlayer
_TEXT	ENDS
PUBLIC	?GDReqAllPlayer@OfflineMode@@QAEXXZ		; OfflineMode::GDReqAllPlayer
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?g_WaitOpen@@3_NA:BYTE				; g_WaitOpen
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?GDReqAllPlayer@OfflineMode@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 4
_this$ = -4						; size = 4
?GDReqAllPlayer@OfflineMode@@QAEXXZ PROC		; OfflineMode::GDReqAllPlayer, COMDAT
; _this$ = ecx

; 1632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1633 : 	if(g_WaitOpen == true)

  0000c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?g_WaitOpen@@3_NA ; g_WaitOpen
  00013	83 f8 01	 cmp	 eax, 1
  00016	75 02		 jne	 SHORT $LN2@GDReqAllPl

; 1634 : 	{
; 1635 : 		return;

  00018	eb 3d		 jmp	 SHORT $LN3@GDReqAllPl
$LN2@GDReqAllPl:

; 1636 : 	}
; 1637 : 
; 1638 : 	if(this->m_bLoadedDB == true)

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	0f b6 48 19	 movzx	 ecx, BYTE PTR [eax+25]
  00021	83 f9 01	 cmp	 ecx, 1
  00024	75 02		 jne	 SHORT $LN1@GDReqAllPl

; 1639 : 	{
; 1640 : 		return;

  00026	eb 2f		 jmp	 SHORT $LN3@GDReqAllPl
$LN1@GDReqAllPl:

; 1641 : 	}
; 1642 : 
; 1643 : 	this->m_bLoadedDB = true;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 40 19 01	 mov	 BYTE PTR [eax+25], 1

; 1644 : 
; 1645 : 	PBMSG_HEAD2 pMsg;
; 1646 : 	pMsg.set((LPBYTE)&pMsg, 0xEB, 0x11, sizeof(pMsg));

  0002f	6a 04		 push	 4
  00031	6a 11		 push	 17			; 00000011H
  00033	68 eb 00 00 00	 push	 235			; 000000ebH
  00038	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003b	50		 push	 eax
  0003c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003f	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 1647 : 	cDBSMng.Send((char*)&pMsg, pMsg.size);

  00044	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00048	50		 push	 eax
  00049	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004c	51		 push	 ecx
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00052	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqAllPl:

; 1648 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?GDReqAllPlayer@OfflineMode@@QAEXXZ ENDP		; OfflineMode::GDReqAllPlayer
_TEXT	ENDS
PUBLIC	??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z@4JA ; `OfflineMode::DGAnsAccauntPassword'::`2'::__LINE__Var
PUBLIC	?GDReqUpdateStatus@OfflineMode@@QAEXH@Z		; OfflineMode::GDReqUpdateStatus
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z ; OfflineMode::DGAnsAccauntPassword
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?wsJServerCli@@3VwsJoinServerCli@@A:BYTE	; wsJServerCli
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_strcpy:PROC
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?GJPUserClose@@YAXPAD@Z:PROC			; GJPUserClose
EXTRN	?BuxConvert@@YAXPADH@Z:PROC			; BuxConvert
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	_strncmp:PROC
EXTRN	_memcpy:PROC
EXTRN	?gObjAdd@@YAFIPADH@Z:PROC			; gObjAdd
;	COMDAT ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ DB 'join send '
	DB	': (%d)%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ DB 'error : %d %s '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z@4JA DD 0673H ; `OfflineMode::DGAnsAccauntPassword'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41?$AA@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41?$AA@ DB '127.0.0.1', 00H	; `string'
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ?DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z
_TEXT	SEGMENT
tv85 = -172						; size = 4
_spMsg$ = -104						; size = 44
_lpObj$ = -60						; size = 4
_sObj$233763 = -56					; size = 4
_i$233759 = -52						; size = 4
_psw$ = -48						; size = 21
_id$ = -24						; size = 11
_aIndex$ = -12						; size = 2
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Data$ = 8						; size = 4
?DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z PROC ; OfflineMode::DGAnsAccauntPassword, COMDAT
; _this$ = ecx

; 1651 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1652 : 	short aIndex = this->AddIndexPlayer();

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?AddIndexPlayer@OfflineMode@@QAEFXZ ; OfflineMode::AddIndexPlayer
  00021	66 89 45 f4	 mov	 WORD PTR _aIndex$[ebp], ax

; 1653 : 
; 1654 : 	if(aIndex == -1)

  00025	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00029	83 f8 ff	 cmp	 eax, -1
  0002c	75 05		 jne	 SHORT $LN16@DGAnsAccau

; 1655 : 	{
; 1656 : 		return;

  0002e	e9 fa 04 00 00	 jmp	 $LN17@DGAnsAccau
$LN16@DGAnsAccau:

; 1657 : 	}
; 1658 : 
; 1659 : 	//if(!gObjIsAccontConnect(aIndex, gObj[aIndex].AccountID))
; 1660 : 	//{
; 1661 : 	//	return;
; 1662 : 	//}
; 1663 : 
; 1664 : 	if(gObj[aIndex].Connected == PLAYER_PLAYING)

  00033	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00037	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00048	75 05		 jne	 SHORT $LN15@DGAnsAccau

; 1665 : 	{
; 1666 : 		return;

  0004a	e9 de 04 00 00	 jmp	 $LN17@DGAnsAccau
$LN15@DGAnsAccau:

; 1667 : 	}
; 1668 : 
; 1669 : 	if(gObjAdd(INVALID_SOCKET, "127.0.0.1", aIndex) == -1)

  0004f	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_09PFCHIMEP@127?40?40?41?$AA@
  00059	6a ff		 push	 -1
  0005b	e8 00 00 00 00	 call	 ?gObjAdd@@YAFIPADH@Z	; gObjAdd
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	0f bf c8	 movsx	 ecx, ax
  00066	83 f9 ff	 cmp	 ecx, -1
  00069	75 05		 jne	 SHORT $LN14@DGAnsAccau

; 1670 : 	{
; 1671 : 		return;

  0006b	e9 bd 04 00 00	 jmp	 $LN17@DGAnsAccau
$LN14@DGAnsAccau:

; 1672 : 	}
; 1673 : 
; 1674 : 	if(!OBJMAX_RANGE(aIndex))

  00070	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00074	85 c0		 test	 eax, eax
  00076	7d 0c		 jge	 SHORT $LN19@DGAnsAccau
  00078	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
  00082	eb 15		 jmp	 SHORT $LN20@DGAnsAccau
$LN19@DGAnsAccau:
  00084	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00088	33 d2		 xor	 edx, edx
  0008a	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00090	0f 9e c2	 setle	 dl
  00093	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], edx
$LN20@DGAnsAccau:
  00099	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv85[ebp], 0
  000a0	75 05		 jne	 SHORT $LN13@DGAnsAccau

; 1675 : 	{
; 1676 : 		return;

  000a2	e9 86 04 00 00	 jmp	 $LN17@DGAnsAccau
$LN13@DGAnsAccau:

; 1677 : 	}
; 1678 : 
; 1679 : 	char id[11] = { 0 };

  000a7	c6 45 e8 00	 mov	 BYTE PTR _id$[ebp], 0
  000ab	33 c0		 xor	 eax, eax
  000ad	89 45 e9	 mov	 DWORD PTR _id$[ebp+1], eax
  000b0	89 45 ed	 mov	 DWORD PTR _id$[ebp+5], eax
  000b3	66 89 45 f1	 mov	 WORD PTR _id$[ebp+9], ax

; 1680 : 	memcpy(id, Data->AccountID, sizeof(Data->AccountID));

  000b7	6a 0b		 push	 11			; 0000000bH
  000b9	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  000bc	83 c0 04	 add	 eax, 4
  000bf	50		 push	 eax
  000c0	8d 4d e8	 lea	 ecx, DWORD PTR _id$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 : 	memcpy(gObj[aIndex].AccountID, id, sizeof(Data->AccountID));

  000cc	6a 0b		 push	 11			; 0000000bH
  000ce	8d 45 e8	 lea	 eax, DWORD PTR _id$[ebp]
  000d1	50		 push	 eax
  000d2	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  000d6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  000dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _memcpy
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1682 : 	memcpy(gObj[aIndex].Name, Data->Name, sizeof(Data->Name));

  000ef	6a 0b		 push	 11			; 0000000bH
  000f1	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  000f4	83 c0 1a	 add	 eax, 26			; 0000001aH
  000f7	50		 push	 eax
  000f8	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  000fc	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00102	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00108	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _memcpy
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1683 : 
; 1684 : 	//#if(CUSTOM_PASSWORD==TRUE)
; 1685 : 	char psw[21] = { 0 };

  00115	c6 45 d0 00	 mov	 BYTE PTR _psw$[ebp], 0
  00119	33 c0		 xor	 eax, eax
  0011b	89 45 d1	 mov	 DWORD PTR _psw$[ebp+1], eax
  0011e	89 45 d5	 mov	 DWORD PTR _psw$[ebp+5], eax
  00121	89 45 d9	 mov	 DWORD PTR _psw$[ebp+9], eax
  00124	89 45 dd	 mov	 DWORD PTR _psw$[ebp+13], eax
  00127	89 45 e1	 mov	 DWORD PTR _psw$[ebp+17], eax

; 1686 : 	memcpy(psw, Data->Password, sizeof(Data->Password));

  0012a	6a 0b		 push	 11			; 0000000bH
  0012c	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  0012f	83 c0 0f	 add	 eax, 15			; 0000000fH
  00132	50		 push	 eax
  00133	8d 4d d0	 lea	 ecx, DWORD PTR _psw$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _memcpy
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1687 : 	memcpy(gObj[aIndex].Pass, psw, sizeof(psw));

  0013f	6a 15		 push	 21			; 00000015H
  00141	8d 45 d0	 lea	 eax, DWORD PTR _psw$[ebp]
  00144	50		 push	 eax
  00145	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00149	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0014f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00155	8d 84 0a 82 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+130]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1688 : 	gObj[aIndex].Pass[10] = 0;

  00165	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00169	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00175	c6 84 01 8c 00
	00 00 00	 mov	 BYTE PTR [ecx+eax+140], 0

; 1689 : 	//#endif
; 1690 : 
; 1691 : 	for(int i = OBJ_MAXMONSTER; i < OBJMAX; i++)

  0017d	c7 45 cc c8 32
	00 00		 mov	 DWORD PTR _i$233759[ebp], 13000 ; 000032c8H
  00184	eb 09		 jmp	 SHORT $LN12@DGAnsAccau
$LN11@DGAnsAccau:
  00186	8b 45 cc	 mov	 eax, DWORD PTR _i$233759[ebp]
  00189	83 c0 01	 add	 eax, 1
  0018c	89 45 cc	 mov	 DWORD PTR _i$233759[ebp], eax
$LN12@DGAnsAccau:
  0018f	81 7d cc 98 3a
	00 00		 cmp	 DWORD PTR _i$233759[ebp], 15000 ; 00003a98H
  00196	0f 8d a5 00 00
	00		 jge	 $LN10@DGAnsAccau

; 1692 : 	{
; 1693 : 		LPOBJ sObj = &gObj[i];

  0019c	8b 45 cc	 mov	 eax, DWORD PTR _i$233759[ebp]
  0019f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001a5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ab	89 45 c8	 mov	 DWORD PTR _sObj$233763[ebp], eax

; 1694 : 
; 1695 : 		if(sObj->Connected != PLAYER_PLAYING)

  001ae	8b 45 c8	 mov	 eax, DWORD PTR _sObj$233763[ebp]
  001b1	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  001b5	74 02		 je	 SHORT $LN9@DGAnsAccau

; 1696 : 		{
; 1697 : 			continue;

  001b7	eb cd		 jmp	 SHORT $LN11@DGAnsAccau
$LN9@DGAnsAccau:

; 1698 : 		}
; 1699 : 		
; 1700 : 		if(id[0] == sObj->AccountID[0] && psw[0] == sObj->Pass[0])

  001b9	0f be 45 e8	 movsx	 eax, BYTE PTR _id$[ebp]
  001bd	8b 4d c8	 mov	 ecx, DWORD PTR _sObj$233763[ebp]
  001c0	0f be 51 6c	 movsx	 edx, BYTE PTR [ecx+108]
  001c4	3b c2		 cmp	 eax, edx
  001c6	75 74		 jne	 SHORT $LN8@DGAnsAccau
  001c8	0f be 45 d0	 movsx	 eax, BYTE PTR _psw$[ebp]
  001cc	8b 4d c8	 mov	 ecx, DWORD PTR _sObj$233763[ebp]
  001cf	0f be 91 82 00
	00 00		 movsx	 edx, BYTE PTR [ecx+130]
  001d6	3b c2		 cmp	 eax, edx
  001d8	75 62		 jne	 SHORT $LN8@DGAnsAccau

; 1701 : 		{
; 1702 : 			if(!strncmp(id, sObj->AccountID, 10) && !strncmp(psw, sObj->Pass, 10))

  001da	6a 0a		 push	 10			; 0000000aH
  001dc	8b 45 c8	 mov	 eax, DWORD PTR _sObj$233763[ebp]
  001df	83 c0 6c	 add	 eax, 108		; 0000006cH
  001e2	50		 push	 eax
  001e3	8d 4d e8	 lea	 ecx, DWORD PTR _id$[ebp]
  001e6	51		 push	 ecx
  001e7	e8 00 00 00 00	 call	 _strncmp
  001ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ef	85 c0		 test	 eax, eax
  001f1	75 49		 jne	 SHORT $LN8@DGAnsAccau
  001f3	6a 0a		 push	 10			; 0000000aH
  001f5	8b 45 c8	 mov	 eax, DWORD PTR _sObj$233763[ebp]
  001f8	05 82 00 00 00	 add	 eax, 130		; 00000082H
  001fd	50		 push	 eax
  001fe	8d 4d d0	 lea	 ecx, DWORD PTR _psw$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 _strncmp
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020a	85 c0		 test	 eax, eax
  0020c	75 2e		 jne	 SHORT $LN8@DGAnsAccau

; 1703 : 			{
; 1704 : 				if(sObj->m_OfflineMode == false)

  0020e	8b 45 c8	 mov	 eax, DWORD PTR _sObj$233763[ebp]
  00211	0f b6 88 d4 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10452]
  00218	85 c9		 test	 ecx, ecx
  0021a	75 0e		 jne	 SHORT $LN6@DGAnsAccau

; 1705 : 				{
; 1706 : 					#if(OFFLINE_MODE_RESTORE)
; 1707 : 					g_OfflineMode.GDReqUpdateStatus(i);

  0021c	8b 45 cc	 mov	 eax, DWORD PTR _i$233759[ebp]
  0021f	50		 push	 eax
  00220	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  00225	e8 00 00 00 00	 call	 ?GDReqUpdateStatus@OfflineMode@@QAEXH@Z ; OfflineMode::GDReqUpdateStatus
$LN6@DGAnsAccau:

; 1708 : 					#endif
; 1709 : 				}
; 1710 : 				gObjDel(aIndex);

  0022a	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00234	83 c4 04	 add	 esp, 4

; 1711 : 				return;

  00237	e9 f1 02 00 00	 jmp	 $LN17@DGAnsAccau
$LN8@DGAnsAccau:

; 1712 : 			}
; 1713 : 		}
; 1714 : 	}

  0023c	e9 45 ff ff ff	 jmp	 $LN11@DGAnsAccau
$LN10@DGAnsAccau:

; 1715 : 
; 1716 : 	LPOBJ lpObj = &gObj[aIndex];

  00241	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00245	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0024b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00251	89 45 c4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 1717 : 
; 1718 : 	BuxConvert(Data->AccountID, MAX_ACCOUNT_LEN);

  00254	6a 0a		 push	 10			; 0000000aH
  00256	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  00259	83 c0 04	 add	 eax, 4
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  00262	83 c4 08	 add	 esp, 8

; 1719 : 	BuxConvert(Data->Password, MAX_ACCOUNT_LEN);

  00265	6a 0a		 push	 10			; 0000000aH
  00267	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  0026a	83 c0 0f	 add	 eax, 15			; 0000000fH
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  00273	83 c4 08	 add	 esp, 8

; 1720 : 
; 1721 : 	GJPUserClose(id);

  00276	8d 45 e8	 lea	 eax, DWORD PTR _id$[ebp]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAD@Z	; GJPUserClose
  0027f	83 c4 04	 add	 esp, 4

; 1722 : 
; 1723 : 	if(gObj[aIndex].Connected != PLAYER_CONNECTED)

  00282	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00286	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00292	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00297	74 34		 je	 SHORT $LN5@DGAnsAccau

; 1724 : 	{
; 1725 : 		LogAdd(lMsg.Get(MSGGET(1, 218)), aIndex, id);

  00299	8d 45 e8	 lea	 eax, DWORD PTR _id$[ebp]
  0029c	50		 push	 eax
  0029d	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  002a1	51		 push	 ecx
  002a2	68 da 01 00 00	 push	 474			; 000001daH
  002a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ac	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002b1	50		 push	 eax
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1726 : 		CloseClient(aIndex);

  002bb	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002c5	83 c4 04	 add	 esp, 4

; 1727 : 		return;

  002c8	e9 60 02 00 00	 jmp	 $LN17@DGAnsAccau
$LN5@DGAnsAccau:

; 1728 : 	}
; 1729 : 
; 1730 : 	if(gObj[aIndex].LoginMsgSnd != FALSE)

  002cd	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002d1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002dd	0f be 54 01 08	 movsx	 edx, BYTE PTR [ecx+eax+8]
  002e2	85 d2		 test	 edx, edx
  002e4	0f 84 8a 00 00
	00		 je	 $LN4@DGAnsAccau

; 1731 : 	{
; 1732 : 		if(gObj[aIndex].LoginMsgSnd == TRUE)

  002ea	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002ee	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fa	0f be 54 01 08	 movsx	 edx, BYTE PTR [ecx+eax+8]
  002ff	83 fa 01	 cmp	 edx, 1
  00302	75 39		 jne	 SHORT $LN3@DGAnsAccau

; 1733 : 		{
; 1734 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  00304	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00308	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00314	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00318	52		 push	 edx
  00319	8d 45 e8	 lea	 eax, DWORD PTR _id$[ebp]
  0031c	50		 push	 eax
  0031d	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00321	51		 push	 ecx
  00322	68 db 01 00 00	 push	 475			; 000001dbH
  00327	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0032c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00331	50		 push	 eax
  00332	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00338	83 c4 10	 add	 esp, 16			; 00000010H

; 1735 : 		}
; 1736 : 		else

  0033b	eb 32		 jmp	 SHORT $LN2@DGAnsAccau
$LN3@DGAnsAccau:

; 1737 : 		{
; 1738 : 			LogAdd("error : %d %s %d", gObj[aIndex].LoginMsgSnd, __FILE__, __LINE__);

  0033d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z@4JA
  00342	83 c0 57	 add	 eax, 87			; 00000057H
  00345	50		 push	 eax
  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@
  0034b	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0034f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00355	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035b	0f be 44 0a 08	 movsx	 eax, BYTE PTR [edx+ecx+8]
  00360	50		 push	 eax
  00361	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0036c	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@DGAnsAccau:

; 1739 : 		}
; 1740 : 		return;

  0036f	e9 b9 01 00 00	 jmp	 $LN17@DGAnsAccau
$LN4@DGAnsAccau:

; 1741 : 	}
; 1742 : 
; 1743 : 	if(lpObj->Connected >= PLAYER_LOGGED)

  00374	8b 45 c4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00377	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0037b	7c 05		 jl	 SHORT $LN1@DGAnsAccau

; 1744 : 	{
; 1745 : 		return;

  0037d	e9 ab 01 00 00	 jmp	 $LN17@DGAnsAccau
$LN1@DGAnsAccau:

; 1746 : 	}
; 1747 : 
; 1748 : 	SDHP_IDPASS spMsg;
; 1749 : 
; 1750 : 	PHeadSetB((LPBYTE)&spMsg, 0x01, sizeof(spMsg));

  00382	6a 2c		 push	 44			; 0000002cH
  00384	6a 01		 push	 1
  00386	8d 45 98	 lea	 eax, DWORD PTR _spMsg$[ebp]
  00389	50		 push	 eax
  0038a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0038f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1751 : 	spMsg.Number = aIndex;

  00392	66 8b 45 f4	 mov	 ax, WORD PTR _aIndex$[ebp]
  00396	66 89 45 b0	 mov	 WORD PTR _spMsg$[ebp+24], ax

; 1752 : 	memcpy(spMsg.Id, Data->AccountID, sizeof(spMsg.Id));

  0039a	6a 0a		 push	 10			; 0000000aH
  0039c	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  0039f	83 c0 04	 add	 eax, 4
  003a2	50		 push	 eax
  003a3	8d 4d 9b	 lea	 ecx, DWORD PTR _spMsg$[ebp+3]
  003a6	51		 push	 ecx
  003a7	e8 00 00 00 00	 call	 _memcpy
  003ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1753 : 	memcpy(spMsg.Pass, Data->Password, sizeof(spMsg.Pass));

  003af	6a 0a		 push	 10			; 0000000aH
  003b1	8b 45 08	 mov	 eax, DWORD PTR _Data$[ebp]
  003b4	83 c0 0f	 add	 eax, 15			; 0000000fH
  003b7	50		 push	 eax
  003b8	8d 4d a5	 lea	 ecx, DWORD PTR _spMsg$[ebp+13]
  003bb	51		 push	 ecx
  003bc	e8 00 00 00 00	 call	 _memcpy
  003c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1754 : 	strcpy(spMsg.IpAddress, gObj[aIndex].Ip_addr);

  003c4	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  003c8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d4	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  003d8	52		 push	 edx
  003d9	8d 45 b2	 lea	 eax, DWORD PTR _spMsg$[ebp+26]
  003dc	50		 push	 eax
  003dd	e8 00 00 00 00	 call	 _strcpy
  003e2	83 c4 08	 add	 esp, 8

; 1755 : 	gObj[aIndex].CheckTick = Data->TickCount;

  003e5	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  003e9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f5	8b 55 08	 mov	 edx, DWORD PTR _Data$[ebp]
  003f8	8b 52 28	 mov	 edx, DWORD PTR [edx+40]
  003fb	89 54 01 40	 mov	 DWORD PTR [ecx+eax+64], edx

; 1756 : 	gObj[aIndex].CheckTick2 = GetTickCount();

  003ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00405	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00409	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0040f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00415	89 44 0a 48	 mov	 DWORD PTR [edx+ecx+72], eax

; 1757 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00419	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0041f	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00423	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00429	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042f	89 44 0a 3c	 mov	 DWORD PTR [edx+ecx+60], eax

; 1758 : 	gObj[aIndex].CheckSpeedHack = true;

  00433	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00437	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0043d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00443	c6 44 01 44 01	 mov	 BYTE PTR [ecx+eax+68], 1

; 1759 : 	gObj[aIndex].LoginMsgSnd = 1;

  00448	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0044c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00452	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00458	c6 44 01 08 01	 mov	 BYTE PTR [ecx+eax+8], 1

; 1760 : 	gObj[aIndex].LoginMsgCount = 1;

  0045d	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00461	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00467	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046d	c6 44 01 09 01	 mov	 BYTE PTR [ecx+eax+9], 1

; 1761 : 	gObj[aIndex].m_cAccountItemBlock = 0;

  00472	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00476	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0047c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00482	c6 84 01 14 02
	00 00 00	 mov	 BYTE PTR [ecx+eax+532], 0

; 1762 : 	gObj[aIndex].m_ReOfflineMode = true;

  0048a	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0048e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00494	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0049a	c6 84 01 ec 28
	00 00 01	 mov	 BYTE PTR [ecx+eax+10476], 1

; 1763 : 	gObj[aIndex].ukn_30 = 0;

  004a2	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  004a6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b2	c7 44 01 30 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+48], 0

; 1764 : 
; 1765 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  004ba	0f b6 45 99	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  004be	50		 push	 eax
  004bf	8d 4d 98	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  004c2	51		 push	 ecx
  004c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  004c8	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 1766 : 	LogAddTD("join send : (%d)%s", aIndex, gObj[aIndex].AccountID);

  004cd	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  004d1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004dd	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  004e1	52		 push	 edx
  004e2	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  004e6	50		 push	 eax
  004e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
  004ec	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1767 : 	
; 1768 : 	lpObj->m_bMapSvrMoveReq = false;

  004f5	8b 45 c4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f8	c6 80 e5 1b 00
	00 00		 mov	 BYTE PTR [eax+7141], 0

; 1769 : 	lpObj->m_sPrevMapSvrCode = -1; 

  004ff	83 c8 ff	 or	 eax, -1
  00502	8b 4d c4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00505	66 89 81 ec 1b
	00 00		 mov	 WORD PTR [ecx+7148], ax

; 1770 : 	lpObj->m_sDestMapNumber = -1;

  0050c	83 c8 ff	 or	 eax, -1
  0050f	8b 4d c4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00512	66 89 81 ee 1b
	00 00		 mov	 WORD PTR [ecx+7150], ax

; 1771 : 	lpObj->m_btDestX = 0;

  00519	8b 45 c4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051c	c6 80 f0 1b 00
	00 00		 mov	 BYTE PTR [eax+7152], 0

; 1772 : 	lpObj->m_btDestY = 0;

  00523	8b 45 c4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00526	c6 80 f1 1b 00
	00 00		 mov	 BYTE PTR [eax+7153], 0
$LN17@DGAnsAccau:

; 1773 : }

  0052d	5f		 pop	 edi
  0052e	5e		 pop	 esi
  0052f	5b		 pop	 ebx
  00530	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00533	33 cd		 xor	 ecx, ebp
  00535	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053a	8b e5		 mov	 esp, ebp
  0053c	5d		 pop	 ebp
  0053d	c2 04 00	 ret	 4
?DGAnsAccauntPassword@OfflineMode@@QAEXPAUPMSG_DGANS_OFFMODE_START@@@Z ENDP ; OfflineMode::DGAnsAccauntPassword
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqOffCharacter@OfflineMode@@QAEXH@Z		; OfflineMode::GDReqOffCharacter
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?GDReqOffCharacter@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv67 = -108						; size = 4
_pMsg$ = -40						; size = 28
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqOffCharacter@OfflineMode@@QAEXH@Z PROC		; OfflineMode::GDReqOffCharacter, COMDAT
; _this$ = ecx

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1777 : 	if(!OBJMAX_RANGE(aIndex))

  00016	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $LN4@GDReqOffCh
  0001c	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00023	eb 0f		 jmp	 SHORT $LN5@GDReqOffCh
$LN4@GDReqOffCh:
  00025	33 c0		 xor	 eax, eax
  00027	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0002e	0f 9e c0	 setle	 al
  00031	89 45 94	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GDReqOffCh:
  00034	83 7d 94 00	 cmp	 DWORD PTR tv67[ebp], 0
  00038	75 05		 jne	 SHORT $LN1@GDReqOffCh

; 1778 : 	{
; 1779 : 		return;

  0003a	e9 95 00 00 00	 jmp	 $LN2@GDReqOffCh
$LN1@GDReqOffCh:

; 1780 : 	}
; 1781 : 
; 1782 : 	LPOBJ lpUser = &gObj[aIndex];

  0003f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00042	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00048	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004e	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1783 : 
; 1784 : 	lpUser->m_ReOfflineMode = false;

  00051	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00054	c6 80 ec 28 00
	00 00		 mov	 BYTE PTR [eax+10476], 0

; 1785 : 
; 1786 : 	PMSG_GDREQ_OFFMODE_CHAR pMsg = { 0 };

  0005b	c6 45 d8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0005f	33 c0		 xor	 eax, eax
  00061	89 45 d9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00064	89 45 dd	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  00067	89 45 e1	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  0006a	89 45 e5	 mov	 DWORD PTR _pMsg$[ebp+13], eax
  0006d	89 45 e9	 mov	 DWORD PTR _pMsg$[ebp+17], eax
  00070	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+21], eax
  00073	66 89 45 f1	 mov	 WORD PTR _pMsg$[ebp+25], ax
  00077	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+27], al

; 1787 : 	pMsg.h.set((LPBYTE)&pMsg, 0xEB, 0x12, sizeof(pMsg));

  0007a	6a 1c		 push	 28			; 0000001cH
  0007c	6a 12		 push	 18			; 00000012H
  0007e	68 eb 00 00 00	 push	 235			; 000000ebH
  00083	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00086	50		 push	 eax
  00087	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0008a	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 1788 : 	memcpy(pMsg.AccountID, lpUser->AccountID, sizeof(pMsg.AccountID));

  0008f	6a 0b		 push	 11			; 0000000bH
  00091	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00094	83 c0 6c	 add	 eax, 108		; 0000006cH
  00097	50		 push	 eax
  00098	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1789 : 	memcpy(pMsg.Name, lpUser->Name, sizeof(pMsg.Name));

  000a4	6a 0b		 push	 11			; 0000000bH
  000a6	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000a9	83 c0 77	 add	 eax, 119		; 00000077H
  000ac	50		 push	 eax
  000ad	8d 4d e7	 lea	 ecx, DWORD PTR _pMsg$[ebp+15]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _memcpy
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1790 : 	pMsg.Number = aIndex;

  000b9	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  000bd	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+26], ax

; 1791 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  000c1	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000c5	50		 push	 eax
  000c6	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000c9	51		 push	 ecx
  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000cf	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDReqOffCh:

; 1792 : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 04 00	 ret	 4
?GDReqOffCharacter@OfflineMode@@QAEXH@Z ENDP		; OfflineMode::GDReqOffCharacter
_TEXT	ENDS
PUBLIC	??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ ; `string'
PUBLIC	??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ ; `string'
PUBLIC	??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA ; `OfflineMode::DGAnsOffCharacter'::`2'::__LINE__Var
PUBLIC	??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@ ; `string'
PUBLIC	??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z ; OfflineMode::DGAnsOffCharacter
EXTRN	?GDStatusUpdate@SpotReturn@@QAEXHE@Z:PROC	; SpotReturn::GDStatusUpdate
EXTRN	?g_SpotReturn@@3VSpotReturn@@A:QWORD		; g_SpotReturn
EXTRN	?RestoreParty@PartyClass@@QAEXH@Z:PROC		; PartyClass::RestoreParty
EXTRN	?UserConnect@PremiumSystemEx@@QAEXH@Z:PROC	; PremiumSystemEx::UserConnect
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?DGGuildMemberInfoRequest@@YAXH@Z:PROC		; DGGuildMemberInfoRequest
EXTRN	?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestUtil::Quest3rdRequestInfo
EXTRN	?g_QuestUtil@@3VCQuestUtil@@A:DWORD		; g_QuestUtil
EXTRN	?GDReqMasterLevelInfo@CMasterLevelSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::GDReqMasterLevelInfo
EXTRN	?DB_Load@CExGDManager@@QAEXH@Z:PROC		; CExGDManager::DB_Load
EXTRN	?g_ExGDManager@@3VCExGDManager@@A:BYTE		; g_ExGDManager
EXTRN	?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestInfo::QuestInfoSave
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
EXTRN	?GJReqMapSvrMove@@YAXHGGEE@Z:PROC		; GJReqMapSvrMove
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z:PROC ; CMapServerManager::CheckMoveMapSvr
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?MapNumberCheck@@YAHH@Z:PROC			; MapNumberCheck
EXTRN	?gObjSetCharacter@@YAHPAEH@Z:PROC		; gObjSetCharacter
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
;	COMDAT ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
CONST	SEGMENT
??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ DB '[MapSe'
	DB	'rverMng] Request to Move Map Server : (%d) - [%s][%s] (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
CONST	SEGMENT
??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ DB '[MapSe'
	DB	'rverMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s]['
	DB	'%s] (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@
CONST	SEGMENT
??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@ DB '['
	DB	' ZEN MODIFY ] [%s][%s] %d -> 0', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA DD 0703H ; `OfflineMode::DGAnsOffCharacter'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@
CONST	SEGMENT
??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@ DB '[A'
	DB	'nti-HACK][JGGetCharacterInfo] Attempted Character-Copy by dou'
	DB	'ble logging [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@
CONST	SEGMENT
??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@ DB 'error-L1 '
	DB	': Load Block Character infomation', 00H	; `string'
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ?DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z
_TEXT	SEGMENT
tv70 = -132						; size = 4
_NextExperience$ = -64					; size = 8
_Experience$ = -56					; size = 8
_wGameServerCode$233819 = -48				; size = 2
_lpObj$ = -44						; size = 4
_i$233801 = -40						; size = 4
_szName$ = -36						; size = 11
_szAccountID$ = -24					; size = 11
_aIndex$ = -12						; size = 2
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z PROC ; OfflineMode::DGAnsOffCharacter, COMDAT
; _this$ = ecx

; 1795 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1796 : 	short aIndex = lpMsg->Number;

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00020	66 89 4d f4	 mov	 WORD PTR _aIndex$[ebp], cx

; 1797 : 
; 1798 : 	if(!OBJMAX_RANGE(aIndex))

  00024	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00028	85 c0		 test	 eax, eax
  0002a	7d 0c		 jge	 SHORT $LN23@DGAnsOffCh
  0002c	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
  00036	eb 15		 jmp	 SHORT $LN24@DGAnsOffCh
$LN23@DGAnsOffCh:
  00038	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0003c	33 d2		 xor	 edx, edx
  0003e	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00044	0f 9e c2	 setle	 dl
  00047	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
$LN24@DGAnsOffCh:
  0004d	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  00054	75 05		 jne	 SHORT $LN20@DGAnsOffCh

; 1799 : 	{
; 1800 : 		return;

  00056	e9 e0 05 00 00	 jmp	 $LN21@DGAnsOffCh
$LN20@DGAnsOffCh:

; 1801 : 	}
; 1802 : 
; 1803 : 	char szAccountID[11] = { 0 };

  0005b	c6 45 e8 00	 mov	 BYTE PTR _szAccountID$[ebp], 0
  0005f	33 c0		 xor	 eax, eax
  00061	89 45 e9	 mov	 DWORD PTR _szAccountID$[ebp+1], eax
  00064	89 45 ed	 mov	 DWORD PTR _szAccountID$[ebp+5], eax
  00067	66 89 45 f1	 mov	 WORD PTR _szAccountID$[ebp+9], ax

; 1804 : 	char szName[11] = { 0 };

  0006b	c6 45 dc 00	 mov	 BYTE PTR _szName$[ebp], 0
  0006f	33 c0		 xor	 eax, eax
  00071	89 45 dd	 mov	 DWORD PTR _szName$[ebp+1], eax
  00074	89 45 e1	 mov	 DWORD PTR _szName$[ebp+5], eax
  00077	66 89 45 e5	 mov	 WORD PTR _szName$[ebp+9], ax

; 1805 : 
; 1806 : 	memcpy(szAccountID, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  0007b	6a 0a		 push	 10			; 0000000aH
  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00080	83 c0 08	 add	 eax, 8
  00083	50		 push	 eax
  00084	8d 4d e8	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1807 : 	memcpy(szName, lpMsg->Name, MAX_ACCOUNT_LEN);

  00090	6a 0a		 push	 10			; 0000000aH
  00092	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00095	83 c0 12	 add	 eax, 18			; 00000012H
  00098	50		 push	 eax
  00099	8d 4d dc	 lea	 ecx, DWORD PTR _szName$[ebp]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _memcpy
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1808 : 
; 1809 : 	if(gObjIsAccontConnect(aIndex, szAccountID) == FALSE)

  000a5	8d 45 e8	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  000a8	50		 push	 eax
  000a9	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  000b3	83 c4 08	 add	 esp, 8
  000b6	85 c0		 test	 eax, eax
  000b8	75 31		 jne	 SHORT $LN19@DGAnsOffCh

; 1810 : 	{
; 1811 : 		LogAddC(2, lMsg.Get(MSGGET(1, 170)), szAccountID);

  000ba	8d 45 e8	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  000bd	50		 push	 eax
  000be	68 aa 01 00 00	 push	 426			; 000001aaH
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000cd	50		 push	 eax
  000ce	6a 02		 push	 2
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1812 : 		CloseClient(aIndex);

  000d9	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000e3	83 c4 04	 add	 esp, 4

; 1813 : 		return;

  000e6	e9 50 05 00 00	 jmp	 $LN21@DGAnsOffCh
$LN19@DGAnsOffCh:

; 1814 : 	}
; 1815 : 
; 1816 : 	if(lpMsg->result == false)

  000eb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ee	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000f2	85 c9		 test	 ecx, ecx
  000f4	75 46		 jne	 SHORT $LN18@DGAnsOffCh

; 1817 : 	{
; 1818 : 		LogAddC(2, lMsg.Get(MSGGET(1, 171)), szName, gObj[aIndex].AccountID);

  000f6	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000fa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00106	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0010a	52		 push	 edx
  0010b	8d 45 dc	 lea	 eax, DWORD PTR _szName$[ebp]
  0010e	50		 push	 eax
  0010f	68 ab 01 00 00	 push	 427			; 000001abH
  00114	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00119	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0011e	50		 push	 eax
  0011f	6a 02		 push	 2
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00127	83 c4 10	 add	 esp, 16			; 00000010H

; 1819 : 		CloseClient(aIndex);

  0012a	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00134	83 c4 04	 add	 esp, 4

; 1820 : 		return;

  00137	e9 ff 04 00 00	 jmp	 $LN21@DGAnsOffCh
$LN18@DGAnsOffCh:

; 1821 : 	}
; 1822 : 
; 1823 : 	if((lpMsg->CtlCode&1) != 0)

  0013c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013f	0f b6 88 d4 10
	00 00		 movzx	 ecx, BYTE PTR [eax+4308]
  00146	83 e1 01	 and	 ecx, 1
  00149	74 3b		 je	 SHORT $LN17@DGAnsOffCh

; 1824 : 	{
; 1825 : 		LogAddC(2, "error-L1 : Load Block Character infomation", szName, gObj[aIndex].AccountID);

  0014b	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0014f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015b	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0015f	52		 push	 edx
  00160	8d 45 dc	 lea	 eax, DWORD PTR _szName$[ebp]
  00163	50		 push	 eax
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@
  00169	6a 02		 push	 2
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00171	83 c4 10	 add	 esp, 16			; 00000010H

; 1826 : 		CloseClient(aIndex);

  00174	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0017e	83 c4 04	 add	 esp, 4

; 1827 : 		return;

  00181	e9 b5 04 00 00	 jmp	 $LN21@DGAnsOffCh
$LN17@DGAnsOffCh:

; 1828 : 	}
; 1829 : 
; 1830 : 	for(int i = OBJ_STARTUSERINDEX; i < OBJMAX; i++)

  00186	c7 45 d8 b0 36
	00 00		 mov	 DWORD PTR _i$233801[ebp], 14000 ; 000036b0H
  0018d	eb 09		 jmp	 SHORT $LN16@DGAnsOffCh
$LN15@DGAnsOffCh:
  0018f	8b 45 d8	 mov	 eax, DWORD PTR _i$233801[ebp]
  00192	83 c0 01	 add	 eax, 1
  00195	89 45 d8	 mov	 DWORD PTR _i$233801[ebp], eax
$LN16@DGAnsOffCh:
  00198	81 7d d8 98 3a
	00 00		 cmp	 DWORD PTR _i$233801[ebp], 15000 ; 00003a98H
  0019f	0f 8d c1 00 00
	00		 jge	 $LN14@DGAnsOffCh

; 1831 : 	{
; 1832 : 		if(gObj[i].Connected == PLAYER_PLAYING)

  001a5	8b 45 d8	 mov	 eax, DWORD PTR _i$233801[ebp]
  001a8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b4	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  001b9	0f 85 a2 00 00
	00		 jne	 $LN13@DGAnsOffCh

; 1833 : 		{
; 1834 : 			if(gObj[i].Type == OBJ_USER)

  001bf	8b 45 d8	 mov	 eax, DWORD PTR _i$233801[ebp]
  001c2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ce	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  001d3	83 fa 01	 cmp	 edx, 1
  001d6	0f 85 85 00 00
	00		 jne	 $LN13@DGAnsOffCh

; 1835 : 			{
; 1836 : 				if(!strncmp(szName, gObj[i].Name, MAX_ACCOUNT_LEN) || !strncmp(szAccountID, gObj[i].AccountID, MAX_ACCOUNT_LEN))

  001dc	6a 0a		 push	 10			; 0000000aH
  001de	8b 45 d8	 mov	 eax, DWORD PTR _i$233801[ebp]
  001e1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ed	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  001f1	52		 push	 edx
  001f2	8d 45 dc	 lea	 eax, DWORD PTR _szName$[ebp]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 _strncmp
  001fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fe	85 c0		 test	 eax, eax
  00200	74 26		 je	 SHORT $LN10@DGAnsOffCh
  00202	6a 0a		 push	 10			; 0000000aH
  00204	8b 45 d8	 mov	 eax, DWORD PTR _i$233801[ebp]
  00207	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00213	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  00217	52		 push	 edx
  00218	8d 45 e8	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 _strncmp
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
  00224	85 c0		 test	 eax, eax
  00226	75 39		 jne	 SHORT $LN13@DGAnsOffCh
$LN10@DGAnsOffCh:

; 1837 : 				{
; 1838 : 					LogAddTD("[Anti-HACK][JGGetCharacterInfo] Attempted Character-Copy by double logging [%s][%s]",	szName, gObj[aIndex].AccountID);

  00228	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0022c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00232	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00238	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0023c	52		 push	 edx
  0023d	8d 45 dc	 lea	 eax, DWORD PTR _szName$[ebp]
  00240	50		 push	 eax
  00241	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1839 : 					CloseClient(aIndex);

  0024f	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00259	83 c4 04	 add	 esp, 4

; 1840 : 					return;

  0025c	e9 da 03 00 00	 jmp	 $LN21@DGAnsOffCh
$LN13@DGAnsOffCh:

; 1841 : 				}
; 1842 : 			}
; 1843 : 		}
; 1844 : 	}

  00261	e9 29 ff ff ff	 jmp	 $LN15@DGAnsOffCh
$LN14@DGAnsOffCh:

; 1845 : 
; 1846 : 	gObj[aIndex].Connected = PLAYER_LOGGED;	//!!!

  00266	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0026a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00276	c7 44 01 04 02
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 2

; 1847 : 
; 1848 : 	if(gObjSetCharacter((LPBYTE)lpMsg, aIndex) == FALSE)

  0027e	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00282	50		 push	 eax
  00283	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00286	51		 push	 ecx
  00287	e8 00 00 00 00	 call	 ?gObjSetCharacter@@YAHPAEH@Z ; gObjSetCharacter
  0028c	83 c4 08	 add	 esp, 8
  0028f	85 c0		 test	 eax, eax
  00291	75 31		 jne	 SHORT $LN9@DGAnsOffCh

; 1849 : 	{
; 1850 : 		LogAddC(2, lMsg.Get(MSGGET(1, 172)), szName);

  00293	8d 45 dc	 lea	 eax, DWORD PTR _szName$[ebp]
  00296	50		 push	 eax
  00297	68 ac 01 00 00	 push	 428			; 000001acH
  0029c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002a1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002a6	50		 push	 eax
  002a7	6a 02		 push	 2
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1851 : 		CloseClient(aIndex);

  002b2	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002bc	83 c4 04	 add	 esp, 4

; 1852 : 		return;

  002bf	e9 77 03 00 00	 jmp	 $LN21@DGAnsOffCh
$LN9@DGAnsOffCh:

; 1853 : 	}
; 1854 : 
; 1855 : 	gObj[aIndex].CheckSumTime = 0;//!!!

  002c4	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002c8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d4	c7 44 01 64 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+100], 0

; 1856 : 
; 1857 : 	gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  002dc	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002e0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002e6	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  002ea	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  002f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f6	8b 84 02 58 01
	00 00		 mov	 eax, DWORD PTR [edx+eax+344]
  002fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00303	03 84 0a 5c 01
	00 00		 add	 eax, DWORD PTR [edx+ecx+348]
  0030a	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0030e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00314	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031a	89 84 0a 54 01
	00 00		 mov	 DWORD PTR [edx+ecx+340], eax

; 1858 : 
; 1859 : 	LPOBJ lpObj = &gObj[aIndex];

  00321	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00325	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0032b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00331	89 45 d4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 1860 : 
; 1861 : 	if(gObj[aIndex].m_Index != aIndex)

  00334	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00338	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0033e	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00342	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00348	39 0c 02	 cmp	 DWORD PTR [edx+eax], ecx
  0034b	74 3b		 je	 SHORT $LN8@DGAnsOffCh

; 1862 : 	{
; 1863 : 		LogAddC(2, lMsg.Get(MSGGET(1, 173)), __FILE__, __LINE__);

  0034d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
  00352	83 c0 44	 add	 eax, 68			; 00000044H
  00355	50		 push	 eax
  00356	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@
  0035b	68 ad 01 00 00	 push	 429			; 000001adH
  00360	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00365	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0036a	50		 push	 eax
  0036b	6a 02		 push	 2
  0036d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00373	83 c4 10	 add	 esp, 16			; 00000010H

; 1864 : 		CloseClient(aIndex);

  00376	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00380	83 c4 04	 add	 esp, 4

; 1865 : 		return;

  00383	e9 b3 02 00 00	 jmp	 $LN21@DGAnsOffCh
$LN8@DGAnsOffCh:

; 1866 : 	}
; 1867 : 
; 1868 : 	if(lpObj->Money < 0)

  00388	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038b	83 b8 f0 00 00
	00 00		 cmp	 DWORD PTR [eax+240], 0
  00392	7d 3f		 jge	 SHORT $LN7@DGAnsOffCh

; 1869 : 	{
; 1870 : 		LogAddC(2, "[ ZEN MODIFY ] [%s][%s] %d -> 0", szName, gObj[aIndex].AccountID, lpObj->Money);

  00394	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00397	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0039d	51		 push	 ecx
  0039e	0f bf 55 f4	 movsx	 edx, WORD PTR _aIndex$[ebp]
  003a2	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  003a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ad	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  003b1	51		 push	 ecx
  003b2	8d 55 dc	 lea	 edx, DWORD PTR _szName$[ebp]
  003b5	52		 push	 edx
  003b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@
  003bb	6a 02		 push	 2
  003bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  003c3	83 c4 14	 add	 esp, 20			; 00000014H

; 1871 : 		lpObj->Money = 0;

  003c6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c9	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0
$LN7@DGAnsOffCh:

; 1872 : 	}
; 1873 : 	
; 1874 : 	if(lpObj->m_bMapSvrMoveReq == false)	//???

  003d3	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d6	0f b6 88 e5 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+7141]
  003dd	85 c9		 test	 ecx, ecx
  003df	0f 85 25 01 00
	00		 jne	 $LN6@DGAnsOffCh

; 1875 : 	{
; 1876 : 		if(MapNumberCheck(lpObj->MapNumber) == FALSE)

  003e5	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e8	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  003ef	51		 push	 ecx
  003f0	e8 00 00 00 00	 call	 ?MapNumberCheck@@YAHH@Z	; MapNumberCheck
  003f5	83 c4 04	 add	 esp, 4
  003f8	85 c0		 test	 eax, eax
  003fa	75 2e		 jne	 SHORT $LN5@DGAnsOffCh

; 1877 : 		{
; 1878 : 			LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  003fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
  00401	83 c0 53	 add	 eax, 83			; 00000053H
  00404	50		 push	 eax
  00405	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KPFCBBFP@d?3?2projects?2exteam6?43?2source?2gam@
  0040a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  0040f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00415	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1879 : 			CloseClient(aIndex);

  00418	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0041c	50		 push	 eax
  0041d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00422	83 c4 04	 add	 esp, 4

; 1880 : 			return;

  00425	e9 11 02 00 00	 jmp	 $LN21@DGAnsOffCh
$LN5@DGAnsOffCh:

; 1881 : 		}
; 1882 : 
; 1883 : 		short wGameServerCode = g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->MapNumber, lpObj->m_sPrevMapSvrCode);

  0042a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0042d	0f b7 88 ec 1b
	00 00		 movzx	 ecx, WORD PTR [eax+7148]
  00434	51		 push	 ecx
  00435	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00438	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0043f	50		 push	 eax
  00440	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00443	8b 11		 mov	 edx, DWORD PTR [ecx]
  00445	52		 push	 edx
  00446	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  0044b	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  00450	66 89 45 d0	 mov	 WORD PTR _wGameServerCode$233819[ebp], ax

; 1884 : 
; 1885 : 		if(wGameServerCode != gGameServerCode)

  00454	0f bf 45 d0	 movsx	 eax, WORD PTR _wGameServerCode$233819[ebp]
  00458	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0045f	3b c1		 cmp	 eax, ecx
  00461	0f 84 a3 00 00
	00		 je	 $LN6@DGAnsOffCh

; 1886 : 		{
; 1887 : 			if(wGameServerCode == -1)

  00467	0f bf 45 d0	 movsx	 eax, WORD PTR _wGameServerCode$233819[ebp]
  0046b	83 f8 ff	 cmp	 eax, -1
  0046e	75 36		 jne	 SHORT $LN3@DGAnsOffCh

; 1888 : 			{
; 1889 : 				LogAddC(2,"[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)", lpObj->AccountID, lpObj->Name, lpObj->m_Index);

  00470	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00473	8b 08		 mov	 ecx, DWORD PTR [eax]
  00475	51		 push	 ecx
  00476	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00479	83 c2 77	 add	 edx, 119		; 00000077H
  0047c	52		 push	 edx
  0047d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00480	83 c0 6c	 add	 eax, 108		; 0000006cH
  00483	50		 push	 eax
  00484	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
  00489	6a 02		 push	 2
  0048b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00491	83 c4 14	 add	 esp, 20			; 00000014H

; 1890 : 				CloseClient(aIndex);

  00494	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00498	50		 push	 eax
  00499	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0049e	83 c4 04	 add	 esp, 4

; 1891 : 				return;

  004a1	e9 95 01 00 00	 jmp	 $LN21@DGAnsOffCh
$LN3@DGAnsOffCh:

; 1892 : 			}
; 1893 : 
; 1894 : 			GJReqMapSvrMove(lpObj->m_Index, wGameServerCode, lpObj->MapNumber, lpObj->X, lpObj->Y);

  004a6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a9	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  004b0	51		 push	 ecx
  004b1	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004b4	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  004bb	50		 push	 eax
  004bc	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004bf	66 0f b6 91 49
	01 00 00	 movzx	 dx, BYTE PTR [ecx+329]
  004c7	0f b7 c2	 movzx	 eax, dx
  004ca	50		 push	 eax
  004cb	0f b7 4d d0	 movzx	 ecx, WORD PTR _wGameServerCode$233819[ebp]
  004cf	51		 push	 ecx
  004d0	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004d3	8b 02		 mov	 eax, DWORD PTR [edx]
  004d5	50		 push	 eax
  004d6	e8 00 00 00 00	 call	 ?GJReqMapSvrMove@@YAXHGGEE@Z ; GJReqMapSvrMove
  004db	83 c4 14	 add	 esp, 20			; 00000014H

; 1895 : 			LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)", wGameServerCode, lpObj->AccountID, lpObj->Name, lpObj->m_Index);

  004de	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e3	51		 push	 ecx
  004e4	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004e7	83 c2 77	 add	 edx, 119		; 00000077H
  004ea	52		 push	 edx
  004eb	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ee	83 c0 6c	 add	 eax, 108		; 0000006cH
  004f1	50		 push	 eax
  004f2	0f bf 4d d0	 movsx	 ecx, WORD PTR _wGameServerCode$233819[ebp]
  004f6	51		 push	 ecx
  004f7	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
  004fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00502	83 c4 14	 add	 esp, 20			; 00000014H

; 1896 : 			return;

  00505	e9 31 01 00 00	 jmp	 $LN21@DGAnsOffCh
$LN6@DGAnsOffCh:

; 1897 : 		}
; 1898 : 	}
; 1899 : 	
; 1900 : 	lpObj->m_bMapSvrMoveReq = false;

  0050a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050d	c6 80 e5 1b 00
	00 00		 mov	 BYTE PTR [eax+7141], 0

; 1901 : 
; 1902 : 	__int64 Experience = lpObj->Experience;

  00514	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00517	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0051d	33 d2		 xor	 edx, edx
  0051f	89 4d c8	 mov	 DWORD PTR _Experience$[ebp], ecx
  00522	89 55 cc	 mov	 DWORD PTR _Experience$[ebp+4], edx

; 1903 : 
; 1904 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpObj) != FALSE)

  00525	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00528	50		 push	 eax
  00529	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  0052e	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  00533	85 c0		 test	 eax, eax
  00535	74 15		 je	 SHORT $LN2@DGAnsOffCh

; 1905 : 	{
; 1906 : 		Experience = lpObj->MLExp;

  00537	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053a	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  00540	89 4d c8	 mov	 DWORD PTR _Experience$[ebp], ecx
  00543	8b 90 dc 00 00
	00		 mov	 edx, DWORD PTR [eax+220]
  00549	89 55 cc	 mov	 DWORD PTR _Experience$[ebp+4], edx
$LN2@DGAnsOffCh:

; 1907 : 	}
; 1908 : 
; 1909 : 	__int64 NextExperience = lpObj->NextExp;

  0054c	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054f	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00555	33 d2		 xor	 edx, edx
  00557	89 4d c0	 mov	 DWORD PTR _NextExperience$[ebp], ecx
  0055a	89 55 c4	 mov	 DWORD PTR _NextExperience$[ebp+4], edx

; 1910 : 
; 1911 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpObj) != FALSE)

  0055d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00560	50		 push	 eax
  00561	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00566	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  0056b	85 c0		 test	 eax, eax
  0056d	74 15		 je	 SHORT $LN1@DGAnsOffCh

; 1912 : 	{
; 1913 : 		NextExperience = lpObj->MLExp;

  0056f	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00572	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  00578	89 4d c0	 mov	 DWORD PTR _NextExperience$[ebp], ecx
  0057b	8b 90 dc 00 00
	00		 mov	 edx, DWORD PTR [eax+220]
  00581	89 55 c4	 mov	 DWORD PTR _NextExperience$[ebp+4], edx
$LN1@DGAnsOffCh:

; 1914 : 	}
; 1915 : 
; 1916 : 	g_QuestInfo.QuestInfoSave(lpObj);

  00584	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00587	50		 push	 eax
  00588	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0058d	e8 00 00 00 00	 call	 ?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestInfo::QuestInfoSave

; 1917 : 	g_ExGDManager.DB_Load(aIndex);

  00592	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00596	50		 push	 eax
  00597	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExGDManager@@3VCExGDManager@@A ; g_ExGDManager
  0059c	e8 00 00 00 00	 call	 ?DB_Load@CExGDManager@@QAEXH@Z ; CExGDManager::DB_Load

; 1918 : 	g_MasterLevelSystem.GDReqMasterLevelInfo(lpObj);

  005a1	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005a4	50		 push	 eax
  005a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  005aa	e8 00 00 00 00	 call	 ?GDReqMasterLevelInfo@CMasterLevelSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::GDReqMasterLevelInfo

; 1919 : 	g_QuestUtil.Quest3rdRequestInfo(lpObj);

  005af	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b2	50		 push	 eax
  005b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestUtil@@3VCQuestUtil@@A ; g_QuestUtil
  005b8	e8 00 00 00 00	 call	 ?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestUtil::Quest3rdRequestInfo

; 1920 : 	DGGuildMemberInfoRequest(aIndex);

  005bd	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  005c1	50		 push	 eax
  005c2	e8 00 00 00 00	 call	 ?DGGuildMemberInfoRequest@@YAXH@Z ; DGGuildMemberInfoRequest
  005c7	83 c4 04	 add	 esp, 4

; 1921 : 
; 1922 : 	#if(FIX_LAND_OWNDER==TRUE)
; 1923 : 	lpObj->GuildLoadTick = 1;

  005ca	b8 01 00 00 00	 mov	 eax, 1
  005cf	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005d2	66 89 81 10 29
	00 00		 mov	 WORD PTR [ecx+10512], ax

; 1924 : 	#endif
; 1925 : 
; 1926 : 	FriendListRequest(aIndex);

  005d9	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  005dd	50		 push	 eax
  005de	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  005e3	83 c4 04	 add	 esp, 4

; 1927 : 	gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  005e6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005eb	51		 push	 ecx
  005ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  005f1	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 1928 : 
; 1929 : 	#if(CUSTOM_PREMIUM_SYSTEM==TRUE)
; 1930 : 	g_PremiumSystemEx.UserConnect(aIndex);

  005f6	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  005fa	50		 push	 eax
  005fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PremiumSystemEx@@3VPremiumSystemEx@@A ; g_PremiumSystemEx
  00600	e8 00 00 00 00	 call	 ?UserConnect@PremiumSystemEx@@QAEXH@Z ; PremiumSystemEx::UserConnect

; 1931 : 	#endif
; 1932 : 
; 1933 : 	#if(CUSTOM_SAVE_PT==TRUE)
; 1934 : 	gParty.RestoreParty(aIndex);

  00605	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00609	50		 push	 eax
  0060a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0060f	e8 00 00 00 00	 call	 ?RestoreParty@PartyClass@@QAEXH@Z ; PartyClass::RestoreParty

; 1935 : 	#endif
; 1936 : 
; 1937 : 	#if(CUSTOM_RETURNSPOT==TRUE)
; 1938 : 	g_SpotReturn.GDStatusUpdate(aIndex, eStatusNormal);

  00614	6a 00		 push	 0
  00616	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0061a	50		 push	 eax
  0061b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SpotReturn@@3VSpotReturn@@A ; g_SpotReturn
  00620	e8 00 00 00 00	 call	 ?GDStatusUpdate@SpotReturn@@QAEXHE@Z ; SpotReturn::GDStatusUpdate

; 1939 : 	#endif
; 1940 : 
; 1941 : 	lpObj->m_OfflineMode = true;

  00625	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00628	c6 80 d4 28 00
	00 01		 mov	 BYTE PTR [eax+10452], 1

; 1942 : 	lpObj->m_OfflineSkill = 0;

  0062f	33 c0		 xor	 eax, eax
  00631	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00634	66 89 81 d6 28
	00 00		 mov	 WORD PTR [ecx+10454], ax
$LN21@DGAnsOffCh:

; 1943 : }

  0063b	5f		 pop	 edi
  0063c	5e		 pop	 esi
  0063d	5b		 pop	 ebx
  0063e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00641	33 cd		 xor	 ecx, ebp
  00643	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00648	8b e5		 mov	 esp, ebp
  0064a	5d		 pop	 ebp
  0064b	c2 04 00	 ret	 4
?DGAnsOffCharacter@OfflineMode@@QAEXPAUSDHP_DBCHAR_INFORESULT@@@Z ENDP ; OfflineMode::DGAnsOffCharacter
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DGPSelectData@OfflineMode@@QAEXPAUPMSG_GDLOAD_OFFMODE_DATA@@@Z ; OfflineMode::DGPSelectData
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?DGPSelectData@OfflineMode@@QAEXPAUPMSG_GDLOAD_OFFMODE_DATA@@@Z
_TEXT	SEGMENT
tv70 = -152						; size = 4
_pMsg$233886 = -84					; size = 52
_sitem$233846 = -32					; size = 4
_i$233841 = -28						; size = 4
_iCredSize$233840 = -24					; size = 4
_iSize$233839 = -20					; size = 4
_lpUser$ = -16						; size = 4
_aIndex$ = -12						; size = 2
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGPSelectData@OfflineMode@@QAEXPAUPMSG_GDLOAD_OFFMODE_DATA@@@Z PROC ; OfflineMode::DGPSelectData, COMDAT
; _this$ = ecx

; 1946 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1947 : 	short aIndex = lpMsg->Number;

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00020	66 89 4d f4	 mov	 WORD PTR _aIndex$[ebp], cx

; 1948 : 
; 1949 : 	if(!OBJMAX_RANGE(aIndex))

  00024	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00028	85 c0		 test	 eax, eax
  0002a	7d 0c		 jge	 SHORT $LN9@DGPSelectD
  0002c	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
  00036	eb 15		 jmp	 SHORT $LN10@DGPSelectD
$LN9@DGPSelectD:
  00038	0f bf 4d f4	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0003c	33 d2		 xor	 edx, edx
  0003e	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00044	0f 9e c2	 setle	 dl
  00047	89 95 68 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
$LN10@DGPSelectD:
  0004d	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  00054	75 05		 jne	 SHORT $LN6@DGPSelectD

; 1950 : 	{
; 1951 : 		return;

  00056	e9 5b 04 00 00	 jmp	 $LN7@DGPSelectD
$LN6@DGPSelectD:

; 1952 : 	}
; 1953 : 
; 1954 : 	LPOBJ lpUser = &gObj[aIndex];

  0005b	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0005f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00065	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	89 45 f0	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1955 : 
; 1956 : 	lpUser->m_OfflineSkill = MAKE_NUMBERW(lpMsg->AttackData[0], lpMsg->AttackData[1]);

  0006e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00071	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00075	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0007b	0f b6 d1	 movzx	 edx, cl
  0007e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00081	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00085	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0008b	0f b6 c1	 movzx	 eax, cl
  0008e	c1 e0 08	 shl	 eax, 8
  00091	0b d0		 or	 edx, eax
  00093	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00096	66 89 91 d6 28
	00 00		 mov	 WORD PTR [ecx+10454], dx

; 1957 : 	lpUser->m_OfflineAutoBuff = lpMsg->AttackData[2];

  0009d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a0	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  000a4	0f 95 c1	 setne	 cl
  000a7	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000aa	88 8a d9 28 00
	00		 mov	 BYTE PTR [edx+10457], cl

; 1958 : 	lpUser->m_OfflinePickZen = lpMsg->AttackData[3];

  000b0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b3	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000b7	0f 95 c1	 setne	 cl
  000ba	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000bd	88 8a e0 28 00
	00		 mov	 BYTE PTR [edx+10464], cl

; 1959 : 	lpUser->m_OfflinePickJewel = lpMsg->AttackData[4];

  000c3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c6	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000ca	0f 95 c1	 setne	 cl
  000cd	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000d0	88 8a e1 28 00
	00		 mov	 BYTE PTR [edx+10465], cl

; 1960 : 	lpUser->m_OfflinePickExel = lpMsg->AttackData[5];

  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d9	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000dd	0f 95 c1	 setne	 cl
  000e0	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000e3	88 8a e2 28 00
	00		 mov	 BYTE PTR [edx+10466], cl

; 1961 : 	lpUser->m_OfflinePickAnc = lpMsg->AttackData[6];

  000e9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ec	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  000f0	0f 95 c1	 setne	 cl
  000f3	8b 55 f0	 mov	 edx, DWORD PTR _lpUser$[ebp]
  000f6	88 8a e3 28 00
	00		 mov	 BYTE PTR [edx+10467], cl

; 1962 : 	//lpUser->m_OfflinePickForBonus = lpMsg->AttackData[7];
; 1963 : 
; 1964 : 	if(lpMsg->PShopOpen)

  000fc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ff	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00103	85 c9		 test	 ecx, ecx
  00105	0f 84 ab 03 00
	00		 je	 $LN7@DGPSelectD

; 1965 : 	{
; 1966 : 		int iSize = 0;

  0010b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iSize$233839[ebp], 0

; 1967 : 		int iCredSize = 0;

  00112	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iCredSize$233840[ebp], 0

; 1968 : 
; 1969 : 		for(int i = MAIN_INVENTORY_SIZE; i < INVENTORY_SIZE; i++)

  00119	c7 45 e4 cc 00
	00 00		 mov	 DWORD PTR _i$233841[ebp], 204 ; 000000ccH
  00120	eb 09		 jmp	 SHORT $LN4@DGPSelectD
$LN3@DGPSelectD:
  00122	8b 45 e4	 mov	 eax, DWORD PTR _i$233841[ebp]
  00125	83 c0 01	 add	 eax, 1
  00128	89 45 e4	 mov	 DWORD PTR _i$233841[ebp], eax
$LN4@DGPSelectD:
  0012b	81 7d e4 ec 00
	00 00		 cmp	 DWORD PTR _i$233841[ebp], 236 ; 000000ecH
  00132	0f 8d d7 02 00
	00		 jge	 $LN2@DGPSelectD

; 1970 : 		{
; 1971 : 			if(!lpMsg->PriceData[iSize])

  00138	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013b	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  0013e	0f b6 48 33	 movzx	 ecx, BYTE PTR [eax+51]
  00142	85 c9		 test	 ecx, ecx
  00144	75 14		 jne	 SHORT $LN1@DGPSelectD

; 1972 : 			{
; 1973 : 				iSize += 17;

  00146	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  00149	83 c0 11	 add	 eax, 17			; 00000011H
  0014c	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1974 : 				iCredSize += 4;

  0014f	8b 45 e8	 mov	 eax, DWORD PTR _iCredSize$233840[ebp]
  00152	83 c0 04	 add	 eax, 4
  00155	89 45 e8	 mov	 DWORD PTR _iCredSize$233840[ebp], eax

; 1975 : 				continue;

  00158	eb c8		 jmp	 SHORT $LN3@DGPSelectD
$LN1@DGPSelectD:

; 1976 : 			}
; 1977 : 
; 1978 : 			iSize++;

  0015a	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  0015d	83 c0 01	 add	 eax, 1
  00160	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1979 : 
; 1980 : 			CItem * sitem = &gObj[aIndex].Inventory1[i];

  00163	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00167	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0016d	8b 4d e4	 mov	 ecx, DWORD PTR _i$233841[ebp]
  00170	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017c	03 8c 02 34 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3636]
  00183	89 4d e0	 mov	 DWORD PTR _sitem$233846[ebp], ecx

; 1981 : 		
; 1982 : 			sitem->m_iPShopValue = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->PriceData[iSize], lpMsg->PriceData[iSize+1]), MAKE_NUMBERW(lpMsg->PriceData[iSize+2], lpMsg->PriceData[iSize+3]));

  00186	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00189	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  0018c	0f b6 48 36	 movzx	 ecx, BYTE PTR [eax+54]
  00190	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00196	0f b6 d1	 movzx	 edx, cl
  00199	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0019c	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  0019f	0f b6 48 35	 movzx	 ecx, BYTE PTR [eax+53]
  001a3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001a9	0f b6 c1	 movzx	 eax, cl
  001ac	c1 e0 08	 shl	 eax, 8
  001af	0b d0		 or	 edx, eax
  001b1	0f b7 ca	 movzx	 ecx, dx
  001b4	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001ba	0f b7 d1	 movzx	 edx, cx
  001bd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001c0	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  001c3	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  001c7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001cd	0f b6 c1	 movzx	 eax, cl
  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001d3	03 4d ec	 add	 ecx, DWORD PTR _iSize$233839[ebp]
  001d6	0f b6 49 33	 movzx	 ecx, BYTE PTR [ecx+51]
  001da	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001e0	0f b6 c9	 movzx	 ecx, cl
  001e3	c1 e1 08	 shl	 ecx, 8
  001e6	0b c1		 or	 eax, ecx
  001e8	0f b7 c0	 movzx	 eax, ax
  001eb	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001f0	0f b7 c8	 movzx	 ecx, ax
  001f3	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001f6	0b d1		 or	 edx, ecx
  001f8	8b 45 e0	 mov	 eax, DWORD PTR _sitem$233846[ebp]
  001fb	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 1983 : 			iSize += 4;

  001fe	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  00201	83 c0 04	 add	 eax, 4
  00204	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1984 : 
; 1985 : 			sitem->m_iPShopBonus = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->PriceData[iSize], lpMsg->PriceData[iSize+1]), MAKE_NUMBERW(lpMsg->PriceData[iSize+2], lpMsg->PriceData[iSize+3]));

  00207	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0020a	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  0020d	0f b6 48 36	 movzx	 ecx, BYTE PTR [eax+54]
  00211	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00217	0f b6 d1	 movzx	 edx, cl
  0021a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0021d	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  00220	0f b6 48 35	 movzx	 ecx, BYTE PTR [eax+53]
  00224	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0022a	0f b6 c1	 movzx	 eax, cl
  0022d	c1 e0 08	 shl	 eax, 8
  00230	0b d0		 or	 edx, eax
  00232	0f b7 ca	 movzx	 ecx, dx
  00235	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0023b	0f b7 d1	 movzx	 edx, cx
  0023e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00241	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  00244	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  00248	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0024e	0f b6 c1	 movzx	 eax, cl
  00251	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00254	03 4d ec	 add	 ecx, DWORD PTR _iSize$233839[ebp]
  00257	0f b6 49 33	 movzx	 ecx, BYTE PTR [ecx+51]
  0025b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00261	0f b6 c9	 movzx	 ecx, cl
  00264	c1 e1 08	 shl	 ecx, 8
  00267	0b c1		 or	 eax, ecx
  00269	0f b7 c0	 movzx	 eax, ax
  0026c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00271	0f b7 c8	 movzx	 ecx, ax
  00274	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00277	0b d1		 or	 edx, ecx
  00279	8b 45 e0	 mov	 eax, DWORD PTR _sitem$233846[ebp]
  0027c	89 50 78	 mov	 DWORD PTR [eax+120], edx

; 1986 : 			iSize += 4;

  0027f	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  00282	83 c0 04	 add	 eax, 4
  00285	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1987 : 
; 1988 : 			sitem->m_PShopBlessValue = MAKE_NUMBERW(lpMsg->PriceData[iSize], lpMsg->PriceData[iSize+1]);

  00288	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0028b	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  0028e	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  00292	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00298	0f b6 d1	 movzx	 edx, cl
  0029b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0029e	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  002a1	0f b6 48 33	 movzx	 ecx, BYTE PTR [eax+51]
  002a5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002ab	0f b6 c1	 movzx	 eax, cl
  002ae	c1 e0 08	 shl	 eax, 8
  002b1	0b d0		 or	 edx, eax
  002b3	8b 4d e0	 mov	 ecx, DWORD PTR _sitem$233846[ebp]
  002b6	66 89 51 7c	 mov	 WORD PTR [ecx+124], dx

; 1989 : 			iSize += 2;

  002ba	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  002bd	83 c0 02	 add	 eax, 2
  002c0	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1990 : 
; 1991 : 			sitem->m_PShopSoulValue = MAKE_NUMBERW(lpMsg->PriceData[iSize], lpMsg->PriceData[iSize+1]);

  002c3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002c6	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  002c9	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  002cd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002d3	0f b6 d1	 movzx	 edx, cl
  002d6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002d9	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  002dc	0f b6 48 33	 movzx	 ecx, BYTE PTR [eax+51]
  002e0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002e6	0f b6 c1	 movzx	 eax, cl
  002e9	c1 e0 08	 shl	 eax, 8
  002ec	0b d0		 or	 edx, eax
  002ee	8b 4d e0	 mov	 ecx, DWORD PTR _sitem$233846[ebp]
  002f1	66 89 51 7e	 mov	 WORD PTR [ecx+126], dx

; 1992 : 			iSize += 2;

  002f5	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  002f8	83 c0 02	 add	 eax, 2
  002fb	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1993 : 
; 1994 : 			sitem->m_PShopChaosValue = MAKE_NUMBERW(lpMsg->PriceData[iSize], lpMsg->PriceData[iSize+1]);

  002fe	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00301	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  00304	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  00308	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0030e	0f b6 d1	 movzx	 edx, cl
  00311	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00314	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  00317	0f b6 48 33	 movzx	 ecx, BYTE PTR [eax+51]
  0031b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00321	0f b6 c1	 movzx	 eax, cl
  00324	c1 e0 08	 shl	 eax, 8
  00327	0b d0		 or	 edx, eax
  00329	8b 4d e0	 mov	 ecx, DWORD PTR _sitem$233846[ebp]
  0032c	66 89 91 80 00
	00 00		 mov	 WORD PTR [ecx+128], dx

; 1995 : 			iSize += 2;

  00333	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  00336	83 c0 02	 add	 eax, 2
  00339	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1996 : 
; 1997 : 			sitem->m_PShopLifeValue = MAKE_NUMBERW(lpMsg->PriceData[iSize], lpMsg->PriceData[iSize+1]);

  0033c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0033f	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  00342	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  00346	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0034c	0f b6 d1	 movzx	 edx, cl
  0034f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00352	03 45 ec	 add	 eax, DWORD PTR _iSize$233839[ebp]
  00355	0f b6 48 33	 movzx	 ecx, BYTE PTR [eax+51]
  00359	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0035f	0f b6 c1	 movzx	 eax, cl
  00362	c1 e0 08	 shl	 eax, 8
  00365	0b d0		 or	 edx, eax
  00367	8b 4d e0	 mov	 ecx, DWORD PTR _sitem$233846[ebp]
  0036a	66 89 91 82 00
	00 00		 mov	 WORD PTR [ecx+130], dx

; 1998 : 			iSize += 2;

  00371	8b 45 ec	 mov	 eax, DWORD PTR _iSize$233839[ebp]
  00374	83 c0 02	 add	 eax, 2
  00377	89 45 ec	 mov	 DWORD PTR _iSize$233839[ebp], eax

; 1999 : 
; 2000 : 			sitem->m_iPShopCredit = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->CreditData[iCredSize], lpMsg->CreditData[iCredSize+1]), MAKE_NUMBERW(lpMsg->CreditData[iCredSize+2], lpMsg->CreditData[iCredSize+3]));

  0037a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0037d	03 45 e8	 add	 eax, DWORD PTR _iCredSize$233840[ebp]
  00380	0f b6 88 56 02
	00 00		 movzx	 ecx, BYTE PTR [eax+598]
  00387	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0038d	0f b6 d1	 movzx	 edx, cl
  00390	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00393	03 45 e8	 add	 eax, DWORD PTR _iCredSize$233840[ebp]
  00396	0f b6 88 55 02
	00 00		 movzx	 ecx, BYTE PTR [eax+597]
  0039d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003a3	0f b6 c1	 movzx	 eax, cl
  003a6	c1 e0 08	 shl	 eax, 8
  003a9	0b d0		 or	 edx, eax
  003ab	0f b7 ca	 movzx	 ecx, dx
  003ae	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003b4	0f b7 d1	 movzx	 edx, cx
  003b7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003ba	03 45 e8	 add	 eax, DWORD PTR _iCredSize$233840[ebp]
  003bd	0f b6 88 54 02
	00 00		 movzx	 ecx, BYTE PTR [eax+596]
  003c4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003ca	0f b6 c1	 movzx	 eax, cl
  003cd	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  003d0	03 4d e8	 add	 ecx, DWORD PTR _iCredSize$233840[ebp]
  003d3	0f b6 89 53 02
	00 00		 movzx	 ecx, BYTE PTR [ecx+595]
  003da	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003e0	0f b6 c9	 movzx	 ecx, cl
  003e3	c1 e1 08	 shl	 ecx, 8
  003e6	0b c1		 or	 eax, ecx
  003e8	0f b7 c0	 movzx	 eax, ax
  003eb	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  003f0	0f b7 c8	 movzx	 ecx, ax
  003f3	c1 e1 10	 shl	 ecx, 16			; 00000010H
  003f6	0b d1		 or	 edx, ecx
  003f8	8b 45 e0	 mov	 eax, DWORD PTR _sitem$233846[ebp]
  003fb	89 90 84 00 00
	00		 mov	 DWORD PTR [eax+132], edx

; 2001 : 			iCredSize += 4;

  00401	8b 45 e8	 mov	 eax, DWORD PTR _iCredSize$233840[ebp]
  00404	83 c0 04	 add	 eax, 4
  00407	89 45 e8	 mov	 DWORD PTR _iCredSize$233840[ebp], eax

; 2002 : 		}

  0040a	e9 13 fd ff ff	 jmp	 $LN3@DGPSelectD
$LN2@DGPSelectD:

; 2003 : 
; 2004 : 		memcpy(lpUser->m_szPShopText, lpMsg->PShopText, sizeof(lpMsg->PShopText));

  0040f	6a 24		 push	 36			; 00000024H
  00411	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00414	83 c0 0f	 add	 eax, 15			; 0000000fH
  00417	50		 push	 eax
  00418	8b 4d f0	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0041b	81 c1 c8 0e 00
	00		 add	 ecx, 3784		; 00000ec8H
  00421	51		 push	 ecx
  00422	e8 00 00 00 00	 call	 _memcpy
  00427	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2005 : 		lpUser->m_bPShopOpen = true;

  0042a	8b 45 f0	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0042d	c6 80 c4 0e 00
	00 01		 mov	 BYTE PTR [eax+3780], 1

; 2006 : 
; 2007 : 		PMSG_ANS_PSHOP_TEXT_CHANGED pMsg;
; 2008 : 		PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x10, sizeof(pMsg));

  00434	6a 34		 push	 52			; 00000034H
  00436	6a 10		 push	 16			; 00000010H
  00438	6a 3f		 push	 63			; 0000003fH
  0043a	8d 45 ac	 lea	 eax, DWORD PTR _pMsg$233886[ebp]
  0043d	50		 push	 eax
  0043e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00443	83 c4 10	 add	 esp, 16			; 00000010H

; 2009 : 		pMsg.NumberH = SET_NUMBERH(aIndex);

  00446	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0044a	c1 e8 08	 shr	 eax, 8
  0044d	88 45 b0	 mov	 BYTE PTR _pMsg$233886[ebp+4], al

; 2010 : 		pMsg.NumberL = SET_NUMBERL(aIndex);

  00450	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00454	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00459	88 45 b1	 mov	 BYTE PTR _pMsg$233886[ebp+5], al

; 2011 : 		memcpy(pMsg.btPShopText, lpMsg->PShopText, sizeof(pMsg.btPShopText));

  0045c	6a 24		 push	 36			; 00000024H
  0045e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00461	83 c0 0f	 add	 eax, 15			; 0000000fH
  00464	50		 push	 eax
  00465	8d 4d b2	 lea	 ecx, DWORD PTR _pMsg$233886[ebp+6]
  00468	51		 push	 ecx
  00469	e8 00 00 00 00	 call	 _memcpy
  0046e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2012 : 		memcpy(pMsg.btName, gObj[aIndex].Name, sizeof(pMsg.btName));

  00471	6a 0a		 push	 10			; 0000000aH
  00473	0f bf 45 f4	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00477	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0047d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00483	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00487	52		 push	 edx
  00488	8d 45 d6	 lea	 eax, DWORD PTR _pMsg$233886[ebp+42]
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 _memcpy
  00491	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2013 : 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00494	0f b6 45 ad	 movzx	 eax, BYTE PTR _pMsg$233886[ebp+1]
  00498	50		 push	 eax
  00499	8d 4d ac	 lea	 ecx, DWORD PTR _pMsg$233886[ebp]
  0049c	51		 push	 ecx
  0049d	0f bf 55 f4	 movsx	 edx, WORD PTR _aIndex$[ebp]
  004a1	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  004a7	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ad	52		 push	 edx
  004ae	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  004b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@DGPSelectD:

; 2014 : 	}
; 2015 : }

  004b6	5f		 pop	 edi
  004b7	5e		 pop	 esi
  004b8	5b		 pop	 ebx
  004b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bc	33 cd		 xor	 ecx, ebp
  004be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c3	8b e5		 mov	 esp, ebp
  004c5	5d		 pop	 ebp
  004c6	c2 04 00	 ret	 4
?DGPSelectData@OfflineMode@@QAEXPAUPMSG_GDLOAD_OFFMODE_DATA@@@Z ENDP ; OfflineMode::DGPSelectData
_TEXT	ENDS
PUBLIC	?set@PWMSG_HEAD@@QAEXPAEEH@Z			; PWMSG_HEAD::set
PUBLIC	__$ArrayPad$
PUBLIC	?GDUpdateData@OfflineMode@@QAEXH@Z		; OfflineMode::GDUpdateData
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?GDUpdateData@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv67 = -1512						; size = 4
_sitem$233918 = -1444					; size = 4
_i$233914 = -1440					; size = 4
_btCredit$ = -1436					; size = 128
_iCredSize$ = -1308					; size = 4
_btPacket$ = -1304					; size = 544
_iSize$ = -760						; size = 4
_btBuff$ = -756						; size = 8
_pMsg$ = -748						; size = 733
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDUpdateData@OfflineMode@@QAEXH@Z PROC			; OfflineMode::GDUpdateData, COMDAT
; _this$ = ecx

; 2018 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 05 00
	00		 sub	 esp, 1512		; 000005e8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2019 : 	if(!OBJMAX_RANGE(aIndex))

  00019	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN9@GDUpdateDa
  0001f	c7 85 18 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 12		 jmp	 SHORT $LN10@GDUpdateDa
$LN9@GDUpdateDa:
  0002b	33 c0		 xor	 eax, eax
  0002d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00034	0f 9e c0	 setle	 al
  00037	89 85 18 fa ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@GDUpdateDa:
  0003d	83 bd 18 fa ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  00044	75 05		 jne	 SHORT $LN6@GDUpdateDa

; 2020 : 	{
; 2021 : 		return;

  00046	e9 35 06 00 00	 jmp	 $LN7@GDUpdateDa
$LN6@GDUpdateDa:

; 2022 : 	}
; 2023 : 
; 2024 : 	LPOBJ lpUser = &gObj[aIndex];

  0004b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 2025 : 
; 2026 : 	PMSG_GDSAVE_OFFMODE_DATA pMsg = { 0 };

  0005d	c6 85 14 fd ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp], 0
  00064	68 dc 02 00 00	 push	 732			; 000002dcH
  00069	6a 00		 push	 0
  0006b	8d 85 15 fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+1]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _memset
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2027 : 	pMsg.h.set((LPBYTE)&pMsg, 0xED, sizeof(pMsg));

  0007a	68 dd 02 00 00	 push	 733			; 000002ddH
  0007f	68 ed 00 00 00	 push	 237			; 000000edH
  00084	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0008a	50		 push	 eax
  0008b	8d 8d 14 fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00091	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD@@QAEXPAEEH@Z ; PWMSG_HEAD::set

; 2028 : 	memcpy(pMsg.Name, lpUser->Name, sizeof(pMsg.Name));

  00096	6a 0b		 push	 11			; 0000000bH
  00098	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0009b	83 c0 77	 add	 eax, 119		; 00000077H
  0009e	50		 push	 eax
  0009f	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _memcpy
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2029 : 	pMsg.Status = lpUser->m_OfflineMode;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000b1	8a 88 d4 28 00
	00		 mov	 cl, BYTE PTR [eax+10452]
  000b7	88 8d 23 fd ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+15], cl

; 2030 : 	memcpy(pMsg.PShopText, lpUser->m_szPShopText, sizeof(pMsg.PShopText));

  000bd	6a 24		 push	 36			; 00000024H
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000c2	05 c8 0e 00 00	 add	 eax, 3784		; 00000ec8H
  000c7	50		 push	 eax
  000c8	8d 8d 2d fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+25]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2031 : 
; 2032 : 	if(lpUser->m_OfflineMode && lpUser->m_bPShopOpen)

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000da	0f b6 88 d4 28
	00 00		 movzx	 ecx, BYTE PTR [eax+10452]
  000e1	85 c9		 test	 ecx, ecx
  000e3	74 17		 je	 SHORT $LN5@GDUpdateDa
  000e5	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  000e8	0f b6 88 c4 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3780]
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 09		 je	 SHORT $LN5@GDUpdateDa

; 2033 : 	{
; 2034 : 		pMsg.PShopOpen = true;

  000f3	c6 85 2c fd ff
	ff 01		 mov	 BYTE PTR _pMsg$[ebp+24], 1

; 2035 : 	}
; 2036 : 	else

  000fa	eb 07		 jmp	 SHORT $LN4@GDUpdateDa
$LN5@GDUpdateDa:

; 2037 : 	{
; 2038 : 		pMsg.PShopOpen = false;

  000fc	c6 85 2c fd ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+24], 0
$LN4@GDUpdateDa:

; 2039 : 	}
; 2040 : 
; 2041 : 	BYTE btBuff[OFFLINEMODE_DBMAX] = { 0 };

  00103	c6 85 0c fd ff
	ff 00		 mov	 BYTE PTR _btBuff$[ebp], 0
  0010a	33 c0		 xor	 eax, eax
  0010c	89 85 0d fd ff
	ff		 mov	 DWORD PTR _btBuff$[ebp+1], eax
  00112	66 89 85 11 fd
	ff ff		 mov	 WORD PTR _btBuff$[ebp+5], ax
  00119	88 85 13 fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+7], al

; 2042 : 
; 2043 : 	btBuff[0] = SET_NUMBERH(lpUser->m_OfflineSkill);

  0011f	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00122	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  00129	c1 e9 08	 shr	 ecx, 8
  0012c	88 8d 0c fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp], cl

; 2044 : 	btBuff[1] = SET_NUMBERL(lpUser->m_OfflineSkill);	

  00132	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00135	0f b7 88 d6 28
	00 00		 movzx	 ecx, WORD PTR [eax+10454]
  0013c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00142	88 8d 0d fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+1], cl

; 2045 : 	btBuff[2] = lpUser->m_OfflineAutoBuff;				

  00148	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0014b	8a 88 d9 28 00
	00		 mov	 cl, BYTE PTR [eax+10457]
  00151	88 8d 0e fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+2], cl

; 2046 : 	btBuff[3] = lpUser->m_OfflinePickZen;				

  00157	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0015a	8a 88 e0 28 00
	00		 mov	 cl, BYTE PTR [eax+10464]
  00160	88 8d 0f fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+3], cl

; 2047 : 	btBuff[4] = lpUser->m_OfflinePickJewel;				

  00166	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00169	8a 88 e1 28 00
	00		 mov	 cl, BYTE PTR [eax+10465]
  0016f	88 8d 10 fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+4], cl

; 2048 : 	btBuff[5] = lpUser->m_OfflinePickExel;				

  00175	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00178	8a 88 e2 28 00
	00		 mov	 cl, BYTE PTR [eax+10466]
  0017e	88 8d 11 fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+5], cl

; 2049 : 	btBuff[6] = lpUser->m_OfflinePickAnc;				

  00184	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00187	8a 88 e3 28 00
	00		 mov	 cl, BYTE PTR [eax+10467]
  0018d	88 8d 12 fd ff
	ff		 mov	 BYTE PTR _btBuff$[ebp+6], cl

; 2050 : 	btBuff[7] = 0;			

  00193	c6 85 13 fd ff
	ff 00		 mov	 BYTE PTR _btBuff$[ebp+7], 0

; 2051 : 
; 2052 : 	memcpy(pMsg.AttackData, btBuff, OFFLINEMODE_DBMAX);

  0019a	6a 08		 push	 8
  0019c	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _btBuff$[ebp]
  001a2	50		 push	 eax
  001a3	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+16]
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 _memcpy
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2053 : 
; 2054 : 	int iSize = 0;

  001b2	c7 85 08 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _iSize$[ebp], 0

; 2055 : 	BYTE btPacket[OFFLINEMODE_DBPRICE] = { 0 };

  001bc	c6 85 e8 fa ff
	ff 00		 mov	 BYTE PTR _btPacket$[ebp], 0
  001c3	68 1f 02 00 00	 push	 543			; 0000021fH
  001c8	6a 00		 push	 0
  001ca	8d 85 e9 fa ff
	ff		 lea	 eax, DWORD PTR _btPacket$[ebp+1]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _memset
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2056 : 
; 2057 : 	int iCredSize = 0;

  001d9	c7 85 e4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCredSize$[ebp], 0

; 2058 : 	BYTE btCredit[OFFLINEMODE_DBCREDIT] = { 0 };

  001e3	c6 85 64 fa ff
	ff 00		 mov	 BYTE PTR _btCredit$[ebp], 0
  001ea	6a 7f		 push	 127			; 0000007fH
  001ec	6a 00		 push	 0
  001ee	8d 85 65 fa ff
	ff		 lea	 eax, DWORD PTR _btCredit$[ebp+1]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _memset
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2059 : 
; 2060 : 	for(int i = MAIN_INVENTORY_SIZE; i < INVENTORY_SIZE; i++)

  001fd	c7 85 60 fa ff
	ff cc 00 00 00	 mov	 DWORD PTR _i$233914[ebp], 204 ; 000000ccH
  00207	eb 0f		 jmp	 SHORT $LN3@GDUpdateDa
$LN2@GDUpdateDa:
  00209	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _i$233914[ebp]
  0020f	83 c0 01	 add	 eax, 1
  00212	89 85 60 fa ff
	ff		 mov	 DWORD PTR _i$233914[ebp], eax
$LN3@GDUpdateDa:
  00218	81 bd 60 fa ff
	ff ec 00 00 00	 cmp	 DWORD PTR _i$233914[ebp], 236 ; 000000ecH
  00222	0f 8d 0c 04 00
	00		 jge	 $LN1@GDUpdateDa

; 2061 : 	{
; 2062 : 		CItem* sitem = &gObj[aIndex].Inventory1[i];

  00228	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0022b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00231	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _i$233914[ebp]
  00237	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0023d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00243	03 8c 02 34 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3636]
  0024a	89 8d 5c fa ff
	ff		 mov	 DWORD PTR _sitem$233918[ebp], ecx

; 2063 : 
; 2064 : 		btPacket[iSize] = sitem->IsItem();									iSize++;

  00250	8b 8d 5c fa ff
	ff		 mov	 ecx, DWORD PTR _sitem$233918[ebp]
  00256	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0025b	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _iSize$[ebp]
  00261	88 84 0d e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+ecx], al
  00268	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  0026e	83 c0 01	 add	 eax, 1
  00271	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2065 : 
; 2066 : 		btPacket[iSize] = SET_NUMBERH(SET_NUMBERHW(sitem->m_iPShopValue));	iSize++;

  00277	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  0027d	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00280	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00283	0f b7 d1	 movzx	 edx, cx
  00286	c1 ea 08	 shr	 edx, 8
  00289	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  0028f	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  00296	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  0029c	83 c0 01	 add	 eax, 1
  0029f	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2067 : 		btPacket[iSize] = SET_NUMBERL(SET_NUMBERHW(sitem->m_iPShopValue));	iSize++;

  002a5	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  002ab	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  002ae	c1 e9 10	 shr	 ecx, 16			; 00000010H
  002b1	0f b7 d1	 movzx	 edx, cx
  002b4	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002ba	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  002c0	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  002c7	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  002cd	83 c0 01	 add	 eax, 1
  002d0	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2068 : 		btPacket[iSize] = SET_NUMBERH(SET_NUMBERLW(sitem->m_iPShopValue));	iSize++;

  002d6	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  002dc	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  002df	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  002e5	0f b7 d1	 movzx	 edx, cx
  002e8	c1 ea 08	 shr	 edx, 8
  002eb	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  002f1	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  002f8	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  002fe	83 c0 01	 add	 eax, 1
  00301	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2069 : 		btPacket[iSize] = SET_NUMBERL(SET_NUMBERLW(sitem->m_iPShopValue));	iSize++;

  00307	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  0030d	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00310	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00316	0f b7 d1	 movzx	 edx, cx
  00319	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0031f	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00325	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  0032c	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00332	83 c0 01	 add	 eax, 1
  00335	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2070 : 
; 2071 : 		btPacket[iSize] = SET_NUMBERH(SET_NUMBERHW(sitem->m_iPShopBonus));	iSize++;

  0033b	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  00341	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00344	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00347	0f b7 d1	 movzx	 edx, cx
  0034a	c1 ea 08	 shr	 edx, 8
  0034d	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00353	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  0035a	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00360	83 c0 01	 add	 eax, 1
  00363	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2072 : 		btPacket[iSize] = SET_NUMBERL(SET_NUMBERHW(sitem->m_iPShopBonus));	iSize++;

  00369	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  0036f	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00372	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00375	0f b7 d1	 movzx	 edx, cx
  00378	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0037e	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00384	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  0038b	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00391	83 c0 01	 add	 eax, 1
  00394	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2073 : 		btPacket[iSize] = SET_NUMBERH(SET_NUMBERLW(sitem->m_iPShopBonus));	iSize++;

  0039a	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  003a0	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  003a3	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003a9	0f b7 d1	 movzx	 edx, cx
  003ac	c1 ea 08	 shr	 edx, 8
  003af	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  003b5	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  003bc	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  003c2	83 c0 01	 add	 eax, 1
  003c5	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2074 : 		btPacket[iSize] = SET_NUMBERL(SET_NUMBERLW(sitem->m_iPShopBonus));	iSize++;

  003cb	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  003d1	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  003d4	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003da	0f b7 d1	 movzx	 edx, cx
  003dd	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003e3	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  003e9	88 94 05 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+eax], dl
  003f0	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  003f6	83 c0 01	 add	 eax, 1
  003f9	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2075 : 
; 2076 : 		btPacket[iSize] = SET_NUMBERH(sitem->m_PShopBlessValue);			iSize++;

  003ff	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  00405	0f bf 48 7c	 movsx	 ecx, WORD PTR [eax+124]
  00409	c1 e9 08	 shr	 ecx, 8
  0040c	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  00412	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  00419	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  0041f	83 c0 01	 add	 eax, 1
  00422	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2077 : 		btPacket[iSize] = SET_NUMBERL(sitem->m_PShopBlessValue);			iSize++;

  00428	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  0042e	0f bf 48 7c	 movsx	 ecx, WORD PTR [eax+124]
  00432	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00438	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  0043e	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  00445	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  0044b	83 c0 01	 add	 eax, 1
  0044e	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2078 : 			
; 2079 : 		btPacket[iSize] = SET_NUMBERH(sitem->m_PShopSoulValue);				iSize++;

  00454	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  0045a	0f bf 48 7e	 movsx	 ecx, WORD PTR [eax+126]
  0045e	c1 e9 08	 shr	 ecx, 8
  00461	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  00467	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  0046e	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00474	83 c0 01	 add	 eax, 1
  00477	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2080 : 		btPacket[iSize] = SET_NUMBERL(sitem->m_PShopSoulValue);				iSize++;

  0047d	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  00483	0f bf 48 7e	 movsx	 ecx, WORD PTR [eax+126]
  00487	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0048d	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  00493	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  0049a	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  004a0	83 c0 01	 add	 eax, 1
  004a3	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2081 : 
; 2082 : 		btPacket[iSize] = SET_NUMBERH(sitem->m_PShopChaosValue);			iSize++;

  004a9	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  004af	0f bf 88 80 00
	00 00		 movsx	 ecx, WORD PTR [eax+128]
  004b6	c1 e9 08	 shr	 ecx, 8
  004b9	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  004bf	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  004c6	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  004cc	83 c0 01	 add	 eax, 1
  004cf	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2083 : 		btPacket[iSize] = SET_NUMBERL(sitem->m_PShopChaosValue);			iSize++;

  004d5	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  004db	0f bf 88 80 00
	00 00		 movsx	 ecx, WORD PTR [eax+128]
  004e2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004e8	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  004ee	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  004f5	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  004fb	83 c0 01	 add	 eax, 1
  004fe	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2084 : 
; 2085 : 		btPacket[iSize] = SET_NUMBERH(sitem->m_PShopLifeValue);				iSize++;

  00504	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  0050a	0f bf 88 82 00
	00 00		 movsx	 ecx, WORD PTR [eax+130]
  00511	c1 e9 08	 shr	 ecx, 8
  00514	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  0051a	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  00521	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00527	83 c0 01	 add	 eax, 1
  0052a	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2086 : 		btPacket[iSize] = SET_NUMBERL(sitem->m_PShopLifeValue);				iSize++;

  00530	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  00536	0f bf 88 82 00
	00 00		 movsx	 ecx, WORD PTR [eax+130]
  0053d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00543	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _iSize$[ebp]
  00549	88 8c 15 e8 fa
	ff ff		 mov	 BYTE PTR _btPacket$[ebp+edx], cl
  00550	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _iSize$[ebp]
  00556	83 c0 01	 add	 eax, 1
  00559	89 85 08 fd ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax

; 2087 : 
; 2088 : 		btCredit[iCredSize] = SET_NUMBERH(SET_NUMBERHW(sitem->m_iPShopCredit));	iCredSize++;

  0055f	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  00565	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0056b	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0056e	0f b7 d1	 movzx	 edx, cx
  00571	c1 ea 08	 shr	 edx, 8
  00574	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  0057a	88 94 05 64 fa
	ff ff		 mov	 BYTE PTR _btCredit$[ebp+eax], dl
  00581	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  00587	83 c0 01	 add	 eax, 1
  0058a	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _iCredSize$[ebp], eax

; 2089 : 		btCredit[iCredSize] = SET_NUMBERL(SET_NUMBERHW(sitem->m_iPShopCredit));	iCredSize++;

  00590	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  00596	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0059c	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0059f	0f b7 d1	 movzx	 edx, cx
  005a2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005a8	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  005ae	88 94 05 64 fa
	ff ff		 mov	 BYTE PTR _btCredit$[ebp+eax], dl
  005b5	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  005bb	83 c0 01	 add	 eax, 1
  005be	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _iCredSize$[ebp], eax

; 2090 : 		btCredit[iCredSize] = SET_NUMBERH(SET_NUMBERLW(sitem->m_iPShopCredit));	iCredSize++;

  005c4	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  005ca	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  005d0	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  005d6	0f b7 d1	 movzx	 edx, cx
  005d9	c1 ea 08	 shr	 edx, 8
  005dc	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  005e2	88 94 05 64 fa
	ff ff		 mov	 BYTE PTR _btCredit$[ebp+eax], dl
  005e9	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  005ef	83 c0 01	 add	 eax, 1
  005f2	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _iCredSize$[ebp], eax

; 2091 : 		btCredit[iCredSize] = SET_NUMBERL(SET_NUMBERLW(sitem->m_iPShopCredit));	iCredSize++;

  005f8	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _sitem$233918[ebp]
  005fe	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00604	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0060a	0f b7 d1	 movzx	 edx, cx
  0060d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00613	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  00619	88 94 05 64 fa
	ff ff		 mov	 BYTE PTR _btCredit$[ebp+eax], dl
  00620	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _iCredSize$[ebp]
  00626	83 c0 01	 add	 eax, 1
  00629	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _iCredSize$[ebp], eax

; 2092 : 	}

  0062f	e9 d5 fb ff ff	 jmp	 $LN2@GDUpdateDa
$LN1@GDUpdateDa:

; 2093 : 
; 2094 : 	memcpy(pMsg.PriceData, btPacket, OFFLINEMODE_DBPRICE);

  00634	68 20 02 00 00	 push	 544			; 00000220H
  00639	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _btPacket$[ebp]
  0063f	50		 push	 eax
  00640	8d 8d 51 fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+61]
  00646	51		 push	 ecx
  00647	e8 00 00 00 00	 call	 _memcpy
  0064c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2095 : 
; 2096 : 	memcpy(pMsg.CreditData, btCredit, OFFLINEMODE_DBCREDIT);

  0064f	68 80 00 00 00	 push	 128			; 00000080H
  00654	8d 85 64 fa ff
	ff		 lea	 eax, DWORD PTR _btCredit$[ebp]
  0065a	50		 push	 eax
  0065b	8d 8d 71 ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+605]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 _memcpy
  00667	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2097 : 
; 2098 : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  0066a	68 dd 02 00 00	 push	 733			; 000002ddH
  0066f	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00675	50		 push	 eax
  00676	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0067b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN7@GDUpdateDa:

; 2099 : }

  00680	5f		 pop	 edi
  00681	5e		 pop	 esi
  00682	5b		 pop	 ebx
  00683	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00686	33 cd		 xor	 ecx, ebp
  00688	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0068d	8b e5		 mov	 esp, ebp
  0068f	5d		 pop	 ebp
  00690	c2 04 00	 ret	 4
?GDUpdateData@OfflineMode@@QAEXH@Z ENDP			; OfflineMode::GDUpdateData
; Function compile flags: /Odtp /ZI /ZX
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 122  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 		lpBuf[0] = 0xC2;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H

; 124  : 		lpBuf[1] = SET_NUMBERH(size);

  00012	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00015	c1 e8 08	 shr	 eax, 8
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  0001b	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 125  : 		lpBuf[2] = SET_NUMBERL(size);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00021	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00029	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 126  : 		lpBuf[3] = head;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0002f	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00032	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 127  : 	};

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI /ZX
; File d:\projects\exteam6.3\source\gameserver\gameserver\offlinemode.cpp
;	COMDAT ?GDReqUpdateStatus@OfflineMode@@QAEXH@Z
_TEXT	SEGMENT
tv67 = -96						; size = 4
_pMsg$ = -28						; size = 16
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqUpdateStatus@OfflineMode@@QAEXH@Z PROC		; OfflineMode::GDReqUpdateStatus, COMDAT
; _this$ = ecx

; 2102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2103 : 	if(!OBJMAX_RANGE(aIndex))

  00016	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $LN4@GDReqUpdat
  0001c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00023	eb 0f		 jmp	 SHORT $LN5@GDReqUpdat
$LN4@GDReqUpdat:
  00025	33 c0		 xor	 eax, eax
  00027	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0002e	0f 9e c0	 setle	 al
  00031	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GDReqUpdat:
  00034	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00038	75 02		 jne	 SHORT $LN1@GDReqUpdat

; 2104 : 	{
; 2105 : 		return;

  0003a	eb 5b		 jmp	 SHORT $LN2@GDReqUpdat
$LN1@GDReqUpdat:

; 2106 : 	}
; 2107 : 
; 2108 : 	LPOBJ lpUser = &gObj[aIndex];

  0003c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00045	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004b	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 2109 : 
; 2110 : 	PMSG_GDREQ_OFFMODE_STATUS pMsg;
; 2111 : 	pMsg.h.set((LPBYTE)&pMsg, 0xEB, 0x13, sizeof(pMsg));

  0004e	6a 10		 push	 16			; 00000010H
  00050	6a 13		 push	 19			; 00000013H
  00052	68 eb 00 00 00	 push	 235			; 000000ebH
  00057	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0005a	50		 push	 eax
  0005b	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005e	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 2112 : 	memcpy(pMsg.Name, lpUser->Name, sizeof(pMsg.Name));

  00063	6a 0b		 push	 11			; 0000000bH
  00065	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00068	83 c0 77	 add	 eax, 119		; 00000077H
  0006b	50		 push	 eax
  0006c	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2113 : 	pMsg.Status = lpUser->m_OfflineMode;

  00078	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0007b	8a 88 d4 28 00
	00		 mov	 cl, BYTE PTR [eax+10452]
  00081	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+15], cl

; 2114 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);	

  00084	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00088	50		 push	 eax
  00089	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0008c	51		 push	 ecx
  0008d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00092	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDReqUpdat:

; 2115 : 
; 2116 : //	lpUser->m_OfflineMode = Status;
; 2117 : 
; 2118 : 	//this->GDUpdateData(aIndex);	//need add other packet status 
; 2119 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009d	33 cd		 xor	 ecx, ebp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?GDReqUpdateStatus@OfflineMode@@QAEXH@Z ENDP		; OfflineMode::GDReqUpdateStatus
_TEXT	ENDS
PUBLIC	??A?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEAAUOFFMODE_BLOCK_MAP@@I@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::operator[]
PUBLIC	?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::size
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?CheckBlockMap@OfflineMode@@QAE_NH@Z
_TEXT	SEGMENT
_i$234015 = -8						; size = 4
_this$ = -4						; size = 4
_Map$ = 8						; size = 4
?CheckBlockMap@OfflineMode@@QAE_NH@Z PROC		; OfflineMode::CheckBlockMap, COMDAT
; _this$ = ecx

; 2123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2124 : 	if( g_ExLicense.CheckUser(eExUB::Local) || g_ExLicense.CheckUser(eExUB::SILVER2))

  0000c	6a 00		 push	 0
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00013	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 13		 jne	 SHORT $LN5@CheckBlock
  0001f	6a 08		 push	 8
  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00026	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	74 3e		 je	 SHORT $LN6@CheckBlock
$LN5@CheckBlock:

; 2125 : 	{
; 2126 : 		for(int i = 0; i < this->m_BlockMap.size(); i++)

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$234015[ebp], 0
  00039	eb 09		 jmp	 SHORT $LN4@CheckBlock
$LN3@CheckBlock:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$234015[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _i$234015[ebp], eax
$LN4@CheckBlock:
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 28	 add	 ecx, 40			; 00000028H
  0004a	e8 00 00 00 00	 call	 ?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::size
  0004f	39 45 f8	 cmp	 DWORD PTR _i$234015[ebp], eax
  00052	73 1c		 jae	 SHORT $LN6@CheckBlock

; 2127 : 		{
; 2128 : 			if(this->m_BlockMap[i].MapNumber == Map)

  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$234015[ebp]
  00057	50		 push	 eax
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 28	 add	 ecx, 40			; 00000028H
  0005e	e8 00 00 00 00	 call	 ??A?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEAAUOFFMODE_BLOCK_MAP@@I@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::operator[]
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	3b 4d 08	 cmp	 ecx, DWORD PTR _Map$[ebp]
  00068	75 04		 jne	 SHORT $LN1@CheckBlock

; 2129 : 			{
; 2130 : 				return false;

  0006a	32 c0		 xor	 al, al
  0006c	eb 04		 jmp	 SHORT $LN7@CheckBlock
$LN1@CheckBlock:

; 2131 : 			}
; 2132 : 		}

  0006e	eb cb		 jmp	 SHORT $LN3@CheckBlock
$LN6@CheckBlock:

; 2133 : 	}
; 2134 : 
; 2135 : 	return true;

  00070	b0 01		 mov	 al, 1
$LN7@CheckBlock:

; 2136 : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?CheckBlockMap@OfflineMode@@QAE_NH@Z ENDP		; OfflineMode::CheckBlockMap
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@V?$allocator@UOFFMODE_BLOCK_MAP@@@1@@Z ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
PUBLIC	??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@XZ	; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T235187 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T235187[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@XZ ; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@V?$allocator@UOFFMODE_BLOCK_MAP@@@1@@Z ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
PUBLIC	?_Tidy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Tidy
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
__ehhandler$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::size
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ??A?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEAAUOFFMODE_BLOCK_MAP@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEAAUOFFMODE_BLOCK_MAP@@I@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEAAUOFFMODE_BLOCK_MAP@@I@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@ABU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@ABU2@@Z ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>
PUBLIC	??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@AAU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@AAU2@@Z ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP &>
PUBLIC	?_Orphan_range@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXI@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Reserve
PUBLIC	?_Inside@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBE_NPBUOFFMODE_BLOCK_MAP@@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Inside
PUBLIC	??$addressof@$$CBUOFFMODE_BLOCK_MAP@@@std@@YAPBUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::addressof<OFFMODE_BLOCK_MAP const >
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?push_back@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXABUOFFMODE_BLOCK_MAP@@@Z
_TEXT	SEGMENT
__Idx$234043 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXABUOFFMODE_BLOCK_MAP@@@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUOFFMODE_BLOCK_MAP@@@std@@YAPBUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::addressof<OFFMODE_BLOCK_MAP const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBE_NPBUOFFMODE_BLOCK_MAP@@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUOFFMODE_BLOCK_MAP@@@std@@YAPBUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::addressof<OFFMODE_BLOCK_MAP const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$234043[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXI@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$234043[ebp]
  00075	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@AAU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@AAU2@@Z ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 04	 add	 ecx, 4
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXI@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@ABU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@ABU2@@Z ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 04	 add	 ecx, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXABUOFFMODE_BLOCK_MAP@@@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::erase
PUBLIC	?begin@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::begin
PUBLIC	?end@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::end
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?clear@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T235209 = -88						; size = 4
$T235210 = -84						; size = 4
$T235211 = -80						; size = 4
$T235212 = -76						; size = 4
$T235213 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXXZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T235210[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T235209[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T235212[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T235211[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T235209[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T235211[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T235213[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXXZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?begin@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::begin
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?end@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@XZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Destroy
PUBLIC	??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00@Z ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Make_iter
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?erase@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T235220 = -84						; size = 4
__Ptr$234234 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@0@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00@Z ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$234234[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$234234[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$234234[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T235220[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T235220[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@0@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::erase
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBE_NPBUOFFMODE_BLOCK_MAP@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBE_NPBUOFFMODE_BLOCK_MAP@@@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBE_NPBUOFFMODE_BLOCK_MAP@@@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::reserve
PUBLIC	?_Grow_to@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEII@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Grow_to
PUBLIC	?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::capacity
PUBLIC	?_Xlen@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Xlen
PUBLIC	?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::max_size
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?_Reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXI@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEII@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXI@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z ; std::allocator<OFFMODE_BLOCK_MAP>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?_Tidy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXXZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 02	 sar	 edx, 2
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z ; std::allocator<OFFMODE_BLOCK_MAP>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXXZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Tidy
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXPAUOFFMODE_BLOCK_MAP@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXPAUOFFMODE_BLOCK_MAP@@0@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXPAUOFFMODE_BLOCK_MAP@@0@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@ABV01@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??0?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@V?$allocator@UOFFMODE_BLOCK_MAP@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@V?$allocator@UOFFMODE_BLOCK_MAP@@@1@@Z PROC ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@ABV01@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@V?$allocator@UOFFMODE_BLOCK_MAP@@@1@@Z ENDP ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::~_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@XZ PROC	; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@XZ ENDP	; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUOFFMODE_BLOCK_MAP@@@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEPAUOFFMODE_BLOCK_MAP@@PAU2@00@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Umove<OFFMODE_BLOCK_MAP *>
PUBLIC	?allocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEPAUOFFMODE_BLOCK_MAP@@I@Z ; std::allocator<OFFMODE_BLOCK_MAP>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$234276 = -28					; size = 4
__Ptr$234269 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEPAUOFFMODE_BLOCK_MAP@@I@Z ; std::allocator<OFFMODE_BLOCK_MAP>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$234269[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$234269[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUOFFMODE_BLOCK_MAP@@@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEPAUOFFMODE_BLOCK_MAP@@PAU2@00@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Umove<OFFMODE_BLOCK_MAP *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234269[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z ; std::allocator<OFFMODE_BLOCK_MAP>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$234276[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z ; std::allocator<OFFMODE_BLOCK_MAP>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234269[ebp]
  00114	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$234276[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234269[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234269[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QAEXI@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::reserve
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::capacity
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@2@@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QBEIXZ ; std::allocator<OFFMODE_BLOCK_MAP>::max_size
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QBEIXZ ; std::allocator<OFFMODE_BLOCK_MAP>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEXPAUOFFMODE_BLOCK_MAP@@0@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Destroy
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEII@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@QBEIXZ ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEII@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXXZ PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IBEXXZ ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Xlen
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@ABV01@@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::allocator<OFFMODE_BLOCK_MAP>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@I@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator==
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@IPAU1@@Z ; std::_Allocate<OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEPAUOFFMODE_BLOCK_MAP@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEPAUOFFMODE_BLOCK_MAP@@I@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@IPAU1@@Z ; std::_Allocate<OFFMODE_BLOCK_MAP>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEPAUOFFMODE_BLOCK_MAP@@I@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::allocate
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QBEIXZ PROC ; std::allocator<OFFMODE_BLOCK_MAP>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QBEIXZ ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QAE@PAUOFFMODE_BLOCK_MAP@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Compat
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::operator==
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> > >::_Compat
_TEXT	ENDS
EXTRN	_vsprintf_s:PROC
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 323  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, _Deref_post_z_ char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax
  0000f	8b 45 fc	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00016	51		 push	 ecx
  00017	68 00 01 00 00	 push	 256			; 00000100H
  0001c	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _vsprintf_s
  00025	83 c4 10	 add	 esp, 16			; 00000010H
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUOFFMODE_BLOCK_MAP@@@std@@YAPBUOFFMODE_BLOCK_MAP@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUOFFMODE_BLOCK_MAP@@@std@@YAPBUOFFMODE_BLOCK_MAP@@ABU1@@Z PROC ; std::addressof<OFFMODE_BLOCK_MAP const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUOFFMODE_BLOCK_MAP@@@std@@YAPBUOFFMODE_BLOCK_MAP@@ABU1@@Z ENDP ; std::addressof<OFFMODE_BLOCK_MAP const >
_TEXT	ENDS
PUBLIC	??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::construct<OFFMODE_BLOCK_MAP &>
PUBLIC	??$forward@AAUOFFMODE_BLOCK_MAP@@@std@@YAAAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::forward<OFFMODE_BLOCK_MAP &>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@AAU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@AAU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUOFFMODE_BLOCK_MAP@@@std@@YAAAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::forward<OFFMODE_BLOCK_MAP &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::construct<OFFMODE_BLOCK_MAP &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@AAU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@ABU3@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::construct
PUBLIC	??$forward@ABUOFFMODE_BLOCK_MAP@@@std@@YAABUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::forward<OFFMODE_BLOCK_MAP const &>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@ABU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@ABU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUOFFMODE_BLOCK_MAP@@@std@@YAABUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::forward<OFFMODE_BLOCK_MAP const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@ABU3@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@ABU3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>
PUBLIC	??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z ; std::_Ptr_cat<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00@Z
_TEXT	SEGMENT
$T235297 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00@Z PROC ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z ; std::_Ptr_cat<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235297[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235297[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00@Z ENDP ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z ; std::_Uninitialized_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP> >
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUOFFMODE_BLOCK_MAP@@@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEPAUOFFMODE_BLOCK_MAP@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUOFFMODE_BLOCK_MAP@@@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEPAUOFFMODE_BLOCK_MAP@@PAU2@00@Z PROC ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Umove<OFFMODE_BLOCK_MAP *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z ; std::_Uninitialized_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUOFFMODE_BLOCK_MAP@@@?$vector@UOFFMODE_BLOCK_MAP@@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@IAEPAUOFFMODE_BLOCK_MAP@@PAU2@00@Z ENDP ; std::vector<OFFMODE_BLOCK_MAP,std::allocator<OFFMODE_BLOCK_MAP> >::_Umove<OFFMODE_BLOCK_MAP *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z
_TEXT	SEGMENT
$T235302 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z PROC ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z ; std::_Ptr_cat<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235302[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235302[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ??$_Allocate@UOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@IPAU1@@Z
_TEXT	SEGMENT
$T235305 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@IPAU1@@Z PROC ; std::_Allocate<OFFMODE_BLOCK_MAP>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T235305[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T235305[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@IPAU1@@Z ENDP ; std::_Allocate<OFFMODE_BLOCK_MAP>
_TEXT	ENDS
PUBLIC	??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::_Construct<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@ABU3@@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::_Construct<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@ABU3@@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::construct
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUOFFMODE_BLOCK_MAP@@@std@@YAAAUOFFMODE_BLOCK_MAP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUOFFMODE_BLOCK_MAP@@@std@@YAAAUOFFMODE_BLOCK_MAP@@AAU1@@Z PROC ; std::forward<OFFMODE_BLOCK_MAP &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUOFFMODE_BLOCK_MAP@@@std@@YAAAUOFFMODE_BLOCK_MAP@@AAU1@@Z ENDP ; std::forward<OFFMODE_BLOCK_MAP &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235312 = -88						; size = 4
$T235313 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::construct<OFFMODE_BLOCK_MAP &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235313[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235313[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUOFFMODE_BLOCK_MAP@@@std@@YAAAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::forward<OFFMODE_BLOCK_MAP &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 45 ac	 mov	 eax, DWORD PTR $T235313[ebp]
  0005a	89 10		 mov	 DWORD PTR [eax], edx
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T235313[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T235312[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235313[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUOFFMODE_BLOCK_MAP@@@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@AAU2@@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::construct<OFFMODE_BLOCK_MAP &>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUOFFMODE_BLOCK_MAP@@@std@@YAABUOFFMODE_BLOCK_MAP@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUOFFMODE_BLOCK_MAP@@@std@@YAABUOFFMODE_BLOCK_MAP@@ABU1@@Z PROC ; std::forward<OFFMODE_BLOCK_MAP const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUOFFMODE_BLOCK_MAP@@@std@@YAABUOFFMODE_BLOCK_MAP@@ABU1@@Z ENDP ; std::forward<OFFMODE_BLOCK_MAP const &>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z PROC ; std::_Ptr_cat<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z ENDP ; std::_Ptr_cat<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
_TEXT	ENDS
PUBLIC	??$move@AAUOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::move<OFFMODE_BLOCK_MAP &>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 04	 add	 eax, 4
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 04	 add	 ecx, 4
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 15		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::move<OFFMODE_BLOCK_MAP &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00036	89 0a		 mov	 DWORD PTR [edx], ecx
  00038	eb d1		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Move@PAUOFFMODE_BLOCK_MAP@@PAU1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
PUBLIC	??$_Val_type@PAUOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@@Z ; std::_Val_type<OFFMODE_BLOCK_MAP *>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z
_TEXT	SEGMENT
$T235335 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z PROC ; std::_Uninitialized_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UOFFMODE_BLOCK_MAP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUOFFMODE_BLOCK_MAP@@0@Z ; std::_Ptr_cat<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T235335[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T235335[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@@Z ; std::_Val_type<OFFMODE_BLOCK_MAP *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@@Z ENDP ; std::_Uninitialized_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@@Z ; std::_Dest_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 04	 add	 eax, 4
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@@Z ; std::_Dest_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@0AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<OFFMODE_BLOCK_MAP> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235340 = -88						; size = 4
$T235341 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z PROC ; std::_Construct<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T235341[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T235341[ebp], 0
  0004a	74 1b		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUOFFMODE_BLOCK_MAP@@@std@@YAABUOFFMODE_BLOCK_MAP@@ABU1@@Z ; std::forward<OFFMODE_BLOCK_MAP const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 45 ac	 mov	 eax, DWORD PTR $T235341[ebp]
  0005d	89 10		 mov	 DWORD PTR [eax], edx
  0005f	8b 4d ac	 mov	 ecx, DWORD PTR $T235341[ebp]
  00062	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00065	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00067	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  0006e	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00071	89 55 a8	 mov	 DWORD PTR $T235340[ebp], edx
  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235341[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UOFFMODE_BLOCK_MAP@@ABU1@@std@@YAXPAUOFFMODE_BLOCK_MAP@@ABU1@@Z ENDP ; std::_Construct<OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP const &>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z PROC ; std::move<OFFMODE_BLOCK_MAP &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ENDP ; std::move<OFFMODE_BLOCK_MAP &>
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@@Z PROC ; std::_Val_type<OFFMODE_BLOCK_MAP *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUOFFMODE_BLOCK_MAP@@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@@Z ENDP ; std::_Val_type<OFFMODE_BLOCK_MAP *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@U3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@$$QAU2@@Z ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 04	 add	 ecx, 4
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@U3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@$$QAU2@@Z ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 04	 add	 eax, 4
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@@Z ; std::_Dest_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUOFFMODE_BLOCK_MAP@@PAU1@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@U1@@std@@YAPAUOFFMODE_BLOCK_MAP@@PAU1@00AAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<OFFMODE_BLOCK_MAP *,OFFMODE_BLOCK_MAP *,std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
PUBLIC	?destroy@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::destroy
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@@Z PROC ; std::_Dest_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@@Z ENDP ; std::_Dest_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP>
_TEXT	ENDS
PUBLIC	??$_Destroy@UOFFMODE_BLOCK_MAP@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@@Z ; std::_Destroy<OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ?destroy@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UOFFMODE_BLOCK_MAP@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@@Z ; std::_Destroy<OFFMODE_BLOCK_MAP>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::construct
PUBLIC	??$forward@UOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::forward<OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@U3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@U3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::forward<OFFMODE_BLOCK_MAP>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z ; std::allocator<OFFMODE_BLOCK_MAP>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UOFFMODE_BLOCK_MAP@@@std@@UOFFMODE_BLOCK_MAP@@U3@@std@@YAXAAV?$allocator@UOFFMODE_BLOCK_MAP@@@0@PAUOFFMODE_BLOCK_MAP@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<OFFMODE_BLOCK_MAP>,OFFMODE_BLOCK_MAP,OFFMODE_BLOCK_MAP>
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ??$_Destroy@UOFFMODE_BLOCK_MAP@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UOFFMODE_BLOCK_MAP@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@@Z PROC ; std::_Destroy<OFFMODE_BLOCK_MAP>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UOFFMODE_BLOCK_MAP@@@std@@YAXPAUOFFMODE_BLOCK_MAP@@@Z ENDP ; std::_Destroy<OFFMODE_BLOCK_MAP>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI /ZX
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T235380 = -88						; size = 4
$T235381 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z PROC ; std::allocator<OFFMODE_BLOCK_MAP>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T235381[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T235381[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ; std::forward<OFFMODE_BLOCK_MAP>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 45 ac	 mov	 eax, DWORD PTR $T235381[ebp]
  0005a	89 10		 mov	 DWORD PTR [eax], edx
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T235381[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T235380[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T235381[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UOFFMODE_BLOCK_MAP@@@std@@QAEXPAUOFFMODE_BLOCK_MAP@@$$QAU3@@Z ENDP ; std::allocator<OFFMODE_BLOCK_MAP>::construct
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z PROC ; std::forward<OFFMODE_BLOCK_MAP>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UOFFMODE_BLOCK_MAP@@@std@@YA$$QAUOFFMODE_BLOCK_MAP@@AAU1@@Z ENDP ; std::forward<OFFMODE_BLOCK_MAP>
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	51		 push	 ecx
  0000a	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  0000d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00010	e8 00 00 00 00	 call	 _sqrtf
  00015	83 c4 04	 add	 esp, 4
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  0000c	83 ec 08	 sub	 esp, 8
  0000f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00012	e8 00 00 00 00	 call	 _sqrt
  00017	83 c4 08	 add	 esp, 8
  0001a	d9 5d bc	 fstp	 DWORD PTR tv73[ebp]
  0001d	d9 45 bc	 fld	 DWORD PTR tv73[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI /ZX
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI /ZX
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI /ZX
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI /ZX
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI /ZX
; File d:\projects\exteam6.3\source\gameserver\gameserver\offlinemode.cpp
;	COMDAT ??__Eg_OfflineMode@@YAXXZ
text$yc	SEGMENT
??__Eg_OfflineMode@@YAXXZ PROC				; `dynamic initializer for 'g_OfflineMode'', COMDAT

; 31   : OfflineMode g_OfflineMode;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  0000e	e8 00 00 00 00	 call	 ??0OfflineMode@@QAE@XZ	; OfflineMode::OfflineMode
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_OfflineMode@@YAXXZ ; `dynamic atexit destructor for 'g_OfflineMode''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_OfflineMode@@YAXXZ ENDP				; `dynamic initializer for 'g_OfflineMode''
; Function compile flags: /Odtp /ZI /ZX
text$yc	ENDS
;	COMDAT ??__Fg_OfflineMode@@YAXXZ
text$yd	SEGMENT
??__Fg_OfflineMode@@YAXXZ PROC				; `dynamic atexit destructor for 'g_OfflineMode'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  0000e	e8 00 00 00 00	 call	 ??1OfflineMode@@QAE@XZ	; OfflineMode::~OfflineMode
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_OfflineMode@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_OfflineMode''
text$yd	ENDS
PUBLIC	?g_OfflineMode@@3VOfflineMode@@A		; g_OfflineMode
_BSS	SEGMENT
?g_OfflineMode@@3VOfflineMode@@A DB 038H DUP (?)	; g_OfflineMode
_BSS	ENDS
CRT$XCU	SEGMENT
_g_OfflineMode$initializer$ DD FLAT:??__Eg_OfflineMode@@YAXXZ
CRT$XCU	ENDS
END
