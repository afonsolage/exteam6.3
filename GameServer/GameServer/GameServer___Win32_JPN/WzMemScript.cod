; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\common\WzMemScript.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7CWzMemScript@@6B@				; CWzMemScript::`vftable'
PUBLIC	??0CWzMemScript@@QAE@XZ				; CWzMemScript::CWzMemScript
PUBLIC	??_R4CWzMemScript@@6B@				; CWzMemScript::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCWzMemScript@@@8			; CWzMemScript `RTTI Type Descriptor'
PUBLIC	??_R3CWzMemScript@@8				; CWzMemScript::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWzMemScript@@8				; CWzMemScript::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWzMemScript@@8			; CWzMemScript::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECWzMemScript@@UAEPAXI@Z:PROC		; CWzMemScript::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CWzMemScript@@8
; File d:\projects\exteam6.3\source\gameserver\common\wzmemscript.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CWzMemScript@@8 DD FLAT:??_R0?AVCWzMemScript@@@8 ; CWzMemScript::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWzMemScript@@8
rdata$r	ENDS
;	COMDAT ??_R2CWzMemScript@@8
rdata$r	SEGMENT
??_R2CWzMemScript@@8 DD FLAT:??_R1A@?0A@EA@CWzMemScript@@8 ; CWzMemScript::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWzMemScript@@8
rdata$r	SEGMENT
??_R3CWzMemScript@@8 DD 00H				; CWzMemScript::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWzMemScript@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWzMemScript@@@8
_DATA	SEGMENT
??_R0?AVCWzMemScript@@@8 DD FLAT:??_7type_info@@6B@	; CWzMemScript `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWzMemScript@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CWzMemScript@@6B@
rdata$r	SEGMENT
??_R4CWzMemScript@@6B@ DD 00H				; CWzMemScript::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCWzMemScript@@@8
	DD	FLAT:??_R3CWzMemScript@@8
rdata$r	ENDS
;	COMDAT ??_7CWzMemScript@@6B@
CONST	SEGMENT
??_7CWzMemScript@@6B@ DD FLAT:??_R4CWzMemScript@@6B@	; CWzMemScript::`vftable'
	DD	FLAT:??_ECWzMemScript@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CWzMemScript@@QAE@XZ PROC				; CWzMemScript::CWzMemScript
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWzMemScript@@6B@

; 6    : 	return;
; 7    : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CWzMemScript@@QAE@XZ ENDP				; CWzMemScript::CWzMemScript
_TEXT	ENDS
PUBLIC	??1CWzMemScript@@UAE@XZ				; CWzMemScript::~CWzMemScript
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCWzMemScript@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCWzMemScript@@UAEPAXI@Z PROC			; CWzMemScript::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCWzMemScript@@UAEPAXI@Z ENDP			; CWzMemScript::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CWzMemScript@@UAE@XZ PROC				; CWzMemScript::~CWzMemScript
; _this$ = ecx

; 10   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWzMemScript@@6B@

; 11   : 	return;
; 12   : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1CWzMemScript@@UAE@XZ ENDP				; CWzMemScript::~CWzMemScript
_TEXT	ENDS
PUBLIC	?SetScriptParsingBuffer@CWzMemScript@@QAEXPADH@Z ; CWzMemScript::SetScriptParsingBuffer
PUBLIC	?SetBuffer@CWzMemScript@@QAEHPADH@Z		; CWzMemScript::SetBuffer
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_buffer$ = 8						; size = 4
_buffersize$ = 12					; size = 4
?SetBuffer@CWzMemScript@@QAEHPADH@Z PROC		; CWzMemScript::SetBuffer
; _this$ = ecx

; 15   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 16   : 	this->SetScriptParsingBuffer(buffer, buffersize);

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _buffersize$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00053	51		 push	 ecx
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?SetScriptParsingBuffer@CWzMemScript@@QAEXPADH@Z ; CWzMemScript::SetScriptParsingBuffer

; 17   : 	return 1;

  0005c	b8 01 00 00 00	 mov	 eax, 1

; 18   : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?SetBuffer@CWzMemScript@@QAEHPADH@Z ENDP		; CWzMemScript::SetBuffer
_TEXT	ENDS
PUBLIC	?GetC@CWzMemScript@@IAEHXZ			; CWzMemScript::GetC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv74 = -72						; size = 4
_this$ = -4						; size = 4
?GetC@CWzMemScript@@IAEHXZ PROC				; CWzMemScript::GetC
; _this$ = ecx

; 22   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	83 ec 48	 sub	 esp, 72			; 00000048H
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 	if ( this->m_iBufferCount >= this->m_iBufferSize )

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00085	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00088	7c 07		 jl	 SHORT $LN2@GetC

; 24   : 	{
; 25   : 		return -1;

  0008a	83 c8 ff	 or	 eax, -1
  0008d	eb 27		 jmp	 SHORT $LN3@GetC

; 26   : 	}
; 27   : 	else

  0008f	eb 25		 jmp	 SHORT $LN3@GetC
$LN2@GetC:

; 28   : 	{
; 29   : 		return this->m_pBuffer[ this->m_iBufferCount++ ];

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0009d	0f be 0c 01	 movsx	 ecx, BYTE PTR [ecx+eax]
  000a1	89 4d b8	 mov	 DWORD PTR tv74[ebp], ecx
  000a4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000aa	83 c0 01	 add	 eax, 1
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000b3	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]
$LN3@GetC:

; 30   : 	}
; 31   : }

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?GetC@CWzMemScript@@IAEHXZ ENDP				; CWzMemScript::GetC
_TEXT	ENDS
PUBLIC	?UnGetC@CWzMemScript@@IAEXH@Z			; CWzMemScript::UnGetC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ch$ = 8						; size = 4
?UnGetC@CWzMemScript@@IAEXH@Z PROC			; CWzMemScript::UnGetC
; _this$ = ecx

; 36   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 44	 sub	 esp, 68			; 00000044H
  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	57		 push	 edi
  000c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 37   : 	if ( this->m_iBufferCount <= 0)

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000d3	7f 04		 jg	 SHORT $LN2@UnGetC

; 38   : 	{
; 39   : 		return;

  000d5	eb 23		 jmp	 SHORT $LN3@UnGetC

; 40   : 	}
; 41   : 	else

  000d7	eb 21		 jmp	 SHORT $LN3@UnGetC
$LN2@UnGetC:

; 42   : 	{
; 43   : 		this->m_iBufferCount--;

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000df	83 e9 01	 sub	 ecx, 1
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e5	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 44   : 
; 45   : 		this->m_pBuffer [ this->m_iBufferCount ] = ch;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000f4	8a 55 08	 mov	 dl, BYTE PTR _ch$[ebp]
  000f7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
$LN3@UnGetC:

; 46   : 	}
; 47   : }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
?UnGetC@CWzMemScript@@IAEXH@Z ENDP			; CWzMemScript::UnGetC
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
?SetScriptParsingBuffer@CWzMemScript@@QAEXPADH@Z PROC	; CWzMemScript::SetScriptParsingBuffer
; _this$ = ecx

; 51   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	83 ec 44	 sub	 esp, 68			; 00000044H
  00116	53		 push	 ebx
  00117	56		 push	 esi
  00118	57		 push	 edi
  00119	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   : 	this->m_pBuffer = buffer;

  0011c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00122	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 53   : 	this->m_iBufferSize = size;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0012b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 54   : 	this->m_iBufferCount = 0;

  0012e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00131	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 55   : }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
?SetScriptParsingBuffer@CWzMemScript@@QAEXPADH@Z ENDP	; CWzMemScript::SetScriptParsingBuffer
_TEXT	ENDS
PUBLIC	?GetNumber@CWzMemScript@@QAEHXZ			; CWzMemScript::GetNumber
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumber@CWzMemScript@@QAEHXZ PROC			; CWzMemScript::GetNumber
; _this$ = ecx

; 59   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	83 ec 44	 sub	 esp, 68			; 00000044H
  00156	53		 push	 ebx
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 	return (int)this->TokenNumber;

  0015c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015f	d9 40 18	 fld	 DWORD PTR [eax+24]
  00162	e8 00 00 00 00	 call	 __ftol2_sse

; 61   : }

  00167	5f		 pop	 edi
  00168	5e		 pop	 esi
  00169	5b		 pop	 ebx
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
?GetNumber@CWzMemScript@@QAEHXZ ENDP			; CWzMemScript::GetNumber
_TEXT	ENDS
PUBLIC	?GetString@CWzMemScript@@QAEPADXZ		; CWzMemScript::GetString
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetString@CWzMemScript@@QAEPADXZ PROC			; CWzMemScript::GetString
; _this$ = ecx

; 64   : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	83 ec 44	 sub	 esp, 68			; 00000044H
  00176	53		 push	 ebx
  00177	56		 push	 esi
  00178	57		 push	 edi
  00179	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 	return &this->TokenString[0];

  0017c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017f	83 c0 1c	 add	 eax, 28			; 0000001cH

; 66   : }

  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
?GetString@CWzMemScript@@QAEPADXZ ENDP			; CWzMemScript::GetString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ	; CWzMemScript::GetToken
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv88 = -184						; size = 4
_TempString$ = -116					; size = 100
_p$ = -16						; size = 4
_ch$ = -9						; size = 1
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ PROC	; CWzMemScript::GetToken
; _this$ = ecx

; 69   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0019e	33 c5		 xor	 eax, ebp
  001a0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001a3	53		 push	 ebx
  001a4	56		 push	 esi
  001a5	57		 push	 edi
  001a6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 	char ch;
; 71   : 	char* p;
; 72   : 	char TempString[100];
; 73   : 
; 74   : 	this->TokenString[0]=0;

  001a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001ac	c6 40 1c 00	 mov	 BYTE PTR [eax+28], 0
$LN30@GetToken:

; 75   : 
; 76   : 	do
; 77   : 	{
; 78   : 		if ( (ch=this->GetC ()) == (-1) )

  001b0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ?GetC@CWzMemScript@@IAEHXZ ; CWzMemScript::GetC
  001b8	88 45 f7	 mov	 BYTE PTR _ch$[ebp], al
  001bb	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  001bf	83 f8 ff	 cmp	 eax, -1
  001c2	75 0c		 jne	 SHORT $LN27@GetToken

; 79   : 		{
; 80   : 			return END;

  001c4	b8 02 00 00 00	 mov	 eax, 2
  001c9	e9 be 02 00 00	 jmp	 $LN20@GetToken

; 81   : 		}
; 82   : 		else

  001ce	eb 35		 jmp	 SHORT $LN22@GetToken
$LN27@GetToken:

; 83   : 		{	
; 84   : 			if (ch=='/')

  001d0	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  001d4	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  001d7	75 2c		 jne	 SHORT $LN22@GetToken

; 85   : 			{
; 86   : 				if((ch=this->GetC ()) == '/')

  001d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	e8 00 00 00 00	 call	 ?GetC@CWzMemScript@@IAEHXZ ; CWzMemScript::GetC
  001e1	88 45 f7	 mov	 BYTE PTR _ch$[ebp], al
  001e4	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  001e8	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  001eb	75 18		 jne	 SHORT $LN22@GetToken
$LN23@GetToken:

; 87   : 				{
; 88   : 					while ( ((ch=this->GetC()) != ('\n')) )

  001ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f0	e8 00 00 00 00	 call	 ?GetC@CWzMemScript@@IAEHXZ ; CWzMemScript::GetC
  001f5	88 45 f7	 mov	 BYTE PTR _ch$[ebp], al
  001f8	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  001fc	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001ff	74 04		 je	 SHORT $LN22@GetToken

; 89   : 					{
; 90   : 						continue;

  00201	eb ea		 jmp	 SHORT $LN23@GetToken

; 91   : 					}

  00203	eb e8		 jmp	 SHORT $LN23@GetToken
$LN22@GetToken:

; 92   : 				}
; 93   : 			}
; 94   : 		}
; 95   : 	}
; 96   : 	while (isspace(ch) != 0);

  00205	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 _isspace
  0020f	83 c4 04	 add	 esp, 4
  00212	85 c0		 test	 eax, eax
  00214	75 9a		 jne	 SHORT $LN30@GetToken

; 97   : 
; 98   : 	switch(ch)

  00216	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  0021a	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  00220	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv88[ebp]
  00226	83 e9 22	 sub	 ecx, 34			; 00000022H
  00229	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv88[ebp], ecx
  0022f	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv88[ebp], 91	; 0000005bH
  00236	0f 87 9f 01 00
	00		 ja	 $LN6@GetToken
  0023c	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv88[ebp]
  00242	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  00249	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN19@GetToken:

; 99   : 	{
; 100  : 
; 101  : 	case 0x23:	// #
; 102  : 		return this->CurrentToken=COMMAND;

  00250	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00253	c7 80 80 00 00
	00 23 00 00 00	 mov	 DWORD PTR [eax+128], 35	; 00000023H
  0025d	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  00262	e9 25 02 00 00	 jmp	 $LN20@GetToken

; 103  : 		break;

  00267	e9 20 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 104  : 	
; 105  : 	case 0x3B:	// ;
; 106  : 		return this->CurrentToken=SEMICOLON;

  0026c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	c7 80 80 00 00
	00 3b 00 00 00	 mov	 DWORD PTR [eax+128], 59	; 0000003bH
  00279	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  0027e	e9 09 02 00 00	 jmp	 $LN20@GetToken

; 107  : 		break;

  00283	e9 04 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 108  : 	
; 109  : 	case 0x2C:	// ,
; 110  : 
; 111  : 		return this->CurrentToken=COMMA;

  00288	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	c7 80 80 00 00
	00 2c 00 00 00	 mov	 DWORD PTR [eax+128], 44	; 0000002cH
  00295	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  0029a	e9 ed 01 00 00	 jmp	 $LN20@GetToken

; 112  : 		break;

  0029f	e9 e8 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 113  : 	
; 114  : 	case 0x7B:	// {
; 115  : 		return this->CurrentToken = LP;

  002a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002a7	c7 80 80 00 00
	00 7b 00 00 00	 mov	 DWORD PTR [eax+128], 123 ; 0000007bH
  002b1	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  002b6	e9 d1 01 00 00	 jmp	 $LN20@GetToken

; 116  : 		break;

  002bb	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 117  : 
; 118  : 	case 0x7D:	// }
; 119  : 		return this->CurrentToken = RP;

  002c0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002c3	c7 80 80 00 00
	00 7d 00 00 00	 mov	 DWORD PTR [eax+128], 125 ; 0000007dH
  002cd	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  002d2	e9 b5 01 00 00	 jmp	 $LN20@GetToken

; 120  : 		break;

  002d7	e9 b0 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 121  : 
; 122  : 	case 0x2D:	//-
; 123  : 	case 0x2E:	//.
; 124  : 	case 0x30:	//0
; 125  : 	case 0x31:	//1
; 126  : 	case 0x32:	//2
; 127  : 	case 0x33:	//3
; 128  : 	case 0x34:	//4		
; 129  : 	case 0x35:	//5
; 130  : 	case 0x36:	//6
; 131  : 	case 0x37:	//7
; 132  : 	case 0x38:	//8
; 133  : 	case 0x39:	//9
; 134  : 		this->UnGetC (ch);

  002dc	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  002e0	50		 push	 eax
  002e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	e8 00 00 00 00	 call	 ?UnGetC@CWzMemScript@@IAEXH@Z ; CWzMemScript::UnGetC

; 135  : 		p = TempString;

  002e9	8d 45 8c	 lea	 eax, DWORD PTR _TempString$[ebp]
  002ec	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 136  : 		
; 137  : 		while (((ch=this->GetC()) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D))) 

  002ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f2	e8 00 00 00 00	 call	 ?GetC@CWzMemScript@@IAEHXZ ; CWzMemScript::GetC
  002f7	88 45 f7	 mov	 BYTE PTR _ch$[ebp], al
  002fa	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  002fe	83 f8 ff	 cmp	 eax, -1
  00301	74 36		 je	 SHORT $LN12@GetToken
  00303	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00307	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0030a	74 1a		 je	 SHORT $LN11@GetToken
  0030c	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00310	50		 push	 eax
  00311	e8 00 00 00 00	 call	 _isdigit
  00316	83 c4 04	 add	 esp, 4
  00319	85 c0		 test	 eax, eax
  0031b	75 09		 jne	 SHORT $LN11@GetToken
  0031d	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00321	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00324	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 138  : 		{
; 139  : 			*p = ch;

  00326	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00329	8a 4d f7	 mov	 cl, BYTE PTR _ch$[ebp]
  0032c	88 08		 mov	 BYTE PTR [eax], cl

; 140  : 			p++;

  0032e	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00331	83 c0 01	 add	 eax, 1
  00334	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 141  : 		}		

  00337	eb b6		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 142  : 		*p = 0;

  00339	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0033c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 143  : 		this->TokenNumber = atof( TempString);

  0033f	8d 45 8c	 lea	 eax, DWORD PTR _TempString$[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 _atof
  00348	83 c4 04	 add	 esp, 4
  0034b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034e	d9 59 18	 fstp	 DWORD PTR [ecx+24]

; 144  : 		return this->CurrentToken  = NUMBER ;

  00351	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00354	c7 80 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+128], 1
  0035e	b8 01 00 00 00	 mov	 eax, 1
  00363	e9 24 01 00 00	 jmp	 $LN20@GetToken

; 145  : 		break;

  00368	e9 1f 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 146  : 
; 147  : 	case 0x22:	// "	
; 148  : 		p=&this->TokenString[0];

  0036d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00370	83 c0 1c	 add	 eax, 28			; 0000001cH
  00373	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 149  : 		
; 150  : 		while (((ch=this->GetC() ) != -1 ) && (ch != 0x22))

  00376	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00379	e8 00 00 00 00	 call	 ?GetC@CWzMemScript@@IAEHXZ ; CWzMemScript::GetC
  0037e	88 45 f7	 mov	 BYTE PTR _ch$[ebp], al
  00381	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00385	83 f8 ff	 cmp	 eax, -1
  00388	74 1c		 je	 SHORT $LN8@GetToken
  0038a	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  0038e	83 f8 22	 cmp	 eax, 34			; 00000022H
  00391	74 13		 je	 SHORT $LN8@GetToken

; 151  : 		{
; 152  : 			*p = ch;

  00393	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00396	8a 4d f7	 mov	 cl, BYTE PTR _ch$[ebp]
  00399	88 08		 mov	 BYTE PTR [eax], cl

; 153  : 			p++;

  0039b	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0039e	83 c0 01	 add	 eax, 1
  003a1	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 154  : 		}

  003a4	eb d0		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 155  : 		if (ch != 0x22 )

  003a6	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  003aa	83 f8 22	 cmp	 eax, 34			; 00000022H
  003ad	74 0d		 je	 SHORT $LN7@GetToken

; 156  : 		{
; 157  : 			this->UnGetC(ch);

  003af	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  003b3	50		 push	 eax
  003b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003b7	e8 00 00 00 00	 call	 ?UnGetC@CWzMemScript@@IAEXH@Z ; CWzMemScript::UnGetC
$LN7@GetToken:

; 158  : 		}
; 159  : 		*p = 0;

  003bc	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  003bf	c6 00 00	 mov	 BYTE PTR [eax], 0

; 160  : 		return this->CurrentToken = NAME;

  003c2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c5	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+128], 0
  003cf	33 c0		 xor	 eax, eax
  003d1	e9 b6 00 00 00	 jmp	 $LN20@GetToken

; 161  : 		break;

  003d6	e9 b1 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 162  : 
; 163  : 	default:	
; 164  : 		if (isalpha(ch))

  003db	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  003df	50		 push	 eax
  003e0	e8 00 00 00 00	 call	 _isalpha
  003e5	83 c4 04	 add	 esp, 4
  003e8	85 c0		 test	 eax, eax
  003ea	0f 84 8a 00 00
	00		 je	 $LN5@GetToken

; 165  : 		{
; 166  : 			p=&this->TokenString[0];

  003f0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f3	83 c0 1c	 add	 eax, 28			; 0000001cH
  003f6	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 167  : 			*p=ch;

  003f9	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  003fc	8a 4d f7	 mov	 cl, BYTE PTR _ch$[ebp]
  003ff	88 08		 mov	 BYTE PTR [eax], cl

; 168  : 			p++;

  00401	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00404	83 c0 01	 add	 eax, 1
  00407	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 169  : 
; 170  : 			while ( ((ch=this->GetC() ) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  0040a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0040d	e8 00 00 00 00	 call	 ?GetC@CWzMemScript@@IAEHXZ ; CWzMemScript::GetC
  00412	88 45 f7	 mov	 BYTE PTR _ch$[ebp], al
  00415	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00419	83 f8 ff	 cmp	 eax, -1
  0041c	74 36		 je	 SHORT $LN3@GetToken
  0041e	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00422	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00425	74 1a		 je	 SHORT $LN2@GetToken
  00427	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  0042b	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0042e	74 11		 je	 SHORT $LN2@GetToken
  00430	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 _isalnum
  0043a	83 c4 04	 add	 esp, 4
  0043d	85 c0		 test	 eax, eax
  0043f	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 171  : 			{
; 172  : 				*p=ch;

  00441	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00444	8a 4d f7	 mov	 cl, BYTE PTR _ch$[ebp]
  00447	88 08		 mov	 BYTE PTR [eax], cl

; 173  : 				p++;

  00449	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0044c	83 c0 01	 add	 eax, 1
  0044f	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 174  : 				
; 175  : 			}

  00452	eb b6		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 176  : 
; 177  : 			this->UnGetC(ch);

  00454	0f be 45 f7	 movsx	 eax, BYTE PTR _ch$[ebp]
  00458	50		 push	 eax
  00459	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0045c	e8 00 00 00 00	 call	 ?UnGetC@CWzMemScript@@IAEXH@Z ; CWzMemScript::UnGetC

; 178  : 			*p=0;

  00461	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00464	c6 00 00	 mov	 BYTE PTR [eax], 0

; 179  : 			this->CurrentToken=NAME;

  00467	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0046a	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+128], 0

; 180  : 			return NAME;

  00474	33 c0		 xor	 eax, eax
  00476	eb 14		 jmp	 SHORT $LN20@GetToken

; 181  : 		}
; 182  : 		else

  00478	eb 12		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 183  : 		{
; 184  : 			return this->CurrentToken = SMD_ERROR;

  0047a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0047d	c7 80 80 00 00
	00 3c 00 00 00	 mov	 DWORD PTR [eax+128], 60	; 0000003cH
  00487	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN1@GetToken:
$LN20@GetToken:

; 185  : 		}
; 186  : 		break;
; 187  : 
; 188  : 	}
; 189  : 
; 190  : }

  0048c	5f		 pop	 edi
  0048d	5e		 pop	 esi
  0048e	5b		 pop	 ebx
  0048f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00492	33 cd		 xor	 ecx, ebp
  00494	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00499	8b e5		 mov	 esp, ebp
  0049b	5d		 pop	 ebp
  0049c	c3		 ret	 0
  0049d	8d 49 00	 npad	 3
$LN34@GetToken:
  004a0	00 00 00 00	 DD	 $LN10@GetToken
  004a4	00 00 00 00	 DD	 $LN19@GetToken
  004a8	00 00 00 00	 DD	 $LN17@GetToken
  004ac	00 00 00 00	 DD	 $LN14@GetToken
  004b0	00 00 00 00	 DD	 $LN18@GetToken
  004b4	00 00 00 00	 DD	 $LN16@GetToken
  004b8	00 00 00 00	 DD	 $LN15@GetToken
  004bc	00 00 00 00	 DD	 $LN6@GetToken
$LN33@GetToken:
  004c0	00		 DB	 0
  004c1	01		 DB	 1
  004c2	07		 DB	 7
  004c3	07		 DB	 7
  004c4	07		 DB	 7
  004c5	07		 DB	 7
  004c6	07		 DB	 7
  004c7	07		 DB	 7
  004c8	07		 DB	 7
  004c9	07		 DB	 7
  004ca	02		 DB	 2
  004cb	03		 DB	 3
  004cc	03		 DB	 3
  004cd	07		 DB	 7
  004ce	03		 DB	 3
  004cf	03		 DB	 3
  004d0	03		 DB	 3
  004d1	03		 DB	 3
  004d2	03		 DB	 3
  004d3	03		 DB	 3
  004d4	03		 DB	 3
  004d5	03		 DB	 3
  004d6	03		 DB	 3
  004d7	03		 DB	 3
  004d8	07		 DB	 7
  004d9	04		 DB	 4
  004da	07		 DB	 7
  004db	07		 DB	 7
  004dc	07		 DB	 7
  004dd	07		 DB	 7
  004de	07		 DB	 7
  004df	07		 DB	 7
  004e0	07		 DB	 7
  004e1	07		 DB	 7
  004e2	07		 DB	 7
  004e3	07		 DB	 7
  004e4	07		 DB	 7
  004e5	07		 DB	 7
  004e6	07		 DB	 7
  004e7	07		 DB	 7
  004e8	07		 DB	 7
  004e9	07		 DB	 7
  004ea	07		 DB	 7
  004eb	07		 DB	 7
  004ec	07		 DB	 7
  004ed	07		 DB	 7
  004ee	07		 DB	 7
  004ef	07		 DB	 7
  004f0	07		 DB	 7
  004f1	07		 DB	 7
  004f2	07		 DB	 7
  004f3	07		 DB	 7
  004f4	07		 DB	 7
  004f5	07		 DB	 7
  004f6	07		 DB	 7
  004f7	07		 DB	 7
  004f8	07		 DB	 7
  004f9	07		 DB	 7
  004fa	07		 DB	 7
  004fb	07		 DB	 7
  004fc	07		 DB	 7
  004fd	07		 DB	 7
  004fe	07		 DB	 7
  004ff	07		 DB	 7
  00500	07		 DB	 7
  00501	07		 DB	 7
  00502	07		 DB	 7
  00503	07		 DB	 7
  00504	07		 DB	 7
  00505	07		 DB	 7
  00506	07		 DB	 7
  00507	07		 DB	 7
  00508	07		 DB	 7
  00509	07		 DB	 7
  0050a	07		 DB	 7
  0050b	07		 DB	 7
  0050c	07		 DB	 7
  0050d	07		 DB	 7
  0050e	07		 DB	 7
  0050f	07		 DB	 7
  00510	07		 DB	 7
  00511	07		 DB	 7
  00512	07		 DB	 7
  00513	07		 DB	 7
  00514	07		 DB	 7
  00515	07		 DB	 7
  00516	07		 DB	 7
  00517	07		 DB	 7
  00518	07		 DB	 7
  00519	05		 DB	 5
  0051a	07		 DB	 7
  0051b	06		 DB	 6
?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ENDP	; CWzMemScript::GetToken
_TEXT	ENDS
END
