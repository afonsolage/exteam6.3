; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MonsterEx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0MonsterEx@@QAE@XZ				; MonsterEx::MonsterEx
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monsterex.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MonsterEx@@QAE@XZ PROC				; MonsterEx::MonsterEx
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 17   : }

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MonsterEx@@QAE@XZ ENDP				; MonsterEx::MonsterEx
_TEXT	ENDS
PUBLIC	??1MonsterEx@@QAE@XZ				; MonsterEx::~MonsterEx
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MonsterEx@@QAE@XZ PROC				; MonsterEx::~MonsterEx
; _this$ = ecx

; 21   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 22   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1MonsterEx@@QAE@XZ ENDP				; MonsterEx::~MonsterEx
_TEXT	ENDS
PUBLIC	?Init@MonsterEx@@QAEXXZ				; MonsterEx::Init
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@MonsterEx@@QAEXXZ PROC				; MonsterEx::Init
; _this$ = ecx

; 26   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 	ZeroMemory(this->mobdata,sizeof(this->mobdata));

  0004c	68 00 30 00 00	 push	 12288			; 00003000H
  00051	6a 00		 push	 0
  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _memset
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28   : 
; 29   : 	this->mobLoaded = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 80 00 30 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+12288], 0

; 30   : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?Init@MonsterEx@@QAEXXZ ENDP				; MonsterEx::Init
_TEXT	ENDS
PUBLIC	?Read@MonsterEx@@QAEXPAD@Z			; MonsterEx::Read
PUBLIC	??_C@_0BF@DDILOELG@ExData?2MonsterEx?4ini?$AA@	; `string'
PUBLIC	?Load@MonsterEx@@QAEXXZ				; MonsterEx::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0BF@DDILOELG@ExData?2MonsterEx?4ini?$AA@
CONST	SEGMENT
??_C@_0BF@DDILOELG@ExData?2MonsterEx?4ini?$AA@ DB 'ExData\MonsterEx.ini', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@MonsterEx@@QAEXXZ PROC				; MonsterEx::Load
; _this$ = ecx

; 34   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 44	 sub	 esp, 68			; 00000044H
  00086	53		 push	 ebx
  00087	56		 push	 esi
  00088	57		 push	 edi
  00089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	this->Init();

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?Init@MonsterEx@@QAEXXZ	; MonsterEx::Init

; 36   : 
; 37   : 	if(!g_ExLicense.user.MonsterAttackLife)

  00094	0f b6 05 e4 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+228
  0009b	85 c0		 test	 eax, eax
  0009d	75 02		 jne	 SHORT $LN1@Load

; 38   : 	{
; 39   : 		return;

  0009f	eb 18		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 40   : 	}
; 41   : 	
; 42   : 	this->Read(gDirPath.GetNewPath("ExData\\MonsterEx.ini"));

  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DDILOELG@ExData?2MonsterEx?4ini?$AA@
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000ab	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000b0	50		 push	 eax
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?Read@MonsterEx@@QAEXPAD@Z ; MonsterEx::Read
$LN2@Load:

; 43   : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?Load@MonsterEx@@QAEXXZ ENDP				; MonsterEx::Load
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_type$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_File$ = 8						; size = 4
?Read@MonsterEx@@QAEXPAD@Z PROC				; MonsterEx::Read
; _this$ = ecx

; 47   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	57		 push	 edi
  000c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	SMDFile = fopen(File, "r");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000d1	8b 45 08	 mov	 eax, DWORD PTR _File$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _fopen
  000da	83 c4 08	 add	 esp, 8
  000dd	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 49   : 
; 50   : 	if( SMDFile == NULL )

  000e2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  000e9	75 22		 jne	 SHORT $LN8@Read

; 51   : 	{
; 52   : 		LogAdd(lMsg.Get(MSGGET(1, 198)), File);

  000eb	8b 45 08	 mov	 eax, DWORD PTR _File$[ebp]
  000ee	50		 push	 eax
  000ef	68 c6 01 00 00	 push	 454			; 000001c6H
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00105	83 c4 08	 add	 esp, 8

; 53   : 		return;

  00108	e9 05 01 00 00	 jmp	 $LN9@Read
$LN8@Read:

; 54   : 	}
; 55   : 
; 56   : 	int Token;
; 57   : 	int type = -1;

  0010d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN7@Read:

; 58   : 
; 59   : 	while ( true )

  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	0f 84 e3 00 00
	00		 je	 $LN6@Read

; 60   : 	{
; 61   : 	    Token = GetToken();

  00121	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00126	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 62   : 
; 63   :         if( Token == END )

  00129	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0012d	75 05		 jne	 SHORT $LN5@Read

; 64   : 		{
; 65   :             break;

  0012f	e9 d0 00 00 00	 jmp	 $LN6@Read
$LN5@Read:

; 66   : 		}
; 67   : 
; 68   : 		type = (int)TokenNumber;

  00134	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0013a	e8 00 00 00 00	 call	 __ftol2_sse
  0013f	89 45 f4	 mov	 DWORD PTR _type$[ebp], eax
$LN4@Read:

; 69   : 
; 70   : 		while ( true )

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	85 c0		 test	 eax, eax
  00149	0f 84 b0 00 00
	00		 je	 $LN3@Read

; 71   : 		{
; 72   : 			if ( type == 0 )

  0014f	83 7d f4 00	 cmp	 DWORD PTR _type$[ebp], 0
  00153	0f 85 a1 00 00
	00		 jne	 $LN2@Read

; 73   : 			{
; 74   : 				Token = GetToken();

  00159	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0015e	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 75   : 
; 76   : 				if ( strcmp("end", TokenString) == 0 )

  00161	68 00 00 00 00	 push	 OFFSET _TokenString
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0016b	e8 00 00 00 00	 call	 _strcmp
  00170	83 c4 08	 add	 esp, 8
  00173	85 c0		 test	 eax, eax
  00175	75 05		 jne	 SHORT $LN1@Read

; 77   : 				{
; 78   : 					break;

  00177	e9 83 00 00 00	 jmp	 $LN3@Read
$LN1@Read:

; 79   : 				}
; 80   : 
; 81   : 				this->mobdata[this->mobLoaded].id = TokenNumber;

  0017c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00182	e8 00 00 00 00	 call	 __ftol2_sse
  00187	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	8b 91 00 30 00
	00		 mov	 edx, DWORD PTR [ecx+12288]
  00190	6b d2 0c	 imul	 edx, 12			; 0000000cH
  00193	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 82   : 
; 83   : 				Token = GetToken();

  00199	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0019e	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 84   : 				this->mobdata[this->mobLoaded].map = TokenNumber;

  001a1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a7	e8 00 00 00 00	 call	 __ftol2_sse
  001ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	8b 91 00 30 00
	00		 mov	 edx, DWORD PTR [ecx+12288]
  001b5	6b d2 0c	 imul	 edx, 12			; 0000000cH
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax

; 85   : 
; 86   : 				Token = GetToken();

  001bf	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001c4	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 87   : 				this->mobdata[this->mobLoaded].AttackDiv = TokenNumber;

  001c7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001cd	e8 00 00 00 00	 call	 __ftol2_sse
  001d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d5	8b 91 00 30 00
	00		 mov	 edx, DWORD PTR [ecx+12288]
  001db	6b d2 0c	 imul	 edx, 12			; 0000000cH
  001de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e1	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax

; 88   : 
; 89   : 				this->mobLoaded++;

  001e5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e8	8b 88 00 30 00
	00		 mov	 ecx, DWORD PTR [eax+12288]
  001ee	83 c1 01	 add	 ecx, 1
  001f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f4	89 8a 00 30 00
	00		 mov	 DWORD PTR [edx+12288], ecx
$LN2@Read:

; 90   : 			}    
; 91   : 		}

  001fa	e9 43 ff ff ff	 jmp	 $LN4@Read
$LN3@Read:

; 92   :     }

  001ff	e9 10 ff ff ff	 jmp	 $LN7@Read
$LN6@Read:

; 93   : 
; 94   : 	fclose(SMDFile);

  00204	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 _fclose
  0020f	83 c4 04	 add	 esp, 4
$LN9@Read:

; 95   : 	return;
; 96   : }

  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c2 04 00	 ret	 4
?Read@MonsterEx@@QAEXPAD@Z ENDP				; MonsterEx::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00220	55		 push	 ebp
  00221	8b ec		 mov	 ebp, esp
  00223	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00229	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0022e	33 c5		 xor	 eax, ebp
  00230	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00233	53		 push	 ebx
  00234	56		 push	 esi
  00235	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00236	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0023d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 _fgetc
  00248	83 c4 04	 add	 esp, 4
  0024b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0024e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00252	83 f9 ff	 cmp	 ecx, -1
  00255	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00257	b8 02 00 00 00	 mov	 eax, 2
  0025c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00261	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00263	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00267	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0026a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 _fgetc
  00277	83 c4 04	 add	 esp, 4
  0027a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0027d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00281	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00284	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00286	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0028a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0028d	74 1c		 je	 SHORT $LN23@GetToken
  0028f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00293	83 f8 ff	 cmp	 eax, -1
  00296	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00298	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0029d	50		 push	 eax
  0029e	e8 00 00 00 00	 call	 _fgetc
  002a3	83 c4 04	 add	 esp, 4
  002a6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  002a9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  002ab	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002af	83 f8 ff	 cmp	 eax, -1
  002b2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  002b4	b8 02 00 00 00	 mov	 eax, 2
  002b9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  002be	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 _isspace
  002c8	83 c4 04	 add	 esp, 4
  002cb	85 c0		 test	 eax, eax
  002cd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  002d3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002d7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  002dd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  002e3	83 e9 22	 sub	 ecx, 34			; 00000022H
  002e6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  002ec	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  002f3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  002f9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  002ff	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00306	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0030d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00317	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0031c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00321	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00326	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00330	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00335	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0033a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0033f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00349	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0034e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00353	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00358	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00362	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00367	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0036c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00371	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0037b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00380	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00385	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0038a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0038f	50		 push	 eax
  00390	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00394	51		 push	 ecx
  00395	e8 00 00 00 00	 call	 _ungetc
  0039a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0039d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  003a0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 _getc
  003ae	83 c4 04	 add	 esp, 4
  003b1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  003b4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003b8	83 f9 ff	 cmp	 ecx, -1
  003bb	74 36		 je	 SHORT $LN12@GetToken
  003bd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003c1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  003c4	74 1a		 je	 SHORT $LN11@GetToken
  003c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003ca	50		 push	 eax
  003cb	e8 00 00 00 00	 call	 _isdigit
  003d0	83 c4 04	 add	 esp, 4
  003d3	85 c0		 test	 eax, eax
  003d5	75 09		 jne	 SHORT $LN11@GetToken
  003d7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003db	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003de	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  003e0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  003e3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  003e6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  003e8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  003eb	83 c0 01	 add	 eax, 1
  003ee	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  003f1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  003f3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  003f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  003f9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  003fc	50		 push	 eax
  003fd	e8 00 00 00 00	 call	 _atof
  00402	83 c4 04	 add	 esp, 4
  00405	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0040b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00415	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0041a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0041f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00424	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0042b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 _getc
  00436	83 c4 04	 add	 esp, 4
  00439	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0043c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00440	83 f9 ff	 cmp	 ecx, -1
  00443	74 1c		 je	 SHORT $LN8@GetToken
  00445	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00449	83 f8 22	 cmp	 eax, 34			; 00000022H
  0044c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0044e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00451	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00454	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00456	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00459	83 c0 01	 add	 eax, 1
  0045c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0045f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00461	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00465	83 f8 22	 cmp	 eax, 34			; 00000022H
  00468	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0046a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0046f	50		 push	 eax
  00470	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00474	51		 push	 ecx
  00475	e8 00 00 00 00	 call	 _ungetc
  0047a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0047d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00480	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00483	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0048d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00492	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00497	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0049c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004a0	50		 push	 eax
  004a1	e8 00 00 00 00	 call	 _isalpha
  004a6	83 c4 04	 add	 esp, 4
  004a9	85 c0		 test	 eax, eax
  004ab	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  004b1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  004b8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004bb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  004be	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  004c0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004c3	83 c0 01	 add	 eax, 1
  004c6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  004c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 _getc
  004d4	83 c4 04	 add	 esp, 4
  004d7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004da	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004de	83 f9 ff	 cmp	 ecx, -1
  004e1	74 36		 je	 SHORT $LN3@GetToken
  004e3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004e7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  004ea	74 1a		 je	 SHORT $LN2@GetToken
  004ec	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004f0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  004f3	74 11		 je	 SHORT $LN2@GetToken
  004f5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004f9	50		 push	 eax
  004fa	e8 00 00 00 00	 call	 _isalnum
  004ff	83 c4 04	 add	 esp, 4
  00502	85 c0		 test	 eax, eax
  00504	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00506	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00509	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0050c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0050e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00511	83 c0 01	 add	 eax, 1
  00514	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00517	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00519	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0051e	50		 push	 eax
  0051f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00523	51		 push	 ecx
  00524	e8 00 00 00 00	 call	 _ungetc
  00529	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0052c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0052f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00532	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0053c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00541	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00543	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00545	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0054f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00554	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00556	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00558	5f		 pop	 edi
  00559	5e		 pop	 esi
  0055a	5b		 pop	 ebx
  0055b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055e	33 cd		 xor	 ecx, ebp
  00560	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00565	8b e5		 mov	 esp, ebp
  00567	5d		 pop	 ebp
  00568	c3		 ret	 0
  00569	8d 49 00	 npad	 3
$LN35@GetToken:
  0056c	00 00 00 00	 DD	 $LN10@GetToken
  00570	00 00 00 00	 DD	 $LN19@GetToken
  00574	00 00 00 00	 DD	 $LN17@GetToken
  00578	00 00 00 00	 DD	 $LN14@GetToken
  0057c	00 00 00 00	 DD	 $LN18@GetToken
  00580	00 00 00 00	 DD	 $LN16@GetToken
  00584	00 00 00 00	 DD	 $LN15@GetToken
  00588	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0058c	00		 DB	 0
  0058d	01		 DB	 1
  0058e	07		 DB	 7
  0058f	07		 DB	 7
  00590	07		 DB	 7
  00591	07		 DB	 7
  00592	07		 DB	 7
  00593	07		 DB	 7
  00594	07		 DB	 7
  00595	07		 DB	 7
  00596	02		 DB	 2
  00597	03		 DB	 3
  00598	03		 DB	 3
  00599	07		 DB	 7
  0059a	03		 DB	 3
  0059b	03		 DB	 3
  0059c	03		 DB	 3
  0059d	03		 DB	 3
  0059e	03		 DB	 3
  0059f	03		 DB	 3
  005a0	03		 DB	 3
  005a1	03		 DB	 3
  005a2	03		 DB	 3
  005a3	03		 DB	 3
  005a4	07		 DB	 7
  005a5	04		 DB	 4
  005a6	07		 DB	 7
  005a7	07		 DB	 7
  005a8	07		 DB	 7
  005a9	07		 DB	 7
  005aa	07		 DB	 7
  005ab	07		 DB	 7
  005ac	07		 DB	 7
  005ad	07		 DB	 7
  005ae	07		 DB	 7
  005af	07		 DB	 7
  005b0	07		 DB	 7
  005b1	07		 DB	 7
  005b2	07		 DB	 7
  005b3	07		 DB	 7
  005b4	07		 DB	 7
  005b5	07		 DB	 7
  005b6	07		 DB	 7
  005b7	07		 DB	 7
  005b8	07		 DB	 7
  005b9	07		 DB	 7
  005ba	07		 DB	 7
  005bb	07		 DB	 7
  005bc	07		 DB	 7
  005bd	07		 DB	 7
  005be	07		 DB	 7
  005bf	07		 DB	 7
  005c0	07		 DB	 7
  005c1	07		 DB	 7
  005c2	07		 DB	 7
  005c3	07		 DB	 7
  005c4	07		 DB	 7
  005c5	07		 DB	 7
  005c6	07		 DB	 7
  005c7	07		 DB	 7
  005c8	07		 DB	 7
  005c9	07		 DB	 7
  005ca	07		 DB	 7
  005cb	07		 DB	 7
  005cc	07		 DB	 7
  005cd	07		 DB	 7
  005ce	07		 DB	 7
  005cf	07		 DB	 7
  005d0	07		 DB	 7
  005d1	07		 DB	 7
  005d2	07		 DB	 7
  005d3	07		 DB	 7
  005d4	07		 DB	 7
  005d5	07		 DB	 7
  005d6	07		 DB	 7
  005d7	07		 DB	 7
  005d8	07		 DB	 7
  005d9	07		 DB	 7
  005da	07		 DB	 7
  005db	07		 DB	 7
  005dc	07		 DB	 7
  005dd	07		 DB	 7
  005de	07		 DB	 7
  005df	07		 DB	 7
  005e0	07		 DB	 7
  005e1	07		 DB	 7
  005e2	07		 DB	 7
  005e3	07		 DB	 7
  005e4	07		 DB	 7
  005e5	05		 DB	 5
  005e6	07		 DB	 7
  005e7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?AttackMonster@MonsterEx@@QAEXHHAAH@Z		; MonsterEx::AttackMonster
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnectedEx@@YA_NH@Z:PROC		; gObjIsConnectedEx
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monsterex.cpp
_TEXT	SEGMENT
tv74 = -84						; size = 4
tv69 = -84						; size = 4
_i$227343 = -16						; size = 4
_lpMonster$ = -12					; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aUserIndex$ = 8					; size = 4
_aMonsterIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
?AttackMonster@MonsterEx@@QAEXHHAAH@Z PROC		; MonsterEx::AttackMonster
; _this$ = ecx

; 100  : {

  005f0	55		 push	 ebp
  005f1	8b ec		 mov	 ebp, esp
  005f3	83 ec 54	 sub	 esp, 84			; 00000054H
  005f6	53		 push	 ebx
  005f7	56		 push	 esi
  005f8	57		 push	 edi
  005f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  : 	if(!g_ExLicense.user.MonsterAttackLife)

  005fc	0f b6 05 e4 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+228
  00603	85 c0		 test	 eax, eax
  00605	75 05		 jne	 SHORT $LN12@AttackMons

; 102  : 	{
; 103  : 		return;

  00607	e9 4b 01 00 00	 jmp	 $LN13@AttackMons
$LN12@AttackMons:

; 104  : 	}
; 105  : 
; 106  : 	if(!OBJMAX_RANGE(aUserIndex) || !OBJMAX_RANGE(aMonsterIndex))

  0060c	83 7d 08 00	 cmp	 DWORD PTR _aUserIndex$[ebp], 0
  00610	7d 09		 jge	 SHORT $LN15@AttackMons
  00612	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00619	eb 0f		 jmp	 SHORT $LN16@AttackMons
$LN15@AttackMons:
  0061b	33 c0		 xor	 eax, eax
  0061d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aUserIndex$[ebp], 14999 ; 00003a97H
  00624	0f 9e c0	 setle	 al
  00627	89 45 ac	 mov	 DWORD PTR tv69[ebp], eax
$LN16@AttackMons:
  0062a	83 7d ac 00	 cmp	 DWORD PTR tv69[ebp], 0
  0062e	74 24		 je	 SHORT $LN10@AttackMons
  00630	83 7d 0c 00	 cmp	 DWORD PTR _aMonsterIndex$[ebp], 0
  00634	7d 09		 jge	 SHORT $LN17@AttackMons
  00636	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0063d	eb 0f		 jmp	 SHORT $LN18@AttackMons
$LN17@AttackMons:
  0063f	33 c0		 xor	 eax, eax
  00641	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aMonsterIndex$[ebp], 14999 ; 00003a97H
  00648	0f 9e c0	 setle	 al
  0064b	89 45 ac	 mov	 DWORD PTR tv74[ebp], eax
$LN18@AttackMons:
  0064e	83 7d ac 00	 cmp	 DWORD PTR tv74[ebp], 0
  00652	75 05		 jne	 SHORT $LN11@AttackMons
$LN10@AttackMons:

; 107  : 	{
; 108  : 		return;

  00654	e9 fe 00 00 00	 jmp	 $LN13@AttackMons
$LN11@AttackMons:

; 109  : 	}
; 110  : 
; 111  : 	if(!gObjIsConnectedEx(aUserIndex))

  00659	8b 45 08	 mov	 eax, DWORD PTR _aUserIndex$[ebp]
  0065c	50		 push	 eax
  0065d	e8 00 00 00 00	 call	 ?gObjIsConnectedEx@@YA_NH@Z ; gObjIsConnectedEx
  00662	83 c4 04	 add	 esp, 4
  00665	0f b6 c8	 movzx	 ecx, al
  00668	85 c9		 test	 ecx, ecx
  0066a	75 05		 jne	 SHORT $LN9@AttackMons

; 112  : 	{
; 113  : 		return;

  0066c	e9 e6 00 00 00	 jmp	 $LN13@AttackMons
$LN9@AttackMons:

; 114  : 	}
; 115  : 
; 116  : 	LPOBJ lpUser = &gObj[aUserIndex];

  00671	8b 45 08	 mov	 eax, DWORD PTR _aUserIndex$[ebp]
  00674	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0067a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00680	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 117  : 	LPOBJ lpMonster = &gObj[aMonsterIndex];

  00683	8b 45 0c	 mov	 eax, DWORD PTR _aMonsterIndex$[ebp]
  00686	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0068c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00692	89 45 f4	 mov	 DWORD PTR _lpMonster$[ebp], eax

; 118  : 
; 119  : 	if(lpMonster->Type != OBJ_NPC && lpMonster->Type != OBJ_MONSTER)

  00695	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00698	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  0069c	83 f9 03	 cmp	 ecx, 3
  0069f	74 11		 je	 SHORT $LN8@AttackMons
  006a1	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  006a4	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  006a8	83 f9 02	 cmp	 ecx, 2
  006ab	74 05		 je	 SHORT $LN8@AttackMons

; 120  : 	{
; 121  : 		return;

  006ad	e9 a5 00 00 00	 jmp	 $LN13@AttackMons
$LN8@AttackMons:

; 122  : 	}
; 123  : 
; 124  : 	for(int i = 0; i < this->mobLoaded; i++)

  006b2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$227343[ebp], 0
  006b9	eb 09		 jmp	 SHORT $LN7@AttackMons
$LN6@AttackMons:
  006bb	8b 45 f0	 mov	 eax, DWORD PTR _i$227343[ebp]
  006be	83 c0 01	 add	 eax, 1
  006c1	89 45 f0	 mov	 DWORD PTR _i$227343[ebp], eax
$LN7@AttackMons:
  006c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006c7	8b 4d f0	 mov	 ecx, DWORD PTR _i$227343[ebp]
  006ca	3b 88 00 30 00
	00		 cmp	 ecx, DWORD PTR [eax+12288]
  006d0	0f 8d 81 00 00
	00		 jge	 $LN5@AttackMons

; 125  : 	{
; 126  : 		if(this->mobdata[i].map == -1 || this->mobdata[i].map == lpMonster->MapNumber)

  006d6	8b 45 f0	 mov	 eax, DWORD PTR _i$227343[ebp]
  006d9	6b c0 0c	 imul	 eax, 12			; 0000000cH
  006dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006df	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  006e4	74 19		 je	 SHORT $LN3@AttackMons
  006e6	8b 45 f0	 mov	 eax, DWORD PTR _i$227343[ebp]
  006e9	6b c0 0c	 imul	 eax, 12			; 0000000cH
  006ec	8b 4d f4	 mov	 ecx, DWORD PTR _lpMonster$[ebp]
  006ef	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  006f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006f9	39 54 01 04	 cmp	 DWORD PTR [ecx+eax+4], edx
  006fd	75 53		 jne	 SHORT $LN1@AttackMons
$LN3@AttackMons:

; 127  : 		{
; 128  : 			if(this->mobdata[i].id == lpMonster->Class)

  006ff	8b 45 f0	 mov	 eax, DWORD PTR _i$227343[ebp]
  00702	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00705	8b 4d f4	 mov	 ecx, DWORD PTR _lpMonster$[ebp]
  00708	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  0070f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00712	39 14 01	 cmp	 DWORD PTR [ecx+eax], edx
  00715	75 3b		 jne	 SHORT $LN1@AttackMons

; 129  : 			{
; 130  : 				if(this->mobdata[i].AttackDiv > 0)

  00717	8b 45 f0	 mov	 eax, DWORD PTR _i$227343[ebp]
  0071a	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0071d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00720	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  00725	7e 2b		 jle	 SHORT $LN1@AttackMons

; 131  : 				{
; 132  : 					AttackDamage = ( lpUser->MaxLife + lpUser->AddLife ) / this->mobdata[i].AttackDiv;

  00727	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0072a	db 80 4c 01 00
	00		 fild	 DWORD PTR [eax+332]
  00730	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00733	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  00739	8b 55 f0	 mov	 edx, DWORD PTR _i$227343[ebp]
  0073c	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0073f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00742	da 74 10 08	 fidiv	 DWORD PTR [eax+edx+8]
  00746	e8 00 00 00 00	 call	 __ftol2_sse
  0074b	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  0074e	89 01		 mov	 DWORD PTR [ecx], eax

; 133  : 					return;

  00750	eb 05		 jmp	 SHORT $LN13@AttackMons
$LN1@AttackMons:

; 134  : 				}			
; 135  : 			}
; 136  : 		}
; 137  : 	}

  00752	e9 64 ff ff ff	 jmp	 $LN6@AttackMons
$LN5@AttackMons:
$LN13@AttackMons:

; 138  : }

  00757	5f		 pop	 edi
  00758	5e		 pop	 esi
  00759	5b		 pop	 ebx
  0075a	8b e5		 mov	 esp, ebp
  0075c	5d		 pop	 ebp
  0075d	c2 0c 00	 ret	 12			; 0000000cH
?AttackMonster@MonsterEx@@QAEXHHAAH@Z ENDP		; MonsterEx::AttackMonster
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Eg_MonsterEx@@YAXXZ
text$yc	SEGMENT
??__Eg_MonsterEx@@YAXXZ PROC				; `dynamic initializer for 'g_MonsterEx'', COMDAT

; 12   : MonsterEx g_MonsterEx;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterEx@@3VMonsterEx@@A ; g_MonsterEx
  0000e	e8 00 00 00 00	 call	 ??0MonsterEx@@QAE@XZ	; MonsterEx::MonsterEx
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MonsterEx@@YAXXZ ; `dynamic atexit destructor for 'g_MonsterEx''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MonsterEx@@YAXXZ ENDP				; `dynamic initializer for 'g_MonsterEx''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_MonsterEx@@YAXXZ
text$yd	SEGMENT
??__Fg_MonsterEx@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MonsterEx'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterEx@@3VMonsterEx@@A ; g_MonsterEx
  0000e	e8 00 00 00 00	 call	 ??1MonsterEx@@QAE@XZ	; MonsterEx::~MonsterEx
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MonsterEx@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MonsterEx''
text$yd	ENDS
PUBLIC	?g_MonsterEx@@3VMonsterEx@@A			; g_MonsterEx
_BSS	SEGMENT
?g_MonsterEx@@3VMonsterEx@@A DB 03004H DUP (?)		; g_MonsterEx
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MonsterEx$initializer$ DD FLAT:??__Eg_MonsterEx@@YAXXZ
CRT$XCU	ENDS
END
