; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\Crc32.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Set@CCrc32@@QAEKKD@Z				; CCrc32::Set
PUBLIC	??0CCrc32@@QAE@XZ				; CCrc32::CCrc32
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\crc32.cpp
_TEXT	SEGMENT
_y$204428 = -12						; size = 4
_i$204424 = -8						; size = 4
_this$ = -4						; size = 4
??0CCrc32@@QAE@XZ PROC					; CCrc32::CCrc32
; _this$ = ecx

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 8    : 	::memset(&this->Addr, NULL, sizeof(this->Addr));

  0000c	68 00 04 00 00	 push	 1024			; 00000400H
  00011	6a 00		 push	 0
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _memset
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9    : 	
; 10   : 	for(int i = 0; i <= 255; i++)

  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$204424[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN6@CCrc32
$LN5@CCrc32:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$204424[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR _i$204424[ebp], eax
$LN6@CCrc32:
  00031	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _i$204424[ebp], 255 ; 000000ffH
  00038	0f 8f 83 00 00
	00		 jg	 $LN7@CCrc32

; 11   : 	{
; 12   : 		this->Addr[i]	= this->Set(i, 8) << 24;

  0003e	6a 08		 push	 8
  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$204424[ebp]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?Set@CCrc32@@QAEKKD@Z	; CCrc32::Set
  0004c	c1 e0 18	 shl	 eax, 24			; 00000018H
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _i$204424[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 13   : 		
; 14   : 		for(int y = 0; y < 8; y++)

  00058	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$204428[ebp], 0
  0005f	eb 09		 jmp	 SHORT $LN3@CCrc32
$LN2@CCrc32:
  00061	8b 45 f4	 mov	 eax, DWORD PTR _y$204428[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 f4	 mov	 DWORD PTR _y$204428[ebp], eax
$LN3@CCrc32:
  0006a	83 7d f4 08	 cmp	 DWORD PTR _y$204428[ebp], 8
  0006e	7d 2f		 jge	 SHORT $LN1@CCrc32

; 15   : 		{
; 16   : 			Addr[i]		= (Addr[i] << 1) ^ (Addr[i] & (1 << 31) ? 0x04C11DB7 : 0);

  00070	8b 45 f8	 mov	 eax, DWORD PTR _i$204424[ebp]
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00079	d1 e2		 shl	 edx, 1
  0007b	8b 45 f8	 mov	 eax, DWORD PTR _i$204424[ebp]
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00084	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00089	f7 d8		 neg	 eax
  0008b	1b c0		 sbb	 eax, eax
  0008d	25 b7 1d c1 04	 and	 eax, 79764919		; 04c11db7H
  00092	33 d0		 xor	 edx, eax
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _i$204424[ebp]
  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 17   : 		}

  0009d	eb c2		 jmp	 SHORT $LN2@CCrc32
$LN1@CCrc32:

; 18   : 
; 19   : 		Addr[i]			= this->Set(Addr[i], 32);

  0009f	6a 20		 push	 32			; 00000020H
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _i$204424[ebp]
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000aa	52		 push	 edx
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?Set@CCrc32@@QAEKKD@Z	; CCrc32::Set
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _i$204424[ebp]
  000b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b9	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 20   : 	}

  000bc	e9 67 ff ff ff	 jmp	 $LN5@CCrc32
$LN7@CCrc32:

; 21   : }

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
??0CCrc32@@QAE@XZ ENDP					; CCrc32::CCrc32
_TEXT	ENDS
PUBLIC	??1CCrc32@@QAE@XZ				; CCrc32::~CCrc32
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CCrc32@@QAE@XZ PROC					; CCrc32::~CCrc32
; _this$ = ecx

; 24   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	83 ec 44	 sub	 esp, 68			; 00000044H
  000d6	53		 push	 ebx
  000d7	56		 push	 esi
  000d8	57		 push	 edi
  000d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : }

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
??1CCrc32@@QAE@XZ ENDP					; CCrc32::~CCrc32
; Function compile flags: /Odtp /ZI
_i$204441 = -12					; size = 4
_Res$ = -8						; size = 4
_this$ = -4						; size = 4
_Replace$ = 8						; size = 4
_szMsg$ = 12						; size = 1
?Set@CCrc32@@QAEKKD@Z PROC				; CCrc32::Set
; _this$ = ecx

; 28   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  000f6	53		 push	 ebx
  000f7	56		 push	 esi
  000f8	57		 push	 edi
  000f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	unsigned long Res	= 0;

  000fc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Res$[ebp], 0

; 30   : 
; 31   : 	for(int i = 1; i < (szMsg + 1); i++)

  00103	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$204441[ebp], 1
  0010a	eb 09		 jmp	 SHORT $LN4@Set
$LN3@Set:
  0010c	8b 45 f4	 mov	 eax, DWORD PTR _i$204441[ebp]
  0010f	83 c0 01	 add	 eax, 1
  00112	89 45 f4	 mov	 DWORD PTR _i$204441[ebp], eax
$LN4@Set:
  00115	0f be 45 0c	 movsx	 eax, BYTE PTR _szMsg$[ebp]
  00119	83 c0 01	 add	 eax, 1
  0011c	39 45 f4	 cmp	 DWORD PTR _i$204441[ebp], eax
  0011f	7d 26		 jge	 SHORT $LN2@Set

; 32   : 	{
; 33   : 		if(Replace & 1) Res |= 1 << (szMsg - i); Replace >>= 1;

  00121	8b 45 08	 mov	 eax, DWORD PTR _Replace$[ebp]
  00124	83 e0 01	 and	 eax, 1
  00127	74 14		 je	 SHORT $LN1@Set
  00129	0f be 4d 0c	 movsx	 ecx, BYTE PTR _szMsg$[ebp]
  0012d	2b 4d f4	 sub	 ecx, DWORD PTR _i$204441[ebp]
  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	d3 e0		 shl	 eax, cl
  00137	0b 45 f8	 or	 eax, DWORD PTR _Res$[ebp]
  0013a	89 45 f8	 mov	 DWORD PTR _Res$[ebp], eax
$LN1@Set:
  0013d	8b 45 08	 mov	 eax, DWORD PTR _Replace$[ebp]
  00140	d1 e8		 shr	 eax, 1
  00142	89 45 08	 mov	 DWORD PTR _Replace$[ebp], eax

; 34   : 	}

  00145	eb c5		 jmp	 SHORT $LN3@Set
$LN2@Set:

; 35   : 
; 36   : 	return Res;

  00147	8b 45 f8	 mov	 eax, DWORD PTR _Res$[ebp]

; 37   : }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
?Set@CCrc32@@QAEKKD@Z ENDP				; CCrc32::Set
_TEXT	ENDS
PUBLIC	?Repl@CCrc32@@QAEXPAKPAEK@Z			; CCrc32::Repl
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szBytes$ = 8						; size = 4
_szBuff$ = 12						; size = 4
_Length$ = 16						; size = 4
?Repl@CCrc32@@QAEXPAKPAEK@Z PROC			; CCrc32::Repl
; _this$ = ecx

; 40   : {

  00160	55		 push	 ebp
  00161	8b ec		 mov	 ebp, esp
  00163	83 ec 44	 sub	 esp, 68			; 00000044H
  00166	53		 push	 ebx
  00167	56		 push	 esi
  00168	57		 push	 edi
  00169	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Repl:

; 41   : 	while(Length--)

  0016c	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  0016f	8b 4d 10	 mov	 ecx, DWORD PTR _Length$[ebp]
  00172	83 e9 01	 sub	 ecx, 1
  00175	89 4d 10	 mov	 DWORD PTR _Length$[ebp], ecx
  00178	85 c0		 test	 eax, eax
  0017a	74 30		 je	 SHORT $LN3@Repl

; 42   : 	{
; 43   : 		*szBytes = (*szBytes >> 8) ^ this->Addr[(*szBytes & 0xFF) ^ *szBuff++];

  0017c	8b 45 08	 mov	 eax, DWORD PTR _szBytes$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	c1 e9 08	 shr	 ecx, 8
  00184	8b 55 08	 mov	 edx, DWORD PTR _szBytes$[ebp]
  00187	8b 02		 mov	 eax, DWORD PTR [edx]
  00189	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0018e	8b 55 0c	 mov	 edx, DWORD PTR _szBuff$[ebp]
  00191	0f b6 12	 movzx	 edx, BYTE PTR [edx]
  00194	33 c2		 xor	 eax, edx
  00196	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00199	33 0c 82	 xor	 ecx, DWORD PTR [edx+eax*4]
  0019c	8b 45 08	 mov	 eax, DWORD PTR _szBytes$[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
  001a1	8b 4d 0c	 mov	 ecx, DWORD PTR _szBuff$[ebp]
  001a4	83 c1 01	 add	 ecx, 1
  001a7	89 4d 0c	 mov	 DWORD PTR _szBuff$[ebp], ecx

; 44   : 	}

  001aa	eb c0		 jmp	 SHORT $LN2@Repl
$LN3@Repl:

; 45   : }

  001ac	5f		 pop	 edi
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c2 0c 00	 ret	 12			; 0000000cH
?Repl@CCrc32@@QAEXPAKPAEK@Z ENDP			; CCrc32::Repl
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Get@CCrc32@@QAEKPBD@Z				; CCrc32::Get
EXTRN	_fclose:PROC
EXTRN	_fread:PROC
EXTRN	_fopen:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szBuff$ = -1044					; size = 1024
_ReadBytes$ = -20					; size = 4
_FilePath$ = -16					; size = 4
_Buff$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_szFile$ = 8						; size = 4
?Get@CCrc32@@QAEKPBD@Z PROC				; CCrc32::Get
; _this$ = ecx

; 48   : {

  001c0	55		 push	 ebp
  001c1	8b ec		 mov	 ebp, esp
  001c3	81 ec 54 04 00
	00		 sub	 esp, 1108		; 00000454H
  001c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001ce	33 c5		 xor	 eax, ebp
  001d0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001d3	53		 push	 ebx
  001d4	56		 push	 esi
  001d5	57		 push	 edi
  001d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 	unsigned long Buff			= 0xFFFFFFFF;

  001d9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _Buff$[ebp], -1

; 50   : 	FILE * FilePath				= NULL;

  001e0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _FilePath$[ebp], 0

; 51   : 	int ReadBytes				= NULL;

  001e7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ReadBytes$[ebp], 0

; 52   : 
; 53   : 	unsigned char szBuff[1024]	= {0};	

  001ee	c6 85 ec fb ff
	ff 00		 mov	 BYTE PTR _szBuff$[ebp], 0
  001f5	68 ff 03 00 00	 push	 1023			; 000003ffH
  001fa	6a 00		 push	 0
  001fc	8d 85 ed fb ff
	ff		 lea	 eax, DWORD PTR _szBuff$[ebp+1]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _memset
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 54   : 
; 55   : 	if((FilePath = fopen(szFile, "rb")) == NULL)

  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00210	8b 45 08	 mov	 eax, DWORD PTR _szFile$[ebp]
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _fopen
  00219	83 c4 08	 add	 esp, 8
  0021c	89 45 f0	 mov	 DWORD PTR _FilePath$[ebp], eax
  0021f	83 7d f0 00	 cmp	 DWORD PTR _FilePath$[ebp], 0
  00223	75 05		 jne	 SHORT $LN3@Get

; 56   : 	{
; 57   : 		return 0xFFFFFFFF;

  00225	83 c8 ff	 or	 eax, -1
  00228	eb 4f		 jmp	 SHORT $LN5@Get
$LN3@Get:

; 58   : 	}
; 59   : 
; 60   : 	do
; 61   : 	{
; 62   : 		ReadBytes = fread(szBuff, sizeof(char), 1024, FilePath);

  0022a	8b 45 f0	 mov	 eax, DWORD PTR _FilePath$[ebp]
  0022d	50		 push	 eax
  0022e	68 00 04 00 00	 push	 1024			; 00000400H
  00233	6a 01		 push	 1
  00235	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szBuff$[ebp]
  0023b	51		 push	 ecx
  0023c	e8 00 00 00 00	 call	 _fread
  00241	83 c4 10	 add	 esp, 16			; 00000010H
  00244	89 45 ec	 mov	 DWORD PTR _ReadBytes$[ebp], eax

; 63   : 		
; 64   : 		this->Repl(&Buff, szBuff, ReadBytes);

  00247	8b 45 ec	 mov	 eax, DWORD PTR _ReadBytes$[ebp]
  0024a	50		 push	 eax
  0024b	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szBuff$[ebp]
  00251	51		 push	 ecx
  00252	8d 55 f4	 lea	 edx, DWORD PTR _Buff$[ebp]
  00255	52		 push	 edx
  00256	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	e8 00 00 00 00	 call	 ?Repl@CCrc32@@QAEXPAKPAEK@Z ; CCrc32::Repl

; 65   : 	}
; 66   : 	while(ReadBytes == 1024);

  0025e	81 7d ec 00 04
	00 00		 cmp	 DWORD PTR _ReadBytes$[ebp], 1024 ; 00000400H
  00265	74 c3		 je	 SHORT $LN3@Get

; 67   : 	
; 68   : 	fclose(FilePath);

  00267	8b 45 f0	 mov	 eax, DWORD PTR _FilePath$[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _fclose
  00270	83 c4 04	 add	 esp, 4

; 69   : 	
; 70   : 	return(Buff ^ 0xFFFFFFFF);

  00273	8b 45 f4	 mov	 eax, DWORD PTR _Buff$[ebp]
  00276	83 f0 ff	 xor	 eax, -1
$LN5@Get:

; 71   : }

  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	5b		 pop	 ebx
  0027c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027f	33 cd		 xor	 ecx, ebp
  00281	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c2 04 00	 ret	 4
?Get@CCrc32@@QAEKPBD@Z ENDP				; CCrc32::Get
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Eg_Crc32@@YAXXZ
text$yc	SEGMENT
??__Eg_Crc32@@YAXXZ PROC				; `dynamic initializer for 'g_Crc32'', COMDAT

; 4    : CCrc32 g_Crc32;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crc32@@3VCCrc32@@A ; g_Crc32
  0000e	e8 00 00 00 00	 call	 ??0CCrc32@@QAE@XZ	; CCrc32::CCrc32
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_Crc32@@YAXXZ ; `dynamic atexit destructor for 'g_Crc32''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_Crc32@@YAXXZ ENDP				; `dynamic initializer for 'g_Crc32''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_Crc32@@YAXXZ
text$yd	SEGMENT
??__Fg_Crc32@@YAXXZ PROC				; `dynamic atexit destructor for 'g_Crc32'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crc32@@3VCCrc32@@A ; g_Crc32
  0000e	e8 00 00 00 00	 call	 ??1CCrc32@@QAE@XZ	; CCrc32::~CCrc32
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_Crc32@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_Crc32''
text$yd	ENDS
PUBLIC	?g_Crc32@@3VCCrc32@@A				; g_Crc32
_BSS	SEGMENT
?g_Crc32@@3VCCrc32@@A DB 0400H DUP (?)			; g_Crc32
_BSS	ENDS
CRT$XCU	SEGMENT
_g_Crc32$initializer$ DD FLAT:??__Eg_Crc32@@YAXXZ
CRT$XCU	ENDS
END
