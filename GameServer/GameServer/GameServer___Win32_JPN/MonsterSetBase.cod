; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MonsterSetBase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CMonsterSetBase@@6B@			; CMonsterSetBase::`vftable'
PUBLIC	??0CMonsterSetBase@@QAE@XZ			; CMonsterSetBase::CMonsterSetBase
PUBLIC	??_R4CMonsterSetBase@@6B@			; CMonsterSetBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMonsterSetBase@@@8			; CMonsterSetBase `RTTI Type Descriptor'
PUBLIC	??_R3CMonsterSetBase@@8				; CMonsterSetBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMonsterSetBase@@8				; CMonsterSetBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMonsterSetBase@@8		; CMonsterSetBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMonsterSetBase@@UAEPAXI@Z:PROC		; CMonsterSetBase::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMonsterSetBase@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstersetbase.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMonsterSetBase@@8 DD FLAT:??_R0?AVCMonsterSetBase@@@8 ; CMonsterSetBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CMonsterSetBase@@8
rdata$r	SEGMENT
??_R2CMonsterSetBase@@8 DD FLAT:??_R1A@?0A@EA@CMonsterSetBase@@8 ; CMonsterSetBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMonsterSetBase@@8
rdata$r	SEGMENT
??_R3CMonsterSetBase@@8 DD 00H				; CMonsterSetBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMonsterSetBase@@@8
_DATA	SEGMENT
??_R0?AVCMonsterSetBase@@@8 DD FLAT:??_7type_info@@6B@	; CMonsterSetBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMonsterSetBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMonsterSetBase@@6B@
rdata$r	SEGMENT
??_R4CMonsterSetBase@@6B@ DD 00H			; CMonsterSetBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMonsterSetBase@@@8
	DD	FLAT:??_R3CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_7CMonsterSetBase@@6B@
CONST	SEGMENT
??_7CMonsterSetBase@@6B@ DD FLAT:??_R4CMonsterSetBase@@6B@ ; CMonsterSetBase::`vftable'
	DD	FLAT:??_ECMonsterSetBase@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMonsterSetBase@@QAE@XZ PROC				; CMonsterSetBase::CMonsterSetBase
; _this$ = ecx

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMonsterSetBase@@6B@

; 13   : 	return;
; 14   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CMonsterSetBase@@QAE@XZ ENDP				; CMonsterSetBase::CMonsterSetBase
_TEXT	ENDS
PUBLIC	??1CMonsterSetBase@@UAE@XZ			; CMonsterSetBase::~CMonsterSetBase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCMonsterSetBase@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMonsterSetBase@@UAEPAXI@Z PROC			; CMonsterSetBase::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CMonsterSetBase@@UAE@XZ ; CMonsterSetBase::~CMonsterSetBase
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCMonsterSetBase@@UAEPAXI@Z ENDP			; CMonsterSetBase::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMonsterSetBase@@UAE@XZ PROC				; CMonsterSetBase::~CMonsterSetBase
; _this$ = ecx

; 17   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMonsterSetBase@@6B@

; 18   : 	return;
; 19   : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1CMonsterSetBase@@UAE@XZ ENDP				; CMonsterSetBase::~CMonsterSetBase
_TEXT	ENDS
PUBLIC	?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z	; CMonsterSetBase::SetBoxPosition
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_TableNum$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_ax$ = 16						; size = 4
_ay$ = 20						; size = 4
_aw$ = 24						; size = 4
_ah$ = 28						; size = 4
?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z PROC	; CMonsterSetBase::SetBoxPosition
; _this$ = ecx

; 23   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 	this->m_Mp[TableNum].m_MapNumber = mapnumber;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0004f	c1 e0 04	 shl	 eax, 4
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8a 55 0c	 mov	 dl, BYTE PTR _mapnumber$[ebp]
  00058	88 54 01 08	 mov	 BYTE PTR [ecx+eax+8], dl

; 25   : 	this->m_Mp[TableNum].m_W  = aw;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0005f	c1 e0 04	 shl	 eax, 4
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8a 55 18	 mov	 dl, BYTE PTR _aw$[ebp]
  00068	88 54 01 0d	 mov	 BYTE PTR [ecx+eax+13], dl

; 26   : 	this->m_Mp[TableNum].m_H  = ah;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0006f	c1 e0 04	 shl	 eax, 4
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8a 55 1c	 mov	 dl, BYTE PTR _ah$[ebp]
  00078	88 54 01 0e	 mov	 BYTE PTR [ecx+eax+14], dl

; 27   : 	this->m_Mp[TableNum].m_X  = ax;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0007f	c1 e0 04	 shl	 eax, 4
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	8a 55 10	 mov	 dl, BYTE PTR _ax$[ebp]
  00088	88 54 01 0a	 mov	 BYTE PTR [ecx+eax+10], dl

; 28   : 	this->m_Mp[TableNum].m_Y  = ay;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0008f	c1 e0 04	 shl	 eax, 4
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	8a 55 14	 mov	 dl, BYTE PTR _ay$[ebp]
  00098	88 54 01 0b	 mov	 BYTE PTR [ecx+eax+11], dl

; 29   : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 18 00	 ret	 24			; 00000018H
?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z ENDP	; CMonsterSetBase::SetBoxPosition
_TEXT	ENDS
PUBLIC	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	_rand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__except_handler4:PROC
xdata$x	SEGMENT
__sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff7cH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN8@GetBoxPosi
	DD	FLAT:$LN9@GetBoxPosi
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_attr$ = -49						; size = 1
_ty$ = -48						; size = 4
_tx$ = -44						; size = 4
_h$ = -40						; size = 4
_w$ = -36						; size = 4
_count$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_mapnumber$ = 8						; size = 4
_ax$ = 12						; size = 4
_ay$ = 16						; size = 4
_aw$ = 20						; size = 4
_ah$ = 24						; size = 4
_mx$ = 28						; size = 4
_my$ = 32						; size = 4
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z PROC	; CMonsterSetBase::GetBoxPosition
; _this$ = ecx

; 32   : {

  000b0	55		 push	 ebp
  000b1	8b ec		 mov	 ebp, esp
  000b3	6a fe		 push	 -2			; fffffffeH
  000b5	68 00 00 00 00	 push	 OFFSET __sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z
  000ba	68 00 00 00 00	 push	 OFFSET __except_handler4
  000bf	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  000c5	50		 push	 eax
  000c6	83 c4 9c	 add	 esp, -100		; ffffff9cH
  000c9	53		 push	 ebx
  000ca	56		 push	 esi
  000cb	57		 push	 edi
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000d1	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  000d4	33 c5		 xor	 eax, ebp
  000d6	50		 push	 eax
  000d7	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  000da	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  000e0	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  000e3	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	int count = 100 ; 

  000e6	c7 45 e0 64 00
	00 00		 mov	 DWORD PTR _count$[ebp], 100 ; 00000064H
$LN4@GetBoxPosi:

; 34   : 	int w;
; 35   : 	int h;
; 36   : 	int tx; 
; 37   : 	int ty;
; 38   : 	BYTE attr;
; 39   : 
; 40   : 	while ( count-- != 0)

  000ed	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  000f0	8b 4d e0	 mov	 ecx, DWORD PTR _count$[ebp]
  000f3	83 e9 01	 sub	 ecx, 1
  000f6	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 bc 00 00
	00		 je	 $LN3@GetBoxPosi

; 41   : 	{
; 42   : 		w = aw - ax;

  00101	8b 45 14	 mov	 eax, DWORD PTR _aw$[ebp]
  00104	2b 45 0c	 sub	 eax, DWORD PTR _ax$[ebp]
  00107	89 45 dc	 mov	 DWORD PTR _w$[ebp], eax

; 43   : 		h = ah - ay;

  0010a	8b 45 18	 mov	 eax, DWORD PTR _ah$[ebp]
  0010d	2b 45 10	 sub	 eax, DWORD PTR _ay$[ebp]
  00110	89 45 d8	 mov	 DWORD PTR _h$[ebp], eax

; 44   : 
; 45   : 		__try

  00113	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 46   : 		{
; 47   : 			tx = ax + (rand()%w);

  0011a	e8 00 00 00 00	 call	 _rand
  0011f	8b 4d dc	 mov	 ecx, DWORD PTR _w$[ebp]
  00122	99		 cdq
  00123	f7 f9		 idiv	 ecx
  00125	03 55 0c	 add	 edx, DWORD PTR _ax$[ebp]
  00128	89 55 d4	 mov	 DWORD PTR _tx$[ebp], edx

; 48   : 			ty = ay + (rand()%h);

  0012b	e8 00 00 00 00	 call	 _rand
  00130	8b 4d d8	 mov	 ecx, DWORD PTR _h$[ebp]
  00133	99		 cdq
  00134	f7 f9		 idiv	 ecx
  00136	03 55 10	 add	 edx, DWORD PTR _ay$[ebp]
  00139	89 55 d0	 mov	 DWORD PTR _ty$[ebp], edx

; 49   : 		}

  0013c	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00143	eb 1e		 jmp	 SHORT $LN11@GetBoxPosi
$LN8@GetBoxPosi:
$LN13@GetBoxPosi:

; 50   : 		__except (w=1,h=1,1)

  00145	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  0014c	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  00153	b8 01 00 00 00	 mov	 eax, 1
$LN10@GetBoxPosi:
$LN12@GetBoxPosi:
  00158	c3		 ret	 0
$LN9@GetBoxPosi:
  00159	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 51   : 		{
; 52   : 
; 53   : 		}

  0015c	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN11@GetBoxPosi:

; 54   : 
; 55   : 		attr = MapC[mapnumber].GetAttr(tx, ty);

  00163	8b 45 d0	 mov	 eax, DWORD PTR _ty$[ebp]
  00166	50		 push	 eax
  00167	8b 4d d4	 mov	 ecx, DWORD PTR _tx$[ebp]
  0016a	51		 push	 ecx
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  0016e	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  00174	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0017a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0017f	88 45 cf	 mov	 BYTE PTR _attr$[ebp], al

; 56   : 
; 57   : 		if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  00182	0f b6 45 cf	 movzx	 eax, BYTE PTR _attr$[ebp]
  00186	83 e0 01	 and	 eax, 1
  00189	75 2d		 jne	 SHORT $LN1@GetBoxPosi
  0018b	0f b6 45 cf	 movzx	 eax, BYTE PTR _attr$[ebp]
  0018f	83 e0 04	 and	 eax, 4
  00192	75 24		 jne	 SHORT $LN1@GetBoxPosi
  00194	0f b6 45 cf	 movzx	 eax, BYTE PTR _attr$[ebp]
  00198	83 e0 08	 and	 eax, 8
  0019b	75 1b		 jne	 SHORT $LN1@GetBoxPosi

; 58   : 		{
; 59   : 			mx = tx;

  0019d	8b 45 1c	 mov	 eax, DWORD PTR _mx$[ebp]
  001a0	66 8b 4d d4	 mov	 cx, WORD PTR _tx$[ebp]
  001a4	66 89 08	 mov	 WORD PTR [eax], cx

; 60   : 			my = ty;

  001a7	8b 45 20	 mov	 eax, DWORD PTR _my$[ebp]
  001aa	66 8b 4d d0	 mov	 cx, WORD PTR _ty$[ebp]
  001ae	66 89 08	 mov	 WORD PTR [eax], cx

; 61   : 			return TRUE;

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	eb 07		 jmp	 SHORT $LN7@GetBoxPosi
$LN1@GetBoxPosi:

; 62   : 		}
; 63   : 	}

  001b8	e9 30 ff ff ff	 jmp	 $LN4@GetBoxPosi
$LN3@GetBoxPosi:

; 64   : 
; 65   : 	return false;

  001bd	33 c0		 xor	 eax, eax
$LN7@GetBoxPosi:

; 66   : }

  001bf	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c9	59		 pop	 ecx
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx
  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c2 1c 00	 ret	 28			; 0000001cH
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ENDP	; CMonsterSetBase::GetBoxPosition
_TEXT	ENDS
PUBLIC	??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
PUBLIC	?__LINE__Var@?1??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA ; `CMonsterSetBase::GetPosition'::`2'::__LINE__Var
PUBLIC	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z	; CMonsterSetBase::GetPosition
EXTRN	?GetLargeRand@@YAKXZ:PROC			; GetLargeRand
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
;	COMDAT ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@ DB 'ERROR : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@
CONST	SEGMENT
??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\monstersetbase.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA DD 045H ; `CMonsterSetBase::GetPosition'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
_Ory$227846 = -44					; size = 4
_Orx$227845 = -40					; size = 4
_iRY$227836 = -36					; size = 4
_iRX$227835 = -32					; size = 4
_h$ = -28						; size = 4
_w$ = -24						; size = 4
_ty$ = -20						; size = 4
_tx$ = -16						; size = 4
_attr$ = -9						; size = 1
_count$ = -8						; size = 4
_this$ = -4						; size = 4
_TableNum$ = 8						; size = 4
_MapNumber$ = 12					; size = 2
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z PROC		; CMonsterSetBase::GetPosition
; _this$ = ecx

; 69   : {

  001e0	55		 push	 ebp
  001e1	8b ec		 mov	 ebp, esp
  001e3	83 ec 6c	 sub	 esp, 108		; 0000006cH
  001e6	53		 push	 ebx
  001e7	56		 push	 esi
  001e8	57		 push	 edi
  001e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 	int count = 100;

  001ec	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _count$[ebp], 100 ; 00000064H

; 71   : 	BYTE attr;
; 72   : 	int tx;
; 73   : 	int ty;
; 74   : 	int w;
; 75   : 	int h;
; 76   : 
; 77   : 	if ( TableNum < 0 || TableNum > OBJ_MAXMONSTER-1 )

  001f3	83 7d 08 00	 cmp	 DWORD PTR _TableNum$[ebp], 0
  001f7	7c 09		 jl	 SHORT $LN19@GetPositio
  001f9	81 7d 08 c7 32
	00 00		 cmp	 DWORD PTR _TableNum$[ebp], 12999 ; 000032c7H
  00200	7e 23		 jle	 SHORT $LN20@GetPositio
$LN19@GetPositio:

; 78   : 	{
; 79   : 		LogAdd("ERROR : %s %d", __FILE__, __LINE__ );

  00202	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA
  00207	83 c0 0a	 add	 eax, 10			; 0000000aH
  0020a	50		 push	 eax
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0021b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   : 		return false;

  0021e	33 c0		 xor	 eax, eax
  00220	e9 c2 02 00 00	 jmp	 $LN21@GetPositio
$LN20@GetPositio:

; 81   : 	}
; 82   : 
; 83   : 	if ( this->m_Mp[TableNum].m_ArrangeType == 1 || this->m_Mp[TableNum].m_ArrangeType == 3 )

  00225	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00228	c1 e0 04	 shl	 eax, 4
  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00233	83 fa 01	 cmp	 edx, 1
  00236	74 17		 je	 SHORT $LN16@GetPositio
  00238	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0023b	c1 e0 04	 shl	 eax, 4
  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00246	83 fa 03	 cmp	 edx, 3
  00249	0f 85 15 01 00
	00		 jne	 $LN18@GetPositio
$LN16@GetPositio:

; 84   : 	{
; 85   : 		while ( count-- != 0 )

  0024f	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00252	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00255	83 e9 01	 sub	 ecx, 1
  00258	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  0025b	85 c0		 test	 eax, eax
  0025d	0f 84 fc 00 00
	00		 je	 $LN15@GetPositio

; 86   : 		{
; 87   : 			w = this->m_Mp[TableNum].m_W - this->m_Mp[TableNum].m_X;

  00263	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00266	c1 e0 04	 shl	 eax, 4
  00269	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026c	0f b6 54 01 0d	 movzx	 edx, BYTE PTR [ecx+eax+13]
  00271	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00274	c1 e0 04	 shl	 eax, 4
  00277	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [ecx+eax+10]
  0027f	2b d0		 sub	 edx, eax
  00281	89 55 e8	 mov	 DWORD PTR _w$[ebp], edx

; 88   : 			h = this->m_Mp[TableNum].m_H - this->m_Mp[TableNum].m_Y;

  00284	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00287	c1 e0 04	 shl	 eax, 4
  0028a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028d	0f b6 54 01 0e	 movzx	 edx, BYTE PTR [ecx+eax+14]
  00292	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00295	c1 e0 04	 shl	 eax, 4
  00298	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029b	0f b6 44 01 0b	 movzx	 eax, BYTE PTR [ecx+eax+11]
  002a0	2b d0		 sub	 edx, eax
  002a2	89 55 e4	 mov	 DWORD PTR _h$[ebp], edx

; 89   : 
; 90   : 			if ( w < 1 )

  002a5	83 7d e8 01	 cmp	 DWORD PTR _w$[ebp], 1
  002a9	7d 07		 jge	 SHORT $LN14@GetPositio

; 91   : 			{
; 92   : 				w = 1;

  002ab	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
$LN14@GetPositio:

; 93   : 			}
; 94   : 
; 95   : 			if ( h < 1 )

  002b2	83 7d e4 01	 cmp	 DWORD PTR _h$[ebp], 1
  002b6	7d 07		 jge	 SHORT $LN13@GetPositio

; 96   : 			{
; 97   : 				h = 1;

  002b8	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
$LN13@GetPositio:

; 98   : 			}
; 99   : 
; 100  : 			int iRX = GetLargeRand()%w;

  002bf	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  002c4	33 d2		 xor	 edx, edx
  002c6	f7 75 e8	 div	 DWORD PTR _w$[ebp]
  002c9	89 55 e0	 mov	 DWORD PTR _iRX$227835[ebp], edx

; 101  : 			int iRY = GetLargeRand()%h;

  002cc	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  002d1	33 d2		 xor	 edx, edx
  002d3	f7 75 e4	 div	 DWORD PTR _h$[ebp]
  002d6	89 55 dc	 mov	 DWORD PTR _iRY$227836[ebp], edx

; 102  : 
; 103  : 			tx = this->m_Mp[TableNum].m_X +  iRX;

  002d9	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  002dc	c1 e0 04	 shl	 eax, 4
  002df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e2	0f b6 54 01 0a	 movzx	 edx, BYTE PTR [ecx+eax+10]
  002e7	03 55 e0	 add	 edx, DWORD PTR _iRX$227835[ebp]
  002ea	89 55 f0	 mov	 DWORD PTR _tx$[ebp], edx

; 104  : 			ty = this->m_Mp[TableNum].m_Y +  iRY;

  002ed	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  002f0	c1 e0 04	 shl	 eax, 4
  002f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f6	0f b6 54 01 0b	 movzx	 edx, BYTE PTR [ecx+eax+11]
  002fb	03 55 dc	 add	 edx, DWORD PTR _iRY$227836[ebp]
  002fe	89 55 ec	 mov	 DWORD PTR _ty$[ebp], edx

; 105  : 			attr = MapC[MapNumber].GetAttr(tx, ty);

  00301	8b 45 ec	 mov	 eax, DWORD PTR _ty$[ebp]
  00304	50		 push	 eax
  00305	8b 4d f0	 mov	 ecx, DWORD PTR _tx$[ebp]
  00308	51		 push	 ecx
  00309	0f bf 4d 0c	 movsx	 ecx, WORD PTR _MapNumber$[ebp]
  0030d	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  00313	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00319	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0031e	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 106  : 
; 107  : 			if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  00321	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00325	83 e0 01	 and	 eax, 1
  00328	75 30		 jne	 SHORT $LN12@GetPositio
  0032a	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0032e	83 e0 04	 and	 eax, 4
  00331	75 27		 jne	 SHORT $LN12@GetPositio
  00333	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00337	83 e0 08	 and	 eax, 8
  0033a	75 1e		 jne	 SHORT $LN12@GetPositio

; 108  : 			{
; 109  : 				x = tx;

  0033c	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0033f	66 8b 4d f0	 mov	 cx, WORD PTR _tx$[ebp]
  00343	66 89 08	 mov	 WORD PTR [eax], cx

; 110  : 				y = ty;

  00346	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00349	66 8b 4d ec	 mov	 cx, WORD PTR _ty$[ebp]
  0034d	66 89 08	 mov	 WORD PTR [eax], cx

; 111  : 				return TRUE;

  00350	b8 01 00 00 00	 mov	 eax, 1
  00355	e9 8d 01 00 00	 jmp	 $LN21@GetPositio
$LN12@GetPositio:

; 112  : 			}
; 113  : 		}

  0035a	e9 f0 fe ff ff	 jmp	 $LN16@GetPositio
$LN15@GetPositio:

; 114  : 	}
; 115  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 0 )

  0035f	e9 81 01 00 00	 jmp	 $LN11@GetPositio
$LN18@GetPositio:
  00364	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00367	c1 e0 04	 shl	 eax, 4
  0036a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0036d	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00372	85 d2		 test	 edx, edx
  00374	75 39		 jne	 SHORT $LN10@GetPositio

; 116  : 	{
; 117  : 		x = this->m_Mp[TableNum].m_X;

  00376	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00379	c1 e0 04	 shl	 eax, 4
  0037c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037f	66 0f b6 54 01
	0a		 movzx	 dx, BYTE PTR [ecx+eax+10]
  00385	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00388	66 89 10	 mov	 WORD PTR [eax], dx

; 118  : 		y = this->m_Mp[TableNum].m_Y;

  0038b	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  0038e	c1 e0 04	 shl	 eax, 4
  00391	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00394	66 0f b6 54 01
	0b		 movzx	 dx, BYTE PTR [ecx+eax+11]
  0039a	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  0039d	66 89 10	 mov	 WORD PTR [eax], dx

; 119  : 		return true;

  003a0	b8 01 00 00 00	 mov	 eax, 1
  003a5	e9 3d 01 00 00	 jmp	 $LN21@GetPositio
  003aa	e9 36 01 00 00	 jmp	 $LN11@GetPositio
$LN10@GetPositio:

; 120  : 	}
; 121  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 2 )

  003af	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  003b2	c1 e0 04	 shl	 eax, 4
  003b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b8	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  003bd	83 fa 02	 cmp	 edx, 2
  003c0	0f 85 bf 00 00
	00		 jne	 $LN8@GetPositio
$LN7@GetPositio:

; 122  : 	{
; 123  : 		while ( count-- != 0 )

  003c6	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  003c9	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  003cc	83 e9 01	 sub	 ecx, 1
  003cf	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  003d2	85 c0		 test	 eax, eax
  003d4	0f 84 a9 00 00
	00		 je	 $LN6@GetPositio

; 124  : 		{
; 125  : 			int Orx = this->m_Mp[TableNum].m_X -3;

  003da	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  003dd	c1 e0 04	 shl	 eax, 4
  003e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e3	0f b6 54 01 0a	 movzx	 edx, BYTE PTR [ecx+eax+10]
  003e8	83 ea 03	 sub	 edx, 3
  003eb	89 55 d8	 mov	 DWORD PTR _Orx$227845[ebp], edx

; 126  : 			int Ory = this->m_Mp[TableNum].m_Y -3;

  003ee	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  003f1	c1 e0 04	 shl	 eax, 4
  003f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f7	0f b6 54 01 0b	 movzx	 edx, BYTE PTR [ecx+eax+11]
  003fc	83 ea 03	 sub	 edx, 3
  003ff	89 55 d4	 mov	 DWORD PTR _Ory$227846[ebp], edx

; 127  : 
; 128  : 			Orx += rand() % 7;

  00402	e8 00 00 00 00	 call	 _rand
  00407	99		 cdq
  00408	b9 07 00 00 00	 mov	 ecx, 7
  0040d	f7 f9		 idiv	 ecx
  0040f	03 55 d8	 add	 edx, DWORD PTR _Orx$227845[ebp]
  00412	89 55 d8	 mov	 DWORD PTR _Orx$227845[ebp], edx

; 129  : 			Ory += rand() % 7;

  00415	e8 00 00 00 00	 call	 _rand
  0041a	99		 cdq
  0041b	b9 07 00 00 00	 mov	 ecx, 7
  00420	f7 f9		 idiv	 ecx
  00422	03 55 d4	 add	 edx, DWORD PTR _Ory$227846[ebp]
  00425	89 55 d4	 mov	 DWORD PTR _Ory$227846[ebp], edx

; 130  : 
; 131  : 			attr = MapC[MapNumber].GetAttr(Orx, Ory);

  00428	8b 45 d4	 mov	 eax, DWORD PTR _Ory$227846[ebp]
  0042b	50		 push	 eax
  0042c	8b 4d d8	 mov	 ecx, DWORD PTR _Orx$227845[ebp]
  0042f	51		 push	 ecx
  00430	0f bf 4d 0c	 movsx	 ecx, WORD PTR _MapNumber$[ebp]
  00434	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0043a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00440	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00445	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 132  : 
; 133  : 			if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  00448	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0044c	83 e0 01	 and	 eax, 1
  0044f	75 2d		 jne	 SHORT $LN5@GetPositio
  00451	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00455	83 e0 04	 and	 eax, 4
  00458	75 24		 jne	 SHORT $LN5@GetPositio
  0045a	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0045e	83 e0 08	 and	 eax, 8
  00461	75 1b		 jne	 SHORT $LN5@GetPositio

; 134  : 			{
; 135  : 				x = Orx;

  00463	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00466	66 8b 4d d8	 mov	 cx, WORD PTR _Orx$227845[ebp]
  0046a	66 89 08	 mov	 WORD PTR [eax], cx

; 136  : 				y = Ory;

  0046d	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00470	66 8b 4d d4	 mov	 cx, WORD PTR _Ory$227846[ebp]
  00474	66 89 08	 mov	 WORD PTR [eax], cx

; 137  : 				return TRUE;

  00477	b8 01 00 00 00	 mov	 eax, 1
  0047c	eb 69		 jmp	 SHORT $LN21@GetPositio
$LN5@GetPositio:

; 138  : 			}
; 139  : 		}

  0047e	e9 43 ff ff ff	 jmp	 $LN7@GetPositio
$LN6@GetPositio:

; 140  : 	}
; 141  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 3 )

  00483	eb 60		 jmp	 SHORT $LN11@GetPositio
$LN8@GetPositio:
  00485	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00488	c1 e0 04	 shl	 eax, 4
  0048b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0048e	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00493	83 fa 03	 cmp	 edx, 3
  00496	75 09		 jne	 SHORT $LN3@GetPositio

; 142  : 	{
; 143  : 		return TRUE;

  00498	b8 01 00 00 00	 mov	 eax, 1
  0049d	eb 48		 jmp	 SHORT $LN21@GetPositio
  0049f	eb 44		 jmp	 SHORT $LN11@GetPositio
$LN3@GetPositio:

; 144  : 	}
; 145  : 
; 146  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 4 )

  004a1	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  004a4	c1 e0 04	 shl	 eax, 4
  004a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004aa	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  004af	83 fa 04	 cmp	 edx, 4
  004b2	75 31		 jne	 SHORT $LN11@GetPositio

; 147  : 	{
; 148  : 		x = this->m_Mp[TableNum].m_X;

  004b4	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  004b7	c1 e0 04	 shl	 eax, 4
  004ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004bd	66 0f b6 54 01
	0a		 movzx	 dx, BYTE PTR [ecx+eax+10]
  004c3	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  004c6	66 89 10	 mov	 WORD PTR [eax], dx

; 149  : 		y = this->m_Mp[TableNum].m_Y;

  004c9	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  004cc	c1 e0 04	 shl	 eax, 4
  004cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004d2	66 0f b6 54 01
	0b		 movzx	 dx, BYTE PTR [ecx+eax+11]
  004d8	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  004db	66 89 10	 mov	 WORD PTR [eax], dx

; 150  : 		return TRUE;

  004de	b8 01 00 00 00	 mov	 eax, 1
  004e3	eb 02		 jmp	 SHORT $LN21@GetPositio
$LN11@GetPositio:

; 151  : 	}
; 152  : #ifdef IMPERIAL_CONFLICT_NEW
; 153  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 5 )
; 154  : 	{
; 155  : 		x = this->m_Mp[TableNum].m_X;
; 156  : 		y = this->m_Mp[TableNum].m_Y;
; 157  : 		return TRUE;
; 158  : 	}
; 159  : #endif
; 160  : 	return false;

  004e5	33 c0		 xor	 eax, eax
$LN21@GetPositio:

; 161  : }

  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi
  004e9	5b		 pop	 ebx
  004ea	8b e5		 mov	 esp, ebp
  004ec	5d		 pop	 ebp
  004ed	c2 10 00	 ret	 16			; 00000010H
?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ENDP		; CMonsterSetBase::GetPosition
_TEXT	ENDS
PUBLIC	??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA ; `CMonsterSetBase::LoadSetBase'::`2'::__LINE__Var
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z		; CMonsterSetBase::LoadSetBase
EXTRN	_fclose:PROC
EXTRN	?CheckMapCanMove@CMapServerManager@@QAEHH@Z:PROC ; CMapServerManager::CheckMapCanMove
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@
CONST	SEGMENT
??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@ DB 'Mo'
	DB	'nster attribute max over %d (%s %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ DB 'Monst'
	DB	'er attribute max over %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA DD 0a4H ; `CMonsterSetBase::LoadSetBase'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@ DB 'file open error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv563 = -116						; size = 4
tv507 = -116						; size = 4
tv495 = -116						; size = 4
tv479 = -116						; size = 4
tv467 = -116						; size = 4
tv455 = -116						; size = 4
tv443 = -116						; size = 4
tv431 = -116						; size = 4
tv561 = -112						; size = 4
tv505 = -112						; size = 4
tv493 = -112						; size = 4
tv477 = -112						; size = 4
tv465 = -112						; size = 4
tv453 = -112						; size = 4
tv441 = -112						; size = 4
tv429 = -112						; size = 4
tv558 = -106						; size = 2
tv502 = -106						; size = 2
tv490 = -106						; size = 2
tv474 = -106						; size = 2
tv462 = -106						; size = 2
tv450 = -106						; size = 2
tv438 = -106						; size = 2
tv426 = -106						; size = 2
_k$227900 = -40						; size = 4
_h$227897 = -34						; size = 1
_w$227896 = -33						; size = 1
_h$227887 = -32						; size = 4
_w$227886 = -28						; size = 4
_Type$227868 = -24					; size = 4
_Sdir$ = -17						; size = 1
_copycount$ = -16					; size = 4
_rcount$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z PROC		; CMonsterSetBase::LoadSetBase
; _this$ = ecx

; 164  : {

  004f0	55		 push	 ebp
  004f1	8b ec		 mov	 ebp, esp
  004f3	83 ec 74	 sub	 esp, 116		; 00000074H
  004f6	53		 push	 ebx
  004f7	56		 push	 esi
  004f8	57		 push	 edi
  004f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 165  : 	int Token;
; 166  : 	int rcount;
; 167  : 	int copycount;
; 168  : 	BYTE Sdir;
; 169  : 
; 170  : 	SMDFile = fopen(filename, "r");

  004fc	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00501	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00504	50		 push	 eax
  00505	e8 00 00 00 00	 call	 _fopen
  0050a	83 c4 08	 add	 esp, 8
  0050d	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 171  : 
; 172  : 	if ( SMDFile == NULL )

  00512	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00519	75 16		 jne	 SHORT $LN28@LoadSetBas

; 173  : 	{
; 174  : 		MsgBox("file open error %s", filename);

  0051b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0051e	50		 push	 eax
  0051f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@
  00524	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00529	83 c4 08	 add	 esp, 8

; 175  : 		return;

  0052c	e9 cd 06 00 00	 jmp	 $LN29@LoadSetBas
$LN28@LoadSetBas:

; 176  : 	}
; 177  : 
; 178  : 	this->m_Count = 0;

  00531	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00534	c7 80 84 2c 03
	00 00 00 00 00	 mov	 DWORD PTR [eax+208004], 0
$LN27@LoadSetBas:

; 179  : 
; 180  : 	while ( true )

  0053e	b8 01 00 00 00	 mov	 eax, 1
  00543	85 c0		 test	 eax, eax
  00545	0f 84 a5 06 00
	00		 je	 $LN26@LoadSetBas

; 181  : 	{
; 182  : 		Token = GetToken();

  0054b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00550	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 183  : 
; 184  : 		if ( Token == 2 )

  00553	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00557	75 05		 jne	 SHORT $LN25@LoadSetBas

; 185  : 			break;

  00559	e9 92 06 00 00	 jmp	 $LN26@LoadSetBas
$LN25@LoadSetBas:

; 186  : 
; 187  : 		if ( Token == 1 )

  0055e	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00562	0f 85 83 06 00
	00		 jne	 $LN22@LoadSetBas

; 188  : 		{
; 189  : 			int Type = (int)TokenNumber;

  00568	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0056e	e8 00 00 00 00	 call	 __ftol2_sse
  00573	89 45 e8	 mov	 DWORD PTR _Type$227868[ebp], eax
$LN31@LoadSetBas:

; 190  : 
; 191  : 			while ( true )

  00576	b8 01 00 00 00	 mov	 eax, 1
  0057b	85 c0		 test	 eax, eax
  0057d	0f 84 68 06 00
	00		 je	 $LN22@LoadSetBas

; 192  : 			{
; 193  : 				Token = GetToken();

  00583	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00588	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 194  : 
; 195  : 				if ( strcmp("end", TokenString) == 0 )

  0058b	68 00 00 00 00	 push	 OFFSET _TokenString
  00590	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00595	e8 00 00 00 00	 call	 _strcmp
  0059a	83 c4 08	 add	 esp, 8
  0059d	85 c0		 test	 eax, eax
  0059f	75 05		 jne	 SHORT $LN21@LoadSetBas

; 196  : 					break;

  005a1	e9 45 06 00 00	 jmp	 $LN22@LoadSetBas
$LN21@LoadSetBas:

; 197  : 				
; 198  : 				this->m_Mp[this->m_Count].m_Type = (WORD)TokenNumber;

  005a6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005ac	d9 7d 96	 fnstcw	 WORD PTR tv426[ebp]
  005af	0f b7 45 96	 movzx	 eax, WORD PTR tv426[ebp]
  005b3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005b8	89 45 90	 mov	 DWORD PTR tv429[ebp], eax
  005bb	d9 6d 90	 fldcw	 WORD PTR tv429[ebp]
  005be	db 5d 8c	 fistp	 DWORD PTR tv431[ebp]
  005c1	d9 6d 96	 fldcw	 WORD PTR tv426[ebp]
  005c4	66 8b 45 8c	 mov	 ax, WORD PTR tv431[ebp]
  005c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005cb	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  005d1	c1 e2 04	 shl	 edx, 4
  005d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005d7	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax

; 199  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_MapNumber = (BYTE)TokenNumber;

  005dc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005e1	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  005e4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005ea	d9 7d 96	 fnstcw	 WORD PTR tv438[ebp]
  005ed	0f b7 45 96	 movzx	 eax, WORD PTR tv438[ebp]
  005f1	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005f6	89 45 90	 mov	 DWORD PTR tv441[ebp], eax
  005f9	d9 6d 90	 fldcw	 WORD PTR tv441[ebp]
  005fc	db 5d 8c	 fistp	 DWORD PTR tv443[ebp]
  005ff	d9 6d 96	 fldcw	 WORD PTR tv438[ebp]
  00602	8a 45 8c	 mov	 al, BYTE PTR tv443[ebp]
  00605	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00608	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0060e	c1 e2 04	 shl	 edx, 4
  00611	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00614	88 44 11 08	 mov	 BYTE PTR [ecx+edx+8], al

; 200  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_Dis = (BYTE)TokenNumber;

  00618	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0061d	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00620	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00626	d9 7d 96	 fnstcw	 WORD PTR tv450[ebp]
  00629	0f b7 45 96	 movzx	 eax, WORD PTR tv450[ebp]
  0062d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00632	89 45 90	 mov	 DWORD PTR tv453[ebp], eax
  00635	d9 6d 90	 fldcw	 WORD PTR tv453[ebp]
  00638	db 5d 8c	 fistp	 DWORD PTR tv455[ebp]
  0063b	d9 6d 96	 fldcw	 WORD PTR tv450[ebp]
  0063e	8a 45 8c	 mov	 al, BYTE PTR tv455[ebp]
  00641	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00644	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0064a	c1 e2 04	 shl	 edx, 4
  0064d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00650	88 44 11 09	 mov	 BYTE PTR [ecx+edx+9], al

; 201  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_X = (BYTE)TokenNumber;

  00654	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00659	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0065c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00662	d9 7d 96	 fnstcw	 WORD PTR tv462[ebp]
  00665	0f b7 45 96	 movzx	 eax, WORD PTR tv462[ebp]
  00669	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0066e	89 45 90	 mov	 DWORD PTR tv465[ebp], eax
  00671	d9 6d 90	 fldcw	 WORD PTR tv465[ebp]
  00674	db 5d 8c	 fistp	 DWORD PTR tv467[ebp]
  00677	d9 6d 96	 fldcw	 WORD PTR tv462[ebp]
  0067a	8a 45 8c	 mov	 al, BYTE PTR tv467[ebp]
  0067d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00680	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00686	c1 e2 04	 shl	 edx, 4
  00689	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0068c	88 44 11 0a	 mov	 BYTE PTR [ecx+edx+10], al

; 202  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_Y = (BYTE)TokenNumber;

  00690	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00695	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00698	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0069e	d9 7d 96	 fnstcw	 WORD PTR tv474[ebp]
  006a1	0f b7 45 96	 movzx	 eax, WORD PTR tv474[ebp]
  006a5	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  006aa	89 45 90	 mov	 DWORD PTR tv477[ebp], eax
  006ad	d9 6d 90	 fldcw	 WORD PTR tv477[ebp]
  006b0	db 5d 8c	 fistp	 DWORD PTR tv479[ebp]
  006b3	d9 6d 96	 fldcw	 WORD PTR tv474[ebp]
  006b6	8a 45 8c	 mov	 al, BYTE PTR tv479[ebp]
  006b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006bc	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  006c2	c1 e2 04	 shl	 edx, 4
  006c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c8	88 44 11 0b	 mov	 BYTE PTR [ecx+edx+11], al

; 203  : 				this->m_Mp[this->m_Count].m_ArrangeType = Type;

  006cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006cf	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  006d5	c1 e1 04	 shl	 ecx, 4
  006d8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006db	8a 45 e8	 mov	 al, BYTE PTR _Type$227868[ebp]
  006de	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 204  : 
; 205  : 				if ( Type == 1 || Type == 3 )

  006e2	83 7d e8 01	 cmp	 DWORD PTR _Type$227868[ebp], 1
  006e6	74 06		 je	 SHORT $LN19@LoadSetBas
  006e8	83 7d e8 03	 cmp	 DWORD PTR _Type$227868[ebp], 3
  006ec	75 7d		 jne	 SHORT $LN20@LoadSetBas
$LN19@LoadSetBas:

; 206  : 				{
; 207  : 					Token = GetToken();	this->m_Mp[this->m_Count].m_W = (BYTE)TokenNumber;

  006ee	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006f3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  006f6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006fc	d9 7d 96	 fnstcw	 WORD PTR tv490[ebp]
  006ff	0f b7 45 96	 movzx	 eax, WORD PTR tv490[ebp]
  00703	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00708	89 45 90	 mov	 DWORD PTR tv493[ebp], eax
  0070b	d9 6d 90	 fldcw	 WORD PTR tv493[ebp]
  0070e	db 5d 8c	 fistp	 DWORD PTR tv495[ebp]
  00711	d9 6d 96	 fldcw	 WORD PTR tv490[ebp]
  00714	8a 45 8c	 mov	 al, BYTE PTR tv495[ebp]
  00717	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0071a	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00720	c1 e2 04	 shl	 edx, 4
  00723	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00726	88 44 11 0d	 mov	 BYTE PTR [ecx+edx+13], al

; 208  : 					Token = GetToken();	this->m_Mp[this->m_Count].m_H = (BYTE)TokenNumber;

  0072a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0072f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00732	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00738	d9 7d 96	 fnstcw	 WORD PTR tv502[ebp]
  0073b	0f b7 45 96	 movzx	 eax, WORD PTR tv502[ebp]
  0073f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00744	89 45 90	 mov	 DWORD PTR tv505[ebp], eax
  00747	d9 6d 90	 fldcw	 WORD PTR tv505[ebp]
  0074a	db 5d 8c	 fistp	 DWORD PTR tv507[ebp]
  0074d	d9 6d 96	 fldcw	 WORD PTR tv502[ebp]
  00750	8a 45 8c	 mov	 al, BYTE PTR tv507[ebp]
  00753	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00756	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0075c	c1 e2 04	 shl	 edx, 4
  0075f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00762	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al
  00766	e9 12 01 00 00	 jmp	 $LN14@LoadSetBas
$LN20@LoadSetBas:

; 209  : 				}
; 210  : 				else if ( Type == 2 )

  0076b	83 7d e8 02	 cmp	 DWORD PTR _Type$227868[ebp], 2
  0076f	0f 85 b0 00 00
	00		 jne	 $LN17@LoadSetBas

; 211  : 				{
; 212  : 					this->m_Mp[this->m_Count].m_W = 0;

  00775	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00778	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0077e	c1 e1 04	 shl	 ecx, 4
  00781	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00784	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 213  : 					this->m_Mp[this->m_Count].m_H = 0;

  00789	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0078c	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00792	c1 e1 04	 shl	 ecx, 4
  00795	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00798	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0

; 214  : 
; 215  : 					int w = this->m_Mp[this->m_Count].m_X - 3;

  0079d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007a0	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  007a6	c1 e1 04	 shl	 ecx, 4
  007a9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007ac	0f b6 44 0a 0a	 movzx	 eax, BYTE PTR [edx+ecx+10]
  007b1	83 e8 03	 sub	 eax, 3
  007b4	89 45 e4	 mov	 DWORD PTR _w$227886[ebp], eax

; 216  : 					int h = this->m_Mp[this->m_Count].m_Y - 3;

  007b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007ba	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  007c0	c1 e1 04	 shl	 ecx, 4
  007c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007c6	0f b6 44 0a 0b	 movzx	 eax, BYTE PTR [edx+ecx+11]
  007cb	83 e8 03	 sub	 eax, 3
  007ce	89 45 e0	 mov	 DWORD PTR _h$227887[ebp], eax

; 217  : 
; 218  : 					w += rand() % 7;

  007d1	e8 00 00 00 00	 call	 _rand
  007d6	99		 cdq
  007d7	b9 07 00 00 00	 mov	 ecx, 7
  007dc	f7 f9		 idiv	 ecx
  007de	03 55 e4	 add	 edx, DWORD PTR _w$227886[ebp]
  007e1	89 55 e4	 mov	 DWORD PTR _w$227886[ebp], edx

; 219  : 					h += rand() % 7;

  007e4	e8 00 00 00 00	 call	 _rand
  007e9	99		 cdq
  007ea	b9 07 00 00 00	 mov	 ecx, 7
  007ef	f7 f9		 idiv	 ecx
  007f1	03 55 e0	 add	 edx, DWORD PTR _h$227887[ebp]
  007f4	89 55 e0	 mov	 DWORD PTR _h$227887[ebp], edx

; 220  : 
; 221  : 					this->m_Mp[this->m_Count].m_X = w;

  007f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007fa	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00800	c1 e1 04	 shl	 ecx, 4
  00803	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00806	8a 45 e4	 mov	 al, BYTE PTR _w$227886[ebp]
  00809	88 44 0a 0a	 mov	 BYTE PTR [edx+ecx+10], al

; 222  : 					this->m_Mp[this->m_Count].m_Y = h;

  0080d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00810	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00816	c1 e1 04	 shl	 ecx, 4
  00819	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0081c	8a 45 e0	 mov	 al, BYTE PTR _h$227887[ebp]
  0081f	88 44 0a 0b	 mov	 BYTE PTR [edx+ecx+11], al
  00823	eb 58		 jmp	 SHORT $LN14@LoadSetBas
$LN17@LoadSetBas:

; 223  : 				}
; 224  : 				else if ( Type == 4 )

  00825	83 7d e8 04	 cmp	 DWORD PTR _Type$227868[ebp], 4
  00829	75 2a		 jne	 SHORT $LN15@LoadSetBas

; 225  : 				{
; 226  : 					this->m_Mp[this->m_Count].m_W = 0;

  0082b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0082e	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00834	c1 e1 04	 shl	 ecx, 4
  00837	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0083a	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 227  : 					this->m_Mp[this->m_Count].m_H = 0;

  0083f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00842	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00848	c1 e1 04	 shl	 ecx, 4
  0084b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0084e	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0

; 228  : 				}
; 229  : 				else

  00853	eb 28		 jmp	 SHORT $LN14@LoadSetBas
$LN15@LoadSetBas:

; 230  : 				{
; 231  : 					this->m_Mp[this->m_Count].m_W = 0;

  00855	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00858	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0085e	c1 e1 04	 shl	 ecx, 4
  00861	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00864	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 232  : 					this->m_Mp[this->m_Count].m_H = 0;

  00869	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0086c	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00872	c1 e1 04	 shl	 ecx, 4
  00875	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00878	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0
$LN14@LoadSetBas:

; 233  : 				}
; 234  : 
; 235  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_Dir = (BYTE)TokenNumber;

  0087d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00882	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00885	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0088b	d9 7d 96	 fnstcw	 WORD PTR tv558[ebp]
  0088e	0f b7 45 96	 movzx	 eax, WORD PTR tv558[ebp]
  00892	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00897	89 45 90	 mov	 DWORD PTR tv561[ebp], eax
  0089a	d9 6d 90	 fldcw	 WORD PTR tv561[ebp]
  0089d	db 5d 8c	 fistp	 DWORD PTR tv563[ebp]
  008a0	d9 6d 96	 fldcw	 WORD PTR tv558[ebp]
  008a3	8a 45 8c	 mov	 al, BYTE PTR tv563[ebp]
  008a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008a9	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  008af	c1 e2 04	 shl	 edx, 4
  008b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008b5	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al

; 236  : 				Sdir = this->m_Mp[this->m_Count].m_Dir;

  008b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008bc	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  008c2	c1 e1 04	 shl	 ecx, 4
  008c5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008c8	8a 44 0a 0c	 mov	 al, BYTE PTR [edx+ecx+12]
  008cc	88 45 ef	 mov	 BYTE PTR _Sdir$[ebp], al

; 237  : 
; 238  : 				if ( this->m_Mp[this->m_Count].m_Dir == (BYTE)-1 )

  008cf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008d2	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  008d8	c1 e1 04	 shl	 ecx, 4
  008db	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008de	0f b6 44 0a 0c	 movzx	 eax, BYTE PTR [edx+ecx+12]
  008e3	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  008e8	75 24		 jne	 SHORT $LN13@LoadSetBas

; 239  : 					this->m_Mp[this->m_Count].m_Dir = rand() % 8;

  008ea	e8 00 00 00 00	 call	 _rand
  008ef	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  008f4	79 05		 jns	 SHORT $LN32@LoadSetBas
  008f6	48		 dec	 eax
  008f7	83 c8 f8	 or	 eax, -8			; fffffff8H
  008fa	40		 inc	 eax
$LN32@LoadSetBas:
  008fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008fe	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00904	c1 e2 04	 shl	 edx, 4
  00907	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0090a	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
$LN13@LoadSetBas:

; 240  : 
; 241  : 				if ( Type == 1 || Type == 3 )

  0090e	83 7d e8 01	 cmp	 DWORD PTR _Type$227868[ebp], 1
  00912	74 0a		 je	 SHORT $LN11@LoadSetBas
  00914	83 7d e8 03	 cmp	 DWORD PTR _Type$227868[ebp], 3
  00918	0f 85 45 02 00
	00		 jne	 $LN7@LoadSetBas
$LN11@LoadSetBas:

; 242  : 				{
; 243  : 					BYTE w = this->m_Mp[this->m_Count].m_X;

  0091e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00921	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00927	c1 e1 04	 shl	 ecx, 4
  0092a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0092d	8a 44 0a 0a	 mov	 al, BYTE PTR [edx+ecx+10]
  00931	88 45 df	 mov	 BYTE PTR _w$227896[ebp], al

; 244  : 					BYTE h = this->m_Mp[this->m_Count].m_Y;

  00934	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00937	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0093d	c1 e1 04	 shl	 ecx, 4
  00940	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00943	8a 44 0a 0b	 mov	 al, BYTE PTR [edx+ecx+11]
  00947	88 45 de	 mov	 BYTE PTR _h$227897[ebp], al

; 245  : 
; 246  : 					Token = GetToken();	rcount = (int)TokenNumber;

  0094a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0094f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00952	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00958	e8 00 00 00 00	 call	 __ftol2_sse
  0095d	89 45 f4	 mov	 DWORD PTR _rcount$[ebp], eax

; 247  : 					copycount = this->m_Count;

  00960	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00963	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00969	89 4d f0	 mov	 DWORD PTR _copycount$[ebp], ecx

; 248  : 
; 249  : 					if ( rcount > 1 )

  0096c	83 7d f4 01	 cmp	 DWORD PTR _rcount$[ebp], 1
  00970	0f 8e ed 01 00
	00		 jle	 $LN7@LoadSetBas

; 250  : 					{
; 251  : 						for ( int k = 0; k<rcount-1 ; k++ )

  00976	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _k$227900[ebp], 0
  0097d	eb 09		 jmp	 SHORT $LN9@LoadSetBas
$LN8@LoadSetBas:
  0097f	8b 45 d8	 mov	 eax, DWORD PTR _k$227900[ebp]
  00982	83 c0 01	 add	 eax, 1
  00985	89 45 d8	 mov	 DWORD PTR _k$227900[ebp], eax
$LN9@LoadSetBas:
  00988	8b 45 f4	 mov	 eax, DWORD PTR _rcount$[ebp]
  0098b	83 e8 01	 sub	 eax, 1
  0098e	39 45 d8	 cmp	 DWORD PTR _k$227900[ebp], eax
  00991	0f 8d cc 01 00
	00		 jge	 $LN7@LoadSetBas

; 252  : 						{
; 253  : 							if ( g_MapServerManager.CheckMapCanMove(this->m_Mp[copycount].m_MapNumber) == FALSE )

  00997	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  0099a	c1 e0 04	 shl	 eax, 4
  0099d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009a0	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  009a5	52		 push	 edx
  009a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  009ab	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  009b0	85 c0		 test	 eax, eax
  009b2	75 05		 jne	 SHORT $LN6@LoadSetBas

; 254  : 								break;

  009b4	e9 aa 01 00 00	 jmp	 $LN7@LoadSetBas
$LN6@LoadSetBas:

; 255  : 						
; 256  : 							this->m_Count++;

  009b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009bc	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  009c2	83 c1 01	 add	 ecx, 1
  009c5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009c8	89 8a 84 2c 03
	00		 mov	 DWORD PTR [edx+208004], ecx

; 257  : 
; 258  : 							if ( this->m_Count > OBJ_MAXMONSTER-1 )

  009ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009d1	81 b8 84 2c 03
	00 c7 32 00 00	 cmp	 DWORD PTR [eax+208004], 12999 ; 000032c7H
  009db	7e 2e		 jle	 SHORT $LN5@LoadSetBas

; 259  : 							{
; 260  : 								MsgBox("Monster attribute max over %s %d", __FILE__, __LINE__);

  009dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA
  009e2	83 c0 60	 add	 eax, 96			; 00000060H
  009e5	50		 push	 eax
  009e6	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@
  009eb	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
  009f0	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  009f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  : 								fclose(SMDFile);

  009f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  009fd	50		 push	 eax
  009fe	e8 00 00 00 00	 call	 _fclose
  00a03	83 c4 04	 add	 esp, 4

; 262  : 								return;

  00a06	e9 f3 01 00 00	 jmp	 $LN29@LoadSetBas
$LN5@LoadSetBas:

; 263  : 							}
; 264  : 
; 265  : 							this->m_Mp[this->m_Count].m_Dis = this->m_Mp[copycount].m_Dis;

  00a0b	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00a0e	c1 e0 04	 shl	 eax, 4
  00a11	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a14	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00a1a	c1 e2 04	 shl	 edx, 4
  00a1d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a20	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00a23	8a 44 06 09	 mov	 al, BYTE PTR [esi+eax+9]
  00a27	88 44 11 09	 mov	 BYTE PTR [ecx+edx+9], al

; 266  : 							this->m_Mp[this->m_Count].m_Type = this->m_Mp[copycount].m_Type;

  00a2b	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00a2e	c1 e0 04	 shl	 eax, 4
  00a31	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a34	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00a3a	c1 e2 04	 shl	 edx, 4
  00a3d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a40	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00a43	66 8b 44 06 06	 mov	 ax, WORD PTR [esi+eax+6]
  00a48	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax

; 267  : 							this->m_Mp[this->m_Count].m_MapNumber = this->m_Mp[copycount].m_MapNumber;

  00a4d	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00a50	c1 e0 04	 shl	 eax, 4
  00a53	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a56	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00a5c	c1 e2 04	 shl	 edx, 4
  00a5f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a62	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00a65	8a 44 06 08	 mov	 al, BYTE PTR [esi+eax+8]
  00a69	88 44 11 08	 mov	 BYTE PTR [ecx+edx+8], al

; 268  : 							this->m_Mp[this->m_Count].m_W = this->m_Mp[copycount].m_W;

  00a6d	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00a70	c1 e0 04	 shl	 eax, 4
  00a73	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a76	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00a7c	c1 e2 04	 shl	 edx, 4
  00a7f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a82	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00a85	8a 44 06 0d	 mov	 al, BYTE PTR [esi+eax+13]
  00a89	88 44 11 0d	 mov	 BYTE PTR [ecx+edx+13], al

; 269  : 							this->m_Mp[this->m_Count].m_H = this->m_Mp[copycount].m_H;

  00a8d	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00a90	c1 e0 04	 shl	 eax, 4
  00a93	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a96	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00a9c	c1 e2 04	 shl	 edx, 4
  00a9f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa2	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00aa5	8a 44 06 0e	 mov	 al, BYTE PTR [esi+eax+14]
  00aa9	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al

; 270  : 							this->m_Mp[this->m_Count].m_X = this->m_Mp[copycount].m_X;

  00aad	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00ab0	c1 e0 04	 shl	 eax, 4
  00ab3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ab6	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00abc	c1 e2 04	 shl	 edx, 4
  00abf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac2	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00ac5	8a 44 06 0a	 mov	 al, BYTE PTR [esi+eax+10]
  00ac9	88 44 11 0a	 mov	 BYTE PTR [ecx+edx+10], al

; 271  : 							this->m_Mp[this->m_Count].m_Y = this->m_Mp[copycount].m_Y;

  00acd	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00ad0	c1 e0 04	 shl	 eax, 4
  00ad3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad6	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00adc	c1 e2 04	 shl	 edx, 4
  00adf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae2	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00ae5	8a 44 06 0b	 mov	 al, BYTE PTR [esi+eax+11]
  00ae9	88 44 11 0b	 mov	 BYTE PTR [ecx+edx+11], al

; 272  : 							this->m_Mp[this->m_Count].m_ArrangeType = this->m_Mp[copycount].m_ArrangeType;

  00aed	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00af0	c1 e0 04	 shl	 eax, 4
  00af3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00af6	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00afc	c1 e2 04	 shl	 edx, 4
  00aff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b02	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00b05	8a 44 06 04	 mov	 al, BYTE PTR [esi+eax+4]
  00b09	88 44 11 04	 mov	 BYTE PTR [ecx+edx+4], al

; 273  : 
; 274  : 							if ( Sdir == (BYTE)-1 )

  00b0d	0f b6 45 ef	 movzx	 eax, BYTE PTR _Sdir$[ebp]
  00b11	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00b16	75 26		 jne	 SHORT $LN4@LoadSetBas

; 275  : 								this->m_Mp[this->m_Count].m_Dir = rand() % 8;

  00b18	e8 00 00 00 00	 call	 _rand
  00b1d	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00b22	79 05		 jns	 SHORT $LN33@LoadSetBas
  00b24	48		 dec	 eax
  00b25	83 c8 f8	 or	 eax, -8			; fffffff8H
  00b28	40		 inc	 eax
$LN33@LoadSetBas:
  00b29	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b2c	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00b32	c1 e2 04	 shl	 edx, 4
  00b35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b38	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al

; 276  : 							else

  00b3c	eb 20		 jmp	 SHORT $LN3@LoadSetBas
$LN4@LoadSetBas:

; 277  : 								this->m_Mp[this->m_Count].m_Dir = this->m_Mp[copycount].m_Dir;

  00b3e	8b 45 f0	 mov	 eax, DWORD PTR _copycount$[ebp]
  00b41	c1 e0 04	 shl	 eax, 4
  00b44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b47	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00b4d	c1 e2 04	 shl	 edx, 4
  00b50	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b53	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00b56	8a 44 06 0c	 mov	 al, BYTE PTR [esi+eax+12]
  00b5a	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
$LN3@LoadSetBas:

; 278  : 						}

  00b5e	e9 1c fe ff ff	 jmp	 $LN8@LoadSetBas
$LN7@LoadSetBas:

; 279  : 					}
; 280  : 				}
; 281  : 
; 282  : 
; 283  : 				
; 284  : #ifdef IMPERIAL_CONFLICT_NEW
; 285  : 
; 286  : 				else if(Type == 5)
; 287  : 				{
; 288  : 					GetToken();
; 289  : 					this->m_Mp[this->m_Count].m_IG_ZoneIndex = TokenNumber;
; 290  : 
; 291  : 					GetToken();
; 292  : 					this->m_Mp[this->m_Count].m_IG_RegenTable = TokenNumber;
; 293  : 				}
; 294  : #endif
; 295  : 
; 296  : 				if ( g_MapServerManager.CheckMapCanMove(this->m_Mp[this->m_Count].m_MapNumber) == FALSE )

  00b63	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b66	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00b6c	c1 e1 04	 shl	 ecx, 4
  00b6f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b72	0f b6 44 0a 08	 movzx	 eax, BYTE PTR [edx+ecx+8]
  00b77	50		 push	 eax
  00b78	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  00b7d	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  00b82	85 c0		 test	 eax, eax
  00b84	75 05		 jne	 SHORT $LN2@LoadSetBas

; 297  : 					continue;

  00b86	e9 eb f9 ff ff	 jmp	 $LN31@LoadSetBas
$LN2@LoadSetBas:

; 298  : 
; 299  : 				this->m_Count++;

  00b8b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b8e	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  00b94	83 c1 01	 add	 ecx, 1
  00b97	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b9a	89 8a 84 2c 03
	00		 mov	 DWORD PTR [edx+208004], ecx

; 300  : 
; 301  : 				if ( this->m_Count > OBJ_MAXMONSTER-1 )

  00ba0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ba3	81 b8 84 2c 03
	00 c7 32 00 00	 cmp	 DWORD PTR [eax+208004], 12999 ; 000032c7H
  00bad	7e 37		 jle	 SHORT $LN1@LoadSetBas

; 302  : 				{
; 303  : 					MsgBox("Monster attribute max over %d (%s %d)", this->m_Count, __FILE__, __LINE__);

  00baf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA
  00bb4	05 8b 00 00 00	 add	 eax, 139		; 0000008bH
  00bb9	50		 push	 eax
  00bba	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@
  00bbf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc2	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  00bc8	52		 push	 edx
  00bc9	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@
  00bce	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00bd3	83 c4 10	 add	 esp, 16			; 00000010H

; 304  : 					fclose(SMDFile);

  00bd6	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00bdb	50		 push	 eax
  00bdc	e8 00 00 00 00	 call	 _fclose
  00be1	83 c4 04	 add	 esp, 4

; 305  : 					return;

  00be4	eb 18		 jmp	 SHORT $LN29@LoadSetBas
$LN1@LoadSetBas:

; 306  : 				}
; 307  : 			}

  00be6	e9 8b f9 ff ff	 jmp	 $LN31@LoadSetBas
$LN22@LoadSetBas:

; 308  : 		}
; 309  : 	}

  00beb	e9 4e f9 ff ff	 jmp	 $LN27@LoadSetBas
$LN26@LoadSetBas:

; 310  : 
; 311  : 	fclose(SMDFile);

  00bf0	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00bf5	50		 push	 eax
  00bf6	e8 00 00 00 00	 call	 _fclose
  00bfb	83 c4 04	 add	 esp, 4
$LN29@LoadSetBas:

; 312  : }

  00bfe	5f		 pop	 edi
  00bff	5e		 pop	 esi
  00c00	5b		 pop	 ebx
  00c01	8b e5		 mov	 esp, ebp
  00c03	5d		 pop	 ebp
  00c04	c2 04 00	 ret	 4
?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z ENDP		; CMonsterSetBase::LoadSetBase
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00c10	55		 push	 ebp
  00c11	8b ec		 mov	 ebp, esp
  00c13	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00c19	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00c1e	33 c5		 xor	 eax, ebp
  00c20	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00c23	53		 push	 ebx
  00c24	56		 push	 esi
  00c25	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00c26	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00c2d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c32	50		 push	 eax
  00c33	e8 00 00 00 00	 call	 _fgetc
  00c38	83 c4 04	 add	 esp, 4
  00c3b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00c3e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c42	83 f9 ff	 cmp	 ecx, -1
  00c45	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00c47	b8 02 00 00 00	 mov	 eax, 2
  00c4c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00c51	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00c53	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c57	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00c5a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  00c5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c61	50		 push	 eax
  00c62	e8 00 00 00 00	 call	 _fgetc
  00c67	83 c4 04	 add	 esp, 4
  00c6a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00c6d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c71	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00c74	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00c76	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c7a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00c7d	74 1c		 je	 SHORT $LN23@GetToken
  00c7f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c83	83 f8 ff	 cmp	 eax, -1
  00c86	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00c88	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c8d	50		 push	 eax
  00c8e	e8 00 00 00 00	 call	 _fgetc
  00c93	83 c4 04	 add	 esp, 4
  00c96	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00c99	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  00c9b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c9f	83 f8 ff	 cmp	 eax, -1
  00ca2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00ca4	b8 02 00 00 00	 mov	 eax, 2
  00ca9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  00cae	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00cb2	50		 push	 eax
  00cb3	e8 00 00 00 00	 call	 _isspace
  00cb8	83 c4 04	 add	 esp, 4
  00cbb	85 c0		 test	 eax, eax
  00cbd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00cc3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00cc7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  00ccd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00cd3	83 e9 22	 sub	 ecx, 34			; 00000022H
  00cd6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  00cdc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00ce3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00ce9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  00cef	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00cf6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  00cfd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00d07	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d0c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00d11	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00d16	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00d20	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d25	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  00d2a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  00d2f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00d39	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d3e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00d43	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00d48	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00d52	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d57	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  00d5c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00d61	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  00d6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00d70	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00d75	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00d7a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d7f	50		 push	 eax
  00d80	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00d84	51		 push	 ecx
  00d85	e8 00 00 00 00	 call	 _ungetc
  00d8a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  00d8d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00d90	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00d93	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d98	50		 push	 eax
  00d99	e8 00 00 00 00	 call	 _getc
  00d9e	83 c4 04	 add	 esp, 4
  00da1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00da4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00da8	83 f9 ff	 cmp	 ecx, -1
  00dab	74 36		 je	 SHORT $LN12@GetToken
  00dad	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00db1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00db4	74 1a		 je	 SHORT $LN11@GetToken
  00db6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00dba	50		 push	 eax
  00dbb	e8 00 00 00 00	 call	 _isdigit
  00dc0	83 c4 04	 add	 esp, 4
  00dc3	85 c0		 test	 eax, eax
  00dc5	75 09		 jne	 SHORT $LN11@GetToken
  00dc7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00dcb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00dce	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00dd0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00dd3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00dd6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00dd8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ddb	83 c0 01	 add	 eax, 1
  00dde	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00de1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00de3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00de6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00de9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00dec	50		 push	 eax
  00ded	e8 00 00 00 00	 call	 _atof
  00df2	83 c4 04	 add	 esp, 4
  00df5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00dfb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00e05	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e0a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00e0f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00e14	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00e1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00e20	50		 push	 eax
  00e21	e8 00 00 00 00	 call	 _getc
  00e26	83 c4 04	 add	 esp, 4
  00e29	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00e2c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00e30	83 f9 ff	 cmp	 ecx, -1
  00e33	74 1c		 je	 SHORT $LN8@GetToken
  00e35	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e39	83 f8 22	 cmp	 eax, 34			; 00000022H
  00e3c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00e3e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e41	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00e44	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00e46	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e49	83 c0 01	 add	 eax, 1
  00e4c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00e4f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00e51	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e55	83 f8 22	 cmp	 eax, 34			; 00000022H
  00e58	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00e5a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00e5f	50		 push	 eax
  00e60	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00e64	51		 push	 ecx
  00e65	e8 00 00 00 00	 call	 _ungetc
  00e6a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00e6d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00e70	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00e73	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00e7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e82	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00e87	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00e8c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00e90	50		 push	 eax
  00e91	e8 00 00 00 00	 call	 _isalpha
  00e96	83 c4 04	 add	 esp, 4
  00e99	85 c0		 test	 eax, eax
  00e9b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00ea1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00ea8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00eab	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00eae	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00eb0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00eb3	83 c0 01	 add	 eax, 1
  00eb6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00eb9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00ebe	50		 push	 eax
  00ebf	e8 00 00 00 00	 call	 _getc
  00ec4	83 c4 04	 add	 esp, 4
  00ec7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00eca	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ece	83 f9 ff	 cmp	 ecx, -1
  00ed1	74 36		 je	 SHORT $LN3@GetToken
  00ed3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ed7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00eda	74 1a		 je	 SHORT $LN2@GetToken
  00edc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ee0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00ee3	74 11		 je	 SHORT $LN2@GetToken
  00ee5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ee9	50		 push	 eax
  00eea	e8 00 00 00 00	 call	 _isalnum
  00eef	83 c4 04	 add	 esp, 4
  00ef2	85 c0		 test	 eax, eax
  00ef4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00ef6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ef9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00efc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00efe	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f01	83 c0 01	 add	 eax, 1
  00f04	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00f07	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00f09	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f0e	50		 push	 eax
  00f0f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f13	51		 push	 ecx
  00f14	e8 00 00 00 00	 call	 _ungetc
  00f19	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  00f1c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f1f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00f22	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  00f2c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f31	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00f33	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00f35	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00f3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f44	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00f46	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00f48	5f		 pop	 edi
  00f49	5e		 pop	 esi
  00f4a	5b		 pop	 ebx
  00f4b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f4e	33 cd		 xor	 ecx, ebp
  00f50	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f55	8b e5		 mov	 esp, ebp
  00f57	5d		 pop	 ebp
  00f58	c3		 ret	 0
  00f59	8d 49 00	 npad	 3
$LN35@GetToken:
  00f5c	00 00 00 00	 DD	 $LN10@GetToken
  00f60	00 00 00 00	 DD	 $LN19@GetToken
  00f64	00 00 00 00	 DD	 $LN17@GetToken
  00f68	00 00 00 00	 DD	 $LN14@GetToken
  00f6c	00 00 00 00	 DD	 $LN18@GetToken
  00f70	00 00 00 00	 DD	 $LN16@GetToken
  00f74	00 00 00 00	 DD	 $LN15@GetToken
  00f78	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00f7c	00		 DB	 0
  00f7d	01		 DB	 1
  00f7e	07		 DB	 7
  00f7f	07		 DB	 7
  00f80	07		 DB	 7
  00f81	07		 DB	 7
  00f82	07		 DB	 7
  00f83	07		 DB	 7
  00f84	07		 DB	 7
  00f85	07		 DB	 7
  00f86	02		 DB	 2
  00f87	03		 DB	 3
  00f88	03		 DB	 3
  00f89	07		 DB	 7
  00f8a	03		 DB	 3
  00f8b	03		 DB	 3
  00f8c	03		 DB	 3
  00f8d	03		 DB	 3
  00f8e	03		 DB	 3
  00f8f	03		 DB	 3
  00f90	03		 DB	 3
  00f91	03		 DB	 3
  00f92	03		 DB	 3
  00f93	03		 DB	 3
  00f94	07		 DB	 7
  00f95	04		 DB	 4
  00f96	07		 DB	 7
  00f97	07		 DB	 7
  00f98	07		 DB	 7
  00f99	07		 DB	 7
  00f9a	07		 DB	 7
  00f9b	07		 DB	 7
  00f9c	07		 DB	 7
  00f9d	07		 DB	 7
  00f9e	07		 DB	 7
  00f9f	07		 DB	 7
  00fa0	07		 DB	 7
  00fa1	07		 DB	 7
  00fa2	07		 DB	 7
  00fa3	07		 DB	 7
  00fa4	07		 DB	 7
  00fa5	07		 DB	 7
  00fa6	07		 DB	 7
  00fa7	07		 DB	 7
  00fa8	07		 DB	 7
  00fa9	07		 DB	 7
  00faa	07		 DB	 7
  00fab	07		 DB	 7
  00fac	07		 DB	 7
  00fad	07		 DB	 7
  00fae	07		 DB	 7
  00faf	07		 DB	 7
  00fb0	07		 DB	 7
  00fb1	07		 DB	 7
  00fb2	07		 DB	 7
  00fb3	07		 DB	 7
  00fb4	07		 DB	 7
  00fb5	07		 DB	 7
  00fb6	07		 DB	 7
  00fb7	07		 DB	 7
  00fb8	07		 DB	 7
  00fb9	07		 DB	 7
  00fba	07		 DB	 7
  00fbb	07		 DB	 7
  00fbc	07		 DB	 7
  00fbd	07		 DB	 7
  00fbe	07		 DB	 7
  00fbf	07		 DB	 7
  00fc0	07		 DB	 7
  00fc1	07		 DB	 7
  00fc2	07		 DB	 7
  00fc3	07		 DB	 7
  00fc4	07		 DB	 7
  00fc5	07		 DB	 7
  00fc6	07		 DB	 7
  00fc7	07		 DB	 7
  00fc8	07		 DB	 7
  00fc9	07		 DB	 7
  00fca	07		 DB	 7
  00fcb	07		 DB	 7
  00fcc	07		 DB	 7
  00fcd	07		 DB	 7
  00fce	07		 DB	 7
  00fcf	07		 DB	 7
  00fd0	07		 DB	 7
  00fd1	07		 DB	 7
  00fd2	07		 DB	 7
  00fd3	07		 DB	 7
  00fd4	07		 DB	 7
  00fd5	05		 DB	 5
  00fd6	07		 DB	 7
  00fd7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPADH@Z@4JA ; `CMonsterSetBase::LoadSetBase'::`2'::__LINE__Var
PUBLIC	__$ArrayPad$
PUBLIC	?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z	; CMonsterSetBase::LoadSetBase
EXTRN	??1CWzMemScript@@UAE@XZ:PROC			; CWzMemScript::~CWzMemScript
EXTRN	?GetString@CWzMemScript@@QAEPADXZ:PROC		; CWzMemScript::GetString
EXTRN	?GetNumber@CWzMemScript@@QAEHXZ:PROC		; CWzMemScript::GetNumber
EXTRN	?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ:PROC ; CWzMemScript::GetToken
EXTRN	?SetBuffer@CWzMemScript@@QAEHPADH@Z:PROC	; CWzMemScript::SetBuffer
EXTRN	??0CWzMemScript@@QAE@XZ:PROC			; CWzMemScript::CWzMemScript
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPADH@Z@4JA
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstersetbase.cpp
_DATA	SEGMENT
?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPADH@Z@4JA DD 013cH ; `CMonsterSetBase::LoadSetBase'::`2'::__LINE__Var
_DATA	ENDS
xdata$x	SEGMENT
__unwindtable$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z$0
__ehfuncinfo$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_k$227950 = -188					; size = 4
_h$227948 = -182					; size = 1
_w$227947 = -181					; size = 1
_h$227939 = -180					; size = 4
_w$227938 = -176					; size = 4
_Type$227929 = -172					; size = 4
_Sdir$ = -165						; size = 1
_copycount$ = -164					; size = 4
_rcount$ = -160						; size = 4
_Token$ = -156						; size = 4
_WzMemScript$ = -152					; size = 132
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Buffer$ = 8						; size = 4
_iSize$ = 12						; size = 4
?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z PROC		; CMonsterSetBase::LoadSetBase
; _this$ = ecx

; 316  : {

  00fe0	55		 push	 ebp
  00fe1	8b ec		 mov	 ebp, esp
  00fe3	6a ff		 push	 -1
  00fe5	68 00 00 00 00	 push	 __ehhandler$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
  00fea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00ff0	50		 push	 eax
  00ff1	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00ff7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00ffc	33 c5		 xor	 eax, ebp
  00ffe	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01001	53		 push	 ebx
  01002	56		 push	 esi
  01003	57		 push	 edi
  01004	50		 push	 eax
  01005	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  01008	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0100e	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 	CWzMemScript WzMemScript;

  01011	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01017	e8 00 00 00 00	 call	 ??0CWzMemScript@@QAE@XZ	; CWzMemScript::CWzMemScript
  0101c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 318  : 	int Token;
; 319  : 	int rcount;
; 320  : 	int copycount;
; 321  : 	BYTE Sdir;
; 322  : 
; 323  : 	WzMemScript.SetBuffer(Buffer, iSize);

  01023	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  01026	50		 push	 eax
  01027	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  0102a	51		 push	 ecx
  0102b	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01031	e8 00 00 00 00	 call	 ?SetBuffer@CWzMemScript@@QAEHPADH@Z ; CWzMemScript::SetBuffer

; 324  : 
; 325  : 	this->m_Count = 0;

  01036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01039	c7 80 84 2c 03
	00 00 00 00 00	 mov	 DWORD PTR [eax+208004], 0
$LN27@LoadSetBas@2:

; 326  : 
; 327  : 	while ( true )

  01043	b8 01 00 00 00	 mov	 eax, 1
  01048	85 c0		 test	 eax, eax
  0104a	0f 84 d5 06 00
	00		 je	 $LN26@LoadSetBas@2

; 328  : 	{
; 329  : 		Token = WzMemScript.GetToken();

  01050	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01056	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  0105b	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 330  : 
; 331  : 		if ( Token == 2 )

  01061	83 bd 64 ff ff
	ff 02		 cmp	 DWORD PTR _Token$[ebp], 2
  01068	75 05		 jne	 SHORT $LN25@LoadSetBas@2

; 332  : 			break;

  0106a	e9 b6 06 00 00	 jmp	 $LN26@LoadSetBas@2
$LN25@LoadSetBas@2:

; 333  : 
; 334  : 		if ( Token == 1 )

  0106f	83 bd 64 ff ff
	ff 01		 cmp	 DWORD PTR _Token$[ebp], 1
  01076	0f 85 a4 06 00
	00		 jne	 $LN24@LoadSetBas@2

; 335  : 		{
; 336  : 			int Type = WzMemScript.GetNumber();

  0107c	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01082	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01087	89 85 54 ff ff
	ff		 mov	 DWORD PTR _Type$227929[ebp], eax
$LN23@LoadSetBas@2:

; 337  : 
; 338  : 			while ( true )

  0108d	b8 01 00 00 00	 mov	 eax, 1
  01092	85 c0		 test	 eax, eax
  01094	0f 84 86 06 00
	00		 je	 $LN24@LoadSetBas@2

; 339  : 			{
; 340  : 				Token = WzMemScript.GetToken();

  0109a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  010a0	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  010a5	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 341  : 
; 342  : 				if ( strcmp("end", WzMemScript.GetString()) == 0 )

  010ab	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  010b1	e8 00 00 00 00	 call	 ?GetString@CWzMemScript@@QAEPADXZ ; CWzMemScript::GetString
  010b6	50		 push	 eax
  010b7	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  010bc	e8 00 00 00 00	 call	 _strcmp
  010c1	83 c4 08	 add	 esp, 8
  010c4	85 c0		 test	 eax, eax
  010c6	75 05		 jne	 SHORT $LN21@LoadSetBas@2

; 343  : 					break;

  010c8	e9 53 06 00 00	 jmp	 $LN24@LoadSetBas@2
$LN21@LoadSetBas@2:

; 344  : 				
; 345  : 				this->m_Mp[this->m_Count].m_Type = WzMemScript.GetNumber();

  010cd	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  010d3	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  010d8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  010db	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  010e1	c1 e2 04	 shl	 edx, 4
  010e4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  010e7	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax

; 346  : 
; 347  : 				Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_MapNumber = WzMemScript.GetNumber();

  010ec	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  010f2	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  010f7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  010fd	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01103	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01108	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0110b	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01111	c1 e2 04	 shl	 edx, 4
  01114	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01117	88 44 11 08	 mov	 BYTE PTR [ecx+edx+8], al

; 348  : 				Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_Dis = WzMemScript.GetNumber();

  0111b	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01121	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  01126	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  0112c	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01132	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01137	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0113a	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01140	c1 e2 04	 shl	 edx, 4
  01143	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01146	88 44 11 09	 mov	 BYTE PTR [ecx+edx+9], al

; 349  : 				Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_X = WzMemScript.GetNumber();

  0114a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01150	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  01155	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  0115b	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01161	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01166	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01169	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0116f	c1 e2 04	 shl	 edx, 4
  01172	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01175	88 44 11 0a	 mov	 BYTE PTR [ecx+edx+10], al

; 350  : 				Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_Y = WzMemScript.GetNumber();

  01179	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0117f	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  01184	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  0118a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01190	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01198	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0119e	c1 e2 04	 shl	 edx, 4
  011a1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  011a4	88 44 11 0b	 mov	 BYTE PTR [ecx+edx+11], al

; 351  : 
; 352  : 				this->m_Mp[this->m_Count].m_ArrangeType = Type;

  011a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  011ab	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  011b1	c1 e1 04	 shl	 ecx, 4
  011b4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  011b7	8a 85 54 ff ff
	ff		 mov	 al, BYTE PTR _Type$227929[ebp]
  011bd	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 353  : 
; 354  : 
; 355  : 				if ( Type == 1 || Type == 3 )

  011c1	83 bd 54 ff ff
	ff 01		 cmp	 DWORD PTR _Type$227929[ebp], 1
  011c8	74 09		 je	 SHORT $LN19@LoadSetBas@2
  011ca	83 bd 54 ff ff
	ff 03		 cmp	 DWORD PTR _Type$227929[ebp], 3
  011d1	75 63		 jne	 SHORT $LN20@LoadSetBas@2
$LN19@LoadSetBas@2:

; 356  : 				{
; 357  : 					Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_W = WzMemScript.GetNumber();

  011d3	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  011d9	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  011de	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  011e4	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  011ea	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  011ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  011f2	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  011f8	c1 e2 04	 shl	 edx, 4
  011fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  011fe	88 44 11 0d	 mov	 BYTE PTR [ecx+edx+13], al

; 358  : 					Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_H = WzMemScript.GetNumber();

  01202	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01208	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  0120d	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  01213	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01219	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  0121e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01221	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01227	c1 e2 04	 shl	 edx, 4
  0122a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0122d	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al
  01231	e9 30 01 00 00	 jmp	 $LN18@LoadSetBas@2
$LN20@LoadSetBas@2:

; 359  : 				}
; 360  : 				else if ( Type == 2 )

  01236	83 bd 54 ff ff
	ff 02		 cmp	 DWORD PTR _Type$227929[ebp], 2
  0123d	0f 85 c8 00 00
	00		 jne	 $LN17@LoadSetBas@2

; 361  : 				{
; 362  : 					this->m_Mp[this->m_Count].m_W = 0;

  01243	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01246	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0124c	c1 e1 04	 shl	 ecx, 4
  0124f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01252	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 363  : 					this->m_Mp[this->m_Count].m_H = 0;

  01257	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0125a	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01260	c1 e1 04	 shl	 ecx, 4
  01263	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01266	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0

; 364  : 
; 365  : 					int w = this->m_Mp[this->m_Count].m_X - 3;

  0126b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0126e	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01274	c1 e1 04	 shl	 ecx, 4
  01277	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0127a	0f b6 44 0a 0a	 movzx	 eax, BYTE PTR [edx+ecx+10]
  0127f	83 e8 03	 sub	 eax, 3
  01282	89 85 50 ff ff
	ff		 mov	 DWORD PTR _w$227938[ebp], eax

; 366  : 					int h = this->m_Mp[this->m_Count].m_Y - 3;

  01288	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0128b	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01291	c1 e1 04	 shl	 ecx, 4
  01294	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01297	0f b6 44 0a 0b	 movzx	 eax, BYTE PTR [edx+ecx+11]
  0129c	83 e8 03	 sub	 eax, 3
  0129f	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$227939[ebp], eax

; 367  : 
; 368  : 					w += rand() % 7;

  012a5	e8 00 00 00 00	 call	 _rand
  012aa	99		 cdq
  012ab	b9 07 00 00 00	 mov	 ecx, 7
  012b0	f7 f9		 idiv	 ecx
  012b2	03 95 50 ff ff
	ff		 add	 edx, DWORD PTR _w$227938[ebp]
  012b8	89 95 50 ff ff
	ff		 mov	 DWORD PTR _w$227938[ebp], edx

; 369  : 					h += rand() % 7;

  012be	e8 00 00 00 00	 call	 _rand
  012c3	99		 cdq
  012c4	b9 07 00 00 00	 mov	 ecx, 7
  012c9	f7 f9		 idiv	 ecx
  012cb	03 95 4c ff ff
	ff		 add	 edx, DWORD PTR _h$227939[ebp]
  012d1	89 95 4c ff ff
	ff		 mov	 DWORD PTR _h$227939[ebp], edx

; 370  : 
; 371  : 					this->m_Mp[this->m_Count].m_X = w;

  012d7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  012da	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  012e0	c1 e1 04	 shl	 ecx, 4
  012e3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  012e6	8a 85 50 ff ff
	ff		 mov	 al, BYTE PTR _w$227938[ebp]
  012ec	88 44 0a 0a	 mov	 BYTE PTR [edx+ecx+10], al

; 372  : 					this->m_Mp[this->m_Count].m_Y = h;

  012f0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  012f3	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  012f9	c1 e1 04	 shl	 ecx, 4
  012fc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  012ff	8a 85 4c ff ff
	ff		 mov	 al, BYTE PTR _h$227939[ebp]
  01305	88 44 0a 0b	 mov	 BYTE PTR [edx+ecx+11], al
  01309	eb 5b		 jmp	 SHORT $LN18@LoadSetBas@2
$LN17@LoadSetBas@2:

; 373  : 				}
; 374  : 				else if ( Type == 4 )

  0130b	83 bd 54 ff ff
	ff 04		 cmp	 DWORD PTR _Type$227929[ebp], 4
  01312	75 2a		 jne	 SHORT $LN15@LoadSetBas@2

; 375  : 				{
; 376  : 					this->m_Mp[this->m_Count].m_W = 0;

  01314	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01317	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0131d	c1 e1 04	 shl	 ecx, 4
  01320	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01323	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 377  : 					this->m_Mp[this->m_Count].m_H = 0;

  01328	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0132b	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01331	c1 e1 04	 shl	 ecx, 4
  01334	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01337	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0

; 378  : 				}
; 379  : 				else

  0133c	eb 28		 jmp	 SHORT $LN18@LoadSetBas@2
$LN15@LoadSetBas@2:

; 380  : 				{
; 381  : 					this->m_Mp[this->m_Count].m_W = 0;

  0133e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01341	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01347	c1 e1 04	 shl	 ecx, 4
  0134a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0134d	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 382  : 					this->m_Mp[this->m_Count].m_H = 0;

  01352	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01355	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0135b	c1 e1 04	 shl	 ecx, 4
  0135e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01361	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0
$LN18@LoadSetBas@2:

; 383  : 				}
; 384  : 
; 385  : 				Token = WzMemScript.GetToken();	this->m_Mp[this->m_Count].m_Dir = WzMemScript.GetNumber();

  01366	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0136c	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  01371	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax
  01377	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0137d	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01382	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01385	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0138b	c1 e2 04	 shl	 edx, 4
  0138e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01391	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al

; 386  : 
; 387  : 				Sdir = this->m_Mp[this->m_Count].m_Dir;

  01395	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01398	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0139e	c1 e1 04	 shl	 ecx, 4
  013a1	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  013a4	8a 44 0a 0c	 mov	 al, BYTE PTR [edx+ecx+12]
  013a8	88 85 5b ff ff
	ff		 mov	 BYTE PTR _Sdir$[ebp], al

; 388  : 
; 389  : 				if ( this->m_Mp[this->m_Count].m_Dir == (BYTE)-1 )

  013ae	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  013b1	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  013b7	c1 e1 04	 shl	 ecx, 4
  013ba	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  013bd	0f b6 44 0a 0c	 movzx	 eax, BYTE PTR [edx+ecx+12]
  013c2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  013c7	75 24		 jne	 SHORT $LN13@LoadSetBas@2

; 390  : 				{
; 391  : 					this->m_Mp[this->m_Count].m_Dir = rand() % 8;

  013c9	e8 00 00 00 00	 call	 _rand
  013ce	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  013d3	79 05		 jns	 SHORT $LN33@LoadSetBas@2
  013d5	48		 dec	 eax
  013d6	83 c8 f8	 or	 eax, -8			; fffffff8H
  013d9	40		 inc	 eax
$LN33@LoadSetBas@2:
  013da	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  013dd	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  013e3	c1 e2 04	 shl	 edx, 4
  013e6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  013e9	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
$LN13@LoadSetBas@2:

; 392  : 				}
; 393  : 
; 394  : 				if ( Type == 1 || Type == 3 )

  013ed	83 bd 54 ff ff
	ff 01		 cmp	 DWORD PTR _Type$227929[ebp], 1
  013f4	74 0d		 je	 SHORT $LN11@LoadSetBas@2
  013f6	83 bd 54 ff ff
	ff 03		 cmp	 DWORD PTR _Type$227929[ebp], 3
  013fd	0f 85 91 02 00
	00		 jne	 $LN12@LoadSetBas@2
$LN11@LoadSetBas@2:

; 395  : 				{
; 396  : 					BYTE w = this->m_Mp[this->m_Count].m_X;

  01403	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01406	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0140c	c1 e1 04	 shl	 ecx, 4
  0140f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01412	8a 44 0a 0a	 mov	 al, BYTE PTR [edx+ecx+10]
  01416	88 85 4b ff ff
	ff		 mov	 BYTE PTR _w$227947[ebp], al

; 397  : 					BYTE h = this->m_Mp[this->m_Count].m_Y;

  0141c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0141f	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01425	c1 e1 04	 shl	 ecx, 4
  01428	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0142b	8a 44 0a 0b	 mov	 al, BYTE PTR [edx+ecx+11]
  0142f	88 85 4a ff ff
	ff		 mov	 BYTE PTR _h$227948[ebp], al

; 398  : 
; 399  : 					Token = WzMemScript.GetToken();

  01435	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0143b	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  01440	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 400  : 					rcount = WzMemScript.GetNumber();

  01446	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0144c	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  01451	89 85 60 ff ff
	ff		 mov	 DWORD PTR _rcount$[ebp], eax

; 401  : 					copycount = this->m_Count;

  01457	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0145a	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  01460	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _copycount$[ebp], ecx

; 402  : 
; 403  : 					if ( rcount > 1 )

  01466	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _rcount$[ebp], 1
  0146d	0f 8e 21 02 00
	00		 jle	 $LN12@LoadSetBas@2

; 404  : 					{
; 405  : 						for ( int k = 0; k<rcount-1 ; k++ )

  01473	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$227950[ebp], 0
  0147d	eb 0f		 jmp	 SHORT $LN9@LoadSetBas@2
$LN8@LoadSetBas@2:
  0147f	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _k$227950[ebp]
  01485	83 c0 01	 add	 eax, 1
  01488	89 85 44 ff ff
	ff		 mov	 DWORD PTR _k$227950[ebp], eax
$LN9@LoadSetBas@2:
  0148e	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _rcount$[ebp]
  01494	83 e8 01	 sub	 eax, 1
  01497	39 85 44 ff ff
	ff		 cmp	 DWORD PTR _k$227950[ebp], eax
  0149d	0f 8d f1 01 00
	00		 jge	 $LN12@LoadSetBas@2

; 406  : 						{
; 407  : 							if ( g_MapServerManager.CheckMapCanMove(this->m_Mp[copycount].m_MapNumber) == FALSE )

  014a3	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  014a9	c1 e0 04	 shl	 eax, 4
  014ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  014af	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  014b4	52		 push	 edx
  014b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  014ba	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  014bf	85 c0		 test	 eax, eax
  014c1	75 05		 jne	 SHORT $LN6@LoadSetBas@2

; 408  : 								break;

  014c3	e9 cc 01 00 00	 jmp	 $LN12@LoadSetBas@2
$LN6@LoadSetBas@2:

; 409  : 						
; 410  : 							this->m_Count++;

  014c8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  014cb	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  014d1	83 c1 01	 add	 ecx, 1
  014d4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  014d7	89 8a 84 2c 03
	00		 mov	 DWORD PTR [edx+208004], ecx

; 411  : 
; 412  : 							if ( this->m_Count > OBJ_MAXMONSTER-1 )

  014dd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  014e0	81 b8 84 2c 03
	00 c7 32 00 00	 cmp	 DWORD PTR [eax+208004], 12999 ; 000032c7H
  014ea	7e 32		 jle	 SHORT $LN5@LoadSetBas@2

; 413  : 							{
; 414  : 								MsgBox("Monster attribute max over %s %d", __FILE__, __LINE__);

  014ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPADH@Z@4JA
  014f1	83 c0 62	 add	 eax, 98			; 00000062H
  014f4	50		 push	 eax
  014f5	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@
  014fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
  014ff	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  01504	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  : 								return;

  01507	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0150e	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01514	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  01519	e9 19 02 00 00	 jmp	 $LN28@LoadSetBas@2
$LN5@LoadSetBas@2:

; 416  : 							}
; 417  : 
; 418  : 							this->m_Mp[this->m_Count].m_Dis = this->m_Mp[copycount].m_Dis;

  0151e	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  01524	c1 e0 04	 shl	 eax, 4
  01527	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0152a	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01530	c1 e2 04	 shl	 edx, 4
  01533	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01536	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  01539	8a 44 06 09	 mov	 al, BYTE PTR [esi+eax+9]
  0153d	88 44 11 09	 mov	 BYTE PTR [ecx+edx+9], al

; 419  : 							this->m_Mp[this->m_Count].m_Type = this->m_Mp[copycount].m_Type;

  01541	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  01547	c1 e0 04	 shl	 eax, 4
  0154a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0154d	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01553	c1 e2 04	 shl	 edx, 4
  01556	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01559	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0155c	66 8b 44 06 06	 mov	 ax, WORD PTR [esi+eax+6]
  01561	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax

; 420  : 							this->m_Mp[this->m_Count].m_MapNumber = this->m_Mp[copycount].m_MapNumber;

  01566	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  0156c	c1 e0 04	 shl	 eax, 4
  0156f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01572	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01578	c1 e2 04	 shl	 edx, 4
  0157b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0157e	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  01581	8a 44 06 08	 mov	 al, BYTE PTR [esi+eax+8]
  01585	88 44 11 08	 mov	 BYTE PTR [ecx+edx+8], al

; 421  : 							this->m_Mp[this->m_Count].m_W = this->m_Mp[copycount].m_W;

  01589	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  0158f	c1 e0 04	 shl	 eax, 4
  01592	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01595	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0159b	c1 e2 04	 shl	 edx, 4
  0159e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  015a4	8a 44 06 0d	 mov	 al, BYTE PTR [esi+eax+13]
  015a8	88 44 11 0d	 mov	 BYTE PTR [ecx+edx+13], al

; 422  : 							this->m_Mp[this->m_Count].m_H = this->m_Mp[copycount].m_H;

  015ac	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  015b2	c1 e0 04	 shl	 eax, 4
  015b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015b8	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  015be	c1 e2 04	 shl	 edx, 4
  015c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015c4	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  015c7	8a 44 06 0e	 mov	 al, BYTE PTR [esi+eax+14]
  015cb	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al

; 423  : 							this->m_Mp[this->m_Count].m_X = this->m_Mp[copycount].m_X;

  015cf	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  015d5	c1 e0 04	 shl	 eax, 4
  015d8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015db	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  015e1	c1 e2 04	 shl	 edx, 4
  015e4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015e7	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  015ea	8a 44 06 0a	 mov	 al, BYTE PTR [esi+eax+10]
  015ee	88 44 11 0a	 mov	 BYTE PTR [ecx+edx+10], al

; 424  : 							this->m_Mp[this->m_Count].m_Y = this->m_Mp[copycount].m_Y;

  015f2	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  015f8	c1 e0 04	 shl	 eax, 4
  015fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015fe	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01604	c1 e2 04	 shl	 edx, 4
  01607	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0160a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0160d	8a 44 06 0b	 mov	 al, BYTE PTR [esi+eax+11]
  01611	88 44 11 0b	 mov	 BYTE PTR [ecx+edx+11], al

; 425  : 							this->m_Mp[this->m_Count].m_ArrangeType = this->m_Mp[copycount].m_ArrangeType;

  01615	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  0161b	c1 e0 04	 shl	 eax, 4
  0161e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01621	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01627	c1 e2 04	 shl	 edx, 4
  0162a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0162d	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  01630	8a 44 06 04	 mov	 al, BYTE PTR [esi+eax+4]
  01634	88 44 11 04	 mov	 BYTE PTR [ecx+edx+4], al

; 426  : 
; 427  : 							if ( Sdir == (BYTE)-1 )

  01638	0f b6 85 5b ff
	ff ff		 movzx	 eax, BYTE PTR _Sdir$[ebp]
  0163f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01644	75 26		 jne	 SHORT $LN4@LoadSetBas@2

; 428  : 								this->m_Mp[this->m_Count].m_Dir = rand() % 8;

  01646	e8 00 00 00 00	 call	 _rand
  0164b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  01650	79 05		 jns	 SHORT $LN34@LoadSetBas@2
  01652	48		 dec	 eax
  01653	83 c8 f8	 or	 eax, -8			; fffffff8H
  01656	40		 inc	 eax
$LN34@LoadSetBas@2:
  01657	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0165a	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  01660	c1 e2 04	 shl	 edx, 4
  01663	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01666	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al

; 429  : 							else

  0166a	eb 23		 jmp	 SHORT $LN3@LoadSetBas@2
$LN4@LoadSetBas@2:

; 430  : 								this->m_Mp[this->m_Count].m_Dir = this->m_Mp[copycount].m_Dir;

  0166c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _copycount$[ebp]
  01672	c1 e0 04	 shl	 eax, 4
  01675	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01678	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  0167e	c1 e2 04	 shl	 edx, 4
  01681	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01684	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  01687	8a 44 06 0c	 mov	 al, BYTE PTR [esi+eax+12]
  0168b	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
$LN3@LoadSetBas@2:

; 431  : 						}

  0168f	e9 eb fd ff ff	 jmp	 $LN8@LoadSetBas@2
$LN12@LoadSetBas@2:

; 432  : 					}
; 433  : 				}
; 434  : 
; 435  : #ifdef IMPERIAL_CONFLICT_NEW
; 436  : 
; 437  : 				else if(Type == 5)
; 438  : 				{
; 439  : 					WzMemScript.GetToken();
; 440  : 					this->m_Mp[this->m_Count].m_IG_ZoneIndex = WzMemScript.GetNumber();
; 441  : 
; 442  : 					WzMemScript.GetToken();
; 443  : 					this->m_Mp[this->m_Count].m_IG_RegenTable = WzMemScript.GetNumber();
; 444  : 				}
; 445  : #endif
; 446  : 
; 447  : 				if ( g_MapServerManager.CheckMapCanMove(this->m_Mp[this->m_Count].m_MapNumber) == FALSE )

  01694	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01697	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  0169d	c1 e1 04	 shl	 ecx, 4
  016a0	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  016a3	0f b6 44 0a 08	 movzx	 eax, BYTE PTR [edx+ecx+8]
  016a8	50		 push	 eax
  016a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  016ae	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  016b3	85 c0		 test	 eax, eax
  016b5	75 05		 jne	 SHORT $LN2@LoadSetBas@2

; 448  : 					continue;

  016b7	e9 d1 f9 ff ff	 jmp	 $LN23@LoadSetBas@2
$LN2@LoadSetBas@2:

; 449  : 
; 450  : 				this->m_Count++;

  016bc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  016bf	8b 88 84 2c 03
	00		 mov	 ecx, DWORD PTR [eax+208004]
  016c5	83 c1 01	 add	 ecx, 1
  016c8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  016cb	89 8a 84 2c 03
	00		 mov	 DWORD PTR [edx+208004], ecx

; 451  : 
; 452  : 				if ( this->m_Count > OBJ_MAXMONSTER-1 )

  016d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  016d4	81 b8 84 2c 03
	00 c7 32 00 00	 cmp	 DWORD PTR [eax+208004], 12999 ; 000032c7H
  016de	7e 3b		 jle	 SHORT $LN1@LoadSetBas@2

; 453  : 				{
; 454  : 					MsgBox("Monster attribute max over %d (%s %d)", this->m_Count, __FILE__, __LINE__);

  016e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??LoadSetBase@CMonsterSetBase@@QAEXPADH@Z@4JA
  016e5	05 8a 00 00 00	 add	 eax, 138		; 0000008aH
  016ea	50		 push	 eax
  016eb	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@NIFJGJOB@d?3?2projects?2exteam6?43?2source?2gam@
  016f0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  016f3	8b 91 84 2c 03
	00		 mov	 edx, DWORD PTR [ecx+208004]
  016f9	52		 push	 edx
  016fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@
  016ff	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  01704	83 c4 10	 add	 esp, 16			; 00000010H

; 455  : 					//fclose(SMDFile);
; 456  : 					return;

  01707	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0170e	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01714	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  01719	eb 1c		 jmp	 SHORT $LN28@LoadSetBas@2
$LN1@LoadSetBas@2:

; 457  : 				}
; 458  : 			}

  0171b	e9 6d f9 ff ff	 jmp	 $LN23@LoadSetBas@2
$LN24@LoadSetBas@2:

; 459  : 		}
; 460  : 	}

  01720	e9 1e f9 ff ff	 jmp	 $LN27@LoadSetBas@2
$LN26@LoadSetBas@2:

; 461  : 
; 462  : 	//fclose(SMDFile);
; 463  : }

  01725	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0172c	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  01732	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
$LN28@LoadSetBas@2:
  01737	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0173a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01741	59		 pop	 ecx
  01742	5f		 pop	 edi
  01743	5e		 pop	 esi
  01744	5b		 pop	 ebx
  01745	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01748	33 cd		 xor	 ecx, ebp
  0174a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0174f	8b e5		 mov	 esp, ebp
  01751	5d		 pop	 ebp
  01752	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z$0:
  00000	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
__ehhandler$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 00 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-256]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z ENDP		; CMonsterSetBase::LoadSetBase
END
