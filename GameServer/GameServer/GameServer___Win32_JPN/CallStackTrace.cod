; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\CallStackTrace.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_03MLIHNEFJ@LOG?$AA@			; `string'
PUBLIC	??_C@_07EIPNPBIJ@LOGDATA?$AA@			; `string'
PUBLIC	??_C@_0BC@ILOEJNOF@INSERT?5LOG?9ID?5?$CB?$CB?$CB?$AA@ ; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7CCallStackTrace@@6B@			; CCallStackTrace::`vftable'
PUBLIC	??0CCallStackTrace@@QAE@QAD00@Z			; CCallStackTrace::CCallStackTrace
PUBLIC	??_R4CCallStackTrace@@6B@			; CCallStackTrace::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCallStackTrace@@@8			; CCallStackTrace `RTTI Type Descriptor'
PUBLIC	??_R3CCallStackTrace@@8				; CCallStackTrace::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCallStackTrace@@8				; CCallStackTrace::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCallStackTrace@@8		; CCallStackTrace::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_strcmp:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECCallStackTrace@@UAEPAXI@Z:PROC		; CCallStackTrace::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCallStackTrace@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\callstacktrace.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CCallStackTrace@@8 DD FLAT:??_R0?AVCCallStackTrace@@@8 ; CCallStackTrace::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCallStackTrace@@8
rdata$r	ENDS
;	COMDAT ??_R2CCallStackTrace@@8
rdata$r	SEGMENT
??_R2CCallStackTrace@@8 DD FLAT:??_R1A@?0A@EA@CCallStackTrace@@8 ; CCallStackTrace::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CCallStackTrace@@8
rdata$r	SEGMENT
??_R3CCallStackTrace@@8 DD 00H				; CCallStackTrace::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CCallStackTrace@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCallStackTrace@@@8
_DATA	SEGMENT
??_R0?AVCCallStackTrace@@@8 DD FLAT:??_7type_info@@6B@	; CCallStackTrace `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCallStackTrace@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCallStackTrace@@6B@
rdata$r	SEGMENT
??_R4CCallStackTrace@@6B@ DD 00H			; CCallStackTrace::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCallStackTrace@@@8
	DD	FLAT:??_R3CCallStackTrace@@8
rdata$r	ENDS
;	COMDAT ??_C@_03MLIHNEFJ@LOG?$AA@
CONST	SEGMENT
??_C@_03MLIHNEFJ@LOG?$AA@ DB 'LOG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EIPNPBIJ@LOGDATA?$AA@
CONST	SEGMENT
??_C@_07EIPNPBIJ@LOGDATA?$AA@ DB 'LOGDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ILOEJNOF@INSERT?5LOG?9ID?5?$CB?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@ILOEJNOF@INSERT?5LOG?9ID?5?$CB?$CB?$CB?$AA@ DB 'INSERT LOG-ID !'
	DB	'!!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR?$AA@ DB 'ERROR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CCallStackTrace@@6B@
CONST	SEGMENT
??_7CCallStackTrace@@6B@ DD FLAT:??_R4CCallStackTrace@@6B@ ; CCallStackTrace::`vftable'
	DD	FLAT:??_ECCallStackTrace@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szLogID$ = 8						; size = 4
_szLogFileName$ = 12					; size = 4
_szLogDirectoryName$ = 16				; size = 4
??0CCallStackTrace@@QAE@QAD00@Z PROC			; CCallStackTrace::CCallStackTrace
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCallStackTrace@@6B@
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  0001e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 10   : 	if ( !strcmp(szLogID, ""))

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00028	8b 45 08	 mov	 eax, DWORD PTR _szLogID$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _strcmp
  00031	83 c4 08	 add	 esp, 8
  00034	85 c0		 test	 eax, eax
  00036	75 19		 jne	 SHORT $LN5@CCallStack

; 11   : 	{
; 12   : 		MessageBox(NULL, "INSERT LOG-ID !!!", "ERROR", MB_OK);

  00038	6a 00		 push	 0
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_05MBDEGLCK@ERROR?$AA@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@ILOEJNOF@INSERT?5LOG?9ID?5?$CB?$CB?$CB?$AA@
  00044	6a 00		 push	 0
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 13   : 		return;

  0004c	e9 b4 00 00 00	 jmp	 $LN6@CCallStack
$LN5@CCallStack:

; 14   : 	}
; 15   : 
; 16   : 	strcpy(this->m_szLogID, szLogID);

  00051	8b 45 08	 mov	 eax, DWORD PTR _szLogID$[ebp]
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 08	 add	 ecx, 8
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _strcpy
  00061	83 c4 08	 add	 esp, 8

; 17   : 
; 18   : 	if ( !strcmp(szLogFileName, ""))

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00069	8b 45 0c	 mov	 eax, DWORD PTR _szLogFileName$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _strcmp
  00072	83 c4 08	 add	 esp, 8
  00075	85 c0		 test	 eax, eax
  00077	75 18		 jne	 SHORT $LN4@CCallStack

; 19   : 		strcpy(this->m_szLogFileName, "LOGDATA");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_07EIPNPBIJ@LOGDATA?$AA@
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _strcpy
  0008c	83 c4 08	 add	 esp, 8

; 20   : 	else

  0008f	eb 16		 jmp	 SHORT $LN3@CCallStack
$LN4@CCallStack:

; 21   : 		strcpy(this->m_szLogFileName, szLogFileName);

  00091	8b 45 0c	 mov	 eax, DWORD PTR _szLogFileName$[ebp]
  00094	50		 push	 eax
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _strcpy
  000a4	83 c4 08	 add	 esp, 8
$LN3@CCallStack:

; 22   : 
; 23   : 	if ( !strcmp(szLogDirectoryName, ""))

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000ac	8b 45 10	 mov	 eax, DWORD PTR _szLogDirectoryName$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _strcmp
  000b5	83 c4 08	 add	 esp, 8
  000b8	85 c0		 test	 eax, eax
  000ba	75 18		 jne	 SHORT $LN2@CCallStack

; 24   : 		strcpy(this->m_szLogDirectoryName, "LOG");

  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_03MLIHNEFJ@LOG?$AA@
  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	05 10 02 00 00	 add	 eax, 528		; 00000210H
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _strcpy
  000cf	83 c4 08	 add	 esp, 8

; 25   : 	else

  000d2	eb 16		 jmp	 SHORT $LN1@CCallStack
$LN2@CCallStack:

; 26   : 		strcpy(this->m_szLogDirectoryName, szLogDirectoryName);

  000d4	8b 45 10	 mov	 eax, DWORD PTR _szLogDirectoryName$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _strcpy
  000e7	83 c4 08	 add	 esp, 8
$LN1@CCallStack:

; 27   : 
; 28   : 	CreateDirectory(szLogDirectoryName, NULL);

  000ea	6a 00		 push	 0
  000ec	8b 45 10	 mov	 eax, DWORD PTR _szLogDirectoryName$[ebp]
  000ef	50		 push	 eax
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 29   : 	InitializeCriticalSection(&this->m_critLogToFile);

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	05 18 04 00 00	 add	 eax, 1048		; 00000418H
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
$LN6@CCallStack:

; 30   : }

  00105	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 0c 00	 ret	 12			; 0000000cH
??0CCallStackTrace@@QAE@QAD00@Z ENDP			; CCallStackTrace::CCallStackTrace
_TEXT	ENDS
PUBLIC	??1CCallStackTrace@@UAE@XZ			; CCallStackTrace::~CCallStackTrace
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCCallStackTrace@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCallStackTrace@@UAEPAXI@Z PROC			; CCallStackTrace::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CCallStackTrace@@UAE@XZ ; CCallStackTrace::~CCallStackTrace
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCCallStackTrace@@UAEPAXI@Z ENDP			; CCallStackTrace::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CCallStackTrace@@UAE@XZ PROC				; CCallStackTrace::~CCallStackTrace
; _this$ = ecx

; 33   : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	83 ec 44	 sub	 esp, 68			; 00000044H
  00126	53		 push	 ebx
  00127	56		 push	 esi
  00128	57		 push	 edi
  00129	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0012c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCallStackTrace@@6B@

; 34   : 	DeleteCriticalSection(&this->m_critLogToFile);

  00135	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00138	05 18 04 00 00	 add	 eax, 1048		; 00000418H
  0013d	50		 push	 eax
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 35   : }

  00144	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  0014d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
??1CCallStackTrace@@UAE@XZ ENDP				; CCallStackTrace::~CCallStackTrace
_TEXT	ENDS
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??_C@_0CB@FIPEKLON@?6?$CK?9?9?9?9?9?$DO?5CallStack?5List?5?$DM?9?9?9?9?9?$CK?6@ ; `string'
PUBLIC	??_C@_0EK@LEGJPJDC@?6CallStack?5Trace?5Infomation?5?$CIDAT@ ; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_0BJ@LHLEGJPB@?$CFs?2?$CFs?5?$CF04d?9?$CF02d?9?$CF02d?4txt?$AA@ ; `string'
PUBLIC	??_C@_0O@GEMMNDNI@NO?5LOG?9ID?5?$CB?$CB?$CB?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Output@CCallStackTrace@@AAEXXZ			; CCallStackTrace::Output
EXTRN	_fclose:PROC
EXTRN	_fputc:PROC
EXTRN	_fprintf:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CB@FIPEKLON@?6?$CK?9?9?9?9?9?$DO?5CallStack?5List?5?$DM?9?9?9?9?9?$CK?6@
CONST	SEGMENT
??_C@_0CB@FIPEKLON@?6?$CK?9?9?9?9?9?$DO?5CallStack?5List?5?$DM?9?9?9?9?9?$CK?6@ DB 0aH
	DB	'*-----> CallStack List <-----*', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@LEGJPJDC@?6CallStack?5Trace?5Infomation?5?$CIDAT@
CONST	SEGMENT
??_C@_0EK@LEGJPJDC@?6CallStack?5Trace?5Infomation?5?$CIDAT@ DB 0aH, 'Call'
	DB	'Stack Trace Infomation (DATE:%04d-%02d-%02d %02d:%02d:%02d / '
	DB	'ID:%s)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LHLEGJPB@?$CFs?2?$CFs?5?$CF04d?9?$CF02d?9?$CF02d?4txt?$AA@
CONST	SEGMENT
??_C@_0BJ@LHLEGJPB@?$CFs?2?$CFs?5?$CF04d?9?$CF02d?9?$CF02d?4txt?$AA@ DB '%'
	DB	's\%s %04d-%02d-%02d.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GEMMNDNI@NO?5LOG?9ID?5?$CB?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0O@GEMMNDNI@NO?5LOG?9ID?5?$CB?$CB?$CB?$AA@ DB 'NO LOG-ID !!!', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iC$206464 = -288					; size = 4
_strSystime$ = -284					; size = 16
_szLogFileName$ = -268					; size = 260
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Output@CCallStackTrace@@AAEXXZ PROC			; CCallStackTrace::Output
; _this$ = ecx

; 38   : {

  00160	55		 push	 ebp
  00161	8b ec		 mov	 ebp, esp
  00163	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00169	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0016e	33 c5		 xor	 eax, ebp
  00170	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00173	53		 push	 ebx
  00174	56		 push	 esi
  00175	57		 push	 edi
  00176	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 	if ( !strcmp(this->m_szLogID, ""))

  00179	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0017e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00181	83 c0 08	 add	 eax, 8
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _strcmp
  0018a	83 c4 08	 add	 esp, 8
  0018d	85 c0		 test	 eax, eax
  0018f	75 19		 jne	 SHORT $LN5@Output

; 40   : 	{
; 41   : 		MessageBox(NULL, "NO LOG-ID !!!", "ERROR", 0);

  00191	6a 00		 push	 0
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_05MBDEGLCK@ERROR?$AA@
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GEMMNDNI@NO?5LOG?9ID?5?$CB?$CB?$CB?$AA@
  0019d	6a 00		 push	 0
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 42   : 		return;

  001a5	e9 45 01 00 00	 jmp	 $LN6@Output
$LN5@Output:

; 43   : 	}
; 44   : 
; 45   : 	char szLogFileName[260];
; 46   : 	SYSTEMTIME strSystime;
; 47   : 
; 48   : 	GetLocalTime(&strSystime);

  001aa	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _strSystime$[ebp]
  001b0	50		 push	 eax
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 49   : 
; 50   : 	wsprintf(szLogFileName, "%s\\%s %04d-%02d-%02d.txt", this->m_szLogDirectoryName, this->m_szLogFileName, strSystime.wYear, strSystime.wMonth, strSystime.wDay);

  001b7	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR _strSystime$[ebp+6]
  001be	50		 push	 eax
  001bf	0f b7 8d e6 fe
	ff ff		 movzx	 ecx, WORD PTR _strSystime$[ebp+2]
  001c6	51		 push	 ecx
  001c7	0f b7 95 e4 fe
	ff ff		 movzx	 edx, WORD PTR _strSystime$[ebp]
  001ce	52		 push	 edx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  001d7	50		 push	 eax
  001d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  001e1	51		 push	 ecx
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LHLEGJPB@?$CFs?2?$CFs?5?$CF04d?9?$CF02d?9?$CF02d?4txt?$AA@
  001e7	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _szLogFileName$[ebp]
  001ed	52		 push	 edx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001f4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 51   : 
; 52   : 	this->m_fLogFile = fopen(szLogFileName, "a+");

  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  001fc	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szLogFileName$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _fopen
  00208	83 c4 08	 add	 esp, 8
  0020b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 53   : 
; 54   : 	if ( this->m_fLogFile == NULL )

  00211	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00214	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00218	75 05		 jne	 SHORT $LN4@Output

; 55   : 	{
; 56   : 		return;

  0021a	e9 d0 00 00 00	 jmp	 $LN6@Output
$LN4@Output:

; 57   : 	}
; 58   : 
; 59   : 	fprintf(this->m_fLogFile, "\nCallStack Trace Infomation (DATE:%04d-%02d-%02d %02d:%02d:%02d / ID:%s)\n", strSystime.wYear, strSystime.wMonth, strSystime.wDay, strSystime.wHour, strSystime.wMinute,	strSystime.wSecond, this->m_szLogID);

  0021f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00222	83 c0 08	 add	 eax, 8
  00225	50		 push	 eax
  00226	0f b7 8d f0 fe
	ff ff		 movzx	 ecx, WORD PTR _strSystime$[ebp+12]
  0022d	51		 push	 ecx
  0022e	0f b7 95 ee fe
	ff ff		 movzx	 edx, WORD PTR _strSystime$[ebp+10]
  00235	52		 push	 edx
  00236	0f b7 85 ec fe
	ff ff		 movzx	 eax, WORD PTR _strSystime$[ebp+8]
  0023d	50		 push	 eax
  0023e	0f b7 8d ea fe
	ff ff		 movzx	 ecx, WORD PTR _strSystime$[ebp+6]
  00245	51		 push	 ecx
  00246	0f b7 95 e6 fe
	ff ff		 movzx	 edx, WORD PTR _strSystime$[ebp+2]
  0024d	52		 push	 edx
  0024e	0f b7 85 e4 fe
	ff ff		 movzx	 eax, WORD PTR _strSystime$[ebp]
  00255	50		 push	 eax
  00256	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@LEGJPJDC@?6CallStack?5Trace?5Infomation?5?$CIDAT@
  0025b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 _fprintf
  00267	83 c4 24	 add	 esp, 36			; 00000024H

; 60   : 	fprintf(this->m_fLogFile, "\n*-----> CallStack List <-----*\n", this->m_szLogID);

  0026a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0026d	83 c0 08	 add	 eax, 8
  00270	50		 push	 eax
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FIPEKLON@?6?$CK?9?9?9?9?9?$DO?5CallStack?5List?5?$DM?9?9?9?9?9?$CK?6@
  00276	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0027c	52		 push	 edx
  0027d	e8 00 00 00 00	 call	 _fprintf
  00282	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   : 
; 62   : 	for ( int iC=0;iC<this->m_strCallStackLog.size(); iC++)

  00285	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iC$206464[ebp], 0
  0028f	eb 0f		 jmp	 SHORT $LN3@Output
$LN2@Output:
  00291	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _iC$206464[ebp]
  00297	83 c0 01	 add	 eax, 1
  0029a	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iC$206464[ebp], eax
$LN3@Output:
  002a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  002a9	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  002ae	39 85 e0 fe ff
	ff		 cmp	 DWORD PTR _iC$206464[ebp], eax
  002b4	73 2a		 jae	 SHORT $LN1@Output

; 63   : 	{
; 64   : 		fputc(this->m_strCallStackLog[iC], this->m_fLogFile);

  002b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002bc	51		 push	 ecx
  002bd	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _iC$206464[ebp]
  002c3	52		 push	 edx
  002c4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  002cd	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  002d2	0f be 00	 movsx	 eax, BYTE PTR [eax]
  002d5	50		 push	 eax
  002d6	e8 00 00 00 00	 call	 _fputc
  002db	83 c4 08	 add	 esp, 8

; 65   : 	}

  002de	eb b1		 jmp	 SHORT $LN2@Output
$LN1@Output:

; 66   : 
; 67   : 	fclose(this->m_fLogFile);

  002e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e6	51		 push	 ecx
  002e7	e8 00 00 00 00	 call	 _fclose
  002ec	83 c4 04	 add	 esp, 4
$LN6@Output:

; 68   : }

  002ef	5f		 pop	 edi
  002f0	5e		 pop	 esi
  002f1	5b		 pop	 ebx
  002f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f5	33 cd		 xor	 ecx, ebp
  002f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fc	8b e5		 mov	 esp, ebp
  002fe	5d		 pop	 ebp
  002ff	c3		 ret	 0
?Output@CCallStackTrace@@AAEXXZ ENDP			; CCallStackTrace::Output
_TEXT	ENDS
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@	; `string'
PUBLIC	??_C@_09HDDDNNCJ@?1?1?5?$CFs?$CI?$CFi?$CJ?$AA@	; `string'
PUBLIC	??_C@_05GALAIONK@?$CFs?$CI?$CJ?5?$AA@		; `string'
PUBLIC	??_C@_0BE@IDPPGAOM@?$DMunknown?5module?$DO?5?3?5?$AA@ ; `string'
PUBLIC	??_C@_05LLGELLBM@?$CFs?5?3?5?$AA@		; `string'
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	__$ArrayPad$
PUBLIC	?ConvertAddress@CCallStackTrace@@AAEKPAXKPAD@Z	; CCallStackTrace::ConvertAddress
EXTRN	__imp__SymGetLineFromAddr@16:PROC
EXTRN	__imp__SymGetSymFromAddr@16:PROC
EXTRN	_sprintf:PROC
EXTRN	__imp__SymGetModuleInfo@12:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@
CONST	SEGMENT
??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@ DB '<unknown symbol>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDDDNNCJ@?1?1?5?$CFs?$CI?$CFi?$CJ?$AA@
CONST	SEGMENT
??_C@_09HDDDNNCJ@?1?1?5?$CFs?$CI?$CFi?$CJ?$AA@ DB '// %s(%i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GALAIONK@?$CFs?$CI?$CJ?5?$AA@
CONST	SEGMENT
??_C@_05GALAIONK@?$CFs?$CI?$CJ?5?$AA@ DB '%s() ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IDPPGAOM@?$DMunknown?5module?$DO?5?3?5?$AA@
CONST	SEGMENT
??_C@_0BE@IDPPGAOM@?$DMunknown?5module?$DO?5?3?5?$AA@ DB '<unknown module'
	DB	'> : ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLGELLBM@?$CFs?5?3?5?$AA@
CONST	SEGMENT
??_C@_05LLGELLBM@?$CFs?5?3?5?$AA@ DB '%s : ', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_imagehlp_line$206489 = -900				; size = 20
_imagehlp_symbol$ = -880				; size = 4
_temp$ = -876						; size = 284
_displacement$ = -592					; size = 4
_image_name$206477 = -588				; size = 4
_imagehlp_module$ = -584				; size = 572
_current_pointer$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hProcess$ = 8						; size = 4
_address$ = 12						; size = 4
_output_buffer$ = 16					; size = 4
?ConvertAddress@CCallStackTrace@@AAEKPAXKPAD@Z PROC	; CCallStackTrace::ConvertAddress
; _this$ = ecx

; 71   : {

  00300	55		 push	 ebp
  00301	8b ec		 mov	 ebp, esp
  00303	81 ec c4 03 00
	00		 sub	 esp, 964		; 000003c4H
  00309	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0030e	33 c5		 xor	 eax, ebp
  00310	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00313	53		 push	 ebx
  00314	56		 push	 esi
  00315	57		 push	 edi
  00316	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 72   : 	char* current_pointer = output_buffer;

  00319	8b 45 10	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0031c	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax

; 73   : 	IMAGEHLP_MODULE imagehlp_module;
; 74   : 	memset(&imagehlp_module, 0, sizeof(imagehlp_module));

  0031f	68 3c 02 00 00	 push	 572			; 0000023cH
  00324	6a 00		 push	 0
  00326	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _imagehlp_module$[ebp]
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 _memset
  00332	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : 	imagehlp_module.SizeOfStruct = sizeof(imagehlp_module);

  00335	c7 85 b8 fd ff
	ff 3c 02 00 00	 mov	 DWORD PTR _imagehlp_module$[ebp], 572 ; 0000023cH

; 76   : 
; 77   : 	if ( SymGetModuleInfo(hProcess, address, &imagehlp_module) != FALSE )

  0033f	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _imagehlp_module$[ebp]
  00345	50		 push	 eax
  00346	8b 4d 0c	 mov	 ecx, DWORD PTR _address$[ebp]
  00349	51		 push	 ecx
  0034a	8b 55 08	 mov	 edx, DWORD PTR _hProcess$[ebp]
  0034d	52		 push	 edx
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymGetModuleInfo@12
  00354	85 c0		 test	 eax, eax
  00356	74 5d		 je	 SHORT $LN7@ConvertAdd

; 78   : 	{
; 79   : 		char * image_name = strrchr(imagehlp_module.ImageName, '\\');

  00358	6a 5c		 push	 92			; 0000005cH
  0035a	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _imagehlp_module$[ebp+60]
  00360	50		 push	 eax
  00361	e8 00 00 00 00	 call	 ?strrchr@@YAPADPADH@Z	; strrchr
  00366	83 c4 08	 add	 esp, 8
  00369	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _image_name$206477[ebp], eax

; 80   : 
; 81   : 		if ( image_name != NULL )

  0036f	83 bd b4 fd ff
	ff 00		 cmp	 DWORD PTR _image_name$206477[ebp], 0
  00376	74 11		 je	 SHORT $LN6@ConvertAdd

; 82   : 			image_name += 1;

  00378	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _image_name$206477[ebp]
  0037e	83 c0 01	 add	 eax, 1
  00381	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _image_name$206477[ebp], eax

; 83   : 		else

  00387	eb 0c		 jmp	 SHORT $LN5@ConvertAdd
$LN6@ConvertAdd:

; 84   : 			image_name = imagehlp_module.ImageName;

  00389	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _imagehlp_module$[ebp+60]
  0038f	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _image_name$206477[ebp], eax
$LN5@ConvertAdd:

; 85   : 
; 86   : 		current_pointer += sprintf(current_pointer, "%s : ", image_name);

  00395	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _image_name$206477[ebp]
  0039b	50		 push	 eax
  0039c	68 00 00 00 00	 push	 OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5?$AA@
  003a1	8b 4d f4	 mov	 ecx, DWORD PTR _current_pointer$[ebp]
  003a4	51		 push	 ecx
  003a5	e8 00 00 00 00	 call	 _sprintf
  003aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ad	03 45 f4	 add	 eax, DWORD PTR _current_pointer$[ebp]
  003b0	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax

; 87   : 	}
; 88   : 	else

  003b3	eb 17		 jmp	 SHORT $LN4@ConvertAdd
$LN7@ConvertAdd:

; 89   : 	{
; 90   : 		current_pointer += sprintf(current_pointer, "<unknown module> : ");

  003b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IDPPGAOM@?$DMunknown?5module?$DO?5?3?5?$AA@
  003ba	8b 45 f4	 mov	 eax, DWORD PTR _current_pointer$[ebp]
  003bd	50		 push	 eax
  003be	e8 00 00 00 00	 call	 _sprintf
  003c3	83 c4 08	 add	 esp, 8
  003c6	03 45 f4	 add	 eax, DWORD PTR _current_pointer$[ebp]
  003c9	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax
$LN4@ConvertAdd:

; 91   : 	}
; 92   : 
; 93   : 	DWORD displacement;
; 94   : 	char temp[0x11c];
; 95   : 	IMAGEHLP_SYMBOL * imagehlp_symbol = (IMAGEHLP_SYMBOL *)temp;

  003cc	8d 85 94 fc ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  003d2	89 85 90 fc ff
	ff		 mov	 DWORD PTR _imagehlp_symbol$[ebp], eax

; 96   : 	memset(imagehlp_symbol, 0, sizeof(temp));

  003d8	68 1c 01 00 00	 push	 284			; 0000011cH
  003dd	6a 00		 push	 0
  003df	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_symbol$[ebp]
  003e5	50		 push	 eax
  003e6	e8 00 00 00 00	 call	 _memset
  003eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   : 	imagehlp_symbol->SizeOfStruct = 24;

  003ee	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_symbol$[ebp]
  003f4	c7 00 18 00 00
	00		 mov	 DWORD PTR [eax], 24	; 00000018H

; 98   : 	imagehlp_symbol->Address = address;

  003fa	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_symbol$[ebp]
  00400	8b 4d 0c	 mov	 ecx, DWORD PTR _address$[ebp]
  00403	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 99   : 	imagehlp_symbol->MaxNameLength = 0x104;

  00406	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_symbol$[ebp]
  0040c	c7 40 10 04 01
	00 00		 mov	 DWORD PTR [eax+16], 260	; 00000104H

; 100  : 
; 101  : 	if ( SymGetSymFromAddr(hProcess, address, &displacement, imagehlp_symbol) != FALSE )

  00413	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_symbol$[ebp]
  00419	50		 push	 eax
  0041a	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _displacement$[ebp]
  00420	51		 push	 ecx
  00421	8b 55 0c	 mov	 edx, DWORD PTR _address$[ebp]
  00424	52		 push	 edx
  00425	8b 45 08	 mov	 eax, DWORD PTR _hProcess$[ebp]
  00428	50		 push	 eax
  00429	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymGetSymFromAddr@16
  0042f	85 c0		 test	 eax, eax
  00431	0f 84 85 00 00
	00		 je	 $LN3@ConvertAdd

; 102  : 	{
; 103  : 		current_pointer += sprintf(current_pointer, "%s() ", imagehlp_symbol->Name);

  00437	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_symbol$[ebp]
  0043d	83 c0 14	 add	 eax, 20			; 00000014H
  00440	50		 push	 eax
  00441	68 00 00 00 00	 push	 OFFSET ??_C@_05GALAIONK@?$CFs?$CI?$CJ?5?$AA@
  00446	8b 4d f4	 mov	 ecx, DWORD PTR _current_pointer$[ebp]
  00449	51		 push	 ecx
  0044a	e8 00 00 00 00	 call	 _sprintf
  0044f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00452	03 45 f4	 add	 eax, DWORD PTR _current_pointer$[ebp]
  00455	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax

; 104  : 
; 105  : 		IMAGEHLP_LINE imagehlp_line;
; 106  : 		memset(&imagehlp_line, 0, sizeof(imagehlp_line));

  00458	6a 14		 push	 20			; 00000014H
  0045a	6a 00		 push	 0
  0045c	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR _imagehlp_line$206489[ebp]
  00462	50		 push	 eax
  00463	e8 00 00 00 00	 call	 _memset
  00468	83 c4 0c	 add	 esp, 12			; 0000000cH

; 107  : 		imagehlp_line.SizeOfStruct = sizeof(IMAGEHLP_LINE);

  0046b	c7 85 7c fc ff
	ff 14 00 00 00	 mov	 DWORD PTR _imagehlp_line$206489[ebp], 20 ; 00000014H

; 108  : 
; 109  : 		if ( SymGetLineFromAddr(hProcess, address, &displacement, &imagehlp_line) != FALSE )

  00475	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR _imagehlp_line$206489[ebp]
  0047b	50		 push	 eax
  0047c	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _displacement$[ebp]
  00482	51		 push	 ecx
  00483	8b 55 0c	 mov	 edx, DWORD PTR _address$[ebp]
  00486	52		 push	 edx
  00487	8b 45 08	 mov	 eax, DWORD PTR _hProcess$[ebp]
  0048a	50		 push	 eax
  0048b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymGetLineFromAddr@16
  00491	85 c0		 test	 eax, eax
  00493	74 25		 je	 SHORT $LN2@ConvertAdd

; 110  : 		{
; 111  : 			current_pointer += sprintf(current_pointer, "// %s(%i)", imagehlp_line.FileName, imagehlp_line.LineNumber);

  00495	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR _imagehlp_line$206489[ebp+8]
  0049b	50		 push	 eax
  0049c	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _imagehlp_line$206489[ebp+12]
  004a2	51		 push	 ecx
  004a3	68 00 00 00 00	 push	 OFFSET ??_C@_09HDDDNNCJ@?1?1?5?$CFs?$CI?$CFi?$CJ?$AA@
  004a8	8b 55 f4	 mov	 edx, DWORD PTR _current_pointer$[ebp]
  004ab	52		 push	 edx
  004ac	e8 00 00 00 00	 call	 _sprintf
  004b1	83 c4 10	 add	 esp, 16			; 00000010H
  004b4	03 45 f4	 add	 eax, DWORD PTR _current_pointer$[ebp]
  004b7	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax
$LN2@ConvertAdd:

; 112  : 		}
; 113  : 	}
; 114  : 	else

  004ba	eb 17		 jmp	 SHORT $LN1@ConvertAdd
$LN3@ConvertAdd:

; 115  : 	{
; 116  : 		current_pointer += sprintf(current_pointer, "<unknown symbol>");

  004bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@
  004c1	8b 45 f4	 mov	 eax, DWORD PTR _current_pointer$[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 _sprintf
  004ca	83 c4 08	 add	 esp, 8
  004cd	03 45 f4	 add	 eax, DWORD PTR _current_pointer$[ebp]
  004d0	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax
$LN1@ConvertAdd:

; 117  : 	}
; 118  : 	
; 119  : 	current_pointer += sprintf(current_pointer, "\r\n");

  004d3	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
  004d8	8b 45 f4	 mov	 eax, DWORD PTR _current_pointer$[ebp]
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 _sprintf
  004e1	83 c4 08	 add	 esp, 8
  004e4	03 45 f4	 add	 eax, DWORD PTR _current_pointer$[ebp]
  004e7	89 45 f4	 mov	 DWORD PTR _current_pointer$[ebp], eax

; 120  : 	return current_pointer - output_buffer;

  004ea	8b 45 f4	 mov	 eax, DWORD PTR _current_pointer$[ebp]
  004ed	2b 45 10	 sub	 eax, DWORD PTR _output_buffer$[ebp]

; 121  : }

  004f0	5f		 pop	 edi
  004f1	5e		 pop	 esi
  004f2	5b		 pop	 ebx
  004f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f6	33 cd		 xor	 ecx, ebp
  004f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004fd	8b e5		 mov	 esp, ebp
  004ff	5d		 pop	 ebp
  00500	c2 0c 00	 ret	 12			; 0000000cH
?ConvertAddress@CCallStackTrace@@AAEKPAXKPAD@Z ENDP	; CCallStackTrace::ConvertAddress
_TEXT	ENDS
EXTRN	_strrchr:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 219  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _strrchr
  00016	83 c4 08	 add	 esp, 8
  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
PUBLIC	?TraceStack@CCallStackTrace@@AAEHH@Z		; CCallStackTrace::TraceStack
PUBLIC	?SaveCallStack@CCallStackTrace@@QAEHH@Z		; CCallStackTrace::SaveCallStack
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\callstacktrace.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bWriteInFile$ = 8					; size = 4
?SaveCallStack@CCallStackTrace@@QAEHH@Z PROC		; CCallStackTrace::SaveCallStack
; _this$ = ecx

; 124  : {

  00510	55		 push	 ebp
  00511	8b ec		 mov	 ebp, esp
  00513	83 ec 44	 sub	 esp, 68			; 00000044H
  00516	53		 push	 ebx
  00517	56		 push	 esi
  00518	57		 push	 edi
  00519	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	return this->TraceStack(bWriteInFile);

  0051c	8b 45 08	 mov	 eax, DWORD PTR _bWriteInFile$[ebp]
  0051f	50		 push	 eax
  00520	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00523	e8 00 00 00 00	 call	 ?TraceStack@CCallStackTrace@@AAEHH@Z ; CCallStackTrace::TraceStack

; 126  : }

  00528	5f		 pop	 edi
  00529	5e		 pop	 esi
  0052a	5b		 pop	 ebx
  0052b	8b e5		 mov	 esp, ebp
  0052d	5d		 pop	 ebp
  0052e	c2 04 00	 ret	 4
?SaveCallStack@CCallStackTrace@@QAEHH@Z ENDP		; CCallStackTrace::SaveCallStack
_TEXT	ENDS
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	?GetModuleBase@CCallStackTrace@@CGKPAXK@Z	; CCallStackTrace::GetModuleBase
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	__$ArrayPad$
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__StackWalk@36:PROC
EXTRN	__imp__SymFunctionTableAccess@8:PROC
EXTRN	__imp__GetThreadContext@8:PROC
EXTRN	__imp__SymInitialize@12:PROC
EXTRN	__imp__SymSetOptions@4:PROC
EXTRN	__imp__SymGetOptions@0:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memset:PROC
EXTRN	__local_unwind4:PROC
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
xdata$x	SEGMENT
__sehtable$?TraceStack@CCallStackTrace@@AAEHH@Z DD 0ffffffe4H
	DD	00H
	DD	0ffff76f8H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN19@TraceStack
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
$T206712 = -35064					; size = 4
$T206713 = -35060					; size = 4
_symbol_size$206528 = -34992				; size = 4
_symbol$206527 = -34988					; size = 1284
_addr_index$206523 = -33704				; size = 4
_i$206515 = -33700					; size = 4
_stackframe$206514 = -33696				; size = 164
_context$206512 = -33532				; size = 716
_address_count$206511 = -32816				; size = 4
_addresses$206510 = -32812				; size = 32768
_option$206508 = -44					; size = 4
_hThread$206507 = -40					; size = 4
_hProcess$206506 = -36					; size = 4
_this$ = -32						; size = 4
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_bWriteInFile$ = 8					; size = 4
?TraceStack@CCallStackTrace@@AAEHH@Z PROC		; CCallStackTrace::TraceStack
; _this$ = ecx

; 129  : {

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	6a fe		 push	 -2			; fffffffeH
  00545	68 00 00 00 00	 push	 OFFSET __sehtable$?TraceStack@CCallStackTrace@@AAEHH@Z
  0054a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0054f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00555	50		 push	 eax
  00556	83 ec 08	 sub	 esp, 8
  00559	b8 e0 88 00 00	 mov	 eax, 35040		; 000088e0H
  0055e	e8 00 00 00 00	 call	 __chkstk
  00563	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00568	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  0056b	33 c5		 xor	 eax, ebp
  0056d	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00570	53		 push	 ebx
  00571	56		 push	 esi
  00572	57		 push	 edi
  00573	50		 push	 eax
  00574	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00577	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0057d	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	if ( strcmp(this->m_szLogID, "") == 0 )

  00580	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00585	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00588	83 c0 08	 add	 eax, 8
  0058b	50		 push	 eax
  0058c	e8 00 00 00 00	 call	 _strcmp
  00591	83 c4 08	 add	 esp, 8
  00594	85 c0		 test	 eax, eax
  00596	75 1c		 jne	 SHORT $LN15@TraceStack

; 131  : 	{
; 132  : 		MessageBox(NULL, "INSERT LOG-ID !!!", "ERROR", MB_OK);

  00598	6a 00		 push	 0
  0059a	68 00 00 00 00	 push	 OFFSET ??_C@_05MBDEGLCK@ERROR?$AA@
  0059f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@ILOEJNOF@INSERT?5LOG?9ID?5?$CB?$CB?$CB?$AA@
  005a4	6a 00		 push	 0
  005a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 133  : 		return -1;

  005ac	83 c8 ff	 or	 eax, -1
  005af	e9 fe 02 00 00	 jmp	 $LN18@TraceStack
$LN15@TraceStack:

; 134  : 	}
; 135  : 
; 136  : 	this->m_strCallStackLog = "";

  005b4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  005b9	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  005bc	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  005c2	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 137  : 
; 138  : 	EnterCriticalSection(&this->m_critLogToFile);

  005c7	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  005ca	05 18 04 00 00	 add	 eax, 1048		; 00000418H
  005cf	50		 push	 eax
  005d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 139  : 
; 140  : 	__try

  005d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 141  : 	{
; 142  : 		HANDLE hProcess = GetCurrentProcess();

  005dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  005e3	89 45 dc	 mov	 DWORD PTR _hProcess$206506[ebp], eax

; 143  : 		HANDLE hThread  = GetCurrentThread();

  005e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  005ec	89 45 d8	 mov	 DWORD PTR _hThread$206507[ebp], eax

; 144  : 		DWORD option = SymGetOptions();

  005ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymGetOptions@0
  005f5	89 45 d4	 mov	 DWORD PTR _option$206508[ebp], eax

; 145  : 		option |= 0x10;

  005f8	8b 45 d4	 mov	 eax, DWORD PTR _option$206508[ebp]
  005fb	83 c8 10	 or	 eax, 16			; 00000010H
  005fe	89 45 d4	 mov	 DWORD PTR _option$206508[ebp], eax

; 146  : 		option &= ~2;

  00601	8b 45 d4	 mov	 eax, DWORD PTR _option$206508[ebp]
  00604	83 e0 fd	 and	 eax, -3			; fffffffdH
  00607	89 45 d4	 mov	 DWORD PTR _option$206508[ebp], eax

; 147  : 		SymSetOptions(option|0x10);

  0060a	8b 45 d4	 mov	 eax, DWORD PTR _option$206508[ebp]
  0060d	83 c8 10	 or	 eax, 16			; 00000010H
  00610	50		 push	 eax
  00611	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymSetOptions@4

; 148  : 
; 149  : 		if (SymInitialize(hProcess, NULL, TRUE) == FALSE )

  00617	6a 01		 push	 1
  00619	6a 00		 push	 0
  0061b	8b 45 dc	 mov	 eax, DWORD PTR _hProcess$206506[ebp]
  0061e	50		 push	 eax
  0061f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymInitialize@12
  00625	85 c0		 test	 eax, eax
  00627	75 28		 jne	 SHORT $LN13@TraceStack

; 150  : 		{
; 151  : 			return -1;

  00629	c7 85 08 77 ff
	ff ff ff ff ff	 mov	 DWORD PTR $T206712[ebp], -1
  00633	6a fe		 push	 -2			; fffffffeH
  00635	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00638	50		 push	 eax
  00639	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0063e	e8 00 00 00 00	 call	 __local_unwind4
  00643	83 c4 0c	 add	 esp, 12			; 0000000cH
  00646	8b 85 08 77 ff
	ff		 mov	 eax, DWORD PTR $T206712[ebp]
  0064c	e9 61 02 00 00	 jmp	 $LN18@TraceStack
$LN13@TraceStack:

; 152  : 		}
; 153  : 
; 154  : 		DWORD addresses[0x2000]={0};

  00651	c7 85 d4 7f ff
	ff 00 00 00 00	 mov	 DWORD PTR _addresses$206510[ebp], 0
  0065b	68 fc 7f 00 00	 push	 32764			; 00007ffcH
  00660	6a 00		 push	 0
  00662	8d 85 d8 7f ff
	ff		 lea	 eax, DWORD PTR _addresses$206510[ebp+4]
  00668	50		 push	 eax
  00669	e8 00 00 00 00	 call	 _memset
  0066e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 		UINT address_count = 0;

  00671	c7 85 d0 7f ff
	ff 00 00 00 00	 mov	 DWORD PTR _address_count$206511[ebp], 0

; 156  : 		CONTEXT context;
; 157  : 		memset(&context, 0, sizeof(context));

  0067b	68 cc 02 00 00	 push	 716			; 000002ccH
  00680	6a 00		 push	 0
  00682	8d 85 04 7d ff
	ff		 lea	 eax, DWORD PTR _context$206512[ebp]
  00688	50		 push	 eax
  00689	e8 00 00 00 00	 call	 _memset
  0068e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : 		context.ContextFlags = 0x10007;

  00691	c7 85 04 7d ff
	ff 07 00 01 00	 mov	 DWORD PTR _context$206512[ebp], 65543 ; 00010007H

; 159  : 
; 160  : 		if ( GetThreadContext(GetCurrentThread(), &context) == FALSE )

  0069b	8d 85 04 7d ff
	ff		 lea	 eax, DWORD PTR _context$206512[ebp]
  006a1	50		 push	 eax
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  006a8	50		 push	 eax
  006a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadContext@8
  006af	85 c0		 test	 eax, eax
  006b1	75 28		 jne	 SHORT $LN12@TraceStack

; 161  : 		{
; 162  : 			return -1;

  006b3	c7 85 0c 77 ff
	ff ff ff ff ff	 mov	 DWORD PTR $T206713[ebp], -1
  006bd	6a fe		 push	 -2			; fffffffeH
  006bf	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  006c2	50		 push	 eax
  006c3	68 00 00 00 00	 push	 OFFSET ___security_cookie
  006c8	e8 00 00 00 00	 call	 __local_unwind4
  006cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d0	8b 85 0c 77 ff
	ff		 mov	 eax, DWORD PTR $T206713[ebp]
  006d6	e9 d7 01 00 00	 jmp	 $LN18@TraceStack
$LN12@TraceStack:

; 163  : 		}
; 164  : 
; 165  : 		STACKFRAME stackframe;
; 166  : 		memset(&stackframe, 0, sizeof(stackframe));

  006db	68 a4 00 00 00	 push	 164			; 000000a4H
  006e0	6a 00		 push	 0
  006e2	8d 85 60 7c ff
	ff		 lea	 eax, DWORD PTR _stackframe$206514[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 _memset
  006ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 
; 168  : 		stackframe.AddrPC.Mode = AddrModeFlat;

  006f1	c7 85 68 7c ff
	ff 03 00 00 00	 mov	 DWORD PTR _stackframe$206514[ebp+8], 3

; 169  : 		stackframe.AddrPC.Offset = context.Eip;

  006fb	8b 85 bc 7d ff
	ff		 mov	 eax, DWORD PTR _context$206512[ebp+184]
  00701	89 85 60 7c ff
	ff		 mov	 DWORD PTR _stackframe$206514[ebp], eax

; 170  : 
; 171  : 		stackframe.AddrStack.Offset = context.Esp;

  00707	8b 85 c8 7d ff
	ff		 mov	 eax, DWORD PTR _context$206512[ebp+196]
  0070d	89 85 84 7c ff
	ff		 mov	 DWORD PTR _stackframe$206514[ebp+36], eax

; 172  : 		stackframe.AddrStack.Mode = AddrModeFlat;

  00713	c7 85 8c 7c ff
	ff 03 00 00 00	 mov	 DWORD PTR _stackframe$206514[ebp+44], 3

; 173  : 		
; 174  : 		stackframe.AddrFrame.Offset = context.Ebp;

  0071d	8b 85 b8 7d ff
	ff		 mov	 eax, DWORD PTR _context$206512[ebp+180]
  00723	89 85 78 7c ff
	ff		 mov	 DWORD PTR _stackframe$206514[ebp+24], eax

; 175  : 		stackframe.AddrFrame.Mode = AddrModeFlat;

  00729	c7 85 80 7c ff
	ff 03 00 00 00	 mov	 DWORD PTR _stackframe$206514[ebp+32], 3

; 176  : 
; 177  : 		for ( UINT i=0; i<512; i++ )

  00733	c7 85 5c 7c ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$206515[ebp], 0
  0073d	eb 0f		 jmp	 SHORT $LN11@TraceStack
$LN10@TraceStack:
  0073f	8b 85 5c 7c ff
	ff		 mov	 eax, DWORD PTR _i$206515[ebp]
  00745	83 c0 01	 add	 eax, 1
  00748	89 85 5c 7c ff
	ff		 mov	 DWORD PTR _i$206515[ebp], eax
$LN11@TraceStack:
  0074e	81 bd 5c 7c ff
	ff 00 02 00 00	 cmp	 DWORD PTR _i$206515[ebp], 512 ; 00000200H
  00758	73 6f		 jae	 SHORT $LN9@TraceStack

; 178  : 		{
; 179  : 			if ( StackWalk( 332, hProcess, hThread, &stackframe, &context, NULL, SymFunctionTableAccess, (PGET_MODULE_BASE_ROUTINE)CCallStackTrace::GetModuleBase, NULL) == FALSE )

  0075a	6a 00		 push	 0
  0075c	68 00 00 00 00	 push	 OFFSET ?GetModuleBase@CCallStackTrace@@CGKPAXK@Z ; CCallStackTrace::GetModuleBase
  00761	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SymFunctionTableAccess@8
  00766	50		 push	 eax
  00767	6a 00		 push	 0
  00769	8d 8d 04 7d ff
	ff		 lea	 ecx, DWORD PTR _context$206512[ebp]
  0076f	51		 push	 ecx
  00770	8d 95 60 7c ff
	ff		 lea	 edx, DWORD PTR _stackframe$206514[ebp]
  00776	52		 push	 edx
  00777	8b 45 d8	 mov	 eax, DWORD PTR _hThread$206507[ebp]
  0077a	50		 push	 eax
  0077b	8b 4d dc	 mov	 ecx, DWORD PTR _hProcess$206506[ebp]
  0077e	51		 push	 ecx
  0077f	68 4c 01 00 00	 push	 332			; 0000014cH
  00784	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StackWalk@36
  0078a	85 c0		 test	 eax, eax
  0078c	75 02		 jne	 SHORT $LN8@TraceStack

; 180  : 			{
; 181  : 				break;

  0078e	eb 39		 jmp	 SHORT $LN9@TraceStack
$LN8@TraceStack:

; 182  : 			}
; 183  : 
; 184  : 			if ( i > 1 )

  00790	83 bd 5c 7c ff
	ff 01		 cmp	 DWORD PTR _i$206515[ebp], 1
  00797	76 2b		 jbe	 SHORT $LN7@TraceStack

; 185  : 			{
; 186  : 				 if ( stackframe.AddrPC.Offset != 0 )

  00799	83 bd 60 7c ff
	ff 00		 cmp	 DWORD PTR _stackframe$206514[ebp], 0
  007a0	74 22		 je	 SHORT $LN7@TraceStack

; 187  : 				 {
; 188  : 					 addresses[address_count] = stackframe.AddrPC.Offset;

  007a2	8b 85 d0 7f ff
	ff		 mov	 eax, DWORD PTR _address_count$206511[ebp]
  007a8	8b 8d 60 7c ff
	ff		 mov	 ecx, DWORD PTR _stackframe$206514[ebp]
  007ae	89 8c 85 d4 7f
	ff ff		 mov	 DWORD PTR _addresses$206510[ebp+eax*4], ecx

; 189  : 					 address_count++;

  007b5	8b 85 d0 7f ff
	ff		 mov	 eax, DWORD PTR _address_count$206511[ebp]
  007bb	83 c0 01	 add	 eax, 1
  007be	89 85 d0 7f ff
	ff		 mov	 DWORD PTR _address_count$206511[ebp], eax
$LN7@TraceStack:

; 190  : 				 }
; 191  : 			}
; 192  : 		}

  007c4	e9 76 ff ff ff	 jmp	 $LN10@TraceStack
$LN9@TraceStack:

; 193  : 
; 194  : 		for ( UINT addr_index =0 ;addr_index < address_count ; addr_index++ )

  007c9	c7 85 58 7c ff
	ff 00 00 00 00	 mov	 DWORD PTR _addr_index$206523[ebp], 0
  007d3	eb 0f		 jmp	 SHORT $LN5@TraceStack
$LN4@TraceStack:
  007d5	8b 85 58 7c ff
	ff		 mov	 eax, DWORD PTR _addr_index$206523[ebp]
  007db	83 c0 01	 add	 eax, 1
  007de	89 85 58 7c ff
	ff		 mov	 DWORD PTR _addr_index$206523[ebp], eax
$LN5@TraceStack:
  007e4	8b 85 58 7c ff
	ff		 mov	 eax, DWORD PTR _addr_index$206523[ebp]
  007ea	3b 85 d0 7f ff
	ff		 cmp	 eax, DWORD PTR _address_count$206511[ebp]
  007f0	73 71		 jae	 SHORT $LN3@TraceStack

; 195  : 		{
; 196  : 			char symbol[0x504] ={0};

  007f2	c6 85 54 77 ff
	ff 00		 mov	 BYTE PTR _symbol$206527[ebp], 0
  007f9	68 03 05 00 00	 push	 1283			; 00000503H
  007fe	6a 00		 push	 0
  00800	8d 85 55 77 ff
	ff		 lea	 eax, DWORD PTR _symbol$206527[ebp+1]
  00806	50		 push	 eax
  00807	e8 00 00 00 00	 call	 _memset
  0080c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  : 			DWORD symbol_size = this->ConvertAddress(hProcess, addresses[addr_index], symbol);

  0080f	8d 85 54 77 ff
	ff		 lea	 eax, DWORD PTR _symbol$206527[ebp]
  00815	50		 push	 eax
  00816	8b 8d 58 7c ff
	ff		 mov	 ecx, DWORD PTR _addr_index$206523[ebp]
  0081c	8b 94 8d d4 7f
	ff ff		 mov	 edx, DWORD PTR _addresses$206510[ebp+ecx*4]
  00823	52		 push	 edx
  00824	8b 45 dc	 mov	 eax, DWORD PTR _hProcess$206506[ebp]
  00827	50		 push	 eax
  00828	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0082b	e8 00 00 00 00	 call	 ?ConvertAddress@CCallStackTrace@@AAEKPAXKPAD@Z ; CCallStackTrace::ConvertAddress
  00830	89 85 50 77 ff
	ff		 mov	 DWORD PTR _symbol_size$206528[ebp], eax

; 198  : 			this->m_strCallStackLog += "\t";

  00836	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
  0083b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0083e	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  00844	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 199  : 			this->m_strCallStackLog += symbol;

  00849	8d 85 54 77 ff
	ff		 lea	 eax, DWORD PTR _symbol$206527[ebp]
  0084f	50		 push	 eax
  00850	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00853	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  00859	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 200  : 		}

  0085e	e9 72 ff ff ff	 jmp	 $LN4@TraceStack
$LN3@TraceStack:

; 201  : 
; 202  : 		if ( bWriteInFile )

  00863	83 7d 08 00	 cmp	 DWORD PTR _bWriteInFile$[ebp], 0
  00867	74 1d		 je	 SHORT $LN14@TraceStack

; 203  : 		{
; 204  : 			if ( this->m_strCallStackLog.empty() == false )

  00869	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0086c	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  00872	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  00877	0f b6 c0	 movzx	 eax, al
  0087a	85 c0		 test	 eax, eax
  0087c	75 08		 jne	 SHORT $LN14@TraceStack

; 205  : 			{
; 206  : 				this->Output();

  0087e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00881	e8 00 00 00 00	 call	 ?Output@CCallStackTrace@@AAEXXZ ; CCallStackTrace::Output
$LN14@TraceStack:

; 207  : 			}
; 208  : 		}
; 209  : 	}
; 210  : 	__finally

  00886	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  0088d	e8 02 00 00 00	 call	 $LN21@TraceStack
  00892	eb 10		 jmp	 SHORT $LN22@TraceStack
$LN19@TraceStack:
$LN24@TraceStack:
$LN21@TraceStack:

; 211  : 	{
; 212  : 		LeaveCriticalSection(&this->m_critLogToFile);

  00894	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00897	05 18 04 00 00	 add	 eax, 1048		; 00000418H
  0089c	50		 push	 eax
  0089d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN20@TraceStack:
$LN23@TraceStack:
  008a3	c3		 ret	 0
$LN22@TraceStack:

; 213  : 		//return this->m_strCallStackLog.size();
; 214  : 	}
; 215  : 	return this->m_strCallStackLog.size();

  008a4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  008a7	81 c1 30 04 00
	00		 add	 ecx, 1072		; 00000430H
  008ad	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
$LN18@TraceStack:

; 216  : }

  008b2	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  008b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  008bc	59		 pop	 ecx
  008bd	5f		 pop	 edi
  008be	5e		 pop	 esi
  008bf	5b		 pop	 ebx
  008c0	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008c3	33 cd		 xor	 ecx, ebp
  008c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008ca	8b e5		 mov	 esp, ebp
  008cc	5d		 pop	 ebp
  008cd	c2 04 00	 ret	 4
?TraceStack@CCallStackTrace@@AAEHH@Z ENDP		; CCallStackTrace::TraceStack
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__imp__SymLoadModule@24:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__VirtualQueryEx@16:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_image_name$ = -876					; size = 4
_file_handle$ = -872					; size = 4
_module_file_name_length$ = -868			; size = 4
_module_file_name$ = -864				; size = 260
_memory_basic_information$ = -604			; size = 28
_imagehlp_module$ = -576				; size = 572
__$ArrayPad$ = -4					; size = 4
_hProcess$ = 8						; size = 4
_address$ = 12						; size = 4
?GetModuleBase@CCallStackTrace@@CGKPAXK@Z PROC		; CCallStackTrace::GetModuleBase

; 219  : {

  008d0	55		 push	 ebp
  008d1	8b ec		 mov	 ebp, esp
  008d3	81 ec ac 03 00
	00		 sub	 esp, 940		; 000003acH
  008d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  008de	33 c5		 xor	 eax, ebp
  008e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  008e3	53		 push	 ebx
  008e4	56		 push	 esi
  008e5	57		 push	 edi

; 220  : 	IMAGEHLP_MODULE imagehlp_module;
; 221  : 	MEMORY_BASIC_INFORMATION memory_basic_information;
; 222  : 	char module_file_name[260];
; 223  : 	DWORD module_file_name_length;
; 224  : 	HANDLE file_handle;
; 225  : 	char * image_name;
; 226  : 
; 227  : 	imagehlp_module.SizeOfStruct = sizeof(imagehlp_module);

  008e6	c7 85 c0 fd ff
	ff 3c 02 00 00	 mov	 DWORD PTR _imagehlp_module$[ebp], 572 ; 0000023cH

; 228  : 
; 229  : 	if ( SymGetModuleInfo(hProcess, address, &imagehlp_module) == TRUE )

  008f0	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _imagehlp_module$[ebp]
  008f6	50		 push	 eax
  008f7	8b 4d 0c	 mov	 ecx, DWORD PTR _address$[ebp]
  008fa	51		 push	 ecx
  008fb	8b 55 08	 mov	 edx, DWORD PTR _hProcess$[ebp]
  008fe	52		 push	 edx
  008ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymGetModuleInfo@12
  00905	83 f8 01	 cmp	 eax, 1
  00908	75 0b		 jne	 SHORT $LN6@GetModuleB

; 230  : 	{
; 231  : 		return imagehlp_module.BaseOfImage;

  0090a	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _imagehlp_module$[ebp+4]
  00910	e9 cc 00 00 00	 jmp	 $LN7@GetModuleB
$LN6@GetModuleB:

; 232  : 	}
; 233  : 
; 234  : 	if ( VirtualQueryEx(hProcess, (LPCVOID)address, &memory_basic_information, sizeof(memory_basic_information)) == FALSE )

  00915	6a 1c		 push	 28			; 0000001cH
  00917	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR _memory_basic_information$[ebp]
  0091d	50		 push	 eax
  0091e	8b 4d 0c	 mov	 ecx, DWORD PTR _address$[ebp]
  00921	51		 push	 ecx
  00922	8b 55 08	 mov	 edx, DWORD PTR _hProcess$[ebp]
  00925	52		 push	 edx
  00926	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualQueryEx@16
  0092c	85 c0		 test	 eax, eax
  0092e	75 07		 jne	 SHORT $LN5@GetModuleB

; 235  : 	{
; 236  : 		return 0;

  00930	33 c0		 xor	 eax, eax
  00932	e9 aa 00 00 00	 jmp	 $LN7@GetModuleB
$LN5@GetModuleB:

; 237  : 	}
; 238  : 
; 239  : 	module_file_name_length = GetModuleFileName((HMODULE)memory_basic_information.AllocationBase, module_file_name, sizeof(module_file_name));

  00937	68 04 01 00 00	 push	 260			; 00000104H
  0093c	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _module_file_name$[ebp]
  00942	50		 push	 eax
  00943	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _memory_basic_information$[ebp+4]
  00949	51		 push	 ecx
  0094a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  00950	89 85 9c fc ff
	ff		 mov	 DWORD PTR _module_file_name_length$[ebp], eax

; 240  : 
; 241  : 	if ( module_file_name_length )

  00956	83 bd 9c fc ff
	ff 00		 cmp	 DWORD PTR _module_file_name_length$[ebp], 0
  0095d	74 24		 je	 SHORT $LN4@GetModuleB

; 242  : 	{
; 243  : 		file_handle = CreateFile(module_file_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

  0095f	6a 00		 push	 0
  00961	6a 00		 push	 0
  00963	6a 03		 push	 3
  00965	6a 00		 push	 0
  00967	6a 01		 push	 1
  00969	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0096e	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _module_file_name$[ebp]
  00974	50		 push	 eax
  00975	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0097b	89 85 98 fc ff
	ff		 mov	 DWORD PTR _file_handle$[ebp], eax

; 244  : 	}
; 245  : 	else

  00981	eb 0a		 jmp	 SHORT $LN3@GetModuleB
$LN4@GetModuleB:

; 246  : 	{
; 247  : 		file_handle = NULL;

  00983	c7 85 98 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _file_handle$[ebp], 0
$LN3@GetModuleB:

; 248  : 	}
; 249  : 
; 250  : 	image_name = NULL;

  0098d	c7 85 94 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _image_name$[ebp], 0

; 251  : 
; 252  : 	if ( module_file_name_length > 0 )

  00997	83 bd 9c fc ff
	ff 00		 cmp	 DWORD PTR _module_file_name_length$[ebp], 0
  0099e	76 0e		 jbe	 SHORT $LN2@GetModuleB

; 253  : 	{
; 254  : 		image_name = module_file_name;

  009a0	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _module_file_name$[ebp]
  009a6	89 85 94 fc ff
	ff		 mov	 DWORD PTR _image_name$[ebp], eax

; 255  : 	}
; 256  : 	else

  009ac	eb 0a		 jmp	 SHORT $LN1@GetModuleB
$LN2@GetModuleB:

; 257  : 	{
; 258  : 		image_name = NULL;

  009ae	c7 85 94 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _image_name$[ebp], 0
$LN1@GetModuleB:

; 259  : 	}
; 260  : 
; 261  : 	SymLoadModule(hProcess, file_handle, image_name, 0, (DWORD)memory_basic_information.AllocationBase, 0);

  009b8	6a 00		 push	 0
  009ba	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _memory_basic_information$[ebp+4]
  009c0	50		 push	 eax
  009c1	6a 00		 push	 0
  009c3	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR _image_name$[ebp]
  009c9	51		 push	 ecx
  009ca	8b 95 98 fc ff
	ff		 mov	 edx, DWORD PTR _file_handle$[ebp]
  009d0	52		 push	 edx
  009d1	8b 45 08	 mov	 eax, DWORD PTR _hProcess$[ebp]
  009d4	50		 push	 eax
  009d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SymLoadModule@24

; 262  : 
; 263  : 	return (DWORD)memory_basic_information.AllocationBase;

  009db	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _memory_basic_information$[ebp+4]
$LN7@GetModuleB:

; 264  : }

  009e1	5f		 pop	 edi
  009e2	5e		 pop	 esi
  009e3	5b		 pop	 ebx
  009e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009e7	33 cd		 xor	 ecx, ebp
  009e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009ee	8b e5		 mov	 esp, ebp
  009f0	5d		 pop	 ebp
  009f1	c2 08 00	 ret	 8
?GetModuleBase@CCallStackTrace@@CGKPAXK@Z ENDP		; CCallStackTrace::GetModuleBase
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 767  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 768  : 		return (assign(_Ptr));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 769  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odtp /ZI
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 782  : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 783  : 		return (append(_Ptr));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 784  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /ZI
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1435 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 
; 1438 : 		if (this->_Mysize <= _Off)
; 1439 : 
; 1440 : 			_DEBUG_ERROR("string subscript out of range");
; 1441 : 
; 1442 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1443 : 		_SCL_SECURE_VALIDATE_RANGE(_Off < this->_Mysize);
; 1444 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1445 : 
; 1446 : 		return (_Myptr()[_Off]);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00014	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 1447 : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1549 : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1550 : 		return (this->_Mysize == 0);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00015	0f 94 c1	 sete	 cl
  00018	8a c1		 mov	 al, cl

; 1551 : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Odtp /ZI
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 838  : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 839  : 		_DEBUG_POINTER(_Ptr);
; 840  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 841  : 		}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odtp /ZI
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 817  : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 819  : 		if (_Count != 0)
; 820  : 			_DEBUG_POINTER(_Ptr);
; 821  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 822  : 
; 823  : 		if (_Inside(_Ptr))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 20		 je	 SHORT $LN3@append

; 824  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	2b c8		 sub	 ecx, eax
  00030	51		 push	 ecx
  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	52		 push	 edx
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0003d	eb 6b		 jmp	 SHORT $LN5@append
$LN3@append:

; 825  : 		if (npos - this->_Mysize <= _Count)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c9 ff	 or	 ecx, -1
  00045	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  00048	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0004b	77 08		 ja	 SHORT $LN2@append

; 826  : 			_Xlen();	// result too long

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 827  : 
; 828  : 		size_type _Num;
; 829  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00055	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00059	76 4c		 jbe	 SHORT $LN1@append
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00061	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00064	89 4d f8	 mov	 DWORD PTR __Num$[ebp], ecx
  00067	6a 00		 push	 0
  00069	8b 55 f8	 mov	 edx, DWORD PTR __Num$[ebp]
  0006c	52		 push	 edx
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00075	0f b6 c0	 movzx	 eax, al
  00078	85 c0		 test	 eax, eax
  0007a	74 2b		 je	 SHORT $LN1@append

; 830  : 			{	// make room and append new stuff
; 831  : 			_Traits::copy(_Myptr() + this->_Mysize, _Ptr, _Count);

  0007c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00083	51		 push	 ecx
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	03 42 10	 add	 eax, DWORD PTR [edx+16]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 832  : 			_Eos(_Num);

  0009b	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  0009e	50		 push	 eax
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append:

; 833  : 			}
; 834  : 		return (*this);

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@append:

; 835  : 		}

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
; Function compile flags: /Odtp /ZI
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 798  : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 799  : 		if (_Right.size() < _Roff)

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00017	73 08		 jae	 SHORT $LN4@append@2

; 800  : 			_Xran();	// _Roff off end

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@append@2:

; 801  : 		size_type _Num = _Right.size() - _Roff;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00029	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 802  : 		if (_Num < _Count)

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  00032	3b 45 10	 cmp	 eax, DWORD PTR __Count$[ebp]
  00035	73 06		 jae	 SHORT $LN3@append@2

; 803  : 			_Count = _Num;	// trim _Count to size

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  0003a	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax
$LN3@append@2:

; 804  : 		if (npos - this->_Mysize <= _Count)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c9 ff	 or	 ecx, -1
  00043	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  00046	3b 4d 10	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00049	77 08		 ja	 SHORT $LN2@append@2

; 805  : 			_Xlen();	// result too long

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append@2:

; 806  : 
; 807  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00053	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00057	76 54		 jbe	 SHORT $LN1@append@2
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005f	03 4d 10	 add	 ecx, DWORD PTR __Count$[ebp]
  00062	89 4d f8	 mov	 DWORD PTR __Num$[ebp], ecx
  00065	6a 00		 push	 0
  00067	8b 55 f8	 mov	 edx, DWORD PTR __Num$[ebp]
  0006a	52		 push	 edx
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	74 33		 je	 SHORT $LN1@append@2

; 808  : 			{	// make room and append new stuff
; 809  : 			_Traits::copy(_Myptr() + this->_Mysize,
; 810  : 				_Right._Myptr() + _Roff, _Count);

  0007a	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00081	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00086	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 811  : 			_Eos(_Num);

  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append@2:

; 812  : 			}
; 813  : 		return (*this);

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN6@append@2:

; 814  : 		}

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 491  : 		return (_CSTD strlen(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4

; 492  : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 498  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T206744 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 550  : 		{	// construct empty string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	51		 push	 ecx
  0002c	8b cc		 mov	 ecx, esp
  0002e	89 65 ac	 mov	 DWORD PTR $T206744[ebp], esp
  00031	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 551  : 		_Tidy();

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 552  : 		}

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 752  : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 753  : 		_Tidy(true);

  00032	6a 00		 push	 0
  00034	6a 01		 push	 1
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 754  : 		}

  0003e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1510 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1511 : 		return (this->_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1512 : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /ZI
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 928  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  : 		_DEBUG_POINTER(_Ptr);
; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 931  : 		}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$201846 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1987 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1988 : 		if (!_Built)

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00010	85 c0		 test	 eax, eax
  00012	75 02		 jne	 SHORT $LN4@Tidy
  00014	eb 44		 jmp	 SHORT $LN3@Tidy
$LN4@Tidy:

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001d	72 3b		 jb	 SHORT $LN3@Tidy

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d f8	 mov	 DWORD PTR __Ptr$201846[ebp], ecx

; 1993 : 			if (0 < _Newsize)

  00027	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0002b	76 14		 jbe	 SHORT $LN1@Tidy

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$201846[ebp]
  00034	51		 push	 ecx
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Tidy:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00047	83 c1 01	 add	 ecx, 1
  0004a	51		 push	 ecx
  0004b	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$201846[ebp]
  0004e	52		 push	 edx
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 c1 18	 add	 ecx, 24			; 00000018H
  00055	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN3@Tidy:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 1998 : 		_Eos(_Newsize);

  00064	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00067	50		 push	 eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1999 : 		}

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv80 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2008 : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00013	72 0a		 jb	 SHORT $LN3@Myptr
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	89 55 b8	 mov	 DWORD PTR tv80[ebp], edx
  0001d	eb 06		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	89 45 b8	 mov	 DWORD PTR tv80[ebp], eax
$LN4@Myptr:
  00025	8b 45 b8	 mov	 eax, DWORD PTR tv80[ebp]

; 2011 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 455  : 		}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 458  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)
; 913  : 			_DEBUG_POINTER(_Ptr);
; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 20		 je	 SHORT $LN2@assign

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	2b c8		 sub	 ecx, eax
  00030	51		 push	 ecx
  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	52		 push	 edx
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	eb 3d		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 918  : 
; 919  : 		if (_Grow(_Count))

  0003f	6a 00		 push	 0
  00041	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00044	50		 push	 eax
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0004d	0f b6 c8	 movzx	 ecx, al
  00050	85 c9		 test	 ecx, ecx
  00052	74 25		 je	 SHORT $LN1@assign

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

  00054	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 922  : 			_Eos(_Count);

  0006d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00070	50		 push	 eax
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 923  : 			}
; 924  : 		return (*this);

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 925  : 		}

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T206785 = -69						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1952 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  0000c	c6 45 bb 00	 mov	 BYTE PTR $T206785[ebp], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00016	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00019	8d 55 bb	 lea	 edx, DWORD PTR $T206785[ebp]
  0001c	52		 push	 edx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00025	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0002e	83 c4 08	 add	 esp, 8

; 1954 : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 527  : 		_Left = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 10		 mov	 BYTE PTR [eax], dl

; 528  : 		}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv80 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2002 : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00013	72 0a		 jb	 SHORT $LN3@Myptr@2
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	89 55 b8	 mov	 DWORD PTR tv80[ebp], edx
  0001d	eb 06		 jmp	 SHORT $LN4@Myptr@2
$LN3@Myptr@2:
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	89 45 b8	 mov	 DWORD PTR tv80[ebp], eax
$LN4@Myptr@2:
  00025	8b 45 b8	 mov	 eax, DWORD PTR tv80[ebp]

; 2005 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2019 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2020 : 		_Xout_of_range("invalid string position");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2021 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File d:\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 893  : 		if (_Right.size() < _Roff)

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00017	73 08		 jae	 SHORT $LN5@assign@2

; 894  : 			_Xran();	// _Roff off end

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign@2:

; 895  : 		size_type _Num = _Right.size() - _Roff;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00029	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 896  : 		if (_Count < _Num)

  0002f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00032	3b 45 f8	 cmp	 eax, DWORD PTR __Num$[ebp]
  00035	73 06		 jae	 SHORT $LN4@assign@2

; 897  : 			_Num = _Count;	// trim _Num to size

  00037	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax
$LN4@assign@2:

; 898  : 
; 899  : 		if (this == &_Right)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00043	75 25		 jne	 SHORT $LN3@assign@2

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
  0004a	50		 push	 eax
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0004e	03 4d f8	 add	 ecx, DWORD PTR __Num$[ebp]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0005a	8b 55 0c	 mov	 edx, DWORD PTR __Roff$[ebp]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00068	eb 42		 jmp	 SHORT $LN2@assign@2
$LN3@assign@2:

; 901  : 		else if (_Grow(_Num))

  0006a	6a 00		 push	 0
  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 2d		 je	 SHORT $LN2@assign@2

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0007f	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  00082	50		 push	 eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0008b	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 904  : 			_Eos(_Num);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign@2:

; 905  : 			}
; 906  : 		return (*this);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN7@assign@2:

; 907  : 		}

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv129 = -72						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1958 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1959 : 		if (max_size() < _Newsize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00014	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00017	73 08		 jae	 SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00027	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  0002a	73 15		 jae	 SHORT $LN5@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00036	52		 push	 edx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0003f	eb 4a		 jmp	 SHORT $LN4@Grow
$LN5@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00041	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  00045	85 c0		 test	 eax, eax
  00047	74 32		 je	 SHORT $LN3@Grow
  00049	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  0004d	73 2c		 jae	 SHORT $LN3@Grow

; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00055	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00058	73 08		 jae	 SHORT $LN9@Grow
  0005a	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0005d	89 55 b8	 mov	 DWORD PTR tv129[ebp], edx
  00060	eb 09		 jmp	 SHORT $LN10@Grow
$LN9@Grow:
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00068	89 4d b8	 mov	 DWORD PTR tv129[ebp], ecx
$LN10@Grow:
  0006b	8b 55 b8	 mov	 edx, DWORD PTR tv129[ebp]
  0006e	52		 push	 edx
  0006f	6a 01		 push	 1
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00079	eb 10		 jmp	 SHORT $LN4@Grow
$LN3@Grow:

; 1966 : 		else if (_Newsize == 0)

  0007b	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0007f	75 0a		 jne	 SHORT $LN4@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

  00081	6a 00		 push	 0
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

  0008b	33 c0		 xor	 eax, eax
  0008d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00090	1b c0		 sbb	 eax, eax
  00092	f7 d8		 neg	 eax
$LN8@Grow:

; 1969 : 		}

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1972 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

  0000c	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00010	74 20		 je	 SHORT $LN2@Inside
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0001a	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  0001d	72 13		 jb	 SHORT $LN2@Inside
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  0002d	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  00030	77 06		 ja	 SHORT $LN3@Inside
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

  00032	32 c0		 xor	 al, al
  00034	eb 04		 jmp	 SHORT $LN4@Inside

; 1975 : 		else

  00036	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:

; 1976 : 			return (true);

  00038	b0 01		 mov	 al, 1
$LN4@Inside:

; 1977 : 		}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2014 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2015 : 		_Xlength_error("string too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 2016 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$202635 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1109 : 		if (this->_Mysize < _Off)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00015	73 08		 jae	 SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00025	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00028	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0002b	73 0c		 jae	 SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00033	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00036	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
$LN2@erase:

; 1113 : 		if (0 < _Count)

  00039	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003d	76 48		 jbe	 SHORT $LN1@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00045	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00048	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00054	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00057	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00063	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00075	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  00078	89 4d f8	 mov	 DWORD PTR __Newsize$202635[ebp], ecx

; 1118 : 			_Eos(_Newsize);

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$202635[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@erase:

; 1119 : 			}
; 1120 : 		return (*this);

  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@erase:

; 1121 : 		}

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 518  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1515 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1516 : 		size_type _Num = this->_Alval.max_size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 18	 add	 ecx, 24			; 00000018H
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size
  00017	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

  0001a	83 7d f8 01	 cmp	 DWORD PTR __Num$[ebp], 1
  0001e	77 09		 ja	 SHORT $LN3@max_size
  00020	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  00027	eb 09		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  0002c	83 e8 01	 sub	 eax, 1
  0002f	89 45 b4	 mov	 DWORD PTR tv73[ebp], eax
$LN4@max_size:
  00032	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]

; 1518 : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv184 = -96						; size = 4
tv183 = -96						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 50	 sub	 esp, 80			; 00000050H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  0002f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00032	83 c8 0f	 or	 eax, 15			; 0000000fH
  00035	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1920 : 		if (max_size() < _Newres)

  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00040	3b 45 e8	 cmp	 eax, DWORD PTR __Newres$[ebp]
  00043	73 08		 jae	 SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

  00045	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00048	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax
  0004b	eb 52		 jmp	 SHORT $LN8@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

  0004d	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  00050	33 d2		 xor	 edx, edx
  00052	b9 03 00 00 00	 mov	 ecx, 3
  00057	f7 f1		 div	 ecx
  00059	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0005f	d1 e9		 shr	 ecx, 1
  00061	3b c8		 cmp	 ecx, eax
  00063	77 02		 ja	 SHORT $LN7@Copy
  00065	eb 38		 jmp	 SHORT $LN8@Copy
$LN7@Copy:

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0006d	d1 ee		 shr	 esi, 1
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00077	2b c6		 sub	 eax, esi
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  0007f	77 13		 ja	 SHORT $LN5@Copy

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

  00081	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00087	d1 e9		 shr	 ecx, 1
  00089	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  0008f	89 4d e8	 mov	 DWORD PTR __Newres$[ebp], ecx

; 1927 : 		else

  00092	eb 0b		 jmp	 SHORT $LN8@Copy
$LN5@Copy:

; 1928 : 			_Newres = max_size();	// settle for max_size()

  00094	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0009c	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

  0009f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

  000a6	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  000a9	83 c0 01	 add	 eax, 1
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	83 c1 18	 add	 ecx, 24			; 00000018H
  000b3	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000b8	89 45 a0	 mov	 DWORD PTR tv183[ebp], eax
  000bb	8b 4d a0	 mov	 ecx, DWORD PTR tv183[ebp]
  000be	89 4d e4	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000c1	eb 60		 jmp	 SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL

  000c3	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000c6	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000c9	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1935 : 			_TRY_BEGIN

  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

  000d0	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  000d3	83 c0 01	 add	 eax, 1
  000d6	50		 push	 eax
  000d7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	83 c1 18	 add	 ecx, 24			; 00000018H
  000dd	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000e2	89 45 a0	 mov	 DWORD PTR tv184[ebp], eax
  000e5	8b 4d a0	 mov	 ecx, DWORD PTR tv184[ebp]
  000e8	89 4d e4	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000eb	eb 22		 jmp	 SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

  000ed	6a 00		 push	 0
  000ef	6a 01		 push	 1
  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1939 : 			_RERAISE;

  000f9	6a 00		 push	 0
  000fb	6a 00		 push	 0
  000fd	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1940 : 			_CATCH_END

  00102	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00109	b8 00 00 00 00	 mov	 eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
  0010e	c3		 ret	 0
$LN14@Copy:
  0010f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 1941 : 		_CATCH_END

  00116	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0011d	b8 00 00 00 00	 mov	 eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
  00122	c3		 ret	 0
$LN12@Copy:
  00123	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

  0012a	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  0012e	76 19		 jbe	 SHORT $LN1@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  00130	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00133	50		 push	 eax
  00134	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0013c	50		 push	 eax
  0013d	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Copy:

; 1945 : 		_Tidy(true);

  00149	6a 00		 push	 0
  0014b	6a 01		 push	 1
  0014d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1946 : 		this->_Bx._Ptr = _Ptr;

  00155	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00158	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0015b	89 08		 mov	 DWORD PTR [eax], ecx

; 1947 : 		this->_Myres = _Newres;

  0015d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00160	8b 4d e8	 mov	 ecx, DWORD PTR __Newres$[ebp]
  00163	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1948 : 		_Eos(_Oldlen);

  00166	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00169	50		 push	 eax
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 1949 : 		}

  00172	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00175	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017c	59		 pop	 ecx
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR __Count$[ebp], -1

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T206843 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 33		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	83 7d 08 ff	 cmp	 DWORD PTR __Count$[ebp], -1
  00023	77 15		 ja	 SHORT $LN1@Allocate
  00025	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  00034	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00038	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0003a	6a 00		 push	 0
  0003c	8d 4d b0	 lea	 ecx, DWORD PTR $T206843[ebp]
  0003f	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 45 b0	 lea	 eax, DWORD PTR $T206843[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00052	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
