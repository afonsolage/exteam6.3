; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MoveCommand.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
	DD	010eH
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_iKalimaGateGateIndex DD 058H
	DD	059H
	DD	05aH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	074H
_g_sttKALIMAGATE_LEVEL DD 028H
	DD	082H
	DD	014H
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	015dH
	DD	0137H
	DD	015dH
	DD	015eH
	DD	0190H
	DD	015eH
	DD	0190H
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
	DD	0190H
	DD	0257H
	DD	0190H
	DD	0257H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CMoveCommand@@6B@				; CMoveCommand::`vftable'
PUBLIC	??0CMoveCommand@@QAE@XZ				; CMoveCommand::CMoveCommand
PUBLIC	??_R4CMoveCommand@@6B@				; CMoveCommand::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMoveCommand@@@8			; CMoveCommand `RTTI Type Descriptor'
PUBLIC	??_R3CMoveCommand@@8				; CMoveCommand::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMoveCommand@@8				; CMoveCommand::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMoveCommand@@8			; CMoveCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMoveCommand@@UAEPAXI@Z:PROC		; CMoveCommand::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMoveCommand@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\movecommand.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMoveCommand@@8 DD FLAT:??_R0?AVCMoveCommand@@@8 ; CMoveCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMoveCommand@@8
rdata$r	ENDS
;	COMDAT ??_R2CMoveCommand@@8
rdata$r	SEGMENT
??_R2CMoveCommand@@8 DD FLAT:??_R1A@?0A@EA@CMoveCommand@@8 ; CMoveCommand::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMoveCommand@@8
rdata$r	SEGMENT
??_R3CMoveCommand@@8 DD 00H				; CMoveCommand::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMoveCommand@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMoveCommand@@@8
_DATA	SEGMENT
??_R0?AVCMoveCommand@@@8 DD FLAT:??_7type_info@@6B@	; CMoveCommand `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMoveCommand@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMoveCommand@@6B@
rdata$r	SEGMENT
??_R4CMoveCommand@@6B@ DD 00H				; CMoveCommand::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMoveCommand@@@8
	DD	FLAT:??_R3CMoveCommand@@8
rdata$r	ENDS
;	COMDAT ??_7CMoveCommand@@6B@
CONST	SEGMENT
??_7CMoveCommand@@6B@ DD FLAT:??_R4CMoveCommand@@6B@	; CMoveCommand::`vftable'
	DD	FLAT:??_ECMoveCommand@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMoveCommand@@QAE@XZ PROC				; CMoveCommand::CMoveCommand
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMoveCommand@@6B@

; 22   : 	return;
; 23   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CMoveCommand@@QAE@XZ ENDP				; CMoveCommand::CMoveCommand
_TEXT	ENDS
PUBLIC	??1CMoveCommand@@UAE@XZ				; CMoveCommand::~CMoveCommand
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCMoveCommand@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMoveCommand@@UAEPAXI@Z PROC			; CMoveCommand::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CMoveCommand@@UAE@XZ	; CMoveCommand::~CMoveCommand
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCMoveCommand@@UAEPAXI@Z ENDP			; CMoveCommand::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMoveCommand@@UAE@XZ PROC				; CMoveCommand::~CMoveCommand
; _this$ = ecx

; 26   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMoveCommand@@6B@

; 27   : 	return;
; 28   : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1CMoveCommand@@UAE@XZ ENDP				; CMoveCommand::~CMoveCommand
_TEXT	ENDS
PUBLIC	?Init@CMoveCommand@@QAEXXZ			; CMoveCommand::Init
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$233333 = -8						; size = 4
_this$ = -4						; size = 4
?Init@CMoveCommand@@QAEXXZ PROC				; CMoveCommand::Init
; _this$ = ecx

; 31   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 48	 sub	 esp, 72			; 00000048H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 32   : 	memset(this->m_MoveCommandData, 0, sizeof(this->m_MoveCommandData));

  0004c	68 20 67 00 00	 push	 26400			; 00006720H
  00051	6a 00		 push	 0
  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 04	 add	 eax, 4
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _memset
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : 
; 34   : 	for (int i =0;i<MAX_MOVE_COMMAND;i++)

  00062	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$233333[ebp], 0
  00069	eb 09		 jmp	 SHORT $LN3@Init
$LN2@Init:
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$233333[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 f8	 mov	 DWORD PTR _i$233333[ebp], eax
$LN3@Init:
  00074	83 7d f8 32	 cmp	 DWORD PTR _i$233333[ebp], 50 ; 00000032H
  00078	7d 16		 jge	 SHORT $LN4@Init

; 35   : 	{
; 36   : 		this->m_MoveCommandData[i].Index = -1;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _i$233333[ebp]
  0007d	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	c7 44 01 04 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+4], -1

; 37   : 	}

  0008e	eb db		 jmp	 SHORT $LN2@Init
$LN4@Init:

; 38   : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?Init@CMoveCommand@@QAEXXZ ENDP				; CMoveCommand::Init
_TEXT	ENDS
PUBLIC	??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail?$AA@ ; `string'
PUBLIC	??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CMoveCommand@@QAEHPAD@Z			; CMoveCommand::Load
EXTRN	_fclose:PROC
EXTRN	_strcpy:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail?$AA@
CONST	SEGMENT
??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail?$AA@ DB 'MoveCommand s'
	DB	'cript load fail', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error?$AA@
CONST	SEGMENT
??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error?$AA@ DB 'MoveCom'
	DB	'mand %s File Load Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_counter$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CMoveCommand@@QAEHPAD@Z PROC			; CMoveCommand::Load
; _this$ = ecx

; 41   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  000a6	53		 push	 ebx
  000a7	56		 push	 esi
  000a8	57		 push	 edi
  000a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	int Token;
; 43   : 	int counter;
; 44   : 
; 45   : 	this->Init();

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 46   : 
; 47   : 	SMDFile=fopen(filename, "r");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000b9	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _fopen
  000c2	83 c4 08	 add	 esp, 8
  000c5	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 48   : 
; 49   : 	if ( SMDFile == 0 )

  000ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  000d1	75 18		 jne	 SHORT $LN6@Load

; 50   : 	{
; 51   : 		MsgBox("MoveCommand %s File Load Error", filename);

  000d3	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error?$AA@
  000dc	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000e1	83 c4 08	 add	 esp, 8

; 52   : 		return 0;

  000e4	33 c0		 xor	 eax, eax
  000e6	e9 57 01 00 00	 jmp	 $LN7@Load
$LN6@Load:

; 53   : 	}
; 54   : 
; 55   : 	counter=0;

  000eb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0
$LN5@Load:

; 56   : 
; 57   : 	while ( true )

  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	85 c0		 test	 eax, eax
  000f9	0f 84 30 01 00
	00		 je	 $LN4@Load

; 58   : 	{
; 59   : 		Token=GetToken();

  000ff	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00104	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 60   : 
; 61   : 		if ( Token == 2)

  00107	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0010b	75 05		 jne	 SHORT $LN3@Load

; 62   : 		{
; 63   : 			break;

  0010d	e9 1d 01 00 00	 jmp	 $LN4@Load
$LN3@Load:

; 64   : 		}
; 65   : 		
; 66   : 		
; 67   : 		if ( Token == 1)

  00112	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00116	0f 85 e7 00 00
	00		 jne	 $LN2@Load

; 68   : 		{
; 69   : 			this->m_MoveCommandData[counter].Index = (int)TokenNumber;

  0011c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00122	e8 00 00 00 00	 call	 __ftol2_sse
  00127	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  0012a	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  00130	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00133	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 70   : 
; 71   : 			Token = GetToken();

  00137	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0013c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 72   : 			strcpy(this->m_MoveCommandData[counter].Name, TokenString);

  0013f	68 00 00 00 00	 push	 OFFSET _TokenString
  00144	8b 45 f4	 mov	 eax, DWORD PTR _counter$[ebp]
  00147	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 _strcpy
  0015a	83 c4 08	 add	 esp, 8

; 73   : 
; 74   : 			Token = GetToken();

  0015d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00162	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 75   : 			strcpy(this->m_MoveCommandData[counter].EngName, TokenString);

  00165	68 00 00 00 00	 push	 OFFSET _TokenString
  0016a	8b 45 f4	 mov	 eax, DWORD PTR _counter$[ebp]
  0016d	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	8d 94 01 07 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+263]
  0017d	52		 push	 edx
  0017e	e8 00 00 00 00	 call	 _strcpy
  00183	83 c4 08	 add	 esp, 8

; 76   : 
; 77   : 			Token = GetToken();

  00186	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0018b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 78   : 			this->m_MoveCommandData[counter].NeedZen = (int)TokenNumber;

  0018e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00194	e8 00 00 00 00	 call	 __ftol2_sse
  00199	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  0019c	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  001a2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001a5	89 84 0a 08 02
	00 00		 mov	 DWORD PTR [edx+ecx+520], eax

; 79   : 
; 80   : 			Token = GetToken();

  001ac	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001b1	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 81   : 			this->m_MoveCommandData[counter].NeedLevel = (int)TokenNumber;

  001b4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ba	e8 00 00 00 00	 call	 __ftol2_sse
  001bf	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  001c2	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  001c8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001cb	89 84 0a 0c 02
	00 00		 mov	 DWORD PTR [edx+ecx+524], eax

; 82   : 
; 83   : 			Token = GetToken();

  001d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001d7	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 84   : 			this->m_MoveCommandData[counter].GateNumber = (int)TokenNumber;

  001da	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e0	e8 00 00 00 00	 call	 __ftol2_sse
  001e5	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  001e8	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  001ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f1	89 84 0a 10 02
	00 00		 mov	 DWORD PTR [edx+ecx+528], eax

; 85   : 
; 86   : 			counter++;

  001f8	8b 45 f4	 mov	 eax, DWORD PTR _counter$[ebp]
  001fb	83 c0 01	 add	 eax, 1
  001fe	89 45 f4	 mov	 DWORD PTR _counter$[ebp], eax

; 87   : 		}
; 88   : 		else

  00201	eb 27		 jmp	 SHORT $LN1@Load
$LN2@Load:

; 89   : 		{
; 90   : 			this->Init();

  00203	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00206	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 91   : 			fclose(SMDFile);

  0020b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _fclose
  00216	83 c4 04	 add	 esp, 4

; 92   : 			MsgBox("MoveCommand script load fail");

  00219	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail?$AA@
  0021e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00223	83 c4 04	 add	 esp, 4

; 93   : 			return FALSE;

  00226	33 c0		 xor	 eax, eax
  00228	eb 18		 jmp	 SHORT $LN7@Load
$LN1@Load:

; 94   : 		}
; 95   : 	}

  0022a	e9 c3 fe ff ff	 jmp	 $LN5@Load
$LN4@Load:

; 96   : 	fclose(SMDFile);

  0022f	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 _fclose
  0023a	83 c4 04	 add	 esp, 4

; 97   : 	return TRUE;

  0023d	b8 01 00 00 00	 mov	 eax, 1
$LN7@Load:

; 98   : }

  00242	5f		 pop	 edi
  00243	5e		 pop	 esi
  00244	5b		 pop	 ebx
  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c2 04 00	 ret	 4
?Load@CMoveCommand@@QAEHPAD@Z ENDP			; CMoveCommand::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00250	55		 push	 ebp
  00251	8b ec		 mov	 ebp, esp
  00253	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00259	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0025e	33 c5		 xor	 eax, ebp
  00260	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00263	53		 push	 ebx
  00264	56		 push	 esi
  00265	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00266	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0026d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _fgetc
  00278	83 c4 04	 add	 esp, 4
  0027b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0027e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00282	83 f9 ff	 cmp	 ecx, -1
  00285	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00287	b8 02 00 00 00	 mov	 eax, 2
  0028c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00291	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00293	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00297	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0029a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0029c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002a1	50		 push	 eax
  002a2	e8 00 00 00 00	 call	 _fgetc
  002a7	83 c4 04	 add	 esp, 4
  002aa	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002ad	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  002b1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  002b4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  002b6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002ba	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002bd	74 1c		 je	 SHORT $LN23@GetToken
  002bf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002c3	83 f8 ff	 cmp	 eax, -1
  002c6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  002c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 _fgetc
  002d3	83 c4 04	 add	 esp, 4
  002d6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  002d9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  002db	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 ff	 cmp	 eax, -1
  002e2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  002e4	b8 02 00 00 00	 mov	 eax, 2
  002e9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  002ee	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  002f2	50		 push	 eax
  002f3	e8 00 00 00 00	 call	 _isspace
  002f8	83 c4 04	 add	 esp, 4
  002fb	85 c0		 test	 eax, eax
  002fd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00303	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00307	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0030d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00313	83 e9 22	 sub	 ecx, 34			; 00000022H
  00316	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0031c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00323	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00329	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0032f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00336	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0033d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00347	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0034c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00351	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00356	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00360	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00365	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0036a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0036f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00379	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0037e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00383	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00388	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00392	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00397	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0039c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  003a1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  003ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  003b0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  003b5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  003ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003bf	50		 push	 eax
  003c0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003c4	51		 push	 ecx
  003c5	e8 00 00 00 00	 call	 _ungetc
  003ca	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  003cd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  003d0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  003d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003d8	50		 push	 eax
  003d9	e8 00 00 00 00	 call	 _getc
  003de	83 c4 04	 add	 esp, 4
  003e1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  003e4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  003e8	83 f9 ff	 cmp	 ecx, -1
  003eb	74 36		 je	 SHORT $LN12@GetToken
  003ed	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003f1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  003f4	74 1a		 je	 SHORT $LN11@GetToken
  003f6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 _isdigit
  00400	83 c4 04	 add	 esp, 4
  00403	85 c0		 test	 eax, eax
  00405	75 09		 jne	 SHORT $LN11@GetToken
  00407	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0040b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0040e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00410	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00413	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00416	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00418	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0041b	83 c0 01	 add	 eax, 1
  0041e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00421	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00423	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00429	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 _atof
  00432	83 c4 04	 add	 esp, 4
  00435	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0043b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00445	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0044a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0044f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00454	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0045b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00460	50		 push	 eax
  00461	e8 00 00 00 00	 call	 _getc
  00466	83 c4 04	 add	 esp, 4
  00469	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0046c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00470	83 f9 ff	 cmp	 ecx, -1
  00473	74 1c		 je	 SHORT $LN8@GetToken
  00475	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00479	83 f8 22	 cmp	 eax, 34			; 00000022H
  0047c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0047e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00481	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00484	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00486	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00489	83 c0 01	 add	 eax, 1
  0048c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0048f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00491	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00495	83 f8 22	 cmp	 eax, 34			; 00000022H
  00498	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0049a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0049f	50		 push	 eax
  004a0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004a4	51		 push	 ecx
  004a5	e8 00 00 00 00	 call	 _ungetc
  004aa	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  004ad	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  004b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  004bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004c2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  004c7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  004cc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004d0	50		 push	 eax
  004d1	e8 00 00 00 00	 call	 _isalpha
  004d6	83 c4 04	 add	 esp, 4
  004d9	85 c0		 test	 eax, eax
  004db	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  004e1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  004e8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004eb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  004ee	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  004f0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004f3	83 c0 01	 add	 eax, 1
  004f6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  004f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004fe	50		 push	 eax
  004ff	e8 00 00 00 00	 call	 _getc
  00504	83 c4 04	 add	 esp, 4
  00507	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0050a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0050e	83 f9 ff	 cmp	 ecx, -1
  00511	74 36		 je	 SHORT $LN3@GetToken
  00513	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00517	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0051a	74 1a		 je	 SHORT $LN2@GetToken
  0051c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00520	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00523	74 11		 je	 SHORT $LN2@GetToken
  00525	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00529	50		 push	 eax
  0052a	e8 00 00 00 00	 call	 _isalnum
  0052f	83 c4 04	 add	 esp, 4
  00532	85 c0		 test	 eax, eax
  00534	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00536	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00539	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0053c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0053e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00541	83 c0 01	 add	 eax, 1
  00544	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00547	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00549	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0054e	50		 push	 eax
  0054f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00553	51		 push	 ecx
  00554	e8 00 00 00 00	 call	 _ungetc
  00559	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0055c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0055f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00562	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0056c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00571	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00573	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00575	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0057f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00584	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00586	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00588	5f		 pop	 edi
  00589	5e		 pop	 esi
  0058a	5b		 pop	 ebx
  0058b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0058e	33 cd		 xor	 ecx, ebp
  00590	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00595	8b e5		 mov	 esp, ebp
  00597	5d		 pop	 ebp
  00598	c3		 ret	 0
  00599	8d 49 00	 npad	 3
$LN35@GetToken:
  0059c	00 00 00 00	 DD	 $LN10@GetToken
  005a0	00 00 00 00	 DD	 $LN19@GetToken
  005a4	00 00 00 00	 DD	 $LN17@GetToken
  005a8	00 00 00 00	 DD	 $LN14@GetToken
  005ac	00 00 00 00	 DD	 $LN18@GetToken
  005b0	00 00 00 00	 DD	 $LN16@GetToken
  005b4	00 00 00 00	 DD	 $LN15@GetToken
  005b8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  005bc	00		 DB	 0
  005bd	01		 DB	 1
  005be	07		 DB	 7
  005bf	07		 DB	 7
  005c0	07		 DB	 7
  005c1	07		 DB	 7
  005c2	07		 DB	 7
  005c3	07		 DB	 7
  005c4	07		 DB	 7
  005c5	07		 DB	 7
  005c6	02		 DB	 2
  005c7	03		 DB	 3
  005c8	03		 DB	 3
  005c9	07		 DB	 7
  005ca	03		 DB	 3
  005cb	03		 DB	 3
  005cc	03		 DB	 3
  005cd	03		 DB	 3
  005ce	03		 DB	 3
  005cf	03		 DB	 3
  005d0	03		 DB	 3
  005d1	03		 DB	 3
  005d2	03		 DB	 3
  005d3	03		 DB	 3
  005d4	07		 DB	 7
  005d5	04		 DB	 4
  005d6	07		 DB	 7
  005d7	07		 DB	 7
  005d8	07		 DB	 7
  005d9	07		 DB	 7
  005da	07		 DB	 7
  005db	07		 DB	 7
  005dc	07		 DB	 7
  005dd	07		 DB	 7
  005de	07		 DB	 7
  005df	07		 DB	 7
  005e0	07		 DB	 7
  005e1	07		 DB	 7
  005e2	07		 DB	 7
  005e3	07		 DB	 7
  005e4	07		 DB	 7
  005e5	07		 DB	 7
  005e6	07		 DB	 7
  005e7	07		 DB	 7
  005e8	07		 DB	 7
  005e9	07		 DB	 7
  005ea	07		 DB	 7
  005eb	07		 DB	 7
  005ec	07		 DB	 7
  005ed	07		 DB	 7
  005ee	07		 DB	 7
  005ef	07		 DB	 7
  005f0	07		 DB	 7
  005f1	07		 DB	 7
  005f2	07		 DB	 7
  005f3	07		 DB	 7
  005f4	07		 DB	 7
  005f5	07		 DB	 7
  005f6	07		 DB	 7
  005f7	07		 DB	 7
  005f8	07		 DB	 7
  005f9	07		 DB	 7
  005fa	07		 DB	 7
  005fb	07		 DB	 7
  005fc	07		 DB	 7
  005fd	07		 DB	 7
  005fe	07		 DB	 7
  005ff	07		 DB	 7
  00600	07		 DB	 7
  00601	07		 DB	 7
  00602	07		 DB	 7
  00603	07		 DB	 7
  00604	07		 DB	 7
  00605	07		 DB	 7
  00606	07		 DB	 7
  00607	07		 DB	 7
  00608	07		 DB	 7
  00609	07		 DB	 7
  0060a	07		 DB	 7
  0060b	07		 DB	 7
  0060c	07		 DB	 7
  0060d	07		 DB	 7
  0060e	07		 DB	 7
  0060f	07		 DB	 7
  00610	07		 DB	 7
  00611	07		 DB	 7
  00612	07		 DB	 7
  00613	07		 DB	 7
  00614	07		 DB	 7
  00615	05		 DB	 5
  00616	07		 DB	 7
  00617	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Load@CMoveCommand@@QAEHPADH@Z			; CMoveCommand::Load
EXTRN	??1CWzMemScript@@UAE@XZ:PROC			; CWzMemScript::~CWzMemScript
EXTRN	?GetString@CWzMemScript@@QAEPADXZ:PROC		; CWzMemScript::GetString
EXTRN	?GetNumber@CWzMemScript@@QAEHXZ:PROC		; CWzMemScript::GetNumber
EXTRN	?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ:PROC ; CWzMemScript::GetToken
EXTRN	?SetBuffer@CWzMemScript@@QAEHPADH@Z:PROC	; CWzMemScript::SetBuffer
EXTRN	??0CWzMemScript@@QAE@XZ:PROC			; CWzMemScript::CWzMemScript
EXTRN	___CxxFrameHandler3:PROC
xdata$x	SEGMENT
__unwindtable$?Load@CMoveCommand@@QAEHPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CMoveCommand@@QAEHPADH@Z$0
__ehfuncinfo$?Load@CMoveCommand@@QAEHPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Load@CMoveCommand@@QAEHPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\movecommand.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T233969 = -232						; size = 4
$T233970 = -228						; size = 4
_counter$ = -160					; size = 4
_Token$ = -156						; size = 4
_WzMemScript$ = -152					; size = 132
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Buffer$ = 8						; size = 4
_iSize$ = 12						; size = 4
?Load@CMoveCommand@@QAEHPADH@Z PROC			; CMoveCommand::Load
; _this$ = ecx

; 101  : {

  00620	55		 push	 ebp
  00621	8b ec		 mov	 ebp, esp
  00623	6a ff		 push	 -1
  00625	68 00 00 00 00	 push	 __ehhandler$?Load@CMoveCommand@@QAEHPADH@Z
  0062a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00630	50		 push	 eax
  00631	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00637	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0063c	33 c5		 xor	 eax, ebp
  0063e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00641	53		 push	 ebx
  00642	56		 push	 esi
  00643	57		 push	 edi
  00644	50		 push	 eax
  00645	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00648	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0064e	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 	this->Init();

  00651	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00654	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 103  : 	CWzMemScript WzMemScript;

  00659	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0065f	e8 00 00 00 00	 call	 ??0CWzMemScript@@QAE@XZ	; CWzMemScript::CWzMemScript
  00664	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 104  : 	int Token;
; 105  : 	int counter;
; 106  : 	
; 107  : 	WzMemScript.SetBuffer(Buffer, iSize);

  0066b	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  0066e	50		 push	 eax
  0066f	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00672	51		 push	 ecx
  00673	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00679	e8 00 00 00 00	 call	 ?SetBuffer@CWzMemScript@@QAEHPADH@Z ; CWzMemScript::SetBuffer

; 108  : 
; 109  : 	counter=0;

  0067e	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _counter$[ebp], 0
$LN5@Load@2:

; 110  : 
; 111  : 	while ( true )

  00688	b8 01 00 00 00	 mov	 eax, 1
  0068d	85 c0		 test	 eax, eax
  0068f	0f 84 a4 01 00
	00		 je	 $LN4@Load@2

; 112  : 	{
; 113  : 		Token=WzMemScript.GetToken();

  00695	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0069b	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  006a0	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 114  : 
; 115  : 		if ( Token == 2)

  006a6	83 bd 64 ff ff
	ff 02		 cmp	 DWORD PTR _Token$[ebp], 2
  006ad	75 05		 jne	 SHORT $LN3@Load@2

; 116  : 		{
; 117  : 			break;

  006af	e9 85 01 00 00	 jmp	 $LN4@Load@2
$LN3@Load@2:

; 118  : 		}
; 119  : 		
; 120  : 		
; 121  : 		if ( Token == 1)

  006b4	83 bd 64 ff ff
	ff 01		 cmp	 DWORD PTR _Token$[ebp], 1
  006bb	0f 85 3a 01 00
	00		 jne	 $LN2@Load@2

; 122  : 		{
; 123  : 			this->m_MoveCommandData[counter].Index = WzMemScript.GetNumber();

  006c1	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  006c7	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  006cc	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _counter$[ebp]
  006d2	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  006d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  006db	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 124  : 
; 125  : 			Token = WzMemScript.GetToken();

  006df	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  006e5	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  006ea	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 126  : 			strcpy(this->m_MoveCommandData[counter].Name, WzMemScript.GetString());

  006f0	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  006f6	e8 00 00 00 00	 call	 ?GetString@CWzMemScript@@QAEPADXZ ; CWzMemScript::GetString
  006fb	50		 push	 eax
  006fc	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00702	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00708	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0070b	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0070f	52		 push	 edx
  00710	e8 00 00 00 00	 call	 _strcpy
  00715	83 c4 08	 add	 esp, 8

; 127  : 
; 128  : 			Token = WzMemScript.GetToken();

  00718	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0071e	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  00723	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 129  : 			strcpy(this->m_MoveCommandData[counter].EngName, WzMemScript.GetString());

  00729	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0072f	e8 00 00 00 00	 call	 ?GetString@CWzMemScript@@QAEPADXZ ; CWzMemScript::GetString
  00734	50		 push	 eax
  00735	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  0073b	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00741	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00744	8d 94 01 07 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+263]
  0074b	52		 push	 edx
  0074c	e8 00 00 00 00	 call	 _strcpy
  00751	83 c4 08	 add	 esp, 8

; 130  : 
; 131  : 			Token = WzMemScript.GetToken();

  00754	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0075a	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  0075f	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 132  : 			this->m_MoveCommandData[counter].NeedZen = WzMemScript.GetNumber();

  00765	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0076b	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  00770	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _counter$[ebp]
  00776	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  0077c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0077f	89 84 0a 08 02
	00 00		 mov	 DWORD PTR [edx+ecx+520], eax

; 133  : 
; 134  : 			Token = WzMemScript.GetToken();

  00786	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0078c	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  00791	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 135  : 			this->m_MoveCommandData[counter].NeedLevel = WzMemScript.GetNumber();

  00797	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0079d	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  007a2	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _counter$[ebp]
  007a8	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  007ae	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  007b1	89 84 0a 0c 02
	00 00		 mov	 DWORD PTR [edx+ecx+524], eax

; 136  : 
; 137  : 			Token = WzMemScript.GetToken();

  007b8	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  007be	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken
  007c3	89 85 64 ff ff
	ff		 mov	 DWORD PTR _Token$[ebp], eax

; 138  : 			this->m_MoveCommandData[counter].GateNumber = WzMemScript.GetNumber();

  007c9	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  007cf	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  007d4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _counter$[ebp]
  007da	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  007e0	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  007e3	89 84 0a 10 02
	00 00		 mov	 DWORD PTR [edx+ecx+528], eax

; 139  : 
; 140  : 			counter++;

  007ea	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  007f0	83 c0 01	 add	 eax, 1
  007f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 141  : 		}
; 142  : 		else

  007f9	eb 39		 jmp	 SHORT $LN1@Load@2
$LN2@Load@2:

; 143  : 		{
; 144  : 			this->Init();

  007fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007fe	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 145  : 			MsgBox("MoveCommand script load fail");

  00803	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail?$AA@
  00808	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0080d	83 c4 04	 add	 esp, 4

; 146  : 			return FALSE;

  00810	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T233969[ebp], 0
  0081a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00821	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00827	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  0082c	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T233969[ebp]
  00832	eb 27		 jmp	 SHORT $LN6@Load@2
$LN1@Load@2:

; 147  : 		}
; 148  : 	}

  00834	e9 4f fe ff ff	 jmp	 $LN5@Load@2
$LN4@Load@2:

; 149  : 	return TRUE;

  00839	c7 85 1c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T233970[ebp], 1
  00843	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0084a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00850	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  00855	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR $T233970[ebp]
$LN6@Load@2:

; 150  : }

  0085b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0085e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00865	59		 pop	 ecx
  00866	5f		 pop	 edi
  00867	5e		 pop	 esi
  00868	5b		 pop	 ebx
  00869	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0086c	33 cd		 xor	 ecx, ebp
  0086e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00873	8b e5		 mov	 esp, ebp
  00875	5d		 pop	 ebp
  00876	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Load@CMoveCommand@@QAEHPADH@Z$0:
  00000	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
__ehhandler$?Load@CMoveCommand@@QAEHPADH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CMoveCommand@@QAEHPADH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CMoveCommand@@QAEHPADH@Z ENDP			; CMoveCommand::Load
PUBLIC	??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail?$AA@ ; `string'
PUBLIC	??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error?$AA@ ; `string'
PUBLIC	?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z		; CMoveCommand::LoadMoveLevel
;	COMDAT ??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail?$AA@
CONST	SEGMENT
??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail?$AA@ DB 'MoveLevel scrip'
	DB	't load fail', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error?$AA@
CONST	SEGMENT
??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error?$AA@ DB 'MoveLevel'
	DB	' %s File Load Error', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_counter$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z PROC		; CMoveCommand::LoadMoveLevel
; _this$ = ecx

; 153  : {

  00880	55		 push	 ebp
  00881	8b ec		 mov	 ebp, esp
  00883	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00886	53		 push	 ebx
  00887	56		 push	 esi
  00888	57		 push	 edi
  00889	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	int Token;
; 155  : 	int counter;
; 156  : 
; 157  : 	memset(this->m_MoveLevel, -1, sizeof(this->m_MoveLevel));

  0088c	68 b0 04 00 00	 push	 1200			; 000004b0H
  00891	6a ff		 push	 -1
  00893	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00896	05 24 67 00 00	 add	 eax, 26404		; 00006724H
  0089b	50		 push	 eax
  0089c	e8 00 00 00 00	 call	 _memset
  008a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : 
; 159  : 	SMDFile=fopen(filename, "r");

  008a4	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  008a9	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  008ac	50		 push	 eax
  008ad	e8 00 00 00 00	 call	 _fopen
  008b2	83 c4 08	 add	 esp, 8
  008b5	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 160  : 
; 161  : 	if ( SMDFile == 0 )

  008ba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  008c1	75 18		 jne	 SHORT $LN6@LoadMoveLe

; 162  : 	{
; 163  : 		MsgBox("MoveLevel %s File Load Error", filename);

  008c3	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  008c6	50		 push	 eax
  008c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error?$AA@
  008cc	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  008d1	83 c4 08	 add	 esp, 8

; 164  : 		return 0;

  008d4	33 c0		 xor	 eax, eax
  008d6	e9 45 01 00 00	 jmp	 $LN7@LoadMoveLe
$LN6@LoadMoveLe:

; 165  : 	}
; 166  : 
; 167  : 	counter=0;

  008db	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0
$LN5@LoadMoveLe:

; 168  : 
; 169  : 	while ( true )

  008e2	b8 01 00 00 00	 mov	 eax, 1
  008e7	85 c0		 test	 eax, eax
  008e9	0f 84 1e 01 00
	00		 je	 $LN4@LoadMoveLe

; 170  : 	{
; 171  : 		Token=GetToken();

  008ef	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  008f4	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 172  : 
; 173  : 		if ( Token == 2)

  008f7	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  008fb	75 05		 jne	 SHORT $LN3@LoadMoveLe

; 174  : 		{
; 175  : 			break;

  008fd	e9 0b 01 00 00	 jmp	 $LN4@LoadMoveLe
$LN3@LoadMoveLe:

; 176  : 		}
; 177  : 		
; 178  : 		
; 179  : 		if ( Token == 1)

  00902	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00906	0f 85 d5 00 00
	00		 jne	 $LN2@LoadMoveLe

; 180  : 		{
; 181  : 			this->m_MoveLevel[counter].MoveLevel = (int)TokenNumber;

  0090c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00912	e8 00 00 00 00	 call	 __ftol2_sse
  00917	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  0091a	6b c9 18	 imul	 ecx, 24			; 00000018H
  0091d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00920	89 84 0a 24 67
	00 00		 mov	 DWORD PTR [edx+ecx+26404], eax

; 182  : 
; 183  : 			Token = GetToken();

  00927	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0092c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 184  : 			this->m_MoveLevel[counter].MapNumber = (int)TokenNumber;

  0092f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00935	e8 00 00 00 00	 call	 __ftol2_sse
  0093a	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  0093d	6b c9 18	 imul	 ecx, 24			; 00000018H
  00940	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00943	89 84 0a 28 67
	00 00		 mov	 DWORD PTR [edx+ecx+26408], eax

; 185  : 
; 186  : 			Token = GetToken();

  0094a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0094f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 187  : 			this->m_MoveLevel[counter].X = (int)TokenNumber;

  00952	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00958	e8 00 00 00 00	 call	 __ftol2_sse
  0095d	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  00960	6b c9 18	 imul	 ecx, 24			; 00000018H
  00963	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00966	89 84 0a 2c 67
	00 00		 mov	 DWORD PTR [edx+ecx+26412], eax

; 188  : 
; 189  : 			Token = GetToken();

  0096d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00972	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 190  : 			this->m_MoveLevel[counter].Y = (int)TokenNumber;

  00975	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0097b	e8 00 00 00 00	 call	 __ftol2_sse
  00980	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  00983	6b c9 18	 imul	 ecx, 24			; 00000018H
  00986	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00989	89 84 0a 30 67
	00 00		 mov	 DWORD PTR [edx+ecx+26416], eax

; 191  : 
; 192  : 			Token = GetToken();

  00990	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00995	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 193  : 			this->m_MoveLevel[counter].TX = (int)TokenNumber;

  00998	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0099e	e8 00 00 00 00	 call	 __ftol2_sse
  009a3	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  009a6	6b c9 18	 imul	 ecx, 24			; 00000018H
  009a9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009ac	89 84 0a 34 67
	00 00		 mov	 DWORD PTR [edx+ecx+26420], eax

; 194  : 
; 195  : 			Token = GetToken();

  009b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009b8	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 196  : 			this->m_MoveLevel[counter].TY = (int)TokenNumber;

  009bb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009c1	e8 00 00 00 00	 call	 __ftol2_sse
  009c6	8b 4d f4	 mov	 ecx, DWORD PTR _counter$[ebp]
  009c9	6b c9 18	 imul	 ecx, 24			; 00000018H
  009cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009cf	89 84 0a 38 67
	00 00		 mov	 DWORD PTR [edx+ecx+26424], eax

; 197  : 
; 198  : 			counter++;

  009d6	8b 45 f4	 mov	 eax, DWORD PTR _counter$[ebp]
  009d9	83 c0 01	 add	 eax, 1
  009dc	89 45 f4	 mov	 DWORD PTR _counter$[ebp], eax

; 199  : 		}
; 200  : 		else

  009df	eb 27		 jmp	 SHORT $LN1@LoadMoveLe
$LN2@LoadMoveLe:

; 201  : 		{
; 202  : 			this->Init();

  009e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009e4	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 203  : 			fclose(SMDFile);

  009e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  009ee	50		 push	 eax
  009ef	e8 00 00 00 00	 call	 _fclose
  009f4	83 c4 04	 add	 esp, 4

; 204  : 			MsgBox("MoveLevel script load fail");

  009f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail?$AA@
  009fc	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00a01	83 c4 04	 add	 esp, 4

; 205  : 			return FALSE;

  00a04	33 c0		 xor	 eax, eax
  00a06	eb 18		 jmp	 SHORT $LN7@LoadMoveLe
$LN1@LoadMoveLe:

; 206  : 		}
; 207  : 	}

  00a08	e9 d5 fe ff ff	 jmp	 $LN5@LoadMoveLe
$LN4@LoadMoveLe:

; 208  : 	fclose(SMDFile);

  00a0d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00a12	50		 push	 eax
  00a13	e8 00 00 00 00	 call	 _fclose
  00a18	83 c4 04	 add	 esp, 4

; 209  : 	return TRUE;

  00a1b	b8 01 00 00 00	 mov	 eax, 1
$LN7@LoadMoveLe:

; 210  : }

  00a20	5f		 pop	 edi
  00a21	5e		 pop	 esi
  00a22	5b		 pop	 ebx
  00a23	8b e5		 mov	 esp, ebp
  00a25	5d		 pop	 ebp
  00a26	c2 04 00	 ret	 4
?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z ENDP		; CMoveCommand::LoadMoveLevel
_TEXT	ENDS
PUBLIC	?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z		; CMoveCommand::GetMoveLevel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$233401 = -8						; size = 4
_this$ = -4						; size = 4
_mapnumber$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_Class$ = 20						; size = 4
?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z PROC		; CMoveCommand::GetMoveLevel
; _this$ = ecx

; 213  : {

  00a30	55		 push	 ebp
  00a31	8b ec		 mov	 ebp, esp
  00a33	83 ec 48	 sub	 esp, 72			; 00000048H
  00a36	53		 push	 ebx
  00a37	56		 push	 esi
  00a38	57		 push	 edi
  00a39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	for( int i=0;i<MAX_MOVE_COMMAND;i++)

  00a3c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$233401[ebp], 0
  00a43	eb 09		 jmp	 SHORT $LN9@GetMoveLev
$LN8@GetMoveLev:
  00a45	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00a48	83 c0 01	 add	 eax, 1
  00a4b	89 45 f8	 mov	 DWORD PTR _i$233401[ebp], eax
$LN9@GetMoveLev:
  00a4e	83 7d f8 32	 cmp	 DWORD PTR _i$233401[ebp], 50 ; 00000032H
  00a52	0f 8d da 00 00
	00		 jge	 $LN7@GetMoveLev

; 215  : 	{
; 216  : 		if ( this->m_MoveLevel[i].MapNumber == mapnumber )

  00a58	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00a5b	6b c0 18	 imul	 eax, 24			; 00000018H
  00a5e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a61	8b 94 01 28 67
	00 00		 mov	 edx, DWORD PTR [ecx+eax+26408]
  00a68	3b 55 08	 cmp	 edx, DWORD PTR _mapnumber$[ebp]
  00a6b	0f 85 bc 00 00
	00		 jne	 $LN6@GetMoveLev

; 217  : 		{
; 218  : 			if ( x >= this->m_MoveLevel[i].X && x <= this->m_MoveLevel[i].TX && y >= this->m_MoveLevel[i].Y && y <= this->m_MoveLevel[i].TY )

  00a71	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00a74	6b c0 18	 imul	 eax, 24			; 00000018H
  00a77	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a7a	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00a7d	3b 94 01 2c 67
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+26412]
  00a84	0f 8c a3 00 00
	00		 jl	 $LN6@GetMoveLev
  00a8a	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00a8d	6b c0 18	 imul	 eax, 24			; 00000018H
  00a90	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a93	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00a96	3b 94 01 34 67
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+26420]
  00a9d	0f 8f 8a 00 00
	00		 jg	 $LN6@GetMoveLev
  00aa3	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00aa6	6b c0 18	 imul	 eax, 24			; 00000018H
  00aa9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aac	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00aaf	3b 94 01 30 67
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+26416]
  00ab6	7c 75		 jl	 SHORT $LN6@GetMoveLev
  00ab8	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00abb	6b c0 18	 imul	 eax, 24			; 00000018H
  00abe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac1	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00ac4	3b 94 01 38 67
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+26424]
  00acb	7f 60		 jg	 SHORT $LN6@GetMoveLev

; 219  : 			{
; 220  : 				if(mapnumber == MAP_INDEX_SWAMPOFCALMNESS)

  00acd	83 7d 08 38	 cmp	 DWORD PTR _mapnumber$[ebp], 56 ; 00000038H
  00ad1	75 12		 jne	 SHORT $LN4@GetMoveLev

; 221  : 				{
; 222  : 					return this->m_MoveLevel[i].MoveLevel;

  00ad3	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00ad6	6b c0 18	 imul	 eax, 24			; 00000018H
  00ad9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00adc	8b 84 01 24 67
	00 00		 mov	 eax, DWORD PTR [ecx+eax+26404]
  00ae3	eb 50		 jmp	 SHORT $LN10@GetMoveLev
$LN4@GetMoveLev:

; 223  : 				}
; 224  : 
; 225  : 				if ( Class == CLASS_DARKLORD || Class == CLASS_MAGUMSA 
; 226  : #ifdef MONK
; 227  : 					|| Class == CLASS_MONK
; 228  : #endif
; 229  : 					|| Class == CLASS_SUMMONER )

  00ae5	83 7d 14 04	 cmp	 DWORD PTR _Class$[ebp], 4
  00ae9	74 12		 je	 SHORT $LN2@GetMoveLev
  00aeb	83 7d 14 03	 cmp	 DWORD PTR _Class$[ebp], 3
  00aef	74 0c		 je	 SHORT $LN2@GetMoveLev
  00af1	83 7d 14 06	 cmp	 DWORD PTR _Class$[ebp], 6
  00af5	74 06		 je	 SHORT $LN2@GetMoveLev
  00af7	83 7d 14 05	 cmp	 DWORD PTR _Class$[ebp], 5
  00afb	75 1e		 jne	 SHORT $LN3@GetMoveLev
$LN2@GetMoveLev:

; 230  : 				{
; 231  : 					return this->m_MoveLevel[i].MoveLevel * 2 / 3;

  00afd	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00b00	6b c0 18	 imul	 eax, 24			; 00000018H
  00b03	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b06	8b 84 01 24 67
	00 00		 mov	 eax, DWORD PTR [ecx+eax+26404]
  00b0d	d1 e0		 shl	 eax, 1
  00b0f	99		 cdq
  00b10	b9 03 00 00 00	 mov	 ecx, 3
  00b15	f7 f9		 idiv	 ecx
  00b17	eb 1c		 jmp	 SHORT $LN10@GetMoveLev

; 232  : 				}
; 233  : 				else

  00b19	eb 12		 jmp	 SHORT $LN6@GetMoveLev
$LN3@GetMoveLev:

; 234  : 				{
; 235  : 					return this->m_MoveLevel[i].MoveLevel;

  00b1b	8b 45 f8	 mov	 eax, DWORD PTR _i$233401[ebp]
  00b1e	6b c0 18	 imul	 eax, 24			; 00000018H
  00b21	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b24	8b 84 01 24 67
	00 00		 mov	 eax, DWORD PTR [ecx+eax+26404]
  00b2b	eb 08		 jmp	 SHORT $LN10@GetMoveLev
$LN6@GetMoveLev:

; 236  : 				}
; 237  : 			}
; 238  : 		}
; 239  : 	}

  00b2d	e9 13 ff ff ff	 jmp	 $LN8@GetMoveLev
$LN7@GetMoveLev:

; 240  : 
; 241  : 	return -1;

  00b32	83 c8 ff	 or	 eax, -1
$LN10@GetMoveLev:

; 242  : }

  00b35	5f		 pop	 edi
  00b36	5e		 pop	 esi
  00b37	5b		 pop	 ebx
  00b38	8b e5		 mov	 esp, ebp
  00b3a	5d		 pop	 ebp
  00b3b	c2 10 00	 ret	 16			; 00000010H
?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z ENDP		; CMoveCommand::GetMoveLevel
_TEXT	ENDS
PUBLIC	?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove
EXTRN	?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z:PROC ; CIllusionTempleEvent::CheckTeleport
EXTRN	?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTempleEvent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv132 = -76						; size = 4
tv87 = -76						; size = 4
tv74 = -76						; size = 4
tv154 = -72						; size = 4
tv142 = -72						; size = 4
tv133 = -72						; size = 4
tv88 = -72						; size = 4
tv75 = -72						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CMoveCommand::CheckMainToMove
; _this$ = ecx

; 245  : {

  00b40	55		 push	 ebp
  00b41	8b ec		 mov	 ebp, esp
  00b43	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00b46	53		 push	 ebx
  00b47	56		 push	 esi
  00b48	57		 push	 edi
  00b49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 246  : 	if ( BC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00b4c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4f	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00b56	83 f9 34	 cmp	 ecx, 52			; 00000034H
  00b59	75 09		 jne	 SHORT $LN12@CheckMainT
  00b5b	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00b62	eb 33		 jmp	 SHORT $LN13@CheckMainT
$LN12@CheckMainT:
  00b64	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b67	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00b6e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00b71	7d 09		 jge	 SHORT $LN10@CheckMainT
  00b73	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00b7a	eb 15		 jmp	 SHORT $LN11@CheckMainT
$LN10@CheckMainT:
  00b7c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b7f	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  00b86	33 c0		 xor	 eax, eax
  00b88	83 fa 11	 cmp	 edx, 17			; 00000011H
  00b8b	0f 9e c0	 setle	 al
  00b8e	89 45 b4	 mov	 DWORD PTR tv74[ebp], eax
$LN11@CheckMainT:
  00b91	8b 4d b4	 mov	 ecx, DWORD PTR tv74[ebp]
  00b94	89 4d b8	 mov	 DWORD PTR tv75[ebp], ecx
$LN13@CheckMainT:
  00b97	83 7d b8 00	 cmp	 DWORD PTR tv75[ebp], 0
  00b9b	74 07		 je	 SHORT $LN7@CheckMainT

; 247  : 	{
; 248  : 		return FALSE;

  00b9d	33 c0		 xor	 eax, eax
  00b9f	e9 4a 01 00 00	 jmp	 $LN8@CheckMainT
$LN7@CheckMainT:

; 249  : 	}
; 250  : 
; 251  : 	if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00ba4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ba7	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00bae	83 f9 35	 cmp	 ecx, 53			; 00000035H
  00bb1	75 09		 jne	 SHORT $LN16@CheckMainT
  00bb3	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00bba	eb 33		 jmp	 SHORT $LN17@CheckMainT
$LN16@CheckMainT:
  00bbc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bbf	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00bc6	83 f8 12	 cmp	 eax, 18			; 00000012H
  00bc9	7d 09		 jge	 SHORT $LN14@CheckMainT
  00bcb	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  00bd2	eb 15		 jmp	 SHORT $LN15@CheckMainT
$LN14@CheckMainT:
  00bd4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bd7	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  00bde	33 c0		 xor	 eax, eax
  00be0	83 fa 17	 cmp	 edx, 23			; 00000017H
  00be3	0f 9e c0	 setle	 al
  00be6	89 45 b4	 mov	 DWORD PTR tv87[ebp], eax
$LN15@CheckMainT:
  00be9	8b 4d b4	 mov	 ecx, DWORD PTR tv87[ebp]
  00bec	89 4d b8	 mov	 DWORD PTR tv88[ebp], ecx
$LN17@CheckMainT:
  00bef	83 7d b8 00	 cmp	 DWORD PTR tv88[ebp], 0
  00bf3	74 07		 je	 SHORT $LN6@CheckMainT

; 252  : 	{
; 253  : 		return FALSE;

  00bf5	33 c0		 xor	 eax, eax
  00bf7	e9 f2 00 00 00	 jmp	 $LN8@CheckMainT
$LN6@CheckMainT:

; 254  : 	}
; 255  : 
; 256  : 	if ( KALIMA_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00bfc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bff	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00c06	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00c09	7d 09		 jge	 SHORT $LN20@CheckMainT
  00c0b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  00c12	eb 33		 jmp	 SHORT $LN21@CheckMainT
$LN20@CheckMainT:
  00c14	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c17	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00c1e	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00c21	7e 17		 jle	 SHORT $LN18@CheckMainT
  00c23	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c26	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  00c2d	33 c0		 xor	 eax, eax
  00c2f	83 fa 24	 cmp	 edx, 36			; 00000024H
  00c32	0f 94 c0	 sete	 al
  00c35	89 45 b4	 mov	 DWORD PTR tv132[ebp], eax
  00c38	eb 07		 jmp	 SHORT $LN19@CheckMainT
$LN18@CheckMainT:
  00c3a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv132[ebp], 1
$LN19@CheckMainT:
  00c41	8b 4d b4	 mov	 ecx, DWORD PTR tv132[ebp]
  00c44	89 4d b8	 mov	 DWORD PTR tv133[ebp], ecx
$LN21@CheckMainT:
  00c47	83 7d b8 00	 cmp	 DWORD PTR tv133[ebp], 0
  00c4b	74 07		 je	 SHORT $LN5@CheckMainT

; 257  : 	{
; 258  : 		return FALSE;

  00c4d	33 c0		 xor	 eax, eax
  00c4f	e9 9a 00 00 00	 jmp	 $LN8@CheckMainT
$LN5@CheckMainT:

; 259  : 	}
; 260  : 
; 261  : 	if ( DS_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00c54	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c57	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00c5e	83 f9 09	 cmp	 ecx, 9
  00c61	75 09		 jne	 SHORT $LN22@CheckMainT
  00c63	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
  00c6a	eb 15		 jmp	 SHORT $LN23@CheckMainT
$LN22@CheckMainT:
  00c6c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c6f	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00c76	33 c9		 xor	 ecx, ecx
  00c78	83 f8 20	 cmp	 eax, 32			; 00000020H
  00c7b	0f 94 c1	 sete	 cl
  00c7e	89 4d b8	 mov	 DWORD PTR tv142[ebp], ecx
$LN23@CheckMainT:
  00c81	83 7d b8 00	 cmp	 DWORD PTR tv142[ebp], 0
  00c85	74 04		 je	 SHORT $LN4@CheckMainT

; 262  : 	{
; 263  : 		return FALSE;

  00c87	33 c0		 xor	 eax, eax
  00c89	eb 63		 jmp	 SHORT $LN8@CheckMainT
$LN4@CheckMainT:

; 264  : 	}
; 265  : 
; 266  : //#if(GS_CASTLE==0)
; 267  : 	if ( lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS )

  00c8b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c8e	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00c95	83 f9 27	 cmp	 ecx, 39			; 00000027H
  00c98	75 04		 jne	 SHORT $LN3@CheckMainT

; 268  : 	{
; 269  : 		return FALSE;

  00c9a	33 c0		 xor	 eax, eax
  00c9c	eb 50		 jmp	 SHORT $LN8@CheckMainT
$LN3@CheckMainT:

; 270  : 	}
; 271  : //#endif
; 272  : 
; 273  : 	if ( IT_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00c9e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ca1	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00ca8	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00cab	7d 09		 jge	 SHORT $LN24@CheckMainT
  00cad	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
  00cb4	eb 15		 jmp	 SHORT $LN25@CheckMainT
$LN24@CheckMainT:
  00cb6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cb9	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00cc0	33 c9		 xor	 ecx, ecx
  00cc2	83 f8 32	 cmp	 eax, 50			; 00000032H
  00cc5	0f 9e c1	 setle	 cl
  00cc8	89 4d b8	 mov	 DWORD PTR tv154[ebp], ecx
$LN25@CheckMainT:
  00ccb	83 7d b8 00	 cmp	 DWORD PTR tv154[ebp], 0
  00ccf	74 18		 je	 SHORT $LN2@CheckMainT

; 274  : 	{
; 275  : 		if(g_IllusionTempleEvent.CheckTeleport(lpObj->m_Index) != FALSE)

  00cd1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cd4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cd6	51		 push	 ecx
  00cd7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00cdc	e8 00 00 00 00	 call	 ?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckTeleport
  00ce1	85 c0		 test	 eax, eax
  00ce3	74 04		 je	 SHORT $LN2@CheckMainT

; 276  : 		{
; 277  : 			return FALSE;

  00ce5	33 c0		 xor	 eax, eax
  00ce7	eb 05		 jmp	 SHORT $LN8@CheckMainT
$LN2@CheckMainT:

; 278  : 		}
; 279  : 	}
; 280  : 
; 281  : 	return TRUE;

  00ce9	b8 01 00 00 00	 mov	 eax, 1
$LN8@CheckMainT:

; 282  : }

  00cee	5f		 pop	 edi
  00cef	5e		 pop	 esi
  00cf0	5b		 pop	 ebx
  00cf1	8b e5		 mov	 esp, ebp
  00cf3	5d		 pop	 ebp
  00cf4	c2 04 00	 ret	 4
?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CMoveCommand::CheckMainToMove
_TEXT	ENDS
PUBLIC	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?GCRecallMonLife@@YAXHHH@Z:PROC			; GCRecallMonLife
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv258 = -72						; size = 4
tv245 = -72						; size = 4
tv232 = -72						; size = 4
tv219 = -72						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iTargetMapNumber$ = 12					; size = 4
?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z PROC ; CMoveCommand::CheckEquipmentToMove
; _this$ = ecx

; 285  : {

  00d00	55		 push	 ebp
  00d01	8b ec		 mov	 ebp, esp
  00d03	83 ec 48	 sub	 esp, 72			; 00000048H
  00d06	53		 push	 ebx
  00d07	56		 push	 esi
  00d08	57		 push	 edi
  00d09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 	if ( iTargetMapNumber == MAP_INDEX_ATHLANSE )

  00d0c	83 7d 0c 07	 cmp	 DWORD PTR _iTargetMapNumber$[ebp], 7
  00d10	75 56		 jne	 SHORT $LN9@CheckEquip

; 287  : 	{
; 288  : 		if ( lpObj->pInventory[8].IsItem() != FALSE )

  00d12	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d15	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00d1b	81 c1 a0 06 00
	00		 add	 ecx, 1696		; 000006a0H
  00d21	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00d26	85 c0		 test	 eax, eax
  00d28	74 3e		 je	 SHORT $LN9@CheckEquip

; 289  : 		{
; 290  : 			if ( lpObj->pInventory[8].m_Type == ITEMGET(13,2) )

  00d2a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d2d	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00d33	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00d3a	81 fa 02 1a 00
	00		 cmp	 edx, 6658		; 00001a02H
  00d40	75 07		 jne	 SHORT $LN7@CheckEquip

; 291  : 			{
; 292  : 				return FALSE;

  00d42	33 c0		 xor	 eax, eax
  00d44	e9 22 04 00 00	 jmp	 $LN10@CheckEquip
$LN7@CheckEquip:

; 293  : 			}
; 294  : 
; 295  : 			if ( lpObj->pInventory[8].m_Type == ITEMGET(13,3) )

  00d49	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d4c	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00d52	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00d59	81 fa 03 1a 00
	00		 cmp	 edx, 6659		; 00001a03H
  00d5f	75 07		 jne	 SHORT $LN9@CheckEquip

; 296  : 			{
; 297  : 				return FALSE;

  00d61	33 c0		 xor	 eax, eax
  00d63	e9 03 04 00 00	 jmp	 $LN10@CheckEquip
$LN9@CheckEquip:

; 298  : 			}
; 299  : 		}
; 300  : 	}
; 301  : 
; 302  : 	if ( iTargetMapNumber == MAP_INDEX_ICARUS )

  00d68	83 7d 0c 0a	 cmp	 DWORD PTR _iTargetMapNumber$[ebp], 10 ; 0000000aH
  00d6c	0f 85 f4 03 00
	00		 jne	 $LN5@CheckEquip

; 303  : 	{
; 304  : 		if ( (lpObj->pInventory[8].m_Type != ITEMGET(13,3) &&
; 305  : 			 lpObj->pInventory[7].m_Type != ITEMGET(13,30) &&
; 306  : 			 lpObj->pInventory[8].m_Type != ITEMGET(13,37) &&
; 307  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,36) &&//Season 4.5 addon
; 308  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,37) &&//Season 4.5 addon
; 309  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,38) &&//Season 4.5 addon
; 310  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,39) &&//Season 4.5 addon
; 311  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,40) &&//Season 4.5 addon
; 312  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,41) &&//Season 4.5 addon
; 313  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,42) &&//Season 4.5 addon
; 314  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12,43) &&//Season 4.5 addon
; 315  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 49) &&//Season 6 addon
; 316  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 50) &&//Season 6 addon
; 317  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 130) &&//Season 6 addon
; 318  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 131) &&//Season 6 addon
; 319  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 132) &&//Season 6 addon
; 320  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 133) &&//Season 6 addon
; 321  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 134) &&//Season 6 addon
; 322  : 			 lpObj->pInventory[7].m_Type != ITEMGET(12, 135) &&//Season 6 addon
; 323  : #ifdef NEWWINGS_2_5
; 324  : 			 !IS_NEWWINGS_2_5(lpObj->pInventory[7].m_Type) &&
; 325  : #endif
; 326  : #ifdef NEWWINGS_4
; 327  : 			 !IS_NEWWINGS_4(lpObj->pInventory[7].m_Type) &&
; 328  : #endif
; 329  : #ifdef NEWWINGS_5
; 330  : 			 !IS_NEWWINGS_5(lpObj->pInventory[7].m_Type) &&
; 331  : #endif
; 332  : #ifdef NEWWINGS_6
; 333  : 			 !IS_NEWWINGS_6(lpObj->pInventory[7].m_Type) &&
; 334  : #endif
; 335  : 			 lpObj->pInventory[8].m_Type != ITEMGET(13,4) &&//Season 4.5 addon
; 336  : 			 (lpObj->pInventory[7].m_Type < ITEMGET(12,0) || lpObj->pInventory[7].m_Type > ITEMGET(12,6)) ) ||
; 337  : 			 lpObj->pInventory[8].m_Type == ITEMGET(13,2) ||
; 338  : 			 lpObj->pInventory[11].m_Type == ITEMGET(13,10) ||
; 339  : 			 lpObj->pInventory[10].m_Type == ITEMGET(13,10)  )

  00d72	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d75	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00d7b	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00d82	81 fa 03 1a 00
	00		 cmp	 edx, 6659		; 00001a03H
  00d88	0f 84 60 03 00
	00		 je	 $LN2@CheckEquip
  00d8e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d91	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00d97	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00d9e	81 fa 1e 1a 00
	00		 cmp	 edx, 6686		; 00001a1eH
  00da4	0f 84 44 03 00
	00		 je	 $LN2@CheckEquip
  00daa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dad	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00db3	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  00dba	81 fa 25 1a 00
	00		 cmp	 edx, 6693		; 00001a25H
  00dc0	0f 84 28 03 00
	00		 je	 $LN2@CheckEquip
  00dc6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dc9	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00dcf	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00dd6	81 fa 24 18 00
	00		 cmp	 edx, 6180		; 00001824H
  00ddc	0f 84 0c 03 00
	00		 je	 $LN2@CheckEquip
  00de2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de5	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00deb	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00df2	81 fa 25 18 00
	00		 cmp	 edx, 6181		; 00001825H
  00df8	0f 84 f0 02 00
	00		 je	 $LN2@CheckEquip
  00dfe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e01	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e07	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00e0e	81 fa 26 18 00
	00		 cmp	 edx, 6182		; 00001826H
  00e14	0f 84 d4 02 00
	00		 je	 $LN2@CheckEquip
  00e1a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e1d	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e23	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00e2a	81 fa 27 18 00
	00		 cmp	 edx, 6183		; 00001827H
  00e30	0f 84 b8 02 00
	00		 je	 $LN2@CheckEquip
  00e36	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e39	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e3f	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00e46	81 fa 28 18 00
	00		 cmp	 edx, 6184		; 00001828H
  00e4c	0f 84 9c 02 00
	00		 je	 $LN2@CheckEquip
  00e52	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e55	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e5b	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00e62	81 fa 29 18 00
	00		 cmp	 edx, 6185		; 00001829H
  00e68	0f 84 80 02 00
	00		 je	 $LN2@CheckEquip
  00e6e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e71	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e77	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00e7e	81 fa 2a 18 00
	00		 cmp	 edx, 6186		; 0000182aH
  00e84	0f 84 64 02 00
	00		 je	 $LN2@CheckEquip
  00e8a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e8d	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00e93	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00e9a	81 fa 2b 18 00
	00		 cmp	 edx, 6187		; 0000182bH
  00ea0	0f 84 48 02 00
	00		 je	 $LN2@CheckEquip
  00ea6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ea9	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00eaf	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00eb6	81 fa 31 18 00
	00		 cmp	 edx, 6193		; 00001831H
  00ebc	0f 84 2c 02 00
	00		 je	 $LN2@CheckEquip
  00ec2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ec5	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00ecb	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00ed2	81 fa 32 18 00
	00		 cmp	 edx, 6194		; 00001832H
  00ed8	0f 84 10 02 00
	00		 je	 $LN2@CheckEquip
  00ede	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ee1	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00ee7	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00eee	81 fa 82 18 00
	00		 cmp	 edx, 6274		; 00001882H
  00ef4	0f 84 f4 01 00
	00		 je	 $LN2@CheckEquip
  00efa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00efd	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f03	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00f0a	81 fa 83 18 00
	00		 cmp	 edx, 6275		; 00001883H
  00f10	0f 84 d8 01 00
	00		 je	 $LN2@CheckEquip
  00f16	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f19	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f1f	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00f26	81 fa 84 18 00
	00		 cmp	 edx, 6276		; 00001884H
  00f2c	0f 84 bc 01 00
	00		 je	 $LN2@CheckEquip
  00f32	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f35	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f3b	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00f42	81 fa 85 18 00
	00		 cmp	 edx, 6277		; 00001885H
  00f48	0f 84 a0 01 00
	00		 je	 $LN2@CheckEquip
  00f4e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f51	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f57	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00f5e	81 fa 86 18 00
	00		 cmp	 edx, 6278		; 00001886H
  00f64	0f 84 84 01 00
	00		 je	 $LN2@CheckEquip
  00f6a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f6d	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f73	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00f7a	81 fa 87 18 00
	00		 cmp	 edx, 6279		; 00001887H
  00f80	0f 84 68 01 00
	00		 je	 $LN2@CheckEquip
  00f86	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f89	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00f8f	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00f96	81 fa ba 18 00
	00		 cmp	 edx, 6330		; 000018baH
  00f9c	7d 09		 jge	 SHORT $LN12@CheckEquip
  00f9e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv219[ebp], 0
  00fa5	eb 1e		 jmp	 SHORT $LN13@CheckEquip
$LN12@CheckEquip:
  00fa7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00faa	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00fb0	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00fb7	33 c0		 xor	 eax, eax
  00fb9	81 fa bc 18 00
	00		 cmp	 edx, 6332		; 000018bcH
  00fbf	0f 9e c0	 setle	 al
  00fc2	89 45 b8	 mov	 DWORD PTR tv219[ebp], eax
$LN13@CheckEquip:
  00fc5	83 7d b8 00	 cmp	 DWORD PTR tv219[ebp], 0
  00fc9	0f 85 1f 01 00
	00		 jne	 $LN2@CheckEquip
  00fcf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fd2	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00fd8	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  00fdf	81 fa b4 18 00
	00		 cmp	 edx, 6324		; 000018b4H
  00fe5	7d 09		 jge	 SHORT $LN14@CheckEquip
  00fe7	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv232[ebp], 0
  00fee	eb 1e		 jmp	 SHORT $LN15@CheckEquip
$LN14@CheckEquip:
  00ff0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ff3	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00ff9	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  01000	33 c0		 xor	 eax, eax
  01002	81 fa b9 18 00
	00		 cmp	 edx, 6329		; 000018b9H
  01008	0f 9e c0	 setle	 al
  0100b	89 45 b8	 mov	 DWORD PTR tv232[ebp], eax
$LN15@CheckEquip:
  0100e	83 7d b8 00	 cmp	 DWORD PTR tv232[ebp], 0
  01012	0f 85 d6 00 00
	00		 jne	 $LN2@CheckEquip
  01018	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0101b	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01021	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  01028	81 fa bd 18 00
	00		 cmp	 edx, 6333		; 000018bdH
  0102e	7d 09		 jge	 SHORT $LN16@CheckEquip
  01030	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv245[ebp], 0
  01037	eb 1e		 jmp	 SHORT $LN17@CheckEquip
$LN16@CheckEquip:
  01039	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0103c	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01042	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  01049	33 c0		 xor	 eax, eax
  0104b	81 fa c2 18 00
	00		 cmp	 edx, 6338		; 000018c2H
  01051	0f 9e c0	 setle	 al
  01054	89 45 b8	 mov	 DWORD PTR tv245[ebp], eax
$LN17@CheckEquip:
  01057	83 7d b8 00	 cmp	 DWORD PTR tv245[ebp], 0
  0105b	0f 85 8d 00 00
	00		 jne	 $LN2@CheckEquip
  01061	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01064	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0106a	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  01071	81 fa c3 18 00
	00		 cmp	 edx, 6339		; 000018c3H
  01077	7d 09		 jge	 SHORT $LN18@CheckEquip
  01079	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv258[ebp], 0
  01080	eb 1e		 jmp	 SHORT $LN19@CheckEquip
$LN18@CheckEquip:
  01082	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01085	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0108b	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  01092	33 c0		 xor	 eax, eax
  01094	81 fa dc 18 00
	00		 cmp	 edx, 6364		; 000018dcH
  0109a	0f 9e c0	 setle	 al
  0109d	89 45 b8	 mov	 DWORD PTR tv258[ebp], eax
$LN19@CheckEquip:
  010a0	83 7d b8 00	 cmp	 DWORD PTR tv258[ebp], 0
  010a4	75 48		 jne	 SHORT $LN2@CheckEquip
  010a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010a9	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010af	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  010b6	81 fa 04 1a 00
	00		 cmp	 edx, 6660		; 00001a04H
  010bc	74 30		 je	 SHORT $LN2@CheckEquip
  010be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010c1	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010c7	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  010ce	81 fa 00 18 00
	00		 cmp	 edx, 6144		; 00001800H
  010d4	7c 60		 jl	 SHORT $LN3@CheckEquip
  010d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010d9	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010df	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  010e6	81 fa 06 18 00
	00		 cmp	 edx, 6150		; 00001806H
  010ec	7f 48		 jg	 SHORT $LN3@CheckEquip
$LN2@CheckEquip:
  010ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010f1	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010f7	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  010fe	81 fa 02 1a 00
	00		 cmp	 edx, 6658		; 00001a02H
  01104	74 30		 je	 SHORT $LN3@CheckEquip
  01106	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01109	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0110f	0f bf 91 22 09
	00 00		 movsx	 edx, WORD PTR [ecx+2338]
  01116	81 fa 0a 1a 00
	00		 cmp	 edx, 6666		; 00001a0aH
  0111c	74 18		 je	 SHORT $LN3@CheckEquip
  0111e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01121	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01127	0f bf 91 4e 08
	00 00		 movsx	 edx, WORD PTR [ecx+2126]
  0112e	81 fa 0a 1a 00
	00		 cmp	 edx, 6666		; 00001a0aH
  01134	75 04		 jne	 SHORT $LN4@CheckEquip
$LN3@CheckEquip:

; 340  : 		{
; 341  : 			return FALSE;

  01136	33 c0		 xor	 eax, eax
  01138	eb 31		 jmp	 SHORT $LN10@CheckEquip
$LN4@CheckEquip:

; 342  : 		}
; 343  : 
; 344  : 		if ( lpObj->m_RecallMon >= 0 )

  0113a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0113d	83 b8 50 04 00
	00 00		 cmp	 DWORD PTR [eax+1104], 0
  01144	7c 20		 jl	 SHORT $LN5@CheckEquip

; 345  : 		{
; 346  : 			GCRecallMonLife(lpObj->m_Index, 60, 0);

  01146	6a 00		 push	 0
  01148	6a 3c		 push	 60			; 0000003cH
  0114a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0114d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0114f	51		 push	 ecx
  01150	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  01155	83 c4 0c	 add	 esp, 12			; 0000000cH

; 347  : 			gObjMonsterCallKill(lpObj->m_Index);

  01158	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0115b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0115d	51		 push	 ecx
  0115e	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  01163	83 c4 04	 add	 esp, 4
$LN5@CheckEquip:

; 348  : 		}
; 349  : 	}
; 350  : 
; 351  : 	return TRUE;

  01166	b8 01 00 00 00	 mov	 eax, 1
$LN10@CheckEquip:

; 352  : }

  0116b	5f		 pop	 edi
  0116c	5e		 pop	 esi
  0116d	5b		 pop	 ebx
  0116e	8b e5		 mov	 esp, ebp
  01170	5d		 pop	 ebp
  01171	c2 08 00	 ret	 8
?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP ; CMoveCommand::CheckEquipmentToMove
_TEXT	ENDS
PUBLIC	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CMoveCommand::CheckInterfaceToMove
; _this$ = ecx

; 355  : {

  01180	55		 push	 ebp
  01181	8b ec		 mov	 ebp, esp
  01183	83 ec 44	 sub	 esp, 68			; 00000044H
  01186	53		 push	 ebx
  01187	56		 push	 esi
  01188	57		 push	 edi
  01189	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 356  : 	if ( lpObj->m_IfState.use == 1 )

  0118c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0118f	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  01195	83 e1 03	 and	 ecx, 3
  01198	83 f9 01	 cmp	 ecx, 1
  0119b	75 04		 jne	 SHORT $LN2@CheckInter

; 357  : 	{
; 358  : 		return FALSE;

  0119d	33 c0		 xor	 eax, eax
  0119f	eb 18		 jmp	 SHORT $LN3@CheckInter
$LN2@CheckInter:

; 359  : 	}
; 360  : 
; 361  : 	if ( lpObj->m_bPShopOpen == true )

  011a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011a4	0f b6 88 c4 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3780]
  011ab	83 f9 01	 cmp	 ecx, 1
  011ae	75 04		 jne	 SHORT $LN1@CheckInter

; 362  : 	{
; 363  : 		return FALSE;

  011b0	33 c0		 xor	 eax, eax
  011b2	eb 05		 jmp	 SHORT $LN3@CheckInter
$LN1@CheckInter:

; 364  : 	}
; 365  : 
; 366  : 	return TRUE;

  011b4	b8 01 00 00 00	 mov	 eax, 1
$LN3@CheckInter:

; 367  : }

  011b9	5f		 pop	 edi
  011ba	5e		 pop	 esi
  011bb	5b		 pop	 ebx
  011bc	8b e5		 mov	 esp, ebp
  011be	5d		 pop	 ebp
  011bf	c2 04 00	 ret	 4
?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CMoveCommand::CheckInterfaceToMove
_TEXT	ENDS
PUBLIC	?FindIndex@CMoveCommand@@AAEHPAD@Z		; CMoveCommand::FindIndex
EXTRN	_strcmpi:PROC
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$233462 = -8						; size = 4
_this$ = -4						; size = 4
_mapname$ = 8						; size = 4
?FindIndex@CMoveCommand@@AAEHPAD@Z PROC			; CMoveCommand::FindIndex
; _this$ = ecx

; 370  : {

  011d0	55		 push	 ebp
  011d1	8b ec		 mov	 ebp, esp
  011d3	83 ec 48	 sub	 esp, 72			; 00000048H
  011d6	53		 push	 ebx
  011d7	56		 push	 esi
  011d8	57		 push	 edi
  011d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 371  : 	for ( int i=0;i<MAX_MOVE_COMMAND;i++)

  011dc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$233462[ebp], 0
  011e3	eb 09		 jmp	 SHORT $LN6@FindIndex
$LN5@FindIndex:
  011e5	8b 45 f8	 mov	 eax, DWORD PTR _i$233462[ebp]
  011e8	83 c0 01	 add	 eax, 1
  011eb	89 45 f8	 mov	 DWORD PTR _i$233462[ebp], eax
$LN6@FindIndex:
  011ee	83 7d f8 32	 cmp	 DWORD PTR _i$233462[ebp], 50 ; 00000032H
  011f2	7d 64		 jge	 SHORT $LN4@FindIndex

; 372  : 	{
; 373  : 		if ( this->m_MoveCommandData[i].Index == -1 )

  011f4	8b 45 f8	 mov	 eax, DWORD PTR _i$233462[ebp]
  011f7	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  011fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01200	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  01205	75 05		 jne	 SHORT $LN3@FindIndex

; 374  : 		{
; 375  : 			return -1;

  01207	83 c8 ff	 or	 eax, -1
  0120a	eb 4f		 jmp	 SHORT $LN7@FindIndex
$LN3@FindIndex:

; 376  : 		}
; 377  : 
; 378  : 		if ( strcmp(mapname, this->m_MoveCommandData[i].Name) == 0 || strcmpi(mapname, this->m_MoveCommandData[i].EngName) == 0  )

  0120c	8b 45 f8	 mov	 eax, DWORD PTR _i$233462[ebp]
  0120f	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01215	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01218	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0121c	52		 push	 edx
  0121d	8b 45 08	 mov	 eax, DWORD PTR _mapname$[ebp]
  01220	50		 push	 eax
  01221	e8 00 00 00 00	 call	 _strcmp
  01226	83 c4 08	 add	 esp, 8
  01229	85 c0		 test	 eax, eax
  0122b	74 24		 je	 SHORT $LN1@FindIndex
  0122d	8b 45 f8	 mov	 eax, DWORD PTR _i$233462[ebp]
  01230	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01236	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01239	8d 94 01 07 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+263]
  01240	52		 push	 edx
  01241	8b 45 08	 mov	 eax, DWORD PTR _mapname$[ebp]
  01244	50		 push	 eax
  01245	e8 00 00 00 00	 call	 _strcmpi
  0124a	83 c4 08	 add	 esp, 8
  0124d	85 c0		 test	 eax, eax
  0124f	75 05		 jne	 SHORT $LN2@FindIndex
$LN1@FindIndex:

; 379  : 		{
; 380  : 			return i;

  01251	8b 45 f8	 mov	 eax, DWORD PTR _i$233462[ebp]
  01254	eb 05		 jmp	 SHORT $LN7@FindIndex
$LN2@FindIndex:

; 381  : 		}
; 382  : 	}

  01256	eb 8d		 jmp	 SHORT $LN5@FindIndex
$LN4@FindIndex:

; 383  : 
; 384  : 	return -1;

  01258	83 c8 ff	 or	 eax, -1
$LN7@FindIndex:

; 385  : }

  0125b	5f		 pop	 edi
  0125c	5e		 pop	 esi
  0125d	5b		 pop	 ebx
  0125e	8b e5		 mov	 esp, ebp
  01260	5d		 pop	 ebp
  01261	c2 04 00	 ret	 4
?FindIndex@CMoveCommand@@AAEHPAD@Z ENDP			; CMoveCommand::FindIndex
_TEXT	ENDS
PUBLIC	?CheckMoveMapBound@CMoveCommand@@QAEHH@Z	; CMoveCommand::CheckMoveMapBound
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv64 = -72						; size = 4
_this$ = -4						; size = 4
_iMapIndex$ = 8						; size = 4
?CheckMoveMapBound@CMoveCommand@@QAEHH@Z PROC		; CMoveCommand::CheckMoveMapBound
; _this$ = ecx

; 388  : {

  01270	55		 push	 ebp
  01271	8b ec		 mov	 ebp, esp
  01273	83 ec 48	 sub	 esp, 72			; 00000048H
  01276	53		 push	 ebx
  01277	56		 push	 esi
  01278	57		 push	 edi
  01279	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 389  : 	switch ( iMapIndex )

  0127c	8b 45 08	 mov	 eax, DWORD PTR _iMapIndex$[ebp]
  0127f	89 45 b8	 mov	 DWORD PTR tv64[ebp], eax
  01282	8b 4d b8	 mov	 ecx, DWORD PTR tv64[ebp]
  01285	83 e9 01	 sub	 ecx, 1
  01288	89 4d b8	 mov	 DWORD PTR tv64[ebp], ecx
  0128b	83 7d b8 0f	 cmp	 DWORD PTR tv64[ebp], 15	; 0000000fH
  0128f	77 18		 ja	 SHORT $LN2@CheckMoveM
  01291	8b 55 b8	 mov	 edx, DWORD PTR tv64[ebp]
  01294	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN6@CheckMoveM[edx]
  0129b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN7@CheckMoveM[eax*4]
$LN1@CheckMoveM:

; 390  : 	{
; 391  : 		case 1:
; 392  : 		case 2:
; 393  : 		case 3:
; 394  : 		case 6:
; 395  : 		case 10:
; 396  : 		case 16:
; 397  : 			return TRUE;

  012a2	b8 01 00 00 00	 mov	 eax, 1
  012a7	eb 02		 jmp	 SHORT $LN4@CheckMoveM
$LN2@CheckMoveM:

; 398  : 	}
; 399  : 	
; 400  : 	return FALSE;

  012a9	33 c0		 xor	 eax, eax
$LN4@CheckMoveM:

; 401  : }

  012ab	5f		 pop	 edi
  012ac	5e		 pop	 esi
  012ad	5b		 pop	 ebx
  012ae	8b e5		 mov	 esp, ebp
  012b0	5d		 pop	 ebp
  012b1	c2 04 00	 ret	 4
$LN7@CheckMoveM:
  012b4	00 00 00 00	 DD	 $LN1@CheckMoveM
  012b8	00 00 00 00	 DD	 $LN2@CheckMoveM
$LN6@CheckMoveM:
  012bc	00		 DB	 0
  012bd	00		 DB	 0
  012be	00		 DB	 0
  012bf	01		 DB	 1
  012c0	01		 DB	 1
  012c1	00		 DB	 0
  012c2	01		 DB	 1
  012c3	01		 DB	 1
  012c4	01		 DB	 1
  012c5	00		 DB	 0
  012c6	01		 DB	 1
  012c7	01		 DB	 1
  012c8	01		 DB	 1
  012c9	01		 DB	 1
  012ca	01		 DB	 1
  012cb	00		 DB	 0
?CheckMoveMapBound@CMoveCommand@@QAEHH@Z ENDP		; CMoveCommand::CheckMoveMapBound
_TEXT	ENDS
PUBLIC	??_C@_0CK@DALHCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5GateNu@ ; `string'
PUBLIC	??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5r@ ; `string'
PUBLIC	?GetCastleState@CCastleSiegeSync@@QAEHXZ	; CCastleSiegeSync::GetCastleState
PUBLIC	??_C@_0BG@LEABBGFP@BattleZone?5not?5enable?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@PAD@Z	; CMoveCommand::Move
EXTRN	__imp__wsprintfA:PROC
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?DeleteUserData@CRaklionBattleUserMng@@QAEHH@Z:PROC ; CRaklionBattleUserMng::DeleteUserData
EXTRN	?g_RaklionBattleUserMng@@3VCRaklionBattleUserMng@@A:BYTE ; g_RaklionBattleUserMng
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?PkPenaltyAddNeedZenMapMove@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::PkPenaltyAddNeedZenMapMove
EXTRN	?CheckCastleOwnerUnionMember@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckCastleOwnerUnionMember
EXTRN	?CheckCastleOwnerMember@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckCastleOwnerMember
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?MoveInBattleZonePartySplit@GensSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::MoveInBattleZonePartySplit
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?IsUserBattleZoneEnable@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::IsUserBattleZoneEnable
EXTRN	?IsMoveMapBattleZone@GensSystem@@QAEHH@Z:PROC	; GensSystem::IsMoveMapBattleZone
EXTRN	?gGensSystem@@3VGensSystem@@A:BYTE		; gGensSystem
EXTRN	?gGENS@@3HA:DWORD				; gGENS
;	COMDAT ??_C@_0CK@DALHCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5GateNu@
CONST	SEGMENT
??_C@_0CK@DALHCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5GateNu@ DB '['
	DB	'%s][%s] Use [%s %s] Fail GateNumber = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5r@
CONST	SEGMENT
??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5r@ DB '['
	DB	'%s][%s] Use [%s %s] Success : reduces money %d - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LEABBGFP@BattleZone?5not?5enable?$AA@
CONST	SEGMENT
??_C@_0BG@LEABBGFP@BattleZone?5not?5enable?$AA@ DB 'BattleZone not enable'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv134 = -364						; size = 4
_szTemp$233531 = -296					; size = 256
_GateNumber$ = -40					; size = 4
_NeedZen$ = -36						; size = 4
_NeedLevel$ = -32					; size = 4
_loc6$ = -28						; size = 4
_index$ = -24						; size = 4
_subMoney$ = -20					; size = 4
_overlevel$ = -16					; size = 4
_m_number$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_mapname$ = 12						; size = 4
?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@PAD@Z PROC	; CMoveCommand::Move
; _this$ = ecx

; 404  : {

  012d0	55		 push	 ebp
  012d1	8b ec		 mov	 ebp, esp
  012d3	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  012d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  012de	33 c5		 xor	 eax, ebp
  012e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  012e3	53		 push	 ebx
  012e4	56		 push	 esi
  012e5	57		 push	 edi
  012e6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 405  : 	int m_number = -1;

  012e9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _m_number$[ebp], -1

; 406  : 	int overlevel = 0;

  012f0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _overlevel$[ebp], 0

; 407  : 	int subMoney = 2000;

  012f7	c7 45 ec d0 07
	00 00		 mov	 DWORD PTR _subMoney$[ebp], 2000 ; 000007d0H

; 408  : 
; 409  : 	int index = this->FindIndex(mapname);

  012fe	8b 45 0c	 mov	 eax, DWORD PTR _mapname$[ebp]
  01301	50		 push	 eax
  01302	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01305	e8 00 00 00 00	 call	 ?FindIndex@CMoveCommand@@AAEHPAD@Z ; CMoveCommand::FindIndex
  0130a	89 45 e8	 mov	 DWORD PTR _index$[ebp], eax

; 410  : 
; 411  : #ifdef OLDCASHSHOP
; 412  : 	if ( g_bUseMoveMapBound == TRUE )
; 413  : 	{
; 414  : 		if ( g_CashItemPeriodSystem.CheckHaveItemPeriodSealEffect(lpObj) == FALSE )
; 415  : 		{
; 416  : 			if ( !this->CheckMoveMapBound(index))
; 417  : 			{
; 418  : 				return FALSE;
; 419  : 			}
; 420  : 		}
; 421  : 	}
; 422  : #endif
; 423  : 
; 424  : 	int loc6 = this->m_MoveCommandData[index].Index; //season 3.0 add-on

  0130d	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  01310	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01316	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01319	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0131d	89 55 e4	 mov	 DWORD PTR _loc6$[ebp], edx

; 425  : 
; 426  : 	if(gGENS)

  01320	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  01327	74 49		 je	 SHORT $LN22@Move

; 427  : 	{
; 428  : 		if( gGensSystem.IsMoveMapBattleZone(loc6) )

  01329	8b 45 e4	 mov	 eax, DWORD PTR _loc6$[ebp]
  0132c	50		 push	 eax
  0132d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  01332	e8 00 00 00 00	 call	 ?IsMoveMapBattleZone@GensSystem@@QAEHH@Z ; GensSystem::IsMoveMapBattleZone
  01337	85 c0		 test	 eax, eax
  01339	74 37		 je	 SHORT $LN22@Move

; 429  : 		{
; 430  : 			if( !gGensSystem.IsUserBattleZoneEnable(lpObj) )

  0133b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0133e	50		 push	 eax
  0133f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  01344	e8 00 00 00 00	 call	 ?IsUserBattleZoneEnable@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::IsUserBattleZoneEnable
  01349	85 c0		 test	 eax, eax
  0134b	75 17		 jne	 SHORT $LN20@Move

; 431  : 			{
; 432  : 				LogAddC(2, "BattleZone not enable");

  0134d	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LEABBGFP@BattleZone?5not?5enable?$AA@
  01352	6a 02		 push	 2
  01354	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0135a	83 c4 08	 add	 esp, 8

; 433  : 				//v4 = *(_DWORD *)a2;
; 434  : 				//v5 = CMsg::Get(&unk_8CFC758, 3451);
; 435  : 				//sub_406D7F(v5, v4, 1);
; 436  : 				return false;

  0135d	33 c0		 xor	 eax, eax
  0135f	e9 f8 02 00 00	 jmp	 $LN23@Move
$LN20@Move:

; 437  : 			}
; 438  : 			// ----
; 439  : 			//v6 = *(_DWORD *)a2;
; 440  : 			//v7 = CMsg::Get(&unk_8CFC758, 3452);
; 441  : 			//sub_406D7F(v7, v6, 1);
; 442  : 			// ----
; 443  : 			gGensSystem.MoveInBattleZonePartySplit(lpObj);

  01364	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01367	50		 push	 eax
  01368	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  0136d	e8 00 00 00 00	 call	 ?MoveInBattleZonePartySplit@GensSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; GensSystem::MoveInBattleZonePartySplit
$LN22@Move:

; 444  : 		}
; 445  : 	}
; 446  : 
; 447  : 	if ( loc6 == 24 ) //season 3.0 changed

  01372	83 7d e4 18	 cmp	 DWORD PTR _loc6$[ebp], 24 ; 00000018H
  01376	75 45		 jne	 SHORT $LN19@Move

; 448  : 	{
; 449  : 		if ( g_CastleSiegeSync.GetCastleState() == 7 )

  01378	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0137d	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiegeSync@@QAEHXZ ; CCastleSiegeSync::GetCastleState
  01382	83 f8 07	 cmp	 eax, 7
  01385	75 07		 jne	 SHORT $LN18@Move

; 450  : 		{
; 451  : 			return FALSE;

  01387	33 c0		 xor	 eax, eax
  01389	e9 ce 02 00 00	 jmp	 $LN23@Move
$LN18@Move:

; 452  : 		}
; 453  : 
; 454  : 		if ( g_CastleSiegeSync.CheckCastleOwnerMember(lpObj->m_Index) == FALSE && g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpObj->m_Index) == FALSE)

  0138e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01391	8b 08		 mov	 ecx, DWORD PTR [eax]
  01393	51		 push	 ecx
  01394	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  01399	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckCastleOwnerMember
  0139e	85 c0		 test	 eax, eax
  013a0	75 1b		 jne	 SHORT $LN19@Move
  013a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  013a7	51		 push	 ecx
  013a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  013ad	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckCastleOwnerUnionMember
  013b2	85 c0		 test	 eax, eax
  013b4	75 07		 jne	 SHORT $LN19@Move

; 455  : 		{
; 456  : 			return FALSE;

  013b6	33 c0		 xor	 eax, eax
  013b8	e9 9f 02 00 00	 jmp	 $LN23@Move
$LN19@Move:

; 457  : 		}
; 458  : 	}
; 459  : 
; 460  : 	if(IT_MAP_RANGE(lpObj->MapNumber) != FALSE) //season 3.0 add-on

  013bd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013c0	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  013c7	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  013ca	7d 0c		 jge	 SHORT $LN25@Move
  013cc	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
  013d6	eb 18		 jmp	 SHORT $LN26@Move
$LN25@Move:
  013d8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  013db	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  013e2	33 c9		 xor	 ecx, ecx
  013e4	83 f8 32	 cmp	 eax, 50			; 00000032H
  013e7	0f 9e c1	 setle	 cl
  013ea	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv134[ebp], ecx
$LN26@Move:
  013f0	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv134[ebp], 0
  013f7	74 1f		 je	 SHORT $LN16@Move

; 461  : 	{
; 462  : 		if(loc6 == 11 || loc6 == 12 || loc6 == 13 || loc6 == 23)

  013f9	83 7d e4 0b	 cmp	 DWORD PTR _loc6$[ebp], 11 ; 0000000bH
  013fd	74 12		 je	 SHORT $LN14@Move
  013ff	83 7d e4 0c	 cmp	 DWORD PTR _loc6$[ebp], 12 ; 0000000cH
  01403	74 0c		 je	 SHORT $LN14@Move
  01405	83 7d e4 0d	 cmp	 DWORD PTR _loc6$[ebp], 13 ; 0000000dH
  01409	74 06		 je	 SHORT $LN14@Move
  0140b	83 7d e4 17	 cmp	 DWORD PTR _loc6$[ebp], 23 ; 00000017H
  0140f	75 07		 jne	 SHORT $LN16@Move
$LN14@Move:

; 463  : 		{
; 464  : 			return FALSE;

  01411	33 c0		 xor	 eax, eax
  01413	e9 44 02 00 00	 jmp	 $LN23@Move
$LN16@Move:

; 465  : 		}
; 466  : 	}
; 467  : 
; 468  : 	if ( index == -1 )

  01418	83 7d e8 ff	 cmp	 DWORD PTR _index$[ebp], -1
  0141c	75 07		 jne	 SHORT $LN13@Move

; 469  : 	{
; 470  : 		return FALSE;

  0141e	33 c0		 xor	 eax, eax
  01420	e9 37 02 00 00	 jmp	 $LN23@Move
$LN13@Move:

; 471  : 	}
; 472  : 
; 473  : 	int NeedLevel = this->m_MoveCommandData[index].NeedLevel;

  01425	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  01428	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  0142e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01431	8b 94 01 0c 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+524]
  01438	89 55 e0	 mov	 DWORD PTR _NeedLevel$[ebp], edx

; 474  : 	int NeedZen   = this->m_MoveCommandData[index].NeedZen;

  0143b	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  0143e	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01444	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01447	8b 94 01 08 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+520]
  0144e	89 55 dc	 mov	 DWORD PTR _NeedZen$[ebp], edx

; 475  : 	int GateNumber= this->m_MoveCommandData[index].GateNumber;

  01451	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  01454	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  0145a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0145d	8b 94 01 10 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+528]
  01464	89 55 d8	 mov	 DWORD PTR _GateNumber$[ebp], edx

; 476  : 
; 477  : 	if(gGENS)

  01467	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  0146e	74 15		 je	 SHORT $LN12@Move

; 478  : 	{
; 479  : 		NeedZen			*= gGensSystem.PkPenaltyAddNeedZenMapMove(lpObj);

  01470	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01473	50		 push	 eax
  01474	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  01479	e8 00 00 00 00	 call	 ?PkPenaltyAddNeedZenMapMove@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::PkPenaltyAddNeedZenMapMove
  0147e	0f af 45 dc	 imul	 eax, DWORD PTR _NeedZen$[ebp]
  01482	89 45 dc	 mov	 DWORD PTR _NeedZen$[ebp], eax
$LN12@Move:

; 480  : 	}
; 481  : 
; 482  : 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA 
; 483  : #ifdef MONK
; 484  : 		|| lpObj->Class == CLASS_MONK
; 485  : #endif
; 486  : 		|| lpObj->Class == CLASS_SUMMONER )

  01485	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01488	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0148f	83 f9 04	 cmp	 ecx, 4
  01492	74 2d		 je	 SHORT $LN10@Move
  01494	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01497	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0149e	83 f9 03	 cmp	 ecx, 3
  014a1	74 1e		 je	 SHORT $LN10@Move
  014a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014a6	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  014ad	83 f9 06	 cmp	 ecx, 6
  014b0	74 0f		 je	 SHORT $LN10@Move
  014b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014b5	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  014bc	83 f9 05	 cmp	 ecx, 5
  014bf	75 1f		 jne	 SHORT $LN11@Move
$LN10@Move:

; 487  : 	{
; 488  : 		if ( NeedLevel > 0 )

  014c1	83 7d e0 00	 cmp	 DWORD PTR _NeedLevel$[ebp], 0
  014c5	7e 19		 jle	 SHORT $LN11@Move

; 489  : 		{
; 490  : 			if (GateNumber != 273) //season 3.0 add-on (Swamp of Calmmness)

  014c7	81 7d d8 11 01
	00 00		 cmp	 DWORD PTR _GateNumber$[ebp], 273 ; 00000111H
  014ce	74 10		 je	 SHORT $LN11@Move

; 491  : 			{
; 492  : 				NeedLevel = NeedLevel *2 / 3;

  014d0	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  014d3	d1 e0		 shl	 eax, 1
  014d5	99		 cdq
  014d6	b9 03 00 00 00	 mov	 ecx, 3
  014db	f7 f9		 idiv	 ecx
  014dd	89 45 e0	 mov	 DWORD PTR _NeedLevel$[ebp], eax
$LN11@Move:

; 493  : 			}
; 494  : 		}
; 495  : 	}
; 496  : 
; 497  : 	if ( GateNumber >= 0 )

  014e0	83 7d d8 00	 cmp	 DWORD PTR _GateNumber$[ebp], 0
  014e4	0f 8c 3c 01 00
	00		 jl	 $LN7@Move

; 498  : 	{
; 499  : 		if ( NeedLevel <= lpObj->Level )

  014ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014ed	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  014f4	39 4d e0	 cmp	 DWORD PTR _NeedLevel$[ebp], ecx
  014f7	0f 8f ee 00 00
	00		 jg	 $LN6@Move

; 500  : 		{
; 501  : 			if ( (lpObj->Money - NeedZen ) >= 0 )

  014fd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01500	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01506	2b 4d dc	 sub	 ecx, DWORD PTR _NeedZen$[ebp]
  01509	0f 88 ba 00 00
	00		 js	 $LN5@Move

; 502  : 			{
; 503  : 				if ( gObjMoveGate(lpObj->m_Index, GateNumber ) != FALSE )

  0150f	8b 45 d8	 mov	 eax, DWORD PTR _GateNumber$[ebp]
  01512	50		 push	 eax
  01513	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01516	8b 11		 mov	 edx, DWORD PTR [ecx]
  01518	52		 push	 edx
  01519	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0151e	83 c4 08	 add	 esp, 8
  01521	85 c0		 test	 eax, eax
  01523	0f 84 9e 00 00
	00		 je	 $LN4@Move

; 504  : 				{
; 505  : 					lpObj->m_bPShopRedrawAbs = true;

  01529	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0152c	c6 80 c7 0e 00
	00 01		 mov	 BYTE PTR [eax+3783], 1

; 506  : 					lpObj->Money -= NeedZen;

  01533	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01536	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0153c	2b 4d dc	 sub	 ecx, DWORD PTR _NeedZen$[ebp]
  0153f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01542	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 507  : 
; 508  : 					LogAddTD("[%s][%s] Use [%s %s] Success : reduces money %d - %d", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(11, 185)), mapname, lpObj->Money, NeedLevel);

  01548	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  0154b	50		 push	 eax
  0154c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0154f	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  01555	52		 push	 edx
  01556	8b 45 0c	 mov	 eax, DWORD PTR _mapname$[ebp]
  01559	50		 push	 eax
  0155a	68 b9 0b 00 00	 push	 3001			; 00000bb9H
  0155f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01564	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01569	50		 push	 eax
  0156a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0156d	83 c1 77	 add	 ecx, 119		; 00000077H
  01570	51		 push	 ecx
  01571	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01574	83 c2 6c	 add	 edx, 108		; 0000006cH
  01577	52		 push	 edx
  01578	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5r@
  0157d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01583	83 c4 1c	 add	 esp, 28			; 0000001cH

; 509  : 
; 510  : 					GCMoneySend(lpObj->m_Index, lpObj->Money );

  01586	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01589	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0158f	51		 push	 ecx
  01590	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01593	8b 02		 mov	 eax, DWORD PTR [edx]
  01595	50		 push	 eax
  01596	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0159b	83 c4 08	 add	 esp, 8

; 511  : 
; 512  : 					if(lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS)//Season 4.5 addon

  0159e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015a1	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  015a8	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  015ab	75 10		 jne	 SHORT $LN3@Move

; 513  : 					{
; 514  : 						g_RaklionBattleUserMng.DeleteUserData(lpObj->m_Index);

  015ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  015b2	51		 push	 ecx
  015b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RaklionBattleUserMng@@3VCRaklionBattleUserMng@@A ; g_RaklionBattleUserMng
  015b8	e8 00 00 00 00	 call	 ?DeleteUserData@CRaklionBattleUserMng@@QAEHH@Z ; CRaklionBattleUserMng::DeleteUserData
$LN3@Move:

; 515  : 					}
; 516  : 					return TRUE;

  015bd	b8 01 00 00 00	 mov	 eax, 1
  015c2	e9 95 00 00 00	 jmp	 $LN23@Move
$LN4@Move:

; 517  : 				}
; 518  : 			}
; 519  : 			else

  015c7	eb 20		 jmp	 SHORT $LN2@Move
$LN5@Move:

; 520  : 			{
; 521  : 				::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 102)), lpObj->m_Index, 1);

  015c9	6a 01		 push	 1
  015cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  015d0	51		 push	 ecx
  015d1	68 66 04 00 00	 push	 1126			; 00000466H
  015d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  015db	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  015e0	50		 push	 eax
  015e1	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  015e6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Move:

; 522  : 			}
; 523  : 		}
; 524  : 		else

  015e9	eb 3b		 jmp	 SHORT $LN7@Move
$LN6@Move:

; 525  : 		{
; 526  : 			char szTemp[256];
; 527  : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 93)), NeedLevel);

  015eb	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  015ee	50		 push	 eax
  015ef	68 5d 04 00 00	 push	 1117			; 0000045dH
  015f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  015f9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  015fe	50		 push	 eax
  015ff	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$233531[ebp]
  01605	51		 push	 ecx
  01606	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0160c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  : 			::GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  0160f	6a 01		 push	 1
  01611	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01614	8b 08		 mov	 ecx, DWORD PTR [eax]
  01616	51		 push	 ecx
  01617	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$233531[ebp]
  0161d	52		 push	 edx
  0161e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01623	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Move:

; 529  : 		}
; 530  : 	}
; 531  : 
; 532  : 	LogAddTD("[%s][%s] Use [%s %s] Fail GateNumber = %d", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(11, 185)), mapname, GateNumber);

  01626	8b 45 d8	 mov	 eax, DWORD PTR _GateNumber$[ebp]
  01629	50		 push	 eax
  0162a	8b 4d 0c	 mov	 ecx, DWORD PTR _mapname$[ebp]
  0162d	51		 push	 ecx
  0162e	68 b9 0b 00 00	 push	 3001			; 00000bb9H
  01633	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01638	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0163d	50		 push	 eax
  0163e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01641	83 c2 77	 add	 edx, 119		; 00000077H
  01644	52		 push	 edx
  01645	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01648	83 c0 6c	 add	 eax, 108		; 0000006cH
  0164b	50		 push	 eax
  0164c	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@DALHCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5GateNu@
  01651	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01657	83 c4 18	 add	 esp, 24			; 00000018H

; 533  : 	return FALSE;

  0165a	33 c0		 xor	 eax, eax
$LN23@Move:

; 534  : 
; 535  : }

  0165c	5f		 pop	 edi
  0165d	5e		 pop	 esi
  0165e	5b		 pop	 ebx
  0165f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01662	33 cd		 xor	 ecx, ebp
  01664	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01669	8b e5		 mov	 esp, ebp
  0166b	5d		 pop	 ebp
  0166c	c2 08 00	 ret	 8
?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@PAD@Z ENDP	; CMoveCommand::Move
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiegesync.h
_TEXT	ENDS
;	COMDAT ?GetCastleState@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCastleState@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetCastleState, COMDAT
; _this$ = ecx

; 34   : 	int  GetCastleState(){return this->m_iCurCastleState;};	// line : 70

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetCastleState@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetCastleState
_TEXT	ENDS
PUBLIC	?GetKalimaGateLevel@@YAHPAUOBJECTSTRUCT@@@Z	; GetKalimaGateLevel
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\movecommand.cpp
_TEXT	SEGMENT
_i$233544 = -8						; size = 4
_i$233538 = -4						; size = 4
_lpObj$ = 8						; size = 4
?GetKalimaGateLevel@@YAHPAUOBJECTSTRUCT@@@Z PROC	; GetKalimaGateLevel

; 538  : {

  01670	55		 push	 ebp
  01671	8b ec		 mov	 ebp, esp
  01673	83 ec 48	 sub	 esp, 72			; 00000048H
  01676	53		 push	 ebx
  01677	56		 push	 esi
  01678	57		 push	 edi

; 539  : 	if ( lpObj->Class == CLASS_MAGUMSA || lpObj->Class == CLASS_DARKLORD 
; 540  : #ifdef MONK
; 541  : 		|| lpObj->Class == CLASS_MONK
; 542  : #endif
; 543  : 		|| lpObj->Class == CLASS_SUMMONER)

  01679	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0167c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01683	83 f9 03	 cmp	 ecx, 3
  01686	74 2d		 je	 SHORT $LN10@GetKalimaG
  01688	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0168b	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01692	83 f9 04	 cmp	 ecx, 4
  01695	74 1e		 je	 SHORT $LN10@GetKalimaG
  01697	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0169a	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  016a1	83 f9 06	 cmp	 ecx, 6
  016a4	74 0f		 je	 SHORT $LN10@GetKalimaG
  016a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016a9	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  016b0	83 f9 05	 cmp	 ecx, 5
  016b3	75 51		 jne	 SHORT $LN11@GetKalimaG
$LN10@GetKalimaG:

; 544  : 	{
; 545  : 		for ( int i=0;i<KALIMA_FLOORS;i++)

  016b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$233538[ebp], 0
  016bc	eb 09		 jmp	 SHORT $LN9@GetKalimaG
$LN8@GetKalimaG:
  016be	8b 45 fc	 mov	 eax, DWORD PTR _i$233538[ebp]
  016c1	83 c0 01	 add	 eax, 1
  016c4	89 45 fc	 mov	 DWORD PTR _i$233538[ebp], eax
$LN9@GetKalimaG:
  016c7	83 7d fc 07	 cmp	 DWORD PTR _i$233538[ebp], 7
  016cb	7d 37		 jge	 SHORT $LN7@GetKalimaG

; 546  : 		{
; 547  : 			if ( lpObj->Level >= g_sttKALIMAGATE_LEVEL[i].iLOWER_BOUND_MAGUMSA && lpObj->Level <= g_sttKALIMAGATE_LEVEL[i].iUPPER_BOUND_MAGUMSA )

  016cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016d0	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  016d7	8b 55 fc	 mov	 edx, DWORD PTR _i$233538[ebp]
  016da	c1 e2 04	 shl	 edx, 4
  016dd	3b 8a 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_sttKALIMAGATE_LEVEL[edx+8]
  016e3	7c 1d		 jl	 SHORT $LN6@GetKalimaG
  016e5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016e8	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  016ef	8b 55 fc	 mov	 edx, DWORD PTR _i$233538[ebp]
  016f2	c1 e2 04	 shl	 edx, 4
  016f5	3b 8a 0c 00 00
	00		 cmp	 ecx, DWORD PTR _g_sttKALIMAGATE_LEVEL[edx+12]
  016fb	7f 05		 jg	 SHORT $LN6@GetKalimaG

; 548  : 			{
; 549  : 				return i;

  016fd	8b 45 fc	 mov	 eax, DWORD PTR _i$233538[ebp]
  01700	eb 56		 jmp	 SHORT $LN12@GetKalimaG
$LN6@GetKalimaG:

; 550  : 			}
; 551  : 		}

  01702	eb ba		 jmp	 SHORT $LN8@GetKalimaG
$LN7@GetKalimaG:

; 552  : 	}
; 553  : 	else

  01704	eb 4f		 jmp	 SHORT $LN5@GetKalimaG
$LN11@GetKalimaG:

; 554  : 	{
; 555  : 		for ( int i=0;i<KALIMA_FLOORS;i++)

  01706	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$233544[ebp], 0
  0170d	eb 09		 jmp	 SHORT $LN4@GetKalimaG
$LN3@GetKalimaG:
  0170f	8b 45 f8	 mov	 eax, DWORD PTR _i$233544[ebp]
  01712	83 c0 01	 add	 eax, 1
  01715	89 45 f8	 mov	 DWORD PTR _i$233544[ebp], eax
$LN4@GetKalimaG:
  01718	83 7d f8 07	 cmp	 DWORD PTR _i$233544[ebp], 7
  0171c	7d 37		 jge	 SHORT $LN5@GetKalimaG

; 556  : 		{
; 557  : 			if ( lpObj->Level >= g_sttKALIMAGATE_LEVEL[i].iLOWER_BOUND && lpObj->Level <= g_sttKALIMAGATE_LEVEL[i].iUPPER_BOUND )

  0171e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01721	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  01728	8b 55 f8	 mov	 edx, DWORD PTR _i$233544[ebp]
  0172b	c1 e2 04	 shl	 edx, 4
  0172e	3b 8a 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_sttKALIMAGATE_LEVEL[edx]
  01734	7c 1d		 jl	 SHORT $LN1@GetKalimaG
  01736	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01739	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  01740	8b 55 f8	 mov	 edx, DWORD PTR _i$233544[ebp]
  01743	c1 e2 04	 shl	 edx, 4
  01746	3b 8a 04 00 00
	00		 cmp	 ecx, DWORD PTR _g_sttKALIMAGATE_LEVEL[edx+4]
  0174c	7f 05		 jg	 SHORT $LN1@GetKalimaG

; 558  : 			{
; 559  : 				return i;

  0174e	8b 45 f8	 mov	 eax, DWORD PTR _i$233544[ebp]
  01751	eb 05		 jmp	 SHORT $LN12@GetKalimaG
$LN1@GetKalimaG:

; 560  : 			}
; 561  : 		}

  01753	eb ba		 jmp	 SHORT $LN3@GetKalimaG
$LN5@GetKalimaG:

; 562  : 	}
; 563  : 
; 564  : 	return -1;

  01755	83 c8 ff	 or	 eax, -1
$LN12@GetKalimaG:

; 565  : }

  01758	5f		 pop	 edi
  01759	5e		 pop	 esi
  0175a	5b		 pop	 ebx
  0175b	8b e5		 mov	 esp, ebp
  0175d	5d		 pop	 ebp
  0175e	c3		 ret	 0
?GetKalimaGateLevel@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; GetKalimaGateLevel
_TEXT	ENDS
PUBLIC	?MoveFree2Kalima@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::MoveFree2Kalima
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iGateNumber$ = -12					; size = 4
_iIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MoveFree2Kalima@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CMoveCommand::MoveFree2Kalima
; _this$ = ecx

; 568  : {

  01760	55		 push	 ebp
  01761	8b ec		 mov	 ebp, esp
  01763	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01766	53		 push	 ebx
  01767	56		 push	 esi
  01768	57		 push	 edi
  01769	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 569  : 	int iIdx = GetKalimaGateLevel(lpObj);

  0176c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0176f	50		 push	 eax
  01770	e8 00 00 00 00	 call	 ?GetKalimaGateLevel@@YAHPAUOBJECTSTRUCT@@@Z ; GetKalimaGateLevel
  01775	83 c4 04	 add	 esp, 4
  01778	89 45 f8	 mov	 DWORD PTR _iIdx$[ebp], eax

; 570  : 
; 571  : 	if ( iIdx >= 6 )

  0177b	83 7d f8 06	 cmp	 DWORD PTR _iIdx$[ebp], 6
  0177f	7c 07		 jl	 SHORT $LN2@MoveFree2K

; 572  : 	{
; 573  : 		iIdx = 5;

  01781	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _iIdx$[ebp], 5
$LN2@MoveFree2K:

; 574  : 	}
; 575  : 
; 576  : 	if ( iIdx < 0 )

  01788	83 7d f8 00	 cmp	 DWORD PTR _iIdx$[ebp], 0
  0178c	7d 04		 jge	 SHORT $LN1@MoveFree2K

; 577  : 	{
; 578  : 		return FALSE;

  0178e	33 c0		 xor	 eax, eax
  01790	eb 1b		 jmp	 SHORT $LN3@MoveFree2K
$LN1@MoveFree2K:

; 579  : 	}
; 580  : 
; 581  : 	int iGateNumber = iIdx + 88;

  01792	8b 45 f8	 mov	 eax, DWORD PTR _iIdx$[ebp]
  01795	83 c0 58	 add	 eax, 88			; 00000058H
  01798	89 45 f4	 mov	 DWORD PTR _iGateNumber$[ebp], eax

; 582  : 
; 583  : 	return gObjMoveGate(lpObj->m_Index, iGateNumber);

  0179b	8b 45 f4	 mov	 eax, DWORD PTR _iGateNumber$[ebp]
  0179e	50		 push	 eax
  0179f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  017a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  017a4	52		 push	 edx
  017a5	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  017aa	83 c4 08	 add	 esp, 8
$LN3@MoveFree2K:

; 584  : }

  017ad	5f		 pop	 edi
  017ae	5e		 pop	 esi
  017af	5b		 pop	 ebx
  017b0	8b e5		 mov	 esp, ebp
  017b2	5d		 pop	 ebp
  017b3	c2 04 00	 ret	 4
?MoveFree2Kalima@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CMoveCommand::MoveFree2Kalima
_TEXT	ENDS
PUBLIC	?CheckMoveNum@CMoveCommand@@QAEHH@Z		; CMoveCommand::CheckMoveNum
PUBLIC	?FindIndex@CMoveCommand@@QAEHH@Z		; CMoveCommand::FindIndex
PUBLIC	__$ArrayPad$
PUBLIC	?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z	; CMoveCommand::Move
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv78 = -364						; size = 4
_szTemp$233586 = -296					; size = 256
_GateNumber$ = -40					; size = 4
_NeedZen$ = -36						; size = 4
_NeedLevel$ = -32					; size = 4
_loc6$ = -28						; size = 4
_index$ = -24						; size = 4
_subMoney$ = -20					; size = 4
_overlevel$ = -16					; size = 4
_m_number$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MoveNum$ = 12						; size = 4
?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z PROC	; CMoveCommand::Move
; _this$ = ecx

; 587  : {

  017c0	55		 push	 ebp
  017c1	8b ec		 mov	 ebp, esp
  017c3	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  017c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  017ce	33 c5		 xor	 eax, ebp
  017d0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  017d3	53		 push	 ebx
  017d4	56		 push	 esi
  017d5	57		 push	 edi
  017d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 588  : 	int m_number = -1;

  017d9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _m_number$[ebp], -1

; 589  : 	int overlevel = 0;

  017e0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _overlevel$[ebp], 0

; 590  : 	int subMoney = 2000;

  017e7	c7 45 ec d0 07
	00 00		 mov	 DWORD PTR _subMoney$[ebp], 2000 ; 000007d0H

; 591  : 
; 592  : 	int index = this->FindIndex(MoveNum);

  017ee	8b 45 0c	 mov	 eax, DWORD PTR _MoveNum$[ebp]
  017f1	50		 push	 eax
  017f2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017f5	e8 00 00 00 00	 call	 ?FindIndex@CMoveCommand@@QAEHH@Z ; CMoveCommand::FindIndex
  017fa	89 45 e8	 mov	 DWORD PTR _index$[ebp], eax

; 593  : #ifdef OLDCASHSHOP
; 594  : 	if ( g_bUseMoveMapBound == TRUE )
; 595  : 	{
; 596  : 		if ( g_CashItemPeriodSystem.CheckHaveItemPeriodSealEffect(lpObj) == FALSE )
; 597  : 		{
; 598  : 			if ( !this->CheckMoveMapBound(index))
; 599  : 			{
; 600  : 				return FALSE;
; 601  : 			}
; 602  : 		}
; 603  : 	}
; 604  : #endif
; 605  : 	if(this->CheckMoveNum(MoveNum) == 0)

  017fd	8b 45 0c	 mov	 eax, DWORD PTR _MoveNum$[ebp]
  01800	50		 push	 eax
  01801	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01804	e8 00 00 00 00	 call	 ?CheckMoveNum@CMoveCommand@@QAEHH@Z ; CMoveCommand::CheckMoveNum
  01809	85 c0		 test	 eax, eax
  0180b	75 07		 jne	 SHORT $LN16@Move@2

; 606  : 	{
; 607  : 		return FALSE;

  0180d	33 c0		 xor	 eax, eax
  0180f	e9 a7 02 00 00	 jmp	 $LN17@Move@2
$LN16@Move@2:

; 608  : 	}
; 609  : 
; 610  : 	int loc6 =  MoveNum;//season 3.0 add-on

  01814	8b 45 0c	 mov	 eax, DWORD PTR _MoveNum$[ebp]
  01817	89 45 e4	 mov	 DWORD PTR _loc6$[ebp], eax

; 611  : 
; 612  : 	/*if ( loc6 == 24 ) //season 3.0 changed
; 613  : 	{
; 614  : 		if ( g_CastleSiegeSync.GetCastleState() == 7 )
; 615  : 		{
; 616  : 			return FALSE;
; 617  : 		}
; 618  : 
; 619  : 		if ( g_CastleSiegeSync.CheckCastleOwnerMember(lpObj->m_Index) == FALSE && g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpObj->m_Index) == FALSE)
; 620  : 		{
; 621  : 			return FALSE;
; 622  : 		}
; 623  : 	}*/
; 624  : 
; 625  : 	if(IT_MAP_RANGE(lpObj->MapNumber) != FALSE) //season 3.0 add-on

  0181a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0181d	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  01824	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  01827	7d 0c		 jge	 SHORT $LN19@Move@2
  01829	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
  01833	eb 18		 jmp	 SHORT $LN20@Move@2
$LN19@Move@2:
  01835	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01838	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0183f	33 c9		 xor	 ecx, ecx
  01841	83 f8 32	 cmp	 eax, 50			; 00000032H
  01844	0f 9e c1	 setle	 cl
  01847	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
$LN20@Move@2:
  0184d	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv78[ebp], 0
  01854	74 1f		 je	 SHORT $LN15@Move@2

; 626  : 	{
; 627  : 		if(loc6 == 11 || loc6 == 12 || loc6 == 13 || loc6 == 23)

  01856	83 7d e4 0b	 cmp	 DWORD PTR _loc6$[ebp], 11 ; 0000000bH
  0185a	74 12		 je	 SHORT $LN13@Move@2
  0185c	83 7d e4 0c	 cmp	 DWORD PTR _loc6$[ebp], 12 ; 0000000cH
  01860	74 0c		 je	 SHORT $LN13@Move@2
  01862	83 7d e4 0d	 cmp	 DWORD PTR _loc6$[ebp], 13 ; 0000000dH
  01866	74 06		 je	 SHORT $LN13@Move@2
  01868	83 7d e4 17	 cmp	 DWORD PTR _loc6$[ebp], 23 ; 00000017H
  0186c	75 07		 jne	 SHORT $LN15@Move@2
$LN13@Move@2:

; 628  : 		{
; 629  : 			return FALSE;

  0186e	33 c0		 xor	 eax, eax
  01870	e9 46 02 00 00	 jmp	 $LN17@Move@2
$LN15@Move@2:

; 630  : 		}
; 631  : 	}
; 632  : 
; 633  : 	if ( index == -1 )

  01875	83 7d e8 ff	 cmp	 DWORD PTR _index$[ebp], -1
  01879	75 07		 jne	 SHORT $LN12@Move@2

; 634  : 	{
; 635  : 		return FALSE;

  0187b	33 c0		 xor	 eax, eax
  0187d	e9 39 02 00 00	 jmp	 $LN17@Move@2
$LN12@Move@2:

; 636  : 	}
; 637  : 
; 638  : 	int NeedLevel = this->m_MoveCommandData[index].NeedLevel;

  01882	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  01885	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  0188b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0188e	8b 94 01 0c 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+524]
  01895	89 55 e0	 mov	 DWORD PTR _NeedLevel$[ebp], edx

; 639  : 	int NeedZen   = this->m_MoveCommandData[index].NeedZen;

  01898	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  0189b	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  018a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018a4	8b 94 01 08 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+520]
  018ab	89 55 dc	 mov	 DWORD PTR _NeedZen$[ebp], edx

; 640  : 	int GateNumber= this->m_MoveCommandData[index].GateNumber;

  018ae	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  018b1	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  018b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018ba	8b 94 01 10 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+528]
  018c1	89 55 d8	 mov	 DWORD PTR _GateNumber$[ebp], edx

; 641  : 
; 642  : 	if ( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA 
; 643  : #ifdef MONK
; 644  : 		|| lpObj->Class == CLASS_MONK
; 645  : #endif
; 646  : 		|| lpObj->Class == CLASS_SUMMONER)

  018c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018c7	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  018ce	83 f9 04	 cmp	 ecx, 4
  018d1	74 2d		 je	 SHORT $LN10@Move@2
  018d3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018d6	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  018dd	83 f9 03	 cmp	 ecx, 3
  018e0	74 1e		 je	 SHORT $LN10@Move@2
  018e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018e5	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  018ec	83 f9 06	 cmp	 ecx, 6
  018ef	74 0f		 je	 SHORT $LN10@Move@2
  018f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018f4	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  018fb	83 f9 05	 cmp	 ecx, 5
  018fe	75 1f		 jne	 SHORT $LN11@Move@2
$LN10@Move@2:

; 647  : 	{
; 648  : 		if ( NeedLevel > 0 )

  01900	83 7d e0 00	 cmp	 DWORD PTR _NeedLevel$[ebp], 0
  01904	7e 19		 jle	 SHORT $LN11@Move@2

; 649  : 		{
; 650  : 			if (GateNumber != 273) //season 3.0 add-on (Swamp of Calmmness)

  01906	81 7d d8 11 01
	00 00		 cmp	 DWORD PTR _GateNumber$[ebp], 273 ; 00000111H
  0190d	74 10		 je	 SHORT $LN11@Move@2

; 651  : 			{
; 652  : 				NeedLevel = NeedLevel *2 / 3;

  0190f	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  01912	d1 e0		 shl	 eax, 1
  01914	99		 cdq
  01915	b9 03 00 00 00	 mov	 ecx, 3
  0191a	f7 f9		 idiv	 ecx
  0191c	89 45 e0	 mov	 DWORD PTR _NeedLevel$[ebp], eax
$LN11@Move@2:

; 653  : 			}
; 654  : 		}
; 655  : 	}
; 656  : 
; 657  : 	if ( GateNumber >= 0 )

  0191f	83 7d d8 00	 cmp	 DWORD PTR _GateNumber$[ebp], 0
  01923	0f 8c 4c 01 00
	00		 jl	 $LN7@Move@2

; 658  : 	{
; 659  : 		if ( NeedLevel <= lpObj->Level )

  01929	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0192c	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  01933	39 4d e0	 cmp	 DWORD PTR _NeedLevel$[ebp], ecx
  01936	0f 8f fe 00 00
	00		 jg	 $LN6@Move@2

; 660  : 		{
; 661  : 			if ( (lpObj->Money - NeedZen ) >= 0 )

  0193c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0193f	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01945	2b 4d dc	 sub	 ecx, DWORD PTR _NeedZen$[ebp]
  01948	0f 88 ca 00 00
	00		 js	 $LN5@Move@2

; 662  : 			{
; 663  : 				if ( gObjMoveGate(lpObj->m_Index, GateNumber ) != FALSE )

  0194e	8b 45 d8	 mov	 eax, DWORD PTR _GateNumber$[ebp]
  01951	50		 push	 eax
  01952	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01955	8b 11		 mov	 edx, DWORD PTR [ecx]
  01957	52		 push	 edx
  01958	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0195d	83 c4 08	 add	 esp, 8
  01960	85 c0		 test	 eax, eax
  01962	0f 84 ae 00 00
	00		 je	 $LN4@Move@2

; 664  : 				{
; 665  : 					lpObj->m_bPShopRedrawAbs = true;

  01968	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0196b	c6 80 c7 0e 00
	00 01		 mov	 BYTE PTR [eax+3783], 1

; 666  : 					lpObj->Money -= NeedZen;

  01972	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01975	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0197b	2b 4d dc	 sub	 ecx, DWORD PTR _NeedZen$[ebp]
  0197e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01981	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 667  : 
; 668  : 					LogAddTD("[%s][%s] Use [%s %s] Success : reduces money %d - %d", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(11, 185)), this->m_MoveCommandData[index].EngName, lpObj->Money, NeedLevel);

  01987	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  0198a	50		 push	 eax
  0198b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0198e	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  01994	52		 push	 edx
  01995	8b 45 e8	 mov	 eax, DWORD PTR _index$[ebp]
  01998	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  0199e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019a1	8d 94 01 07 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+263]
  019a8	52		 push	 edx
  019a9	68 b9 0b 00 00	 push	 3001			; 00000bb9H
  019ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  019b3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  019b8	50		 push	 eax
  019b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019bc	83 c0 77	 add	 eax, 119		; 00000077H
  019bf	50		 push	 eax
  019c0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  019c3	83 c1 6c	 add	 ecx, 108		; 0000006cH
  019c6	51		 push	 ecx
  019c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5r@
  019cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  019d2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 669  : 
; 670  : 					GCMoneySend(lpObj->m_Index, lpObj->Money );

  019d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019d8	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  019de	51		 push	 ecx
  019df	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  019e2	8b 02		 mov	 eax, DWORD PTR [edx]
  019e4	50		 push	 eax
  019e5	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  019ea	83 c4 08	 add	 esp, 8

; 671  : 					
; 672  : 					if(lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS)//Season 4.5 addon

  019ed	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019f0	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  019f7	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  019fa	75 10		 jne	 SHORT $LN3@Move@2

; 673  : 					{
; 674  : 						g_RaklionBattleUserMng.DeleteUserData(lpObj->m_Index);

  019fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  01a01	51		 push	 ecx
  01a02	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RaklionBattleUserMng@@3VCRaklionBattleUserMng@@A ; g_RaklionBattleUserMng
  01a07	e8 00 00 00 00	 call	 ?DeleteUserData@CRaklionBattleUserMng@@QAEHH@Z ; CRaklionBattleUserMng::DeleteUserData
$LN3@Move@2:

; 675  : 					}
; 676  : 					return TRUE;

  01a0c	b8 01 00 00 00	 mov	 eax, 1
  01a11	e9 a5 00 00 00	 jmp	 $LN17@Move@2
$LN4@Move@2:

; 677  : 				}
; 678  : 			}
; 679  : 			else

  01a16	eb 20		 jmp	 SHORT $LN2@Move@2
$LN5@Move@2:

; 680  : 			{
; 681  : 				::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 102)), lpObj->m_Index, 1);

  01a18	6a 01		 push	 1
  01a1a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a1d	8b 08		 mov	 ecx, DWORD PTR [eax]
  01a1f	51		 push	 ecx
  01a20	68 66 04 00 00	 push	 1126			; 00000466H
  01a25	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01a2a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01a2f	50		 push	 eax
  01a30	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01a35	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Move@2:

; 682  : 			}
; 683  : 		}
; 684  : 		else

  01a38	eb 3b		 jmp	 SHORT $LN7@Move@2
$LN6@Move@2:

; 685  : 		{
; 686  : 			char szTemp[256];
; 687  : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 93)), NeedLevel);

  01a3a	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  01a3d	50		 push	 eax
  01a3e	68 5d 04 00 00	 push	 1117			; 0000045dH
  01a43	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01a48	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01a4d	50		 push	 eax
  01a4e	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$233586[ebp]
  01a54	51		 push	 ecx
  01a55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01a5b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  : 			::GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  01a5e	6a 01		 push	 1
  01a60	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a63	8b 08		 mov	 ecx, DWORD PTR [eax]
  01a65	51		 push	 ecx
  01a66	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$233586[ebp]
  01a6c	52		 push	 edx
  01a6d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01a72	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Move@2:

; 689  : 		}
; 690  : 	}
; 691  : 
; 692  : 	LogAddTD("[%s][%s] Use [%s %s] Fail GateNumber = %d", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(11, 185)), this->m_MoveCommandData[index].EngName, GateNumber);

  01a75	8b 45 d8	 mov	 eax, DWORD PTR _GateNumber$[ebp]
  01a78	50		 push	 eax
  01a79	8b 4d e8	 mov	 ecx, DWORD PTR _index$[ebp]
  01a7c	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  01a82	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01a85	8d 84 0a 07 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+263]
  01a8c	50		 push	 eax
  01a8d	68 b9 0b 00 00	 push	 3001			; 00000bb9H
  01a92	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01a97	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01a9c	50		 push	 eax
  01a9d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01aa0	83 c1 77	 add	 ecx, 119		; 00000077H
  01aa3	51		 push	 ecx
  01aa4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01aa7	83 c2 6c	 add	 edx, 108		; 0000006cH
  01aaa	52		 push	 edx
  01aab	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@DALHCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5GateNu@
  01ab0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01ab6	83 c4 18	 add	 esp, 24			; 00000018H

; 693  : 	return FALSE;

  01ab9	33 c0		 xor	 eax, eax
$LN17@Move@2:

; 694  : 
; 695  : }

  01abb	5f		 pop	 edi
  01abc	5e		 pop	 esi
  01abd	5b		 pop	 ebx
  01abe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ac1	33 cd		 xor	 ecx, ebp
  01ac3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ac8	8b e5		 mov	 esp, ebp
  01aca	5d		 pop	 ebp
  01acb	c2 08 00	 ret	 8
?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP	; CMoveCommand::Move
; Function compile flags: /Odtp /ZI
_i$233591 = -8						; size = 4
_this$ = -4						; size = 4
_MoveNum$ = 8						; size = 4
?FindIndex@CMoveCommand@@QAEHH@Z PROC			; CMoveCommand::FindIndex
; _this$ = ecx

; 698  : {

  01ad0	55		 push	 ebp
  01ad1	8b ec		 mov	 ebp, esp
  01ad3	83 ec 48	 sub	 esp, 72			; 00000048H
  01ad6	53		 push	 ebx
  01ad7	56		 push	 esi
  01ad8	57		 push	 edi
  01ad9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 699  : 	for ( int i=0;i<MAX_MOVE_COMMAND;i++)

  01adc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$233591[ebp], 0
  01ae3	eb 09		 jmp	 SHORT $LN5@FindIndex@2
$LN4@FindIndex@2:
  01ae5	8b 45 f8	 mov	 eax, DWORD PTR _i$233591[ebp]
  01ae8	83 c0 01	 add	 eax, 1
  01aeb	89 45 f8	 mov	 DWORD PTR _i$233591[ebp], eax
$LN5@FindIndex@2:
  01aee	83 7d f8 32	 cmp	 DWORD PTR _i$233591[ebp], 50 ; 00000032H
  01af2	7d 34		 jge	 SHORT $LN3@FindIndex@2

; 700  : 	{
; 701  : 		if ( this->m_MoveCommandData[i].Index == -1 )

  01af4	8b 45 f8	 mov	 eax, DWORD PTR _i$233591[ebp]
  01af7	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01afd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b00	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  01b05	75 05		 jne	 SHORT $LN2@FindIndex@2

; 702  : 		{
; 703  : 			return -1;

  01b07	83 c8 ff	 or	 eax, -1
  01b0a	eb 1f		 jmp	 SHORT $LN6@FindIndex@2
$LN2@FindIndex@2:

; 704  : 		}
; 705  : 
; 706  : 		if ( this->m_MoveCommandData[i].Index ==MoveNum )

  01b0c	8b 45 f8	 mov	 eax, DWORD PTR _i$233591[ebp]
  01b0f	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01b15	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b18	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  01b1c	3b 55 08	 cmp	 edx, DWORD PTR _MoveNum$[ebp]
  01b1f	75 05		 jne	 SHORT $LN1@FindIndex@2

; 707  : 		{
; 708  : 			return i;

  01b21	8b 45 f8	 mov	 eax, DWORD PTR _i$233591[ebp]
  01b24	eb 05		 jmp	 SHORT $LN6@FindIndex@2
$LN1@FindIndex@2:

; 709  : 		}
; 710  : 	}

  01b26	eb bd		 jmp	 SHORT $LN4@FindIndex@2
$LN3@FindIndex@2:

; 711  : 
; 712  : 	return -1;

  01b28	83 c8 ff	 or	 eax, -1
$LN6@FindIndex@2:

; 713  : }

  01b2b	5f		 pop	 edi
  01b2c	5e		 pop	 esi
  01b2d	5b		 pop	 ebx
  01b2e	8b e5		 mov	 esp, ebp
  01b30	5d		 pop	 ebp
  01b31	c2 04 00	 ret	 4
?FindIndex@CMoveCommand@@QAEHH@Z ENDP			; CMoveCommand::FindIndex
; Function compile flags: /Odtp /ZI
_i$233601 = -8						; size = 4
_this$ = -4						; size = 4
_MoveNum$ = 8						; size = 4
?CheckMoveNum@CMoveCommand@@QAEHH@Z PROC		; CMoveCommand::CheckMoveNum
; _this$ = ecx

; 715  : {

  01b40	55		 push	 ebp
  01b41	8b ec		 mov	 ebp, esp
  01b43	83 ec 48	 sub	 esp, 72			; 00000048H
  01b46	53		 push	 ebx
  01b47	56		 push	 esi
  01b48	57		 push	 edi
  01b49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 716  : #ifdef DEBUG_CODE
; 717  : 	LogAddC(2,"MoveNum: %d",MoveNum);
; 718  : #endif
; 719  : 	for ( int i=0;i<MAX_MOVE_COMMAND;i++)

  01b4c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$233601[ebp], 0
  01b53	eb 09		 jmp	 SHORT $LN4@CheckMoveN
$LN3@CheckMoveN:
  01b55	8b 45 f8	 mov	 eax, DWORD PTR _i$233601[ebp]
  01b58	83 c0 01	 add	 eax, 1
  01b5b	89 45 f8	 mov	 DWORD PTR _i$233601[ebp], eax
$LN4@CheckMoveN:
  01b5e	83 7d f8 32	 cmp	 DWORD PTR _i$233601[ebp], 50 ; 00000032H
  01b62	7d 1e		 jge	 SHORT $LN2@CheckMoveN

; 720  : 	{
; 721  : 		if ( this->m_MoveCommandData[i].Index == MoveNum )

  01b64	8b 45 f8	 mov	 eax, DWORD PTR _i$233601[ebp]
  01b67	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01b6d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b70	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  01b74	3b 55 08	 cmp	 edx, DWORD PTR _MoveNum$[ebp]
  01b77	75 07		 jne	 SHORT $LN1@CheckMoveN

; 722  : 		{
; 723  : 			return 1;

  01b79	b8 01 00 00 00	 mov	 eax, 1
  01b7e	eb 04		 jmp	 SHORT $LN5@CheckMoveN
$LN1@CheckMoveN:

; 724  : 		}
; 725  : 
; 726  : 	}

  01b80	eb d3		 jmp	 SHORT $LN3@CheckMoveN
$LN2@CheckMoveN:

; 727  : 
; 728  : 	return 0;

  01b82	33 c0		 xor	 eax, eax
$LN5@CheckMoveN:

; 729  : }

  01b84	5f		 pop	 edi
  01b85	5e		 pop	 esi
  01b86	5b		 pop	 ebx
  01b87	8b e5		 mov	 esp, ebp
  01b89	5d		 pop	 ebp
  01b8a	c2 04 00	 ret	 4
?CheckMoveNum@CMoveCommand@@QAEHH@Z ENDP		; CMoveCommand::CheckMoveNum
_TEXT	ENDS
PUBLIC	?GetMoveCommandData@CMoveCommand@@QAEPAUMOVE_COMMAND_DATA@@H@Z ; CMoveCommand::GetMoveCommandData
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$233611 = -12						; size = 4
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_nMapIndex$ = 8						; size = 4
?GetMoveCommandData@CMoveCommand@@QAEPAUMOVE_COMMAND_DATA@@H@Z PROC ; CMoveCommand::GetMoveCommandData
; _this$ = ecx

; 732  : {

  01b90	55		 push	 ebp
  01b91	8b ec		 mov	 ebp, esp
  01b93	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01b96	53		 push	 ebx
  01b97	56		 push	 esi
  01b98	57		 push	 edi
  01b99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 733  : 	int nIndex = -1;

  01b9c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _nIndex$[ebp], -1

; 734  : 	// ----
; 735  : 	for( int i = 0; i < MAX_MOVE_COMMAND; i++ )

  01ba3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$233611[ebp], 0
  01baa	eb 09		 jmp	 SHORT $LN5@GetMoveCom
$LN4@GetMoveCom:
  01bac	8b 45 f4	 mov	 eax, DWORD PTR _i$233611[ebp]
  01baf	83 c0 01	 add	 eax, 1
  01bb2	89 45 f4	 mov	 DWORD PTR _i$233611[ebp], eax
$LN5@GetMoveCom:
  01bb5	83 7d f4 32	 cmp	 DWORD PTR _i$233611[ebp], 50 ; 00000032H
  01bb9	7d 1f		 jge	 SHORT $LN3@GetMoveCom

; 736  : 	{
; 737  : 		if( this->m_MoveCommandData[i].Index == nMapIndex )

  01bbb	8b 45 f4	 mov	 eax, DWORD PTR _i$233611[ebp]
  01bbe	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01bc4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bc7	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  01bcb	3b 55 08	 cmp	 edx, DWORD PTR _nMapIndex$[ebp]
  01bce	75 08		 jne	 SHORT $LN2@GetMoveCom

; 738  : 		{
; 739  : 			nIndex = i;

  01bd0	8b 45 f4	 mov	 eax, DWORD PTR _i$233611[ebp]
  01bd3	89 45 f8	 mov	 DWORD PTR _nIndex$[ebp], eax

; 740  : 			break;

  01bd6	eb 02		 jmp	 SHORT $LN3@GetMoveCom
$LN2@GetMoveCom:

; 741  : 		}
; 742  : 	}

  01bd8	eb d2		 jmp	 SHORT $LN4@GetMoveCom
$LN3@GetMoveCom:

; 743  : 	// ----
; 744  : 	if( nIndex >= 0 )

  01bda	83 7d f8 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  01bde	7c 12		 jl	 SHORT $LN1@GetMoveCom

; 745  : 	{
; 746  : 		return &this->m_MoveCommandData[nIndex];

  01be0	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]
  01be3	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  01be9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bec	8d 44 01 04	 lea	 eax, DWORD PTR [ecx+eax+4]
  01bf0	eb 02		 jmp	 SHORT $LN6@GetMoveCom
$LN1@GetMoveCom:

; 747  : 	}
; 748  : 	// ----
; 749  : 	return 0;

  01bf2	33 c0		 xor	 eax, eax
$LN6@GetMoveCom:

; 750  : }

  01bf4	5f		 pop	 edi
  01bf5	5e		 pop	 esi
  01bf6	5b		 pop	 ebx
  01bf7	8b e5		 mov	 esp, ebp
  01bf9	5d		 pop	 ebp
  01bfa	c2 04 00	 ret	 4
?GetMoveCommandData@CMoveCommand@@QAEPAUMOVE_COMMAND_DATA@@H@Z ENDP ; CMoveCommand::GetMoveCommandData
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??__EgMoveCommand@@YAXXZ
text$yc	SEGMENT
??__EgMoveCommand@@YAXXZ PROC				; `dynamic initializer for 'gMoveCommand'', COMDAT

; 18   : CMoveCommand gMoveCommand;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0000e	e8 00 00 00 00	 call	 ??0CMoveCommand@@QAE@XZ	; CMoveCommand::CMoveCommand
  00013	68 00 00 00 00	 push	 OFFSET ??__FgMoveCommand@@YAXXZ ; `dynamic atexit destructor for 'gMoveCommand''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EgMoveCommand@@YAXXZ ENDP				; `dynamic initializer for 'gMoveCommand''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__FgMoveCommand@@YAXXZ
text$yd	SEGMENT
??__FgMoveCommand@@YAXXZ PROC				; `dynamic atexit destructor for 'gMoveCommand'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0000e	e8 00 00 00 00	 call	 ??1CMoveCommand@@UAE@XZ	; CMoveCommand::~CMoveCommand
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FgMoveCommand@@YAXXZ ENDP				; `dynamic atexit destructor for 'gMoveCommand''
text$yd	ENDS
PUBLIC	?gMoveCommand@@3VCMoveCommand@@A		; gMoveCommand
_BSS	SEGMENT
?gMoveCommand@@3VCMoveCommand@@A DB 06bd4H DUP (?)	; gMoveCommand
_BSS	ENDS
CRT$XCU	SEGMENT
_gMoveCommand$initializer$ DD FLAT:??__EgMoveCommand@@YAXXZ
CRT$XCU	ENDS
END
