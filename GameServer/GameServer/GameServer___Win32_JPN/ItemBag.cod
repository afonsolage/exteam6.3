; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\ItemBag.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CItemBagAttr@@QAE@XZ				; CItemBagAttr::CItemBagAttr
PUBLIC	??_7CItemBag@@6B@				; CItemBag::`vftable'
PUBLIC	??0CItemBag@@QAE@XZ				; CItemBag::CItemBag
PUBLIC	??_R4CItemBag@@6B@				; CItemBag::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCItemBag@@@8				; CItemBag `RTTI Type Descriptor'
PUBLIC	??_R3CItemBag@@8				; CItemBag::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CItemBag@@8				; CItemBag::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CItemBag@@8			; CItemBag::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CItemBag@@UAEXPAD@Z			; CItemBag::Init
PUBLIC	?LoadItem@CItemBag@@UAEXPAD@Z			; CItemBag::LoadItem
PUBLIC	?GetType@CItemBag@@UAEEH@Z			; CItemBag::GetType
PUBLIC	?GetIndex@CItemBag@@UAEEH@Z			; CItemBag::GetIndex
PUBLIC	?GetLevel@CItemBag@@UAEEH@Z			; CItemBag::GetLevel
PUBLIC	?GetOp1@CItemBag@@UAEEH@Z			; CItemBag::GetOp1
PUBLIC	?GetOp2@CItemBag@@UAEEH@Z			; CItemBag::GetOp2
PUBLIC	?GetOp3@CItemBag@@UAEEH@Z			; CItemBag::GetOp3
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECItemBag@@UAEPAXI@Z:PROC			; CItemBag::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CItemBag@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\itembag.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CItemBag@@8 DD FLAT:??_R0?AVCItemBag@@@8	; CItemBag::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CItemBag@@8
rdata$r	ENDS
;	COMDAT ??_R2CItemBag@@8
rdata$r	SEGMENT
??_R2CItemBag@@8 DD FLAT:??_R1A@?0A@EA@CItemBag@@8	; CItemBag::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CItemBag@@8
rdata$r	SEGMENT
??_R3CItemBag@@8 DD 00H					; CItemBag::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CItemBag@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCItemBag@@@8
_DATA	SEGMENT
??_R0?AVCItemBag@@@8 DD FLAT:??_7type_info@@6B@		; CItemBag `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCItemBag@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CItemBag@@6B@
rdata$r	SEGMENT
??_R4CItemBag@@6B@ DD 00H				; CItemBag::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCItemBag@@@8
	DD	FLAT:??_R3CItemBag@@8
rdata$r	ENDS
;	COMDAT ??_7CItemBag@@6B@
CONST	SEGMENT
??_7CItemBag@@6B@ DD FLAT:??_R4CItemBag@@6B@		; CItemBag::`vftable'
	DD	FLAT:??_ECItemBag@@UAEPAXI@Z
	DD	FLAT:?Init@CItemBag@@UAEXPAD@Z
	DD	FLAT:?LoadItem@CItemBag@@UAEXPAD@Z
	DD	FLAT:?GetType@CItemBag@@UAEEH@Z
	DD	FLAT:?GetIndex@CItemBag@@UAEEH@Z
	DD	FLAT:?GetLevel@CItemBag@@UAEEH@Z
	DD	FLAT:?GetOp1@CItemBag@@UAEEH@Z
	DD	FLAT:?GetOp2@CItemBag@@UAEEH@Z
	DD	FLAT:?GetOp3@CItemBag@@UAEEH@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CItemBag@@QAE@XZ PROC				; CItemBag::CItemBag
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CItemBag@@6B@
  00015	68 00 00 00 00	 push	 OFFSET ??0CItemBagAttr@@QAE@XZ ; CItemBagAttr::CItemBagAttr
  0001a	68 96 00 00 00	 push	 150			; 00000096H
  0001f	6a 06		 push	 6
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z

; 11   : 	return;
; 12   : }

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??0CItemBag@@QAE@XZ ENDP				; CItemBag::CItemBag
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\itembag.h
_TEXT	ENDS
;	COMDAT ??0CItemBagAttr@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CItemBagAttr@@QAE@XZ PROC				; CItemBagAttr::CItemBagAttr, COMDAT
; _this$ = ecx

; 15   : 	CItemBagAttr()	// line : 28

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 16   : 	{
; 17   : 		this->m_type=0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 18   : 		this->m_index=0;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 19   : 		this->m_level=0;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 20   : 		this->m_op1=0;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 21   : 		this->m_op2=0;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 22   : 		this->m_op3=0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c6 40 05 00	 mov	 BYTE PTR [eax+5], 0

; 23   : 	}	// line : 36

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0CItemBagAttr@@QAE@XZ ENDP				; CItemBagAttr::CItemBagAttr
_TEXT	ENDS
PUBLIC	??1CItemBag@@UAE@XZ				; CItemBag::~CItemBag
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCItemBag@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCItemBag@@UAEPAXI@Z PROC				; CItemBag::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CItemBag@@UAE@XZ	; CItemBag::~CItemBag
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCItemBag@@UAEPAXI@Z ENDP				; CItemBag::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\itembag.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CItemBag@@UAE@XZ PROC				; CItemBag::~CItemBag
; _this$ = ecx

; 15   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 44	 sub	 esp, 68			; 00000044H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CItemBag@@6B@

; 16   : 	return;
; 17   : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??1CItemBag@@UAE@XZ ENDP				; CItemBag::~CItemBag
_TEXT	ENDS
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 4
?Init@CItemBag@@UAEXPAD@Z PROC				; CItemBag::Init
; _this$ = ecx

; 20   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	83 ec 44	 sub	 esp, 68			; 00000044H
  00066	53		 push	 ebx
  00067	56		 push	 esi
  00068	57		 push	 edi
  00069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	this->BagObjectCount = 0;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	c7 80 88 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+904], 0

; 22   : 	this->BagNormalItemCount = 0;

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	c7 80 8c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+908], 0

; 23   : 	this->BagExItemCount = 0;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c7 80 90 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+912], 0

; 24   : 
; 25   : 	this->LoadItem( gDirPath.GetNewPath(name));

  00093	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00096	50		 push	 eax
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0009c	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000a1	50		 push	 eax
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ad	ff d0		 call	 eax

; 26   : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
?Init@CItemBag@@UAEXPAD@Z ENDP				; CItemBag::Init
_TEXT	ENDS
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	_fclose:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
_BSS	SEGMENT
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv309 = -108						; size = 4
tv298 = -108						; size = 4
tv287 = -108						; size = 4
tv276 = -108						; size = 4
tv265 = -108						; size = 4
tv254 = -108						; size = 4
tv242 = -108						; size = 4
tv233 = -108						; size = 4
tv224 = -108						; size = 4
tv215 = -108						; size = 4
tv206 = -108						; size = 4
tv307 = -104						; size = 4
tv296 = -104						; size = 4
tv285 = -104						; size = 4
tv274 = -104						; size = 4
tv263 = -104						; size = 4
tv252 = -104						; size = 4
tv240 = -104						; size = 4
tv231 = -104						; size = 4
tv222 = -104						; size = 4
tv213 = -104						; size = 4
tv204 = -104						; size = 4
tv304 = -98						; size = 2
tv293 = -98						; size = 2
tv282 = -98						; size = 2
tv271 = -98						; size = 2
tv260 = -98						; size = 2
tv249 = -98						; size = 2
tv237 = -98						; size = 2
tv228 = -98						; size = 2
tv219 = -98						; size = 2
tv210 = -98						; size = 2
tv201 = -98						; size = 2
_add_luck$ = -32					; size = 4
_add_skill$ = -28					; size = 4
_add_opt$ = -24						; size = 4
_add_lvl$ = -20						; size = 4
_v$ = -16						; size = 4
_n$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_script_file$ = 8					; size = 4
?LoadItem@CItemBag@@UAEXPAD@Z PROC			; CItemBag::LoadItem
; _this$ = ecx

; 29   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 6c	 sub	 esp, 108		; 0000006cH
  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	57		 push	 edi
  000c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	SMDFile = fopen(script_file, "r");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000d1	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _fopen
  000da	83 c4 08	 add	 esp, 8
  000dd	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 31   : 
; 32   : 	if ( SMDFile == NULL )

  000e2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  000e9	75 22		 jne	 SHORT $LN11@LoadItem

; 33   : 	{
; 34   : 		LogAdd(lMsg.Get(MSGGET(1, 197)), script_file);

  000eb	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  000ee	50		 push	 eax
  000ef	68 c5 01 00 00	 push	 453			; 000001c5H
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00105	83 c4 08	 add	 esp, 8

; 35   : 		return ;

  00108	e9 37 03 00 00	 jmp	 $LN12@LoadItem
$LN11@LoadItem:

; 36   : 	}
; 37   : 
; 38   : 	int Token;
; 39   : 	int n = 0;

  0010d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 40   : 	int v = 0;

  00114	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0

; 41   : 
; 42   : 	int add_lvl = 0;

  0011b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _add_lvl$[ebp], 0

; 43   : 	int add_opt = 0;

  00122	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _add_opt$[ebp], 0

; 44   : 	int add_skill = 0;

  00129	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _add_skill$[ebp], 0

; 45   : 	int add_luck = 0;

  00130	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _add_luck$[ebp], 0
$LN10@LoadItem:

; 46   : 
; 47   : 	while ( true )

  00137	b8 01 00 00 00	 mov	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	0f 84 d5 02 00
	00		 je	 $LN9@LoadItem

; 48   : 	{
; 49   : 		Token = GetToken();

  00144	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00149	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 50   : 
; 51   : 		if ( Token == 2 )

  0014c	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00150	75 05		 jne	 SHORT $LN8@LoadItem

; 52   : 		{
; 53   : 			break;

  00152	e9 c2 02 00 00	 jmp	 $LN9@LoadItem
$LN8@LoadItem:

; 54   : 		}
; 55   : 
; 56   : 		if (Token == COMMAND)

  00157	83 7d f8 23	 cmp	 DWORD PTR _Token$[ebp], 35 ; 00000023H
  0015b	75 3b		 jne	 SHORT $LN7@LoadItem

; 57   : 		{
; 58   : 			Token = GetToken();

  0015d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00162	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 59   : 
; 60   : 			if (Token == 1)

  00165	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00169	75 25		 jne	 SHORT $LN6@LoadItem

; 61   : 				v = (BYTE)TokenNumber;

  0016b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00171	d9 7d 9e	 fnstcw	 WORD PTR tv201[ebp]
  00174	0f b7 45 9e	 movzx	 eax, WORD PTR tv201[ebp]
  00178	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0017d	89 45 98	 mov	 DWORD PTR tv204[ebp], eax
  00180	d9 6d 98	 fldcw	 WORD PTR tv204[ebp]
  00183	db 5d 94	 fistp	 DWORD PTR tv206[ebp]
  00186	d9 6d 9e	 fldcw	 WORD PTR tv201[ebp]
  00189	0f b6 45 94	 movzx	 eax, BYTE PTR tv206[ebp]
  0018d	89 45 f0	 mov	 DWORD PTR _v$[ebp], eax
$LN6@LoadItem:

; 62   : 
; 63   : 			Token = GetToken();

  00190	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00195	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
$LN7@LoadItem:

; 64   : 		}
; 65   : 		
; 66   : 		if (v == 1)

  00198	83 7d f0 01	 cmp	 DWORD PTR _v$[ebp], 1
  0019c	0f 85 bc 00 00
	00		 jne	 $LN5@LoadItem

; 67   : 		{
; 68   : 			add_lvl = (BYTE)TokenNumber;

  001a2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a8	d9 7d 9e	 fnstcw	 WORD PTR tv210[ebp]
  001ab	0f b7 45 9e	 movzx	 eax, WORD PTR tv210[ebp]
  001af	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001b4	89 45 98	 mov	 DWORD PTR tv213[ebp], eax
  001b7	d9 6d 98	 fldcw	 WORD PTR tv213[ebp]
  001ba	db 5d 94	 fistp	 DWORD PTR tv215[ebp]
  001bd	d9 6d 9e	 fldcw	 WORD PTR tv210[ebp]
  001c0	0f b6 45 94	 movzx	 eax, BYTE PTR tv215[ebp]
  001c4	89 45 ec	 mov	 DWORD PTR _add_lvl$[ebp], eax

; 69   : 
; 70   : 			Token = GetToken();

  001c7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001cc	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 71   : 			add_opt = (BYTE)TokenNumber;

  001cf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d5	d9 7d 9e	 fnstcw	 WORD PTR tv219[ebp]
  001d8	0f b7 45 9e	 movzx	 eax, WORD PTR tv219[ebp]
  001dc	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001e1	89 45 98	 mov	 DWORD PTR tv222[ebp], eax
  001e4	d9 6d 98	 fldcw	 WORD PTR tv222[ebp]
  001e7	db 5d 94	 fistp	 DWORD PTR tv224[ebp]
  001ea	d9 6d 9e	 fldcw	 WORD PTR tv219[ebp]
  001ed	0f b6 45 94	 movzx	 eax, BYTE PTR tv224[ebp]
  001f1	89 45 e8	 mov	 DWORD PTR _add_opt$[ebp], eax

; 72   : 
; 73   : 			Token = GetToken();

  001f4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001f9	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 74   : 			add_skill = (BYTE)TokenNumber;

  001fc	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00202	d9 7d 9e	 fnstcw	 WORD PTR tv228[ebp]
  00205	0f b7 45 9e	 movzx	 eax, WORD PTR tv228[ebp]
  00209	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0020e	89 45 98	 mov	 DWORD PTR tv231[ebp], eax
  00211	d9 6d 98	 fldcw	 WORD PTR tv231[ebp]
  00214	db 5d 94	 fistp	 DWORD PTR tv233[ebp]
  00217	d9 6d 9e	 fldcw	 WORD PTR tv228[ebp]
  0021a	0f b6 45 94	 movzx	 eax, BYTE PTR tv233[ebp]
  0021e	89 45 e4	 mov	 DWORD PTR _add_skill$[ebp], eax

; 75   : 
; 76   : 			Token = GetToken();

  00221	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00226	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 77   : 			add_luck = (BYTE)TokenNumber;

  00229	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0022f	d9 7d 9e	 fnstcw	 WORD PTR tv237[ebp]
  00232	0f b7 45 9e	 movzx	 eax, WORD PTR tv237[ebp]
  00236	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0023b	89 45 98	 mov	 DWORD PTR tv240[ebp], eax
  0023e	d9 6d 98	 fldcw	 WORD PTR tv240[ebp]
  00241	db 5d 94	 fistp	 DWORD PTR tv242[ebp]
  00244	d9 6d 9e	 fldcw	 WORD PTR tv237[ebp]
  00247	0f b6 45 94	 movzx	 eax, BYTE PTR tv242[ebp]
  0024b	89 45 e0	 mov	 DWORD PTR _add_luck$[ebp], eax

; 78   : 
; 79   : 			Token = GetToken(); //END

  0024e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00253	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 80   : 
; 81   : 			Token = GetToken();

  00256	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0025b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
$LN5@LoadItem:

; 82   : 		}
; 83   : 
; 84   : 		if ( Token == 1 )

  0025e	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00262	0f 85 ac 01 00
	00		 jne	 $LN1@LoadItem

; 85   : 		{
; 86   : 			n = this->BagObjectCount;

  00268	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	8b 88 88 03 00
	00		 mov	 ecx, DWORD PTR [eax+904]
  00271	89 4d f4	 mov	 DWORD PTR _n$[ebp], ecx

; 87   : 
; 88   : 			this->BagObject[n].m_type = (BYTE)TokenNumber;

  00274	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0027a	d9 7d 9e	 fnstcw	 WORD PTR tv249[ebp]
  0027d	0f b7 45 9e	 movzx	 eax, WORD PTR tv249[ebp]
  00281	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00286	89 45 98	 mov	 DWORD PTR tv252[ebp], eax
  00289	d9 6d 98	 fldcw	 WORD PTR tv252[ebp]
  0028c	db 5d 94	 fistp	 DWORD PTR tv254[ebp]
  0028f	d9 6d 9e	 fldcw	 WORD PTR tv249[ebp]
  00292	8a 45 94	 mov	 al, BYTE PTR tv254[ebp]
  00295	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  00298	6b c9 06	 imul	 ecx, 6
  0029b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0029e	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 89   : 
; 90   : 			Token = GetToken();

  002a2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002a7	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 91   : 			this->BagObject[n].m_index = (BYTE)TokenNumber;

  002aa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002b0	d9 7d 9e	 fnstcw	 WORD PTR tv260[ebp]
  002b3	0f b7 45 9e	 movzx	 eax, WORD PTR tv260[ebp]
  002b7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002bc	89 45 98	 mov	 DWORD PTR tv263[ebp], eax
  002bf	d9 6d 98	 fldcw	 WORD PTR tv263[ebp]
  002c2	db 5d 94	 fistp	 DWORD PTR tv265[ebp]
  002c5	d9 6d 9e	 fldcw	 WORD PTR tv260[ebp]
  002c8	8a 45 94	 mov	 al, BYTE PTR tv265[ebp]
  002cb	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  002ce	6b c9 06	 imul	 ecx, 6
  002d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002d4	88 44 0a 05	 mov	 BYTE PTR [edx+ecx+5], al

; 92   : 
; 93   : 			Token = GetToken();

  002d8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002dd	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 94   : 			this->BagObject[n].m_level = (BYTE)TokenNumber;

  002e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002e6	d9 7d 9e	 fnstcw	 WORD PTR tv271[ebp]
  002e9	0f b7 45 9e	 movzx	 eax, WORD PTR tv271[ebp]
  002ed	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002f2	89 45 98	 mov	 DWORD PTR tv274[ebp], eax
  002f5	d9 6d 98	 fldcw	 WORD PTR tv274[ebp]
  002f8	db 5d 94	 fistp	 DWORD PTR tv276[ebp]
  002fb	d9 6d 9e	 fldcw	 WORD PTR tv271[ebp]
  002fe	8a 45 94	 mov	 al, BYTE PTR tv276[ebp]
  00301	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  00304	6b c9 06	 imul	 ecx, 6
  00307	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0030a	88 44 0a 06	 mov	 BYTE PTR [edx+ecx+6], al

; 95   : 
; 96   : 			Token = GetToken();

  0030e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00313	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 97   : 			this->BagObject[n].m_op1 = (BYTE)TokenNumber;

  00316	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0031c	d9 7d 9e	 fnstcw	 WORD PTR tv282[ebp]
  0031f	0f b7 45 9e	 movzx	 eax, WORD PTR tv282[ebp]
  00323	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00328	89 45 98	 mov	 DWORD PTR tv285[ebp], eax
  0032b	d9 6d 98	 fldcw	 WORD PTR tv285[ebp]
  0032e	db 5d 94	 fistp	 DWORD PTR tv287[ebp]
  00331	d9 6d 9e	 fldcw	 WORD PTR tv282[ebp]
  00334	8a 45 94	 mov	 al, BYTE PTR tv287[ebp]
  00337	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  0033a	6b c9 06	 imul	 ecx, 6
  0033d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00340	88 44 0a 07	 mov	 BYTE PTR [edx+ecx+7], al

; 98   : 
; 99   : 			Token = GetToken();

  00344	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00349	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 100  : 			this->BagObject[n].m_op2 = (BYTE)TokenNumber;

  0034c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00352	d9 7d 9e	 fnstcw	 WORD PTR tv293[ebp]
  00355	0f b7 45 9e	 movzx	 eax, WORD PTR tv293[ebp]
  00359	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0035e	89 45 98	 mov	 DWORD PTR tv296[ebp], eax
  00361	d9 6d 98	 fldcw	 WORD PTR tv296[ebp]
  00364	db 5d 94	 fistp	 DWORD PTR tv298[ebp]
  00367	d9 6d 9e	 fldcw	 WORD PTR tv293[ebp]
  0036a	8a 45 94	 mov	 al, BYTE PTR tv298[ebp]
  0036d	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  00370	6b c9 06	 imul	 ecx, 6
  00373	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00376	88 44 0a 08	 mov	 BYTE PTR [edx+ecx+8], al

; 101  : 
; 102  : 			Token = GetToken();

  0037a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0037f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 103  : 			this->BagObject[n].m_op3 = (BYTE)TokenNumber;

  00382	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00388	d9 7d 9e	 fnstcw	 WORD PTR tv304[ebp]
  0038b	0f b7 45 9e	 movzx	 eax, WORD PTR tv304[ebp]
  0038f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00394	89 45 98	 mov	 DWORD PTR tv307[ebp], eax
  00397	d9 6d 98	 fldcw	 WORD PTR tv307[ebp]
  0039a	db 5d 94	 fistp	 DWORD PTR tv309[ebp]
  0039d	d9 6d 9e	 fldcw	 WORD PTR tv304[ebp]
  003a0	8a 45 94	 mov	 al, BYTE PTR tv309[ebp]
  003a3	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  003a6	6b c9 06	 imul	 ecx, 6
  003a9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003ac	88 44 0a 09	 mov	 BYTE PTR [edx+ecx+9], al

; 104  : 
; 105  : 			if ( this->BagObject[n].m_op2 != 0 )

  003b0	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  003b3	6b c0 06	 imul	 eax, 6
  003b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b9	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  003be	85 d2		 test	 edx, edx
  003c0	74 17		 je	 SHORT $LN3@LoadItem

; 106  : 			{
; 107  : 				this->BagExItemCount++;

  003c2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003c5	8b 88 90 03 00
	00		 mov	 ecx, DWORD PTR [eax+912]
  003cb	83 c1 01	 add	 ecx, 1
  003ce	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003d1	89 8a 90 03 00
	00		 mov	 DWORD PTR [edx+912], ecx

; 108  : 			}
; 109  : 			else

  003d7	eb 15		 jmp	 SHORT $LN2@LoadItem
$LN3@LoadItem:

; 110  : 			{
; 111  : 				this->BagNormalItemCount++;

  003d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003dc	8b 88 8c 03 00
	00		 mov	 ecx, DWORD PTR [eax+908]
  003e2	83 c1 01	 add	 ecx, 1
  003e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003e8	89 8a 8c 03 00
	00		 mov	 DWORD PTR [edx+908], ecx
$LN2@LoadItem:

; 112  : 			}
; 113  : 
; 114  : 			this->BagObjectCount++;

  003ee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003f1	8b 88 88 03 00
	00		 mov	 ecx, DWORD PTR [eax+904]
  003f7	83 c1 01	 add	 ecx, 1
  003fa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003fd	89 8a 88 03 00
	00		 mov	 DWORD PTR [edx+904], ecx

; 115  : 
; 116  : 			if ( this->BagObjectCount > MAX_ITEMBAG_ATTR-1 )

  00403	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00406	81 b8 88 03 00
	00 95 00 00 00	 cmp	 DWORD PTR [eax+904], 149 ; 00000095H
  00410	7e 02		 jle	 SHORT $LN1@LoadItem

; 117  : 			{
; 118  : 				break;

  00412	eb 05		 jmp	 SHORT $LN9@LoadItem
$LN1@LoadItem:

; 119  : 			}
; 120  : 		}
; 121  : 	}

  00414	e9 1e fd ff ff	 jmp	 $LN10@LoadItem
$LN9@LoadItem:

; 122  : 
; 123  : 	fclose(SMDFile);

  00419	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 _fclose
  00424	83 c4 04	 add	 esp, 4

; 124  : 
; 125  : 	LogAdd(lMsg.Get(MSGGET(1, 198)), script_file);

  00427	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  0042a	50		 push	 eax
  0042b	68 c6 01 00 00	 push	 454			; 000001c6H
  00430	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00435	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0043a	50		 push	 eax
  0043b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00441	83 c4 08	 add	 esp, 8
$LN12@LoadItem:

; 126  : }

  00444	5f		 pop	 edi
  00445	5e		 pop	 esi
  00446	5b		 pop	 ebx
  00447	8b e5		 mov	 esp, ebp
  00449	5d		 pop	 ebp
  0044a	c2 04 00	 ret	 4
?LoadItem@CItemBag@@UAEXPAD@Z ENDP			; CItemBag::LoadItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00450	55		 push	 ebp
  00451	8b ec		 mov	 ebp, esp
  00453	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00459	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0045e	33 c5		 xor	 eax, ebp
  00460	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00463	53		 push	 ebx
  00464	56		 push	 esi
  00465	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00466	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0046d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00472	50		 push	 eax
  00473	e8 00 00 00 00	 call	 _fgetc
  00478	83 c4 04	 add	 esp, 4
  0047b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0047e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00482	83 f9 ff	 cmp	 ecx, -1
  00485	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00487	b8 02 00 00 00	 mov	 eax, 2
  0048c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00491	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00493	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00497	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0049a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0049c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004a1	50		 push	 eax
  004a2	e8 00 00 00 00	 call	 _fgetc
  004a7	83 c4 04	 add	 esp, 4
  004aa	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004ad	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004b1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  004b4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  004b6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ba	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  004bd	74 1c		 je	 SHORT $LN23@GetToken
  004bf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004c3	83 f8 ff	 cmp	 eax, -1
  004c6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  004c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004cd	50		 push	 eax
  004ce	e8 00 00 00 00	 call	 _fgetc
  004d3	83 c4 04	 add	 esp, 4
  004d6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  004d9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  004db	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004df	83 f8 ff	 cmp	 eax, -1
  004e2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  004e4	b8 02 00 00 00	 mov	 eax, 2
  004e9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  004ee	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004f2	50		 push	 eax
  004f3	e8 00 00 00 00	 call	 _isspace
  004f8	83 c4 04	 add	 esp, 4
  004fb	85 c0		 test	 eax, eax
  004fd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00503	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00507	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0050d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00513	83 e9 22	 sub	 ecx, 34			; 00000022H
  00516	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0051c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00523	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00529	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0052f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00536	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0053d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00547	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0054c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00551	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00556	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00560	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00565	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0056a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0056f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00579	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0057e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00583	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00588	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00592	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00597	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0059c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  005a1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  005ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005b0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  005b5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  005ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005bf	50		 push	 eax
  005c0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005c4	51		 push	 ecx
  005c5	e8 00 00 00 00	 call	 _ungetc
  005ca	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  005cd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  005d0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  005d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005d8	50		 push	 eax
  005d9	e8 00 00 00 00	 call	 _getc
  005de	83 c4 04	 add	 esp, 4
  005e1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005e4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005e8	83 f9 ff	 cmp	 ecx, -1
  005eb	74 36		 je	 SHORT $LN12@GetToken
  005ed	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005f1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  005f4	74 1a		 je	 SHORT $LN11@GetToken
  005f6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005fa	50		 push	 eax
  005fb	e8 00 00 00 00	 call	 _isdigit
  00600	83 c4 04	 add	 esp, 4
  00603	85 c0		 test	 eax, eax
  00605	75 09		 jne	 SHORT $LN11@GetToken
  00607	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0060b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0060e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00610	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00613	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00616	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00618	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0061b	83 c0 01	 add	 eax, 1
  0061e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00621	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00623	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00626	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00629	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0062c	50		 push	 eax
  0062d	e8 00 00 00 00	 call	 _atof
  00632	83 c4 04	 add	 esp, 4
  00635	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0063b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00645	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0064a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0064f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00654	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0065b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00660	50		 push	 eax
  00661	e8 00 00 00 00	 call	 _getc
  00666	83 c4 04	 add	 esp, 4
  00669	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0066c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00670	83 f9 ff	 cmp	 ecx, -1
  00673	74 1c		 je	 SHORT $LN8@GetToken
  00675	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00679	83 f8 22	 cmp	 eax, 34			; 00000022H
  0067c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0067e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00681	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00684	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00686	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00689	83 c0 01	 add	 eax, 1
  0068c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0068f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00691	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00695	83 f8 22	 cmp	 eax, 34			; 00000022H
  00698	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0069a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0069f	50		 push	 eax
  006a0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006a4	51		 push	 ecx
  006a5	e8 00 00 00 00	 call	 _ungetc
  006aa	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  006ad	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  006b3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  006bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006c2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  006c7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  006cc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006d0	50		 push	 eax
  006d1	e8 00 00 00 00	 call	 _isalpha
  006d6	83 c4 04	 add	 esp, 4
  006d9	85 c0		 test	 eax, eax
  006db	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  006e1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  006e8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006eb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  006ee	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  006f0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006f3	83 c0 01	 add	 eax, 1
  006f6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  006f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006fe	50		 push	 eax
  006ff	e8 00 00 00 00	 call	 _getc
  00704	83 c4 04	 add	 esp, 4
  00707	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0070a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0070e	83 f9 ff	 cmp	 ecx, -1
  00711	74 36		 je	 SHORT $LN3@GetToken
  00713	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00717	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0071a	74 1a		 je	 SHORT $LN2@GetToken
  0071c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00720	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00723	74 11		 je	 SHORT $LN2@GetToken
  00725	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00729	50		 push	 eax
  0072a	e8 00 00 00 00	 call	 _isalnum
  0072f	83 c4 04	 add	 esp, 4
  00732	85 c0		 test	 eax, eax
  00734	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00736	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00739	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0073c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0073e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00741	83 c0 01	 add	 eax, 1
  00744	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00747	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00749	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0074e	50		 push	 eax
  0074f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00753	51		 push	 ecx
  00754	e8 00 00 00 00	 call	 _ungetc
  00759	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0075c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0075f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00762	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0076c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00771	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00773	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00775	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0077f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00784	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00786	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00788	5f		 pop	 edi
  00789	5e		 pop	 esi
  0078a	5b		 pop	 ebx
  0078b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0078e	33 cd		 xor	 ecx, ebp
  00790	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00795	8b e5		 mov	 esp, ebp
  00797	5d		 pop	 ebp
  00798	c3		 ret	 0
  00799	8d 49 00	 npad	 3
$LN35@GetToken:
  0079c	00 00 00 00	 DD	 $LN10@GetToken
  007a0	00 00 00 00	 DD	 $LN19@GetToken
  007a4	00 00 00 00	 DD	 $LN17@GetToken
  007a8	00 00 00 00	 DD	 $LN14@GetToken
  007ac	00 00 00 00	 DD	 $LN18@GetToken
  007b0	00 00 00 00	 DD	 $LN16@GetToken
  007b4	00 00 00 00	 DD	 $LN15@GetToken
  007b8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  007bc	00		 DB	 0
  007bd	01		 DB	 1
  007be	07		 DB	 7
  007bf	07		 DB	 7
  007c0	07		 DB	 7
  007c1	07		 DB	 7
  007c2	07		 DB	 7
  007c3	07		 DB	 7
  007c4	07		 DB	 7
  007c5	07		 DB	 7
  007c6	02		 DB	 2
  007c7	03		 DB	 3
  007c8	03		 DB	 3
  007c9	07		 DB	 7
  007ca	03		 DB	 3
  007cb	03		 DB	 3
  007cc	03		 DB	 3
  007cd	03		 DB	 3
  007ce	03		 DB	 3
  007cf	03		 DB	 3
  007d0	03		 DB	 3
  007d1	03		 DB	 3
  007d2	03		 DB	 3
  007d3	03		 DB	 3
  007d4	07		 DB	 7
  007d5	04		 DB	 4
  007d6	07		 DB	 7
  007d7	07		 DB	 7
  007d8	07		 DB	 7
  007d9	07		 DB	 7
  007da	07		 DB	 7
  007db	07		 DB	 7
  007dc	07		 DB	 7
  007dd	07		 DB	 7
  007de	07		 DB	 7
  007df	07		 DB	 7
  007e0	07		 DB	 7
  007e1	07		 DB	 7
  007e2	07		 DB	 7
  007e3	07		 DB	 7
  007e4	07		 DB	 7
  007e5	07		 DB	 7
  007e6	07		 DB	 7
  007e7	07		 DB	 7
  007e8	07		 DB	 7
  007e9	07		 DB	 7
  007ea	07		 DB	 7
  007eb	07		 DB	 7
  007ec	07		 DB	 7
  007ed	07		 DB	 7
  007ee	07		 DB	 7
  007ef	07		 DB	 7
  007f0	07		 DB	 7
  007f1	07		 DB	 7
  007f2	07		 DB	 7
  007f3	07		 DB	 7
  007f4	07		 DB	 7
  007f5	07		 DB	 7
  007f6	07		 DB	 7
  007f7	07		 DB	 7
  007f8	07		 DB	 7
  007f9	07		 DB	 7
  007fa	07		 DB	 7
  007fb	07		 DB	 7
  007fc	07		 DB	 7
  007fd	07		 DB	 7
  007fe	07		 DB	 7
  007ff	07		 DB	 7
  00800	07		 DB	 7
  00801	07		 DB	 7
  00802	07		 DB	 7
  00803	07		 DB	 7
  00804	07		 DB	 7
  00805	07		 DB	 7
  00806	07		 DB	 7
  00807	07		 DB	 7
  00808	07		 DB	 7
  00809	07		 DB	 7
  0080a	07		 DB	 7
  0080b	07		 DB	 7
  0080c	07		 DB	 7
  0080d	07		 DB	 7
  0080e	07		 DB	 7
  0080f	07		 DB	 7
  00810	07		 DB	 7
  00811	07		 DB	 7
  00812	07		 DB	 7
  00813	07		 DB	 7
  00814	07		 DB	 7
  00815	05		 DB	 5
  00816	07		 DB	 7
  00817	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\itembag.cpp
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetType@CItemBag@@UAEEH@Z PROC				; CItemBag::GetType
; _this$ = ecx

; 129  : {

  00820	55		 push	 ebp
  00821	8b ec		 mov	 ebp, esp
  00823	83 ec 44	 sub	 esp, 68			; 00000044H
  00826	53		 push	 ebx
  00827	56		 push	 esi
  00828	57		 push	 edi
  00829	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	if ( n< 0 || n > MAX_ITEMBAG_ATTR-1 )

  0082c	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  00830	7c 09		 jl	 SHORT $LN1@GetType
  00832	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  00839	7e 04		 jle	 SHORT $LN2@GetType
$LN1@GetType:

; 131  : 	{
; 132  : 		return 0;

  0083b	32 c0		 xor	 al, al
  0083d	eb 0d		 jmp	 SHORT $LN3@GetType
$LN2@GetType:

; 133  : 	}
; 134  : 
; 135  : 	return this->BagObject[n].m_type;

  0083f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00842	6b c0 06	 imul	 eax, 6
  00845	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00848	8a 44 01 04	 mov	 al, BYTE PTR [ecx+eax+4]
$LN3@GetType:

; 136  : }

  0084c	5f		 pop	 edi
  0084d	5e		 pop	 esi
  0084e	5b		 pop	 ebx
  0084f	8b e5		 mov	 esp, ebp
  00851	5d		 pop	 ebp
  00852	c2 04 00	 ret	 4
?GetType@CItemBag@@UAEEH@Z ENDP				; CItemBag::GetType
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetIndex@CItemBag@@UAEEH@Z PROC			; CItemBag::GetIndex
; _this$ = ecx

; 139  : {

  00860	55		 push	 ebp
  00861	8b ec		 mov	 ebp, esp
  00863	83 ec 44	 sub	 esp, 68			; 00000044H
  00866	53		 push	 ebx
  00867	56		 push	 esi
  00868	57		 push	 edi
  00869	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	if ( n< 0 || n > MAX_ITEMBAG_ATTR-1 )

  0086c	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  00870	7c 09		 jl	 SHORT $LN1@GetIndex
  00872	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  00879	7e 04		 jle	 SHORT $LN2@GetIndex
$LN1@GetIndex:

; 141  : 	{
; 142  : 		return 0;

  0087b	32 c0		 xor	 al, al
  0087d	eb 0d		 jmp	 SHORT $LN3@GetIndex
$LN2@GetIndex:

; 143  : 	}
; 144  : 
; 145  : 	return this->BagObject[n].m_index;

  0087f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00882	6b c0 06	 imul	 eax, 6
  00885	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00888	8a 44 01 05	 mov	 al, BYTE PTR [ecx+eax+5]
$LN3@GetIndex:

; 146  : }

  0088c	5f		 pop	 edi
  0088d	5e		 pop	 esi
  0088e	5b		 pop	 ebx
  0088f	8b e5		 mov	 esp, ebp
  00891	5d		 pop	 ebp
  00892	c2 04 00	 ret	 4
?GetIndex@CItemBag@@UAEEH@Z ENDP			; CItemBag::GetIndex
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetLevel@CItemBag@@UAEEH@Z PROC			; CItemBag::GetLevel
; _this$ = ecx

; 150  : {

  008a0	55		 push	 ebp
  008a1	8b ec		 mov	 ebp, esp
  008a3	83 ec 44	 sub	 esp, 68			; 00000044H
  008a6	53		 push	 ebx
  008a7	56		 push	 esi
  008a8	57		 push	 edi
  008a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	if ( n< 0 || n > MAX_ITEMBAG_ATTR-1 )

  008ac	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  008b0	7c 09		 jl	 SHORT $LN1@GetLevel
  008b2	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  008b9	7e 04		 jle	 SHORT $LN2@GetLevel
$LN1@GetLevel:

; 152  : 	{
; 153  : 		return 0;

  008bb	32 c0		 xor	 al, al
  008bd	eb 0d		 jmp	 SHORT $LN3@GetLevel
$LN2@GetLevel:

; 154  : 	}
; 155  : 
; 156  : 	return this->BagObject[n].m_level;

  008bf	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  008c2	6b c0 06	 imul	 eax, 6
  008c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008c8	8a 44 01 06	 mov	 al, BYTE PTR [ecx+eax+6]
$LN3@GetLevel:

; 157  : }

  008cc	5f		 pop	 edi
  008cd	5e		 pop	 esi
  008ce	5b		 pop	 ebx
  008cf	8b e5		 mov	 esp, ebp
  008d1	5d		 pop	 ebp
  008d2	c2 04 00	 ret	 4
?GetLevel@CItemBag@@UAEEH@Z ENDP			; CItemBag::GetLevel
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetOp1@CItemBag@@UAEEH@Z PROC				; CItemBag::GetOp1
; _this$ = ecx

; 161  : {

  008e0	55		 push	 ebp
  008e1	8b ec		 mov	 ebp, esp
  008e3	83 ec 44	 sub	 esp, 68			; 00000044H
  008e6	53		 push	 ebx
  008e7	56		 push	 esi
  008e8	57		 push	 edi
  008e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	if ( n< 0 || n > MAX_ITEMBAG_ATTR-1 )

  008ec	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  008f0	7c 09		 jl	 SHORT $LN1@GetOp1
  008f2	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  008f9	7e 04		 jle	 SHORT $LN2@GetOp1
$LN1@GetOp1:

; 163  : 	{
; 164  : 		return 0;

  008fb	32 c0		 xor	 al, al
  008fd	eb 0d		 jmp	 SHORT $LN3@GetOp1
$LN2@GetOp1:

; 165  : 	}
; 166  : 
; 167  : 	return this->BagObject[n].m_op1;

  008ff	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00902	6b c0 06	 imul	 eax, 6
  00905	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00908	8a 44 01 07	 mov	 al, BYTE PTR [ecx+eax+7]
$LN3@GetOp1:

; 168  : }

  0090c	5f		 pop	 edi
  0090d	5e		 pop	 esi
  0090e	5b		 pop	 ebx
  0090f	8b e5		 mov	 esp, ebp
  00911	5d		 pop	 ebp
  00912	c2 04 00	 ret	 4
?GetOp1@CItemBag@@UAEEH@Z ENDP				; CItemBag::GetOp1
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetOp2@CItemBag@@UAEEH@Z PROC				; CItemBag::GetOp2
; _this$ = ecx

; 172  : {

  00920	55		 push	 ebp
  00921	8b ec		 mov	 ebp, esp
  00923	83 ec 44	 sub	 esp, 68			; 00000044H
  00926	53		 push	 ebx
  00927	56		 push	 esi
  00928	57		 push	 edi
  00929	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 173  : 	if ( n< 0 || n > MAX_ITEMBAG_ATTR-1 )

  0092c	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  00930	7c 09		 jl	 SHORT $LN1@GetOp2
  00932	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  00939	7e 04		 jle	 SHORT $LN2@GetOp2
$LN1@GetOp2:

; 174  : 	{
; 175  : 		return 0;

  0093b	32 c0		 xor	 al, al
  0093d	eb 0d		 jmp	 SHORT $LN3@GetOp2
$LN2@GetOp2:

; 176  : 	}
; 177  : 
; 178  : 	return this->BagObject[n].m_op2;

  0093f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00942	6b c0 06	 imul	 eax, 6
  00945	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00948	8a 44 01 08	 mov	 al, BYTE PTR [ecx+eax+8]
$LN3@GetOp2:

; 179  : }

  0094c	5f		 pop	 edi
  0094d	5e		 pop	 esi
  0094e	5b		 pop	 ebx
  0094f	8b e5		 mov	 esp, ebp
  00951	5d		 pop	 ebp
  00952	c2 04 00	 ret	 4
?GetOp2@CItemBag@@UAEEH@Z ENDP				; CItemBag::GetOp2
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetOp3@CItemBag@@UAEEH@Z PROC				; CItemBag::GetOp3
; _this$ = ecx

; 183  : {

  00960	55		 push	 ebp
  00961	8b ec		 mov	 ebp, esp
  00963	83 ec 44	 sub	 esp, 68			; 00000044H
  00966	53		 push	 ebx
  00967	56		 push	 esi
  00968	57		 push	 edi
  00969	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	if ( n< 0 || n > MAX_ITEMBAG_ATTR-1 )

  0096c	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  00970	7c 09		 jl	 SHORT $LN1@GetOp3
  00972	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  00979	7e 04		 jle	 SHORT $LN2@GetOp3
$LN1@GetOp3:

; 185  : 	{
; 186  : 		return 0;

  0097b	32 c0		 xor	 al, al
  0097d	eb 0d		 jmp	 SHORT $LN3@GetOp3
$LN2@GetOp3:

; 187  : 	}
; 188  : 
; 189  : 	return this->BagObject[n].m_op3;

  0097f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00982	6b c0 06	 imul	 eax, 6
  00985	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00988	8a 44 01 09	 mov	 al, BYTE PTR [ecx+eax+9]
$LN3@GetOp3:

; 190  : }

  0098c	5f		 pop	 edi
  0098d	5e		 pop	 esi
  0098e	5b		 pop	 ebx
  0098f	8b e5		 mov	 esp, ebp
  00991	5d		 pop	 ebp
  00992	c2 04 00	 ret	 4
?GetOp3@CItemBag@@UAEEH@Z ENDP				; CItemBag::GetOp3
_TEXT	ENDS
END
