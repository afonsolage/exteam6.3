; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\TeleportManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
PUBLIC	??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
PUBLIC	??0cTeleportManager@@QAE@XZ			; cTeleportManager::cTeleportManager
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0cTeleportManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0cTeleportManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0cTeleportManager@@QAE@XZ$1
__ehfuncinfo$??0cTeleportManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0cTeleportManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\teleportmanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0cTeleportManager@@QAE@XZ PROC			; cTeleportManager::cTeleportManager
; _this$ = ecx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0cTeleportManager@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  00034	e8 00 00 00 00	 call	 ??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  00049	e8 00 00 00 00	 call	 ??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
  0004e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	81 c1 ec 2b 00
	00		 add	 ecx, 11244		; 00002becH
  0005b	e8 00 00 00 00	 call	 ??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >

; 16   : 
; 17   : }

  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0cTeleportManager@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
__unwindfunclet$??0cTeleportManager@@QAE@XZ$1:
  0000e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  00017	e9 00 00 00 00	 jmp	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
__ehhandler$??0cTeleportManager@@QAE@XZ:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0cTeleportManager@@QAE@XZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0cTeleportManager@@QAE@XZ ENDP			; cTeleportManager::cTeleportManager
PUBLIC	??1cTeleportManager@@QAE@XZ			; cTeleportManager::~cTeleportManager
xdata$x	SEGMENT
__unwindtable$??1cTeleportManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1cTeleportManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1cTeleportManager@@QAE@XZ$1
__ehfuncinfo$??1cTeleportManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1cTeleportManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1cTeleportManager@@QAE@XZ PROC			; cTeleportManager::~cTeleportManager
; _this$ = ecx

; 20   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	6a ff		 push	 -1
  00085	68 00 00 00 00	 push	 __ehhandler$??1cTeleportManager@@QAE@XZ
  0008a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00090	50		 push	 eax
  00091	83 ec 44	 sub	 esp, 68			; 00000044H
  00094	53		 push	 ebx
  00095	56		 push	 esi
  00096	57		 push	 edi
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0009c	33 c5		 xor	 eax, ebp
  0009e	50		 push	 eax
  0009f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  000a2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  000a8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  000ab	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 21   : 
; 22   : }

  000b2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	81 c1 ec 2b 00
	00		 add	 ecx, 11244		; 00002becH
  000bb	e8 00 00 00 00	 call	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
  000c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  000cd	e8 00 00 00 00	 call	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
  000d2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  000e2	e8 00 00 00 00	 call	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
  000e7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f1	59		 pop	 ecx
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1cTeleportManager@@QAE@XZ$0:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  00040	e9 00 00 00 00	 jmp	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
__unwindfunclet$??1cTeleportManager@@QAE@XZ$1:
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  0004e	e9 00 00 00 00	 jmp	 ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
__ehhandler$??1cTeleportManager@@QAE@XZ:
  00053	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00057	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005a	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0005d	33 c8		 xor	 ecx, eax
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1cTeleportManager@@QAE@XZ
  00069	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1cTeleportManager@@QAE@XZ ENDP			; cTeleportManager::~cTeleportManager
PUBLIC	?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::push_back
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0CD@MBABJFMK@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CH@DDKHOEJN@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0CJ@OKAPPHKC@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CN@OBHGOHPF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	?clear@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::clear
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_06MLPMCPDE@ExTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0CD@JKINLBEG@?4?4?2Data?2ExData?2TeleportManager?4i@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cTeleportManager@@QAEXXZ			; cTeleportManager::Load
EXTRN	_fclose:PROC
EXTRN	_sprintf:PROC
EXTRN	_sscanf:PROC
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
EXTRN	?Ex_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Ex_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	_memset:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MBABJFMK@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@
CONST	SEGMENT
??_C@_0CD@MBABJFMK@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@ DB '"'
	DB	'%[^"]" %d %d %d %d %d %d %d %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DDKHOEJN@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0CH@DDKHOEJN@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d %d %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OKAPPHKC@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@
CONST	SEGMENT
??_C@_0CJ@OKAPPHKC@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@ DB '"'
	DB	'%[^"]" %d %d %d %d %d %d %d %d %d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OBHGOHPF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0CN@OBHGOHPF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d %d %d %d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLPMCPDE@ExTeam?$AA@
CONST	SEGMENT
??_C@_06MLPMCPDE@ExTeam?$AA@ DB 'ExTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JKINLBEG@?4?4?2Data?2ExData?2TeleportManager?4i@
CONST	SEGMENT
??_C@_0CD@JKINLBEG@?4?4?2Data?2ExData?2TeleportManager?4i@ DB '..\Data\Ex'
	DB	'Data\TeleportManager.ini', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_List$220836 = -592					; size = 4
_n$220835 = -588					; size = 4
_List$220833 = -584					; size = 4
_n$220832 = -580					; size = 4
_List$220828 = -576					; size = 4
_n$220827 = -572					; size = 4
_n$220822 = -568					; size = 36
_mes$220821 = -532					; size = 50
_n$220818 = -480					; size = 52
_n$220813 = -428					; size = 44
_mes$220812 = -384					; size = 50
_n$220809 = -332					; size = 60
_Flag$ = -272						; size = 4
_Buff$ = -268						; size = 256
_file$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Load@cTeleportManager@@QAEXXZ PROC			; cTeleportManager::Load
; _this$ = ecx

; 25   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	81 ec 90 02 00
	00		 sub	 esp, 656		; 00000290H
  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0010e	33 c5		 xor	 eax, ebp
  00110	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00113	53		 push	 ebx
  00114	56		 push	 esi
  00115	57		 push	 edi
  00116	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 	this->Enable = GetPrivateProfileInt("ExTeam","Enable",0,TeleportManager_DIR);

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JKINLBEG@?4?4?2Data?2ExData?2TeleportManager?4i@
  0011e	6a 00		 push	 0
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_06MLPMCPDE@ExTeam?$AA@
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00130	85 c0		 test	 eax, eax
  00132	0f 95 c0	 setne	 al
  00135	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	88 01		 mov	 BYTE PTR [ecx], al

; 27   : 
; 28   : 	ZeroMemory(this->NpcBase,sizeof(NpcBase));

  0013a	68 10 0e 00 00	 push	 3600			; 00000e10H
  0013f	6a 00		 push	 0
  00141	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00144	83 c0 04	 add	 eax, 4
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _memset
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29   : 	ZeroMemory(this->CmdBase,sizeof(CmdBase));

  00150	68 b0 1d 00 00	 push	 7600			; 00001db0H
  00155	6a 00		 push	 0
  00157	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0015a	05 14 0e 00 00	 add	 eax, 3604		; 00000e14H
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _memset
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30   : 
; 31   : 	FILE * file = fopen(TeleportManager_DIR,"r");

  00168	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JKINLBEG@?4?4?2Data?2ExData?2TeleportManager?4i@
  00172	e8 00 00 00 00	 call	 _fopen
  00177	83 c4 08	 add	 esp, 8
  0017a	89 45 f4	 mov	 DWORD PTR _file$[ebp], eax

; 32   : 
; 33   : 	if(file == NULL)

  0017d	83 7d f4 00	 cmp	 DWORD PTR _file$[ebp], 0
  00181	75 1a		 jne	 SHORT $LN19@Load

; 34   : 	{
; 35   : 		MessageBoxA(0,TeleportManager_DIR,"LOAD FILE ERROR",0);

  00183	6a 00		 push	 0
  00185	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JKINLBEG@?4?4?2Data?2ExData?2TeleportManager?4i@
  0018f	6a 00		 push	 0
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 36   : 		this->Enable = false;

  00197	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN19@Load:

; 37   : 	}
; 38   : 
; 39   : 	if(!this->Enable) return;

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001a3	85 c9		 test	 ecx, ecx
  001a5	75 05		 jne	 SHORT $LN18@Load
  001a7	e9 28 0a 00 00	 jmp	 $LN20@Load
$LN18@Load:

; 40   : 
; 41   : 	char Buff[256];
; 42   : 	int Flag = 0;

  001ac	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _Flag$[ebp], 0

; 43   : 
; 44   : 	this->CountNPC = 0;

  001b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	c7 80 c4 2b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+11204], 0

; 45   : 	this->CountCMD = 0;

  001c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001c6	c7 80 c8 2b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+11208], 0

; 46   : 
; 47   : 	this->m_DLMasterBlock.clear();

  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  001d9	e8 00 00 00 00	 call	 ?clear@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::clear

; 48   : 	this->m_DLMemberBlock.clear();

  001de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e1	81 c1 ec 2b 00
	00		 add	 ecx, 11244		; 00002becH
  001e7	e8 00 00 00 00	 call	 ?clear@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::clear
$LN17@Load:

; 49   : 
; 50   : 	while(!feof(file))

  001ec	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _feof
  001f5	83 c4 04	 add	 esp, 4
  001f8	85 c0		 test	 eax, eax
  001fa	0f 85 c8 09 00
	00		 jne	 $LN16@Load

; 51   : 	{
; 52   : 		fgets(Buff,256,file);

  00200	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  00203	50		 push	 eax
  00204	68 00 01 00 00	 push	 256			; 00000100H
  00209	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _fgets
  00215	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 		if(Ex_IsBadFileLine(Buff, Flag))

  00218	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Flag$[ebp]
  0021e	50		 push	 eax
  0021f	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ?Ex_IsBadFileLine@@YA_NPADAAH@Z ; Ex_IsBadFileLine
  0022b	83 c4 08	 add	 esp, 8
  0022e	0f b6 d0	 movzx	 edx, al
  00231	85 d2		 test	 edx, edx
  00233	74 02		 je	 SHORT $LN15@Load

; 54   : 			continue;

  00235	eb b5		 jmp	 SHORT $LN17@Load
$LN15@Load:

; 55   : 
; 56   : 		if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 57   : 			g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 58   : 			g_ExLicense.CheckUser(eExUB::SILVER2)	 ||
; 59   : 			g_ExLicense.CheckUser(eExUB::Gredy)		 || 
; 60   : 			g_ExLicense.CheckUser(eExUB::GredyLocal) || 
; 61   : 			g_ExLicense.CheckUser(eExUB::Gredy2) )

  00237	6a 00		 push	 0
  00239	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0023e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00243	0f b6 c0	 movzx	 eax, al
  00246	85 c0		 test	 eax, eax
  00248	75 63		 jne	 SHORT $LN13@Load
  0024a	6a 07		 push	 7
  0024c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00251	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00256	0f b6 c0	 movzx	 eax, al
  00259	85 c0		 test	 eax, eax
  0025b	75 50		 jne	 SHORT $LN13@Load
  0025d	6a 08		 push	 8
  0025f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00264	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00269	0f b6 c0	 movzx	 eax, al
  0026c	85 c0		 test	 eax, eax
  0026e	75 3d		 jne	 SHORT $LN13@Load
  00270	6a 20		 push	 32			; 00000020H
  00272	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00277	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0027c	0f b6 c0	 movzx	 eax, al
  0027f	85 c0		 test	 eax, eax
  00281	75 2a		 jne	 SHORT $LN13@Load
  00283	6a 21		 push	 33			; 00000021H
  00285	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0028a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0028f	0f b6 c0	 movzx	 eax, al
  00292	85 c0		 test	 eax, eax
  00294	75 17		 jne	 SHORT $LN13@Load
  00296	6a 22		 push	 34			; 00000022H
  00298	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0029d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  002a2	0f b6 c0	 movzx	 eax, al
  002a5	85 c0		 test	 eax, eax
  002a7	0f 84 30 04 00
	00		 je	 $LN14@Load
$LN13@Load:

; 62   : 		{
; 63   : 			if(Flag == 1)

  002ad	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR _Flag$[ebp], 1
  002b4	0f 85 23 02 00
	00		 jne	 $LN12@Load

; 64   : 			{
; 65   : 				int n[15];
; 66   : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &n[0], &n[1], &n[2], &n[3], &n[4], &n[5], &n[6], &n[7], &n[8], &n[9], &n[10], &n[11], &n[12], &n[13], &n[14]);

  002ba	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _n$220809[ebp+56]
  002c0	50		 push	 eax
  002c1	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220809[ebp+52]
  002c7	51		 push	 ecx
  002c8	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _n$220809[ebp+48]
  002ce	52		 push	 edx
  002cf	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _n$220809[ebp+44]
  002d5	50		 push	 eax
  002d6	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _n$220809[ebp+40]
  002dc	51		 push	 ecx
  002dd	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _n$220809[ebp+36]
  002e3	52		 push	 edx
  002e4	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _n$220809[ebp+32]
  002ea	50		 push	 eax
  002eb	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220809[ebp+28]
  002f1	51		 push	 ecx
  002f2	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _n$220809[ebp+24]
  002f8	52		 push	 edx
  002f9	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _n$220809[ebp+20]
  002ff	50		 push	 eax
  00300	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220809[ebp+16]
  00306	51		 push	 ecx
  00307	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _n$220809[ebp+12]
  0030d	52		 push	 edx
  0030e	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _n$220809[ebp+8]
  00314	50		 push	 eax
  00315	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220809[ebp+4]
  0031b	51		 push	 ecx
  0031c	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _n$220809[ebp]
  00322	52		 push	 edx
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@OBHGOHPF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  00328	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 _sscanf
  00334	83 c4 44	 add	 esp, 68			; 00000044H

; 67   : 				this->NpcBase[this->CountNPC].NPC			= n[0];

  00337	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0033a	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00340	6b c9 24	 imul	 ecx, 36			; 00000024H
  00343	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00346	66 8b 85 b4 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp]
  0034d	66 89 44 0a 04	 mov	 WORD PTR [edx+ecx+4], ax

; 68   : 				this->NpcBase[this->CountNPC].MAP			= n[1];

  00352	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00355	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0035b	6b c9 24	 imul	 ecx, 36			; 00000024H
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00361	66 8b 85 b8 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+4]
  00368	66 89 44 0a 06	 mov	 WORD PTR [edx+ecx+6], ax

; 69   : 				this->NpcBase[this->CountNPC].X				= n[2];

  0036d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00370	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00376	6b c9 24	 imul	 ecx, 36			; 00000024H
  00379	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0037c	66 8b 85 bc fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+8]
  00383	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 70   : 				this->NpcBase[this->CountNPC].Y				= n[3];

  00388	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0038b	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00391	6b c9 24	 imul	 ecx, 36			; 00000024H
  00394	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00397	66 8b 85 c0 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+12]
  0039e	66 89 44 0a 0a	 mov	 WORD PTR [edx+ecx+10], ax

; 71   : 				this->NpcBase[this->CountNPC].TeleportMap	= n[4];

  003a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003a6	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  003ac	6b c9 24	 imul	 ecx, 36			; 00000024H
  003af	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003b2	66 8b 85 c4 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+16]
  003b9	66 89 44 0a 0c	 mov	 WORD PTR [edx+ecx+12], ax

; 72   : 				this->NpcBase[this->CountNPC].TeleportX		= n[5];

  003be	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c1	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  003c7	6b c9 24	 imul	 ecx, 36			; 00000024H
  003ca	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003cd	66 8b 85 c8 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+20]
  003d4	66 89 44 0a 0e	 mov	 WORD PTR [edx+ecx+14], ax

; 73   : 				this->NpcBase[this->CountNPC].TeleportY		= n[6];

  003d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003dc	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  003e2	6b c9 24	 imul	 ecx, 36			; 00000024H
  003e5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003e8	66 8b 85 cc fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+24]
  003ef	66 89 44 0a 10	 mov	 WORD PTR [edx+ecx+16], ax

; 74   : 				this->NpcBase[this->CountNPC].Level			= n[7];

  003f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f7	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  003fd	6b c9 24	 imul	 ecx, 36			; 00000024H
  00400	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00403	66 8b 85 d0 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+28]
  0040a	66 89 44 0a 12	 mov	 WORD PTR [edx+ecx+18], ax

; 75   : 				this->NpcBase[this->CountNPC].Reset			= n[8];

  0040f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00412	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00418	6b c9 24	 imul	 ecx, 36			; 00000024H
  0041b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0041e	66 8b 85 d4 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+32]
  00425	66 89 44 0a 14	 mov	 WORD PTR [edx+ecx+20], ax

; 76   : 				this->NpcBase[this->CountNPC].GReset		= n[9];

  0042a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0042d	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00433	6b c9 24	 imul	 ecx, 36			; 00000024H
  00436	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00439	66 8b 85 d8 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+36]
  00440	66 89 44 0a 16	 mov	 WORD PTR [edx+ecx+22], ax

; 77   : 				this->NpcBase[this->CountNPC].MaxReset		= n[10];

  00445	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00448	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0044e	6b c9 24	 imul	 ecx, 36			; 00000024H
  00451	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00454	66 8b 85 dc fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+40]
  0045b	66 89 44 0a 18	 mov	 WORD PTR [edx+ecx+24], ax

; 78   : 				this->NpcBase[this->CountNPC].MaxGReset		= n[11];

  00460	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00463	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00469	6b c9 24	 imul	 ecx, 36			; 00000024H
  0046c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0046f	66 8b 85 e0 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+44]
  00476	66 89 44 0a 1a	 mov	 WORD PTR [edx+ecx+26], ax

; 79   : 				this->NpcBase[this->CountNPC].Premium		= n[12];

  0047b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0047e	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00484	6b c9 24	 imul	 ecx, 36			; 00000024H
  00487	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0048a	66 8b 85 e4 fe
	ff ff		 mov	 ax, WORD PTR _n$220809[ebp+48]
  00491	66 89 44 0a 1c	 mov	 WORD PTR [edx+ecx+28], ax

; 80   : 				this->NpcBase[this->CountNPC].Price			= n[13];

  00496	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00499	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0049f	6b c9 24	 imul	 ecx, 36			; 00000024H
  004a2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  004a5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$220809[ebp+52]
  004ab	89 44 0a 20	 mov	 DWORD PTR [edx+ecx+32], eax

; 81   : 				this->NpcBase[this->CountNPC].Value			= n[14];

  004af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004b2	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  004b8	6b c9 24	 imul	 ecx, 36			; 00000024H
  004bb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  004be	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _n$220809[ebp+56]
  004c4	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax

; 82   : 				this->CountNPC++;

  004c8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004cb	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  004d1	83 c1 01	 add	 ecx, 1
  004d4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  004d7	89 8a c4 2b 00
	00		 mov	 DWORD PTR [edx+11204], ecx
$LN12@Load:

; 83   : 			}
; 84   : 
; 85   : 			if(Flag == 2)

  004dd	83 bd f0 fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  004e4	0f 85 ee 01 00
	00		 jne	 $LN11@Load

; 86   : 			{
; 87   : 				char mes[50];
; 88   : 				int n[11];
; 89   : 				sscanf(Buff, "\"%[^\"]\" %d %d %d %d %d %d %d %d %d %d %d", &mes, &n[0], &n[1], &n[2], &n[3], &n[4], &n[5], &n[6], &n[7], &n[8], &n[9], &n[10]);

  004ea	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _n$220813[ebp+40]
  004f0	50		 push	 eax
  004f1	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220813[ebp+36]
  004f7	51		 push	 ecx
  004f8	8d 95 74 fe ff
	ff		 lea	 edx, DWORD PTR _n$220813[ebp+32]
  004fe	52		 push	 edx
  004ff	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _n$220813[ebp+28]
  00505	50		 push	 eax
  00506	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _n$220813[ebp+24]
  0050c	51		 push	 ecx
  0050d	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR _n$220813[ebp+20]
  00513	52		 push	 edx
  00514	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _n$220813[ebp+16]
  0051a	50		 push	 eax
  0051b	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220813[ebp+12]
  00521	51		 push	 ecx
  00522	8d 95 5c fe ff
	ff		 lea	 edx, DWORD PTR _n$220813[ebp+8]
  00528	52		 push	 edx
  00529	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _n$220813[ebp+4]
  0052f	50		 push	 eax
  00530	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220813[ebp]
  00536	51		 push	 ecx
  00537	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR _mes$220812[ebp]
  0053d	52		 push	 edx
  0053e	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OKAPPHKC@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@
  00543	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00549	50		 push	 eax
  0054a	e8 00 00 00 00	 call	 _sscanf
  0054f	83 c4 38	 add	 esp, 56			; 00000038H

; 90   : 				sprintf(this->CmdBase[this->CountCMD].Command,"%s",mes);

  00552	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _mes$220812[ebp]
  00558	50		 push	 eax
  00559	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0055e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00561	8b 91 c8 2b 00
	00		 mov	 edx, DWORD PTR [ecx+11208]
  00567	6b d2 4c	 imul	 edx, 76			; 0000004cH
  0056a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0056d	8d 8c 10 14 0e
	00 00		 lea	 ecx, DWORD PTR [eax+edx+3604]
  00574	51		 push	 ecx
  00575	e8 00 00 00 00	 call	 _sprintf
  0057a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 				this->CmdBase[this->CountCMD].TeleportMap	= n[0];

  0057d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00580	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00586	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00589	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0058c	66 8b 85 54 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp]
  00593	66 89 84 0a 46
	0e 00 00	 mov	 WORD PTR [edx+ecx+3654], ax

; 92   : 				this->CmdBase[this->CountCMD].TeleportX		= n[1];

  0059b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0059e	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  005a4	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  005a7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005aa	66 8b 85 58 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+4]
  005b1	66 89 84 0a 48
	0e 00 00	 mov	 WORD PTR [edx+ecx+3656], ax

; 93   : 				this->CmdBase[this->CountCMD].TeleportY		= n[2];

  005b9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005bc	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  005c2	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  005c5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005c8	66 8b 85 5c fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+8]
  005cf	66 89 84 0a 4a
	0e 00 00	 mov	 WORD PTR [edx+ecx+3658], ax

; 94   : 				this->CmdBase[this->CountCMD].Level			= n[3];

  005d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005da	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  005e0	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  005e3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005e6	66 8b 85 60 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+12]
  005ed	66 89 84 0a 4c
	0e 00 00	 mov	 WORD PTR [edx+ecx+3660], ax

; 95   : 				this->CmdBase[this->CountCMD].Reset			= n[4];

  005f5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005f8	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  005fe	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00601	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00604	66 8b 85 64 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+16]
  0060b	66 89 84 0a 4e
	0e 00 00	 mov	 WORD PTR [edx+ecx+3662], ax

; 96   : 				this->CmdBase[this->CountCMD].GReset		= n[5];

  00613	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00616	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  0061c	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  0061f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00622	66 8b 85 68 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+20]
  00629	66 89 84 0a 50
	0e 00 00	 mov	 WORD PTR [edx+ecx+3664], ax

; 97   : 				this->CmdBase[this->CountCMD].MaxReset		= n[6];

  00631	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00634	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  0063a	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  0063d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00640	66 8b 85 6c fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+24]
  00647	66 89 84 0a 52
	0e 00 00	 mov	 WORD PTR [edx+ecx+3666], ax

; 98   : 				this->CmdBase[this->CountCMD].MaxGReset		= n[7];

  0064f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00652	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00658	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  0065b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0065e	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+28]
  00665	66 89 84 0a 54
	0e 00 00	 mov	 WORD PTR [edx+ecx+3668], ax

; 99   : 				this->CmdBase[this->CountCMD].Premium		= n[8];

  0066d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00670	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00676	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00679	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0067c	66 8b 85 74 fe
	ff ff		 mov	 ax, WORD PTR _n$220813[ebp+32]
  00683	66 89 84 0a 56
	0e 00 00	 mov	 WORD PTR [edx+ecx+3670], ax

; 100  : 				this->CmdBase[this->CountCMD].Price			= n[9];

  0068b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0068e	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00694	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00697	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0069a	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _n$220813[ebp+36]
  006a0	89 84 0a 58 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3672], eax

; 101  : 				this->CmdBase[this->CountCMD].Value			= n[10];

  006a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006aa	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  006b0	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  006b3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006b6	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _n$220813[ebp+40]
  006bc	89 84 0a 5c 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3676], eax

; 102  : 				this->CountCMD++;

  006c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006c6	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  006cc	83 c1 01	 add	 ecx, 1
  006cf	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006d2	89 8a c8 2b 00
	00		 mov	 DWORD PTR [edx+11208], ecx
$LN11@Load:

; 103  : 			}
; 104  : 
; 105  : 		}
; 106  : 		else

  006d8	e9 9d 03 00 00	 jmp	 $LN10@Load
$LN14@Load:

; 107  : 		{
; 108  : 			if(Flag == 1)

  006dd	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR _Flag$[ebp], 1
  006e4	0f 85 df 01 00
	00		 jne	 $LN9@Load

; 109  : 			{
; 110  : 				int n[13];
; 111  : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d %d %d %d", &n[0], &n[1], &n[2], &n[3], &n[4], &n[5], &n[6], &n[7], &n[8], &n[9], &n[10], &n[11], &n[12]);

  006ea	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _n$220818[ebp+48]
  006f0	50		 push	 eax
  006f1	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR _n$220818[ebp+44]
  006f7	51		 push	 ecx
  006f8	8d 95 48 fe ff
	ff		 lea	 edx, DWORD PTR _n$220818[ebp+40]
  006fe	52		 push	 edx
  006ff	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR _n$220818[ebp+36]
  00705	50		 push	 eax
  00706	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220818[ebp+32]
  0070c	51		 push	 ecx
  0070d	8d 95 3c fe ff
	ff		 lea	 edx, DWORD PTR _n$220818[ebp+28]
  00713	52		 push	 edx
  00714	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _n$220818[ebp+24]
  0071a	50		 push	 eax
  0071b	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220818[ebp+20]
  00721	51		 push	 ecx
  00722	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR _n$220818[ebp+16]
  00728	52		 push	 edx
  00729	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR _n$220818[ebp+12]
  0072f	50		 push	 eax
  00730	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _n$220818[ebp+8]
  00736	51		 push	 ecx
  00737	8d 95 24 fe ff
	ff		 lea	 edx, DWORD PTR _n$220818[ebp+4]
  0073d	52		 push	 edx
  0073e	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _n$220818[ebp]
  00744	50		 push	 eax
  00745	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DDKHOEJN@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  0074a	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00750	51		 push	 ecx
  00751	e8 00 00 00 00	 call	 _sscanf
  00756	83 c4 3c	 add	 esp, 60			; 0000003cH

; 112  : 				this->NpcBase[this->CountNPC].NPC			= n[0];

  00759	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0075c	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00762	6b c9 24	 imul	 ecx, 36			; 00000024H
  00765	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00768	66 8b 85 20 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp]
  0076f	66 89 44 0a 04	 mov	 WORD PTR [edx+ecx+4], ax

; 113  : 				this->NpcBase[this->CountNPC].MAP			= n[1];

  00774	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00777	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0077d	6b c9 24	 imul	 ecx, 36			; 00000024H
  00780	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00783	66 8b 85 24 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+4]
  0078a	66 89 44 0a 06	 mov	 WORD PTR [edx+ecx+6], ax

; 114  : 				this->NpcBase[this->CountNPC].X				= n[2];

  0078f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00792	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00798	6b c9 24	 imul	 ecx, 36			; 00000024H
  0079b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0079e	66 8b 85 28 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+8]
  007a5	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 115  : 				this->NpcBase[this->CountNPC].Y				= n[3];

  007aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007ad	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  007b3	6b c9 24	 imul	 ecx, 36			; 00000024H
  007b6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007b9	66 8b 85 2c fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+12]
  007c0	66 89 44 0a 0a	 mov	 WORD PTR [edx+ecx+10], ax

; 116  : 				this->NpcBase[this->CountNPC].TeleportMap	= n[4];

  007c5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007c8	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  007ce	6b c9 24	 imul	 ecx, 36			; 00000024H
  007d1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007d4	66 8b 85 30 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+16]
  007db	66 89 44 0a 0c	 mov	 WORD PTR [edx+ecx+12], ax

; 117  : 				this->NpcBase[this->CountNPC].TeleportX		= n[5];

  007e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007e3	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  007e9	6b c9 24	 imul	 ecx, 36			; 00000024H
  007ec	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007ef	66 8b 85 34 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+20]
  007f6	66 89 44 0a 0e	 mov	 WORD PTR [edx+ecx+14], ax

; 118  : 				this->NpcBase[this->CountNPC].TeleportY		= n[6];

  007fb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007fe	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00804	6b c9 24	 imul	 ecx, 36			; 00000024H
  00807	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0080a	66 8b 85 38 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+24]
  00811	66 89 44 0a 10	 mov	 WORD PTR [edx+ecx+16], ax

; 119  : 				this->NpcBase[this->CountNPC].Level			= n[7];

  00816	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00819	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0081f	6b c9 24	 imul	 ecx, 36			; 00000024H
  00822	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00825	66 8b 85 3c fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+28]
  0082c	66 89 44 0a 12	 mov	 WORD PTR [edx+ecx+18], ax

; 120  : 				this->NpcBase[this->CountNPC].Reset			= n[8];

  00831	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00834	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0083a	6b c9 24	 imul	 ecx, 36			; 00000024H
  0083d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00840	66 8b 85 40 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+32]
  00847	66 89 44 0a 14	 mov	 WORD PTR [edx+ecx+20], ax

; 121  : 				this->NpcBase[this->CountNPC].GReset		= n[9];

  0084c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0084f	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00855	6b c9 24	 imul	 ecx, 36			; 00000024H
  00858	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0085b	66 8b 85 44 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+36]
  00862	66 89 44 0a 16	 mov	 WORD PTR [edx+ecx+22], ax

; 122  : 				this->NpcBase[this->CountNPC].Premium		= n[10];

  00867	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0086a	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  00870	6b c9 24	 imul	 ecx, 36			; 00000024H
  00873	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00876	66 8b 85 48 fe
	ff ff		 mov	 ax, WORD PTR _n$220818[ebp+40]
  0087d	66 89 44 0a 1c	 mov	 WORD PTR [edx+ecx+28], ax

; 123  : 				this->NpcBase[this->CountNPC].Price			= n[11];

  00882	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00885	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  0088b	6b c9 24	 imul	 ecx, 36			; 00000024H
  0088e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00891	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR _n$220818[ebp+44]
  00897	89 44 0a 20	 mov	 DWORD PTR [edx+ecx+32], eax

; 124  : 				this->NpcBase[this->CountNPC].Value			= n[12];

  0089b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0089e	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  008a4	6b c9 24	 imul	 ecx, 36			; 00000024H
  008a7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  008aa	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR _n$220818[ebp+48]
  008b0	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax

; 125  : 				this->CountNPC++;

  008b4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008b7	8b 88 c4 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11204]
  008bd	83 c1 01	 add	 ecx, 1
  008c0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  008c3	89 8a c4 2b 00
	00		 mov	 DWORD PTR [edx+11204], ecx
$LN9@Load:

; 126  : 			}
; 127  : 
; 128  : 			if(Flag == 2)

  008c9	83 bd f0 fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  008d0	0f 85 a4 01 00
	00		 jne	 $LN10@Load

; 129  : 			{
; 130  : 				char mes[50];
; 131  : 				int n[9];
; 132  : 				sscanf(Buff, "\"%[^\"]\" %d %d %d %d %d %d %d %d %d", &mes, &n[0], &n[1], &n[2], &n[3], &n[4], &n[5], &n[6], &n[7], &n[8]);

  008d6	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _n$220822[ebp+32]
  008dc	50		 push	 eax
  008dd	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _n$220822[ebp+28]
  008e3	51		 push	 ecx
  008e4	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR _n$220822[ebp+24]
  008ea	52		 push	 edx
  008eb	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _n$220822[ebp+20]
  008f1	50		 push	 eax
  008f2	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _n$220822[ebp+16]
  008f8	51		 push	 ecx
  008f9	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _n$220822[ebp+12]
  008ff	52		 push	 edx
  00900	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _n$220822[ebp+8]
  00906	50		 push	 eax
  00907	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _n$220822[ebp+4]
  0090d	51		 push	 ecx
  0090e	8d 95 c8 fd ff
	ff		 lea	 edx, DWORD PTR _n$220822[ebp]
  00914	52		 push	 edx
  00915	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _mes$220821[ebp]
  0091b	50		 push	 eax
  0091c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@MBABJFMK@?$CC?$CF?$FL?$FO?$CC?$FN?$CC?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5@
  00921	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00927	51		 push	 ecx
  00928	e8 00 00 00 00	 call	 _sscanf
  0092d	83 c4 30	 add	 esp, 48			; 00000030H

; 133  : 				sprintf(this->CmdBase[this->CountCMD].Command,"%s",mes);

  00930	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _mes$220821[ebp]
  00936	50		 push	 eax
  00937	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0093c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0093f	8b 91 c8 2b 00
	00		 mov	 edx, DWORD PTR [ecx+11208]
  00945	6b d2 4c	 imul	 edx, 76			; 0000004cH
  00948	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0094b	8d 8c 10 14 0e
	00 00		 lea	 ecx, DWORD PTR [eax+edx+3604]
  00952	51		 push	 ecx
  00953	e8 00 00 00 00	 call	 _sprintf
  00958	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  : 				this->CmdBase[this->CountCMD].TeleportMap	= n[0];

  0095b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0095e	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00964	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00967	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0096a	66 8b 85 c8 fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp]
  00971	66 89 84 0a 46
	0e 00 00	 mov	 WORD PTR [edx+ecx+3654], ax

; 135  : 				this->CmdBase[this->CountCMD].TeleportX		= n[1];

  00979	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0097c	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00982	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00985	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00988	66 8b 85 cc fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp+4]
  0098f	66 89 84 0a 48
	0e 00 00	 mov	 WORD PTR [edx+ecx+3656], ax

; 136  : 				this->CmdBase[this->CountCMD].TeleportY		= n[2];

  00997	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0099a	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  009a0	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  009a3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  009a6	66 8b 85 d0 fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp+8]
  009ad	66 89 84 0a 4a
	0e 00 00	 mov	 WORD PTR [edx+ecx+3658], ax

; 137  : 				this->CmdBase[this->CountCMD].Level			= n[3];

  009b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009b8	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  009be	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  009c1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  009c4	66 8b 85 d4 fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp+12]
  009cb	66 89 84 0a 4c
	0e 00 00	 mov	 WORD PTR [edx+ecx+3660], ax

; 138  : 				this->CmdBase[this->CountCMD].Reset			= n[4];

  009d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009d6	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  009dc	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  009df	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  009e2	66 8b 85 d8 fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp+16]
  009e9	66 89 84 0a 4e
	0e 00 00	 mov	 WORD PTR [edx+ecx+3662], ax

; 139  : 				this->CmdBase[this->CountCMD].GReset		= n[5];

  009f1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009f4	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  009fa	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  009fd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a00	66 8b 85 dc fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp+20]
  00a07	66 89 84 0a 50
	0e 00 00	 mov	 WORD PTR [edx+ecx+3664], ax

; 140  : 				this->CmdBase[this->CountCMD].Premium		= n[6];

  00a0f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a12	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00a18	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00a1b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a1e	66 8b 85 e0 fd
	ff ff		 mov	 ax, WORD PTR _n$220822[ebp+24]
  00a25	66 89 84 0a 56
	0e 00 00	 mov	 WORD PTR [edx+ecx+3670], ax

; 141  : 				this->CmdBase[this->CountCMD].Price			= n[7];

  00a2d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a30	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00a36	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00a39	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a3c	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _n$220822[ebp+28]
  00a42	89 84 0a 58 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3672], eax

; 142  : 				this->CmdBase[this->CountCMD].Value			= n[8];

  00a49	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a4c	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00a52	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00a55	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a58	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _n$220822[ebp+32]
  00a5e	89 84 0a 5c 0e
	00 00		 mov	 DWORD PTR [edx+ecx+3676], eax

; 143  : 				this->CountCMD++;

  00a65	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a68	8b 88 c8 2b 00
	00		 mov	 ecx, DWORD PTR [eax+11208]
  00a6e	83 c1 01	 add	 ecx, 1
  00a71	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a74	89 8a c8 2b 00
	00		 mov	 DWORD PTR [edx+11208], ecx
$LN10@Load:

; 144  : 			}
; 145  : 		}
; 146  : 
; 147  : 		if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 148  : 			g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 149  : 			g_ExLicense.CheckUser(eExUB::SILVER2)	 ||
; 150  : 			LICENSE_ARCMU )

  00a7a	6a 00		 push	 0
  00a7c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a81	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a86	0f b6 c0	 movzx	 eax, al
  00a89	85 c0		 test	 eax, eax
  00a8b	75 2a		 jne	 SHORT $LN6@Load
  00a8d	6a 07		 push	 7
  00a8f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a94	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a99	0f b6 c0	 movzx	 eax, al
  00a9c	85 c0		 test	 eax, eax
  00a9e	75 17		 jne	 SHORT $LN6@Load
  00aa0	6a 08		 push	 8
  00aa2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00aa7	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00aac	0f b6 c0	 movzx	 eax, al
  00aaf	85 c0		 test	 eax, eax
  00ab1	75 04		 jne	 SHORT $LN6@Load
  00ab3	33 c0		 xor	 eax, eax
  00ab5	74 45		 je	 SHORT $LN7@Load
$LN6@Load:

; 151  : 		{
; 152  : 			if(Flag == 3)

  00ab7	83 bd f0 fe ff
	ff 03		 cmp	 DWORD PTR _Flag$[ebp], 3
  00abe	75 3c		 jne	 SHORT $LN7@Load

; 153  : 			{
; 154  : 				int n;
; 155  : 				sscanf(Buff, "%d", &n);

  00ac0	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _n$220827[ebp]
  00ac6	50		 push	 eax
  00ac7	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00acc	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00ad2	51		 push	 ecx
  00ad3	e8 00 00 00 00	 call	 _sscanf
  00ad8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 				DLTP_BLOCK_DATA List;			
; 157  : 				List.MapNumber = n;

  00adb	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _n$220827[ebp]
  00ae1	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _List$220828[ebp], eax

; 158  : 				this->m_dlblock.push_back(List);

  00ae7	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _List$220828[ebp]
  00aed	50		 push	 eax
  00aee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00af1	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  00af7	e8 00 00 00 00	 call	 ?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::push_back
$LN7@Load:

; 159  : 			}
; 160  : 		}
; 161  : 
; 162  : 		if( g_ExLicense.CheckUser(eExUB::Gredy) || g_ExLicense.CheckUser(eExUB::GredyLocal) || g_ExLicense.CheckUser(eExUB::Gredy2) )

  00afc	6a 20		 push	 32			; 00000020H
  00afe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00b03	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00b08	0f b6 c0	 movzx	 eax, al
  00b0b	85 c0		 test	 eax, eax
  00b0d	75 2a		 jne	 SHORT $LN3@Load
  00b0f	6a 21		 push	 33			; 00000021H
  00b11	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00b16	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00b1b	0f b6 c0	 movzx	 eax, al
  00b1e	85 c0		 test	 eax, eax
  00b20	75 17		 jne	 SHORT $LN3@Load
  00b22	6a 22		 push	 34			; 00000022H
  00b24	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00b29	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00b2e	0f b6 c0	 movzx	 eax, al
  00b31	85 c0		 test	 eax, eax
  00b33	0f 84 8a 00 00
	00		 je	 $LN4@Load
$LN3@Load:

; 163  : 		{
; 164  : 			if(Flag == 4)

  00b39	83 bd f0 fe ff
	ff 04		 cmp	 DWORD PTR _Flag$[ebp], 4
  00b40	75 3c		 jne	 SHORT $LN2@Load

; 165  : 			{
; 166  : 				int n;
; 167  : 				sscanf(Buff, "%d", &n);

  00b42	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _n$220832[ebp]
  00b48	50		 push	 eax
  00b49	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00b4e	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00b54	51		 push	 ecx
  00b55	e8 00 00 00 00	 call	 _sscanf
  00b5a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  : 				DLTP_BLOCK_DATA List;			
; 169  : 				List.MapNumber = n;

  00b5d	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _n$220832[ebp]
  00b63	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _List$220833[ebp], eax

; 170  : 				this->m_DLMasterBlock.push_back(List);

  00b69	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _List$220833[ebp]
  00b6f	50		 push	 eax
  00b70	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b73	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  00b79	e8 00 00 00 00	 call	 ?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::push_back
$LN2@Load:

; 171  : 			}
; 172  : 
; 173  : 			if(Flag == 5)

  00b7e	83 bd f0 fe ff
	ff 05		 cmp	 DWORD PTR _Flag$[ebp], 5
  00b85	75 3c		 jne	 SHORT $LN4@Load

; 174  : 			{
; 175  : 				int n;
; 176  : 				sscanf(Buff, "%d", &n);

  00b87	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _n$220835[ebp]
  00b8d	50		 push	 eax
  00b8e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00b93	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00b99	51		 push	 ecx
  00b9a	e8 00 00 00 00	 call	 _sscanf
  00b9f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 				DLTP_BLOCK_DATA List;			
; 178  : 				List.MapNumber = n;

  00ba2	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _n$220835[ebp]
  00ba8	89 85 b0 fd ff
	ff		 mov	 DWORD PTR _List$220836[ebp], eax

; 179  : 				this->m_DLMemberBlock.push_back(List);

  00bae	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _List$220836[ebp]
  00bb4	50		 push	 eax
  00bb5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb8	81 c1 ec 2b 00
	00		 add	 ecx, 11244		; 00002becH
  00bbe	e8 00 00 00 00	 call	 ?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::push_back
$LN4@Load:

; 180  : 			}
; 181  : 		}
; 182  : 	}

  00bc3	e9 24 f6 ff ff	 jmp	 $LN17@Load
$LN16@Load:

; 183  : 	fclose(file);

  00bc8	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  00bcb	50		 push	 eax
  00bcc	e8 00 00 00 00	 call	 _fclose
  00bd1	83 c4 04	 add	 esp, 4
$LN20@Load:

; 184  : }

  00bd4	5f		 pop	 edi
  00bd5	5e		 pop	 esi
  00bd6	5b		 pop	 ebx
  00bd7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bda	33 cd		 xor	 ecx, ebp
  00bdc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00be1	8b e5		 mov	 esp, ebp
  00be3	5d		 pop	 ebp
  00be4	c3		 ret	 0
?Load@cTeleportManager@@QAEXXZ ENDP			; cTeleportManager::Load
_TEXT	ENDS
PUBLIC	?NPCClick@cTeleportManager@@QAEXPAUOBJECTSTRUCT@@0@Z ; cTeleportManager::NPCClick
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?ExUserDataSend@@YAXH@Z:PROC			; ExUserDataSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
EXTRN	?GetText@CExText@@QAEPADH@Z:PROC		; CExText::GetText
EXTRN	?g_ExText@@3VCExText@@A:BYTE			; g_ExText
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv313 = -76						; size = 4
_a$220843 = -8						; size = 4
_this$ = -4						; size = 4
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?NPCClick@cTeleportManager@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; cTeleportManager::NPCClick
; _this$ = ecx

; 187  : {

  00bf0	55		 push	 ebp
  00bf1	8b ec		 mov	 ebp, esp
  00bf3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00bf6	53		 push	 ebx
  00bf7	56		 push	 esi
  00bf8	57		 push	 edi
  00bf9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 188  : 	if(!this->Enable) return;

  00bfc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bff	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00c02	85 c9		 test	 ecx, ecx
  00c04	75 05		 jne	 SHORT $LN34@NPCClick
  00c06	e9 70 06 00 00	 jmp	 $LN35@NPCClick
$LN34@NPCClick:

; 189  : 
; 190  : 	for(int a=0;a<this->CountNPC;a++)

  00c0b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _a$220843[ebp], 0
  00c12	eb 09		 jmp	 SHORT $LN33@NPCClick
$LN32@NPCClick:
  00c14	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00c17	83 c0 01	 add	 eax, 1
  00c1a	89 45 f8	 mov	 DWORD PTR _a$220843[ebp], eax
$LN33@NPCClick:
  00c1d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c20	8b 4d f8	 mov	 ecx, DWORD PTR _a$220843[ebp]
  00c23	3b 88 c4 2b 00
	00		 cmp	 ecx, DWORD PTR [eax+11204]
  00c29	0f 8d 4c 06 00
	00		 jge	 $LN31@NPCClick

; 191  : 	{
; 192  : 		if(this->NpcBase[a].NPC == lpNpc->Class && 
; 193  : 			this->NpcBase[a].MAP == lpNpc->MapNumber &&
; 194  : 			this->NpcBase[a].X == lpNpc->X &&
; 195  : 			this->NpcBase[a].Y == lpNpc->Y ||
; 196  : 			this->NpcBase[a].NPC == lpNpc->Class &&
; 197  : 			this->NpcBase[a].MAP == -1)

  00c2f	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00c32	6b c0 24	 imul	 eax, 36			; 00000024H
  00c35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c38	0f bf 54 01 04	 movsx	 edx, WORD PTR [ecx+eax+4]
  00c3d	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  00c40	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00c47	3b d1		 cmp	 edx, ecx
  00c49	75 54		 jne	 SHORT $LN28@NPCClick
  00c4b	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00c4e	6b c0 24	 imul	 eax, 36			; 00000024H
  00c51	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c54	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  00c59	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  00c5c	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00c63	3b d1		 cmp	 edx, ecx
  00c65	75 38		 jne	 SHORT $LN28@NPCClick
  00c67	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00c6a	6b c0 24	 imul	 eax, 36			; 00000024H
  00c6d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c70	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  00c75	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  00c78	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00c7f	3b d1		 cmp	 edx, ecx
  00c81	75 1c		 jne	 SHORT $LN28@NPCClick
  00c83	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00c86	6b c0 24	 imul	 eax, 36			; 00000024H
  00c89	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c8c	0f bf 54 01 0a	 movsx	 edx, WORD PTR [ecx+eax+10]
  00c91	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  00c94	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00c9b	3b d1		 cmp	 edx, ecx
  00c9d	74 37		 je	 SHORT $LN29@NPCClick
$LN28@NPCClick:
  00c9f	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00ca2	6b c0 24	 imul	 eax, 36			; 00000024H
  00ca5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ca8	0f bf 54 01 04	 movsx	 edx, WORD PTR [ecx+eax+4]
  00cad	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  00cb0	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00cb7	3b d1		 cmp	 edx, ecx
  00cb9	0f 85 b7 05 00
	00		 jne	 $LN30@NPCClick
  00cbf	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00cc2	6b c0 24	 imul	 eax, 36			; 00000024H
  00cc5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cc8	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  00ccd	83 fa ff	 cmp	 edx, -1
  00cd0	0f 85 a0 05 00
	00		 jne	 $LN30@NPCClick
$LN29@NPCClick:

; 198  : 		{
; 199  : 			// ----
; 200  : 
; 201  : 			if(this->NpcBase[a].Level > lpObj->Level)

  00cd6	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00cd9	6b c0 24	 imul	 eax, 36			; 00000024H
  00cdc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cdf	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00ce4	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ce7	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00cee	3b d1		 cmp	 edx, ecx
  00cf0	7e 32		 jle	 SHORT $LN27@NPCClick

; 202  : 			{
; 203  : 				MsgNormal(lpObj->m_Index,g_ExText.GetText(255),this->NpcBase[a].Level);

  00cf2	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00cf5	6b c0 24	 imul	 eax, 36			; 00000024H
  00cf8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cfb	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00d00	52		 push	 edx
  00d01	68 ff 00 00 00	 push	 255			; 000000ffH
  00d06	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00d0b	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00d10	50		 push	 eax
  00d11	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d14	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d16	51		 push	 ecx
  00d17	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00d1c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 				return;

  00d1f	e9 57 05 00 00	 jmp	 $LN35@NPCClick
$LN27@NPCClick:

; 205  : 			}
; 206  : 
; 207  : 			if(this->NpcBase[a].Reset > lpObj->Reset)

  00d24	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00d27	6b c0 24	 imul	 eax, 36			; 00000024H
  00d2a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d2d	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  00d32	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d35	3b 90 90 22 00
	00		 cmp	 edx, DWORD PTR [eax+8848]
  00d3b	7e 32		 jle	 SHORT $LN26@NPCClick

; 208  : 			{
; 209  : 				MsgNormal(lpObj->m_Index,g_ExText.GetText(256),this->NpcBase[a].Reset);

  00d3d	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00d40	6b c0 24	 imul	 eax, 36			; 00000024H
  00d43	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d46	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  00d4b	52		 push	 edx
  00d4c	68 00 01 00 00	 push	 256			; 00000100H
  00d51	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00d56	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00d5b	50		 push	 eax
  00d5c	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d5f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d61	51		 push	 ecx
  00d62	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00d67	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  : 				return;

  00d6a	e9 0c 05 00 00	 jmp	 $LN35@NPCClick
$LN26@NPCClick:

; 211  : 			}
; 212  : 
; 213  : 			if(this->NpcBase[a].GReset > lpObj->GReset)

  00d6f	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00d72	6b c0 24	 imul	 eax, 36			; 00000024H
  00d75	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d78	0f bf 54 01 16	 movsx	 edx, WORD PTR [ecx+eax+22]
  00d7d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d80	3b 90 94 22 00
	00		 cmp	 edx, DWORD PTR [eax+8852]
  00d86	7e 32		 jle	 SHORT $LN25@NPCClick

; 214  : 			{
; 215  : 				MsgNormal(lpObj->m_Index,g_ExText.GetText(257),this->NpcBase[a].GReset);

  00d88	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00d8b	6b c0 24	 imul	 eax, 36			; 00000024H
  00d8e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d91	0f bf 54 01 16	 movsx	 edx, WORD PTR [ecx+eax+22]
  00d96	52		 push	 edx
  00d97	68 01 01 00 00	 push	 257			; 00000101H
  00d9c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00da1	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00da6	50		 push	 eax
  00da7	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00daa	8b 08		 mov	 ecx, DWORD PTR [eax]
  00dac	51		 push	 ecx
  00dad	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00db2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 216  : 				return;

  00db5	e9 c1 04 00 00	 jmp	 $LN35@NPCClick
$LN25@NPCClick:

; 217  : 			}
; 218  : 
; 219  : 			if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 220  : 				g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 221  : 				g_ExLicense.CheckUser(eExUB::SILVER2)	 ||
; 222  : 				g_ExLicense.CheckUser(eExUB::Gredy)		 || 
; 223  : 				g_ExLicense.CheckUser(eExUB::GredyLocal) || 
; 224  : 				g_ExLicense.CheckUser(eExUB::Gredy2) )

  00dba	6a 00		 push	 0
  00dbc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00dc1	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00dc6	0f b6 c0	 movzx	 eax, al
  00dc9	85 c0		 test	 eax, eax
  00dcb	75 63		 jne	 SHORT $LN23@NPCClick
  00dcd	6a 07		 push	 7
  00dcf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00dd4	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00dd9	0f b6 c0	 movzx	 eax, al
  00ddc	85 c0		 test	 eax, eax
  00dde	75 50		 jne	 SHORT $LN23@NPCClick
  00de0	6a 08		 push	 8
  00de2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00de7	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00dec	0f b6 c0	 movzx	 eax, al
  00def	85 c0		 test	 eax, eax
  00df1	75 3d		 jne	 SHORT $LN23@NPCClick
  00df3	6a 20		 push	 32			; 00000020H
  00df5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00dfa	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00dff	0f b6 c0	 movzx	 eax, al
  00e02	85 c0		 test	 eax, eax
  00e04	75 2a		 jne	 SHORT $LN23@NPCClick
  00e06	6a 21		 push	 33			; 00000021H
  00e08	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00e0d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00e12	0f b6 c0	 movzx	 eax, al
  00e15	85 c0		 test	 eax, eax
  00e17	75 17		 jne	 SHORT $LN23@NPCClick
  00e19	6a 22		 push	 34			; 00000022H
  00e1b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00e20	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00e25	0f b6 c0	 movzx	 eax, al
  00e28	85 c0		 test	 eax, eax
  00e2a	0f 84 96 00 00
	00		 je	 $LN21@NPCClick
$LN23@NPCClick:

; 225  : 			{
; 226  : 				if(this->NpcBase[a].MaxReset < lpObj->Reset)

  00e30	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00e33	6b c0 24	 imul	 eax, 36			; 00000024H
  00e36	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e39	0f bf 54 01 18	 movsx	 edx, WORD PTR [ecx+eax+24]
  00e3e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e41	3b 90 90 22 00
	00		 cmp	 edx, DWORD PTR [eax+8848]
  00e47	7d 32		 jge	 SHORT $LN22@NPCClick

; 227  : 				{
; 228  : 					MsgNormal(lpObj->m_Index,g_ExText.GetText(256),this->NpcBase[a].MaxReset);

  00e49	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00e4c	6b c0 24	 imul	 eax, 36			; 00000024H
  00e4f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e52	0f bf 54 01 18	 movsx	 edx, WORD PTR [ecx+eax+24]
  00e57	52		 push	 edx
  00e58	68 00 01 00 00	 push	 256			; 00000100H
  00e5d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00e62	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00e67	50		 push	 eax
  00e68	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e6b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e6d	51		 push	 ecx
  00e6e	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00e73	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  : 					return;

  00e76	e9 00 04 00 00	 jmp	 $LN35@NPCClick
$LN22@NPCClick:

; 230  : 				}
; 231  : 
; 232  : 				if(this->NpcBase[a].MaxGReset < lpObj->GReset)

  00e7b	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00e7e	6b c0 24	 imul	 eax, 36			; 00000024H
  00e81	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e84	0f bf 54 01 1a	 movsx	 edx, WORD PTR [ecx+eax+26]
  00e89	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e8c	3b 90 94 22 00
	00		 cmp	 edx, DWORD PTR [eax+8852]
  00e92	7d 32		 jge	 SHORT $LN21@NPCClick

; 233  : 				{
; 234  : 					MsgNormal(lpObj->m_Index,g_ExText.GetText(257),this->NpcBase[a].MaxGReset);

  00e94	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00e97	6b c0 24	 imul	 eax, 36			; 00000024H
  00e9a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e9d	0f bf 54 01 1a	 movsx	 edx, WORD PTR [ecx+eax+26]
  00ea2	52		 push	 edx
  00ea3	68 01 01 00 00	 push	 257			; 00000101H
  00ea8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00ead	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00eb2	50		 push	 eax
  00eb3	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00eb6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00eb8	51		 push	 ecx
  00eb9	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00ebe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 235  : 					return;

  00ec1	e9 b5 03 00 00	 jmp	 $LN35@NPCClick
$LN21@NPCClick:

; 236  : 				}
; 237  : 			}
; 238  : 
; 239  : 			if(this->NpcBase[a].Premium)

  00ec6	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00ec9	6b c0 24	 imul	 eax, 36			; 00000024H
  00ecc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ecf	0f bf 54 01 1c	 movsx	 edx, WORD PTR [ecx+eax+28]
  00ed4	85 d2		 test	 edx, edx
  00ed6	0f 84 ae 00 00
	00		 je	 $LN14@NPCClick

; 240  : 			{
; 241  : 				if(g_ExLicense.CheckUser(eExUB::SILVER1) || g_ExLicense.CheckUser(eExUB::SILVER2))

  00edc	6a 07		 push	 7
  00ede	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00ee3	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00ee8	0f b6 c0	 movzx	 eax, al
  00eeb	85 c0		 test	 eax, eax
  00eed	75 13		 jne	 SHORT $LN18@NPCClick
  00eef	6a 08		 push	 8
  00ef1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00ef6	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00efb	0f b6 c0	 movzx	 eax, al
  00efe	85 c0		 test	 eax, eax
  00f00	74 59		 je	 SHORT $LN19@NPCClick
$LN18@NPCClick:

; 242  : 				{
; 243  : 					if(this->NpcBase[a].Premium != lpObj->PremiumTimeType || lpObj->PremiumTime == 0)

  00f02	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00f05	6b c0 24	 imul	 eax, 36			; 00000024H
  00f08	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f0b	0f bf 54 01 1c	 movsx	 edx, WORD PTR [ecx+eax+28]
  00f10	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f13	3b 90 bc 22 00
	00		 cmp	 edx, DWORD PTR [eax+8892]
  00f19	75 0c		 jne	 SHORT $LN16@NPCClick
  00f1b	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f1e	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  00f25	75 32		 jne	 SHORT $LN17@NPCClick
$LN16@NPCClick:

; 244  : 					{
; 245  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(258), this->NpcBase[a].Premium);

  00f27	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00f2a	6b c0 24	 imul	 eax, 36			; 00000024H
  00f2d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f30	0f bf 54 01 1c	 movsx	 edx, WORD PTR [ecx+eax+28]
  00f35	52		 push	 edx
  00f36	68 02 01 00 00	 push	 258			; 00000102H
  00f3b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00f40	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00f45	50		 push	 eax
  00f46	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f49	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f4b	51		 push	 ecx
  00f4c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00f51	83 c4 0c	 add	 esp, 12			; 0000000cH

; 246  : 						return;

  00f54	e9 22 03 00 00	 jmp	 $LN35@NPCClick
$LN17@NPCClick:

; 247  : 					}
; 248  : 				}
; 249  : 				else

  00f59	eb 2f		 jmp	 SHORT $LN14@NPCClick
$LN19@NPCClick:

; 250  : 				{
; 251  : 					if(lpObj->PremiumTime == 0)

  00f5b	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f5e	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  00f65	75 23		 jne	 SHORT $LN14@NPCClick

; 252  : 					{
; 253  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(259));

  00f67	68 03 01 00 00	 push	 259			; 00000103H
  00f6c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00f71	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00f76	50		 push	 eax
  00f77	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f7a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f7c	51		 push	 ecx
  00f7d	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00f82	83 c4 08	 add	 esp, 8

; 254  : 						return;

  00f85	e9 f1 02 00 00	 jmp	 $LN35@NPCClick
$LN14@NPCClick:

; 255  : 					}
; 256  : 				}
; 257  : 			}
; 258  : 
; 259  : 			switch(this->NpcBase[a].Price)

  00f8a	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00f8d	6b c0 24	 imul	 eax, 36			; 00000024H
  00f90	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f93	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  00f97	89 55 b4	 mov	 DWORD PTR tv313[ebp], edx
  00f9a	8b 45 b4	 mov	 eax, DWORD PTR tv313[ebp]
  00f9d	83 e8 01	 sub	 eax, 1
  00fa0	89 45 b4	 mov	 DWORD PTR tv313[ebp], eax
  00fa3	83 7d b4 04	 cmp	 DWORD PTR tv313[ebp], 4
  00fa7	0f 87 8c 02 00
	00		 ja	 $LN1@NPCClick
  00fad	8b 4d b4	 mov	 ecx, DWORD PTR tv313[ebp]
  00fb0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN37@NPCClick[ecx*4]
$LN11@NPCClick:

; 260  : 			{
; 261  : 			case 1:
; 262  : 				{
; 263  : 					if(this->NpcBase[a].Value > lpObj->Money )

  00fb7	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00fba	6b c0 24	 imul	 eax, 36			; 00000024H
  00fbd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc0	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00fc3	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  00fc7	3b 82 f0 00 00
	00		 cmp	 eax, DWORD PTR [edx+240]
  00fcd	7e 31		 jle	 SHORT $LN10@NPCClick

; 264  : 					{
; 265  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(260),this->NpcBase[a].Value);

  00fcf	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  00fd2	6b c0 24	 imul	 eax, 36			; 00000024H
  00fd5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fd8	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  00fdc	52		 push	 edx
  00fdd	68 04 01 00 00	 push	 260			; 00000104H
  00fe2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00fe7	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00fec	50		 push	 eax
  00fed	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ff0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ff2	51		 push	 ecx
  00ff3	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00ff8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 266  : 						return;

  00ffb	e9 7b 02 00 00	 jmp	 $LN35@NPCClick
$LN10@NPCClick:

; 267  : 					}
; 268  : 					lpObj->Money -= this->NpcBase[a].Value;

  01000	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  01003	6b c0 24	 imul	 eax, 36			; 00000024H
  01006	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01009	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0100c	8b 89 f0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+240]
  01012	2b 4c 02 24	 sub	 ecx, DWORD PTR [edx+eax+36]
  01016	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01019	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 269  : 					GCMoneySend(lpObj->m_Index,lpObj->Money);

  0101f	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01022	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01028	51		 push	 ecx
  01029	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0102c	8b 02		 mov	 eax, DWORD PTR [edx]
  0102e	50		 push	 eax
  0102f	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  01034	83 c4 08	 add	 esp, 8

; 270  : 				}
; 271  : 				break;

  01037	e9 fd 01 00 00	 jmp	 $LN12@NPCClick
$LN9@NPCClick:

; 272  : 			case 2:
; 273  : 				{
; 274  : 					if(this->NpcBase[a].Value > lpObj->ExCred )

  0103c	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0103f	6b c0 24	 imul	 eax, 36			; 00000024H
  01042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01045	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  01049	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0104c	d9 82 a8 22 00
	00		 fld	 DWORD PTR [edx+8872]
  01052	de d9		 fcompp
  01054	df e0		 fnstsw	 ax
  01056	f6 c4 05	 test	 ah, 5
  01059	7a 31		 jp	 SHORT $LN8@NPCClick

; 275  : 					{
; 276  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(261),this->NpcBase[a].Value);

  0105b	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0105e	6b c0 24	 imul	 eax, 36			; 00000024H
  01061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01064	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  01068	52		 push	 edx
  01069	68 05 01 00 00	 push	 261			; 00000105H
  0106e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01073	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01078	50		 push	 eax
  01079	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0107c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0107e	51		 push	 ecx
  0107f	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 277  : 						return;

  01087	e9 ef 01 00 00	 jmp	 $LN35@NPCClick
$LN8@NPCClick:

; 278  : 					}
; 279  : 					lpObj->ExCred -= this->NpcBase[a].Value;

  0108c	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0108f	6b c0 24	 imul	 eax, 36			; 00000024H
  01092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01095	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  01099	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0109c	d8 aa a8 22 00
	00		 fsubr	 DWORD PTR [edx+8872]
  010a2	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010a5	d9 98 a8 22 00
	00		 fstp	 DWORD PTR [eax+8872]

; 280  : 					ExUserDataSend(lpObj->m_Index);

  010ab	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  010b0	51		 push	 ecx
  010b1	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  010b6	83 c4 04	 add	 esp, 4

; 281  : 				}
; 282  : 				break;

  010b9	e9 7b 01 00 00	 jmp	 $LN12@NPCClick
$LN7@NPCClick:

; 283  : 			case 3:
; 284  : 				{
; 285  : 					if(this->NpcBase[a].Value > lpObj->GameShop.WCoinC )

  010be	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  010c1	6b c0 24	 imul	 eax, 36			; 00000024H
  010c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010c7	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  010cb	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  010ce	dc 9a 00 23 00
	00		 fcomp	 QWORD PTR [edx+8960]
  010d4	df e0		 fnstsw	 ax
  010d6	f6 c4 41	 test	 ah, 65			; 00000041H
  010d9	75 31		 jne	 SHORT $LN6@NPCClick

; 286  : 					{
; 287  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(262),this->NpcBase[a].Value);

  010db	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  010de	6b c0 24	 imul	 eax, 36			; 00000024H
  010e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010e4	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  010e8	52		 push	 edx
  010e9	68 06 01 00 00	 push	 262			; 00000106H
  010ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  010f3	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  010f8	50		 push	 eax
  010f9	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  010fe	51		 push	 ecx
  010ff	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01104	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  : 						return;

  01107	e9 6f 01 00 00	 jmp	 $LN35@NPCClick
$LN6@NPCClick:

; 289  : 					}
; 290  : 					lpObj->GameShop.WCoinC -= this->NpcBase[a].Value;

  0110c	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0110f	6b c0 24	 imul	 eax, 36			; 00000024H
  01112	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01115	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  01119	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0111c	dc aa 00 23 00
	00		 fsubr	 QWORD PTR [edx+8960]
  01122	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01125	dd 98 00 23 00
	00		 fstp	 QWORD PTR [eax+8960]

; 291  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  0112b	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0112e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01130	51		 push	 ecx
  01131	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  01136	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 292  : 				}
; 293  : 				break;

  0113b	e9 f9 00 00 00	 jmp	 $LN12@NPCClick
$LN5@NPCClick:

; 294  : 			case 4:
; 295  : 				{
; 296  : 					if(this->NpcBase[a].Value > lpObj->GameShop.WCoinP )

  01140	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  01143	6b c0 24	 imul	 eax, 36			; 00000024H
  01146	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01149	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  0114d	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01150	dc 9a f8 22 00
	00		 fcomp	 QWORD PTR [edx+8952]
  01156	df e0		 fnstsw	 ax
  01158	f6 c4 41	 test	 ah, 65			; 00000041H
  0115b	75 31		 jne	 SHORT $LN4@NPCClick

; 297  : 					{
; 298  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(263),this->NpcBase[a].Value);

  0115d	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  01160	6b c0 24	 imul	 eax, 36			; 00000024H
  01163	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01166	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  0116a	52		 push	 edx
  0116b	68 07 01 00 00	 push	 263			; 00000107H
  01170	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01175	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0117a	50		 push	 eax
  0117b	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0117e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01180	51		 push	 ecx
  01181	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01186	83 c4 0c	 add	 esp, 12			; 0000000cH

; 299  : 						return;

  01189	e9 ed 00 00 00	 jmp	 $LN35@NPCClick
$LN4@NPCClick:

; 300  : 					}
; 301  : 					lpObj->GameShop.WCoinP -= this->NpcBase[a].Value;

  0118e	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  01191	6b c0 24	 imul	 eax, 36			; 00000024H
  01194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01197	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  0119b	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0119e	dc aa f8 22 00
	00		 fsubr	 QWORD PTR [edx+8952]
  011a4	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011a7	dd 98 f8 22 00
	00		 fstp	 QWORD PTR [eax+8952]

; 302  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  011ad	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  011b2	51		 push	 ecx
  011b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  011b8	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 303  : 				}
; 304  : 				break;

  011bd	eb 7a		 jmp	 SHORT $LN12@NPCClick
$LN3@NPCClick:

; 305  : 			case 5:
; 306  : 				{
; 307  : 					if(this->NpcBase[a].Value > lpObj->GameShop.GoblinPoint )

  011bf	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  011c2	6b c0 24	 imul	 eax, 36			; 00000024H
  011c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011c8	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  011cc	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  011cf	dc 9a 08 23 00
	00		 fcomp	 QWORD PTR [edx+8968]
  011d5	df e0		 fnstsw	 ax
  011d7	f6 c4 41	 test	 ah, 65			; 00000041H
  011da	75 2e		 jne	 SHORT $LN2@NPCClick

; 308  : 					{
; 309  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(264),this->NpcBase[a].Value);

  011dc	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  011df	6b c0 24	 imul	 eax, 36			; 00000024H
  011e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011e5	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  011e9	52		 push	 edx
  011ea	68 08 01 00 00	 push	 264			; 00000108H
  011ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  011f4	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  011f9	50		 push	 eax
  011fa	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  011ff	51		 push	 ecx
  01200	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01205	83 c4 0c	 add	 esp, 12			; 0000000cH

; 310  : 						return;

  01208	eb 71		 jmp	 SHORT $LN35@NPCClick
$LN2@NPCClick:

; 311  : 					}
; 312  : 					lpObj->GameShop.GoblinPoint -= this->NpcBase[a].Value;

  0120a	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0120d	6b c0 24	 imul	 eax, 36			; 00000024H
  01210	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01213	db 44 01 24	 fild	 DWORD PTR [ecx+eax+36]
  01217	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0121a	dc aa 08 23 00
	00		 fsubr	 QWORD PTR [edx+8968]
  01220	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01223	dd 98 08 23 00
	00		 fstp	 QWORD PTR [eax+8968]

; 313  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  01229	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0122c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0122e	51		 push	 ecx
  0122f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  01234	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN1@NPCClick:
$LN12@NPCClick:

; 314  : 				}
; 315  : 				break;
; 316  : 			default:
; 317  : 
; 318  : 				break;
; 319  : 			}
; 320  : 
; 321  : 			gObjTeleport(lpObj->m_Index,this->NpcBase[a].TeleportMap,this->NpcBase[a].TeleportX,this->NpcBase[a].TeleportY);

  01239	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0123c	6b c0 24	 imul	 eax, 36			; 00000024H
  0123f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01242	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01247	52		 push	 edx
  01248	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0124b	6b c0 24	 imul	 eax, 36			; 00000024H
  0124e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01251	0f bf 54 01 0e	 movsx	 edx, WORD PTR [ecx+eax+14]
  01256	52		 push	 edx
  01257	8b 45 f8	 mov	 eax, DWORD PTR _a$220843[ebp]
  0125a	6b c0 24	 imul	 eax, 36			; 00000024H
  0125d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01260	0f bf 54 01 0c	 movsx	 edx, WORD PTR [ecx+eax+12]
  01265	52		 push	 edx
  01266	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01269	8b 08		 mov	 ecx, DWORD PTR [eax]
  0126b	51		 push	 ecx
  0126c	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  01271	83 c4 10	 add	 esp, 16			; 00000010H

; 322  : 			return;

  01274	eb 05		 jmp	 SHORT $LN35@NPCClick
$LN30@NPCClick:

; 323  : 		}
; 324  : 	}

  01276	e9 99 f9 ff ff	 jmp	 $LN32@NPCClick
$LN31@NPCClick:
$LN35@NPCClick:

; 325  : }

  0127b	5f		 pop	 edi
  0127c	5e		 pop	 esi
  0127d	5b		 pop	 ebx
  0127e	8b e5		 mov	 esp, ebp
  01280	5d		 pop	 ebp
  01281	c2 08 00	 ret	 8
$LN37@NPCClick:
  01284	00 00 00 00	 DD	 $LN11@NPCClick
  01288	00 00 00 00	 DD	 $LN9@NPCClick
  0128c	00 00 00 00	 DD	 $LN7@NPCClick
  01290	00 00 00 00	 DD	 $LN5@NPCClick
  01294	00 00 00 00	 DD	 $LN3@NPCClick
?NPCClick@cTeleportManager@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; cTeleportManager::NPCClick
_TEXT	ENDS
PUBLIC	?ChatDataSend@cTeleportManager@@QAEXHPAE@Z	; cTeleportManager::ChatDataSend
EXTRN	_memcmp:PROC
EXTRN	_strlen:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv285 = -80						; size = 4
_a$220886 = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Protocol$ = 12						; size = 4
?ChatDataSend@cTeleportManager@@QAEXHPAE@Z PROC		; cTeleportManager::ChatDataSend
; _this$ = ecx

; 328  : {

  012a0	55		 push	 ebp
  012a1	8b ec		 mov	 ebp, esp
  012a3	83 ec 50	 sub	 esp, 80			; 00000050H
  012a6	53		 push	 ebx
  012a7	56		 push	 esi
  012a8	57		 push	 edi
  012a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 329  : 	if(!this->Enable) return;

  012ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012af	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  012b2	85 c9		 test	 ecx, ecx
  012b4	75 05		 jne	 SHORT $LN32@ChatDataSe
  012b6	e9 80 06 00 00	 jmp	 $LN33@ChatDataSe
$LN32@ChatDataSe:

; 330  : 
; 331  : 	LPOBJ lpObj = &gObj[aIndex];

  012bb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  012be	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  012c4	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012ca	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 332  : 
; 333  : 	for(int a=0;a<this->CountCMD;a++)

  012cd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _a$220886[ebp], 0
  012d4	eb 09		 jmp	 SHORT $LN31@ChatDataSe
$LN30@ChatDataSe:
  012d6	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  012d9	83 c0 01	 add	 eax, 1
  012dc	89 45 f4	 mov	 DWORD PTR _a$220886[ebp], eax
$LN31@ChatDataSe:
  012df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012e2	8b 4d f4	 mov	 ecx, DWORD PTR _a$220886[ebp]
  012e5	3b 88 c8 2b 00
	00		 cmp	 ecx, DWORD PTR [eax+11208]
  012eb	0f 8d 4a 06 00
	00		 jge	 $LN29@ChatDataSe

; 334  : 	{
; 335  : 		if(!memcmp(&Protocol[13],this->CmdBase[a].Command,strlen(this->CmdBase[a].Command)))

  012f1	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  012f4	6b c0 4c	 imul	 eax, 76			; 0000004cH
  012f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012fa	8d 94 01 14 0e
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3604]
  01301	52		 push	 edx
  01302	e8 00 00 00 00	 call	 _strlen
  01307	83 c4 04	 add	 esp, 4
  0130a	50		 push	 eax
  0130b	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  0130e	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01311	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01314	8d 94 01 14 0e
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3604]
  0131b	52		 push	 edx
  0131c	8b 45 0c	 mov	 eax, DWORD PTR _Protocol$[ebp]
  0131f	83 c0 0d	 add	 eax, 13			; 0000000dH
  01322	50		 push	 eax
  01323	e8 00 00 00 00	 call	 _memcmp
  01328	83 c4 0c	 add	 esp, 12			; 0000000cH
  0132b	85 c0		 test	 eax, eax
  0132d	0f 85 03 06 00
	00		 jne	 $LN28@ChatDataSe

; 336  : 		{
; 337  : 			// ----
; 338  : 
; 339  : 			if(this->CmdBase[a].Level > lpObj->Level)

  01333	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01336	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01339	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0133c	0f bf 94 01 4c
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3660]
  01344	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01347	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  0134e	3b d1		 cmp	 edx, ecx
  01350	7e 35		 jle	 SHORT $LN27@ChatDataSe

; 340  : 			{
; 341  : 				MsgNormal(lpObj->m_Index,g_ExText.GetText(255),this->CmdBase[a].Level);

  01352	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01355	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01358	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0135b	0f bf 94 01 4c
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3660]
  01363	52		 push	 edx
  01364	68 ff 00 00 00	 push	 255			; 000000ffH
  01369	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  0136e	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01373	50		 push	 eax
  01374	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01377	8b 08		 mov	 ecx, DWORD PTR [eax]
  01379	51		 push	 ecx
  0137a	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0137f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 342  : 				return;

  01382	e9 b4 05 00 00	 jmp	 $LN33@ChatDataSe
$LN27@ChatDataSe:

; 343  : 			}
; 344  : 
; 345  : 			if(this->CmdBase[a].Reset > lpObj->Reset)

  01387	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  0138a	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0138d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01390	0f bf 94 01 4e
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3662]
  01398	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0139b	3b 90 90 22 00
	00		 cmp	 edx, DWORD PTR [eax+8848]
  013a1	7e 35		 jle	 SHORT $LN26@ChatDataSe

; 346  : 			{
; 347  : 				MsgNormal(lpObj->m_Index,g_ExText.GetText(256),this->CmdBase[a].Reset);

  013a3	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  013a6	6b c0 4c	 imul	 eax, 76			; 0000004cH
  013a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013ac	0f bf 94 01 4e
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3662]
  013b4	52		 push	 edx
  013b5	68 00 01 00 00	 push	 256			; 00000100H
  013ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  013bf	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  013c4	50		 push	 eax
  013c5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  013ca	51		 push	 ecx
  013cb	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  013d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 				return;

  013d3	e9 63 05 00 00	 jmp	 $LN33@ChatDataSe
$LN26@ChatDataSe:

; 349  : 			}
; 350  : 
; 351  : 			if(this->CmdBase[a].GReset > lpObj->GReset)

  013d8	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  013db	6b c0 4c	 imul	 eax, 76			; 0000004cH
  013de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013e1	0f bf 94 01 50
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3664]
  013e9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013ec	3b 90 94 22 00
	00		 cmp	 edx, DWORD PTR [eax+8852]
  013f2	7e 35		 jle	 SHORT $LN25@ChatDataSe

; 352  : 			{
; 353  : 				MsgNormal(lpObj->m_Index,g_ExText.GetText(257),this->CmdBase[a].GReset);

  013f4	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  013f7	6b c0 4c	 imul	 eax, 76			; 0000004cH
  013fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013fd	0f bf 94 01 50
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3664]
  01405	52		 push	 edx
  01406	68 01 01 00 00	 push	 257			; 00000101H
  0140b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01410	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01415	50		 push	 eax
  01416	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01419	8b 08		 mov	 ecx, DWORD PTR [eax]
  0141b	51		 push	 ecx
  0141c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01421	83 c4 0c	 add	 esp, 12			; 0000000cH

; 354  : 				return;

  01424	e9 12 05 00 00	 jmp	 $LN33@ChatDataSe
$LN25@ChatDataSe:

; 355  : 			}
; 356  : 
; 357  : 			if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 358  : 				g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 359  : 				g_ExLicense.CheckUser(eExUB::SILVER2)	 ||
; 360  : 				g_ExLicense.CheckUser(eExUB::Gredy)		 || 
; 361  : 				g_ExLicense.CheckUser(eExUB::GredyLocal) || 
; 362  : 				g_ExLicense.CheckUser(eExUB::Gredy2) )

  01429	6a 00		 push	 0
  0142b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01430	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01435	0f b6 c0	 movzx	 eax, al
  01438	85 c0		 test	 eax, eax
  0143a	75 63		 jne	 SHORT $LN23@ChatDataSe
  0143c	6a 07		 push	 7
  0143e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01443	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01448	0f b6 c0	 movzx	 eax, al
  0144b	85 c0		 test	 eax, eax
  0144d	75 50		 jne	 SHORT $LN23@ChatDataSe
  0144f	6a 08		 push	 8
  01451	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01456	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0145b	0f b6 c0	 movzx	 eax, al
  0145e	85 c0		 test	 eax, eax
  01460	75 3d		 jne	 SHORT $LN23@ChatDataSe
  01462	6a 20		 push	 32			; 00000020H
  01464	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01469	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0146e	0f b6 c0	 movzx	 eax, al
  01471	85 c0		 test	 eax, eax
  01473	75 2a		 jne	 SHORT $LN23@ChatDataSe
  01475	6a 21		 push	 33			; 00000021H
  01477	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0147c	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01481	0f b6 c0	 movzx	 eax, al
  01484	85 c0		 test	 eax, eax
  01486	75 17		 jne	 SHORT $LN23@ChatDataSe
  01488	6a 22		 push	 34			; 00000022H
  0148a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0148f	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01494	0f b6 c0	 movzx	 eax, al
  01497	85 c0		 test	 eax, eax
  01499	0f 84 a2 00 00
	00		 je	 $LN21@ChatDataSe
$LN23@ChatDataSe:

; 363  : 			{
; 364  : 				if(this->CmdBase[a].MaxReset < lpObj->Reset)

  0149f	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  014a2	6b c0 4c	 imul	 eax, 76			; 0000004cH
  014a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014a8	0f bf 94 01 52
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3666]
  014b0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014b3	3b 90 90 22 00
	00		 cmp	 edx, DWORD PTR [eax+8848]
  014b9	7d 35		 jge	 SHORT $LN22@ChatDataSe

; 365  : 				{
; 366  : 					MsgNormal(lpObj->m_Index,g_ExText.GetText(265),this->CmdBase[a].MaxReset);

  014bb	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  014be	6b c0 4c	 imul	 eax, 76			; 0000004cH
  014c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014c4	0f bf 94 01 52
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3666]
  014cc	52		 push	 edx
  014cd	68 09 01 00 00	 push	 265			; 00000109H
  014d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  014d7	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  014dc	50		 push	 eax
  014dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  014e2	51		 push	 ecx
  014e3	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  014e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 367  : 					return;

  014eb	e9 4b 04 00 00	 jmp	 $LN33@ChatDataSe
$LN22@ChatDataSe:

; 368  : 				}
; 369  : 
; 370  : 				if(this->CmdBase[a].MaxGReset < lpObj->GReset)

  014f0	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  014f3	6b c0 4c	 imul	 eax, 76			; 0000004cH
  014f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014f9	0f bf 94 01 54
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3668]
  01501	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01504	3b 90 94 22 00
	00		 cmp	 edx, DWORD PTR [eax+8852]
  0150a	7d 35		 jge	 SHORT $LN21@ChatDataSe

; 371  : 				{
; 372  : 					MsgNormal(lpObj->m_Index,g_ExText.GetText(266),this->CmdBase[a].MaxGReset);

  0150c	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  0150f	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01512	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01515	0f bf 94 01 54
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3668]
  0151d	52		 push	 edx
  0151e	68 0a 01 00 00	 push	 266			; 0000010aH
  01523	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01528	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0152d	50		 push	 eax
  0152e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01531	8b 08		 mov	 ecx, DWORD PTR [eax]
  01533	51		 push	 ecx
  01534	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01539	83 c4 0c	 add	 esp, 12			; 0000000cH

; 373  : 					return;

  0153c	e9 fa 03 00 00	 jmp	 $LN33@ChatDataSe
$LN21@ChatDataSe:

; 374  : 				}
; 375  : 			}
; 376  : 
; 377  : 			if(this->CmdBase[a].Premium)

  01541	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01544	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01547	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0154a	0f bf 94 01 56
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3670]
  01552	85 d2		 test	 edx, edx
  01554	0f 84 b4 00 00
	00		 je	 $LN14@ChatDataSe

; 378  : 			{
; 379  : 				if(g_ExLicense.CheckUser(eExUB::SILVER1) || g_ExLicense.CheckUser(eExUB::SILVER2))

  0155a	6a 07		 push	 7
  0155c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01561	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01566	0f b6 c0	 movzx	 eax, al
  01569	85 c0		 test	 eax, eax
  0156b	75 13		 jne	 SHORT $LN18@ChatDataSe
  0156d	6a 08		 push	 8
  0156f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01574	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01579	0f b6 c0	 movzx	 eax, al
  0157c	85 c0		 test	 eax, eax
  0157e	74 5f		 je	 SHORT $LN19@ChatDataSe
$LN18@ChatDataSe:

; 380  : 				{
; 381  : 					if(this->CmdBase[a].Premium != lpObj->PremiumTimeType || lpObj->PremiumTime == 0)

  01580	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01583	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01586	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01589	0f bf 94 01 56
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3670]
  01591	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01594	3b 90 bc 22 00
	00		 cmp	 edx, DWORD PTR [eax+8892]
  0159a	75 0c		 jne	 SHORT $LN16@ChatDataSe
  0159c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0159f	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  015a6	75 35		 jne	 SHORT $LN17@ChatDataSe
$LN16@ChatDataSe:

; 382  : 					{
; 383  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(258), this->CmdBase[a].Premium);

  015a8	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  015ab	6b c0 4c	 imul	 eax, 76			; 0000004cH
  015ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015b1	0f bf 94 01 56
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3670]
  015b9	52		 push	 edx
  015ba	68 02 01 00 00	 push	 258			; 00000102H
  015bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  015c4	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  015c9	50		 push	 eax
  015ca	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  015cf	51		 push	 ecx
  015d0	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  015d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 						return;

  015d8	e9 5e 03 00 00	 jmp	 $LN33@ChatDataSe
$LN17@ChatDataSe:

; 385  : 					}
; 386  : 				}
; 387  : 				else

  015dd	eb 2f		 jmp	 SHORT $LN14@ChatDataSe
$LN19@ChatDataSe:

; 388  : 				{
; 389  : 					if(lpObj->PremiumTime == 0)

  015df	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015e2	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  015e9	75 23		 jne	 SHORT $LN14@ChatDataSe

; 390  : 					{
; 391  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(259));

  015eb	68 03 01 00 00	 push	 259			; 00000103H
  015f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  015f5	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  015fa	50		 push	 eax
  015fb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  01600	51		 push	 ecx
  01601	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01606	83 c4 08	 add	 esp, 8

; 392  : 						return;

  01609	e9 2d 03 00 00	 jmp	 $LN33@ChatDataSe
$LN14@ChatDataSe:

; 393  : 					}
; 394  : 				}
; 395  : 			}
; 396  : 
; 397  : 			switch(this->CmdBase[a].Price)

  0160e	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01611	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01614	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01617	8b 94 01 58 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3672]
  0161e	89 55 b0	 mov	 DWORD PTR tv285[ebp], edx
  01621	8b 45 b0	 mov	 eax, DWORD PTR tv285[ebp]
  01624	83 e8 01	 sub	 eax, 1
  01627	89 45 b0	 mov	 DWORD PTR tv285[ebp], eax
  0162a	83 7d b0 04	 cmp	 DWORD PTR tv285[ebp], 4
  0162e	0f 87 bc 02 00
	00		 ja	 $LN1@ChatDataSe
  01634	8b 4d b0	 mov	 ecx, DWORD PTR tv285[ebp]
  01637	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN35@ChatDataSe[ecx*4]
$LN11@ChatDataSe:

; 398  : 			{
; 399  : 			case 1:
; 400  : 				{
; 401  : 					if(this->CmdBase[a].Value > lpObj->Money )

  0163e	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01641	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01644	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01647	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0164a	8b 84 01 5c 0e
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3676]
  01651	3b 82 f0 00 00
	00		 cmp	 eax, DWORD PTR [edx+240]
  01657	7e 34		 jle	 SHORT $LN10@ChatDataSe

; 402  : 					{
; 403  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(260),this->CmdBase[a].Value);

  01659	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  0165c	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0165f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01662	8b 94 01 5c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3676]
  01669	52		 push	 edx
  0166a	68 04 01 00 00	 push	 260			; 00000104H
  0166f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01674	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01679	50		 push	 eax
  0167a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0167d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0167f	51		 push	 ecx
  01680	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01685	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  : 						return;

  01688	e9 ae 02 00 00	 jmp	 $LN33@ChatDataSe
$LN10@ChatDataSe:

; 405  : 					}
; 406  : 					lpObj->Money -= this->CmdBase[a].Value;

  0168d	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01690	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01693	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01696	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01699	8b 89 f0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+240]
  0169f	2b 8c 02 5c 0e
	00 00		 sub	 ecx, DWORD PTR [edx+eax+3676]
  016a6	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016a9	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 407  : 					GCMoneySend(lpObj->m_Index,lpObj->Money);

  016af	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016b2	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  016b8	51		 push	 ecx
  016b9	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016bc	8b 02		 mov	 eax, DWORD PTR [edx]
  016be	50		 push	 eax
  016bf	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  016c4	83 c4 08	 add	 esp, 8

; 408  : 				}
; 409  : 				break;

  016c7	e9 24 02 00 00	 jmp	 $LN12@ChatDataSe
$LN9@ChatDataSe:

; 410  : 			case 2:
; 411  : 				{
; 412  : 					if(this->CmdBase[a].Value > lpObj->ExCred )

  016cc	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  016cf	6b c0 4c	 imul	 eax, 76			; 0000004cH
  016d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016d5	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  016dc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016df	d9 82 a8 22 00
	00		 fld	 DWORD PTR [edx+8872]
  016e5	de d9		 fcompp
  016e7	df e0		 fnstsw	 ax
  016e9	f6 c4 05	 test	 ah, 5
  016ec	7a 34		 jp	 SHORT $LN8@ChatDataSe

; 413  : 					{
; 414  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(261),this->CmdBase[a].Value);

  016ee	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  016f1	6b c0 4c	 imul	 eax, 76			; 0000004cH
  016f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016f7	8b 94 01 5c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3676]
  016fe	52		 push	 edx
  016ff	68 05 01 00 00	 push	 261			; 00000105H
  01704	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01709	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0170e	50		 push	 eax
  0170f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01712	8b 08		 mov	 ecx, DWORD PTR [eax]
  01714	51		 push	 ecx
  01715	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0171a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  : 						return;

  0171d	e9 19 02 00 00	 jmp	 $LN33@ChatDataSe
$LN8@ChatDataSe:

; 416  : 					}
; 417  : 					lpObj->ExCred -= this->CmdBase[a].Value;

  01722	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01725	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01728	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0172b	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  01732	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01735	d8 aa a8 22 00
	00		 fsubr	 DWORD PTR [edx+8872]
  0173b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0173e	d9 98 a8 22 00
	00		 fstp	 DWORD PTR [eax+8872]

; 418  : 					ExUserDataSend(lpObj->m_Index);

  01744	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01747	8b 08		 mov	 ecx, DWORD PTR [eax]
  01749	51		 push	 ecx
  0174a	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  0174f	83 c4 04	 add	 esp, 4

; 419  : 				}
; 420  : 				break;

  01752	e9 99 01 00 00	 jmp	 $LN12@ChatDataSe
$LN7@ChatDataSe:

; 421  : 			case 3:
; 422  : 				{
; 423  : 					if(this->CmdBase[a].Value > lpObj->GameShop.WCoinC )

  01757	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  0175a	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0175d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01760	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  01767	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0176a	dc 9a 00 23 00
	00		 fcomp	 QWORD PTR [edx+8960]
  01770	df e0		 fnstsw	 ax
  01772	f6 c4 41	 test	 ah, 65			; 00000041H
  01775	75 34		 jne	 SHORT $LN6@ChatDataSe

; 424  : 					{
; 425  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(262),this->CmdBase[a].Value);

  01777	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  0177a	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0177d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01780	8b 94 01 5c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3676]
  01787	52		 push	 edx
  01788	68 06 01 00 00	 push	 262			; 00000106H
  0178d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01792	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01797	50		 push	 eax
  01798	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0179b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0179d	51		 push	 ecx
  0179e	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  017a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 426  : 						return;

  017a6	e9 90 01 00 00	 jmp	 $LN33@ChatDataSe
$LN6@ChatDataSe:

; 427  : 					}
; 428  : 					lpObj->GameShop.WCoinC -= this->CmdBase[a].Value;

  017ab	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  017ae	6b c0 4c	 imul	 eax, 76			; 0000004cH
  017b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017b4	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  017bb	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017be	dc aa 00 23 00
	00		 fsubr	 QWORD PTR [edx+8960]
  017c4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017c7	dd 98 00 23 00
	00		 fstp	 QWORD PTR [eax+8960]

; 429  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  017cd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017d0	8b 08		 mov	 ecx, DWORD PTR [eax]
  017d2	51		 push	 ecx
  017d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  017d8	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 430  : 				}
; 431  : 				break;

  017dd	e9 0e 01 00 00	 jmp	 $LN12@ChatDataSe
$LN5@ChatDataSe:

; 432  : 			case 4:
; 433  : 				{
; 434  : 					if(this->CmdBase[a].Value > lpObj->GameShop.WCoinP )

  017e2	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  017e5	6b c0 4c	 imul	 eax, 76			; 0000004cH
  017e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017eb	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  017f2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017f5	dc 9a f8 22 00
	00		 fcomp	 QWORD PTR [edx+8952]
  017fb	df e0		 fnstsw	 ax
  017fd	f6 c4 41	 test	 ah, 65			; 00000041H
  01800	75 34		 jne	 SHORT $LN4@ChatDataSe

; 435  : 					{
; 436  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(263),this->CmdBase[a].Value);

  01802	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01805	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01808	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0180b	8b 94 01 5c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3676]
  01812	52		 push	 edx
  01813	68 07 01 00 00	 push	 263			; 00000107H
  01818	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  0181d	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01822	50		 push	 eax
  01823	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01826	8b 08		 mov	 ecx, DWORD PTR [eax]
  01828	51		 push	 ecx
  01829	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0182e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 						return;

  01831	e9 05 01 00 00	 jmp	 $LN33@ChatDataSe
$LN4@ChatDataSe:

; 438  : 					}
; 439  : 					lpObj->GameShop.WCoinP -= this->CmdBase[a].Value;

  01836	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01839	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0183c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0183f	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  01846	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01849	dc aa f8 22 00
	00		 fsubr	 QWORD PTR [edx+8952]
  0184f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01852	dd 98 f8 22 00
	00		 fstp	 QWORD PTR [eax+8952]

; 440  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  01858	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0185b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0185d	51		 push	 ecx
  0185e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  01863	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 441  : 				}
; 442  : 				break;

  01868	e9 83 00 00 00	 jmp	 $LN12@ChatDataSe
$LN3@ChatDataSe:

; 443  : 			case 5:
; 444  : 				{
; 445  : 					if(this->CmdBase[a].Value > lpObj->GameShop.GoblinPoint )

  0186d	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01870	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01873	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01876	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  0187d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01880	dc 9a 08 23 00
	00		 fcomp	 QWORD PTR [edx+8968]
  01886	df e0		 fnstsw	 ax
  01888	f6 c4 41	 test	 ah, 65			; 00000041H
  0188b	75 31		 jne	 SHORT $LN2@ChatDataSe

; 446  : 					{
; 447  : 						MsgNormal(lpObj->m_Index,g_ExText.GetText(264),this->CmdBase[a].Value);

  0188d	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01890	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01893	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01896	8b 94 01 5c 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3676]
  0189d	52		 push	 edx
  0189e	68 08 01 00 00	 push	 264			; 00000108H
  018a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  018a8	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  018ad	50		 push	 eax
  018ae	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  018b3	51		 push	 ecx
  018b4	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  018b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 448  : 						return;

  018bc	eb 7d		 jmp	 SHORT $LN33@ChatDataSe
$LN2@ChatDataSe:

; 449  : 					}
; 450  : 					lpObj->GameShop.GoblinPoint -= this->CmdBase[a].Value;

  018be	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  018c1	6b c0 4c	 imul	 eax, 76			; 0000004cH
  018c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  018c7	db 84 01 5c 0e
	00 00		 fild	 DWORD PTR [ecx+eax+3676]
  018ce	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  018d1	dc aa 08 23 00
	00		 fsubr	 QWORD PTR [edx+8968]
  018d7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018da	dd 98 08 23 00
	00		 fstp	 QWORD PTR [eax+8968]

; 451  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  018e0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  018e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  018e5	51		 push	 ecx
  018e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  018eb	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN1@ChatDataSe:
$LN12@ChatDataSe:

; 452  : 				}
; 453  : 				break;
; 454  : 			default:
; 455  : 
; 456  : 				break;
; 457  : 			}
; 458  : 
; 459  : 			gObjTeleport(lpObj->m_Index,this->CmdBase[a].TeleportMap,this->CmdBase[a].TeleportX,this->CmdBase[a].TeleportY);

  018f0	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  018f3	6b c0 4c	 imul	 eax, 76			; 0000004cH
  018f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  018f9	0f bf 94 01 4a
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3658]
  01901	52		 push	 edx
  01902	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01905	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01908	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0190b	0f bf 94 01 48
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3656]
  01913	52		 push	 edx
  01914	8b 45 f4	 mov	 eax, DWORD PTR _a$220886[ebp]
  01917	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0191a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0191d	0f bf 94 01 46
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3654]
  01925	52		 push	 edx
  01926	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01929	8b 08		 mov	 ecx, DWORD PTR [eax]
  0192b	51		 push	 ecx
  0192c	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  01931	83 c4 10	 add	 esp, 16			; 00000010H

; 460  : 			return;

  01934	eb 05		 jmp	 SHORT $LN33@ChatDataSe
$LN28@ChatDataSe:

; 461  : 		}
; 462  : 	}

  01936	e9 9b f9 ff ff	 jmp	 $LN30@ChatDataSe
$LN29@ChatDataSe:
$LN33@ChatDataSe:

; 463  : }

  0193b	5f		 pop	 edi
  0193c	5e		 pop	 esi
  0193d	5b		 pop	 ebx
  0193e	8b e5		 mov	 esp, ebp
  01940	5d		 pop	 ebp
  01941	c2 08 00	 ret	 8
$LN35@ChatDataSe:
  01944	00 00 00 00	 DD	 $LN11@ChatDataSe
  01948	00 00 00 00	 DD	 $LN9@ChatDataSe
  0194c	00 00 00 00	 DD	 $LN7@ChatDataSe
  01950	00 00 00 00	 DD	 $LN5@ChatDataSe
  01954	00 00 00 00	 DD	 $LN3@ChatDataSe
?ChatDataSend@cTeleportManager@@QAEXHPAE@Z ENDP		; cTeleportManager::ChatDataSend
_TEXT	ENDS
PUBLIC	??_C@_0BH@KHMLGCFI@?$FLNeed?5Premium?$FN?3?5Status?$AA@ ; `string'
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0EH@EEJKLAMG@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
PUBLIC	?__LINE__Var@?1??CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z@4JA ; `cTeleportManager::CheckTeleoprtMap'::`2'::__LINE__Var
PUBLIC	?CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z	; cTeleportManager::CheckTeleoprtMap
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
;	COMDAT ??_C@_0BH@KHMLGCFI@?$FLNeed?5Premium?$FN?3?5Status?$AA@
CONST	SEGMENT
??_C@_0BH@KHMLGCFI@?$FLNeed?5Premium?$FN?3?5Status?$AA@ DB '[Need Premium'
	DB	']: Status', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@EEJKLAMG@d?3?2projects?2exteam6?43?2source?2gam@
CONST	SEGMENT
??_C@_0EH@EEJKLAMG@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\teleportmanager.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z@4JA DD 01d2H ; `cTeleportManager::CheckTeleoprtMap'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
tv78 = -88						; size = 4
tv69 = -88						; size = 4
_a$220942 = -20						; size = 4
_a$220935 = -16						; size = 4
_lpTarget$ = -12					; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z PROC	; cTeleportManager::CheckTeleoprtMap
; _this$ = ecx

; 466  : {

  01960	55		 push	 ebp
  01961	8b ec		 mov	 ebp, esp
  01963	83 ec 58	 sub	 esp, 88			; 00000058H
  01966	53		 push	 ebx
  01967	56		 push	 esi
  01968	57		 push	 edi
  01969	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 467  : 	if(!this->Enable)

  0196c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0196f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  01972	85 c9		 test	 ecx, ecx
  01974	75 07		 jne	 SHORT $LN15@CheckTeleo

; 468  : 	{
; 469  : 		return true;

  01976	b0 01		 mov	 al, 1
  01978	e9 c0 01 00 00	 jmp	 $LN16@CheckTeleo
$LN15@CheckTeleo:

; 470  : 	}
; 471  : 
; 472  : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0197d	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01981	7d 09		 jge	 SHORT $LN18@CheckTeleo
  01983	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0198a	eb 0f		 jmp	 SHORT $LN19@CheckTeleo
$LN18@CheckTeleo:
  0198c	33 c0		 xor	 eax, eax
  0198e	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  01995	0f 9e c0	 setle	 al
  01998	89 45 a8	 mov	 DWORD PTR tv69[ebp], eax
$LN19@CheckTeleo:
  0199b	83 7d a8 00	 cmp	 DWORD PTR tv69[ebp], 0
  0199f	75 23		 jne	 SHORT $LN14@CheckTeleo

; 473  : 	{
; 474  : 		LogAdd("error : %s %d", __FILE__, __LINE__ );

  019a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z@4JA
  019a6	83 c0 08	 add	 eax, 8
  019a9	50		 push	 eax
  019aa	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@EEJKLAMG@d?3?2projects?2exteam6?43?2source?2gam@
  019af	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  019b4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  019ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 475  : 		return false;

  019bd	32 c0		 xor	 al, al
  019bf	e9 79 01 00 00	 jmp	 $LN16@CheckTeleo
$LN14@CheckTeleo:

; 476  : 	}
; 477  : 
; 478  : 	if ( OBJMAX_RANGE(aTargetIndex) == FALSE )

  019c4	83 7d 0c 00	 cmp	 DWORD PTR _aTargetIndex$[ebp], 0
  019c8	7d 09		 jge	 SHORT $LN20@CheckTeleo
  019ca	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  019d1	eb 0f		 jmp	 SHORT $LN21@CheckTeleo
$LN20@CheckTeleo:
  019d3	33 c0		 xor	 eax, eax
  019d5	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aTargetIndex$[ebp], 14999 ; 00003a97H
  019dc	0f 9e c0	 setle	 al
  019df	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
$LN21@CheckTeleo:
  019e2	83 7d a8 00	 cmp	 DWORD PTR tv78[ebp], 0
  019e6	75 23		 jne	 SHORT $LN13@CheckTeleo

; 479  : 	{
; 480  : 		LogAdd("error : %s %d", __FILE__, __LINE__ );

  019e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z@4JA
  019ed	83 c0 0e	 add	 eax, 14			; 0000000eH
  019f0	50		 push	 eax
  019f1	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@EEJKLAMG@d?3?2projects?2exteam6?43?2source?2gam@
  019f6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  019fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01a01	83 c4 0c	 add	 esp, 12			; 0000000cH

; 481  : 		return false;

  01a04	32 c0		 xor	 al, al
  01a06	e9 32 01 00 00	 jmp	 $LN16@CheckTeleo
$LN13@CheckTeleo:

; 482  : 	}
; 483  : 
; 484  : 	LPOBJ lpUser = &gObj[aIndex];

  01a0b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01a0e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a14	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a1a	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 485  : 	LPOBJ lpTarget = &gObj[aTargetIndex];

  01a1d	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  01a20	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a26	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a2c	89 45 f4	 mov	 DWORD PTR _lpTarget$[ebp], eax

; 486  : 
; 487  : 	if(lpUser->Connected < PLAYER_PLAYING)

  01a2f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01a32	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  01a36	7d 07		 jge	 SHORT $LN12@CheckTeleo

; 488  : 	{
; 489  : 		return false;

  01a38	32 c0		 xor	 al, al
  01a3a	e9 fe 00 00 00	 jmp	 $LN16@CheckTeleo
$LN12@CheckTeleo:

; 490  : 	}
; 491  : 
; 492  : 	if(lpTarget->Connected < PLAYER_PLAYING)

  01a3f	8b 45 f4	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  01a42	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  01a46	7d 07		 jge	 SHORT $LN11@CheckTeleo

; 493  : 	{
; 494  : 		return false;

  01a48	32 c0		 xor	 al, al
  01a4a	e9 ee 00 00 00	 jmp	 $LN16@CheckTeleo
$LN11@CheckTeleo:

; 495  : 	}
; 496  : 
; 497  : 	for(int a=0;a<this->CountNPC;a++)

  01a4f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _a$220935[ebp], 0
  01a56	eb 09		 jmp	 SHORT $LN10@CheckTeleo
$LN9@CheckTeleo:
  01a58	8b 45 f0	 mov	 eax, DWORD PTR _a$220935[ebp]
  01a5b	83 c0 01	 add	 eax, 1
  01a5e	89 45 f0	 mov	 DWORD PTR _a$220935[ebp], eax
$LN10@CheckTeleo:
  01a61	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a64	8b 4d f0	 mov	 ecx, DWORD PTR _a$220935[ebp]
  01a67	3b 88 c4 2b 00
	00		 cmp	 ecx, DWORD PTR [eax+11204]
  01a6d	7d 53		 jge	 SHORT $LN8@CheckTeleo

; 498  : 	{
; 499  : 		if(this->NpcBase[a].Premium)

  01a6f	8b 45 f0	 mov	 eax, DWORD PTR _a$220935[ebp]
  01a72	6b c0 24	 imul	 eax, 36			; 00000024H
  01a75	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a78	0f bf 54 01 1c	 movsx	 edx, WORD PTR [ecx+eax+28]
  01a7d	85 d2		 test	 edx, edx
  01a7f	74 3f		 je	 SHORT $LN7@CheckTeleo

; 500  : 		{
; 501  : 			if(lpTarget->PremiumTime == 0 && this->NpcBase[a].TeleportMap == lpUser->MapNumber)

  01a81	8b 45 f4	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  01a84	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  01a8b	75 33		 jne	 SHORT $LN7@CheckTeleo
  01a8d	8b 45 f0	 mov	 eax, DWORD PTR _a$220935[ebp]
  01a90	6b c0 24	 imul	 eax, 36			; 00000024H
  01a93	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a96	0f bf 54 01 0c	 movsx	 edx, WORD PTR [ecx+eax+12]
  01a9b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01a9e	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  01aa5	3b d1		 cmp	 edx, ecx
  01aa7	75 17		 jne	 SHORT $LN7@CheckTeleo

; 502  : 			{
; 503  : 				MsgNormal(lpTarget->m_Index,"[Need Premium]: Status");

  01aa9	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KHMLGCFI@?$FLNeed?5Premium?$FN?3?5Status?$AA@
  01aae	8b 45 f4	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  01ab1	8b 08		 mov	 ecx, DWORD PTR [eax]
  01ab3	51		 push	 ecx
  01ab4	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01ab9	83 c4 08	 add	 esp, 8

; 504  : 				return false;

  01abc	32 c0		 xor	 al, al
  01abe	eb 7d		 jmp	 SHORT $LN16@CheckTeleo
$LN7@CheckTeleo:

; 505  : 			}
; 506  : 		}
; 507  : 	}

  01ac0	eb 96		 jmp	 SHORT $LN9@CheckTeleo
$LN8@CheckTeleo:

; 508  : 
; 509  : 	for(int a=0;a<this->CountCMD;a++)

  01ac2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _a$220942[ebp], 0
  01ac9	eb 09		 jmp	 SHORT $LN5@CheckTeleo
$LN4@CheckTeleo:
  01acb	8b 45 ec	 mov	 eax, DWORD PTR _a$220942[ebp]
  01ace	83 c0 01	 add	 eax, 1
  01ad1	89 45 ec	 mov	 DWORD PTR _a$220942[ebp], eax
$LN5@CheckTeleo:
  01ad4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ad7	8b 4d ec	 mov	 ecx, DWORD PTR _a$220942[ebp]
  01ada	3b 88 c8 2b 00
	00		 cmp	 ecx, DWORD PTR [eax+11208]
  01ae0	7d 59		 jge	 SHORT $LN3@CheckTeleo

; 510  : 	{
; 511  : 		if(this->CmdBase[a].Premium)

  01ae2	8b 45 ec	 mov	 eax, DWORD PTR _a$220942[ebp]
  01ae5	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01ae8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aeb	0f bf 94 01 56
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3670]
  01af3	85 d2		 test	 edx, edx
  01af5	74 42		 je	 SHORT $LN2@CheckTeleo

; 512  : 		{
; 513  : 			if(lpTarget->PremiumTime == 0 && this->CmdBase[a].TeleportMap == lpUser->MapNumber)

  01af7	8b 45 f4	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  01afa	83 b8 b8 22 00
	00 00		 cmp	 DWORD PTR [eax+8888], 0
  01b01	75 36		 jne	 SHORT $LN2@CheckTeleo
  01b03	8b 45 ec	 mov	 eax, DWORD PTR _a$220942[ebp]
  01b06	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01b09	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b0c	0f bf 94 01 46
	0e 00 00	 movsx	 edx, WORD PTR [ecx+eax+3654]
  01b14	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  01b17	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  01b1e	3b d1		 cmp	 edx, ecx
  01b20	75 17		 jne	 SHORT $LN2@CheckTeleo

; 514  : 			{
; 515  : 				MsgNormal(lpTarget->m_Index,"[Need Premium]: Status");

  01b22	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KHMLGCFI@?$FLNeed?5Premium?$FN?3?5Status?$AA@
  01b27	8b 45 f4	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  01b2a	8b 08		 mov	 ecx, DWORD PTR [eax]
  01b2c	51		 push	 ecx
  01b2d	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01b32	83 c4 08	 add	 esp, 8

; 516  : 				return false;

  01b35	32 c0		 xor	 al, al
  01b37	eb 04		 jmp	 SHORT $LN16@CheckTeleo
$LN2@CheckTeleo:

; 517  : 			}
; 518  : 		}
; 519  : 	}

  01b39	eb 90		 jmp	 SHORT $LN4@CheckTeleo
$LN3@CheckTeleo:

; 520  : 
; 521  : 	return true;

  01b3b	b0 01		 mov	 al, 1
$LN16@CheckTeleo:

; 522  : 
; 523  : }

  01b3d	5f		 pop	 edi
  01b3e	5e		 pop	 esi
  01b3f	5b		 pop	 ebx
  01b40	8b e5		 mov	 esp, ebp
  01b42	5d		 pop	 ebp
  01b43	c2 08 00	 ret	 8
?CheckTeleoprtMap@cTeleportManager@@QAE_NHH@Z ENDP	; cTeleportManager::CheckTeleoprtMap
_TEXT	ENDS
PUBLIC	??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::operator[]
PUBLIC	?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
PUBLIC	?CheckTeleportDL@cTeleportManager@@QAE_NH@Z	; cTeleportManager::CheckTeleportDL
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220954 = -8						; size = 4
_this$ = -4						; size = 4
_map$ = 8						; size = 4
?CheckTeleportDL@cTeleportManager@@QAE_NH@Z PROC	; cTeleportManager::CheckTeleportDL
; _this$ = ecx

; 527  : {

  01b50	55		 push	 ebp
  01b51	8b ec		 mov	 ebp, esp
  01b53	83 ec 48	 sub	 esp, 72			; 00000048H
  01b56	53		 push	 ebx
  01b57	56		 push	 esi
  01b58	57		 push	 edi
  01b59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 528  : 	if( g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 529  : 		g_ExLicense.CheckUser(eExUB::SILVER2)	 )

  01b5c	6a 07		 push	 7
  01b5e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01b63	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01b68	0f b6 c0	 movzx	 eax, al
  01b6b	85 c0		 test	 eax, eax
  01b6d	75 13		 jne	 SHORT $LN5@CheckTelep
  01b6f	6a 08		 push	 8
  01b71	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01b76	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01b7b	0f b6 c0	 movzx	 eax, al
  01b7e	85 c0		 test	 eax, eax
  01b80	74 44		 je	 SHORT $LN6@CheckTelep
$LN5@CheckTelep:

; 530  : 	{
; 531  : 		for(int i = 0; i < this->m_dlblock.size(); i++)

  01b82	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220954[ebp], 0
  01b89	eb 09		 jmp	 SHORT $LN4@CheckTelep
$LN3@CheckTelep:
  01b8b	8b 45 f8	 mov	 eax, DWORD PTR _i$220954[ebp]
  01b8e	83 c0 01	 add	 eax, 1
  01b91	89 45 f8	 mov	 DWORD PTR _i$220954[ebp], eax
$LN4@CheckTelep:
  01b94	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b97	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  01b9d	e8 00 00 00 00	 call	 ?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
  01ba2	39 45 f8	 cmp	 DWORD PTR _i$220954[ebp], eax
  01ba5	73 1f		 jae	 SHORT $LN6@CheckTelep

; 532  : 		{
; 533  : 			if(this->m_dlblock[i].MapNumber == map)

  01ba7	8b 45 f8	 mov	 eax, DWORD PTR _i$220954[ebp]
  01baa	50		 push	 eax
  01bab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bae	81 c1 cc 2b 00
	00		 add	 ecx, 11212		; 00002bccH
  01bb4	e8 00 00 00 00	 call	 ??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::operator[]
  01bb9	8b 08		 mov	 ecx, DWORD PTR [eax]
  01bbb	3b 4d 08	 cmp	 ecx, DWORD PTR _map$[ebp]
  01bbe	75 04		 jne	 SHORT $LN1@CheckTelep

; 534  : 			{
; 535  : 				return false;

  01bc0	32 c0		 xor	 al, al
  01bc2	eb 04		 jmp	 SHORT $LN7@CheckTelep
$LN1@CheckTelep:

; 536  : 			}
; 537  : 		}

  01bc4	eb c5		 jmp	 SHORT $LN3@CheckTelep
$LN6@CheckTelep:

; 538  : 	}
; 539  : 
; 540  : 	return true;

  01bc6	b0 01		 mov	 al, 1
$LN7@CheckTelep:

; 541  : }

  01bc8	5f		 pop	 edi
  01bc9	5e		 pop	 esi
  01bca	5b		 pop	 ebx
  01bcb	8b e5		 mov	 esp, ebp
  01bcd	5d		 pop	 ebp
  01bce	c2 04 00	 ret	 4
?CheckTeleportDL@cTeleportManager@@QAE_NH@Z ENDP	; cTeleportManager::CheckTeleportDL
_TEXT	ENDS
PUBLIC	?CheckDLMasterTeleport@cTeleportManager@@QAE_NH@Z ; cTeleportManager::CheckDLMasterTeleport
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220965 = -8						; size = 4
_this$ = -4						; size = 4
_Map$ = 8						; size = 4
?CheckDLMasterTeleport@cTeleportManager@@QAE_NH@Z PROC	; cTeleportManager::CheckDLMasterTeleport
; _this$ = ecx

; 545  : {

  01be0	55		 push	 ebp
  01be1	8b ec		 mov	 ebp, esp
  01be3	83 ec 48	 sub	 esp, 72			; 00000048H
  01be6	53		 push	 ebx
  01be7	56		 push	 esi
  01be8	57		 push	 edi
  01be9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 546  : 	if( g_ExLicense.CheckUser(eExUB::Gredy) || g_ExLicense.CheckUser(eExUB::GredyLocal) || g_ExLicense.CheckUser(eExUB::Gredy2) )

  01bec	6a 20		 push	 32			; 00000020H
  01bee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01bf3	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01bf8	0f b6 c0	 movzx	 eax, al
  01bfb	85 c0		 test	 eax, eax
  01bfd	75 26		 jne	 SHORT $LN5@CheckDLMas
  01bff	6a 21		 push	 33			; 00000021H
  01c01	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01c06	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01c0b	0f b6 c0	 movzx	 eax, al
  01c0e	85 c0		 test	 eax, eax
  01c10	75 13		 jne	 SHORT $LN5@CheckDLMas
  01c12	6a 22		 push	 34			; 00000022H
  01c14	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01c19	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01c1e	0f b6 c0	 movzx	 eax, al
  01c21	85 c0		 test	 eax, eax
  01c23	74 44		 je	 SHORT $LN6@CheckDLMas
$LN5@CheckDLMas:

; 547  : 	{
; 548  : 		for(int i = 0; i < this->m_DLMasterBlock.size(); i++)

  01c25	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220965[ebp], 0
  01c2c	eb 09		 jmp	 SHORT $LN4@CheckDLMas
$LN3@CheckDLMas:
  01c2e	8b 45 f8	 mov	 eax, DWORD PTR _i$220965[ebp]
  01c31	83 c0 01	 add	 eax, 1
  01c34	89 45 f8	 mov	 DWORD PTR _i$220965[ebp], eax
$LN4@CheckDLMas:
  01c37	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c3a	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  01c40	e8 00 00 00 00	 call	 ?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
  01c45	39 45 f8	 cmp	 DWORD PTR _i$220965[ebp], eax
  01c48	73 1f		 jae	 SHORT $LN6@CheckDLMas

; 549  : 		{
; 550  : 			if(this->m_DLMasterBlock[i].MapNumber == Map)

  01c4a	8b 45 f8	 mov	 eax, DWORD PTR _i$220965[ebp]
  01c4d	50		 push	 eax
  01c4e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c51	81 c1 dc 2b 00
	00		 add	 ecx, 11228		; 00002bdcH
  01c57	e8 00 00 00 00	 call	 ??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::operator[]
  01c5c	8b 08		 mov	 ecx, DWORD PTR [eax]
  01c5e	3b 4d 08	 cmp	 ecx, DWORD PTR _Map$[ebp]
  01c61	75 04		 jne	 SHORT $LN1@CheckDLMas

; 551  : 			{
; 552  : 				return false;

  01c63	32 c0		 xor	 al, al
  01c65	eb 04		 jmp	 SHORT $LN7@CheckDLMas
$LN1@CheckDLMas:

; 553  : 			}
; 554  : 		}

  01c67	eb c5		 jmp	 SHORT $LN3@CheckDLMas
$LN6@CheckDLMas:

; 555  : 	}
; 556  : 
; 557  : 	return true;

  01c69	b0 01		 mov	 al, 1
$LN7@CheckDLMas:

; 558  : }

  01c6b	5f		 pop	 edi
  01c6c	5e		 pop	 esi
  01c6d	5b		 pop	 ebx
  01c6e	8b e5		 mov	 esp, ebp
  01c70	5d		 pop	 ebp
  01c71	c2 04 00	 ret	 4
?CheckDLMasterTeleport@cTeleportManager@@QAE_NH@Z ENDP	; cTeleportManager::CheckDLMasterTeleport
_TEXT	ENDS
PUBLIC	?CheckDLMemberTeleport@cTeleportManager@@QAE_NH@Z ; cTeleportManager::CheckDLMemberTeleport
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220976 = -8						; size = 4
_this$ = -4						; size = 4
_Map$ = 8						; size = 4
?CheckDLMemberTeleport@cTeleportManager@@QAE_NH@Z PROC	; cTeleportManager::CheckDLMemberTeleport
; _this$ = ecx

; 561  : {

  01c80	55		 push	 ebp
  01c81	8b ec		 mov	 ebp, esp
  01c83	83 ec 48	 sub	 esp, 72			; 00000048H
  01c86	53		 push	 ebx
  01c87	56		 push	 esi
  01c88	57		 push	 edi
  01c89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 562  : 	if( g_ExLicense.CheckUser(eExUB::Gredy) || g_ExLicense.CheckUser(eExUB::GredyLocal) || g_ExLicense.CheckUser(eExUB::Gredy2) )

  01c8c	6a 20		 push	 32			; 00000020H
  01c8e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01c93	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01c98	0f b6 c0	 movzx	 eax, al
  01c9b	85 c0		 test	 eax, eax
  01c9d	75 26		 jne	 SHORT $LN5@CheckDLMem
  01c9f	6a 21		 push	 33			; 00000021H
  01ca1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01ca6	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01cab	0f b6 c0	 movzx	 eax, al
  01cae	85 c0		 test	 eax, eax
  01cb0	75 13		 jne	 SHORT $LN5@CheckDLMem
  01cb2	6a 22		 push	 34			; 00000022H
  01cb4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01cb9	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01cbe	0f b6 c0	 movzx	 eax, al
  01cc1	85 c0		 test	 eax, eax
  01cc3	74 44		 je	 SHORT $LN6@CheckDLMem
$LN5@CheckDLMem:

; 563  : 	{
; 564  : 		for(int i = 0; i < this->m_DLMemberBlock.size(); i++)

  01cc5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220976[ebp], 0
  01ccc	eb 09		 jmp	 SHORT $LN4@CheckDLMem
$LN3@CheckDLMem:
  01cce	8b 45 f8	 mov	 eax, DWORD PTR _i$220976[ebp]
  01cd1	83 c0 01	 add	 eax, 1
  01cd4	89 45 f8	 mov	 DWORD PTR _i$220976[ebp], eax
$LN4@CheckDLMem:
  01cd7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cda	81 c1 ec 2b 00
	00		 add	 ecx, 11244		; 00002becH
  01ce0	e8 00 00 00 00	 call	 ?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
  01ce5	39 45 f8	 cmp	 DWORD PTR _i$220976[ebp], eax
  01ce8	73 1f		 jae	 SHORT $LN6@CheckDLMem

; 565  : 		{
; 566  : 			if(this->m_DLMemberBlock[i].MapNumber == Map)

  01cea	8b 45 f8	 mov	 eax, DWORD PTR _i$220976[ebp]
  01ced	50		 push	 eax
  01cee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cf1	81 c1 ec 2b 00
	00		 add	 ecx, 11244		; 00002becH
  01cf7	e8 00 00 00 00	 call	 ??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::operator[]
  01cfc	8b 08		 mov	 ecx, DWORD PTR [eax]
  01cfe	3b 4d 08	 cmp	 ecx, DWORD PTR _Map$[ebp]
  01d01	75 04		 jne	 SHORT $LN1@CheckDLMem

; 567  : 			{
; 568  : 				return false;

  01d03	32 c0		 xor	 al, al
  01d05	eb 04		 jmp	 SHORT $LN7@CheckDLMem
$LN1@CheckDLMem:

; 569  : 			}
; 570  : 		}

  01d07	eb c5		 jmp	 SHORT $LN3@CheckDLMem
$LN6@CheckDLMem:

; 571  : 	}
; 572  : 
; 573  : 	return true;

  01d09	b0 01		 mov	 al, 1
$LN7@CheckDLMem:

; 574  : }

  01d0b	5f		 pop	 edi
  01d0c	5e		 pop	 esi
  01d0d	5b		 pop	 ebx
  01d0e	8b e5		 mov	 esp, ebp
  01d10	5d		 pop	 ebp
  01d11	c2 04 00	 ret	 4
?CheckDLMemberTeleport@cTeleportManager@@QAE_NH@Z ENDP	; cTeleportManager::CheckDLMemberTeleport
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@V?$allocator@UDLTP_BLOCK_DATA@@@1@@Z ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
PUBLIC	??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@XZ	; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T221950 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T221950[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@XZ ; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@V?$allocator@UDLTP_BLOCK_DATA@@@1@@Z ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
PUBLIC	?_Tidy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
__ehhandler$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEAAUDLTP_BLOCK_DATA@@I@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@ABU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@AAU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA &>
PUBLIC	?_Orphan_range@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXI@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBE_NPBUDLTP_BLOCK_DATA@@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUDLTP_BLOCK_DATA@@@std@@YAPBUDLTP_BLOCK_DATA@@ABU1@@Z ; std::addressof<DLTP_BLOCK_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z
_TEXT	SEGMENT
__Idx$221004 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUDLTP_BLOCK_DATA@@@std@@YAPBUDLTP_BLOCK_DATA@@ABU1@@Z ; std::addressof<DLTP_BLOCK_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBE_NPBUDLTP_BLOCK_DATA@@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUDLTP_BLOCK_DATA@@@std@@YAPBUDLTP_BLOCK_DATA@@ABU1@@Z ; std::addressof<DLTP_BLOCK_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$221004[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXI@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$221004[ebp]
  00075	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@AAU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 04	 add	 ecx, 4
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXI@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@ABU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 04	 add	 ecx, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXABUDLTP_BLOCK_DATA@@@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::erase
PUBLIC	?begin@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::begin
PUBLIC	?end@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T221969 = -88						; size = 4
$T221970 = -84						; size = 4
$T221971 = -80						; size = 4
$T221972 = -76						; size = 4
$T221973 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T221970[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T221969[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T221972[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T221971[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T221969[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T221971[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T221973[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Destroy
PUBLIC	??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00@Z ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T221980 = -84						; size = 4
__Ptr$221189 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00@Z ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$221189[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$221189[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$221189[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T221980[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T221980[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBE_NPBUDLTP_BLOCK_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBE_NPBUDLTP_BLOCK_DATA@@@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBE_NPBUDLTP_BLOCK_DATA@@@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEII@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEII@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z ; std::allocator<DLTP_BLOCK_DATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 02	 sar	 edx, 2
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z ; std::allocator<DLTP_BLOCK_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXPAUDLTP_BLOCK_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXPAUDLTP_BLOCK_DATA@@0@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXPAUDLTP_BLOCK_DATA@@0@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@V?$allocator@UDLTP_BLOCK_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@V?$allocator@UDLTP_BLOCK_DATA@@@1@@Z PROC ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@V?$allocator@UDLTP_BLOCK_DATA@@@1@@Z ENDP ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::~_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@XZ PROC	; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@XZ ENDP	; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUDLTP_BLOCK_DATA@@@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEPAUDLTP_BLOCK_DATA@@PAU2@00@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Umove<DLTP_BLOCK_DATA *>
PUBLIC	?allocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEPAUDLTP_BLOCK_DATA@@I@Z ; std::allocator<DLTP_BLOCK_DATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$221231 = -28					; size = 4
__Ptr$221224 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEPAUDLTP_BLOCK_DATA@@I@Z ; std::allocator<DLTP_BLOCK_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$221224[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$221224[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUDLTP_BLOCK_DATA@@@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEPAUDLTP_BLOCK_DATA@@PAU2@00@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Umove<DLTP_BLOCK_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221224[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z ; std::allocator<DLTP_BLOCK_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$221231[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z ; std::allocator<DLTP_BLOCK_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221224[ebp]
  00114	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$221231[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221224[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221224[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UDLTP_BLOCK_DATA@@@std@@QBEIXZ ; std::allocator<DLTP_BLOCK_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UDLTP_BLOCK_DATA@@@std@@QBEIXZ ; std::allocator<DLTP_BLOCK_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEXPAUDLTP_BLOCK_DATA@@0@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@QBEIXZ ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UDLTP_BLOCK_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::allocator<DLTP_BLOCK_DATA>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@I@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@IPAU1@@Z ; std::_Allocate<DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEPAUDLTP_BLOCK_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEPAUDLTP_BLOCK_DATA@@I@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@IPAU1@@Z ; std::_Allocate<DLTP_BLOCK_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEPAUDLTP_BLOCK_DATA@@I@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UDLTP_BLOCK_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UDLTP_BLOCK_DATA@@@std@@QBEIXZ PROC ; std::allocator<DLTP_BLOCK_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UDLTP_BLOCK_DATA@@@std@@QBEIXZ ENDP ; std::allocator<DLTP_BLOCK_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QAE@PAUDLTP_BLOCK_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUDLTP_BLOCK_DATA@@@std@@YAPBUDLTP_BLOCK_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUDLTP_BLOCK_DATA@@@std@@YAPBUDLTP_BLOCK_DATA@@ABU1@@Z PROC ; std::addressof<DLTP_BLOCK_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUDLTP_BLOCK_DATA@@@std@@YAPBUDLTP_BLOCK_DATA@@ABU1@@Z ENDP ; std::addressof<DLTP_BLOCK_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z ; std::allocator<DLTP_BLOCK_DATA>::construct<DLTP_BLOCK_DATA &>
PUBLIC	??$forward@AAUDLTP_BLOCK_DATA@@@std@@YAAAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::forward<DLTP_BLOCK_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@AAU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@AAU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUDLTP_BLOCK_DATA@@@std@@YAAAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::forward<DLTP_BLOCK_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z ; std::allocator<DLTP_BLOCK_DATA>::construct<DLTP_BLOCK_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@AAU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@ABU3@@Z ; std::allocator<DLTP_BLOCK_DATA>::construct
PUBLIC	??$forward@ABUDLTP_BLOCK_DATA@@@std@@YAABUDLTP_BLOCK_DATA@@ABU1@@Z ; std::forward<DLTP_BLOCK_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@ABU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@ABU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUDLTP_BLOCK_DATA@@@std@@YAABUDLTP_BLOCK_DATA@@ABU1@@Z ; std::forward<DLTP_BLOCK_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@ABU3@@Z ; std::allocator<DLTP_BLOCK_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@ABU3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>
PUBLIC	??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z ; std::_Ptr_cat<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T222055 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00@Z PROC ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z ; std::_Ptr_cat<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T222055[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T222055[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00@Z ENDP ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z ; std::_Uninitialized_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUDLTP_BLOCK_DATA@@@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEPAUDLTP_BLOCK_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUDLTP_BLOCK_DATA@@@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEPAUDLTP_BLOCK_DATA@@PAU2@00@Z PROC ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Umove<DLTP_BLOCK_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z ; std::_Uninitialized_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUDLTP_BLOCK_DATA@@@?$vector@UDLTP_BLOCK_DATA@@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@IAEPAUDLTP_BLOCK_DATA@@PAU2@00@Z ENDP ; std::vector<DLTP_BLOCK_DATA,std::allocator<DLTP_BLOCK_DATA> >::_Umove<DLTP_BLOCK_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z
_TEXT	SEGMENT
$T222060 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z ; std::_Ptr_cat<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T222060[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T222060[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T222063 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@IPAU1@@Z PROC ; std::_Allocate<DLTP_BLOCK_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T222063[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T222063[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@IPAU1@@Z ENDP ; std::_Allocate<DLTP_BLOCK_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z ; std::_Construct<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@ABU3@@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z ; std::_Construct<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@ABU3@@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUDLTP_BLOCK_DATA@@@std@@YAAAUDLTP_BLOCK_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUDLTP_BLOCK_DATA@@@std@@YAAAUDLTP_BLOCK_DATA@@AAU1@@Z PROC ; std::forward<DLTP_BLOCK_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUDLTP_BLOCK_DATA@@@std@@YAAAUDLTP_BLOCK_DATA@@AAU1@@Z ENDP ; std::forward<DLTP_BLOCK_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T222070 = -88						; size = 4
$T222071 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::construct<DLTP_BLOCK_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T222071[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T222071[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUDLTP_BLOCK_DATA@@@std@@YAAAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::forward<DLTP_BLOCK_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 45 ac	 mov	 eax, DWORD PTR $T222071[ebp]
  0005a	89 10		 mov	 DWORD PTR [eax], edx
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T222071[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T222070[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T222071[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUDLTP_BLOCK_DATA@@@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@AAU2@@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::construct<DLTP_BLOCK_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUDLTP_BLOCK_DATA@@@std@@YAABUDLTP_BLOCK_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUDLTP_BLOCK_DATA@@@std@@YAABUDLTP_BLOCK_DATA@@ABU1@@Z PROC ; std::forward<DLTP_BLOCK_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUDLTP_BLOCK_DATA@@@std@@YAABUDLTP_BLOCK_DATA@@ABU1@@Z ENDP ; std::forward<DLTP_BLOCK_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z PROC ; std::_Ptr_cat<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z ENDP ; std::_Ptr_cat<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAUDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::move<DLTP_BLOCK_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 04	 add	 eax, 4
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 04	 add	 ecx, 4
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 15		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::move<DLTP_BLOCK_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00036	89 0a		 mov	 DWORD PTR [edx], ecx
  00038	eb d1		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Move@PAUDLTP_BLOCK_DATA@@PAU1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
PUBLIC	??$_Val_type@PAUDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@@Z ; std::_Val_type<DLTP_BLOCK_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z
_TEXT	SEGMENT
$T222093 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z PROC ; std::_Uninitialized_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UDLTP_BLOCK_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDLTP_BLOCK_DATA@@0@Z ; std::_Ptr_cat<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T222093[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T222093[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@@Z ; std::_Val_type<DLTP_BLOCK_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@@Z ; std::_Dest_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 04	 add	 eax, 4
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@@Z ; std::_Dest_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UDLTP_BLOCK_DATA@@@std@@@std@@YAXPAUDLTP_BLOCK_DATA@@0AAV?$allocator@UDLTP_BLOCK_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DLTP_BLOCK_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T222098 = -88						; size = 4
$T222099 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z PROC ; std::_Construct<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T222099[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T222099[ebp], 0
  0004a	74 1b		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUDLTP_BLOCK_DATA@@@std@@YAABUDLTP_BLOCK_DATA@@ABU1@@Z ; std::forward<DLTP_BLOCK_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 45 ac	 mov	 eax, DWORD PTR $T222099[ebp]
  0005d	89 10		 mov	 DWORD PTR [eax], edx
  0005f	8b 4d ac	 mov	 ecx, DWORD PTR $T222099[ebp]
  00062	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00065	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00067	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  0006e	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00071	89 55 a8	 mov	 DWORD PTR $T222098[ebp], edx
  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T222099[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UDLTP_BLOCK_DATA@@ABU1@@std@@YAXPAUDLTP_BLOCK_DATA@@ABU1@@Z ENDP ; std::_Construct<DLTP_BLOCK_DATA,DLTP_BLOCK_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z PROC ; std::move<DLTP_BLOCK_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ENDP ; std::move<DLTP_BLOCK_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@@Z PROC ; std::_Val_type<DLTP_BLOCK_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUDLTP_BLOCK_DATA@@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@@Z ENDP ; std::_Val_type<DLTP_BLOCK_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@U3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 04	 add	 ecx, 4
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@U3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 04	 add	 eax, 4
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@@Z ; std::_Dest_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUDLTP_BLOCK_DATA@@PAU1@V?$allocator@UDLTP_BLOCK_DATA@@@std@@U1@@std@@YAPAUDLTP_BLOCK_DATA@@PAU1@00AAV?$allocator@UDLTP_BLOCK_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<DLTP_BLOCK_DATA *,DLTP_BLOCK_DATA *,std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
PUBLIC	?destroy@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@@Z ; std::allocator<DLTP_BLOCK_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@@Z PROC ; std::_Dest_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@@Z ; std::allocator<DLTP_BLOCK_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UDLTP_BLOCK_DATA@@@std@@YAXPAUDLTP_BLOCK_DATA@@@Z ; std::_Destroy<DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UDLTP_BLOCK_DATA@@@std@@YAXPAUDLTP_BLOCK_DATA@@@Z ; std::_Destroy<DLTP_BLOCK_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z ; std::allocator<DLTP_BLOCK_DATA>::construct
PUBLIC	??$forward@UDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::forward<DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@U3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@U3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::forward<DLTP_BLOCK_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z ; std::allocator<DLTP_BLOCK_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UDLTP_BLOCK_DATA@@@std@@UDLTP_BLOCK_DATA@@U3@@std@@YAXAAV?$allocator@UDLTP_BLOCK_DATA@@@0@PAUDLTP_BLOCK_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<DLTP_BLOCK_DATA>,DLTP_BLOCK_DATA,DLTP_BLOCK_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UDLTP_BLOCK_DATA@@@std@@YAXPAUDLTP_BLOCK_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UDLTP_BLOCK_DATA@@@std@@YAXPAUDLTP_BLOCK_DATA@@@Z PROC ; std::_Destroy<DLTP_BLOCK_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UDLTP_BLOCK_DATA@@@std@@YAXPAUDLTP_BLOCK_DATA@@@Z ENDP ; std::_Destroy<DLTP_BLOCK_DATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T222138 = -88						; size = 4
$T222139 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z PROC ; std::allocator<DLTP_BLOCK_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T222139[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T222139[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ; std::forward<DLTP_BLOCK_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 45 ac	 mov	 eax, DWORD PTR $T222139[ebp]
  0005a	89 10		 mov	 DWORD PTR [eax], edx
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T222139[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T222138[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T222139[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UDLTP_BLOCK_DATA@@@std@@QAEXPAUDLTP_BLOCK_DATA@@$$QAU3@@Z ENDP ; std::allocator<DLTP_BLOCK_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z PROC ; std::forward<DLTP_BLOCK_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UDLTP_BLOCK_DATA@@@std@@YA$$QAUDLTP_BLOCK_DATA@@AAU1@@Z ENDP ; std::forward<DLTP_BLOCK_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\teleportmanager.cpp
;	COMDAT ??__EgTeleportManager@@YAXXZ
text$yc	SEGMENT
??__EgTeleportManager@@YAXXZ PROC			; `dynamic initializer for 'gTeleportManager'', COMDAT

; 12   : cTeleportManager gTeleportManager;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gTeleportManager@@3VcTeleportManager@@A ; gTeleportManager
  0000e	e8 00 00 00 00	 call	 ??0cTeleportManager@@QAE@XZ ; cTeleportManager::cTeleportManager
  00013	68 00 00 00 00	 push	 OFFSET ??__FgTeleportManager@@YAXXZ ; `dynamic atexit destructor for 'gTeleportManager''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EgTeleportManager@@YAXXZ ENDP			; `dynamic initializer for 'gTeleportManager''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__FgTeleportManager@@YAXXZ
text$yd	SEGMENT
??__FgTeleportManager@@YAXXZ PROC			; `dynamic atexit destructor for 'gTeleportManager'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gTeleportManager@@3VcTeleportManager@@A ; gTeleportManager
  0000e	e8 00 00 00 00	 call	 ??1cTeleportManager@@QAE@XZ ; cTeleportManager::~cTeleportManager
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FgTeleportManager@@YAXXZ ENDP			; `dynamic atexit destructor for 'gTeleportManager''
text$yd	ENDS
PUBLIC	?gTeleportManager@@3VcTeleportManager@@A	; gTeleportManager
_BSS	SEGMENT
?gTeleportManager@@3VcTeleportManager@@A DB 02bfcH DUP (?) ; gTeleportManager
_BSS	ENDS
CRT$XCU	SEGMENT
_gTeleportManager$initializer$ DD FLAT:??__EgTeleportManager@@YAXXZ
CRT$XCU	ENDS
END
