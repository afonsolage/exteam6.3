; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\JewelOfHarmonySystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?_InitOption@CJewelOfHarmonySystem@@QAEXXZ	; CJewelOfHarmonySystem::_InitOption
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	??_7CJewelOfHarmonySystem@@6B@			; CJewelOfHarmonySystem::`vftable'
PUBLIC	??0CJewelOfHarmonySystem@@QAE@XZ		; CJewelOfHarmonySystem::CJewelOfHarmonySystem
PUBLIC	??_R4CJewelOfHarmonySystem@@6B@			; CJewelOfHarmonySystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCJewelOfHarmonySystem@@@8		; CJewelOfHarmonySystem `RTTI Type Descriptor'
PUBLIC	??_R3CJewelOfHarmonySystem@@8			; CJewelOfHarmonySystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CJewelOfHarmonySystem@@8			; CJewelOfHarmonySystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CJewelOfHarmonySystem@@8		; CJewelOfHarmonySystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1TRandomPoolMgr@@UAE@XZ:PROC			; TRandomPoolMgr::~TRandomPoolMgr
EXTRN	??0TRandomPoolMgr@@QAE@XZ:PROC			; TRandomPoolMgr::TRandomPoolMgr
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECJewelOfHarmonySystem@@UAEPAXI@Z:PROC	; CJewelOfHarmonySystem::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CJewelOfHarmonySystem@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\jewelofharmonysystem.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CJewelOfHarmonySystem@@8 DD FLAT:??_R0?AVCJewelOfHarmonySystem@@@8 ; CJewelOfHarmonySystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CJewelOfHarmonySystem@@8
rdata$r	ENDS
;	COMDAT ??_R2CJewelOfHarmonySystem@@8
rdata$r	SEGMENT
??_R2CJewelOfHarmonySystem@@8 DD FLAT:??_R1A@?0A@EA@CJewelOfHarmonySystem@@8 ; CJewelOfHarmonySystem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CJewelOfHarmonySystem@@8
rdata$r	SEGMENT
??_R3CJewelOfHarmonySystem@@8 DD 00H			; CJewelOfHarmonySystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CJewelOfHarmonySystem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCJewelOfHarmonySystem@@@8
_DATA	SEGMENT
??_R0?AVCJewelOfHarmonySystem@@@8 DD FLAT:??_7type_info@@6B@ ; CJewelOfHarmonySystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCJewelOfHarmonySystem@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CJewelOfHarmonySystem@@6B@
rdata$r	SEGMENT
??_R4CJewelOfHarmonySystem@@6B@ DD 00H			; CJewelOfHarmonySystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCJewelOfHarmonySystem@@@8
	DD	FLAT:??_R3CJewelOfHarmonySystem@@8
rdata$r	ENDS
;	COMDAT ??_7CJewelOfHarmonySystem@@6B@
CONST	SEGMENT
??_7CJewelOfHarmonySystem@@6B@ DD FLAT:??_R4CJewelOfHarmonySystem@@6B@ ; CJewelOfHarmonySystem::`vftable'
	DD	FLAT:??_ECJewelOfHarmonySystem@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CJewelOfHarmonySystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CJewelOfHarmonySystem@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CJewelOfHarmonySystem@@QAE@XZ$1
__ehfuncinfo$??0CJewelOfHarmonySystem@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CJewelOfHarmonySystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CJewelOfHarmonySystem@@QAE@XZ PROC			; CJewelOfHarmonySystem::CJewelOfHarmonySystem
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CJewelOfHarmonySystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CJewelOfHarmonySystem@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  0003d	e8 00 00 00 00	 call	 ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	81 c1 5c 53 00
	00		 add	 ecx, 21340		; 0000535cH
  00052	e8 00 00 00 00	 call	 ??0TRandomPoolMgr@@QAE@XZ ; TRandomPoolMgr::TRandomPoolMgr
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 25   : 	this->m_bEnable = TRUE;

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 26   : 	this->_InitOption();

  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_InitOption@CJewelOfHarmonySystem@@QAEXXZ ; CJewelOfHarmonySystem::_InitOption

; 27   : }

  0006d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CJewelOfHarmonySystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  00009	e9 00 00 00 00	 jmp	 ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CJewelOfHarmonySystem@@QAE@XZ$1:
  0000e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 5c 53 00
	00		 add	 ecx, 21340		; 0000535cH
  00017	e9 00 00 00 00	 jmp	 ??1TRandomPoolMgr@@UAE@XZ ; TRandomPoolMgr::~TRandomPoolMgr
__ehhandler$??0CJewelOfHarmonySystem@@QAE@XZ:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CJewelOfHarmonySystem@@QAE@XZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CJewelOfHarmonySystem@@QAE@XZ ENDP			; CJewelOfHarmonySystem::CJewelOfHarmonySystem
PUBLIC	??1CJewelOfHarmonySystem@@UAE@XZ		; CJewelOfHarmonySystem::~CJewelOfHarmonySystem
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCJewelOfHarmonySystem@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCJewelOfHarmonySystem@@UAEPAXI@Z PROC		; CJewelOfHarmonySystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CJewelOfHarmonySystem@@UAE@XZ ; CJewelOfHarmonySystem::~CJewelOfHarmonySystem
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCJewelOfHarmonySystem@@UAEPAXI@Z ENDP		; CJewelOfHarmonySystem::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1CJewelOfHarmonySystem@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CJewelOfHarmonySystem@@UAE@XZ$0
__ehfuncinfo$??1CJewelOfHarmonySystem@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CJewelOfHarmonySystem@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CJewelOfHarmonySystem@@UAE@XZ PROC			; CJewelOfHarmonySystem::~CJewelOfHarmonySystem
; _this$ = ecx

; 30   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	6a ff		 push	 -1
  00095	68 00 00 00 00	 push	 __ehhandler$??1CJewelOfHarmonySystem@@UAE@XZ
  0009a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  000a0	50		 push	 eax
  000a1	83 ec 44	 sub	 esp, 68			; 00000044H
  000a4	53		 push	 ebx
  000a5	56		 push	 esi
  000a6	57		 push	 edi
  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000ac	33 c5		 xor	 eax, ebp
  000ae	50		 push	 eax
  000af	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  000b2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  000b8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CJewelOfHarmonySystem@@6B@
  000c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 31   : 	return;
; 32   : }

  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	81 c1 5c 53 00
	00		 add	 ecx, 21340		; 0000535cH
  000d4	e8 00 00 00 00	 call	 ??1TRandomPoolMgr@@UAE@XZ ; TRandomPoolMgr::~TRandomPoolMgr
  000d9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  000e9	e8 00 00 00 00	 call	 ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f8	59		 pop	 ecx
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CJewelOfHarmonySystem@@UAE@XZ$0:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  00040	e9 00 00 00 00	 jmp	 ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__ehhandler$??1CJewelOfHarmonySystem@@UAE@XZ:
  00045	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00049	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004c	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CJewelOfHarmonySystem@@UAE@XZ
  0005b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CJewelOfHarmonySystem@@UAE@XZ ENDP			; CJewelOfHarmonySystem::~CJewelOfHarmonySystem
PUBLIC	??_C@_0BL@JDFNNPPK@SmeltingItemSuccessRateExt?$AA@ ; `string'
PUBLIC	??_C@_0BL@LGPEKII@SmeltingItemSuccessRateNor?$AA@ ; `string'
PUBLIC	??_C@_0BG@GJJLECKD@StrengthenSuccessRate?$AA@	; `string'
PUBLIC	??_C@_0BA@OLOLOLHH@SmeltingNeedZen?$AA@		; `string'
PUBLIC	??_C@_0CB@OIIHNAJJ@SmeltingStoneSuccesRateExcellent@ ; `string'
PUBLIC	??_C@_0BO@BGJDAANF@SmeltingStoneSuccesRateNormal?$AA@ ; `string'
PUBLIC	??_C@_0O@COBODJFF@PurityNeedZen?$AA@		; `string'
PUBLIC	??_C@_0BC@OHFAIMAL@PuritySuccessRate?$AA@	; `string'
PUBLIC	??_C@_0BJ@HOKIFFK@SmeltItemBySmeltingStone?$AA@	; `string'
PUBLIC	??_C@_0P@HFALALIA@StrengthenItem?$AA@		; `string'
PUBLIC	??_C@_0BG@LKPLCOLG@RestoreStrengthenItem?$AA@	; `string'
PUBLIC	??_C@_0BF@IHPDJEFP@MixSmeltingStoneItem?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BD@KNEMDBBP@PurityHarmonyJewel?$AA@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@	; `string'
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BL@JDFNNPPK@SmeltingItemSuccessRateExt?$AA@
CONST	SEGMENT
??_C@_0BL@JDFNNPPK@SmeltingItemSuccessRateExt?$AA@ DB 'SmeltingItemSucces'
	DB	'sRateExt', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LGPEKII@SmeltingItemSuccessRateNor?$AA@
CONST	SEGMENT
??_C@_0BL@LGPEKII@SmeltingItemSuccessRateNor?$AA@ DB 'SmeltingItemSuccess'
	DB	'RateNor', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJJLECKD@StrengthenSuccessRate?$AA@
CONST	SEGMENT
??_C@_0BG@GJJLECKD@StrengthenSuccessRate?$AA@ DB 'StrengthenSuccessRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLOLOLHH@SmeltingNeedZen?$AA@
CONST	SEGMENT
??_C@_0BA@OLOLOLHH@SmeltingNeedZen?$AA@ DB 'SmeltingNeedZen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OIIHNAJJ@SmeltingStoneSuccesRateExcellent@
CONST	SEGMENT
??_C@_0CB@OIIHNAJJ@SmeltingStoneSuccesRateExcellent@ DB 'SmeltingStoneSuc'
	DB	'cesRateExcellent', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BGJDAANF@SmeltingStoneSuccesRateNormal?$AA@
CONST	SEGMENT
??_C@_0BO@BGJDAANF@SmeltingStoneSuccesRateNormal?$AA@ DB 'SmeltingStoneSu'
	DB	'ccesRateNormal', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COBODJFF@PurityNeedZen?$AA@
CONST	SEGMENT
??_C@_0O@COBODJFF@PurityNeedZen?$AA@ DB 'PurityNeedZen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OHFAIMAL@PuritySuccessRate?$AA@
CONST	SEGMENT
??_C@_0BC@OHFAIMAL@PuritySuccessRate?$AA@ DB 'PuritySuccessRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HOKIFFK@SmeltItemBySmeltingStone?$AA@
CONST	SEGMENT
??_C@_0BJ@HOKIFFK@SmeltItemBySmeltingStone?$AA@ DB 'SmeltItemBySmeltingSt'
	DB	'one', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFALALIA@StrengthenItem?$AA@
CONST	SEGMENT
??_C@_0P@HFALALIA@StrengthenItem?$AA@ DB 'StrengthenItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LKPLCOLG@RestoreStrengthenItem?$AA@
CONST	SEGMENT
??_C@_0BG@LKPLCOLG@RestoreStrengthenItem?$AA@ DB 'RestoreStrengthenItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IHPDJEFP@MixSmeltingStoneItem?$AA@
CONST	SEGMENT
??_C@_0BF@IHPDJEFP@MixSmeltingStoneItem?$AA@ DB 'MixSmeltingStoneItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNEMDBBP@PurityHarmonyJewel?$AA@
CONST	SEGMENT
??_C@_0BD@KNEMDBBP@PurityHarmonyJewel?$AA@ DB 'PurityHarmonyJewel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@ DB 'commonserver.cfg', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_InitOption@CJewelOfHarmonySystem@@QAEXXZ PROC		; CJewelOfHarmonySystem::_InitOption
; _this$ = ecx

; 37   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 44	 sub	 esp, 68			; 00000044H
  00106	53		 push	 ebx
  00107	56		 push	 esi
  00108	57		 push	 edi
  00109	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 	this->JEWEL_OF_HARMONY_ITEMINDEX = ITEMGET(14,41);

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	c7 40 08 29 1c
	00 00		 mov	 DWORD PTR [eax+8], 7209	; 00001c29H

; 39   : 	this->JEWEL_OF_HARMONY_PURITY_ITEMINDEX = ITEMGET(14,42);

  00116	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00119	c7 40 0c 2a 1c
	00 00		 mov	 DWORD PTR [eax+12], 7210 ; 00001c2aH

; 40   : 	this->JEWEL_OF_HARMONY_SMELT_NOR_ITEMINDEX = ITEMGET(14,43);

  00120	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00123	c7 40 10 2b 1c
	00 00		 mov	 DWORD PTR [eax+16], 7211 ; 00001c2bH

; 41   : 	this->JEWEL_OF_HARMONY_SMELT_EXT_ITEMINDEX = ITEMGET(14,44);

  0012a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	c7 40 14 2c 1c
	00 00		 mov	 DWORD PTR [eax+20], 7212 ; 00001c2cH

; 42   : 
; 43   : 	memset(this->m_itemOption, 0, sizeof(this->m_itemOption));

  00134	68 00 53 00 00	 push	 21248			; 00005300H
  00139	6a 00		 push	 0
  0013b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	83 c0 18	 add	 eax, 24			; 00000018H
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _memset
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 
; 45   : 	this->m_bSystemPrutiyJewel = GetPrivateProfileInt("GameServerInfo", "PurityHarmonyJewel", 0, gDirPath.GetNewPath("commonserver.cfg"));

  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0014f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00154	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00159	50		 push	 eax
  0015a	6a 00		 push	 0
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KNEMDBBP@PurityHarmonyJewel?$AA@
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	89 81 18 53 00
	00		 mov	 DWORD PTR [ecx+21272], eax

; 46   : 	this->m_bSystemMixSmeltingStone = GetPrivateProfileInt("GameServerInfo", "MixSmeltingStoneItem", 0, gDirPath.GetNewPath("commonserver.cfg"));

  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0017a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0017f	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00184	50		 push	 eax
  00185	6a 00		 push	 0
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IHPDJEFP@MixSmeltingStoneItem?$AA@
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00197	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	89 81 1c 53 00
	00		 mov	 DWORD PTR [ecx+21276], eax

; 47   : 	this->m_bSystemRestoreStrengthen = GetPrivateProfileInt("GameServerInfo", "RestoreStrengthenItem", 0, gDirPath.GetNewPath("commonserver.cfg"));

  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  001a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001aa	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001af	50		 push	 eax
  001b0	6a 00		 push	 0
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LKPLCOLG@RestoreStrengthenItem?$AA@
  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	89 81 20 53 00
	00		 mov	 DWORD PTR [ecx+21280], eax

; 48   : 	this->m_bSystemStrengthenItem = GetPrivateProfileInt("GameServerInfo", "StrengthenItem", 0, gDirPath.GetNewPath("commonserver.cfg"));

  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  001d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001d5	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001da	50		 push	 eax
  001db	6a 00		 push	 0
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HFALALIA@StrengthenItem?$AA@
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f0	89 81 24 53 00
	00		 mov	 DWORD PTR [ecx+21284], eax

; 49   : 	this->m_bSystemSmeltingItem = GetPrivateProfileInt("GameServerInfo", "SmeltItemBySmeltingStone", 0, gDirPath.GetNewPath("commonserver.cfg"));

  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  001fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00200	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00205	50		 push	 eax
  00206	6a 00		 push	 0
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HOKIFFK@SmeltItemBySmeltingStone?$AA@
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00218	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	89 81 28 53 00
	00		 mov	 DWORD PTR [ecx+21288], eax

; 50   : 
; 51   : 	this->m_iRatePuritySuccess = GetPrivateProfileInt("GameServerInfo", "PuritySuccessRate", 0, gDirPath.GetNewPath("commonserver.cfg"));

  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00226	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0022b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00230	50		 push	 eax
  00231	6a 00		 push	 0
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OHFAIMAL@PuritySuccessRate?$AA@
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00243	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	89 81 2c 53 00
	00		 mov	 DWORD PTR [ecx+21292], eax

; 52   : 	this->m_iZenForPurity = GetPrivateProfileInt("GameServerInfo", "PurityNeedZen", 0, gDirPath.GetNewPath("commonserver.cfg"));

  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00251	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00256	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0025b	50		 push	 eax
  0025c	6a 00		 push	 0
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@COBODJFF@PurityNeedZen?$AA@
  00263	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0026e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00271	89 81 30 53 00
	00		 mov	 DWORD PTR [ecx+21296], eax

; 53   : 	this->m_iRateMixSmeltingStoneNor = GetPrivateProfileInt("GameServerInfo", "SmeltingStoneSuccesRateNormal", 0, gDirPath.GetNewPath("commonserver.cfg"));

  00277	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0027c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00281	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00286	50		 push	 eax
  00287	6a 00		 push	 0
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BGJDAANF@SmeltingStoneSuccesRateNormal?$AA@
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00293	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00299	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029c	89 81 34 53 00
	00		 mov	 DWORD PTR [ecx+21300], eax

; 54   : 	this->m_iRateMixSmeltingStoneExt = GetPrivateProfileInt("GameServerInfo", "SmeltingStoneSuccesRateExcellent", 0, gDirPath.GetNewPath("commonserver.cfg"));

  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  002a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  002ac	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  002b1	50		 push	 eax
  002b2	6a 00		 push	 0
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OIIHNAJJ@SmeltingStoneSuccesRateExcellent@
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	89 81 38 53 00
	00		 mov	 DWORD PTR [ecx+21304], eax

; 55   : 	this->m_iZenForMixSmeltingStone = GetPrivateProfileInt("GameServerInfo", "SmeltingNeedZen", 0, gDirPath.GetNewPath("commonserver.cfg"));

  002cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  002d7	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  002dc	50		 push	 eax
  002dd	6a 00		 push	 0
  002df	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OLOLOLHH@SmeltingNeedZen?$AA@
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  002e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f2	89 81 3c 53 00
	00		 mov	 DWORD PTR [ecx+21308], eax

; 56   : 	this->m_iRateStrengthenSuccess = GetPrivateProfileInt("GameServerInfo", "StrengthenSuccessRate", 0, gDirPath.GetNewPath("commonserver.cfg"));

  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  002fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00302	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00307	50		 push	 eax
  00308	6a 00		 push	 0
  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GJJLECKD@StrengthenSuccessRate?$AA@
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0031a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	89 81 40 53 00
	00		 mov	 DWORD PTR [ecx+21312], eax

; 57   : 	this->m_iRateSmeltingSuccessNor = GetPrivateProfileInt("GameServerInfo", "SmeltingItemSuccessRateNor", 0, gDirPath.GetNewPath("commonserver.cfg"));

  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00328	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0032d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00332	50		 push	 eax
  00333	6a 00		 push	 0
  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LGPEKII@SmeltingItemSuccessRateNor?$AA@
  0033a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0033f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00345	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00348	89 81 44 53 00
	00		 mov	 DWORD PTR [ecx+21316], eax

; 58   : 	this->m_iRateSmeltingSuccessExt = GetPrivateProfileInt("GameServerInfo", "SmeltingItemSuccessRateExt", 0, gDirPath.GetNewPath("commonserver.cfg"));

  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00353	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00358	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0035d	50		 push	 eax
  0035e	6a 00		 push	 0
  00360	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JDFNNPPK@SmeltingItemSuccessRateExt?$AA@
  00365	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0036a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00370	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00373	89 81 48 53 00
	00		 mov	 DWORD PTR [ecx+21320], eax

; 59   : }

  00379	5f		 pop	 edi
  0037a	5e		 pop	 esi
  0037b	5b		 pop	 ebx
  0037c	8b e5		 mov	 esp, ebp
  0037e	5d		 pop	 ebp
  0037f	c3		 ret	 0
?_InitOption@CJewelOfHarmonySystem@@QAEXXZ ENDP		; CJewelOfHarmonySystem::_InitOption
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?LoadScript@CJewelOfHarmonySystem@@QAEHPAD@Z	; CJewelOfHarmonySystem::LoadScript
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv201 = -104						; size = 8
tv191 = -100						; size = 4
tv180 = -100						; size = 4
tv170 = -100						; size = 4
tv199 = -96						; size = 4
tv189 = -96						; size = 4
tv178 = -96						; size = 4
tv168 = -96						; size = 4
tv196 = -90						; size = 2
tv186 = -90						; size = 2
tv175 = -90						; size = 2
tv165 = -90						; size = 2
_i$229750 = -24						; size = 4
_p$229744 = -20						; size = 4
_Index$229739 = -16					; size = 4
_Type$229733 = -12					; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_lpszFileName$ = 8					; size = 4
?LoadScript@CJewelOfHarmonySystem@@QAEHPAD@Z PROC	; CJewelOfHarmonySystem::LoadScript
; _this$ = ecx

; 65   : {

  00380	55		 push	 ebp
  00381	8b ec		 mov	 ebp, esp
  00383	83 ec 68	 sub	 esp, 104		; 00000068H
  00386	53		 push	 ebx
  00387	56		 push	 esi
  00388	57		 push	 edi
  00389	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	SMDToken Token;
; 67   : 	SMDFile = fopen(lpszFileName, "r");

  0038c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00391	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00394	50		 push	 eax
  00395	e8 00 00 00 00	 call	 _fopen
  0039a	83 c4 08	 add	 esp, 8
  0039d	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 68   : 
; 69   : 	if ( SMDFile == NULL )

  003a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  003a9	75 07		 jne	 SHORT $LN12@LoadScript

; 70   : 		return FALSE;

  003ab	33 c0		 xor	 eax, eax
  003ad	e9 b3 01 00 00	 jmp	 $LN13@LoadScript
$LN12@LoadScript:

; 71   : 
; 72   : 	this->_InitOption();

  003b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b5	e8 00 00 00 00	 call	 ?_InitOption@CJewelOfHarmonySystem@@QAEXXZ ; CJewelOfHarmonySystem::_InitOption
$LN11@LoadScript:

; 73   : 
; 74   : 
; 75   : 	while ( true )

  003ba	b8 01 00 00 00	 mov	 eax, 1
  003bf	85 c0		 test	 eax, eax
  003c1	0f 84 99 01 00
	00		 je	 $LN10@LoadScript

; 76   : 	{
; 77   : 		Token = (SMDToken)GetToken();

  003c7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003cc	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 78   : 
; 79   : 		if ( Token == END )

  003cf	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  003d3	75 05		 jne	 SHORT $LN9@LoadScript

; 80   : 			break;

  003d5	e9 86 01 00 00	 jmp	 $LN10@LoadScript
$LN9@LoadScript:

; 81   : 
; 82   : 		if ( Token == NUMBER )

  003da	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  003de	0f 85 77 01 00
	00		 jne	 $LN6@LoadScript

; 83   : 		{
; 84   : 			int Type = (int)TokenNumber;

  003e4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003ea	e8 00 00 00 00	 call	 __ftol2_sse
  003ef	89 45 f4	 mov	 DWORD PTR _Type$229733[ebp], eax
$LN7@LoadScript:

; 85   : 
; 86   : 			while ( true )

  003f2	b8 01 00 00 00	 mov	 eax, 1
  003f7	85 c0		 test	 eax, eax
  003f9	0f 84 5c 01 00
	00		 je	 $LN6@LoadScript

; 87   : 			{
; 88   : 				Token = (SMDToken)GetToken();

  003ff	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00404	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 89   : 				int Index = (int)TokenNumber;

  00407	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0040d	e8 00 00 00 00	 call	 __ftol2_sse
  00412	89 45 f0	 mov	 DWORD PTR _Index$229739[ebp], eax

; 90   : 
; 91   : 				if ( Token == NAME )

  00415	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  00419	75 1b		 jne	 SHORT $LN4@LoadScript

; 92   : 				{
; 93   : 					if ( !strcmp("end", TokenString))

  0041b	68 00 00 00 00	 push	 OFFSET _TokenString
  00420	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00425	e8 00 00 00 00	 call	 _strcmp
  0042a	83 c4 08	 add	 esp, 8
  0042d	85 c0		 test	 eax, eax
  0042f	75 05		 jne	 SHORT $LN4@LoadScript

; 94   : 					{
; 95   : 						break;

  00431	e9 25 01 00 00	 jmp	 $LN6@LoadScript
$LN4@LoadScript:

; 96   : 					}
; 97   : 				}
; 98   : 
; 99   : 				JEWELOFHARMONY_ITEM_OPTION * p = &this->m_itemOption[Type][Index];

  00436	8b 45 f4	 mov	 eax, DWORD PTR _Type$229733[ebp]
  00439	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  0043f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00442	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00446	8b 45 f0	 mov	 eax, DWORD PTR _Index$229739[ebp]
  00449	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  0044f	03 d0		 add	 edx, eax
  00451	89 55 ec	 mov	 DWORD PTR _p$229744[ebp], edx

; 100  : 				
; 101  : 				Token = (SMDToken)GetToken();

  00454	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00459	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 102  : 				strcpy(p->szOptionName, TokenString);

  0045c	68 00 00 00 00	 push	 OFFSET _TokenString
  00461	8b 45 ec	 mov	 eax, DWORD PTR _p$229744[ebp]
  00464	83 c0 4c	 add	 eax, 76			; 0000004cH
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 _strcpy
  0046d	83 c4 08	 add	 esp, 8

; 103  : 
; 104  : 				Token = (SMDToken)GetToken();

  00470	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00475	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 105  : 				p->iRandomWeight = (BYTE)TokenNumber;

  00478	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0047e	d9 7d a6	 fnstcw	 WORD PTR tv165[ebp]
  00481	0f b7 45 a6	 movzx	 eax, WORD PTR tv165[ebp]
  00485	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0048a	89 45 a0	 mov	 DWORD PTR tv168[ebp], eax
  0048d	d9 6d a0	 fldcw	 WORD PTR tv168[ebp]
  00490	db 5d 9c	 fistp	 DWORD PTR tv170[ebp]
  00493	d9 6d a6	 fldcw	 WORD PTR tv165[ebp]
  00496	8a 45 9c	 mov	 al, BYTE PTR tv170[ebp]
  00499	8b 4d ec	 mov	 ecx, DWORD PTR _p$229744[ebp]
  0049c	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 106  : 
; 107  : 				Token = (SMDToken)GetToken();

  0049f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004a4	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 108  : 				p->iRequireLevel = (BYTE)TokenNumber;

  004a7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004ad	d9 7d a6	 fnstcw	 WORD PTR tv175[ebp]
  004b0	0f b7 45 a6	 movzx	 eax, WORD PTR tv175[ebp]
  004b4	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004b9	89 45 a0	 mov	 DWORD PTR tv178[ebp], eax
  004bc	d9 6d a0	 fldcw	 WORD PTR tv178[ebp]
  004bf	db 5d 9c	 fistp	 DWORD PTR tv180[ebp]
  004c2	d9 6d a6	 fldcw	 WORD PTR tv175[ebp]
  004c5	8a 45 9c	 mov	 al, BYTE PTR tv180[ebp]
  004c8	8b 4d ec	 mov	 ecx, DWORD PTR _p$229744[ebp]
  004cb	88 41 05	 mov	 BYTE PTR [ecx+5], al

; 109  : 
; 110  : 				for ( int i=0;i<MAX_JOH_ITEM_OPTION;i++)

  004ce	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$229750[ebp], 0
  004d5	eb 09		 jmp	 SHORT $LN3@LoadScript
$LN2@LoadScript:
  004d7	8b 45 e8	 mov	 eax, DWORD PTR _i$229750[ebp]
  004da	83 c0 01	 add	 eax, 1
  004dd	89 45 e8	 mov	 DWORD PTR _i$229750[ebp], eax
$LN3@LoadScript:
  004e0	83 7d e8 0e	 cmp	 DWORD PTR _i$229750[ebp], 14 ; 0000000eH
  004e4	7d 67		 jge	 SHORT $LN1@LoadScript

; 111  : 				{
; 112  : 					Token = (SMDToken)GetToken();

  004e6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004eb	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 113  : 					p->iItemEffectValue[i] = (BYTE)TokenNumber;

  004ee	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004f4	d9 7d a6	 fnstcw	 WORD PTR tv186[ebp]
  004f7	0f b7 45 a6	 movzx	 eax, WORD PTR tv186[ebp]
  004fb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00500	89 45 a0	 mov	 DWORD PTR tv189[ebp], eax
  00503	d9 6d a0	 fldcw	 WORD PTR tv189[ebp]
  00506	db 5d 9c	 fistp	 DWORD PTR tv191[ebp]
  00509	d9 6d a6	 fldcw	 WORD PTR tv186[ebp]
  0050c	8a 45 9c	 mov	 al, BYTE PTR tv191[ebp]
  0050f	8b 4d ec	 mov	 ecx, DWORD PTR _p$229744[ebp]
  00512	03 4d e8	 add	 ecx, DWORD PTR _i$229750[ebp]
  00515	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 114  : 
; 115  : 					Token = (SMDToken)GetToken();

  00518	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0051d	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 116  : 					p->iZenForRestore[i] = (DWORD)TokenNumber;

  00520	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00526	d9 7d a6	 fnstcw	 WORD PTR tv196[ebp]
  00529	0f b7 45 a6	 movzx	 eax, WORD PTR tv196[ebp]
  0052d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00532	89 45 a0	 mov	 DWORD PTR tv199[ebp], eax
  00535	d9 6d a0	 fldcw	 WORD PTR tv199[ebp]
  00538	df 7d 98	 fistp	 QWORD PTR tv201[ebp]
  0053b	d9 6d a6	 fldcw	 WORD PTR tv196[ebp]
  0053e	8b 45 98	 mov	 eax, DWORD PTR tv201[ebp]
  00541	8b 4d e8	 mov	 ecx, DWORD PTR _i$229750[ebp]
  00544	8b 55 ec	 mov	 edx, DWORD PTR _p$229744[ebp]
  00547	89 44 8a 14	 mov	 DWORD PTR [edx+ecx*4+20], eax

; 117  : 				}

  0054b	eb 8a		 jmp	 SHORT $LN2@LoadScript
$LN1@LoadScript:

; 118  : 
; 119  : 				p->bValid = TRUE;

  0054d	8b 45 ec	 mov	 eax, DWORD PTR _p$229744[ebp]
  00550	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 120  : 			}

  00556	e9 97 fe ff ff	 jmp	 $LN7@LoadScript
$LN6@LoadScript:

; 121  : 		}
; 122  : 	}

  0055b	e9 5a fe ff ff	 jmp	 $LN11@LoadScript
$LN10@LoadScript:

; 123  : 	return TRUE;

  00560	b8 01 00 00 00	 mov	 eax, 1
$LN13@LoadScript:

; 124  : }

  00565	5f		 pop	 edi
  00566	5e		 pop	 esi
  00567	5b		 pop	 ebx
  00568	8b e5		 mov	 esp, ebp
  0056a	5d		 pop	 ebp
  0056b	c2 04 00	 ret	 4
?LoadScript@CJewelOfHarmonySystem@@QAEHPAD@Z ENDP	; CJewelOfHarmonySystem::LoadScript
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00570	55		 push	 ebp
  00571	8b ec		 mov	 ebp, esp
  00573	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00579	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0057e	33 c5		 xor	 eax, ebp
  00580	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00583	53		 push	 ebx
  00584	56		 push	 esi
  00585	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00586	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0058d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 _fgetc
  00598	83 c4 04	 add	 esp, 4
  0059b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0059e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005a2	83 f9 ff	 cmp	 ecx, -1
  005a5	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  005a7	b8 02 00 00 00	 mov	 eax, 2
  005ac	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  005b1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  005b3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005b7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  005ba	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  005bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005c1	50		 push	 eax
  005c2	e8 00 00 00 00	 call	 _fgetc
  005c7	83 c4 04	 add	 esp, 4
  005ca	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005cd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005d1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  005d4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  005d6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005da	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  005dd	74 1c		 je	 SHORT $LN23@GetToken
  005df	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005e3	83 f8 ff	 cmp	 eax, -1
  005e6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  005e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005ed	50		 push	 eax
  005ee	e8 00 00 00 00	 call	 _fgetc
  005f3	83 c4 04	 add	 esp, 4
  005f6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  005f9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  005fb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005ff	83 f8 ff	 cmp	 eax, -1
  00602	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00604	b8 02 00 00 00	 mov	 eax, 2
  00609	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0060e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00612	50		 push	 eax
  00613	e8 00 00 00 00	 call	 _isspace
  00618	83 c4 04	 add	 esp, 4
  0061b	85 c0		 test	 eax, eax
  0061d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00623	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00627	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0062d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00633	83 e9 22	 sub	 ecx, 34			; 00000022H
  00636	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0063c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00643	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00649	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0064f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00656	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0065d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00667	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0066c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00671	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00676	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00680	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00685	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0068a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0068f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00699	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0069e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  006a3	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  006a8	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  006b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006b7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  006bc	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  006c1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  006cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006d0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  006d5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  006da	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006df	50		 push	 eax
  006e0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006e4	51		 push	 ecx
  006e5	e8 00 00 00 00	 call	 _ungetc
  006ea	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  006ed	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  006f0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  006f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006f8	50		 push	 eax
  006f9	e8 00 00 00 00	 call	 _getc
  006fe	83 c4 04	 add	 esp, 4
  00701	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00704	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00708	83 f9 ff	 cmp	 ecx, -1
  0070b	74 36		 je	 SHORT $LN12@GetToken
  0070d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00711	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00714	74 1a		 je	 SHORT $LN11@GetToken
  00716	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0071a	50		 push	 eax
  0071b	e8 00 00 00 00	 call	 _isdigit
  00720	83 c4 04	 add	 esp, 4
  00723	85 c0		 test	 eax, eax
  00725	75 09		 jne	 SHORT $LN11@GetToken
  00727	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0072b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0072e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00730	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00733	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00736	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00738	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0073b	83 c0 01	 add	 eax, 1
  0073e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00741	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00743	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00746	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00749	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0074c	50		 push	 eax
  0074d	e8 00 00 00 00	 call	 _atof
  00752	83 c4 04	 add	 esp, 4
  00755	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0075b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00765	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0076a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0076f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00774	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0077b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00780	50		 push	 eax
  00781	e8 00 00 00 00	 call	 _getc
  00786	83 c4 04	 add	 esp, 4
  00789	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0078c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00790	83 f9 ff	 cmp	 ecx, -1
  00793	74 1c		 je	 SHORT $LN8@GetToken
  00795	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00799	83 f8 22	 cmp	 eax, 34			; 00000022H
  0079c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0079e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007a1	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  007a4	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  007a6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007a9	83 c0 01	 add	 eax, 1
  007ac	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  007af	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  007b1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  007b5	83 f8 22	 cmp	 eax, 34			; 00000022H
  007b8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  007ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007bf	50		 push	 eax
  007c0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  007c4	51		 push	 ecx
  007c5	e8 00 00 00 00	 call	 _ungetc
  007ca	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  007cd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  007d0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  007d3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  007dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007e2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  007e7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  007ec	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  007f0	50		 push	 eax
  007f1	e8 00 00 00 00	 call	 _isalpha
  007f6	83 c4 04	 add	 esp, 4
  007f9	85 c0		 test	 eax, eax
  007fb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00801	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00808	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0080b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0080e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00810	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00813	83 c0 01	 add	 eax, 1
  00816	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00819	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0081e	50		 push	 eax
  0081f	e8 00 00 00 00	 call	 _getc
  00824	83 c4 04	 add	 esp, 4
  00827	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0082a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0082e	83 f9 ff	 cmp	 ecx, -1
  00831	74 36		 je	 SHORT $LN3@GetToken
  00833	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00837	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0083a	74 1a		 je	 SHORT $LN2@GetToken
  0083c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00840	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00843	74 11		 je	 SHORT $LN2@GetToken
  00845	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00849	50		 push	 eax
  0084a	e8 00 00 00 00	 call	 _isalnum
  0084f	83 c4 04	 add	 esp, 4
  00852	85 c0		 test	 eax, eax
  00854	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00856	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00859	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0085c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0085e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00861	83 c0 01	 add	 eax, 1
  00864	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00867	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00869	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0086e	50		 push	 eax
  0086f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00873	51		 push	 ecx
  00874	e8 00 00 00 00	 call	 _ungetc
  00879	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0087c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0087f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00882	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0088c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00891	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00893	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00895	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0089f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  008a4	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  008a6	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  008a8	5f		 pop	 edi
  008a9	5e		 pop	 esi
  008aa	5b		 pop	 ebx
  008ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008ae	33 cd		 xor	 ecx, ebp
  008b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008b5	8b e5		 mov	 esp, ebp
  008b7	5d		 pop	 ebp
  008b8	c3		 ret	 0
  008b9	8d 49 00	 npad	 3
$LN35@GetToken:
  008bc	00 00 00 00	 DD	 $LN10@GetToken
  008c0	00 00 00 00	 DD	 $LN19@GetToken
  008c4	00 00 00 00	 DD	 $LN17@GetToken
  008c8	00 00 00 00	 DD	 $LN14@GetToken
  008cc	00 00 00 00	 DD	 $LN18@GetToken
  008d0	00 00 00 00	 DD	 $LN16@GetToken
  008d4	00 00 00 00	 DD	 $LN15@GetToken
  008d8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  008dc	00		 DB	 0
  008dd	01		 DB	 1
  008de	07		 DB	 7
  008df	07		 DB	 7
  008e0	07		 DB	 7
  008e1	07		 DB	 7
  008e2	07		 DB	 7
  008e3	07		 DB	 7
  008e4	07		 DB	 7
  008e5	07		 DB	 7
  008e6	02		 DB	 2
  008e7	03		 DB	 3
  008e8	03		 DB	 3
  008e9	07		 DB	 7
  008ea	03		 DB	 3
  008eb	03		 DB	 3
  008ec	03		 DB	 3
  008ed	03		 DB	 3
  008ee	03		 DB	 3
  008ef	03		 DB	 3
  008f0	03		 DB	 3
  008f1	03		 DB	 3
  008f2	03		 DB	 3
  008f3	03		 DB	 3
  008f4	07		 DB	 7
  008f5	04		 DB	 4
  008f6	07		 DB	 7
  008f7	07		 DB	 7
  008f8	07		 DB	 7
  008f9	07		 DB	 7
  008fa	07		 DB	 7
  008fb	07		 DB	 7
  008fc	07		 DB	 7
  008fd	07		 DB	 7
  008fe	07		 DB	 7
  008ff	07		 DB	 7
  00900	07		 DB	 7
  00901	07		 DB	 7
  00902	07		 DB	 7
  00903	07		 DB	 7
  00904	07		 DB	 7
  00905	07		 DB	 7
  00906	07		 DB	 7
  00907	07		 DB	 7
  00908	07		 DB	 7
  00909	07		 DB	 7
  0090a	07		 DB	 7
  0090b	07		 DB	 7
  0090c	07		 DB	 7
  0090d	07		 DB	 7
  0090e	07		 DB	 7
  0090f	07		 DB	 7
  00910	07		 DB	 7
  00911	07		 DB	 7
  00912	07		 DB	 7
  00913	07		 DB	 7
  00914	07		 DB	 7
  00915	07		 DB	 7
  00916	07		 DB	 7
  00917	07		 DB	 7
  00918	07		 DB	 7
  00919	07		 DB	 7
  0091a	07		 DB	 7
  0091b	07		 DB	 7
  0091c	07		 DB	 7
  0091d	07		 DB	 7
  0091e	07		 DB	 7
  0091f	07		 DB	 7
  00920	07		 DB	 7
  00921	07		 DB	 7
  00922	07		 DB	 7
  00923	07		 DB	 7
  00924	07		 DB	 7
  00925	07		 DB	 7
  00926	07		 DB	 7
  00927	07		 DB	 7
  00928	07		 DB	 7
  00929	07		 DB	 7
  0092a	07		 DB	 7
  0092b	07		 DB	 7
  0092c	07		 DB	 7
  0092d	07		 DB	 7
  0092e	07		 DB	 7
  0092f	07		 DB	 7
  00930	07		 DB	 7
  00931	07		 DB	 7
  00932	07		 DB	 7
  00933	07		 DB	 7
  00934	07		 DB	 7
  00935	05		 DB	 5
  00936	07		 DB	 7
  00937	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
PUBLIC	?LoadScriptOfSmelt@CJewelOfHarmonySystem@@QAEHPAD@Z ; CJewelOfHarmonySystem::LoadScriptOfSmelt
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\jewelofharmonysystem.cpp
_TEXT	SEGMENT
_idx$229784 = -24					; size = 4
_reqLev$229782 = -20					; size = 4
_index$229776 = -16					; size = 4
_Type$229770 = -12					; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_lpszFileName$ = 8					; size = 4
?LoadScriptOfSmelt@CJewelOfHarmonySystem@@QAEHPAD@Z PROC ; CJewelOfHarmonySystem::LoadScriptOfSmelt
; _this$ = ecx

; 128  : {

  00940	55		 push	 ebp
  00941	8b ec		 mov	 ebp, esp
  00943	83 ec 58	 sub	 esp, 88			; 00000058H
  00946	53		 push	 ebx
  00947	56		 push	 esi
  00948	57		 push	 edi
  00949	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  : 	SMDToken Token;
; 130  : 	SMDFile = fopen(lpszFileName, "r");

  0094c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00951	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00954	50		 push	 eax
  00955	e8 00 00 00 00	 call	 _fopen
  0095a	83 c4 08	 add	 esp, 8
  0095d	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 131  : 
; 132  : 	if ( SMDFile == NULL )

  00962	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00969	75 07		 jne	 SHORT $LN9@LoadScript@2

; 133  : 		return FALSE;

  0096b	33 c0		 xor	 eax, eax
  0096d	e9 d0 00 00 00	 jmp	 $LN10@LoadScript@2
$LN9@LoadScript@2:

; 134  : 
; 135  : 	this->m_mapEnableMixList.clear();

  00972	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00975	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  0097b	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
$LN8@LoadScript@2:

; 136  : 
; 137  : 	while ( true )

  00980	b8 01 00 00 00	 mov	 eax, 1
  00985	85 c0		 test	 eax, eax
  00987	0f 84 b0 00 00
	00		 je	 $LN7@LoadScript@2

; 138  : 	{
; 139  : 		Token = (SMDToken)GetToken();

  0098d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00992	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 140  : 
; 141  : 		if ( Token == END )

  00995	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00999	75 05		 jne	 SHORT $LN6@LoadScript@2

; 142  : 			break;

  0099b	e9 9d 00 00 00	 jmp	 $LN7@LoadScript@2
$LN6@LoadScript@2:

; 143  : 
; 144  : 		if ( Token == NUMBER )

  009a0	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  009a4	0f 85 8e 00 00
	00		 jne	 $LN3@LoadScript@2

; 145  : 		{
; 146  : 			int Type = (int)TokenNumber;

  009aa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009b0	e8 00 00 00 00	 call	 __ftol2_sse
  009b5	89 45 f4	 mov	 DWORD PTR _Type$229770[ebp], eax
$LN4@LoadScript@2:

; 147  : 
; 148  : 			while ( true )

  009b8	b8 01 00 00 00	 mov	 eax, 1
  009bd	85 c0		 test	 eax, eax
  009bf	74 77		 je	 SHORT $LN3@LoadScript@2

; 149  : 			{
; 150  : 				Token = (SMDToken)GetToken();

  009c1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009c6	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 151  : 				int index = (int)TokenNumber;

  009c9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009cf	e8 00 00 00 00	 call	 __ftol2_sse
  009d4	89 45 f0	 mov	 DWORD PTR _index$229776[ebp], eax

; 152  : 
; 153  : 				if ( Token == NAME )

  009d7	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  009db	75 18		 jne	 SHORT $LN1@LoadScript@2

; 154  : 				{
; 155  : 					if ( !strcmp("end", TokenString))

  009dd	68 00 00 00 00	 push	 OFFSET _TokenString
  009e2	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  009e7	e8 00 00 00 00	 call	 _strcmp
  009ec	83 c4 08	 add	 esp, 8
  009ef	85 c0		 test	 eax, eax
  009f1	75 02		 jne	 SHORT $LN1@LoadScript@2

; 156  : 					{
; 157  : 						break;

  009f3	eb 43		 jmp	 SHORT $LN3@LoadScript@2
$LN1@LoadScript@2:

; 158  : 					}
; 159  : 				}
; 160  : 
; 161  : 				Token = (SMDToken)GetToken();

  009f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009fa	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 162  : 
; 163  : 				Token = (SMDToken)GetToken();

  009fd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00a02	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 164  : 
; 165  : 				int reqLev = (int)TokenNumber;

  00a05	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00a0b	e8 00 00 00 00	 call	 __ftol2_sse
  00a10	89 45 ec	 mov	 DWORD PTR _reqLev$229782[ebp], eax

; 166  : 				int idx = ITEMGET(Type, index);

  00a13	8b 45 f4	 mov	 eax, DWORD PTR _Type$229770[ebp]
  00a16	c1 e0 09	 shl	 eax, 9
  00a19	03 45 f0	 add	 eax, DWORD PTR _index$229776[ebp]
  00a1c	89 45 e8	 mov	 DWORD PTR _idx$229784[ebp], eax

; 167  : 
; 168  : 				this->m_mapEnableMixList[idx]= reqLev;

  00a1f	8d 45 e8	 lea	 eax, DWORD PTR _idx$229784[ebp]
  00a22	50		 push	 eax
  00a23	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a26	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  00a2c	e8 00 00 00 00	 call	 ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
  00a31	8b 4d ec	 mov	 ecx, DWORD PTR _reqLev$229782[ebp]
  00a34	89 08		 mov	 DWORD PTR [eax], ecx

; 169  : 			}

  00a36	eb 80		 jmp	 SHORT $LN4@LoadScript@2
$LN3@LoadScript@2:

; 170  : 		}
; 171  : 	}

  00a38	e9 43 ff ff ff	 jmp	 $LN8@LoadScript@2
$LN7@LoadScript@2:

; 172  : 	return TRUE;

  00a3d	b8 01 00 00 00	 mov	 eax, 1
$LN10@LoadScript@2:

; 173  : }

  00a42	5f		 pop	 edi
  00a43	5e		 pop	 esi
  00a44	5b		 pop	 ebx
  00a45	8b e5		 mov	 esp, ebp
  00a47	5d		 pop	 ebp
  00a48	c2 04 00	 ret	 4
?LoadScriptOfSmelt@CJewelOfHarmonySystem@@QAEHPAD@Z ENDP ; CJewelOfHarmonySystem::LoadScriptOfSmelt
_TEXT	ENDS
PUBLIC	?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
; _this$ = ecx

; 178  : {

  00a50	55		 push	 ebp
  00a51	8b ec		 mov	 ebp, esp
  00a53	83 ec 48	 sub	 esp, 72			; 00000048H
  00a56	53		 push	 ebx
  00a57	56		 push	 esi
  00a58	57		 push	 edi
  00a59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : 	BOOL bRet = FALSE;

  00a5c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 180  : 
; 181  : 	if ( type == this->JEWEL_OF_HARMONY_ITEMINDEX )

  00a63	0f bf 45 08	 movsx	 eax, WORD PTR _type$[ebp]
  00a67	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a6a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00a6d	75 07		 jne	 SHORT $LN1@IsJewelOfH

; 182  : 		bRet = TRUE;

  00a6f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN1@IsJewelOfH:

; 183  : 
; 184  : 	return bRet;

  00a76	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 185  : }

  00a79	5f		 pop	 edi
  00a7a	5e		 pop	 esi
  00a7b	5b		 pop	 ebx
  00a7c	8b e5		 mov	 esp, ebp
  00a7e	5d		 pop	 ebp
  00a7f	c2 04 00	 ret	 4
?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z ENDP ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
_TEXT	ENDS
PUBLIC	?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
; _this$ = ecx

; 190  : {

  00a90	55		 push	 ebp
  00a91	8b ec		 mov	 ebp, esp
  00a93	83 ec 48	 sub	 esp, 72			; 00000048H
  00a96	53		 push	 ebx
  00a97	56		 push	 esi
  00a98	57		 push	 edi
  00a99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 	BOOL bRet = FALSE;

  00a9c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 192  : 
; 193  : 	if ( type == this->JEWEL_OF_HARMONY_PURITY_ITEMINDEX )

  00aa3	0f bf 45 08	 movsx	 eax, WORD PTR _type$[ebp]
  00aa7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aaa	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00aad	75 07		 jne	 SHORT $LN1@IsJewelOfH@2

; 194  : 		bRet = TRUE;

  00aaf	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN1@IsJewelOfH@2:

; 195  : 
; 196  : 	return bRet;

  00ab6	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 197  : }

  00ab9	5f		 pop	 edi
  00aba	5e		 pop	 esi
  00abb	5b		 pop	 ebx
  00abc	8b e5		 mov	 esp, ebp
  00abe	5d		 pop	 ebp
  00abf	c2 04 00	 ret	 4
?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ENDP ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
_TEXT	ENDS
PUBLIC	?_IsJewelOfHarmonySmeltingItemExt@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemExt
PUBLIC	?_IsJewelOfHarmonySmeltingItemNor@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemNor
PUBLIC	?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
; _this$ = ecx

; 203  : {

  00ad0	55		 push	 ebp
  00ad1	8b ec		 mov	 ebp, esp
  00ad3	83 ec 48	 sub	 esp, 72			; 00000048H
  00ad6	53		 push	 ebx
  00ad7	56		 push	 esi
  00ad8	57		 push	 edi
  00ad9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 	BOOL bRet = FALSE;

  00adc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 205  : 
; 206  : 	if ( this->_IsJewelOfHarmonySmeltingItemNor(type) == TRUE || this->_IsJewelOfHarmonySmeltingItemExt(type) == TRUE )

  00ae3	0f b7 45 08	 movzx	 eax, WORD PTR _type$[ebp]
  00ae7	50		 push	 eax
  00ae8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aeb	e8 00 00 00 00	 call	 ?_IsJewelOfHarmonySmeltingItemNor@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemNor
  00af0	83 f8 01	 cmp	 eax, 1
  00af3	74 12		 je	 SHORT $LN1@IsJewelOfH@3
  00af5	0f b7 45 08	 movzx	 eax, WORD PTR _type$[ebp]
  00af9	50		 push	 eax
  00afa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00afd	e8 00 00 00 00	 call	 ?_IsJewelOfHarmonySmeltingItemExt@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemExt
  00b02	83 f8 01	 cmp	 eax, 1
  00b05	75 07		 jne	 SHORT $LN2@IsJewelOfH@3
$LN1@IsJewelOfH@3:

; 207  : 		bRet = TRUE;

  00b07	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN2@IsJewelOfH@3:

; 208  : 
; 209  : 	return bRet;

  00b0e	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 210  : }

  00b11	5f		 pop	 edi
  00b12	5e		 pop	 esi
  00b13	5b		 pop	 ebx
  00b14	8b e5		 mov	 esp, ebp
  00b16	5d		 pop	 ebp
  00b17	c2 04 00	 ret	 4
?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ENDP ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
; Function compile flags: /Odtp /ZI
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
?_IsJewelOfHarmonySmeltingItemNor@CJewelOfHarmonySystem@@QAEHF@Z PROC ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemNor
; _this$ = ecx

; 214  : {

  00b20	55		 push	 ebp
  00b21	8b ec		 mov	 ebp, esp
  00b23	83 ec 48	 sub	 esp, 72			; 00000048H
  00b26	53		 push	 ebx
  00b27	56		 push	 esi
  00b28	57		 push	 edi
  00b29	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 215  : 	BOOL bRet = FALSE;

  00b2c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 216  : 
; 217  : 	if ( type == this->JEWEL_OF_HARMONY_SMELT_NOR_ITEMINDEX )

  00b33	0f bf 45 08	 movsx	 eax, WORD PTR _type$[ebp]
  00b37	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3a	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00b3d	75 07		 jne	 SHORT $LN1@IsJewelOfH@4

; 218  : 		bRet = TRUE;

  00b3f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN1@IsJewelOfH@4:

; 219  : 
; 220  : 	return bRet;

  00b46	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 221  : }

  00b49	5f		 pop	 edi
  00b4a	5e		 pop	 esi
  00b4b	5b		 pop	 ebx
  00b4c	8b e5		 mov	 esp, ebp
  00b4e	5d		 pop	 ebp
  00b4f	c2 04 00	 ret	 4
?_IsJewelOfHarmonySmeltingItemNor@CJewelOfHarmonySystem@@QAEHF@Z ENDP ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemNor
; Function compile flags: /Odtp /ZI
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
?_IsJewelOfHarmonySmeltingItemExt@CJewelOfHarmonySystem@@QAEHF@Z PROC ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemExt
; _this$ = ecx

; 226  : {

  00b60	55		 push	 ebp
  00b61	8b ec		 mov	 ebp, esp
  00b63	83 ec 48	 sub	 esp, 72			; 00000048H
  00b66	53		 push	 ebx
  00b67	56		 push	 esi
  00b68	57		 push	 edi
  00b69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 227  : 	BOOL bRet = FALSE;

  00b6c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 228  : 
; 229  : 	if ( type == this->JEWEL_OF_HARMONY_SMELT_EXT_ITEMINDEX )

  00b73	0f bf 45 08	 movsx	 eax, WORD PTR _type$[ebp]
  00b77	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7a	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00b7d	75 07		 jne	 SHORT $LN1@IsJewelOfH@5

; 230  : 		bRet = TRUE;

  00b7f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN1@IsJewelOfH@5:

; 231  : 
; 232  : 	return bRet;

  00b86	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 233  : }

  00b89	5f		 pop	 edi
  00b8a	5e		 pop	 esi
  00b8b	5b		 pop	 ebx
  00b8c	8b e5		 mov	 esp, ebp
  00b8e	5d		 pop	 ebp
  00b8f	c2 04 00	 ret	 4
?_IsJewelOfHarmonySmeltingItemExt@CJewelOfHarmonySystem@@QAEHF@Z ENDP ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemExt
_TEXT	ENDS
PUBLIC	??_C@_0CJ@MMJIHELL@?$FLJewelOfHarmony?$FN?$FLPuritySystem?$FN?5E@ ; `string'
PUBLIC	?SetEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEXH@Z ; CJewelOfHarmonySystem::SetEnableToUsePuritySystem
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0CJ@MMJIHELL@?$FLJewelOfHarmony?$FN?$FLPuritySystem?$FN?5E@
CONST	SEGMENT
??_C@_0CJ@MMJIHELL@?$FLJewelOfHarmony?$FN?$FLPuritySystem?$FN?5E@ DB '[Je'
	DB	'welOfHarmony][PuritySystem] Enable %d', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bEnable$ = 8						; size = 4
?SetEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEXH@Z PROC ; CJewelOfHarmonySystem::SetEnableToUsePuritySystem
; _this$ = ecx

; 239  : {

  00ba0	55		 push	 ebp
  00ba1	8b ec		 mov	 ebp, esp
  00ba3	83 ec 44	 sub	 esp, 68			; 00000044H
  00ba6	53		 push	 ebx
  00ba7	56		 push	 esi
  00ba8	57		 push	 edi
  00ba9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 	this->m_bEnable = bEnable;

  00bac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00baf	8b 4d 08	 mov	 ecx, DWORD PTR _bEnable$[ebp]
  00bb2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 241  : 
; 242  : 	LogAddTD("[JewelOfHarmony][PuritySystem] Enable %d", bEnable);

  00bb5	8b 45 08	 mov	 eax, DWORD PTR _bEnable$[ebp]
  00bb8	50		 push	 eax
  00bb9	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MMJIHELL@?$FLJewelOfHarmony?$FN?$FLPuritySystem?$FN?5E@
  00bbe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00bc4	83 c4 08	 add	 esp, 8

; 243  : }

  00bc7	5f		 pop	 edi
  00bc8	5e		 pop	 esi
  00bc9	5b		 pop	 ebx
  00bca	8b e5		 mov	 esp, ebp
  00bcc	5d		 pop	 ebp
  00bcd	c2 04 00	 ret	 4
?SetEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEXH@Z ENDP ; CJewelOfHarmonySystem::SetEnableToUsePuritySystem
_TEXT	ENDS
PUBLIC	?IsEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEHXZ ; CJewelOfHarmonySystem::IsEnableToUsePuritySystem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEHXZ PROC ; CJewelOfHarmonySystem::IsEnableToUsePuritySystem
; _this$ = ecx

; 246  : {

  00bd0	55		 push	 ebp
  00bd1	8b ec		 mov	 ebp, esp
  00bd3	83 ec 44	 sub	 esp, 68			; 00000044H
  00bd6	53		 push	 ebx
  00bd7	56		 push	 esi
  00bd8	57		 push	 edi
  00bd9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 	return this->m_bEnable;

  00bdc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bdf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 248  : }

  00be2	5f		 pop	 edi
  00be3	5e		 pop	 esi
  00be4	5b		 pop	 ebx
  00be5	8b e5		 mov	 esp, ebp
  00be7	5d		 pop	 ebp
  00be8	c3		 ret	 0
?IsEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEHXZ ENDP ; CJewelOfHarmonySystem::IsEnableToUsePuritySystem
_TEXT	ENDS
PUBLIC	??_C@_0DJ@NHFKNAAA@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@ ; `string'
PUBLIC	??_C@_0DM@HFGEEFMN@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@ ; `string'
PUBLIC	??_C@_0CF@BJBDMPPO@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5?9?5Mix?5S@ ; `string'
PUBLIC	??_C@_0BH@BHDMJJEI@JewelOfHarmony?$FN?$FLPurity?$AA@ ; `string'
PUBLIC	??_C@_0CK@BCOFIMEK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Pur@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::PurityJewelOfHarmony
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
EXTRN	?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CMixSystem::LogChaosItem
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0DJ@NHFKNAAA@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@
CONST	SEGMENT
??_C@_0DJ@NHFKNAAA@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@ DB '[J'
	DB	'ewelOfHarmony][Purity] Purity Fail [%s][%s] Rate %d/%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HFGEEFMN@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@
CONST	SEGMENT
??_C@_0DM@HFGEEFMN@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@ DB '[J'
	DB	'ewelOfHarmony][Purity] Purity Success [%s][%s] Rate %d/%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BJBDMPPO@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5?9?5Mix?5S@
CONST	SEGMENT
??_C@_0CF@BJBDMPPO@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5?9?5Mix?5S@ DB '['
	DB	'JewelOfHarmony][Purity] - Mix Start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BHDMJJEI@JewelOfHarmony?$FN?$FLPurity?$AA@
CONST	SEGMENT
??_C@_0BH@BHDMJJEI@JewelOfHarmony?$FN?$FLPurity?$AA@ DB 'JewelOfHarmony]['
	DB	'Purity', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BCOFIMEK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Pur@
CONST	SEGMENT
??_C@_0CK@BCOFIMEK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Pur@ DB '['
	DB	'JewelOfHarmony][%s][%s] Not Purtiy Time ', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iItemType$229856 = -52					; size = 4
_iRate$ = -48						; size = 4
_iChaosTaxMoney$ = -44					; size = 4
_n$229837 = -40						; size = 4
_pMsg$ = -36						; size = 16
_iChaosMixPrice$ = -20					; size = 4
_iInvalidItemCount$ = -16				; size = 4
_iJewelOfHarmonyItemCount$ = -12			; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CJewelOfHarmonySystem::PurityJewelOfHarmony
; _this$ = ecx

; 253  : {

  00bf0	55		 push	 ebp
  00bf1	8b ec		 mov	 ebp, esp
  00bf3	83 ec 74	 sub	 esp, 116		; 00000074H
  00bf6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00bfb	33 c5		 xor	 eax, ebp
  00bfd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00c00	53		 push	 ebx
  00c01	56		 push	 esi
  00c02	57		 push	 edi
  00c03	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 254  : 	if ( this->m_bSystemPrutiyJewel != TRUE )

  00c06	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c09	83 b8 18 53 00
	00 01		 cmp	 DWORD PTR [eax+21272], 1
  00c10	74 25		 je	 SHORT $LN15@PurityJewe

; 255  : 	{
; 256  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 50)), lpObj->m_Index, 1);

  00c12	6a 01		 push	 1
  00c14	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c19	51		 push	 ecx
  00c1a	68 32 0d 00 00	 push	 3378			; 00000d32H
  00c1f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00c24	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00c29	50		 push	 eax
  00c2a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00c2f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  : 		return;

  00c32	e9 ff 02 00 00	 jmp	 $LN16@PurityJewe
$LN15@PurityJewe:

; 258  : 	}
; 259  : 
; 260  : 	if ( this->IsEnableToUsePuritySystem() == FALSE )

  00c37	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c3a	e8 00 00 00 00	 call	 ?IsEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEHXZ ; CJewelOfHarmonySystem::IsEnableToUsePuritySystem
  00c3f	85 c0		 test	 eax, eax
  00c41	75 41		 jne	 SHORT $LN14@PurityJewe

; 261  : 	{
; 262  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 50)), lpObj->m_Index, 1);

  00c43	6a 01		 push	 1
  00c45	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c48	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c4a	51		 push	 ecx
  00c4b	68 32 0d 00 00	 push	 3378			; 00000d32H
  00c50	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00c55	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00c5a	50		 push	 eax
  00c5b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00c60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 		LogAddTD("[JewelOfHarmony][%s][%s] Not Purtiy Time ", lpObj->AccountID, lpObj->Name);

  00c63	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c66	83 c0 77	 add	 eax, 119		; 00000077H
  00c69	50		 push	 eax
  00c6a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c6d	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00c70	51		 push	 ecx
  00c71	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BCOFIMEK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Pur@
  00c76	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c7c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 264  : 		return;

  00c7f	e9 b2 02 00 00	 jmp	 $LN16@PurityJewe
$LN14@PurityJewe:

; 265  : 	}
; 266  : 
; 267  : 	lpObj->ChaosLock = TRUE;

  00c84	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c87	c7 80 88 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3720], 1

; 268  : 	// Chaos Lock was Enabled
; 269  : 		int iJewelOfHarmonyItemCount = 0;

  00c91	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iJewelOfHarmonyItemCount$[ebp], 0

; 270  : 		int iInvalidItemCount = 0;

  00c98	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iInvalidItemCount$[ebp], 0

; 271  : 		int iChaosMixPrice = 0;

  00c9f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iChaosMixPrice$[ebp], 0

; 272  : 		PMSG_CHAOSMIXRESULT pMsg;
; 273  : 		PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00ca6	6a 10		 push	 16			; 00000010H
  00ca8	68 86 00 00 00	 push	 134			; 00000086H
  00cad	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00cb0	50		 push	 eax
  00cb1	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00cb6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  : 
; 275  : 		pMsg.Result = CB_ERROR;

  00cb9	c6 45 df 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 276  : 
; 277  : 		for ( int n =0;n<CHAOS_BOX_SIZE;n++)

  00cbd	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$229837[ebp], 0
  00cc4	eb 09		 jmp	 SHORT $LN13@PurityJewe
$LN12@PurityJewe:
  00cc6	8b 45 d8	 mov	 eax, DWORD PTR _n$229837[ebp]
  00cc9	83 c0 01	 add	 eax, 1
  00ccc	89 45 d8	 mov	 DWORD PTR _n$229837[ebp], eax
$LN13@PurityJewe:
  00ccf	83 7d d8 20	 cmp	 DWORD PTR _n$229837[ebp], 32 ; 00000020H
  00cd3	7d 51		 jge	 SHORT $LN11@PurityJewe

; 278  : 		{
; 279  : 			if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00cd5	8b 4d d8	 mov	 ecx, DWORD PTR _n$229837[ebp]
  00cd8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00cde	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ce1	03 88 78 0e 00
	00		 add	 ecx, DWORD PTR [eax+3704]
  00ce7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00cec	83 f8 01	 cmp	 eax, 1
  00cef	75 33		 jne	 SHORT $LN10@PurityJewe

; 280  : 			{
; 281  : 				if ( lpObj->pChaosBox[n].m_Type == this->JEWEL_OF_HARMONY_ITEMINDEX )

  00cf1	8b 45 d8	 mov	 eax, DWORD PTR _n$229837[ebp]
  00cf4	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00cfa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cfd	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  00d03	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00d08	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d0b	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00d0e	75 0b		 jne	 SHORT $LN9@PurityJewe

; 282  : 				{
; 283  : 					iJewelOfHarmonyItemCount++;

  00d10	8b 45 f4	 mov	 eax, DWORD PTR _iJewelOfHarmonyItemCount$[ebp]
  00d13	83 c0 01	 add	 eax, 1
  00d16	89 45 f4	 mov	 DWORD PTR _iJewelOfHarmonyItemCount$[ebp], eax

; 284  : 				}
; 285  : 				else

  00d19	eb 09		 jmp	 SHORT $LN10@PurityJewe
$LN9@PurityJewe:

; 286  : 				{
; 287  : 					iInvalidItemCount++;

  00d1b	8b 45 f0	 mov	 eax, DWORD PTR _iInvalidItemCount$[ebp]
  00d1e	83 c0 01	 add	 eax, 1
  00d21	89 45 f0	 mov	 DWORD PTR _iInvalidItemCount$[ebp], eax
$LN10@PurityJewe:

; 288  : 				}
; 289  : 			}
; 290  : 		}

  00d24	eb a0		 jmp	 SHORT $LN12@PurityJewe
$LN11@PurityJewe:

; 291  : 
; 292  : 		if ( iInvalidItemCount > 0 || iJewelOfHarmonyItemCount !=1 )

  00d26	83 7d f0 00	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], 0
  00d2a	7f 06		 jg	 SHORT $LN6@PurityJewe
  00d2c	83 7d f4 01	 cmp	 DWORD PTR _iJewelOfHarmonyItemCount$[ebp], 1
  00d30	74 29		 je	 SHORT $LN7@PurityJewe
$LN6@PurityJewe:

; 293  : 		{
; 294  : 			DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00d32	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00d36	50		 push	 eax
  00d37	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00d3a	51		 push	 ecx
  00d3b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d3e	8b 02		 mov	 eax, DWORD PTR [edx]
  00d40	50		 push	 eax
  00d41	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00d46	83 c4 0c	 add	 esp, 12			; 0000000cH

; 295  : 			lpObj->ChaosLock = FALSE;

  00d49	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d4c	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 296  : 			return;

  00d56	e9 db 01 00 00	 jmp	 $LN16@PurityJewe
$LN7@PurityJewe:

; 297  : 		}
; 298  : 
; 299  : 		iChaosMixPrice = this->m_iZenForPurity;

  00d5b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00d5e	8b 88 30 53 00
	00		 mov	 ecx, DWORD PTR [eax+21296]
  00d64	89 4d ec	 mov	 DWORD PTR _iChaosMixPrice$[ebp], ecx

; 300  : 		int iChaosTaxMoney = iChaosMixPrice * g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / 100;

  00d67	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d6a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d6c	51		 push	 ecx
  00d6d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00d72	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00d77	0f af 45 ec	 imul	 eax, DWORD PTR _iChaosMixPrice$[ebp]
  00d7b	99		 cdq
  00d7c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00d81	f7 f9		 idiv	 ecx
  00d83	89 45 d4	 mov	 DWORD PTR _iChaosTaxMoney$[ebp], eax

; 301  : 
; 302  : 		if (iChaosTaxMoney < 0 )

  00d86	83 7d d4 00	 cmp	 DWORD PTR _iChaosTaxMoney$[ebp], 0
  00d8a	7d 07		 jge	 SHORT $LN5@PurityJewe

; 303  : 			iChaosTaxMoney = 0;

  00d8c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iChaosTaxMoney$[ebp], 0
$LN5@PurityJewe:

; 304  : 
; 305  : 		iChaosMixPrice += iChaosTaxMoney;

  00d93	8b 45 ec	 mov	 eax, DWORD PTR _iChaosMixPrice$[ebp]
  00d96	03 45 d4	 add	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  00d99	89 45 ec	 mov	 DWORD PTR _iChaosMixPrice$[ebp], eax

; 306  : 
; 307  : 		if ( iChaosMixPrice < 0 )

  00d9c	79 07		 jns	 SHORT $LN4@PurityJewe

; 308  : 			iChaosMixPrice = 0;

  00d9e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iChaosMixPrice$[ebp], 0
$LN4@PurityJewe:

; 309  : 
; 310  : 		if ( lpObj->Money < iChaosMixPrice )

  00da5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00da8	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00dae	3b 4d ec	 cmp	 ecx, DWORD PTR _iChaosMixPrice$[ebp]
  00db1	7d 2d		 jge	 SHORT $LN3@PurityJewe

; 311  : 		{
; 312  : 			pMsg.Result = CB_NOT_ENOUGH_ZEN;

  00db3	c6 45 df 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 313  : 			DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00db7	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00dbb	50		 push	 eax
  00dbc	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00dbf	51		 push	 ecx
  00dc0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00dc3	8b 02		 mov	 eax, DWORD PTR [edx]
  00dc5	50		 push	 eax
  00dc6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00dcb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 			lpObj->ChaosLock = FALSE;

  00dce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dd1	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 315  : 			return;

  00ddb	e9 56 01 00 00	 jmp	 $LN16@PurityJewe
$LN3@PurityJewe:

; 316  : 		}
; 317  : 
; 318  : 		lpObj->Money -= iChaosMixPrice;

  00de0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de3	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00de9	2b 4d ec	 sub	 ecx, DWORD PTR _iChaosMixPrice$[ebp]
  00dec	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00def	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 319  : 		g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  00df5	8b 45 d4	 mov	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  00df8	50		 push	 eax
  00df9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00dfe	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 320  : 		GCMoneySend(lpObj->m_Index, lpObj->Money);

  00e03	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e06	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00e0c	51		 push	 ecx
  00e0d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00e10	8b 02		 mov	 eax, DWORD PTR [edx]
  00e12	50		 push	 eax
  00e13	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00e18	83 c4 08	 add	 esp, 8

; 321  : 		g_MixSystem.LogChaosItem(lpObj, "JewelOfHarmony][Purity"); //LogChaosItem(lpObj, "JewelOfHarmony][Purity");

  00e1b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BHDMJJEI@JewelOfHarmony?$FN?$FLPurity?$AA@
  00e20	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e23	50		 push	 eax
  00e24	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00e29	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 322  : 
; 323  : 		LogAddTD("[JewelOfHarmony][Purity] - Mix Start");

  00e2e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BJBDMPPO@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5?9?5Mix?5S@
  00e33	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00e39	83 c4 04	 add	 esp, 4

; 324  : 
; 325  : 
; 326  : 		int iRate = rand() % 100;

  00e3c	e8 00 00 00 00	 call	 _rand
  00e41	99		 cdq
  00e42	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00e47	f7 f9		 idiv	 ecx
  00e49	89 55 d0	 mov	 DWORD PTR _iRate$[ebp], edx

; 327  : 
; 328  : 		if ( iRate < this->m_iRatePuritySuccess )

  00e4c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00e4f	8b 4d d0	 mov	 ecx, DWORD PTR _iRate$[ebp]
  00e52	3b 88 2c 53 00
	00		 cmp	 ecx, DWORD PTR [eax+21292]
  00e58	7d 72		 jge	 SHORT $LN2@PurityJewe

; 329  : 		{
; 330  : 			int iItemType = this->JEWEL_OF_HARMONY_PURITY_ITEMINDEX;

  00e5a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00e5d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00e60	89 4d cc	 mov	 DWORD PTR _iItemType$229856[ebp], ecx

; 331  : 			ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, iItemType, 0, 1, 0, 0, 0, lpObj->m_Index, 0, 0);

  00e63	6a 00		 push	 0
  00e65	6a 00		 push	 0
  00e67	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e6a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e6c	51		 push	 ecx
  00e6d	6a 00		 push	 0
  00e6f	6a 00		 push	 0
  00e71	6a 00		 push	 0
  00e73	6a 01		 push	 1
  00e75	6a 00		 push	 0
  00e77	8b 55 cc	 mov	 edx, DWORD PTR _iItemType$229856[ebp]
  00e7a	52		 push	 edx
  00e7b	6a 00		 push	 0
  00e7d	6a 00		 push	 0
  00e7f	68 ff 00 00 00	 push	 255			; 000000ffH
  00e84	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e87	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e89	51		 push	 ecx
  00e8a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00e8f	83 c4 34	 add	 esp, 52			; 00000034H

; 332  : 			gObjInventoryCommit(lpObj->m_Index);

  00e92	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e95	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e97	51		 push	 ecx
  00e98	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00e9d	83 c4 04	 add	 esp, 4

; 333  : 
; 334  : 			LogAddTD("[JewelOfHarmony][Purity] Purity Success [%s][%s] Rate %d/%d",
; 335  : 				lpObj->AccountID, lpObj->Name, iRate, this->m_iRatePuritySuccess);

  00ea0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00ea3	8b 88 2c 53 00
	00		 mov	 ecx, DWORD PTR [eax+21292]
  00ea9	51		 push	 ecx
  00eaa	8b 55 d0	 mov	 edx, DWORD PTR _iRate$[ebp]
  00ead	52		 push	 edx
  00eae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00eb1	83 c0 77	 add	 eax, 119		; 00000077H
  00eb4	50		 push	 eax
  00eb5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00eb8	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00ebb	51		 push	 ecx
  00ebc	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HFGEEFMN@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@
  00ec1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ec7	83 c4 14	 add	 esp, 20			; 00000014H

; 336  : 		}
; 337  : 		else

  00eca	eb 5d		 jmp	 SHORT $LN1@PurityJewe
$LN2@PurityJewe:

; 338  : 		{
; 339  : 			g_MixSystem.ChaosBoxInit(lpObj); //ChaosBoxInit(lpObj);

  00ecc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ecf	50		 push	 eax
  00ed0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00ed5	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 340  : 			GCUserChaosBoxSend(lpObj, 0);

  00eda	6a 00		 push	 0
  00edc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00edf	50		 push	 eax
  00ee0	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  00ee5	83 c4 08	 add	 esp, 8

; 341  : 			DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00ee8	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00eec	50		 push	 eax
  00eed	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00ef0	51		 push	 ecx
  00ef1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ef4	8b 02		 mov	 eax, DWORD PTR [edx]
  00ef6	50		 push	 eax
  00ef7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00efc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 342  : 
; 343  : 			LogAddTD("[JewelOfHarmony][Purity] Purity Fail [%s][%s] Rate %d/%d",
; 344  : 				lpObj->AccountID, lpObj->Name, iRate, this->m_iRatePuritySuccess);

  00eff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00f02	8b 88 2c 53 00
	00		 mov	 ecx, DWORD PTR [eax+21292]
  00f08	51		 push	 ecx
  00f09	8b 55 d0	 mov	 edx, DWORD PTR _iRate$[ebp]
  00f0c	52		 push	 edx
  00f0d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f10	83 c0 77	 add	 eax, 119		; 00000077H
  00f13	50		 push	 eax
  00f14	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f17	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00f1a	51		 push	 ecx
  00f1b	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@NHFKNAAA@?$FLJewelOfHarmony?$FN?$FLPurity?$FN?5Purity?5@
  00f20	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00f26	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@PurityJewe:

; 345  : 		}
; 346  : 	// Chaos Lock was Disabled
; 347  : 	lpObj->ChaosLock = FALSE;

  00f29	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f2c	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0
$LN16@PurityJewe:

; 348  : }

  00f36	5f		 pop	 edi
  00f37	5e		 pop	 esi
  00f38	5b		 pop	 ebx
  00f39	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f3c	33 cd		 xor	 ecx, ebp
  00f3e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f43	8b e5		 mov	 esp, ebp
  00f45	5d		 pop	 ebp
  00f46	c2 04 00	 ret	 4
?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CJewelOfHarmonySystem::PurityJewelOfHarmony
_TEXT	ENDS
PUBLIC	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
; _this$ = ecx

; 353  : {

  00f50	55		 push	 ebp
  00f51	8b ec		 mov	 ebp, esp
  00f53	83 ec 44	 sub	 esp, 68			; 00000044H
  00f56	53		 push	 ebx
  00f57	56		 push	 esi
  00f58	57		 push	 edi
  00f59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 354  : 	return ( pItem->m_JewelOfHarmonyOption & 0xF0 ) >> 4;

  00f5c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00f5f	0f b6 80 c4 00
	00 00		 movzx	 eax, BYTE PTR [eax+196]
  00f66	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00f6b	c1 f8 04	 sar	 eax, 4

; 355  : }

  00f6e	5f		 pop	 edi
  00f6f	5e		 pop	 esi
  00f70	5b		 pop	 ebx
  00f71	8b e5		 mov	 esp, ebp
  00f73	5d		 pop	 ebp
  00f74	c2 04 00	 ret	 4
?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::GetItemStrengthenOption
_TEXT	ENDS
PUBLIC	?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
PUBLIC	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
; _this$ = ecx

; 358  : {

  00f80	55		 push	 ebp
  00f81	8b ec		 mov	 ebp, esp
  00f83	83 ec 44	 sub	 esp, 68			; 00000044H
  00f86	53		 push	 ebx
  00f87	56		 push	 esi
  00f88	57		 push	 edi
  00f89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 359  : 	return this->_GetItemOptionLevel(pItem);

  00f8c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00f8f	50		 push	 eax
  00f90	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f93	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel

; 360  : }

  00f98	5f		 pop	 edi
  00f99	5e		 pop	 esi
  00f9a	5b		 pop	 ebx
  00f9b	8b e5		 mov	 esp, ebp
  00f9d	5d		 pop	 ebp
  00f9e	c2 04 00	 ret	 4
?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::GetItemOptionLevel
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::_GetItemOptionLevel
; _this$ = ecx

; 364  : {

  00fb0	55		 push	 ebp
  00fb1	8b ec		 mov	 ebp, esp
  00fb3	83 ec 44	 sub	 esp, 68			; 00000044H
  00fb6	53		 push	 ebx
  00fb7	56		 push	 esi
  00fb8	57		 push	 edi
  00fb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 	return ( pItem->m_JewelOfHarmonyOption & 0x0F ) ;

  00fbc	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00fbf	0f b6 80 c4 00
	00 00		 movzx	 eax, BYTE PTR [eax+196]
  00fc6	83 e0 0f	 and	 eax, 15			; 0000000fH

; 366  : }

  00fc9	5f		 pop	 edi
  00fca	5e		 pop	 esi
  00fcb	5b		 pop	 ebx
  00fcc	8b e5		 mov	 esp, ebp
  00fce	5d		 pop	 ebp
  00fcf	c2 04 00	 ret	 4
?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::_GetItemOptionLevel
_TEXT	ENDS
PUBLIC	?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
; _this$ = ecx

; 370  : {

  00fe0	55		 push	 ebp
  00fe1	8b ec		 mov	 ebp, esp
  00fe3	83 ec 44	 sub	 esp, 68			; 00000044H
  00fe6	53		 push	 ebx
  00fe7	56		 push	 esi
  00fe8	57		 push	 edi
  00fe9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 371  : 	if ( this->GetItemStrengthenOption(pItem) >0  )

  00fec	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00fef	50		 push	 eax
  00ff0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ff3	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  00ff8	0f b6 c8	 movzx	 ecx, al
  00ffb	85 c9		 test	 ecx, ecx
  00ffd	7e 07		 jle	 SHORT $LN1@IsStrength

; 372  : 		return TRUE;

  00fff	b8 01 00 00 00	 mov	 eax, 1
  01004	eb 02		 jmp	 SHORT $LN2@IsStrength
$LN1@IsStrength:

; 373  : 
; 374  : 	return FALSE;

  01006	33 c0		 xor	 eax, eax
$LN2@IsStrength:

; 375  : }

  01008	5f		 pop	 edi
  01009	5e		 pop	 esi
  0100a	5b		 pop	 ebx
  0100b	8b e5		 mov	 esp, ebp
  0100d	5d		 pop	 ebp
  0100e	c2 04 00	 ret	 4
?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
_TEXT	ENDS
PUBLIC	?IsActive@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsActive
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iOptionLevel$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?IsActive@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z PROC	; CJewelOfHarmonySystem::IsActive
; _this$ = ecx

; 379  : {

  01020	55		 push	 ebp
  01021	8b ec		 mov	 ebp, esp
  01023	83 ec 48	 sub	 esp, 72			; 00000048H
  01026	53		 push	 ebx
  01027	56		 push	 esi
  01028	57		 push	 edi
  01029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	if ( this->IsStrengthenByJewelOfHarmony(pItem) == FALSE )

  0102c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0102f	50		 push	 eax
  01030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01033	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  01038	85 c0		 test	 eax, eax
  0103a	75 04		 jne	 SHORT $LN2@IsActive

; 381  : 		return FALSE;

  0103c	33 c0		 xor	 eax, eax
  0103e	eb 27		 jmp	 SHORT $LN3@IsActive
$LN2@IsActive:

; 382  : 
; 383  : 	int iOptionLevel = this->_GetItemOptionLevel(pItem);

  01040	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01043	50		 push	 eax
  01044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01047	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  0104c	0f b6 c8	 movzx	 ecx, al
  0104f	89 4d f8	 mov	 DWORD PTR _iOptionLevel$[ebp], ecx

; 384  : 
; 385  : 	if ( pItem->m_Level < iOptionLevel )

  01052	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01055	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01059	3b 4d f8	 cmp	 ecx, DWORD PTR _iOptionLevel$[ebp]
  0105c	7d 04		 jge	 SHORT $LN1@IsActive

; 386  : 		return FALSE;

  0105e	33 c0		 xor	 eax, eax
  01060	eb 05		 jmp	 SHORT $LN3@IsActive
$LN1@IsActive:

; 387  : 
; 388  : 	return TRUE;

  01062	b8 01 00 00 00	 mov	 eax, 1
$LN3@IsActive:

; 389  : }

  01067	5f		 pop	 edi
  01068	5e		 pop	 esi
  01069	5b		 pop	 ebx
  0106a	8b e5		 mov	 esp, ebp
  0106c	5d		 pop	 ebp
  0106d	c2 04 00	 ret	 4
?IsActive@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ENDP	; CJewelOfHarmonySystem::IsActive
_TEXT	ENDS
PUBLIC	?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
PUBLIC	?_GetItemOptionRequireLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionRequireLevel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iItemOption$ = -9					; size = 1
_iItemType$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?_GetItemOptionRequireLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::_GetItemOptionRequireLevel
; _this$ = ecx

; 393  : {

  01070	55		 push	 ebp
  01071	8b ec		 mov	 ebp, esp
  01073	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01076	53		 push	 ebx
  01077	56		 push	 esi
  01078	57		 push	 edi
  01079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 394  : 	int iItemType = this->_GetItemType(pItem);

  0107c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0107f	50		 push	 eax
  01080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01083	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  01088	89 45 f8	 mov	 DWORD PTR _iItemType$[ebp], eax

; 395  : 	BYTE iItemOption = this->GetItemStrengthenOption(pItem);

  0108b	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0108e	50		 push	 eax
  0108f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01092	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01097	88 45 f7	 mov	 BYTE PTR _iItemOption$[ebp], al

; 396  : 
; 397  : 	if ( iItemType == 0 || iItemOption > MAX_JOH_ITEM_OPTION+1 || iItemOption == 0 )

  0109a	83 7d f8 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  0109e	74 11		 je	 SHORT $LN1@GetItemOpt
  010a0	0f b6 45 f7	 movzx	 eax, BYTE PTR _iItemOption$[ebp]
  010a4	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  010a7	7f 08		 jg	 SHORT $LN1@GetItemOpt
  010a9	0f b6 45 f7	 movzx	 eax, BYTE PTR _iItemOption$[ebp]
  010ad	85 c0		 test	 eax, eax
  010af	75 04		 jne	 SHORT $LN2@GetItemOpt
$LN1@GetItemOpt:

; 398  : 		return 0;

  010b1	32 c0		 xor	 al, al
  010b3	eb 1e		 jmp	 SHORT $LN3@GetItemOpt
$LN2@GetItemOpt:

; 399  : 
; 400  : 	return this->m_itemOption[iItemType][iItemOption].iRequireLevel;

  010b5	8b 45 f8	 mov	 eax, DWORD PTR _iItemType$[ebp]
  010b8	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  010be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010c1	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  010c5	0f b6 45 f7	 movzx	 eax, BYTE PTR _iItemOption$[ebp]
  010c9	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  010cf	8a 44 02 05	 mov	 al, BYTE PTR [edx+eax+5]
$LN3@GetItemOpt:

; 401  : }

  010d3	5f		 pop	 edi
  010d4	5e		 pop	 esi
  010d5	5b		 pop	 ebx
  010d6	8b e5		 mov	 esp, ebp
  010d8	5d		 pop	 ebp
  010d9	c2 04 00	 ret	 4
?_GetItemOptionRequireLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::_GetItemOptionRequireLevel
; Function compile flags: /Odtp /ZI
_iItemType$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::_GetItemType
; _this$ = ecx

; 407  : {

  010e0	55		 push	 ebp
  010e1	8b ec		 mov	 ebp, esp
  010e3	83 ec 48	 sub	 esp, 72			; 00000048H
  010e6	53		 push	 ebx
  010e7	56		 push	 esi
  010e8	57		 push	 edi
  010e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  : 	int iItemType = JEWELOFHARMONY_ITEM_TYPE_NULL;

  010ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iItemType$[ebp], 0

; 409  : 
; 410  : 
; 411  : 	if ( (pItem->m_Type >= ITEMGET(0,0) && pItem->m_Type <ITEMGET(4,0)) || (pItem->m_Type >= ITEMGET(4,0) && pItem->m_Type <ITEMGET(4,7)) || (pItem->m_Type >= ITEMGET(4,8) && pItem->m_Type <ITEMGET(4,15)) || (pItem->m_Type >= ITEMGET(4,16) && pItem->m_Type <ITEMGET(5,0)) )

  010f3	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  010f6	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010fa	85 c9		 test	 ecx, ecx
  010fc	7c 0f		 jl	 SHORT $LN5@GetItemTyp
  010fe	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01101	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01105	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  0110b	7c 5a		 jl	 SHORT $LN6@GetItemTyp
$LN5@GetItemTyp:
  0110d	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01110	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01114	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  0111a	7c 0f		 jl	 SHORT $LN4@GetItemTyp
  0111c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0111f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01123	81 f9 07 08 00
	00		 cmp	 ecx, 2055		; 00000807H
  01129	7c 3c		 jl	 SHORT $LN6@GetItemTyp
$LN4@GetItemTyp:
  0112b	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0112e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01132	81 f9 08 08 00
	00		 cmp	 ecx, 2056		; 00000808H
  01138	7c 0f		 jl	 SHORT $LN3@GetItemTyp
  0113a	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0113d	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01141	81 f9 0f 08 00
	00		 cmp	 ecx, 2063		; 0000080fH
  01147	7c 1e		 jl	 SHORT $LN6@GetItemTyp
$LN3@GetItemTyp:
  01149	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0114c	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01150	81 f9 10 08 00
	00		 cmp	 ecx, 2064		; 00000810H
  01156	7c 16		 jl	 SHORT $LN7@GetItemTyp
  01158	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0115b	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0115f	81 f9 00 0a 00
	00		 cmp	 ecx, 2560		; 00000a00H
  01165	7d 07		 jge	 SHORT $LN7@GetItemTyp
$LN6@GetItemTyp:

; 412  : 		iItemType =JEWELOFHARMONY_ITEM_TYPE_WEAPON;

  01167	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iItemType$[ebp], 1
$LN7@GetItemTyp:

; 413  : 
; 414  : 	if (pItem->m_Type >= ITEMGET(5,0) && pItem->m_Type <ITEMGET(6,0) )

  0116e	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01171	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01175	81 f9 00 0a 00
	00		 cmp	 ecx, 2560		; 00000a00H
  0117b	7c 16		 jl	 SHORT $LN2@GetItemTyp
  0117d	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01180	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01184	81 f9 00 0c 00
	00		 cmp	 ecx, 3072		; 00000c00H
  0118a	7d 07		 jge	 SHORT $LN2@GetItemTyp

; 415  : 		iItemType =JEWELOFHARMONY_ITEM_TYPE_STAFF;

  0118c	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _iItemType$[ebp], 2
$LN2@GetItemTyp:

; 416  : 
; 417  : 	if (pItem->m_Type >= ITEMGET(6,0) && pItem->m_Type <ITEMGET(12,0) )

  01193	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01196	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0119a	81 f9 00 0c 00
	00		 cmp	 ecx, 3072		; 00000c00H
  011a0	7c 16		 jl	 SHORT $LN1@GetItemTyp
  011a2	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  011a5	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  011a9	81 f9 00 18 00
	00		 cmp	 ecx, 6144		; 00001800H
  011af	7d 07		 jge	 SHORT $LN1@GetItemTyp

; 418  : 		iItemType =JEWELOFHARMONY_ITEM_TYPE_DEFENSE;

  011b1	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _iItemType$[ebp], 3
$LN1@GetItemTyp:

; 419  : 
; 420  : 	return iItemType;

  011b8	8b 45 f8	 mov	 eax, DWORD PTR _iItemType$[ebp]

; 421  : }

  011bb	5f		 pop	 edi
  011bc	5e		 pop	 esi
  011bd	5b		 pop	 ebx
  011be	8b e5		 mov	 esp, ebp
  011c0	5d		 pop	 ebp
  011c1	c2 04 00	 ret	 4
?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::_GetItemType
_TEXT	ENDS
PUBLIC	?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ; CJewelOfHarmonySystem::_GetSelectRandomOption
EXTRN	?GetRandomValue@TRandomPoolMgr@@QAEHW4eRandomPoolSelectType@@@Z:PROC ; TRandomPoolMgr::GetRandomValue
EXTRN	?AddValue@TRandomPoolMgr@@QAE_NHH@Z:PROC	; TRandomPoolMgr::AddValue
EXTRN	?InitPool@TRandomPoolMgr@@QAEXXZ:PROC		; TRandomPoolMgr::InitPool
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_idx$229912 = -12					; size = 4
_iItemOption$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
_iItemType$ = 12					; size = 4
?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z PROC ; CJewelOfHarmonySystem::_GetSelectRandomOption
; _this$ = ecx

; 427  : {

  011d0	55		 push	 ebp
  011d1	8b ec		 mov	 ebp, esp
  011d3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  011d6	53		 push	 ebx
  011d7	56		 push	 esi
  011d8	57		 push	 edi
  011d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 428  : 	if ( iItemType == 0 )

  011dc	83 7d 0c 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  011e0	75 08		 jne	 SHORT $LN12@GetSelectR

; 429  : 		return iItemType;

  011e2	8b 45 0c	 mov	 eax, DWORD PTR _iItemType$[ebp]
  011e5	e9 fe 00 00 00	 jmp	 $LN13@GetSelectR
$LN12@GetSelectR:

; 430  : 
; 431  : 	int iItemOption = AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM;

  011ea	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iItemOption$[ebp], 0

; 432  : 	this->m_kRandomPool.InitPool();

  011f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011f4	81 c1 5c 53 00
	00		 add	 ecx, 21340		; 0000535cH
  011fa	e8 00 00 00 00	 call	 ?InitPool@TRandomPoolMgr@@QAEXXZ ; TRandomPoolMgr::InitPool

; 433  : 
; 434  : 	for ( int idx =1;idx<MAX_JOH_ITEM_INDEX;idx++)

  011ff	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _idx$229912[ebp], 1
  01206	eb 09		 jmp	 SHORT $LN11@GetSelectR
$LN10@GetSelectR:
  01208	8b 45 f4	 mov	 eax, DWORD PTR _idx$229912[ebp]
  0120b	83 c0 01	 add	 eax, 1
  0120e	89 45 f4	 mov	 DWORD PTR _idx$229912[ebp], eax
$LN11@GetSelectR:
  01211	83 7d f4 10	 cmp	 DWORD PTR _idx$229912[ebp], 16 ; 00000010H
  01215	0f 8d b7 00 00
	00		 jge	 $LN9@GetSelectR

; 435  : 	{
; 436  : 		if ( this->m_itemOption[iItemType][idx].bValid == FALSE )

  0121b	8b 45 0c	 mov	 eax, DWORD PTR _iItemType$[ebp]
  0121e	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  01224	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01227	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0122b	8b 45 f4	 mov	 eax, DWORD PTR _idx$229912[ebp]
  0122e	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  01234	83 3c 02 00	 cmp	 DWORD PTR [edx+eax], 0
  01238	75 02		 jne	 SHORT $LN8@GetSelectR

; 437  : 			continue;

  0123a	eb cc		 jmp	 SHORT $LN10@GetSelectR
$LN8@GetSelectR:

; 438  : 
; 439  : 		if ( pItem->m_Level < this->m_itemOption[iItemType][idx].iRequireLevel )

  0123c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0123f	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01243	8b 55 0c	 mov	 edx, DWORD PTR _iItemType$[ebp]
  01246	69 d2 c0 14 00
	00		 imul	 edx, 5312		; 000014c0H
  0124c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0124f	8d 54 10 18	 lea	 edx, DWORD PTR [eax+edx+24]
  01253	8b 45 f4	 mov	 eax, DWORD PTR _idx$229912[ebp]
  01256	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  0125c	0f b6 54 02 05	 movzx	 edx, BYTE PTR [edx+eax+5]
  01261	3b ca		 cmp	 ecx, edx
  01263	7d 02		 jge	 SHORT $LN7@GetSelectR

; 440  : 			continue;

  01265	eb a1		 jmp	 SHORT $LN10@GetSelectR
$LN7@GetSelectR:

; 441  : 
; 442  : 		if ( iItemOption == AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_STR || iItemOption == AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_STR)

  01267	83 7d f8 02	 cmp	 DWORD PTR _iItemOption$[ebp], 2
  0126b	74 06		 je	 SHORT $LN5@GetSelectR
  0126d	83 7d f8 03	 cmp	 DWORD PTR _iItemOption$[ebp], 3
  01271	75 0d		 jne	 SHORT $LN6@GetSelectR
$LN5@GetSelectR:

; 443  : 		{
; 444  : 			if ( pItem->m_RequireStrength == 0 )

  01273	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01276	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  0127a	85 c9		 test	 ecx, ecx
  0127c	75 02		 jne	 SHORT $LN6@GetSelectR

; 445  : 				continue;

  0127e	eb 88		 jmp	 SHORT $LN10@GetSelectR
$LN6@GetSelectR:

; 446  : 		}
; 447  : 
; 448  : 		if ( iItemOption == AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_DEX || iItemOption == AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_DEX)

  01280	83 7d f8 03	 cmp	 DWORD PTR _iItemOption$[ebp], 3
  01284	74 06		 je	 SHORT $LN2@GetSelectR
  01286	83 7d f8 04	 cmp	 DWORD PTR _iItemOption$[ebp], 4
  0128a	75 10		 jne	 SHORT $LN3@GetSelectR
$LN2@GetSelectR:

; 449  : 		{
; 450  : 			if ( pItem->m_RequireDexterity == 0 )

  0128c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0128f	0f b7 48 4c	 movzx	 ecx, WORD PTR [eax+76]
  01293	85 c9		 test	 ecx, ecx
  01295	75 05		 jne	 SHORT $LN3@GetSelectR

; 451  : 				continue;

  01297	e9 6c ff ff ff	 jmp	 $LN10@GetSelectR
$LN3@GetSelectR:

; 452  : 		}
; 453  : 
; 454  : 		this->m_kRandomPool.AddValue(idx, this->m_itemOption[iItemType][idx].iRandomWeight);

  0129c	8b 45 0c	 mov	 eax, DWORD PTR _iItemType$[ebp]
  0129f	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  012a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012a8	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  012ac	8b 45 f4	 mov	 eax, DWORD PTR _idx$229912[ebp]
  012af	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  012b5	0f b6 4c 02 04	 movzx	 ecx, BYTE PTR [edx+eax+4]
  012ba	51		 push	 ecx
  012bb	8b 55 f4	 mov	 edx, DWORD PTR _idx$229912[ebp]
  012be	52		 push	 edx
  012bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012c2	81 c1 5c 53 00
	00		 add	 ecx, 21340		; 0000535cH
  012c8	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue

; 455  : 	}

  012cd	e9 36 ff ff ff	 jmp	 $LN10@GetSelectR
$LN9@GetSelectR:

; 456  : 
; 457  : 	iItemOption = this->m_kRandomPool.GetRandomValue(eRANDOMPOOL_BY_WEIGHT);

  012d2	6a 01		 push	 1
  012d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012d7	81 c1 5c 53 00
	00		 add	 ecx, 21340		; 0000535cH
  012dd	e8 00 00 00 00	 call	 ?GetRandomValue@TRandomPoolMgr@@QAEHW4eRandomPoolSelectType@@@Z ; TRandomPoolMgr::GetRandomValue
  012e2	89 45 f8	 mov	 DWORD PTR _iItemOption$[ebp], eax

; 458  : 	return iItemOption;

  012e5	8b 45 f8	 mov	 eax, DWORD PTR _iItemOption$[ebp]
$LN13@GetSelectR:

; 459  : }

  012e8	5f		 pop	 edi
  012e9	5e		 pop	 esi
  012ea	5b		 pop	 ebx
  012eb	8b e5		 mov	 esp, ebp
  012ed	5d		 pop	 ebp
  012ee	c2 08 00	 ret	 8
?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ENDP ; CJewelOfHarmonySystem::_GetSelectRandomOption
_TEXT	ENDS
PUBLIC	??_C@_0JB@GPNNHBFH@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ ; `string'
PUBLIC	?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z ; CJewelOfHarmonySystem::_MakeOption
PUBLIC	??_C@_0HF@LLJODOCN@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ ; `string'
PUBLIC	??_C@_0IC@LKDAOMEB@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ ; `string'
PUBLIC	??_C@_0HN@EAIBDDGK@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ ; `string'
PUBLIC	??_C@_0EO@NFBPNNC@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ ; `string'
PUBLIC	??_C@_0DP@KNLFIGGJ@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ ; `string'
PUBLIC	?StrengthenItemByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::StrengthenItemByJewelOfHarmony
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z:PROC	; CItem::Convert
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?ExAddJoHtoAnc@@3HA:DWORD			; ExAddJoHtoAnc
EXTRN	?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z:PROC ; LuckyItemManager::IsLuckyItemEquipment
EXTRN	?g_LuckyItemManager@@3ULuckyItemManager@@A:BYTE	; g_LuckyItemManager
;	COMDAT ??_C@_0JB@GPNNHBFH@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
CONST	SEGMENT
??_C@_0JB@GPNNHBFH@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ DB '[Jewel'
	DB	'OfHarmony][Strengthen Item] Strengthen Success [%s][%s] Name['
	DB	'%s] Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d) Option %'
	DB	'd OptionLevel %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@LLJODOCN@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
CONST	SEGMENT
??_C@_0HF@LLJODOCN@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ DB '[Jewel'
	DB	'OfHarmony][Strengthen Item] Strengthen Fail [%s][%s] Name[%s]'
	DB	' Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IC@LKDAOMEB@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
CONST	SEGMENT
??_C@_0IC@LKDAOMEB@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ DB '[Jewel'
	DB	'OfHarmony][Strengthen Item] Strengthen Fail - NOT OPTION [%s]'
	DB	'[%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) ItemType[%d'
	DB	']', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@EAIBDDGK@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
CONST	SEGMENT
??_C@_0HN@EAIBDDGK@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ DB '[Jewel'
	DB	'OfHarmony][Strengthen Item] Strengthen Fail [%s][%s] Name[%s]'
	DB	' Type[%d] Serial[%u] JewelSerial(%u) Invalid ItemType[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@NFBPNNC@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
CONST	SEGMENT
??_C@_0EO@NFBPNNC@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ DB '[JewelO'
	DB	'fHarmony][Strengthen Item] SetItem not enable to Strengthened'
	DB	' [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KNLFIGGJ@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
CONST	SEGMENT
??_C@_0DP@KNLFIGGJ@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@ DB '[Jewel'
	DB	'OfHarmony][Strengthen Item] Already Strengtened [%s][%s]', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv481 = -100						; size = 4
_levelitemdur$ = -32					; size = 4
_iSuccessRate$ = -28					; size = 4
_iItemOptionLevel$ = -24				; size = 4
_iItemOption$ = -20					; size = 4
_iItemType$ = -16					; size = 4
_pTarget$ = -12						; size = 4
_pSource$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?StrengthenItemByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z PROC ; CJewelOfHarmonySystem::StrengthenItemByJewelOfHarmony
; _this$ = ecx

; 464  : {

  01300	55		 push	 ebp
  01301	8b ec		 mov	 ebp, esp
  01303	83 ec 64	 sub	 esp, 100		; 00000064H
  01306	53		 push	 ebx
  01307	56		 push	 esi
  01308	57		 push	 edi
  01309	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 465  : 	if ( this->m_bSystemStrengthenItem == FALSE )

  0130c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0130f	83 b8 24 53 00
	00 00		 cmp	 DWORD PTR [eax+21284], 0
  01316	75 27		 jne	 SHORT $LN14@Strengthen

; 466  : 	{
; 467  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 52)), lpObj->m_Index, 1);

  01318	6a 01		 push	 1
  0131a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0131d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0131f	51		 push	 ecx
  01320	68 34 0d 00 00	 push	 3380			; 00000d34H
  01325	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0132a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0132f	50		 push	 eax
  01330	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01335	83 c4 0c	 add	 esp, 12			; 0000000cH

; 468  : 		return FALSE;

  01338	33 c0		 xor	 eax, eax
  0133a	e9 d3 04 00 00	 jmp	 $LN15@Strengthen
$LN14@Strengthen:

; 469  : 	}
; 470  : 
; 471  : 	if ( source < 0 || source > MAIN_INVENTORY_SIZE-1 )

  0133f	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  01343	7c 09		 jl	 SHORT $LN12@Strengthen
  01345	81 7d 0c cb 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 203 ; 000000cbH
  0134c	7e 07		 jle	 SHORT $LN13@Strengthen
$LN12@Strengthen:

; 472  : 		return FALSE;

  0134e	33 c0		 xor	 eax, eax
  01350	e9 bd 04 00 00	 jmp	 $LN15@Strengthen
$LN13@Strengthen:

; 473  : 
; 474  : 	if ( target < 0 || target > MAIN_INVENTORY_SIZE-1 )

  01355	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  01359	7c 09		 jl	 SHORT $LN10@Strengthen
  0135b	81 7d 10 cb 00
	00 00		 cmp	 DWORD PTR _target$[ebp], 203 ; 000000cbH
  01362	7e 07		 jle	 SHORT $LN11@Strengthen
$LN10@Strengthen:

; 475  : 		return FALSE;

  01364	33 c0		 xor	 eax, eax
  01366	e9 a7 04 00 00	 jmp	 $LN15@Strengthen
$LN11@Strengthen:

; 476  : 
; 477  : 	if ( lpObj->pInventory[source].IsItem() == FALSE )

  0136b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0136e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01374	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01377	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0137d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  01382	85 c0		 test	 eax, eax
  01384	75 07		 jne	 SHORT $LN9@Strengthen

; 478  : 		return FALSE;

  01386	33 c0		 xor	 eax, eax
  01388	e9 85 04 00 00	 jmp	 $LN15@Strengthen
$LN9@Strengthen:

; 479  : 
; 480  : 	if ( lpObj->pInventory[target].IsItem() == FALSE )

  0138d	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  01390	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01396	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01399	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0139f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  013a4	85 c0		 test	 eax, eax
  013a6	75 07		 jne	 SHORT $LN8@Strengthen

; 481  : 		return FALSE;

  013a8	33 c0		 xor	 eax, eax
  013aa	e9 63 04 00 00	 jmp	 $LN15@Strengthen
$LN8@Strengthen:

; 482  : 
; 483  : 	CItem * pSource = &lpObj->pInventory[source];

  013af	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  013b2	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  013b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013bb	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  013c1	89 45 f8	 mov	 DWORD PTR _pSource$[ebp], eax

; 484  : 	CItem * pTarget = &lpObj->pInventory[target];

  013c4	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  013c7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  013cd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013d0	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  013d6	89 45 f4	 mov	 DWORD PTR _pTarget$[ebp], eax

; 485  : 
; 486  : #ifdef LUCKYITEM
; 487  : 	if( g_LuckyItemManager.IsLuckyItemEquipment(pTarget->m_Type) )

  013d9	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  013dc	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  013e0	51		 push	 ecx
  013e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  013e6	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  013eb	85 c0		 test	 eax, eax
  013ed	74 07		 je	 SHORT $LN7@Strengthen

; 488  : 	{
; 489  : 		return false;

  013ef	33 c0		 xor	 eax, eax
  013f1	e9 1c 04 00 00	 jmp	 $LN15@Strengthen
$LN7@Strengthen:

; 490  : 	}
; 491  : #endif
; 492  : 
; 493  : 	if ( this->IsStrengthenByJewelOfHarmony(pTarget) == TRUE )

  013f6	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  013f9	50		 push	 eax
  013fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013fd	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  01402	83 f8 01	 cmp	 eax, 1
  01405	75 23		 jne	 SHORT $LN6@Strengthen

; 494  : 	{
; 495  : 		LogAddTD("[JewelOfHarmony][Strengthen Item] Already Strengtened [%s][%s]",
; 496  : 			lpObj->AccountID, lpObj->Name);

  01407	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0140a	83 c0 77	 add	 eax, 119		; 00000077H
  0140d	50		 push	 eax
  0140e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01411	83 c1 6c	 add	 ecx, 108		; 0000006cH
  01414	51		 push	 ecx
  01415	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@KNLFIGGJ@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
  0141a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01420	83 c4 0c	 add	 esp, 12			; 0000000cH

; 497  : 
; 498  : 		return FALSE;

  01423	33 c0		 xor	 eax, eax
  01425	e9 e8 03 00 00	 jmp	 $LN15@Strengthen
$LN6@Strengthen:

; 499  : 	}
; 500  : 	//int ExAddJoHtoAnc = GetPrivateProfileInt("Items","AddJoHtoAnc",1,"..\\Data\\ExData\\CommonServer.ini");
; 501  : 	if(!ExAddJoHtoAnc)

  0142a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ExAddJoHtoAnc@@3HA, 0 ; ExAddJoHtoAnc
  01431	75 4f		 jne	 SHORT $LN4@Strengthen

; 502  : 	{
; 503  : 		if (pTarget->IsSetItem() != FALSE)

  01433	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  01436	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  0143b	85 c0		 test	 eax, eax
  0143d	74 43		 je	 SHORT $LN4@Strengthen

; 504  : 		{
; 505  : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13, 44)), lpObj->m_Index, 1);

  0143f	6a 01		 push	 1
  01441	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01444	8b 08		 mov	 ecx, DWORD PTR [eax]
  01446	51		 push	 ecx
  01447	68 2c 0d 00 00	 push	 3372			; 00000d2cH
  0144c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01451	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01456	50		 push	 eax
  01457	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0145c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 			LogAddTD("[JewelOfHarmony][Strengthen Item] SetItem not enable to Strengthened [%s][%s]",
; 507  : 				lpObj->AccountID, lpObj->Name);

  0145f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01462	83 c0 77	 add	 eax, 119		; 00000077H
  01465	50		 push	 eax
  01466	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01469	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0146c	51		 push	 ecx
  0146d	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NFBPNNC@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
  01472	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01478	83 c4 0c	 add	 esp, 12			; 0000000cH

; 508  : 	
; 509  : 			return FALSE;

  0147b	33 c0		 xor	 eax, eax
  0147d	e9 90 03 00 00	 jmp	 $LN15@Strengthen
$LN4@Strengthen:

; 510  : 		}
; 511  : 	}
; 512  : 
; 513  : 	int iItemType = this->_GetItemType(pTarget);

  01482	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  01485	50		 push	 eax
  01486	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01489	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  0148e	89 45 f0	 mov	 DWORD PTR _iItemType$[ebp], eax

; 514  : 
; 515  : 	if ( iItemType == JEWELOFHARMONY_ITEM_TYPE_NULL )

  01491	83 7d f0 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  01495	75 44		 jne	 SHORT $LN3@Strengthen

; 516  : 	{
; 517  : 		LogAddTD("[JewelOfHarmony][Strengthen Item] Strengthen Fail [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) Invalid ItemType[%d]",
; 518  : 			lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 519  : 			pTarget->m_Number, pSource->m_Number, iItemType);

  01497	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  0149a	50		 push	 eax
  0149b	8b 4d f8	 mov	 ecx, DWORD PTR _pSource$[ebp]
  0149e	8b 11		 mov	 edx, DWORD PTR [ecx]
  014a0	52		 push	 edx
  014a1	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  014a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  014a6	51		 push	 ecx
  014a7	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  014aa	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  014ae	50		 push	 eax
  014af	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  014b2	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  014b7	50		 push	 eax
  014b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  014bb	83 c1 77	 add	 ecx, 119		; 00000077H
  014be	51		 push	 ecx
  014bf	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014c2	83 c2 6c	 add	 edx, 108		; 0000006cH
  014c5	52		 push	 edx
  014c6	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@EAIBDDGK@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
  014cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  014d1	83 c4 20	 add	 esp, 32			; 00000020H

; 520  : 		
; 521  : 		return FALSE;

  014d4	33 c0		 xor	 eax, eax
  014d6	e9 37 03 00 00	 jmp	 $LN15@Strengthen
$LN3@Strengthen:

; 522  : 	}
; 523  : 
; 524  : 	int iItemOption = this->_GetSelectRandomOption(pTarget, iItemType);

  014db	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  014de	50		 push	 eax
  014df	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  014e2	51		 push	 ecx
  014e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014e6	e8 00 00 00 00	 call	 ?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ; CJewelOfHarmonySystem::_GetSelectRandomOption
  014eb	89 45 ec	 mov	 DWORD PTR _iItemOption$[ebp], eax

; 525  : 
; 526  : 	if ( iItemOption == AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM )

  014ee	83 7d ec 00	 cmp	 DWORD PTR _iItemOption$[ebp], 0
  014f2	75 44		 jne	 SHORT $LN2@Strengthen

; 527  : 	{
; 528  : 		LogAddTD("[JewelOfHarmony][Strengthen Item] Strengthen Fail - NOT OPTION [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) ItemType[%d]",
; 529  : 			lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 530  : 			pTarget->m_Number, pSource->m_Number, iItemType);

  014f4	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  014f7	50		 push	 eax
  014f8	8b 4d f8	 mov	 ecx, DWORD PTR _pSource$[ebp]
  014fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  014fd	52		 push	 edx
  014fe	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  01501	8b 08		 mov	 ecx, DWORD PTR [eax]
  01503	51		 push	 ecx
  01504	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  01507	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  0150b	50		 push	 eax
  0150c	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0150f	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  01514	50		 push	 eax
  01515	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01518	83 c1 77	 add	 ecx, 119		; 00000077H
  0151b	51		 push	 ecx
  0151c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0151f	83 c2 6c	 add	 edx, 108		; 0000006cH
  01522	52		 push	 edx
  01523	68 00 00 00 00	 push	 OFFSET ??_C@_0IC@LKDAOMEB@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
  01528	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0152e	83 c4 20	 add	 esp, 32			; 00000020H

; 531  : 		
; 532  : 		return FALSE;

  01531	33 c0		 xor	 eax, eax
  01533	e9 da 02 00 00	 jmp	 $LN15@Strengthen
$LN2@Strengthen:

; 533  : 	}
; 534  : 
; 535  : 	int iItemOptionLevel = this->m_itemOption[iItemType][iItemOption].iRequireLevel;

  01538	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  0153b	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  01541	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01544	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  01548	8b 45 ec	 mov	 eax, DWORD PTR _iItemOption$[ebp]
  0154b	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  01551	0f b6 4c 02 05	 movzx	 ecx, BYTE PTR [edx+eax+5]
  01556	89 4d e8	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 536  : 	int iSuccessRate = rand() % 100;

  01559	e8 00 00 00 00	 call	 _rand
  0155e	99		 cdq
  0155f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01564	f7 f9		 idiv	 ecx
  01566	89 55 e4	 mov	 DWORD PTR _iSuccessRate$[ebp], edx

; 537  : 
; 538  : 	if ( iSuccessRate >= this->m_iRateStrengthenSuccess )

  01569	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0156c	8b 4d e4	 mov	 ecx, DWORD PTR _iSuccessRate$[ebp]
  0156f	3b 88 40 53 00
	00		 cmp	 ecx, DWORD PTR [eax+21312]
  01575	7c 71		 jl	 SHORT $LN1@Strengthen

; 539  : 	{
; 540  : 		LogAddTD("[JewelOfHarmony][Strengthen Item] Strengthen Fail [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d)",
; 541  : 			lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 542  : 			pTarget->m_Number, pSource->m_Number, iSuccessRate, this->m_iRateStrengthenSuccess);

  01577	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0157a	8b 88 40 53 00
	00		 mov	 ecx, DWORD PTR [eax+21312]
  01580	51		 push	 ecx
  01581	8b 55 e4	 mov	 edx, DWORD PTR _iSuccessRate$[ebp]
  01584	52		 push	 edx
  01585	8b 45 f8	 mov	 eax, DWORD PTR _pSource$[ebp]
  01588	8b 08		 mov	 ecx, DWORD PTR [eax]
  0158a	51		 push	 ecx
  0158b	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  0158e	8b 02		 mov	 eax, DWORD PTR [edx]
  01590	50		 push	 eax
  01591	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  01594	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  01598	52		 push	 edx
  01599	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0159c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  015a1	50		 push	 eax
  015a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015a5	83 c0 77	 add	 eax, 119		; 00000077H
  015a8	50		 push	 eax
  015a9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  015ac	83 c1 6c	 add	 ecx, 108		; 0000006cH
  015af	51		 push	 ecx
  015b0	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@LLJODOCN@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
  015b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  015bb	83 c4 24	 add	 esp, 36			; 00000024H

; 543  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 45)), lpObj->m_Index, 1);

  015be	6a 01		 push	 1
  015c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  015c5	51		 push	 ecx
  015c6	68 2d 0d 00 00	 push	 3373			; 00000d2dH
  015cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  015d0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  015d5	50		 push	 eax
  015d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  015db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 544  : 		return TRUE;

  015de	b8 01 00 00 00	 mov	 eax, 1
  015e3	e9 2a 02 00 00	 jmp	 $LN15@Strengthen
$LN1@Strengthen:

; 545  : 	}
; 546  : 
; 547  : 
; 548  : 	this->_MakeOption(pTarget, iItemOption, iItemOptionLevel);

  015e8	0f b6 45 e8	 movzx	 eax, BYTE PTR _iItemOptionLevel$[ebp]
  015ec	50		 push	 eax
  015ed	0f b6 4d ec	 movzx	 ecx, BYTE PTR _iItemOption$[ebp]
  015f1	51		 push	 ecx
  015f2	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  015f5	52		 push	 edx
  015f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015f9	e8 00 00 00 00	 call	 ?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z ; CJewelOfHarmonySystem::_MakeOption

; 549  : 
; 550  : 	LogAddTD("[JewelOfHarmony][Strengthen Item] Strengthen Success [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d) Option %d OptionLevel %d", //season 2.5 changed -> identical
; 551  : 		lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type, pTarget->m_Number,
; 552  : 		pSource->m_Number, iSuccessRate, this->m_iRateStrengthenSuccess,
; 553  : 		iItemOption, iItemOptionLevel);

  015fe	8b 45 e8	 mov	 eax, DWORD PTR _iItemOptionLevel$[ebp]
  01601	50		 push	 eax
  01602	8b 4d ec	 mov	 ecx, DWORD PTR _iItemOption$[ebp]
  01605	51		 push	 ecx
  01606	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01609	8b 82 40 53 00
	00		 mov	 eax, DWORD PTR [edx+21312]
  0160f	50		 push	 eax
  01610	8b 4d e4	 mov	 ecx, DWORD PTR _iSuccessRate$[ebp]
  01613	51		 push	 ecx
  01614	8b 55 f8	 mov	 edx, DWORD PTR _pSource$[ebp]
  01617	8b 02		 mov	 eax, DWORD PTR [edx]
  01619	50		 push	 eax
  0161a	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0161d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0161f	52		 push	 edx
  01620	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  01623	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01627	51		 push	 ecx
  01628	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0162b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  01630	50		 push	 eax
  01631	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01634	83 c2 77	 add	 edx, 119		; 00000077H
  01637	52		 push	 edx
  01638	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0163b	83 c0 6c	 add	 eax, 108		; 0000006cH
  0163e	50		 push	 eax
  0163f	68 00 00 00 00	 push	 OFFSET ??_C@_0JB@GPNNHBFH@?$FLJewelOfHarmony?$FN?$FLStrengthen?5Item@
  01644	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0164a	83 c4 2c	 add	 esp, 44			; 0000002cH

; 554  : 
; 555  : 	GCServerMsgStringSend(lMsg.Get(MSGGET(13, 46)), lpObj->m_Index, 1);

  0164d	6a 01		 push	 1
  0164f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01652	8b 08		 mov	 ecx, DWORD PTR [eax]
  01654	51		 push	 ecx
  01655	68 2e 0d 00 00	 push	 3374			; 00000d2eH
  0165a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0165f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01664	50		 push	 eax
  01665	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0166a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 556  : 
; 557  : 	gObjMakePreviewCharSet(lpObj->m_Index);

  0166d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01670	8b 08		 mov	 ecx, DWORD PTR [eax]
  01672	51		 push	 ecx
  01673	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  01678	83 c4 04	 add	 esp, 4

; 558  : 
; 559  : 	float levelitemdur = (float)ItemGetDurability(lpObj->pInventory[target].m_Type,
; 560  : 		lpObj->pInventory[target].m_Level, lpObj->pInventory[target].IsExtItem(),
; 561  : 		lpObj->pInventory[target].IsSetItem());

  0167b	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  0167e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01684	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01687	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0168d	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  01692	50		 push	 eax
  01693	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  01696	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0169c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0169f	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  016a5	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  016aa	50		 push	 eax
  016ab	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  016ae	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  016b4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  016b7	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  016bd	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  016c2	50		 push	 eax
  016c3	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  016c6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  016cc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016cf	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  016d5	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  016da	51		 push	 ecx
  016db	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  016e0	83 c4 10	 add	 esp, 16			; 00000010H
  016e3	89 45 9c	 mov	 DWORD PTR tv481[ebp], eax
  016e6	db 45 9c	 fild	 DWORD PTR tv481[ebp]
  016e9	d9 5d e0	 fstp	 DWORD PTR _levelitemdur$[ebp]

; 562  : 
; 563  : 	lpObj->pInventory[target].m_Durability = levelitemdur * lpObj->pInventory[target].m_Durability / lpObj->pInventory[target].m_BaseDurability;

  016ec	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  016ef	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  016f5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  016f8	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  016fe	d9 45 e0	 fld	 DWORD PTR _levelitemdur$[ebp]
  01701	d8 4c 02 24	 fmul	 DWORD PTR [edx+eax+36]
  01705	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  01708	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0170e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01711	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  01717	d8 74 02 2c	 fdiv	 DWORD PTR [edx+eax+44]
  0171b	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  0171e	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01724	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01727	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0172d	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]

; 564  : 
; 565  : 	lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type,
; 566  : 		lpObj->pInventory[target].m_Option1, lpObj->pInventory[target].m_Option2,
; 567  : 		lpObj->pInventory[target].m_Option3, lpObj->pInventory[target].m_NewOption,
; 568  : 		lpObj->pInventory[target].m_SetOption, lpObj->pInventory[target].m_ItemOptionEx, NULL, 0xFF, 0, 3);

  01731	6a 03		 push	 3
  01733	6a 00		 push	 0
  01735	68 ff 00 00 00	 push	 255			; 000000ffH
  0173a	6a 00		 push	 0
  0173c	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  0173f	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01745	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01748	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0174e	0f b6 84 02 ca
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+202]
  01756	50		 push	 eax
  01757	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  0175a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01760	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01763	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  01769	0f b6 8c 08 ae
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+174]
  01771	51		 push	 ecx
  01772	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  01775	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0177b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0177e	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01784	0f b6 94 11 97
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edx+151]
  0178c	52		 push	 edx
  0178d	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  01790	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01796	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01799	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0179f	0f b6 84 02 96
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+150]
  017a7	50		 push	 eax
  017a8	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  017ab	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  017b1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017b4	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  017ba	0f b6 8c 08 95
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+149]
  017c2	51		 push	 ecx
  017c3	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  017c6	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  017cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017cf	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  017d5	0f b6 94 11 94
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edx+148]
  017dd	52		 push	 edx
  017de	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  017e1	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  017e7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  017ea	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  017f0	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  017f5	50		 push	 eax
  017f6	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  017f9	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  017ff	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01802	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  01808	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 569  : 
; 570  : 
; 571  : 	return TRUE;

  0180d	b8 01 00 00 00	 mov	 eax, 1
$LN15@Strengthen:

; 572  : }

  01812	5f		 pop	 edi
  01813	5e		 pop	 esi
  01814	5b		 pop	 ebx
  01815	8b e5		 mov	 esp, ebp
  01817	5d		 pop	 ebp
  01818	c2 0c 00	 ret	 12			; 0000000cH
?StrengthenItemByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ENDP ; CJewelOfHarmonySystem::StrengthenItemByJewelOfHarmony
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
_btOptionType$ = 12					; size = 1
_btOptionLevel$ = 16					; size = 1
?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z PROC ; CJewelOfHarmonySystem::_MakeOption
; _this$ = ecx

; 577  : {

  01820	55		 push	 ebp
  01821	8b ec		 mov	 ebp, esp
  01823	83 ec 44	 sub	 esp, 68			; 00000044H
  01826	53		 push	 ebx
  01827	56		 push	 esi
  01828	57		 push	 edi
  01829	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 	pItem->m_JewelOfHarmonyOption = AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM;

  0182c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0182f	c6 80 c4 00 00
	00 00		 mov	 BYTE PTR [eax+196], 0

; 579  : 	pItem->m_JewelOfHarmonyOption |= btOptionType << 4;

  01836	0f b6 45 0c	 movzx	 eax, BYTE PTR _btOptionType$[ebp]
  0183a	c1 e0 04	 shl	 eax, 4
  0183d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  01840	0f b6 91 c4 00
	00 00		 movzx	 edx, BYTE PTR [ecx+196]
  01847	0b d0		 or	 edx, eax
  01849	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0184c	88 90 c4 00 00
	00		 mov	 BYTE PTR [eax+196], dl

; 580  : 	pItem->m_JewelOfHarmonyOption |= btOptionLevel & 0x0F;

  01852	0f b6 45 10	 movzx	 eax, BYTE PTR _btOptionLevel$[ebp]
  01856	83 e0 0f	 and	 eax, 15			; 0000000fH
  01859	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0185c	0f b6 91 c4 00
	00 00		 movzx	 edx, BYTE PTR [ecx+196]
  01863	0b d0		 or	 edx, eax
  01865	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01868	88 90 c4 00 00
	00		 mov	 BYTE PTR [eax+196], dl

; 581  : 
; 582  : 	return TRUE;

  0186e	b8 01 00 00 00	 mov	 eax, 1

; 583  : }

  01873	5f		 pop	 edi
  01874	5e		 pop	 esi
  01875	5b		 pop	 ebx
  01876	8b e5		 mov	 esp, ebp
  01878	5d		 pop	 ebp
  01879	c2 0c 00	 ret	 12			; 0000000cH
?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z ENDP ; CJewelOfHarmonySystem::_MakeOption
_TEXT	ENDS
PUBLIC	?StrengthenItemByMacro@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@EEE@Z ; CJewelOfHarmonySystem::StrengthenItemByMacro
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_invenrotyTargetPos$ = 12				; size = 1
_btOptionType$ = 16					; size = 1
_btOptionLevel$ = 20					; size = 1
?StrengthenItemByMacro@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@EEE@Z PROC ; CJewelOfHarmonySystem::StrengthenItemByMacro
; _this$ = ecx

; 589  : {

  01880	55		 push	 ebp
  01881	8b ec		 mov	 ebp, esp
  01883	81 ec 54 08 00
	00		 sub	 esp, 2132		; 00000854H
  01889	53		 push	 ebx
  0188a	56		 push	 esi
  0188b	57		 push	 edi
  0188c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 590  : 	return;
; 591  : 	
; 592  : 	int iType;
; 593  : 	CItem * pItem;
; 594  : 	char szMsg[256];
; 595  : 	{
; 596  : 		char szMsg[256];
; 597  : 	}
; 598  : 	{
; 599  : 		char szMsg[256];
; 600  : 	}
; 601  : 	{
; 602  : 		char szMsg[256];
; 603  : 	}
; 604  : 	{
; 605  : 		BYTE iValue;
; 606  : 	}
; 607  : 	{
; 608  : 		
; 609  : 		char szMsg[256];
; 610  : 	}
; 611  : 	{
; 612  : 		char szMsg[256];
; 613  : 	}
; 614  : 	{
; 615  : 		char szMsg[256];
; 616  : 	}
; 617  : 	{
; 618  : 		char szMsg	[256];
; 619  : 	}
; 620  : }

  0188f	5f		 pop	 edi
  01890	5e		 pop	 esi
  01891	5b		 pop	 ebx
  01892	8b e5		 mov	 esp, ebp
  01894	5d		 pop	 ebp
  01895	c2 10 00	 ret	 16			; 00000010H
?StrengthenItemByMacro@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@EEE@Z ENDP ; CJewelOfHarmonySystem::StrengthenItemByMacro
_TEXT	ENDS
PUBLIC	??_C@_0DM@KFGLPALB@?H?$LP?$LA?z?5?3?5?$CF20s?5?5?5?5type?3?$CFd?0?5option?3?$CF@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ShowStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::ShowStrengthenOption
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	_sprintf:PROC
;	COMDAT ??_C@_0DM@KFGLPALB@?H?$LP?$LA?z?5?3?5?$CF20s?5?5?5?5type?3?$CFd?0?5option?3?$CF@
CONST	SEGMENT
??_C@_0DM@KFGLPALB@?H?$LP?$LA?z?5?3?5?$CF20s?5?5?5?5type?3?$CFd?0?5option?3?$CF@ DB 0c8H
	DB	0bfH, 0b0H, 0faH, ' : %20s    type:%d, option:%d optionLevel %'
	DB	'd value %d ', 0aH, 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_buf$ = -276						; size = 256
_iItemOptionLevel$ = -20				; size = 4
_type$ = -16						; size = 4
_bResult$ = -9						; size = 1
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pItem$ = 8						; size = 4
?ShowStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::ShowStrengthenOption
; _this$ = ecx

; 624  : {

  018a0	55		 push	 ebp
  018a1	8b ec		 mov	 ebp, esp
  018a3	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  018a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  018ae	33 c5		 xor	 eax, ebp
  018b0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  018b3	53		 push	 ebx
  018b4	56		 push	 esi
  018b5	57		 push	 edi
  018b6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 625  : 	BYTE bResult = -1;

  018b9	c6 45 f7 ff	 mov	 BYTE PTR _bResult$[ebp], 255 ; 000000ffH

; 626  : 
; 627  : 	if ( this->IsStrengthenByJewelOfHarmony(pItem) == FALSE )

  018bd	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  018c0	50		 push	 eax
  018c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018c4	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  018c9	85 c0		 test	 eax, eax
  018cb	75 08		 jne	 SHORT $LN1@ShowStreng

; 628  : 		return bResult;

  018cd	8a 45 f7	 mov	 al, BYTE PTR _bResult$[ebp]
  018d0	e9 a3 00 00 00	 jmp	 $LN2@ShowStreng
$LN1@ShowStreng:

; 629  : 
; 630  : 	int type = this->_GetItemType(pItem);

  018d5	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  018d8	50		 push	 eax
  018d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018dc	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  018e1	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 631  : 	bResult = this->GetItemStrengthenOption(pItem);

  018e4	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  018e7	50		 push	 eax
  018e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018eb	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  018f0	88 45 f7	 mov	 BYTE PTR _bResult$[ebp], al

; 632  : 	int iItemOptionLevel = this->_GetItemOptionLevel(pItem);

  018f3	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  018f6	50		 push	 eax
  018f7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018fa	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  018ff	0f b6 c8	 movzx	 ecx, al
  01902	89 4d ec	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 633  : 	
; 634  : 	char buf[256];
; 635  : 	sprintf(buf, " : %20s    type:%d, option:%d optionLevel %d value %d \n", 
; 636  : 		this->m_itemOption[type][bResult].szOptionName, type,
; 637  : 		bResult, iItemOptionLevel, this->m_itemOption[type][bResult].iItemEffectValue[iItemOptionLevel]);

  01905	8b 45 f0	 mov	 eax, DWORD PTR _type$[ebp]
  01908	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  0190e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01911	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  01915	0f b6 45 f7	 movzx	 eax, BYTE PTR _bResult$[ebp]
  01919	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  0191f	03 55 ec	 add	 edx, DWORD PTR _iItemOptionLevel$[ebp]
  01922	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  01927	51		 push	 ecx
  01928	8b 55 ec	 mov	 edx, DWORD PTR _iItemOptionLevel$[ebp]
  0192b	52		 push	 edx
  0192c	0f b6 45 f7	 movzx	 eax, BYTE PTR _bResult$[ebp]
  01930	50		 push	 eax
  01931	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  01934	51		 push	 ecx
  01935	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  01938	69 d2 c0 14 00
	00		 imul	 edx, 5312		; 000014c0H
  0193e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01941	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  01945	0f b6 55 f7	 movzx	 edx, BYTE PTR _bResult$[ebp]
  01949	69 d2 4c 01 00
	00		 imul	 edx, 332		; 0000014cH
  0194f	8d 44 11 4c	 lea	 eax, DWORD PTR [ecx+edx+76]
  01953	50		 push	 eax
  01954	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@KFGLPALB@?H?$LP?$LA?z?5?3?5?$CF20s?5?5?5?5type?3?$CFd?0?5option?3?$CF@
  01959	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  0195f	51		 push	 ecx
  01960	e8 00 00 00 00	 call	 _sprintf
  01965	83 c4 1c	 add	 esp, 28			; 0000001cH

; 638  : 	
; 639  : 	OutputDebugString(buf);

  01968	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0196e	50		 push	 eax
  0196f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 640  : 	return bResult;

  01975	8a 45 f7	 mov	 al, BYTE PTR _bResult$[ebp]
$LN2@ShowStreng:

; 641  : }

  01978	5f		 pop	 edi
  01979	5e		 pop	 esi
  0197a	5b		 pop	 ebx
  0197b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0197e	33 cd		 xor	 ecx, ebp
  01980	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01985	8b e5		 mov	 esp, ebp
  01987	5d		 pop	 ebp
  01988	c2 04 00	 ret	 4
?ShowStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::ShowStrengthenOption
_TEXT	ENDS
PUBLIC	?MakeCharSetData@CJewelOfHarmonySystem@@QAEEPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::MakeCharSetData
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iOptionLevel$230005 = -16				; size = 4
_iOptionLevel$229998 = -12				; size = 4
_btResult$ = -5						; size = 1
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MakeCharSetData@CJewelOfHarmonySystem@@QAEEPAUOBJECTSTRUCT@@@Z PROC ; CJewelOfHarmonySystem::MakeCharSetData
; _this$ = ecx

; 646  : {

  01990	55		 push	 ebp
  01991	8b ec		 mov	 ebp, esp
  01993	83 ec 50	 sub	 esp, 80			; 00000050H
  01996	53		 push	 ebx
  01997	56		 push	 esi
  01998	57		 push	 edi
  01999	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 	BYTE btResult = 0;

  0199c	c6 45 fb 00	 mov	 BYTE PTR _btResult$[ebp], 0

; 648  : 
; 649  : 	if ( this->IsActive(&lpObj->pInventory[0]) == TRUE )

  019a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019a3	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  019a9	51		 push	 ecx
  019aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019ad	e8 00 00 00 00	 call	 ?IsActive@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsActive
  019b2	83 f8 01	 cmp	 eax, 1
  019b5	75 5c		 jne	 SHORT $LN12@MakeCharSe

; 650  : 	{
; 651  : 		int iOptionLevel = this->_GetItemOptionLevel(&lpObj->pInventory[0]);

  019b7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019ba	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  019c0	51		 push	 ecx
  019c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019c4	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  019c9	0f b6 d0	 movzx	 edx, al
  019cc	89 55 f4	 mov	 DWORD PTR _iOptionLevel$229998[ebp], edx

; 652  : 
; 653  : 		if ( iOptionLevel > 5 && iOptionLevel < 9 )

  019cf	83 7d f4 05	 cmp	 DWORD PTR _iOptionLevel$229998[ebp], 5
  019d3	7e 12		 jle	 SHORT $LN11@MakeCharSe
  019d5	83 7d f4 09	 cmp	 DWORD PTR _iOptionLevel$229998[ebp], 9
  019d9	7d 0c		 jge	 SHORT $LN11@MakeCharSe

; 654  : 			btResult |= 0x40;

  019db	0f b6 45 fb	 movzx	 eax, BYTE PTR _btResult$[ebp]
  019df	83 c8 40	 or	 eax, 64			; 00000040H
  019e2	88 45 fb	 mov	 BYTE PTR _btResult$[ebp], al
  019e5	eb 2c		 jmp	 SHORT $LN12@MakeCharSe
$LN11@MakeCharSe:

; 655  : 		else if ( iOptionLevel > 8 && iOptionLevel < 13 )

  019e7	83 7d f4 08	 cmp	 DWORD PTR _iOptionLevel$229998[ebp], 8
  019eb	7e 14		 jle	 SHORT $LN9@MakeCharSe
  019ed	83 7d f4 0d	 cmp	 DWORD PTR _iOptionLevel$229998[ebp], 13 ; 0000000dH
  019f1	7d 0e		 jge	 SHORT $LN9@MakeCharSe

; 656  : 			btResult |= 0x80;

  019f3	0f b6 45 fb	 movzx	 eax, BYTE PTR _btResult$[ebp]
  019f7	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  019fc	88 45 fb	 mov	 BYTE PTR _btResult$[ebp], al
  019ff	eb 12		 jmp	 SHORT $LN12@MakeCharSe
$LN9@MakeCharSe:

; 657  : 		else if ( iOptionLevel > 12 )

  01a01	83 7d f4 0c	 cmp	 DWORD PTR _iOptionLevel$229998[ebp], 12 ; 0000000cH
  01a05	7e 0c		 jle	 SHORT $LN12@MakeCharSe

; 658  : 			btResult |= 0xC0;

  01a07	0f b6 45 fb	 movzx	 eax, BYTE PTR _btResult$[ebp]
  01a0b	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  01a10	88 45 fb	 mov	 BYTE PTR _btResult$[ebp], al
$LN12@MakeCharSe:

; 659  : 	}
; 660  : 
; 661  : 	if ( this->IsActive(&lpObj->pInventory[1]) == TRUE )

  01a13	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a16	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01a1c	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  01a22	51		 push	 ecx
  01a23	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a26	e8 00 00 00 00	 call	 ?IsActive@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsActive
  01a2b	83 f8 01	 cmp	 eax, 1
  01a2e	75 5e		 jne	 SHORT $LN6@MakeCharSe

; 662  : 	{
; 663  : 		int iOptionLevel = this->_GetItemOptionLevel(&lpObj->pInventory[1]);

  01a30	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a33	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01a39	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  01a3f	51		 push	 ecx
  01a40	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a43	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  01a48	0f b6 d0	 movzx	 edx, al
  01a4b	89 55 f0	 mov	 DWORD PTR _iOptionLevel$230005[ebp], edx

; 664  : 
; 665  : 		if ( iOptionLevel > 5 && iOptionLevel < 9 )

  01a4e	83 7d f0 05	 cmp	 DWORD PTR _iOptionLevel$230005[ebp], 5
  01a52	7e 12		 jle	 SHORT $LN5@MakeCharSe
  01a54	83 7d f0 09	 cmp	 DWORD PTR _iOptionLevel$230005[ebp], 9
  01a58	7d 0c		 jge	 SHORT $LN5@MakeCharSe

; 666  : 			btResult |= 0x10;

  01a5a	0f b6 45 fb	 movzx	 eax, BYTE PTR _btResult$[ebp]
  01a5e	83 c8 10	 or	 eax, 16			; 00000010H
  01a61	88 45 fb	 mov	 BYTE PTR _btResult$[ebp], al
  01a64	eb 28		 jmp	 SHORT $LN6@MakeCharSe
$LN5@MakeCharSe:

; 667  : 		else if ( iOptionLevel > 8 && iOptionLevel < 13 )

  01a66	83 7d f0 08	 cmp	 DWORD PTR _iOptionLevel$230005[ebp], 8
  01a6a	7e 12		 jle	 SHORT $LN3@MakeCharSe
  01a6c	83 7d f0 0d	 cmp	 DWORD PTR _iOptionLevel$230005[ebp], 13 ; 0000000dH
  01a70	7d 0c		 jge	 SHORT $LN3@MakeCharSe

; 668  : 			btResult |= 0x20;

  01a72	0f b6 45 fb	 movzx	 eax, BYTE PTR _btResult$[ebp]
  01a76	83 c8 20	 or	 eax, 32			; 00000020H
  01a79	88 45 fb	 mov	 BYTE PTR _btResult$[ebp], al
  01a7c	eb 10		 jmp	 SHORT $LN6@MakeCharSe
$LN3@MakeCharSe:

; 669  : 		else if ( iOptionLevel > 12 )

  01a7e	83 7d f0 0c	 cmp	 DWORD PTR _iOptionLevel$230005[ebp], 12 ; 0000000cH
  01a82	7e 0a		 jle	 SHORT $LN6@MakeCharSe

; 670  : 			btResult |= 0x30;

  01a84	0f b6 45 fb	 movzx	 eax, BYTE PTR _btResult$[ebp]
  01a88	83 c8 30	 or	 eax, 48			; 00000030H
  01a8b	88 45 fb	 mov	 BYTE PTR _btResult$[ebp], al
$LN6@MakeCharSe:

; 671  : 	}
; 672  : 
; 673  : 	return btResult;

  01a8e	8a 45 fb	 mov	 al, BYTE PTR _btResult$[ebp]

; 674  : }

  01a91	5f		 pop	 edi
  01a92	5e		 pop	 esi
  01a93	5b		 pop	 ebx
  01a94	8b e5		 mov	 esp, ebp
  01a96	5d		 pop	 ebp
  01a97	c2 04 00	 ret	 4
?MakeCharSetData@CJewelOfHarmonySystem@@QAEEPAUOBJECTSTRUCT@@@Z ENDP ; CJewelOfHarmonySystem::MakeCharSetData
_TEXT	ENDS
PUBLIC	?_CalcItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@PAUJEWELOFHARMONY_ITEM_EFFECT@@@Z ; CJewelOfHarmonySystem::_CalcItemEffectValue
PUBLIC	?InitEffectValue@CJewelOfHarmonySystem@@QAEXPAUJEWELOFHARMONY_ITEM_EFFECT@@@Z ; CJewelOfHarmonySystem::InitEffectValue
PUBLIC	?SetApplyStrengthenItem@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::SetApplyStrengthenItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_bResult$230022 = -16					; size = 4
_iItemIndex$ = -12					; size = 4
_pItemEffect$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?SetApplyStrengthenItem@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CJewelOfHarmonySystem::SetApplyStrengthenItem
; _this$ = ecx

; 678  : {

  01aa0	55		 push	 ebp
  01aa1	8b ec		 mov	 ebp, esp
  01aa3	83 ec 50	 sub	 esp, 80			; 00000050H
  01aa6	53		 push	 ebx
  01aa7	56		 push	 esi
  01aa8	57		 push	 edi
  01aa9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 679  : 	JEWELOFHARMONY_ITEM_EFFECT * pItemEffect = &lpObj->m_JewelOfHarmonyEffect;

  01aac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01aaf	05 d8 1f 00 00	 add	 eax, 8152		; 00001fd8H
  01ab4	89 45 f8	 mov	 DWORD PTR _pItemEffect$[ebp], eax

; 680  : 
; 681  : 	this->InitEffectValue(pItemEffect);

  01ab7	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01aba	50		 push	 eax
  01abb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01abe	e8 00 00 00 00	 call	 ?InitEffectValue@CJewelOfHarmonySystem@@QAEXPAUJEWELOFHARMONY_ITEM_EFFECT@@@Z ; CJewelOfHarmonySystem::InitEffectValue

; 682  : 
; 683  : 	int iItemIndex = 0;

  01ac3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iItemIndex$[ebp], 0

; 684  : 
; 685  : 	for ( iItemIndex =0;iItemIndex <INVETORY_WEAR_SIZE ; iItemIndex++)

  01aca	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iItemIndex$[ebp], 0
  01ad1	eb 09		 jmp	 SHORT $LN5@SetApplySt
$LN4@SetApplySt:
  01ad3	8b 45 f4	 mov	 eax, DWORD PTR _iItemIndex$[ebp]
  01ad6	83 c0 01	 add	 eax, 1
  01ad9	89 45 f4	 mov	 DWORD PTR _iItemIndex$[ebp], eax
$LN5@SetApplySt:
  01adc	83 7d f4 0c	 cmp	 DWORD PTR _iItemIndex$[ebp], 12 ; 0000000cH
  01ae0	7d 5d		 jge	 SHORT $LN3@SetApplySt

; 686  : 	{
; 687  : 		if ( lpObj->pInventory[iItemIndex].IsItem() != FALSE )

  01ae2	8b 4d f4	 mov	 ecx, DWORD PTR _iItemIndex$[ebp]
  01ae5	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01aeb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01aee	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  01af4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  01af9	85 c0		 test	 eax, eax
  01afb	74 40		 je	 SHORT $LN2@SetApplySt

; 688  : 		{
; 689  : 			if ( lpObj->pInventory[iItemIndex].m_IsValidItem !=  false )

  01afd	8b 45 f4	 mov	 eax, DWORD PTR _iItemIndex$[ebp]
  01b00	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01b06	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b09	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  01b0f	0f b6 84 02 b0
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+176]
  01b17	85 c0		 test	 eax, eax
  01b19	74 22		 je	 SHORT $LN2@SetApplySt

; 690  : 			{
; 691  : 				BOOL bResult = this->_CalcItemEffectValue(&lpObj->pInventory[iItemIndex], pItemEffect);

  01b1b	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01b1e	50		 push	 eax
  01b1f	8b 4d f4	 mov	 ecx, DWORD PTR _iItemIndex$[ebp]
  01b22	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01b28	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b2b	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  01b31	51		 push	 ecx
  01b32	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b35	e8 00 00 00 00	 call	 ?_CalcItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@PAUJEWELOFHARMONY_ITEM_EFFECT@@@Z ; CJewelOfHarmonySystem::_CalcItemEffectValue
  01b3a	89 45 f0	 mov	 DWORD PTR _bResult$230022[ebp], eax
$LN2@SetApplySt:

; 692  : 			}
; 693  : 		}
; 694  : 	}

  01b3d	eb 94		 jmp	 SHORT $LN4@SetApplySt
$LN3@SetApplySt:

; 695  : 
; 696  : 	lpObj->m_AttackDamageMinLeft += pItemEffect->HJOpAddMinAttackDamage;

  01b3f	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01b42	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01b45	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b48	03 8a 7c 04 00
	00		 add	 ecx, DWORD PTR [edx+1148]
  01b4e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b51	89 88 7c 04 00
	00		 mov	 DWORD PTR [eax+1148], ecx

; 697  : 	lpObj->m_AttackDamageMinLeft += pItemEffect->HJOpAddAttackDamage;

  01b57	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01b5a	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01b5e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b61	03 8a 7c 04 00
	00		 add	 ecx, DWORD PTR [edx+1148]
  01b67	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b6a	89 88 7c 04 00
	00		 mov	 DWORD PTR [eax+1148], ecx

; 698  : 	lpObj->m_AttackDamageMinRight += pItemEffect->HJOpAddMinAttackDamage;

  01b70	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01b73	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01b76	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b79	03 8a 84 04 00
	00		 add	 ecx, DWORD PTR [edx+1156]
  01b7f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b82	89 88 84 04 00
	00		 mov	 DWORD PTR [eax+1156], ecx

; 699  : 	lpObj->m_AttackDamageMinRight += pItemEffect->HJOpAddAttackDamage;

  01b88	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01b8b	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01b8f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b92	03 8a 84 04 00
	00		 add	 ecx, DWORD PTR [edx+1156]
  01b98	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b9b	89 88 84 04 00
	00		 mov	 DWORD PTR [eax+1156], ecx

; 700  : 
; 701  : 	lpObj->m_AttackDamageMaxLeft += pItemEffect->HJOpAddMaxAttackDamage;

  01ba1	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01ba4	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  01ba8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01bab	03 8a 78 04 00
	00		 add	 ecx, DWORD PTR [edx+1144]
  01bb1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01bb4	89 88 78 04 00
	00		 mov	 DWORD PTR [eax+1144], ecx

; 702  : 	lpObj->m_AttackDamageMaxLeft += pItemEffect->HJOpAddAttackDamage;

  01bba	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01bbd	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01bc1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01bc4	03 8a 78 04 00
	00		 add	 ecx, DWORD PTR [edx+1144]
  01bca	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01bcd	89 88 78 04 00
	00		 mov	 DWORD PTR [eax+1144], ecx

; 703  : 	lpObj->m_AttackDamageMaxRight += pItemEffect->HJOpAddMaxAttackDamage;

  01bd3	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01bd6	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  01bda	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01bdd	03 8a 80 04 00
	00		 add	 ecx, DWORD PTR [edx+1152]
  01be3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01be6	89 88 80 04 00
	00		 mov	 DWORD PTR [eax+1152], ecx

; 704  : 	lpObj->m_AttackDamageMaxRight += pItemEffect->HJOpAddAttackDamage;

  01bec	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01bef	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01bf3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01bf6	03 8a 80 04 00
	00		 add	 ecx, DWORD PTR [edx+1152]
  01bfc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01bff	89 88 80 04 00
	00		 mov	 DWORD PTR [eax+1152], ecx

; 705  : 
; 706  : 	lpObj->m_MagicDamageMin += pItemEffect->HJOpAddMagicPower;

  01c05	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01c08	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  01c0c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c0f	03 8a 68 04 00
	00		 add	 ecx, DWORD PTR [edx+1128]
  01c15	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c18	89 88 68 04 00
	00		 mov	 DWORD PTR [eax+1128], ecx

; 707  : 	lpObj->m_MagicDamageMax += pItemEffect->HJOpAddMagicPower;

  01c1e	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01c21	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  01c25	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c28	03 8a 6c 04 00
	00		 add	 ecx, DWORD PTR [edx+1132]
  01c2e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c31	89 88 6c 04 00
	00		 mov	 DWORD PTR [eax+1132], ecx

; 708  : 
; 709  : 	lpObj->m_Defense += pItemEffect->HJOpAddDefense * 10 / 20;

  01c37	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01c3a	0f bf 40 16	 movsx	 eax, WORD PTR [eax+22]
  01c3e	6b c0 0a	 imul	 eax, 10			; 0000000aH
  01c41	99		 cdq
  01c42	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01c47	f7 f9		 idiv	 ecx
  01c49	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c4c	03 82 94 04 00
	00		 add	 eax, DWORD PTR [edx+1172]
  01c52	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01c55	89 81 94 04 00
	00		 mov	 DWORD PTR [ecx+1172], eax

; 710  : 
; 711  : 	lpObj->AddBP += pItemEffect->HJOpAddMaxAG;

  01c5b	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01c5e	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  01c62	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c65	03 8a 30 01 00
	00		 add	 ecx, DWORD PTR [edx+304]
  01c6b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c6e	89 88 30 01 00
	00		 mov	 DWORD PTR [eax+304], ecx

; 712  : 	
; 713  : 	lpObj->AddLife += pItemEffect->HJOpAddMaxHP;

  01c74	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01c77	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  01c7b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c7e	03 8a 4c 01 00
	00		 add	 ecx, DWORD PTR [edx+332]
  01c84	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c87	89 88 4c 01 00
	00		 mov	 DWORD PTR [eax+332], ecx

; 714  : 
; 715  : 	lpObj->DamageMinus += pItemEffect->HJOpAddDamageDecrease;

  01c8d	8b 45 f8	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01c90	0f bf 48 22	 movsx	 ecx, WORD PTR [eax+34]
  01c94	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c97	0f b6 82 70 01
	00 00		 movzx	 eax, BYTE PTR [edx+368]
  01c9e	03 c1		 add	 eax, ecx
  01ca0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01ca3	88 81 70 01 00
	00		 mov	 BYTE PTR [ecx+368], al

; 716  : }

  01ca9	5f		 pop	 edi
  01caa	5e		 pop	 esi
  01cab	5b		 pop	 ebx
  01cac	8b e5		 mov	 esp, ebp
  01cae	5d		 pop	 ebp
  01caf	c2 04 00	 ret	 4
?SetApplyStrengthenItem@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CJewelOfHarmonySystem::SetApplyStrengthenItem
_TEXT	ENDS
PUBLIC	?GetItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ; CJewelOfHarmonySystem::GetItemEffectValue
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iItemEffectValue$ = -20				; size = 4
_iItemOptionLevel$ = -16				; size = 4
_iItemOptionType$ = -12					; size = 4
_iItemType$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
_iOptionType$ = 12					; size = 4
?GetItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z PROC ; CJewelOfHarmonySystem::GetItemEffectValue
; _this$ = ecx

; 722  : {

  01cc0	55		 push	 ebp
  01cc1	8b ec		 mov	 ebp, esp
  01cc3	83 ec 54	 sub	 esp, 84			; 00000054H
  01cc6	53		 push	 ebx
  01cc7	56		 push	 esi
  01cc8	57		 push	 edi
  01cc9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 723  : 	int iItemType = this->_GetItemType(pItem);

  01ccc	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01ccf	50		 push	 eax
  01cd0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cd3	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  01cd8	89 45 f8	 mov	 DWORD PTR _iItemType$[ebp], eax

; 724  : 
; 725  : 	if ( iItemType == JEWELOFHARMONY_ITEM_TYPE_NULL )

  01cdb	83 7d f8 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  01cdf	75 04		 jne	 SHORT $LN4@GetItemEff

; 726  : 		return 0;

  01ce1	33 c0		 xor	 eax, eax
  01ce3	eb 6e		 jmp	 SHORT $LN5@GetItemEff
$LN4@GetItemEff:

; 727  : 
; 728  : 	int iItemOptionType = AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM;

  01ce5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iItemOptionType$[ebp], 0

; 729  : 
; 730  : 	iItemOptionType = this->GetItemStrengthenOption(pItem);

  01cec	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01cef	50		 push	 eax
  01cf0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cf3	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01cf8	0f b6 c8	 movzx	 ecx, al
  01cfb	89 4d f4	 mov	 DWORD PTR _iItemOptionType$[ebp], ecx

; 731  : 
; 732  : 	if ( iItemOptionType == AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM ||iItemOptionType != iOptionType )

  01cfe	83 7d f4 00	 cmp	 DWORD PTR _iItemOptionType$[ebp], 0
  01d02	74 08		 je	 SHORT $LN2@GetItemEff
  01d04	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  01d07	3b 45 0c	 cmp	 eax, DWORD PTR _iOptionType$[ebp]
  01d0a	74 04		 je	 SHORT $LN3@GetItemEff
$LN2@GetItemEff:

; 733  : 		return 0;

  01d0c	33 c0		 xor	 eax, eax
  01d0e	eb 43		 jmp	 SHORT $LN5@GetItemEff
$LN3@GetItemEff:

; 734  : 
; 735  : 	int iItemOptionLevel = this->_GetItemOptionLevel(pItem);

  01d10	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01d13	50		 push	 eax
  01d14	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d17	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  01d1c	0f b6 c8	 movzx	 ecx, al
  01d1f	89 4d f0	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 736  : 
; 737  : 	if ( iItemOptionLevel >= MAX_JOH_ITEM_OPTION )

  01d22	83 7d f0 0e	 cmp	 DWORD PTR _iItemOptionLevel$[ebp], 14 ; 0000000eH
  01d26	7c 04		 jl	 SHORT $LN1@GetItemEff

; 738  : 		return 0;

  01d28	33 c0		 xor	 eax, eax
  01d2a	eb 27		 jmp	 SHORT $LN5@GetItemEff
$LN1@GetItemEff:

; 739  : 
; 740  : 	int iItemEffectValue = this->m_itemOption[iItemType][iItemOptionType].iItemEffectValue[iItemOptionLevel];

  01d2c	8b 45 f8	 mov	 eax, DWORD PTR _iItemType$[ebp]
  01d2f	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  01d35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d38	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  01d3c	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  01d3f	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  01d45	03 55 f0	 add	 edx, DWORD PTR _iItemOptionLevel$[ebp]
  01d48	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  01d4d	89 4d ec	 mov	 DWORD PTR _iItemEffectValue$[ebp], ecx

; 741  : 	return iItemEffectValue;

  01d50	8b 45 ec	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]
$LN5@GetItemEff:

; 742  : }

  01d53	5f		 pop	 edi
  01d54	5e		 pop	 esi
  01d55	5b		 pop	 ebx
  01d56	8b e5		 mov	 esp, ebp
  01d58	5d		 pop	 ebp
  01d59	c2 08 00	 ret	 8
?GetItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ENDP ; CJewelOfHarmonySystem::GetItemEffectValue
; Function compile flags: /Odtp /ZI
tv200 = -92						; size = 4
tv167 = -92						; size = 4
tv91 = -92						; size = 4
tv90 = -92						; size = 4
_bResult$ = -24						; size = 4
_iItemEffectValue$ = -20				; size = 4
_iItemOptionLevel$ = -16				; size = 4
_iItemOptionType$ = -12					; size = 4
_iItemType$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
_pItemEffect$ = 12					; size = 4
?_CalcItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@PAUJEWELOFHARMONY_ITEM_EFFECT@@@Z PROC ; CJewelOfHarmonySystem::_CalcItemEffectValue
; _this$ = ecx

; 747  : {

  01d60	55		 push	 ebp
  01d61	8b ec		 mov	 ebp, esp
  01d63	83 ec 5c	 sub	 esp, 92			; 0000005cH
  01d66	53		 push	 ebx
  01d67	56		 push	 esi
  01d68	57		 push	 edi
  01d69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 748  : 	int iItemType = this->_GetItemType(pItem);

  01d6c	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01d6f	50		 push	 eax
  01d70	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d73	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  01d78	89 45 f8	 mov	 DWORD PTR _iItemType$[ebp], eax

; 749  : 
; 750  : 	if ( iItemType == JEWELOFHARMONY_ITEM_TYPE_NULL )

  01d7b	83 7d f8 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  01d7f	75 07		 jne	 SHORT $LN45@CalcItemEf

; 751  : 		return 0;

  01d81	33 c0		 xor	 eax, eax
  01d83	e9 06 03 00 00	 jmp	 $LN46@CalcItemEf
$LN45@CalcItemEf:

; 752  : 
; 753  : 	int iItemOptionType = AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM;

  01d88	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iItemOptionType$[ebp], 0

; 754  : 
; 755  : 	iItemOptionType = this->GetItemStrengthenOption(pItem);

  01d8f	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01d92	50		 push	 eax
  01d93	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d96	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01d9b	0f b6 c8	 movzx	 ecx, al
  01d9e	89 4d f4	 mov	 DWORD PTR _iItemOptionType$[ebp], ecx

; 756  : 
; 757  : 	if ( iItemOptionType == AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM )

  01da1	83 7d f4 00	 cmp	 DWORD PTR _iItemOptionType$[ebp], 0
  01da5	75 07		 jne	 SHORT $LN44@CalcItemEf

; 758  : 		return 0;

  01da7	33 c0		 xor	 eax, eax
  01da9	e9 e0 02 00 00	 jmp	 $LN46@CalcItemEf
$LN44@CalcItemEf:

; 759  : 
; 760  : 	int iItemOptionLevel = this->_GetItemOptionLevel(pItem);

  01dae	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01db1	50		 push	 eax
  01db2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01db5	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  01dba	0f b6 c8	 movzx	 ecx, al
  01dbd	89 4d f0	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 761  : 
; 762  : 	if ( iItemOptionLevel >= MAX_JOH_ITEM_OPTION )

  01dc0	83 7d f0 0e	 cmp	 DWORD PTR _iItemOptionLevel$[ebp], 14 ; 0000000eH
  01dc4	7c 07		 jl	 SHORT $LN43@CalcItemEf

; 763  : 		return 0;

  01dc6	33 c0		 xor	 eax, eax
  01dc8	e9 c1 02 00 00	 jmp	 $LN46@CalcItemEf
$LN43@CalcItemEf:

; 764  : 
; 765  : 
; 766  : 	if ( this->IsActive(pItem) == FALSE )

  01dcd	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  01dd0	50		 push	 eax
  01dd1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01dd4	e8 00 00 00 00	 call	 ?IsActive@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsActive
  01dd9	85 c0		 test	 eax, eax
  01ddb	75 07		 jne	 SHORT $LN42@CalcItemEf

; 767  : 		return FALSE;

  01ddd	33 c0		 xor	 eax, eax
  01ddf	e9 aa 02 00 00	 jmp	 $LN46@CalcItemEf
$LN42@CalcItemEf:

; 768  : 
; 769  : 	int iItemEffectValue = this->m_itemOption[iItemType][iItemOptionType].iItemEffectValue[iItemOptionLevel];

  01de4	8b 45 f8	 mov	 eax, DWORD PTR _iItemType$[ebp]
  01de7	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  01ded	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01df0	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  01df4	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  01df7	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  01dfd	03 55 f0	 add	 edx, DWORD PTR _iItemOptionLevel$[ebp]
  01e00	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  01e05	89 4d ec	 mov	 DWORD PTR _iItemEffectValue$[ebp], ecx

; 770  : 
; 771  : 	BOOL bResult = TRUE;

  01e08	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 772  : 
; 773  : 	switch ( iItemType )

  01e0f	8b 45 f8	 mov	 eax, DWORD PTR _iItemType$[ebp]
  01e12	89 45 a4	 mov	 DWORD PTR tv90[ebp], eax
  01e15	83 7d a4 01	 cmp	 DWORD PTR tv90[ebp], 1
  01e19	74 19		 je	 SHORT $LN39@CalcItemEf
  01e1b	83 7d a4 02	 cmp	 DWORD PTR tv90[ebp], 2
  01e1f	0f 84 f3 00 00
	00		 je	 $LN25@CalcItemEf
  01e25	83 7d a4 03	 cmp	 DWORD PTR tv90[ebp], 3
  01e29	0f 84 8e 01 00
	00		 je	 $LN13@CalcItemEf
  01e2f	e9 50 02 00 00	 jmp	 $LN1@CalcItemEf
$LN39@CalcItemEf:

; 774  : 	{
; 775  : 		case JEWELOFHARMONY_ITEM_TYPE_WEAPON:
; 776  : 			switch (iItemOptionType)

  01e34	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  01e37	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  01e3a	8b 4d a4	 mov	 ecx, DWORD PTR tv91[ebp]
  01e3d	83 e9 01	 sub	 ecx, 1
  01e40	89 4d a4	 mov	 DWORD PTR tv91[ebp], ecx
  01e43	83 7d a4 09	 cmp	 DWORD PTR tv91[ebp], 9
  01e47	0f 87 bf 00 00
	00		 ja	 $LN26@CalcItemEf
  01e4d	8b 55 a4	 mov	 edx, DWORD PTR tv91[ebp]
  01e50	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN48@CalcItemEf[edx*4]
$LN36@CalcItemEf:

; 777  : 			{
; 778  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_MINATTACKDAMAGE:
; 779  : 					pItemEffect->HJOpAddMinAttackDamage += iItemEffectValue;

  01e57	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01e5a	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01e5d	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01e60	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01e63	66 89 0a	 mov	 WORD PTR [edx], cx

; 780  : 					break;

  01e66	e9 a8 00 00 00	 jmp	 $LN37@CalcItemEf
$LN35@CalcItemEf:

; 781  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_MAXATTACKDAMAGE:
; 782  : 					pItemEffect->HJOpAddMaxAttackDamage += iItemEffectValue;

  01e6b	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01e6e	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  01e72	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01e75	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01e78	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 783  : 					break;

  01e7c	e9 92 00 00 00	 jmp	 $LN37@CalcItemEf
$LN34@CalcItemEf:

; 784  : 				case AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_STR:
; 785  : 					break;

  01e81	e9 8d 00 00 00	 jmp	 $LN37@CalcItemEf
$LN33@CalcItemEf:

; 786  : 				case AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_DEX:
; 787  : 					break;

  01e86	e9 88 00 00 00	 jmp	 $LN37@CalcItemEf
$LN32@CalcItemEf:

; 788  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_ATTACKDAMAGE_BOTH:
; 789  : 					pItemEffect->HJOpAddMinAttackDamage += iItemEffectValue;

  01e8b	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01e8e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01e91	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01e94	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01e97	66 89 0a	 mov	 WORD PTR [edx], cx

; 790  : 					pItemEffect->HJOpAddMaxAttackDamage += iItemEffectValue;

  01e9a	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01e9d	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  01ea1	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01ea4	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01ea7	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 791  : 					break;

  01eab	eb 66		 jmp	 SHORT $LN37@CalcItemEf
$LN31@CalcItemEf:

; 792  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_CRITICALDAMAGE:
; 793  : 					pItemEffect->HJOpAddCriticalDamage += iItemEffectValue;

  01ead	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01eb0	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  01eb4	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01eb7	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01eba	66 89 4a 0a	 mov	 WORD PTR [edx+10], cx

; 794  : 					break;

  01ebe	eb 53		 jmp	 SHORT $LN37@CalcItemEf
$LN30@CalcItemEf:

; 795  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_SKILLDAMAGE:
; 796  : 					pItemEffect->HJOpAddSkillAttack += iItemEffectValue;

  01ec0	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01ec3	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  01ec7	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01eca	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01ecd	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 797  : 					break;

  01ed1	eb 40		 jmp	 SHORT $LN37@CalcItemEf
$LN29@CalcItemEf:

; 798  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_ATTACKSUCCESRATE_PVP:
; 799  : 					pItemEffect->HJOpAddAttackSuccessRatePVP += iItemEffectValue;

  01ed3	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01ed6	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  01eda	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01edd	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01ee0	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 800  : 					break;

  01ee4	eb 2d		 jmp	 SHORT $LN37@CalcItemEf
$LN28@CalcItemEf:

; 801  : 				case AT_JEWELOFHARMONY_WEAPON_DECREASE_SD_RATE:
; 802  : 					pItemEffect->HJOpDecreaseSDRate += iItemEffectValue;

  01ee6	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01ee9	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  01eed	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01ef0	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01ef3	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 803  : 					break;

  01ef7	eb 1a		 jmp	 SHORT $LN37@CalcItemEf
$LN27@CalcItemEf:

; 804  : 				case AT_JEWELOFHARMONY_WEAPON_IMPROVE_IGNORE_SD_RATE:
; 805  : 					pItemEffect->HJOpAddIgnoreSDRate += iItemEffectValue;

  01ef9	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01efc	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  01f00	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01f03	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01f06	66 89 4a 12	 mov	 WORD PTR [edx+18], cx

; 806  : 					break;

  01f0a	eb 07		 jmp	 SHORT $LN37@CalcItemEf
$LN26@CalcItemEf:

; 807  : 				default:
; 808  : 					bResult = FALSE;

  01f0c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0
$LN37@CalcItemEf:

; 809  : 			}
; 810  : 			break;

  01f13	e9 73 01 00 00	 jmp	 $LN40@CalcItemEf
$LN25@CalcItemEf:

; 811  : 
; 812  : 		case JEWELOFHARMONY_ITEM_TYPE_STAFF:
; 813  : 			switch (iItemOptionType)

  01f18	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  01f1b	89 45 a4	 mov	 DWORD PTR tv167[ebp], eax
  01f1e	8b 4d a4	 mov	 ecx, DWORD PTR tv167[ebp]
  01f21	83 e9 01	 sub	 ecx, 1
  01f24	89 4d a4	 mov	 DWORD PTR tv167[ebp], ecx
  01f27	83 7d a4 07	 cmp	 DWORD PTR tv167[ebp], 7
  01f2b	0f 87 80 00 00
	00		 ja	 $LN14@CalcItemEf
  01f31	8b 55 a4	 mov	 edx, DWORD PTR tv167[ebp]
  01f34	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN49@CalcItemEf[edx*4]
$LN22@CalcItemEf:

; 814  : 			{
; 815  : 				case AT_JEWELOFHARMONY_STAFF_IMPROVE_MAGICDAMAGE:
; 816  : 					pItemEffect->HJOpAddMagicPower += iItemEffectValue;

  01f3b	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01f3e	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  01f42	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01f45	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01f48	66 89 4a 14	 mov	 WORD PTR [edx+20], cx

; 817  : 					break;

  01f4c	eb 6a		 jmp	 SHORT $LN23@CalcItemEf
$LN21@CalcItemEf:

; 818  : 				case AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_STR:
; 819  : 					break;

  01f4e	eb 68		 jmp	 SHORT $LN23@CalcItemEf
$LN20@CalcItemEf:

; 820  : 				case AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_DEX:
; 821  : 					break;

  01f50	eb 66		 jmp	 SHORT $LN23@CalcItemEf
$LN19@CalcItemEf:

; 822  : 				case AT_JEWELOFHARMONY_STAFF_IMPROVE_SKILLDAMAGE:
; 823  : 					pItemEffect->HJOpAddSkillAttack += iItemEffectValue;

  01f52	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01f55	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  01f59	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01f5c	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01f5f	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 824  : 					break;

  01f63	eb 53		 jmp	 SHORT $LN23@CalcItemEf
$LN18@CalcItemEf:

; 825  : 				case AT_JEWELOFHARMONY_STAFF_IMPROVE_CRITICALDAMAGE:
; 826  : 					pItemEffect->HJOpAddCriticalDamage += iItemEffectValue;

  01f65	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01f68	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  01f6c	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01f6f	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01f72	66 89 4a 0a	 mov	 WORD PTR [edx+10], cx

; 827  : 					break;

  01f76	eb 40		 jmp	 SHORT $LN23@CalcItemEf
$LN17@CalcItemEf:

; 828  : 				case AT_JEWELOFHARMONY_STAFF_DECREASE_SD_RATE:
; 829  : 					pItemEffect->HJOpDecreaseSDRate += iItemEffectValue;

  01f78	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01f7b	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  01f7f	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01f82	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01f85	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 830  : 					break;

  01f89	eb 2d		 jmp	 SHORT $LN23@CalcItemEf
$LN16@CalcItemEf:

; 831  : 				case AT_JEWELOFHARMONY_STAFF_IMPROVE_ATTACKSUCCESRATE_PVP:
; 832  : 					pItemEffect->HJOpAddAttackSuccessRatePVP += iItemEffectValue;

  01f8b	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01f8e	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  01f92	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01f95	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01f98	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 833  : 					break;

  01f9c	eb 1a		 jmp	 SHORT $LN23@CalcItemEf
$LN15@CalcItemEf:

; 834  : 				case AT_JEWELOFHARMONY_STAFF_IMPROVE_IGNORE_SD_RATE:
; 835  : 					pItemEffect->HJOpAddIgnoreSDRate += iItemEffectValue;

  01f9e	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01fa1	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  01fa5	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01fa8	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01fab	66 89 4a 12	 mov	 WORD PTR [edx+18], cx

; 836  : 					break;

  01faf	eb 07		 jmp	 SHORT $LN23@CalcItemEf
$LN14@CalcItemEf:

; 837  : 				default:
; 838  : 					bResult = FALSE;

  01fb1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0
$LN23@CalcItemEf:

; 839  : 			}
; 840  : 			break;

  01fb8	e9 ce 00 00 00	 jmp	 $LN40@CalcItemEf
$LN13@CalcItemEf:

; 841  : 
; 842  : 		case JEWELOFHARMONY_ITEM_TYPE_DEFENSE:
; 843  : 			switch (iItemOptionType)

  01fbd	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  01fc0	89 45 a4	 mov	 DWORD PTR tv200[ebp], eax
  01fc3	8b 4d a4	 mov	 ecx, DWORD PTR tv200[ebp]
  01fc6	83 e9 01	 sub	 ecx, 1
  01fc9	89 4d a4	 mov	 DWORD PTR tv200[ebp], ecx
  01fcc	83 7d a4 07	 cmp	 DWORD PTR tv200[ebp], 7
  01fd0	0f 87 a5 00 00
	00		 ja	 $LN2@CalcItemEf
  01fd6	8b 55 a4	 mov	 edx, DWORD PTR tv200[ebp]
  01fd9	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN50@CalcItemEf[edx*4]
$LN10@CalcItemEf:

; 844  : 			{
; 845  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_DEFENSE:
; 846  : 					pItemEffect->HJOpAddDefense += iItemEffectValue;

  01fe0	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01fe3	0f bf 48 16	 movsx	 ecx, WORD PTR [eax+22]
  01fe7	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  01fea	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  01fed	66 89 4a 16	 mov	 WORD PTR [edx+22], cx

; 847  : 					break;

  01ff1	e9 8c 00 00 00	 jmp	 $LN11@CalcItemEf
$LN9@CalcItemEf:

; 848  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_MAX_AG:
; 849  : 					pItemEffect->HJOpAddMaxAG += iItemEffectValue;

  01ff6	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  01ff9	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  01ffd	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  02000	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  02003	66 89 4a 18	 mov	 WORD PTR [edx+24], cx

; 850  : 					break;

  02007	eb 79		 jmp	 SHORT $LN11@CalcItemEf
$LN8@CalcItemEf:

; 851  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_MAX_HP:
; 852  : 					pItemEffect->HJOpAddMaxHP += iItemEffectValue;

  02009	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  0200c	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  02010	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  02013	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  02016	66 89 4a 1a	 mov	 WORD PTR [edx+26], cx

; 853  : 					break;

  0201a	eb 66		 jmp	 SHORT $LN11@CalcItemEf
$LN7@CalcItemEf:

; 854  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_AUTO_REFILL_HP:
; 855  : 					pItemEffect->HJOpAddRefillHP += iItemEffectValue;

  0201c	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  0201f	0f bf 48 1c	 movsx	 ecx, WORD PTR [eax+28]
  02023	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  02026	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  02029	66 89 4a 1c	 mov	 WORD PTR [edx+28], cx

; 856  : 					break;

  0202d	eb 53		 jmp	 SHORT $LN11@CalcItemEf
$LN6@CalcItemEf:

; 857  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_AUTO_REFILL_MP:
; 858  : 					pItemEffect->HJOpAddRefillMP += iItemEffectValue;

  0202f	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  02032	0f bf 48 1e	 movsx	 ecx, WORD PTR [eax+30]
  02036	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  02039	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  0203c	66 89 4a 1e	 mov	 WORD PTR [edx+30], cx

; 859  : 					break;

  02040	eb 40		 jmp	 SHORT $LN11@CalcItemEf
$LN5@CalcItemEf:

; 860  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_BLOCKSUCCESRATE_PVP:
; 861  : 					pItemEffect->HJOpAddDefenseSuccessRatePvP += iItemEffectValue;

  02042	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  02045	0f bf 48 20	 movsx	 ecx, WORD PTR [eax+32]
  02049	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  0204c	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  0204f	66 89 4a 20	 mov	 WORD PTR [edx+32], cx

; 862  : 					break;

  02053	eb 2d		 jmp	 SHORT $LN11@CalcItemEf
$LN4@CalcItemEf:

; 863  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_DAMAGE_DECREASE:
; 864  : 					pItemEffect->HJOpAddDamageDecrease += iItemEffectValue;

  02055	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  02058	0f bf 48 22	 movsx	 ecx, WORD PTR [eax+34]
  0205c	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  0205f	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  02062	66 89 4a 22	 mov	 WORD PTR [edx+34], cx

; 865  : 					break;

  02066	eb 1a		 jmp	 SHORT $LN11@CalcItemEf
$LN3@CalcItemEf:

; 866  : 				case AT_JEWELOFHARMONY_DEFENSE_IMPROVE_SD_RATE:
; 867  : 					pItemEffect->HJOpAddSDRate += iItemEffectValue;

  02068	8b 45 0c	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  0206b	0f bf 48 24	 movsx	 ecx, WORD PTR [eax+36]
  0206f	03 4d ec	 add	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  02072	8b 55 0c	 mov	 edx, DWORD PTR _pItemEffect$[ebp]
  02075	66 89 4a 24	 mov	 WORD PTR [edx+36], cx

; 868  : 					break;

  02079	eb 07		 jmp	 SHORT $LN11@CalcItemEf
$LN2@CalcItemEf:

; 869  : 				default:
; 870  : 					bResult = FALSE;

  0207b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0
$LN11@CalcItemEf:

; 871  : 			}
; 872  : 			break;

  02082	eb 07		 jmp	 SHORT $LN40@CalcItemEf
$LN1@CalcItemEf:

; 873  : 
; 874  : 		default:
; 875  : 			bResult = FALSE;

  02084	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0
$LN40@CalcItemEf:

; 876  : 	}
; 877  : 
; 878  : 	return bResult;

  0208b	8b 45 e8	 mov	 eax, DWORD PTR _bResult$[ebp]
$LN46@CalcItemEf:

; 879  : }

  0208e	5f		 pop	 edi
  0208f	5e		 pop	 esi
  02090	5b		 pop	 ebx
  02091	8b e5		 mov	 esp, ebp
  02093	5d		 pop	 ebp
  02094	c2 08 00	 ret	 8
  02097	90		 npad	 1
$LN48@CalcItemEf:
  02098	00 00 00 00	 DD	 $LN36@CalcItemEf
  0209c	00 00 00 00	 DD	 $LN35@CalcItemEf
  020a0	00 00 00 00	 DD	 $LN34@CalcItemEf
  020a4	00 00 00 00	 DD	 $LN33@CalcItemEf
  020a8	00 00 00 00	 DD	 $LN32@CalcItemEf
  020ac	00 00 00 00	 DD	 $LN31@CalcItemEf
  020b0	00 00 00 00	 DD	 $LN30@CalcItemEf
  020b4	00 00 00 00	 DD	 $LN29@CalcItemEf
  020b8	00 00 00 00	 DD	 $LN28@CalcItemEf
  020bc	00 00 00 00	 DD	 $LN27@CalcItemEf
$LN49@CalcItemEf:
  020c0	00 00 00 00	 DD	 $LN22@CalcItemEf
  020c4	00 00 00 00	 DD	 $LN21@CalcItemEf
  020c8	00 00 00 00	 DD	 $LN20@CalcItemEf
  020cc	00 00 00 00	 DD	 $LN19@CalcItemEf
  020d0	00 00 00 00	 DD	 $LN18@CalcItemEf
  020d4	00 00 00 00	 DD	 $LN17@CalcItemEf
  020d8	00 00 00 00	 DD	 $LN16@CalcItemEf
  020dc	00 00 00 00	 DD	 $LN15@CalcItemEf
$LN50@CalcItemEf:
  020e0	00 00 00 00	 DD	 $LN10@CalcItemEf
  020e4	00 00 00 00	 DD	 $LN9@CalcItemEf
  020e8	00 00 00 00	 DD	 $LN8@CalcItemEf
  020ec	00 00 00 00	 DD	 $LN7@CalcItemEf
  020f0	00 00 00 00	 DD	 $LN6@CalcItemEf
  020f4	00 00 00 00	 DD	 $LN5@CalcItemEf
  020f8	00 00 00 00	 DD	 $LN4@CalcItemEf
  020fc	00 00 00 00	 DD	 $LN3@CalcItemEf
?_CalcItemEffectValue@CJewelOfHarmonySystem@@QAEHPAVCItem@@PAUJEWELOFHARMONY_ITEM_EFFECT@@@Z ENDP ; CJewelOfHarmonySystem::_CalcItemEffectValue
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_pItemEffect$ = 8					; size = 4
?InitEffectValue@CJewelOfHarmonySystem@@QAEXPAUJEWELOFHARMONY_ITEM_EFFECT@@@Z PROC ; CJewelOfHarmonySystem::InitEffectValue
; _this$ = ecx

; 884  : {

  02100	55		 push	 ebp
  02101	8b ec		 mov	 ebp, esp
  02103	83 ec 44	 sub	 esp, 68			; 00000044H
  02106	53		 push	 ebx
  02107	56		 push	 esi
  02108	57		 push	 edi
  02109	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 885  : 	pItemEffect->HJOpAddMinAttackDamage = 0;

  0210c	33 c0		 xor	 eax, eax
  0210e	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02111	66 89 01	 mov	 WORD PTR [ecx], ax

; 886  : 	pItemEffect->HJOpAddMaxAttackDamage = 0;

  02114	33 c0		 xor	 eax, eax
  02116	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02119	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 887  : 	pItemEffect->HJOpRequireStr = 0;

  0211d	33 c0		 xor	 eax, eax
  0211f	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02122	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 888  : 	pItemEffect->HJOpRequireDex = 0;

  02126	33 c0		 xor	 eax, eax
  02128	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  0212b	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 889  : 	pItemEffect->HJOpAddAttackDamage = 0;

  0212f	33 c0		 xor	 eax, eax
  02131	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02134	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 890  : 	pItemEffect->HJOpAddCriticalDamage = 0;

  02138	33 c0		 xor	 eax, eax
  0213a	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  0213d	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 891  : 	pItemEffect->HJOpAddSkillAttack = 0;

  02141	33 c0		 xor	 eax, eax
  02143	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02146	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 892  : 	pItemEffect->HJOpAddAttackSuccessRatePVP = 0;

  0214a	33 c0		 xor	 eax, eax
  0214c	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  0214f	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 893  : 	pItemEffect->HJOpDecreaseSDRate = 0;

  02153	33 c0		 xor	 eax, eax
  02155	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02158	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 894  : 	pItemEffect->HJOpAddIgnoreSDRate = 0;

  0215c	33 c0		 xor	 eax, eax
  0215e	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02161	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 895  : 	pItemEffect->HJOpAddMagicPower = 0;

  02165	33 c0		 xor	 eax, eax
  02167	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  0216a	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 896  : 	pItemEffect->HJOpAddDefense = 0;

  0216e	33 c0		 xor	 eax, eax
  02170	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02173	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 897  : 	pItemEffect->HJOpAddMaxAG = 0;

  02177	33 c0		 xor	 eax, eax
  02179	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  0217c	66 89 41 18	 mov	 WORD PTR [ecx+24], ax

; 898  : 	pItemEffect->HJOpAddMaxHP = 0;

  02180	33 c0		 xor	 eax, eax
  02182	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02185	66 89 41 1a	 mov	 WORD PTR [ecx+26], ax

; 899  : 	pItemEffect->HJOpAddRefillHP = 0;

  02189	33 c0		 xor	 eax, eax
  0218b	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  0218e	66 89 41 1c	 mov	 WORD PTR [ecx+28], ax

; 900  : 	pItemEffect->HJOpAddRefillMP = 0;

  02192	33 c0		 xor	 eax, eax
  02194	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  02197	66 89 41 1e	 mov	 WORD PTR [ecx+30], ax

; 901  : 	pItemEffect->HJOpAddDefenseSuccessRatePvP = 0;

  0219b	33 c0		 xor	 eax, eax
  0219d	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  021a0	66 89 41 20	 mov	 WORD PTR [ecx+32], ax

; 902  : 	pItemEffect->HJOpAddDamageDecrease = 0;

  021a4	33 c0		 xor	 eax, eax
  021a6	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  021a9	66 89 41 22	 mov	 WORD PTR [ecx+34], ax

; 903  : 	pItemEffect->HJOpAddSDRate = 0;

  021ad	33 c0		 xor	 eax, eax
  021af	8b 4d 08	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  021b2	66 89 41 24	 mov	 WORD PTR [ecx+36], ax

; 904  : }

  021b6	5f		 pop	 edi
  021b7	5e		 pop	 esi
  021b8	5b		 pop	 ebx
  021b9	8b e5		 mov	 esp, ebp
  021bb	5d		 pop	 ebp
  021bc	c2 04 00	 ret	 4
?InitEffectValue@CJewelOfHarmonySystem@@QAEXPAUJEWELOFHARMONY_ITEM_EFFECT@@@Z ENDP ; CJewelOfHarmonySystem::InitEffectValue
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
PUBLIC	?IsEnableToMakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsEnableToMakeSmeltingStoneItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T231943 = -84						; size = 4
$T231944 = -80						; size = 4
_reqLevel$230280 = -12					; size = 4
_iter$ = -8						; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?IsEnableToMakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::IsEnableToMakeSmeltingStoneItem
; _this$ = ecx

; 910  : {

  021c0	55		 push	 ebp
  021c1	8b ec		 mov	 ebp, esp
  021c3	83 ec 54	 sub	 esp, 84			; 00000054H
  021c6	53		 push	 ebx
  021c7	56		 push	 esi
  021c8	57		 push	 edi
  021c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 911  : 	if ( this->_GetItemType(pItem) == JEWELOFHARMONY_ITEM_TYPE_NULL )

  021cc	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  021cf	50		 push	 eax
  021d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021d3	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  021d8	85 c0		 test	 eax, eax
  021da	75 07		 jne	 SHORT $LN5@IsEnableTo

; 912  : 		return FALSE;

  021dc	33 c0		 xor	 eax, eax
  021de	e9 8a 00 00 00	 jmp	 $LN6@IsEnableTo
$LN5@IsEnableTo:

; 913  : 
; 914  : 	if ( this->IsStrengthenByJewelOfHarmony(pItem) == TRUE )

  021e3	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  021e6	50		 push	 eax
  021e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021ea	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  021ef	83 f8 01	 cmp	 eax, 1
  021f2	75 04		 jne	 SHORT $LN4@IsEnableTo

; 915  : 		return FALSE;

  021f4	33 c0		 xor	 eax, eax
  021f6	eb 75		 jmp	 SHORT $LN6@IsEnableTo
$LN4@IsEnableTo:

; 916  : 
; 917  : 	if ( pItem->IsSetItem() != FALSE)

  021f8	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  021fb	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  02200	85 c0		 test	 eax, eax
  02202	74 04		 je	 SHORT $LN3@IsEnableTo

; 918  : 		return FALSE;

  02204	33 c0		 xor	 eax, eax
  02206	eb 65		 jmp	 SHORT $LN6@IsEnableTo
$LN3@IsEnableTo:

; 919  : 
; 920  : 	std::map<int,int>::iterator iter = this->m_mapEnableMixList.find(pItem->m_Type);

  02208	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0220b	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0220f	89 4d ac	 mov	 DWORD PTR $T231943[ebp], ecx
  02212	8d 55 ac	 lea	 edx, DWORD PTR $T231943[ebp]
  02215	52		 push	 edx
  02216	8d 45 f8	 lea	 eax, DWORD PTR _iter$[ebp]
  02219	50		 push	 eax
  0221a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0221d	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  02223	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find

; 921  : 
; 922  : 	if ( iter != this->m_mapEnableMixList.end() )

  02228	8d 45 b0	 lea	 eax, DWORD PTR $T231944[ebp]
  0222b	50		 push	 eax
  0222c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0222f	81 c1 4c 53 00
	00		 add	 ecx, 21324		; 0000534cH
  02235	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  0223a	50		 push	 eax
  0223b	8d 4d f8	 lea	 ecx, DWORD PTR _iter$[ebp]
  0223e	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
  02243	0f b6 c8	 movzx	 ecx, al
  02246	85 c9		 test	 ecx, ecx
  02248	74 1e		 je	 SHORT $LN2@IsEnableTo

; 923  : 	{
; 924  : 		int reqLevel = iter->second;

  0224a	8d 4d f8	 lea	 ecx, DWORD PTR _iter$[ebp]
  0224d	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
  02252	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  02255	89 45 f4	 mov	 DWORD PTR _reqLevel$230280[ebp], eax

; 925  : 
; 926  : 		if ( pItem->m_Level < reqLevel )

  02258	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0225b	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0225f	3b 4d f4	 cmp	 ecx, DWORD PTR _reqLevel$230280[ebp]
  02262	7d 04		 jge	 SHORT $LN2@IsEnableTo

; 927  : 			return FALSE;

  02264	33 c0		 xor	 eax, eax
  02266	eb 05		 jmp	 SHORT $LN6@IsEnableTo
$LN2@IsEnableTo:

; 928  : 
; 929  : 	}
; 930  : 
; 931  : 	return TRUE;

  02268	b8 01 00 00 00	 mov	 eax, 1
$LN6@IsEnableTo:

; 932  : }

  0226d	5f		 pop	 edi
  0226e	5e		 pop	 esi
  0226f	5b		 pop	 ebx
  02270	8b e5		 mov	 esp, ebp
  02272	5d		 pop	 ebp
  02273	c2 04 00	 ret	 4
?IsEnableToMakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::IsEnableToMakeSmeltingStoneItem
_TEXT	ENDS
PUBLIC	??_C@_0GI@PEBNKJPD@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@ ; `string'
PUBLIC	??_C@_0GK@JILNDENM@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@ ; `string'
PUBLIC	??_C@_0CN@FAMNANK@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@ ; `string'
PUBLIC	??_C@_0BP@EOIAKNIF@JewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
;	COMDAT ??_C@_0GI@PEBNKJPD@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@
CONST	SEGMENT
??_C@_0GI@PEBNKJPD@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@ DB '[J'
	DB	'ewelOfHarmony][Smelt Item Mix] Smelting Stone Normal[%d] Mix '
	DB	'Fail [%s][%s], Money : %d-%d Rate(%d/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JILNDENM@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@
CONST	SEGMENT
??_C@_0GK@JILNDENM@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@ DB '[J'
	DB	'ewelOfHarmony][Smelt Item Mix] Smelting Stone Normal[%d] Mix '
	DB	'Success [%s][%s], Money(%d-%d) Rate(%d/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FAMNANK@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@
CONST	SEGMENT
??_C@_0CN@FAMNANK@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@ DB '[Je'
	DB	'welOfHarmony][Smelt Item Mix] - Mix Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EOIAKNIF@JewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$AA@
CONST	SEGMENT
??_C@_0BP@EOIAKNIF@JewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$AA@ DB 'JewelO'
	DB	'fHarmony][Smelt Item Mix', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iItemType$230446 = -64					; size = 4
_iRate$ = -60						; size = 4
_iChaosTaxMoney$ = -56					; size = 4
_bIsItemNormal$ = -52					; size = 4
_JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE$ = -48	; size = 4
_n$230423 = -44						; size = 4
_iItemPos$ = -40					; size = 4
_pMsg$ = -36						; size = 16
_iMakeSmeltingStoneMixPrice$ = -20			; size = 4
_iInvalidItemCount$ = -16				; size = 4
_iValidItemCount$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
; _this$ = ecx

; 935  : {

  02280	55		 push	 ebp
  02281	8b ec		 mov	 ebp, esp
  02283	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  02289	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0228e	33 c5		 xor	 eax, ebp
  02290	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02293	53		 push	 ebx
  02294	56		 push	 esi
  02295	57		 push	 edi
  02296	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 936  : 	if ( this->m_bSystemMixSmeltingStone != TRUE )

  02299	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0229c	83 b8 1c 53 00
	00 01		 cmp	 DWORD PTR [eax+21276], 1
  022a3	74 2a		 je	 SHORT $LN18@MakeSmelti

; 937  : 	{
; 938  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13,53)), lpObj->m_Index, 1);

  022a5	6a 01		 push	 1
  022a7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  022aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  022ac	51		 push	 ecx
  022ad	68 35 0d 00 00	 push	 3381			; 00000d35H
  022b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  022b7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  022bc	50		 push	 eax
  022bd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  022c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 939  : 		return TRUE;

  022c5	b8 01 00 00 00	 mov	 eax, 1
  022ca	e9 48 03 00 00	 jmp	 $LN19@MakeSmelti
$LN18@MakeSmelti:

; 940  : 	}
; 941  : 
; 942  : 	lpObj->ChaosLock = TRUE;

  022cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  022d2	c7 80 88 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3720], 1

; 943  : 	int iValidItemCount = 0;

  022dc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iValidItemCount$[ebp], 0

; 944  : 	int iInvalidItemCount = 0;

  022e3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iInvalidItemCount$[ebp], 0

; 945  : 	int iMakeSmeltingStoneMixPrice = 0;

  022ea	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp], 0

; 946  : 
; 947  : 	PMSG_CHAOSMIXRESULT pMsg;
; 948  : 
; 949  : 	PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof(pMsg));

  022f1	6a 10		 push	 16			; 00000010H
  022f3	68 86 00 00 00	 push	 134			; 00000086H
  022f8	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  022fb	50		 push	 eax
  022fc	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  02301	83 c4 0c	 add	 esp, 12			; 0000000cH

; 950  : 	pMsg.Result = 0;

  02304	c6 45 df 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 951  : 	int iItemPos = -1;

  02308	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _iItemPos$[ebp], -1

; 952  : 
; 953  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0230f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$230423[ebp], 0
  02316	eb 09		 jmp	 SHORT $LN17@MakeSmelti
$LN16@MakeSmelti:
  02318	8b 45 d4	 mov	 eax, DWORD PTR _n$230423[ebp]
  0231b	83 c0 01	 add	 eax, 1
  0231e	89 45 d4	 mov	 DWORD PTR _n$230423[ebp], eax
$LN17@MakeSmelti:
  02321	83 7d d4 20	 cmp	 DWORD PTR _n$230423[ebp], 32 ; 00000020H
  02325	7d 58		 jge	 SHORT $LN15@MakeSmelti

; 954  : 	{
; 955  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  02327	8b 4d d4	 mov	 ecx, DWORD PTR _n$230423[ebp]
  0232a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  02330	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02333	03 88 78 0e 00
	00		 add	 ecx, DWORD PTR [eax+3704]
  02339	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0233e	83 f8 01	 cmp	 eax, 1
  02341	75 3a		 jne	 SHORT $LN14@MakeSmelti

; 956  : 		{
; 957  : 			if ( this->IsEnableToMakeSmeltingStoneItem(&lpObj->pChaosBox[n]) == TRUE )

  02343	8b 45 d4	 mov	 eax, DWORD PTR _n$230423[ebp]
  02346	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0234c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0234f	03 81 78 0e 00
	00		 add	 eax, DWORD PTR [ecx+3704]
  02355	50		 push	 eax
  02356	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02359	e8 00 00 00 00	 call	 ?IsEnableToMakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsEnableToMakeSmeltingStoneItem
  0235e	83 f8 01	 cmp	 eax, 1
  02361	75 11		 jne	 SHORT $LN13@MakeSmelti

; 958  : 			{
; 959  : 				iValidItemCount++;

  02363	8b 45 f4	 mov	 eax, DWORD PTR _iValidItemCount$[ebp]
  02366	83 c0 01	 add	 eax, 1
  02369	89 45 f4	 mov	 DWORD PTR _iValidItemCount$[ebp], eax

; 960  : 				iItemPos = n;

  0236c	8b 45 d4	 mov	 eax, DWORD PTR _n$230423[ebp]
  0236f	89 45 d8	 mov	 DWORD PTR _iItemPos$[ebp], eax

; 961  : 			}
; 962  : 			else

  02372	eb 09		 jmp	 SHORT $LN14@MakeSmelti
$LN13@MakeSmelti:

; 963  : 			{
; 964  : 				iInvalidItemCount++;

  02374	8b 45 f0	 mov	 eax, DWORD PTR _iInvalidItemCount$[ebp]
  02377	83 c0 01	 add	 eax, 1
  0237a	89 45 f0	 mov	 DWORD PTR _iInvalidItemCount$[ebp], eax
$LN14@MakeSmelti:

; 965  : 			}
; 966  : 		}
; 967  : 	}

  0237d	eb 99		 jmp	 SHORT $LN16@MakeSmelti
$LN15@MakeSmelti:

; 968  : 
; 969  : 	if ( iValidItemCount != 1 ||
; 970  : 		 iInvalidItemCount ||
; 971  : 		 iItemPos == -1 )

  0237f	83 7d f4 01	 cmp	 DWORD PTR _iValidItemCount$[ebp], 1
  02383	75 0c		 jne	 SHORT $LN10@MakeSmelti
  02385	83 7d f0 00	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], 0
  02389	75 06		 jne	 SHORT $LN10@MakeSmelti
  0238b	83 7d d8 ff	 cmp	 DWORD PTR _iItemPos$[ebp], -1
  0238f	75 2b		 jne	 SHORT $LN11@MakeSmelti
$LN10@MakeSmelti:

; 972  : 	{
; 973  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  02391	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02395	50		 push	 eax
  02396	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02399	51		 push	 ecx
  0239a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0239d	8b 02		 mov	 eax, DWORD PTR [edx]
  0239f	50		 push	 eax
  023a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  023a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 974  : 		lpObj->ChaosLock = FALSE;

  023a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  023ab	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 975  : 
; 976  : 		return FALSE;

  023b5	33 c0		 xor	 eax, eax
  023b7	e9 5b 02 00 00	 jmp	 $LN19@MakeSmelti
$LN11@MakeSmelti:

; 977  : 	}
; 978  : 
; 979  : 	int JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE;
; 980  : 	BOOL bIsItemNormal = TRUE;

  023bc	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _bIsItemNormal$[ebp], 1

; 981  : 
; 982  : 	if ( lpObj->pChaosBox[iItemPos].IsExtItem() == TRUE )

  023c3	8b 4d d8	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  023c6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  023cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  023cf	03 88 78 0e 00
	00		 add	 ecx, DWORD PTR [eax+3704]
  023d5	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  023da	83 f8 01	 cmp	 eax, 1
  023dd	75 15		 jne	 SHORT $LN9@MakeSmelti

; 983  : 	{
; 984  : 		bIsItemNormal = FALSE;

  023df	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _bIsItemNormal$[ebp], 0

; 985  : 		JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE = this->m_iRateMixSmeltingStoneExt;

  023e6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  023e9	8b 88 38 53 00
	00		 mov	 ecx, DWORD PTR [eax+21304]
  023ef	89 4d d0	 mov	 DWORD PTR _JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE$[ebp], ecx

; 986  : 	}
; 987  : 	else

  023f2	eb 13		 jmp	 SHORT $LN8@MakeSmelti
$LN9@MakeSmelti:

; 988  : 	{
; 989  : 		bIsItemNormal = TRUE;

  023f4	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _bIsItemNormal$[ebp], 1

; 990  : 		JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE = this->m_iRateMixSmeltingStoneNor;

  023fb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  023fe	8b 88 34 53 00
	00		 mov	 ecx, DWORD PTR [eax+21300]
  02404	89 4d d0	 mov	 DWORD PTR _JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE$[ebp], ecx
$LN8@MakeSmelti:

; 991  : 	}
; 992  : 
; 993  : 	iMakeSmeltingStoneMixPrice = this->m_iZenForMixSmeltingStone;

  02407	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0240a	8b 88 3c 53 00
	00		 mov	 ecx, DWORD PTR [eax+21308]
  02410	89 4d ec	 mov	 DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp], ecx

; 994  : 	int iChaosTaxMoney = iMakeSmeltingStoneMixPrice * g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / 100;

  02413	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02416	8b 08		 mov	 ecx, DWORD PTR [eax]
  02418	51		 push	 ecx
  02419	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0241e	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  02423	0f af 45 ec	 imul	 eax, DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp]
  02427	99		 cdq
  02428	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0242d	f7 f9		 idiv	 ecx
  0242f	89 45 c8	 mov	 DWORD PTR _iChaosTaxMoney$[ebp], eax

; 995  : 
; 996  : 	if ( iChaosTaxMoney < 0 )

  02432	83 7d c8 00	 cmp	 DWORD PTR _iChaosTaxMoney$[ebp], 0
  02436	7d 07		 jge	 SHORT $LN7@MakeSmelti

; 997  : 		iChaosTaxMoney = 0;

  02438	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _iChaosTaxMoney$[ebp], 0
$LN7@MakeSmelti:

; 998  : 
; 999  : 	iMakeSmeltingStoneMixPrice += iChaosTaxMoney;

  0243f	8b 45 ec	 mov	 eax, DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp]
  02442	03 45 c8	 add	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  02445	89 45 ec	 mov	 DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp], eax

; 1000 : 
; 1001 : 	if ( iMakeSmeltingStoneMixPrice < 0 )

  02448	79 07		 jns	 SHORT $LN6@MakeSmelti

; 1002 : 		iMakeSmeltingStoneMixPrice = 0;

  0244a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp], 0
$LN6@MakeSmelti:

; 1003 : 
; 1004 : 	if ( lpObj->Money < iMakeSmeltingStoneMixPrice )

  02451	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02454	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0245a	3b 4d ec	 cmp	 ecx, DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp]
  0245d	7d 2f		 jge	 SHORT $LN5@MakeSmelti

; 1005 : 	{
; 1006 : 		pMsg.Result = 2;

  0245f	c6 45 df 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 1007 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  02463	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02467	50		 push	 eax
  02468	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0246b	51		 push	 ecx
  0246c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0246f	8b 02		 mov	 eax, DWORD PTR [edx]
  02471	50		 push	 eax
  02472	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02477	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1008 : 		lpObj->ChaosLock = FALSE;

  0247a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0247d	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 1009 : 
; 1010 : 		return FALSE;

  02487	33 c0		 xor	 eax, eax
  02489	e9 89 01 00 00	 jmp	 $LN19@MakeSmelti
$LN5@MakeSmelti:

; 1011 : 	}
; 1012 : 
; 1013 : 	lpObj->Money -= iMakeSmeltingStoneMixPrice;

  0248e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02491	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02497	2b 4d ec	 sub	 ecx, DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp]
  0249a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0249d	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 1014 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  024a3	8b 45 c8	 mov	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  024a6	50		 push	 eax
  024a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  024ac	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1015 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  024b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  024b4	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  024ba	51		 push	 ecx
  024bb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  024be	8b 02		 mov	 eax, DWORD PTR [edx]
  024c0	50		 push	 eax
  024c1	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  024c6	83 c4 08	 add	 esp, 8

; 1016 : 	g_MixSystem.LogChaosItem(lpObj, "JewelOfHarmony][Smelt Item Mix"); //LogChaosItem(lpObj, "JewelOfHarmony][Smelt Item Mix");

  024c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EOIAKNIF@JewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$AA@
  024ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  024d1	50		 push	 eax
  024d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  024d7	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 1017 : 	LogAddTD("[JewelOfHarmony][Smelt Item Mix] - Mix Start");

  024dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FAMNANK@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@
  024e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  024e7	83 c4 04	 add	 esp, 4

; 1018 : 
; 1019 : 	int iRate = rand() % 100;

  024ea	e8 00 00 00 00	 call	 _rand
  024ef	99		 cdq
  024f0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  024f5	f7 f9		 idiv	 ecx
  024f7	89 55 c4	 mov	 DWORD PTR _iRate$[ebp], edx

; 1020 : 
; 1021 : 	if ( iRate < JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE )

  024fa	8b 45 c4	 mov	 eax, DWORD PTR _iRate$[ebp]
  024fd	3b 45 d0	 cmp	 eax, DWORD PTR _JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE$[ebp]
  02500	0f 8d 96 00 00
	00		 jge	 $LN4@MakeSmelti

; 1022 : 	{
; 1023 : 		int iItemType;
; 1024 : 
; 1025 : 		if ( bIsItemNormal == TRUE )

  02506	83 7d cc 01	 cmp	 DWORD PTR _bIsItemNormal$[ebp], 1
  0250a	75 0b		 jne	 SHORT $LN3@MakeSmelti

; 1026 : 			iItemType = this->JEWEL_OF_HARMONY_SMELT_NOR_ITEMINDEX;

  0250c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0250f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02512	89 4d c0	 mov	 DWORD PTR _iItemType$230446[ebp], ecx

; 1027 : 		else

  02515	eb 09		 jmp	 SHORT $LN2@MakeSmelti
$LN3@MakeSmelti:

; 1028 : 			iItemType = this->JEWEL_OF_HARMONY_SMELT_EXT_ITEMINDEX;

  02517	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0251a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0251d	89 4d c0	 mov	 DWORD PTR _iItemType$230446[ebp], ecx
$LN2@MakeSmelti:

; 1029 : 
; 1030 : 		ItemSerialCreateSend(lpObj->m_Index, 255, 0, 0, iItemType, 0,
; 1031 : 							1, 0, 0, 0, lpObj->m_Index, 0, 0);

  02520	6a 00		 push	 0
  02522	6a 00		 push	 0
  02524	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02527	8b 08		 mov	 ecx, DWORD PTR [eax]
  02529	51		 push	 ecx
  0252a	6a 00		 push	 0
  0252c	6a 00		 push	 0
  0252e	6a 00		 push	 0
  02530	6a 01		 push	 1
  02532	6a 00		 push	 0
  02534	8b 55 c0	 mov	 edx, DWORD PTR _iItemType$230446[ebp]
  02537	52		 push	 edx
  02538	6a 00		 push	 0
  0253a	6a 00		 push	 0
  0253c	68 ff 00 00 00	 push	 255			; 000000ffH
  02541	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02544	8b 08		 mov	 ecx, DWORD PTR [eax]
  02546	51		 push	 ecx
  02547	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0254c	83 c4 34	 add	 esp, 52			; 00000034H

; 1032 : 		gObjInventoryCommit(lpObj->m_Index);

  0254f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02552	8b 08		 mov	 ecx, DWORD PTR [eax]
  02554	51		 push	 ecx
  02555	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0255a	83 c4 04	 add	 esp, 4

; 1033 : 
; 1034 : 		LogAddTD("[JewelOfHarmony][Smelt Item Mix] Smelting Stone Normal[%d] Mix Success [%s][%s], Money(%d-%d) Rate(%d/%d)",
; 1035 : 			bIsItemNormal, lpObj->AccountID, lpObj->Name,
; 1036 : 			lpObj->Money, iMakeSmeltingStoneMixPrice, iRate,
; 1037 : 			JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE);

  0255d	8b 45 d0	 mov	 eax, DWORD PTR _JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE$[ebp]
  02560	50		 push	 eax
  02561	8b 4d c4	 mov	 ecx, DWORD PTR _iRate$[ebp]
  02564	51		 push	 ecx
  02565	8b 55 ec	 mov	 edx, DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp]
  02568	52		 push	 edx
  02569	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0256c	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02572	51		 push	 ecx
  02573	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02576	83 c2 77	 add	 edx, 119		; 00000077H
  02579	52		 push	 edx
  0257a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0257d	83 c0 6c	 add	 eax, 108		; 0000006cH
  02580	50		 push	 eax
  02581	8b 4d cc	 mov	 ecx, DWORD PTR _bIsItemNormal$[ebp]
  02584	51		 push	 ecx
  02585	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JILNDENM@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@
  0258a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02590	83 c4 20	 add	 esp, 32			; 00000020H

; 1038 : 		return TRUE; //season 4.5 add-on

  02593	b8 01 00 00 00	 mov	 eax, 1
  02598	eb 7d		 jmp	 SHORT $LN19@MakeSmelti

; 1039 : 	}
; 1040 : 	else

  0259a	eb 69		 jmp	 SHORT $LN1@MakeSmelti
$LN4@MakeSmelti:

; 1041 : 	{
; 1042 : 		g_MixSystem.ChaosBoxInit(lpObj); //ChaosBoxInit(lpObj);

  0259c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0259f	50		 push	 eax
  025a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  025a5	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 1043 : 		GCUserChaosBoxSend(lpObj, 0);

  025aa	6a 00		 push	 0
  025ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  025af	50		 push	 eax
  025b0	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  025b5	83 c4 08	 add	 esp, 8

; 1044 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  025b8	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  025bc	50		 push	 eax
  025bd	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  025c0	51		 push	 ecx
  025c1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  025c4	8b 02		 mov	 eax, DWORD PTR [edx]
  025c6	50		 push	 eax
  025c7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  025cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1045 : 
; 1046 : 		LogAddTD("[JewelOfHarmony][Smelt Item Mix] Smelting Stone Normal[%d] Mix Fail [%s][%s], Money : %d-%d Rate(%d/%d)",
; 1047 : 			bIsItemNormal, lpObj->AccountID, lpObj->Name,
; 1048 : 			lpObj->Money, iMakeSmeltingStoneMixPrice, iRate,
; 1049 : 			JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE);

  025cf	8b 45 d0	 mov	 eax, DWORD PTR _JEWEL_OF_HARMONY_MAKE_SMELTINGSTONE_RATE$[ebp]
  025d2	50		 push	 eax
  025d3	8b 4d c4	 mov	 ecx, DWORD PTR _iRate$[ebp]
  025d6	51		 push	 ecx
  025d7	8b 55 ec	 mov	 edx, DWORD PTR _iMakeSmeltingStoneMixPrice$[ebp]
  025da	52		 push	 edx
  025db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  025de	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  025e4	51		 push	 ecx
  025e5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  025e8	83 c2 77	 add	 edx, 119		; 00000077H
  025eb	52		 push	 edx
  025ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  025ef	83 c0 6c	 add	 eax, 108		; 0000006cH
  025f2	50		 push	 eax
  025f3	8b 4d cc	 mov	 ecx, DWORD PTR _bIsItemNormal$[ebp]
  025f6	51		 push	 ecx
  025f7	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@PEBNKJPD@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?5Mix?$FN@
  025fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02602	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@MakeSmelti:

; 1050 : 	}
; 1051 : 
; 1052 : 	lpObj->ChaosLock = FALSE;

  02605	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02608	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 1053 : 	return TRUE;

  02612	b8 01 00 00 00	 mov	 eax, 1
$LN19@MakeSmelti:

; 1054 : }

  02617	5f		 pop	 edi
  02618	5e		 pop	 esi
  02619	5b		 pop	 ebx
  0261a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0261d	33 cd		 xor	 ecx, ebp
  0261f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02624	8b e5		 mov	 esp, ebp
  02626	5d		 pop	 ebp
  02627	c2 04 00	 ret	 4
?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
_TEXT	ENDS
PUBLIC	??_C@_0JL@BOGENCJH@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@ ; `string'
PUBLIC	??_C@_0IN@CGDKLAAB@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@ ; `string'
PUBLIC	??_C@_0GD@LODEDAHC@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Alr@ ; `string'
PUBLIC	??_C@_0DK@EJIJHEJO@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Not@ ; `string'
PUBLIC	?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
;	COMDAT ??_C@_0JL@BOGENCJH@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@
CONST	SEGMENT
??_C@_0JL@BOGENCJH@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@ DB '[J'
	DB	'ewelOfHarmony][Smelt Item] Smelt Item Success by Normal[%d] ['
	DB	'%s][%s] Name[%s] Type [%d] Serial [%u] JewelSerial(%u) Rate(%'
	DB	'd/%d) Option(%d) Level(%d->%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IN@CGDKLAAB@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@
CONST	SEGMENT
??_C@_0IN@CGDKLAAB@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@ DB '[J'
	DB	'ewelOfHarmony][Smelt Item] Smelt Item Fail by Normal[%d] [%s]'
	DB	'[%s] Name[%s] Type [%d] Serial [%u] JewelSerial(%u) Rate(%d/%'
	DB	'd) Level(%d->%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@LODEDAHC@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Alr@
CONST	SEGMENT
??_C@_0GD@LODEDAHC@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Alr@ DB '[J'
	DB	'ewelOfHarmony][Smelt Item] Already Have Max OptionLevel [%s]['
	DB	'%s] OptionLevel [%d] ItemLevel [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EJIJHEJO@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Not@
CONST	SEGMENT
??_C@_0DK@EJIJHEJO@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Not@ DB '[J'
	DB	'ewelOfHarmony][Smelt Item] Not Strengthen Item [%s][%s]', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iItemOptionType$230508 = -48				; size = 4
_iItemOptionNewLevel$230507 = -44			; size = 4
_iItemOptionNewLevel$230504 = -40			; size = 4
_bIsNormalSmeltingStone$ = -36				; size = 4
_iRateSmeltingSuccess$ = -32				; size = 4
_iSuccessRate$ = -28					; size = 4
_iValue$230496 = -21					; size = 1
_iNextLevel$230495 = -20				; size = 4
_iItemOptionLevel$ = -16				; size = 4
_pTarget$ = -12						; size = 4
_pSource$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z PROC ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
; _this$ = ecx

; 1059 : {

  02630	55		 push	 ebp
  02631	8b ec		 mov	 ebp, esp
  02633	83 ec 70	 sub	 esp, 112		; 00000070H
  02636	53		 push	 ebx
  02637	56		 push	 esi
  02638	57		 push	 edi
  02639	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1060 : 	if ( this->m_bSystemSmeltingItem == FALSE )

  0263c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0263f	83 b8 28 53 00
	00 00		 cmp	 DWORD PTR [eax+21288], 0
  02646	75 27		 jne	 SHORT $LN20@SmeltItemB

; 1061 : 	{
; 1062 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13,51)), lpObj->m_Index, 1);

  02648	6a 01		 push	 1
  0264a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0264d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0264f	51		 push	 ecx
  02650	68 33 0d 00 00	 push	 3379			; 00000d33H
  02655	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0265a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0265f	50		 push	 eax
  02660	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02665	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1063 : 		return FALSE;

  02668	33 c0		 xor	 eax, eax
  0266a	e9 39 04 00 00	 jmp	 $LN21@SmeltItemB
$LN20@SmeltItemB:

; 1064 : 	}
; 1065 : 
; 1066 : 	if ( source < 0 || source > MAIN_INVENTORY_SIZE-1 )

  0266f	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  02673	7c 09		 jl	 SHORT $LN18@SmeltItemB
  02675	81 7d 0c cb 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 203 ; 000000cbH
  0267c	7e 07		 jle	 SHORT $LN19@SmeltItemB
$LN18@SmeltItemB:

; 1067 : 		return FALSE;

  0267e	33 c0		 xor	 eax, eax
  02680	e9 23 04 00 00	 jmp	 $LN21@SmeltItemB
$LN19@SmeltItemB:

; 1068 : 
; 1069 : 	if ( target < 0 || target > MAIN_INVENTORY_SIZE-1 )

  02685	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  02689	7c 09		 jl	 SHORT $LN16@SmeltItemB
  0268b	81 7d 10 cb 00
	00 00		 cmp	 DWORD PTR _target$[ebp], 203 ; 000000cbH
  02692	7e 07		 jle	 SHORT $LN17@SmeltItemB
$LN16@SmeltItemB:

; 1070 : 		return FALSE;

  02694	33 c0		 xor	 eax, eax
  02696	e9 0d 04 00 00	 jmp	 $LN21@SmeltItemB
$LN17@SmeltItemB:

; 1071 : 
; 1072 : 	if ( lpObj->pInventory[source].IsItem() == FALSE )

  0269b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0269e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  026a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  026a7	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  026ad	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  026b2	85 c0		 test	 eax, eax
  026b4	75 07		 jne	 SHORT $LN15@SmeltItemB

; 1073 : 		return FALSE;

  026b6	33 c0		 xor	 eax, eax
  026b8	e9 eb 03 00 00	 jmp	 $LN21@SmeltItemB
$LN15@SmeltItemB:

; 1074 : 
; 1075 : 	if ( lpObj->pInventory[target].IsItem() == FALSE )

  026bd	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  026c0	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  026c6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  026c9	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  026cf	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  026d4	85 c0		 test	 eax, eax
  026d6	75 07		 jne	 SHORT $LN14@SmeltItemB

; 1076 : 		return FALSE;

  026d8	33 c0		 xor	 eax, eax
  026da	e9 c9 03 00 00	 jmp	 $LN21@SmeltItemB
$LN14@SmeltItemB:

; 1077 : 
; 1078 : 	//if ( lpObj->pInventory[target].m_Level >= 13 )
; 1079 : 	//	return FALSE;
; 1080 : 
; 1081 : 	CItem * pSource = &lpObj->pInventory[source];

  026df	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  026e2	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  026e8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  026eb	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  026f1	89 45 f8	 mov	 DWORD PTR _pSource$[ebp], eax

; 1082 : 	CItem * pTarget = &lpObj->pInventory[target];

  026f4	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  026f7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  026fd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02700	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  02706	89 45 f4	 mov	 DWORD PTR _pTarget$[ebp], eax

; 1083 : 	//int ExAddJoHtoAnc = GetPrivateProfileInt("Items","AddJoHtoAnc",1,"..\\Data\\ExData\\CommonServer.ini");
; 1084 : 	if(!ExAddJoHtoAnc)

  02709	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ExAddJoHtoAnc@@3HA, 0 ; ExAddJoHtoAnc
  02710	75 33		 jne	 SHORT $LN13@SmeltItemB

; 1085 : 	{
; 1086 : 		if ( !this->IsStrengthenByJewelOfHarmony(pTarget)  )

  02712	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02715	50		 push	 eax
  02716	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02719	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  0271e	85 c0		 test	 eax, eax
  02720	75 23		 jne	 SHORT $LN13@SmeltItemB

; 1087 : 		{
; 1088 : 			LogAddTD("[JewelOfHarmony][Smelt Item] Not Strengthen Item [%s][%s]",
; 1089 : 				lpObj->AccountID, lpObj->Name);

  02722	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02725	83 c0 77	 add	 eax, 119		; 00000077H
  02728	50		 push	 eax
  02729	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0272c	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0272f	51		 push	 ecx
  02730	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EJIJHEJO@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Not@
  02735	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0273b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1090 : 	
; 1091 : 			return FALSE;

  0273e	33 c0		 xor	 eax, eax
  02740	e9 63 03 00 00	 jmp	 $LN21@SmeltItemB
$LN13@SmeltItemB:

; 1092 : 		}
; 1093 : 	}
; 1094 : 	int iItemOptionLevel = this->_GetItemOptionLevel(pTarget);

  02745	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02748	50		 push	 eax
  02749	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0274c	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  02751	0f b6 c8	 movzx	 ecx, al
  02754	89 4d f0	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 1095 : 
; 1096 : 	if( iItemOptionLevel >= 13 )	//1.01.00

  02757	83 7d f0 0d	 cmp	 DWORD PTR _iItemOptionLevel$[ebp], 13 ; 0000000dH
  0275b	7c 4f		 jl	 SHORT $LN11@SmeltItemB

; 1097 : 	{
; 1098 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13,41)), lpObj->m_Index, 1);

  0275d	6a 01		 push	 1
  0275f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02762	8b 08		 mov	 ecx, DWORD PTR [eax]
  02764	51		 push	 ecx
  02765	68 29 0d 00 00	 push	 3369			; 00000d29H
  0276a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0276f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02774	50		 push	 eax
  02775	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0277a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1099 : 		LogAddTD("[JewelOfHarmony][Smelt Item] Already Have Max OptionLevel [%s][%s] OptionLevel [%d] ItemLevel [%d]",
; 1100 : 			lpObj->AccountID, lpObj->Name, iItemOptionLevel, pTarget->m_Level);

  0277d	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02780	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  02784	51		 push	 ecx
  02785	8b 55 f0	 mov	 edx, DWORD PTR _iItemOptionLevel$[ebp]
  02788	52		 push	 edx
  02789	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0278c	83 c0 77	 add	 eax, 119		; 00000077H
  0278f	50		 push	 eax
  02790	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02793	83 c1 6c	 add	 ecx, 108		; 0000006cH
  02796	51		 push	 ecx
  02797	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LODEDAHC@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Alr@
  0279c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  027a2	83 c4 14	 add	 esp, 20			; 00000014H

; 1101 : 		return false;

  027a5	33 c0		 xor	 eax, eax
  027a7	e9 fc 02 00 00	 jmp	 $LN21@SmeltItemB
$LN11@SmeltItemB:

; 1102 : 	}
; 1103 : 		
; 1104 : 
; 1105 : 	if ( iItemOptionLevel >= pTarget->m_Level )

  027ac	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  027af	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  027b3	39 4d f0	 cmp	 DWORD PTR _iItemOptionLevel$[ebp], ecx
  027b6	7c 77		 jl	 SHORT $LN10@SmeltItemB

; 1106 : 	{
; 1107 : 		if ( iItemOptionLevel >= 13 )	//Season 5 +15 Items

  027b8	83 7d f0 0d	 cmp	 DWORD PTR _iItemOptionLevel$[ebp], 13 ; 0000000dH
  027bc	7c 22		 jl	 SHORT $LN9@SmeltItemB

; 1108 : 		{
; 1109 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,41)), lpObj->m_Index, 1);

  027be	6a 01		 push	 1
  027c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  027c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  027c5	51		 push	 ecx
  027c6	68 29 0d 00 00	 push	 3369			; 00000d29H
  027cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  027d0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  027d5	50		 push	 eax
  027d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  027db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1110 : 		}
; 1111 : 		else

  027de	eb 20		 jmp	 SHORT $LN8@SmeltItemB
$LN9@SmeltItemB:

; 1112 : 		{
; 1113 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,40)), lpObj->m_Index, 1);

  027e0	6a 01		 push	 1
  027e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  027e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  027e7	51		 push	 ecx
  027e8	68 28 0d 00 00	 push	 3368			; 00000d28H
  027ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  027f2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  027f7	50		 push	 eax
  027f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  027fd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@SmeltItemB:

; 1114 : 		}
; 1115 : 
; 1116 : 		LogAddTD("[JewelOfHarmony][Smelt Item] Already Have Max OptionLevel [%s][%s] OptionLevel [%d] ItemLevel [%d]",
; 1117 : 			lpObj->AccountID, lpObj->Name, iItemOptionLevel, pTarget->m_Level);

  02800	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02803	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  02807	51		 push	 ecx
  02808	8b 55 f0	 mov	 edx, DWORD PTR _iItemOptionLevel$[ebp]
  0280b	52		 push	 edx
  0280c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0280f	83 c0 77	 add	 eax, 119		; 00000077H
  02812	50		 push	 eax
  02813	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02816	83 c1 6c	 add	 ecx, 108		; 0000006cH
  02819	51		 push	 ecx
  0281a	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LODEDAHC@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Alr@
  0281f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02825	83 c4 14	 add	 esp, 20			; 00000014H

; 1118 : 
; 1119 : 		return FALSE;

  02828	33 c0		 xor	 eax, eax
  0282a	e9 79 02 00 00	 jmp	 $LN21@SmeltItemB
$LN10@SmeltItemB:

; 1120 : 	}
; 1121 : 
; 1122 : 	if ( this->_GetItemType(pTarget) == JEWELOFHARMONY_ITEM_TYPE_WEAPON )

  0282f	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02832	50		 push	 eax
  02833	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02836	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  0283b	83 f8 01	 cmp	 eax, 1
  0283e	75 7a		 jne	 SHORT $LN7@SmeltItemB

; 1123 : 	{
; 1124 : 		if ( this->GetItemStrengthenOption(pTarget) == AT_JEWELOFHARMONY_WEAPON_IMPROVE_MINATTACKDAMAGE )

  02840	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02843	50		 push	 eax
  02844	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02847	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  0284c	0f b6 c8	 movzx	 ecx, al
  0284f	83 f9 01	 cmp	 ecx, 1
  02852	75 66		 jne	 SHORT $LN7@SmeltItemB

; 1125 : 		{
; 1126 : 			int iNextLevel = this->_GetItemOptionLevel(pTarget)+1;

  02854	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02857	50		 push	 eax
  02858	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0285b	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  02860	0f b6 c8	 movzx	 ecx, al
  02863	83 c1 01	 add	 ecx, 1
  02866	89 4d ec	 mov	 DWORD PTR _iNextLevel$230495[ebp], ecx

; 1127 : 			BYTE iValue = this->m_itemOption[JEWELOFHARMONY_ITEM_TYPE_WEAPON][AT_JEWELOFHARMONY_WEAPON_IMPROVE_MINATTACKDAMAGE].iItemEffectValue[iNextLevel];

  02869	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0286c	03 45 ec	 add	 eax, DWORD PTR _iNextLevel$230495[ebp]
  0286f	8a 88 2a 16 00
	00		 mov	 cl, BYTE PTR [eax+5674]
  02875	88 4d eb	 mov	 BYTE PTR _iValue$230496[ebp], cl

; 1128 : 
; 1129 : 			if ( (pTarget->m_DamageMin+iValue) > (pTarget->m_DamageMax-1) )

  02878	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0287b	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  0287f	0f b6 55 eb	 movzx	 edx, BYTE PTR _iValue$230496[ebp]
  02883	03 ca		 add	 ecx, edx
  02885	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02888	0f b7 50 12	 movzx	 edx, WORD PTR [eax+18]
  0288c	83 ea 01	 sub	 edx, 1
  0288f	3b ca		 cmp	 ecx, edx
  02891	7e 27		 jle	 SHORT $LN7@SmeltItemB

; 1130 : 			{
; 1131 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13,41)), lpObj->m_Index, 1);

  02893	6a 01		 push	 1
  02895	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02898	8b 08		 mov	 ecx, DWORD PTR [eax]
  0289a	51		 push	 ecx
  0289b	68 29 0d 00 00	 push	 3369			; 00000d29H
  028a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  028a5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  028aa	50		 push	 eax
  028ab	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  028b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1132 : 				return FALSE;

  028b3	33 c0		 xor	 eax, eax
  028b5	e9 ee 01 00 00	 jmp	 $LN21@SmeltItemB
$LN7@SmeltItemB:

; 1133 : 			}
; 1134 : 		}
; 1135 : 	}
; 1136 : 
; 1137 : 	int iSuccessRate = rand() % 100;

  028ba	e8 00 00 00 00	 call	 _rand
  028bf	99		 cdq
  028c0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  028c5	f7 f9		 idiv	 ecx
  028c7	89 55 e4	 mov	 DWORD PTR _iSuccessRate$[ebp], edx

; 1138 : 	int iRateSmeltingSuccess = 0;

  028ca	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iRateSmeltingSuccess$[ebp], 0

; 1139 : 	BOOL bIsNormalSmeltingStone = this->_IsJewelOfHarmonySmeltingItemNor(pSource->m_Type);

  028d1	8b 45 f8	 mov	 eax, DWORD PTR _pSource$[ebp]
  028d4	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  028d8	51		 push	 ecx
  028d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  028dc	e8 00 00 00 00	 call	 ?_IsJewelOfHarmonySmeltingItemNor@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::_IsJewelOfHarmonySmeltingItemNor
  028e1	89 45 dc	 mov	 DWORD PTR _bIsNormalSmeltingStone$[ebp], eax

; 1140 : 
; 1141 : 	if ( bIsNormalSmeltingStone == TRUE )

  028e4	83 7d dc 01	 cmp	 DWORD PTR _bIsNormalSmeltingStone$[ebp], 1
  028e8	75 0e		 jne	 SHORT $LN4@SmeltItemB

; 1142 : 		iRateSmeltingSuccess = this->m_iRateSmeltingSuccessNor;

  028ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  028ed	8b 88 44 53 00
	00		 mov	 ecx, DWORD PTR [eax+21316]
  028f3	89 4d e0	 mov	 DWORD PTR _iRateSmeltingSuccess$[ebp], ecx

; 1143 : 	else

  028f6	eb 0c		 jmp	 SHORT $LN3@SmeltItemB
$LN4@SmeltItemB:

; 1144 : 		iRateSmeltingSuccess = this->m_iRateSmeltingSuccessExt;

  028f8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  028fb	8b 88 48 53 00
	00		 mov	 ecx, DWORD PTR [eax+21320]
  02901	89 4d e0	 mov	 DWORD PTR _iRateSmeltingSuccess$[ebp], ecx
$LN3@SmeltItemB:

; 1145 : 
; 1146 : 	if ( iSuccessRate >= iRateSmeltingSuccess )

  02904	8b 45 e4	 mov	 eax, DWORD PTR _iSuccessRate$[ebp]
  02907	3b 45 e0	 cmp	 eax, DWORD PTR _iRateSmeltingSuccess$[ebp]
  0290a	0f 8c c4 00 00
	00		 jl	 $LN2@SmeltItemB

; 1147 : 	{
; 1148 : 		int iItemOptionNewLevel = _GetItemOptionRequireLevel(pTarget);

  02910	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02913	50		 push	 eax
  02914	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02917	e8 00 00 00 00	 call	 ?_GetItemOptionRequireLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionRequireLevel
  0291c	0f b6 c8	 movzx	 ecx, al
  0291f	89 4d d8	 mov	 DWORD PTR _iItemOptionNewLevel$230504[ebp], ecx

; 1149 : 		pTarget->m_JewelOfHarmonyOption = pTarget->m_JewelOfHarmonyOption & 0xF0;

  02922	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02925	0f b6 88 c4 00
	00 00		 movzx	 ecx, BYTE PTR [eax+196]
  0292c	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  02932	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  02935	88 8a c4 00 00
	00		 mov	 BYTE PTR [edx+196], cl

; 1150 : 		pTarget->m_JewelOfHarmonyOption |= iItemOptionNewLevel & 0x0F;

  0293b	8b 45 d8	 mov	 eax, DWORD PTR _iItemOptionNewLevel$230504[ebp]
  0293e	83 e0 0f	 and	 eax, 15			; 0000000fH
  02941	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  02944	0f b6 91 c4 00
	00 00		 movzx	 edx, BYTE PTR [ecx+196]
  0294b	0b d0		 or	 edx, eax
  0294d	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02950	88 90 c4 00 00
	00		 mov	 BYTE PTR [eax+196], dl

; 1151 : 		this->ShowStrengthenOption(pTarget);

  02956	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02959	50		 push	 eax
  0295a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0295d	e8 00 00 00 00	 call	 ?ShowStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::ShowStrengthenOption

; 1152 : 
; 1153 : 		LogAddTD("[JewelOfHarmony][Smelt Item] Smelt Item Fail by Normal[%d] [%s][%s] Name[%s] Type [%d] Serial [%u] JewelSerial(%u) Rate(%d/%d) Level(%d->%d)",
; 1154 : 			bIsNormalSmeltingStone, lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 1155 : 			pTarget->m_Number, pSource->m_Number, iSuccessRate, iRateSmeltingSuccess, iItemOptionLevel, iItemOptionNewLevel);

  02962	8b 45 d8	 mov	 eax, DWORD PTR _iItemOptionNewLevel$230504[ebp]
  02965	50		 push	 eax
  02966	8b 4d f0	 mov	 ecx, DWORD PTR _iItemOptionLevel$[ebp]
  02969	51		 push	 ecx
  0296a	8b 55 e0	 mov	 edx, DWORD PTR _iRateSmeltingSuccess$[ebp]
  0296d	52		 push	 edx
  0296e	8b 45 e4	 mov	 eax, DWORD PTR _iSuccessRate$[ebp]
  02971	50		 push	 eax
  02972	8b 4d f8	 mov	 ecx, DWORD PTR _pSource$[ebp]
  02975	8b 11		 mov	 edx, DWORD PTR [ecx]
  02977	52		 push	 edx
  02978	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0297b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0297d	51		 push	 ecx
  0297e	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  02981	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  02985	50		 push	 eax
  02986	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  02989	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0298e	50		 push	 eax
  0298f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02992	83 c1 77	 add	 ecx, 119		; 00000077H
  02995	51		 push	 ecx
  02996	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02999	83 c2 6c	 add	 edx, 108		; 0000006cH
  0299c	52		 push	 edx
  0299d	8b 45 dc	 mov	 eax, DWORD PTR _bIsNormalSmeltingStone$[ebp]
  029a0	50		 push	 eax
  029a1	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@CGDKLAAB@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@
  029a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  029ac	83 c4 30	 add	 esp, 48			; 00000030H

; 1156 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 47)), lpObj->m_Index, 1);

  029af	6a 01		 push	 1
  029b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  029b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  029b6	51		 push	 ecx
  029b7	68 2f 0d 00 00	 push	 3375			; 00000d2fH
  029bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  029c1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  029c6	50		 push	 eax
  029c7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  029cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1157 : 	}
; 1158 : 	else

  029cf	e9 cf 00 00 00	 jmp	 $LN1@SmeltItemB
$LN2@SmeltItemB:

; 1159 : 	{
; 1160 : 		int iItemOptionNewLevel = iItemOptionLevel+1;

  029d4	8b 45 f0	 mov	 eax, DWORD PTR _iItemOptionLevel$[ebp]
  029d7	83 c0 01	 add	 eax, 1
  029da	89 45 d4	 mov	 DWORD PTR _iItemOptionNewLevel$230507[ebp], eax

; 1161 : 		pTarget->m_JewelOfHarmonyOption = pTarget->m_JewelOfHarmonyOption & 0xF0;

  029dd	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  029e0	0f b6 88 c4 00
	00 00		 movzx	 ecx, BYTE PTR [eax+196]
  029e7	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  029ed	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  029f0	88 8a c4 00 00
	00		 mov	 BYTE PTR [edx+196], cl

; 1162 : 		pTarget->m_JewelOfHarmonyOption |= iItemOptionNewLevel & 0x0F;

  029f6	8b 45 d4	 mov	 eax, DWORD PTR _iItemOptionNewLevel$230507[ebp]
  029f9	83 e0 0f	 and	 eax, 15			; 0000000fH
  029fc	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  029ff	0f b6 91 c4 00
	00 00		 movzx	 edx, BYTE PTR [ecx+196]
  02a06	0b d0		 or	 edx, eax
  02a08	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02a0b	88 90 c4 00 00
	00		 mov	 BYTE PTR [eax+196], dl

; 1163 : 		this->ShowStrengthenOption(pTarget);

  02a11	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02a14	50		 push	 eax
  02a15	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a18	e8 00 00 00 00	 call	 ?ShowStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::ShowStrengthenOption

; 1164 : 		int iItemOptionType = this->GetItemStrengthenOption(pTarget); //loc12

  02a1d	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02a20	50		 push	 eax
  02a21	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a24	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  02a29	0f b6 c8	 movzx	 ecx, al
  02a2c	89 4d d0	 mov	 DWORD PTR _iItemOptionType$230508[ebp], ecx

; 1165 : 
; 1166 : 		LogAddTD("[JewelOfHarmony][Smelt Item] Smelt Item Success by Normal[%d] [%s][%s] Name[%s] Type [%d] Serial [%u] JewelSerial(%u) Rate(%d/%d) Option(%d) Level(%d->%d)",
; 1167 : 			bIsNormalSmeltingStone, lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 1168 : 			pTarget->m_Number, pSource->m_Number, iSuccessRate, iRateSmeltingSuccess, iItemOptionType, iItemOptionLevel, iItemOptionNewLevel & 0x0F);

  02a2f	8b 45 d4	 mov	 eax, DWORD PTR _iItemOptionNewLevel$230507[ebp]
  02a32	83 e0 0f	 and	 eax, 15			; 0000000fH
  02a35	50		 push	 eax
  02a36	8b 4d f0	 mov	 ecx, DWORD PTR _iItemOptionLevel$[ebp]
  02a39	51		 push	 ecx
  02a3a	8b 55 d0	 mov	 edx, DWORD PTR _iItemOptionType$230508[ebp]
  02a3d	52		 push	 edx
  02a3e	8b 45 e0	 mov	 eax, DWORD PTR _iRateSmeltingSuccess$[ebp]
  02a41	50		 push	 eax
  02a42	8b 4d e4	 mov	 ecx, DWORD PTR _iSuccessRate$[ebp]
  02a45	51		 push	 ecx
  02a46	8b 55 f8	 mov	 edx, DWORD PTR _pSource$[ebp]
  02a49	8b 02		 mov	 eax, DWORD PTR [edx]
  02a4b	50		 push	 eax
  02a4c	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  02a4f	8b 11		 mov	 edx, DWORD PTR [ecx]
  02a51	52		 push	 edx
  02a52	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  02a55	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  02a59	51		 push	 ecx
  02a5a	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  02a5d	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  02a62	50		 push	 eax
  02a63	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02a66	83 c2 77	 add	 edx, 119		; 00000077H
  02a69	52		 push	 edx
  02a6a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02a6d	83 c0 6c	 add	 eax, 108		; 0000006cH
  02a70	50		 push	 eax
  02a71	8b 4d dc	 mov	 ecx, DWORD PTR _bIsNormalSmeltingStone$[ebp]
  02a74	51		 push	 ecx
  02a75	68 00 00 00 00	 push	 OFFSET ??_C@_0JL@BOGENCJH@?$FLJewelOfHarmony?$FN?$FLSmelt?5Item?$FN?5Sme@
  02a7a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02a80	83 c4 34	 add	 esp, 52			; 00000034H

; 1169 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 48)), lpObj->m_Index, 1);

  02a83	6a 01		 push	 1
  02a85	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02a88	8b 08		 mov	 ecx, DWORD PTR [eax]
  02a8a	51		 push	 ecx
  02a8b	68 30 0d 00 00	 push	 3376			; 00000d30H
  02a90	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02a95	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02a9a	50		 push	 eax
  02a9b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02aa0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SmeltItemB:

; 1170 : 	}
; 1171 : 
; 1172 : 	return TRUE;

  02aa3	b8 01 00 00 00	 mov	 eax, 1
$LN21@SmeltItemB:

; 1173 : }

  02aa8	5f		 pop	 edi
  02aa9	5e		 pop	 esi
  02aaa	5b		 pop	 ebx
  02aab	8b e5		 mov	 esp, ebp
  02aad	5d		 pop	 ebp
  02aae	c2 0c 00	 ret	 12			; 0000000cH
?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ENDP ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
_TEXT	ENDS
PUBLIC	?_GetZenForRestoreItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetZenForRestoreItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iZenForRestore$ = -20					; size = 4
_iItemOptionLevel$ = -16				; size = 4
_iItemOptionType$ = -12					; size = 4
_iItemType$ = -8					; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?_GetZenForRestoreItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z PROC ; CJewelOfHarmonySystem::_GetZenForRestoreItem
; _this$ = ecx

; 1177 : {

  02ac0	55		 push	 ebp
  02ac1	8b ec		 mov	 ebp, esp
  02ac3	83 ec 54	 sub	 esp, 84			; 00000054H
  02ac6	53		 push	 ebx
  02ac7	56		 push	 esi
  02ac8	57		 push	 edi
  02ac9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1178 : 	int iItemType = this->_GetItemType(pItem);

  02acc	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  02acf	50		 push	 eax
  02ad0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02ad3	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  02ad8	89 45 f8	 mov	 DWORD PTR _iItemType$[ebp], eax

; 1179 : 
; 1180 : 	if ( iItemType == JEWELOFHARMONY_ITEM_TYPE_NULL )

  02adb	83 7d f8 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  02adf	75 05		 jne	 SHORT $LN3@GetZenForR

; 1181 : 		return -1;

  02ae1	83 c8 ff	 or	 eax, -1
  02ae4	eb 69		 jmp	 SHORT $LN4@GetZenForR
$LN3@GetZenForR:

; 1182 : 
; 1183 : 	int iItemOptionType = AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM;

  02ae6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iItemOptionType$[ebp], 0

; 1184 : 	iItemOptionType = this->GetItemStrengthenOption(pItem);

  02aed	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  02af0	50		 push	 eax
  02af1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02af4	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  02af9	0f b6 c8	 movzx	 ecx, al
  02afc	89 4d f4	 mov	 DWORD PTR _iItemOptionType$[ebp], ecx

; 1185 : 
; 1186 : 	if ( iItemOptionType == AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM )

  02aff	83 7d f4 00	 cmp	 DWORD PTR _iItemOptionType$[ebp], 0
  02b03	75 05		 jne	 SHORT $LN2@GetZenForR

; 1187 : 		return -1;

  02b05	83 c8 ff	 or	 eax, -1
  02b08	eb 45		 jmp	 SHORT $LN4@GetZenForR
$LN2@GetZenForR:

; 1188 : 
; 1189 : 	int iItemOptionLevel = this->_GetItemOptionLevel(pItem);

  02b0a	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  02b0d	50		 push	 eax
  02b0e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b11	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  02b16	0f b6 c8	 movzx	 ecx, al
  02b19	89 4d f0	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 1190 : 
; 1191 : 	if ( iItemOptionLevel >= MAX_JOH_ITEM_OPTION )

  02b1c	83 7d f0 0e	 cmp	 DWORD PTR _iItemOptionLevel$[ebp], 14 ; 0000000eH
  02b20	7c 05		 jl	 SHORT $LN1@GetZenForR

; 1192 : 		return -1;

  02b22	83 c8 ff	 or	 eax, -1
  02b25	eb 28		 jmp	 SHORT $LN4@GetZenForR
$LN1@GetZenForR:

; 1193 : 
; 1194 : 	int iZenForRestore = this->m_itemOption[iItemType][iItemOptionType].iZenForRestore[iItemOptionLevel];

  02b27	8b 45 f8	 mov	 eax, DWORD PTR _iItemType$[ebp]
  02b2a	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  02b30	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b33	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  02b37	8b 45 f4	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  02b3a	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  02b40	03 d0		 add	 edx, eax
  02b42	8b 4d f0	 mov	 ecx, DWORD PTR _iItemOptionLevel$[ebp]
  02b45	8b 54 8a 14	 mov	 edx, DWORD PTR [edx+ecx*4+20]
  02b49	89 55 ec	 mov	 DWORD PTR _iZenForRestore$[ebp], edx

; 1195 : 	return iZenForRestore;

  02b4c	8b 45 ec	 mov	 eax, DWORD PTR _iZenForRestore$[ebp]
$LN4@GetZenForR:

; 1196 : }

  02b4f	5f		 pop	 edi
  02b50	5e		 pop	 esi
  02b51	5b		 pop	 ebx
  02b52	8b e5		 mov	 esp, ebp
  02b54	5d		 pop	 ebp
  02b55	c2 04 00	 ret	 4
?_GetZenForRestoreItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ENDP ; CJewelOfHarmonySystem::_GetZenForRestoreItem
_TEXT	ENDS
PUBLIC	??_C@_0IP@PGENAODE@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5R@ ; `string'
PUBLIC	??_C@_0CP@EJFBEOFL@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5?9@ ; `string'
PUBLIC	??_C@_0BN@GBDPAFPP@JewelOfHarmony?$FN?$FLRestore?5Item?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::RestoreStrengthenItem
;	COMDAT ??_C@_0IP@PGENAODE@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5R@
CONST	SEGMENT
??_C@_0IP@PGENAODE@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5R@ DB '[J'
	DB	'ewelOfHarmony][Restore Item] Restore Strengthened Item [%s][%'
	DB	's] Name[%s] ItemType[%d] Serial[%u] OptionType[%d] OptionLeve'
	DB	'l [%d] Money %d-%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EJFBEOFL@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5?9@
CONST	SEGMENT
??_C@_0CP@EJFBEOFL@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5?9@ DB '['
	DB	'JewelOfHarmony][Restore Item] - Restore Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GBDPAFPP@JewelOfHarmony?$FN?$FLRestore?5Item?$AA@
CONST	SEGMENT
??_C@_0BN@GBDPAFPP@JewelOfHarmony?$FN?$FLRestore?5Item?$AA@ DB 'JewelOfHa'
	DB	'rmony][Restore Item', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iChaosTaxMoney$ = -56					; size = 4
_JEWEL_OF_HARMONY_RETORE_NEEDZEN$ = -52			; size = 4
_iItemOptionLevel$ = -48				; size = 4
_iItemOption$ = -44					; size = 4
_n$230531 = -40						; size = 4
_pItem$ = -36						; size = 4
_iInvalidItemCount$ = -32				; size = 4
_iStrengtenItemCount$ = -28				; size = 4
_pMsg$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CJewelOfHarmonySystem::RestoreStrengthenItem
; _this$ = ecx

; 1200 : {

  02b60	55		 push	 ebp
  02b61	8b ec		 mov	 ebp, esp
  02b63	83 ec 78	 sub	 esp, 120		; 00000078H
  02b66	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02b6b	33 c5		 xor	 eax, ebp
  02b6d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02b70	53		 push	 ebx
  02b71	56		 push	 esi
  02b72	57		 push	 edi
  02b73	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1201 : 	if ( this->m_bSystemRestoreStrengthen != TRUE )

  02b76	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02b79	83 b8 20 53 00
	00 01		 cmp	 DWORD PTR [eax+21280], 1
  02b80	74 2a		 je	 SHORT $LN11@RestoreStr

; 1202 : 	{
; 1203 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13,54)), lpObj->m_Index, 1);

  02b82	6a 01		 push	 1
  02b84	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02b87	8b 08		 mov	 ecx, DWORD PTR [eax]
  02b89	51		 push	 ecx
  02b8a	68 36 0d 00 00	 push	 3382			; 00000d36H
  02b8f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02b94	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02b99	50		 push	 eax
  02b9a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02b9f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1204 : 		return TRUE;

  02ba2	b8 01 00 00 00	 mov	 eax, 1
  02ba7	e9 98 02 00 00	 jmp	 $LN12@RestoreStr
$LN11@RestoreStr:

; 1205 : 	}
; 1206 : 
; 1207 : 	lpObj->ChaosLock = TRUE;

  02bac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02baf	c7 80 88 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3720], 1

; 1208 : 
; 1209 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1210 : 
; 1211 : 	PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof(pMsg));

  02bb9	6a 10		 push	 16			; 00000010H
  02bbb	68 86 00 00 00	 push	 134			; 00000086H
  02bc0	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  02bc3	50		 push	 eax
  02bc4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  02bc9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1212 : 	pMsg.Result = 0;

  02bcc	c6 45 eb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1213 : 	int iStrengtenItemCount = 0;

  02bd0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iStrengtenItemCount$[ebp], 0

; 1214 : 	int iInvalidItemCount = 0;

  02bd7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iInvalidItemCount$[ebp], 0

; 1215 : 	CItem * pItem = NULL;

  02bde	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pItem$[ebp], 0

; 1216 : 
; 1217 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  02be5	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$230531[ebp], 0
  02bec	eb 09		 jmp	 SHORT $LN10@RestoreStr
$LN9@RestoreStr:
  02bee	8b 45 d8	 mov	 eax, DWORD PTR _n$230531[ebp]
  02bf1	83 c0 01	 add	 eax, 1
  02bf4	89 45 d8	 mov	 DWORD PTR _n$230531[ebp], eax
$LN10@RestoreStr:
  02bf7	83 7d d8 20	 cmp	 DWORD PTR _n$230531[ebp], 32 ; 00000020H
  02bfb	7d 5c		 jge	 SHORT $LN8@RestoreStr

; 1218 : 	{
; 1219 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  02bfd	8b 4d d8	 mov	 ecx, DWORD PTR _n$230531[ebp]
  02c00	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  02c06	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02c09	03 88 78 0e 00
	00		 add	 ecx, DWORD PTR [eax+3704]
  02c0f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  02c14	83 f8 01	 cmp	 eax, 1
  02c17	75 3e		 jne	 SHORT $LN7@RestoreStr

; 1220 : 		{
; 1221 : 			if ( this->IsStrengthenByJewelOfHarmony(&lpObj->pChaosBox[n]) == TRUE )

  02c19	8b 45 d8	 mov	 eax, DWORD PTR _n$230531[ebp]
  02c1c	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  02c22	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02c25	03 81 78 0e 00
	00		 add	 eax, DWORD PTR [ecx+3704]
  02c2b	50		 push	 eax
  02c2c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c2f	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  02c34	83 f8 01	 cmp	 eax, 1
  02c37	75 1e		 jne	 SHORT $LN7@RestoreStr

; 1222 : 			{
; 1223 : 				iStrengtenItemCount++;

  02c39	8b 45 e4	 mov	 eax, DWORD PTR _iStrengtenItemCount$[ebp]
  02c3c	83 c0 01	 add	 eax, 1
  02c3f	89 45 e4	 mov	 DWORD PTR _iStrengtenItemCount$[ebp], eax

; 1224 : 				pItem = &lpObj->pChaosBox[n];

  02c42	8b 45 d8	 mov	 eax, DWORD PTR _n$230531[ebp]
  02c45	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  02c4b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02c4e	03 81 78 0e 00
	00		 add	 eax, DWORD PTR [ecx+3704]
  02c54	89 45 dc	 mov	 DWORD PTR _pItem$[ebp], eax
$LN7@RestoreStr:

; 1225 : 			}
; 1226 : 		}
; 1227 : 	}

  02c57	eb 95		 jmp	 SHORT $LN9@RestoreStr
$LN8@RestoreStr:

; 1228 : 
; 1229 : 	if ( iStrengtenItemCount != 1 )

  02c59	83 7d e4 01	 cmp	 DWORD PTR _iStrengtenItemCount$[ebp], 1
  02c5d	74 2b		 je	 SHORT $LN5@RestoreStr

; 1230 : 	{
; 1231 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  02c5f	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02c63	50		 push	 eax
  02c64	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02c67	51		 push	 ecx
  02c68	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02c6b	8b 02		 mov	 eax, DWORD PTR [edx]
  02c6d	50		 push	 eax
  02c6e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02c73	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 : 		lpObj->ChaosLock = FALSE;

  02c76	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02c79	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 1233 : 
; 1234 : 		return FALSE;

  02c83	33 c0		 xor	 eax, eax
  02c85	e9 ba 01 00 00	 jmp	 $LN12@RestoreStr
$LN5@RestoreStr:

; 1235 : 	}
; 1236 : 	
; 1237 : 	int iItemOption = this->GetItemStrengthenOption(pItem);

  02c8a	8b 45 dc	 mov	 eax, DWORD PTR _pItem$[ebp]
  02c8d	50		 push	 eax
  02c8e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c91	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  02c96	0f b6 c8	 movzx	 ecx, al
  02c99	89 4d d4	 mov	 DWORD PTR _iItemOption$[ebp], ecx

; 1238 : 	int iItemOptionLevel = this->_GetItemOptionLevel(pItem);

  02c9c	8b 45 dc	 mov	 eax, DWORD PTR _pItem$[ebp]
  02c9f	50		 push	 eax
  02ca0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02ca3	e8 00 00 00 00	 call	 ?_GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemOptionLevel
  02ca8	0f b6 c8	 movzx	 ecx, al
  02cab	89 4d d0	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 1239 : 	int JEWEL_OF_HARMONY_RETORE_NEEDZEN = this->_GetZenForRestoreItem(pItem);

  02cae	8b 45 dc	 mov	 eax, DWORD PTR _pItem$[ebp]
  02cb1	50		 push	 eax
  02cb2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02cb5	e8 00 00 00 00	 call	 ?_GetZenForRestoreItem@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetZenForRestoreItem
  02cba	89 45 cc	 mov	 DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp], eax

; 1240 : 
; 1241 : 	if ( JEWEL_OF_HARMONY_RETORE_NEEDZEN < 0 ) 

  02cbd	83 7d cc 00	 cmp	 DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp], 0
  02cc1	7d 2b		 jge	 SHORT $LN4@RestoreStr

; 1242 : 	{
; 1243 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  02cc3	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02cc7	50		 push	 eax
  02cc8	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02ccb	51		 push	 ecx
  02ccc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02ccf	8b 02		 mov	 eax, DWORD PTR [edx]
  02cd1	50		 push	 eax
  02cd2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02cd7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1244 : 		lpObj->ChaosLock = FALSE;

  02cda	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02cdd	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 1245 : 
; 1246 : 		return FALSE;

  02ce7	33 c0		 xor	 eax, eax
  02ce9	e9 56 01 00 00	 jmp	 $LN12@RestoreStr
$LN4@RestoreStr:

; 1247 : 	}
; 1248 : 
; 1249 : 	int iChaosTaxMoney = JEWEL_OF_HARMONY_RETORE_NEEDZEN * g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / 100;

  02cee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02cf1	8b 08		 mov	 ecx, DWORD PTR [eax]
  02cf3	51		 push	 ecx
  02cf4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  02cf9	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  02cfe	0f af 45 cc	 imul	 eax, DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp]
  02d02	99		 cdq
  02d03	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  02d08	f7 f9		 idiv	 ecx
  02d0a	89 45 c8	 mov	 DWORD PTR _iChaosTaxMoney$[ebp], eax

; 1250 : 
; 1251 : 	if ( iChaosTaxMoney < 0 )

  02d0d	83 7d c8 00	 cmp	 DWORD PTR _iChaosTaxMoney$[ebp], 0
  02d11	7d 07		 jge	 SHORT $LN3@RestoreStr

; 1252 : 		iChaosTaxMoney = 0;

  02d13	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _iChaosTaxMoney$[ebp], 0
$LN3@RestoreStr:

; 1253 : 
; 1254 : 	JEWEL_OF_HARMONY_RETORE_NEEDZEN += iChaosTaxMoney;

  02d1a	8b 45 cc	 mov	 eax, DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp]
  02d1d	03 45 c8	 add	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  02d20	89 45 cc	 mov	 DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp], eax

; 1255 : 
; 1256 : 	if ( JEWEL_OF_HARMONY_RETORE_NEEDZEN < 0 )

  02d23	79 07		 jns	 SHORT $LN2@RestoreStr

; 1257 : 		JEWEL_OF_HARMONY_RETORE_NEEDZEN = 0;

  02d25	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp], 0
$LN2@RestoreStr:

; 1258 : 
; 1259 : 	if ( lpObj->Money < JEWEL_OF_HARMONY_RETORE_NEEDZEN )

  02d2c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02d2f	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02d35	3b 4d cc	 cmp	 ecx, DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp]
  02d38	7d 2f		 jge	 SHORT $LN1@RestoreStr

; 1260 : 	{
; 1261 : 		pMsg.Result = 2;

  02d3a	c6 45 eb 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 1262 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  02d3e	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02d42	50		 push	 eax
  02d43	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02d46	51		 push	 ecx
  02d47	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02d4a	8b 02		 mov	 eax, DWORD PTR [edx]
  02d4c	50		 push	 eax
  02d4d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02d52	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1263 : 		lpObj->ChaosLock = FALSE;

  02d55	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02d58	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 1264 : 
; 1265 : 		return FALSE;

  02d62	33 c0		 xor	 eax, eax
  02d64	e9 db 00 00 00	 jmp	 $LN12@RestoreStr
$LN1@RestoreStr:

; 1266 : 	}
; 1267 : 
; 1268 : 	lpObj->Money -= JEWEL_OF_HARMONY_RETORE_NEEDZEN;

  02d69	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02d6c	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02d72	2b 4d cc	 sub	 ecx, DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp]
  02d75	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02d78	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 1269 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  02d7e	8b 45 c8	 mov	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  02d81	50		 push	 eax
  02d82	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  02d87	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1270 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  02d8c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02d8f	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02d95	51		 push	 ecx
  02d96	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02d99	8b 02		 mov	 eax, DWORD PTR [edx]
  02d9b	50		 push	 eax
  02d9c	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  02da1	83 c4 08	 add	 esp, 8

; 1271 : 	g_MixSystem.LogChaosItem(lpObj, "JewelOfHarmony][Restore Item"); //LogChaosItem(lpObj, "JewelOfHarmony][Restore Item");

  02da4	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GBDPAFPP@JewelOfHarmony?$FN?$FLRestore?5Item?$AA@
  02da9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02dac	50		 push	 eax
  02dad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  02db2	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 1272 : 	LogAddTD("[JewelOfHarmony][Restore Item] - Restore Start");

  02db7	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@EJFBEOFL@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5?9@
  02dbc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02dc2	83 c4 04	 add	 esp, 4

; 1273 : 
; 1274 : 	LogAddTD("[JewelOfHarmony][Restore Item] Restore Strengthened Item [%s][%s] Name[%s] ItemType[%d] Serial[%u] OptionType[%d] OptionLevel [%d] Money %d-%d",
; 1275 : 		lpObj->AccountID, lpObj->Name, pItem->GetName(), pItem->m_Type,
; 1276 : 		pItem->m_Number, iItemOption, iItemOptionLevel, 
; 1277 : 		lpObj->Money, JEWEL_OF_HARMONY_RETORE_NEEDZEN);

  02dc5	8b 45 cc	 mov	 eax, DWORD PTR _JEWEL_OF_HARMONY_RETORE_NEEDZEN$[ebp]
  02dc8	50		 push	 eax
  02dc9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02dcc	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  02dd2	52		 push	 edx
  02dd3	8b 45 d0	 mov	 eax, DWORD PTR _iItemOptionLevel$[ebp]
  02dd6	50		 push	 eax
  02dd7	8b 4d d4	 mov	 ecx, DWORD PTR _iItemOption$[ebp]
  02dda	51		 push	 ecx
  02ddb	8b 55 dc	 mov	 edx, DWORD PTR _pItem$[ebp]
  02dde	8b 02		 mov	 eax, DWORD PTR [edx]
  02de0	50		 push	 eax
  02de1	8b 4d dc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  02de4	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  02de8	52		 push	 edx
  02de9	8b 4d dc	 mov	 ecx, DWORD PTR _pItem$[ebp]
  02dec	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  02df1	50		 push	 eax
  02df2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02df5	83 c0 77	 add	 eax, 119		; 00000077H
  02df8	50		 push	 eax
  02df9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02dfc	83 c1 6c	 add	 ecx, 108		; 0000006cH
  02dff	51		 push	 ecx
  02e00	68 00 00 00 00	 push	 OFFSET ??_C@_0IP@PGENAODE@?$FLJewelOfHarmony?$FN?$FLRestore?5Item?$FN?5R@
  02e05	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02e0b	83 c4 28	 add	 esp, 40			; 00000028H

; 1278 : 
; 1279 : 	pItem->m_JewelOfHarmonyOption = 0;

  02e0e	8b 45 dc	 mov	 eax, DWORD PTR _pItem$[ebp]
  02e11	c6 80 c4 00 00
	00 00		 mov	 BYTE PTR [eax+196], 0

; 1280 : 	GCUserChaosBoxSend(lpObj, 0);

  02e18	6a 00		 push	 0
  02e1a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02e1d	50		 push	 eax
  02e1e	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  02e23	83 c4 08	 add	 esp, 8

; 1281 : 	this->ShowStrengthenOption(pItem);

  02e26	8b 45 dc	 mov	 eax, DWORD PTR _pItem$[ebp]
  02e29	50		 push	 eax
  02e2a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02e2d	e8 00 00 00 00	 call	 ?ShowStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::ShowStrengthenOption

; 1282 : 	lpObj->ChaosLock = FALSE;

  02e32	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02e35	c7 80 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3720], 0

; 1283 : 
; 1284 : 	return TRUE;

  02e3f	b8 01 00 00 00	 mov	 eax, 1
$LN12@RestoreStr:

; 1285 : }

  02e44	5f		 pop	 edi
  02e45	5e		 pop	 esi
  02e46	5b		 pop	 ebx
  02e47	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02e4a	33 cd		 xor	 ecx, ebp
  02e4c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02e51	8b e5		 mov	 esp, ebp
  02e53	5d		 pop	 ebp
  02e54	c2 04 00	 ret	 4
?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CJewelOfHarmonySystem::RestoreStrengthenItem
_TEXT	ENDS
PUBLIC	??_C@_0CI@BLEFGBBC@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@ ; `string'
PUBLIC	??_C@_0ED@FEDKDEDK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Alre@ ; `string'
PUBLIC	??_C@_0DM@ODMCBHME@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?NpcJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CJewelOfHarmonySystem::NpcJewelOfHarmony
EXTRN	?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z:PROC		; GCAnsCsMapSvrTaxInfo
EXTRN	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?gObjInventoryTrans@@YAHH@Z:PROC		; gObjInventoryTrans
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?bCanChaosBox@@3HA:DWORD			; bCanChaosBox
EXTRN	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z:PROC ; ChatTargetSend
;	COMDAT ??_C@_0CI@BLEFGBBC@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@
CONST	SEGMENT
??_C@_0CI@BLEFGBBC@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@ DB '['
	DB	'JewelOfHarmony][%s][%s] Open Chaos Box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FEDKDEDK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Alre@
CONST	SEGMENT
??_C@_0ED@FEDKDEDK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Alre@ DB '['
	DB	'JewelOfHarmony][%s][%s] is Already Opening PShop, ChaosBox Fa'
	DB	'iled', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ODMCBHME@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@
CONST	SEGMENT
??_C@_0DM@ODMCBHME@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@ DB '['
	DB	'JewelOfHarmony][%s][%s] Open Chaos Box Failed NpcType [%d]', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pResult$ = -20						; size = 11
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?NpcJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@0@Z PROC ; CJewelOfHarmonySystem::NpcJewelOfHarmony
; _this$ = ecx

; 1289 : {

  02e60	55		 push	 ebp
  02e61	8b ec		 mov	 ebp, esp
  02e63	83 ec 54	 sub	 esp, 84			; 00000054H
  02e66	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02e6b	33 c5		 xor	 eax, ebp
  02e6d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02e70	53		 push	 ebx
  02e71	56		 push	 esi
  02e72	57		 push	 edi
  02e73	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1290 : 	if ( lpObj->m_IfState.use > 0 )

  02e76	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02e79	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  02e7f	83 e1 03	 and	 ecx, 3
  02e82	76 0a		 jbe	 SHORT $LN13@NpcJewelOf

; 1291 : 		return TRUE;

  02e84	b8 01 00 00 00	 mov	 eax, 1
  02e89	e9 e1 02 00 00	 jmp	 $LN14@NpcJewelOf
$LN13@NpcJewelOf:

; 1292 : 
; 1293 : 	PMSG_TALKRESULT pResult;
; 1294 : 
; 1295 : 	pResult.h.c = 0xC3;

  02e8e	c6 45 ec c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 1296 : 	pResult.h.headcode = 0x30;

  02e92	c6 45 ee 30	 mov	 BYTE PTR _pResult$[ebp+2], 48 ; 00000030H

; 1297 : 	pResult.h.size = sizeof(pResult);

  02e96	c6 45 ed 0b	 mov	 BYTE PTR _pResult$[ebp+1], 11 ; 0000000bH

; 1298 : 	
; 1299 : 	if ( lpNpc->Class == 368 )

  02e9a	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  02e9d	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  02ea4	81 f9 70 01 00
	00		 cmp	 ecx, 368		; 00000170H
  02eaa	0f 85 9d 00 00
	00		 jne	 $LN12@NpcJewelOf

; 1300 : 	{
; 1301 : 		pResult.result = 17;

  02eb0	c6 45 ef 11	 mov	 BYTE PTR _pResult$[ebp+3], 17 ; 00000011H

; 1302 : 		pResult.level1 = this->m_iRatePuritySuccess;

  02eb4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02eb7	8a 88 2c 53 00
	00		 mov	 cl, BYTE PTR [eax+21292]
  02ebd	88 4d f0	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 1303 : 
; 1304 : 		if ( this->m_bSystemPrutiyJewel != TRUE )

  02ec0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02ec3	83 b8 18 53 00
	00 01		 cmp	 DWORD PTR [eax+21272], 1
  02eca	74 2a		 je	 SHORT $LN11@NpcJewelOf

; 1305 : 		{
; 1306 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,50)), lpObj->m_Index, 1);

  02ecc	6a 01		 push	 1
  02ece	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02ed1	8b 08		 mov	 ecx, DWORD PTR [eax]
  02ed3	51		 push	 ecx
  02ed4	68 32 0d 00 00	 push	 3378			; 00000d32H
  02ed9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02ede	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02ee3	50		 push	 eax
  02ee4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02ee9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1307 : 			return TRUE;

  02eec	b8 01 00 00 00	 mov	 eax, 1
  02ef1	e9 79 02 00 00	 jmp	 $LN14@NpcJewelOf
$LN11@NpcJewelOf:

; 1308 : 		}
; 1309 : 
; 1310 : 		if ( !this->IsEnableToUsePuritySystem() )

  02ef6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02ef9	e8 00 00 00 00	 call	 ?IsEnableToUsePuritySystem@CJewelOfHarmonySystem@@QAEHXZ ; CJewelOfHarmonySystem::IsEnableToUsePuritySystem
  02efe	85 c0		 test	 eax, eax
  02f00	75 46		 jne	 SHORT $LN10@NpcJewelOf

; 1311 : 		{
; 1312 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,50)), lpObj->m_Index, 1);

  02f02	6a 01		 push	 1
  02f04	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02f07	8b 08		 mov	 ecx, DWORD PTR [eax]
  02f09	51		 push	 ecx
  02f0a	68 32 0d 00 00	 push	 3378			; 00000d32H
  02f0f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02f14	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02f19	50		 push	 eax
  02f1a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02f1f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1313 : 			LogAddTD("[JewelOfHarmony][%s][%s] Not Purtiy Time ",
; 1314 : 				lpObj->AccountID, lpObj->Name);

  02f22	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02f25	83 c0 77	 add	 eax, 119		; 00000077H
  02f28	50		 push	 eax
  02f29	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02f2c	83 c1 6c	 add	 ecx, 108		; 0000006cH
  02f2f	51		 push	 ecx
  02f30	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BCOFIMEK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Pur@
  02f35	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02f3b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1315 : 
; 1316 : 			return TRUE;

  02f3e	b8 01 00 00 00	 mov	 eax, 1
  02f43	e9 27 02 00 00	 jmp	 $LN14@NpcJewelOf
$LN10@NpcJewelOf:

; 1317 : 		}
; 1318 : 	}

  02f48	e9 ec 00 00 00	 jmp	 $LN9@NpcJewelOf
$LN12@NpcJewelOf:

; 1319 : 	else  if ( lpNpc->Class == 369 )

  02f4d	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  02f50	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  02f57	81 f9 71 01 00
	00		 cmp	 ecx, 369		; 00000171H
  02f5d	75 59		 jne	 SHORT $LN8@NpcJewelOf

; 1320 : 	{
; 1321 : 		pResult.result = 18;

  02f5f	c6 45 ef 12	 mov	 BYTE PTR _pResult$[ebp+3], 18 ; 00000012H

; 1322 : 		pResult.level1 = this->m_iRateMixSmeltingStoneNor;

  02f63	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02f66	8a 88 34 53 00
	00		 mov	 cl, BYTE PTR [eax+21300]
  02f6c	88 4d f0	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 1323 : 		pResult.level2 = this->m_iRateMixSmeltingStoneExt;

  02f6f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02f72	8a 88 38 53 00
	00		 mov	 cl, BYTE PTR [eax+21304]
  02f78	88 4d f1	 mov	 BYTE PTR _pResult$[ebp+5], cl

; 1324 : 
; 1325 : 		if ( this->m_bSystemMixSmeltingStone != TRUE )

  02f7b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02f7e	83 b8 1c 53 00
	00 01		 cmp	 DWORD PTR [eax+21276], 1
  02f85	74 2c		 je	 SHORT $LN7@NpcJewelOf

; 1326 : 		{
; 1327 : 			ChatTargetSend(lpNpc, lMsg.Get(MSGGET(13,53)), lpObj->m_Index);

  02f87	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02f8a	8b 08		 mov	 ecx, DWORD PTR [eax]
  02f8c	51		 push	 ecx
  02f8d	68 35 0d 00 00	 push	 3381			; 00000d35H
  02f92	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02f97	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02f9c	50		 push	 eax
  02f9d	8b 55 08	 mov	 edx, DWORD PTR _lpNpc$[ebp]
  02fa0	52		 push	 edx
  02fa1	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  02fa6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1328 : 			return TRUE;

  02fa9	b8 01 00 00 00	 mov	 eax, 1
  02fae	e9 bc 01 00 00	 jmp	 $LN14@NpcJewelOf
$LN7@NpcJewelOf:

; 1329 : 		}
; 1330 : 	}

  02fb3	e9 81 00 00 00	 jmp	 $LN9@NpcJewelOf
$LN8@NpcJewelOf:

; 1331 : 	else if ( lpNpc->Class == 370 )

  02fb8	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  02fbb	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  02fc2	81 f9 72 01 00
	00		 cmp	 ecx, 370		; 00000172H
  02fc8	75 3e		 jne	 SHORT $LN5@NpcJewelOf

; 1332 : 	{
; 1333 : 		pResult.result = 19;

  02fca	c6 45 ef 13	 mov	 BYTE PTR _pResult$[ebp+3], 19 ; 00000013H

; 1334 : 
; 1335 : 		if ( this->m_bSystemRestoreStrengthen != TRUE )

  02fce	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02fd1	83 b8 20 53 00
	00 01		 cmp	 DWORD PTR [eax+21280], 1
  02fd8	74 2c		 je	 SHORT $LN4@NpcJewelOf

; 1336 : 		{
; 1337 : 			ChatTargetSend(lpNpc, lMsg.Get(MSGGET(13,54)), lpObj->m_Index);

  02fda	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02fdd	8b 08		 mov	 ecx, DWORD PTR [eax]
  02fdf	51		 push	 ecx
  02fe0	68 36 0d 00 00	 push	 3382			; 00000d36H
  02fe5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02fea	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02fef	50		 push	 eax
  02ff0	8b 55 08	 mov	 edx, DWORD PTR _lpNpc$[ebp]
  02ff3	52		 push	 edx
  02ff4	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  02ff9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1338 : 			return TRUE;

  02ffc	b8 01 00 00 00	 mov	 eax, 1
  03001	e9 69 01 00 00	 jmp	 $LN14@NpcJewelOf
$LN4@NpcJewelOf:

; 1339 : 		}
; 1340 : 	}
; 1341 : 	else

  03006	eb 31		 jmp	 SHORT $LN9@NpcJewelOf
$LN5@NpcJewelOf:

; 1342 : 	{
; 1343 : 		LogAddTD("[JewelOfHarmony][%s][%s] Open Chaos Box Failed NpcType [%d]",
; 1344 : 			lpObj->AccountID, lpObj->Name, lpNpc->Class);

  03008	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  0300b	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  03012	51		 push	 ecx
  03013	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  03016	83 c2 77	 add	 edx, 119		; 00000077H
  03019	52		 push	 edx
  0301a	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0301d	83 c0 6c	 add	 eax, 108		; 0000006cH
  03020	50		 push	 eax
  03021	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ODMCBHME@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@
  03026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0302c	83 c4 10	 add	 esp, 16			; 00000010H

; 1345 : 
; 1346 : 		return TRUE;

  0302f	b8 01 00 00 00	 mov	 eax, 1
  03034	e9 36 01 00 00	 jmp	 $LN14@NpcJewelOf
$LN9@NpcJewelOf:

; 1347 : 	}
; 1348 : 
; 1349 : 	if ( bCanChaosBox == TRUE )

  03039	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanChaosBox@@3HA, 1 ; bCanChaosBox
  03040	0f 85 24 01 00
	00		 jne	 $LN2@NpcJewelOf

; 1350 : 	{
; 1351 : 		if ( lpObj->m_bPShopOpen == true )

  03046	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03049	0f b6 88 c4 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3780]
  03050	83 f9 01	 cmp	 ecx, 1
  03053	75 46		 jne	 SHORT $LN1@NpcJewelOf

; 1352 : 		{
; 1353 : 			LogAdd("[JewelOfHarmony][%s][%s] is Already Opening PShop, ChaosBox Failed",
; 1354 : 				lpObj->AccountID, lpObj->Name);

  03055	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03058	83 c0 77	 add	 eax, 119		; 00000077H
  0305b	50		 push	 eax
  0305c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0305f	83 c1 6c	 add	 ecx, 108		; 0000006cH
  03062	51		 push	 ecx
  03063	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@FEDKDEDK@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Alre@
  03068	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0306e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1355 : 
; 1356 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4,194)), lpObj->m_Index, 1);

  03071	6a 01		 push	 1
  03073	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03076	8b 08		 mov	 ecx, DWORD PTR [eax]
  03078	51		 push	 ecx
  03079	68 c2 04 00 00	 push	 1218			; 000004c2H
  0307e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  03083	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  03088	50		 push	 eax
  03089	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0308e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1357 : 			return TRUE;

  03091	b8 01 00 00 00	 mov	 eax, 1
  03096	e9 d4 00 00 00	 jmp	 $LN14@NpcJewelOf
$LN1@NpcJewelOf:

; 1358 : 		}
; 1359 : 
; 1360 : 		lpObj->m_IfState.type = 7;

  0309b	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0309e	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  030a4	81 e1 3f 00 ff
	ff		 and	 ecx, -65473		; ffff003fH
  030aa	81 c9 c0 01 00
	00		 or	 ecx, 448		; 000001c0H
  030b0	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  030b3	89 8a 1c 0e 00
	00		 mov	 DWORD PTR [edx+3612], ecx

; 1361 : 		lpObj->m_IfState.state = 0;

  030b9	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  030bc	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  030c2	83 e1 c3	 and	 ecx, -61		; ffffffc3H
  030c5	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  030c8	89 8a 1c 0e 00
	00		 mov	 DWORD PTR [edx+3612], ecx

; 1362 : 		lpObj->m_IfState.use = 1;

  030ce	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  030d1	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  030d7	83 e1 fc	 and	 ecx, -4			; fffffffcH
  030da	83 c9 01	 or	 ecx, 1
  030dd	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  030e0	89 8a 1c 0e 00
	00		 mov	 DWORD PTR [edx+3612], ecx

; 1363 : 		lpObj->bIsChaosMixCompleted = false;

  030e6	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  030e9	c6 80 79 12 00
	00 00		 mov	 BYTE PTR [eax+4729], 0

; 1364 : 
; 1365 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  030f0	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  030f4	50		 push	 eax
  030f5	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  030f8	51		 push	 ecx
  030f9	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  030fc	8b 02		 mov	 eax, DWORD PTR [edx]
  030fe	50		 push	 eax
  030ff	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  03104	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1366 : 		gObjInventoryTrans(lpObj->m_Index);

  03107	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0310a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0310c	51		 push	 ecx
  0310d	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  03112	83 c4 04	 add	 esp, 4

; 1367 : 
; 1368 : 		LogAddTD("[JewelOfHarmony][%s][%s] Open Chaos Box",
; 1369 : 			lpObj->AccountID, lpObj->Name);

  03115	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03118	83 c0 77	 add	 eax, 119		; 00000077H
  0311b	50		 push	 eax
  0311c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0311f	83 c1 6c	 add	 ecx, 108		; 0000006cH
  03122	51		 push	 ecx
  03123	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@BLEFGBBC@?$FLJewelOfHarmony?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Ch@
  03128	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0312e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1370 : 
; 1371 : 		gObjItemTextSave(lpObj);

  03131	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03134	50		 push	 eax
  03135	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave
  0313a	83 c4 04	 add	 esp, 4

; 1372 : 		gObjWarehouseTextSave(lpObj);

  0313d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03140	50		 push	 eax
  03141	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave
  03146	83 c4 04	 add	 esp, 4

; 1373 : 		GCAnsCsMapSvrTaxInfo(lpObj->m_Index, 1, g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index));

  03149	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0314c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0314e	51		 push	 ecx
  0314f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  03154	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  03159	50		 push	 eax
  0315a	6a 01		 push	 1
  0315c	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0315f	8b 02		 mov	 eax, DWORD PTR [edx]
  03161	50		 push	 eax
  03162	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo
  03167	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@NpcJewelOf:

; 1374 : 	}
; 1375 : 
; 1376 : 	return TRUE;

  0316a	b8 01 00 00 00	 mov	 eax, 1
$LN14@NpcJewelOf:

; 1377 : }

  0316f	5f		 pop	 edi
  03170	5e		 pop	 esi
  03171	5b		 pop	 ebx
  03172	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  03175	33 cd		 xor	 ecx, ebp
  03177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0317c	8b e5		 mov	 esp, ebp
  0317e	5d		 pop	 ebp
  0317f	c2 08 00	 ret	 8
?NpcJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP ; CJewelOfHarmonySystem::NpcJewelOfHarmony
_TEXT	ENDS
PUBLIC	?IsEnableToTrade@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::IsEnableToTrade
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_n$230580 = -12						; size = 4
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?IsEnableToTrade@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CJewelOfHarmonySystem::IsEnableToTrade
; _this$ = ecx

; 1382 : {

  03190	55		 push	 ebp
  03191	8b ec		 mov	 ebp, esp
  03193	83 ec 4c	 sub	 esp, 76			; 0000004cH
  03196	53		 push	 ebx
  03197	56		 push	 esi
  03198	57		 push	 edi
  03199	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1383 : 	BOOL bRet = TRUE;

  0319c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1

; 1384 : 
; 1385 : 	for ( int n=0;n<TRADE_BOX_SIZE;n++)

  031a3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$230580[ebp], 0
  031aa	eb 09		 jmp	 SHORT $LN5@IsEnableTo@2
$LN4@IsEnableTo@2:
  031ac	8b 45 f4	 mov	 eax, DWORD PTR _n$230580[ebp]
  031af	83 c0 01	 add	 eax, 1
  031b2	89 45 f4	 mov	 DWORD PTR _n$230580[ebp], eax
$LN5@IsEnableTo@2:
  031b5	83 7d f4 20	 cmp	 DWORD PTR _n$230580[ebp], 32 ; 00000020H
  031b9	7d 45		 jge	 SHORT $LN3@IsEnableTo@2

; 1386 : 	{
; 1387 : 		if ( lpObj->Trade[n].IsItem() == TRUE )

  031bb	8b 4d f4	 mov	 ecx, DWORD PTR _n$230580[ebp]
  031be	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  031c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  031c7	03 88 4c 0e 00
	00		 add	 ecx, DWORD PTR [eax+3660]
  031cd	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  031d2	83 f8 01	 cmp	 eax, 1
  031d5	75 27		 jne	 SHORT $LN2@IsEnableTo@2

; 1388 : 		{
; 1389 : 			if ( this->IsStrengthenByJewelOfHarmony(&lpObj->Trade[n]) == TRUE )

  031d7	8b 45 f4	 mov	 eax, DWORD PTR _n$230580[ebp]
  031da	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  031e0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  031e3	03 81 4c 0e 00
	00		 add	 eax, DWORD PTR [ecx+3660]
  031e9	50		 push	 eax
  031ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  031ed	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  031f2	83 f8 01	 cmp	 eax, 1
  031f5	75 07		 jne	 SHORT $LN2@IsEnableTo@2

; 1390 : 			{
; 1391 : 				bRet = FALSE;

  031f7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0
$LN2@IsEnableTo@2:

; 1392 : 			}
; 1393 : 		}
; 1394 : 	}

  031fe	eb ac		 jmp	 SHORT $LN4@IsEnableTo@2
$LN3@IsEnableTo@2:

; 1395 : 
; 1396 : 	return bRet;

  03200	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 1397 : }

  03203	5f		 pop	 edi
  03204	5e		 pop	 esi
  03205	5b		 pop	 ebx
  03206	8b e5		 mov	 esp, ebp
  03208	5d		 pop	 ebp
  03209	c2 04 00	 ret	 4
?IsEnableToTrade@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CJewelOfHarmonySystem::IsEnableToTrade
_TEXT	ENDS
PUBLIC	??_C@_0IM@HNPECCPL@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ ; `string'
PUBLIC	??_C@_0HA@NENOIDMG@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ ; `string'
PUBLIC	??_C@_0HN@OPIFLCLD@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ ; `string'
PUBLIC	??_C@_0HI@MLKDMOMN@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ ; `string'
PUBLIC	??_C@_0DK@IGAHEKOO@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Alr@ ; `string'
PUBLIC	?StrengthenItemByJewelOfRise@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::StrengthenItemByJewelOfRise
;	COMDAT ??_C@_0IM@HNPECCPL@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
CONST	SEGMENT
??_C@_0IM@HNPECCPL@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ DB '[L'
	DB	'uckyItem][Strengthen Item] Strengthen Success [%s][%s] Name[%'
	DB	's] Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d) Option %d'
	DB	' OptionLevel %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@NENOIDMG@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
CONST	SEGMENT
??_C@_0HA@NENOIDMG@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ DB '[L'
	DB	'uckyItem][Strengthen Item] Strengthen Fail [%s][%s] Name[%s] '
	DB	'Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@OPIFLCLD@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
CONST	SEGMENT
??_C@_0HN@OPIFLCLD@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ DB '[L'
	DB	'uckyItem][Strengthen Item] Strengthen Fail - NOT OPTION [%s]['
	DB	'%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) ItemType[%d]'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@MLKDMOMN@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
CONST	SEGMENT
??_C@_0HI@MLKDMOMN@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@ DB '[L'
	DB	'uckyItem][Strengthen Item] Strengthen Fail [%s][%s] Name[%s] '
	DB	'Type[%d] Serial[%u] JewelSerial(%u) Invalid ItemType[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IGAHEKOO@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Alr@
CONST	SEGMENT
??_C@_0DK@IGAHEKOO@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Alr@ DB '[L'
	DB	'uckyItem][Strengthen Item] Already Strengtened [%s][%s]', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv459 = -100						; size = 4
_levelitemdur$ = -32					; size = 4
_iSuccessRate$ = -28					; size = 4
_iItemOptionLevel$ = -24				; size = 4
_iItemOption$ = -20					; size = 4
_iItemType$ = -16					; size = 4
_pTarget$ = -12						; size = 4
_pSource$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?StrengthenItemByJewelOfRise@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z PROC ; CJewelOfHarmonySystem::StrengthenItemByJewelOfRise
; _this$ = ecx

; 1400 : {

  03210	55		 push	 ebp
  03211	8b ec		 mov	 ebp, esp
  03213	83 ec 64	 sub	 esp, 100		; 00000064H
  03216	53		 push	 ebx
  03217	56		 push	 esi
  03218	57		 push	 edi
  03219	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1401 : 	if ( this->m_bSystemStrengthenItem == FALSE )

  0321c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0321f	83 b8 24 53 00
	00 00		 cmp	 DWORD PTR [eax+21284], 0
  03226	75 27		 jne	 SHORT $LN12@Strengthen@2

; 1402 : 	{
; 1403 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 52)), lpObj->m_Index, 1);

  03228	6a 01		 push	 1
  0322a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0322d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0322f	51		 push	 ecx
  03230	68 34 0d 00 00	 push	 3380			; 00000d34H
  03235	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0323a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0323f	50		 push	 eax
  03240	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  03245	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1404 : 		return FALSE;

  03248	33 c0		 xor	 eax, eax
  0324a	e9 7b 04 00 00	 jmp	 $LN13@Strengthen@2
$LN12@Strengthen@2:

; 1405 : 	}
; 1406 : 
; 1407 : 	if ( source < 0 || source > MAIN_INVENTORY_SIZE-1 )

  0324f	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  03253	7c 09		 jl	 SHORT $LN10@Strengthen@2
  03255	81 7d 0c cb 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 203 ; 000000cbH
  0325c	7e 07		 jle	 SHORT $LN11@Strengthen@2
$LN10@Strengthen@2:

; 1408 : 		return FALSE;

  0325e	33 c0		 xor	 eax, eax
  03260	e9 65 04 00 00	 jmp	 $LN13@Strengthen@2
$LN11@Strengthen@2:

; 1409 : 
; 1410 : 	if ( target < 0 || target > MAIN_INVENTORY_SIZE-1 )

  03265	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  03269	7c 09		 jl	 SHORT $LN8@Strengthen@2
  0326b	81 7d 10 cb 00
	00 00		 cmp	 DWORD PTR _target$[ebp], 203 ; 000000cbH
  03272	7e 07		 jle	 SHORT $LN9@Strengthen@2
$LN8@Strengthen@2:

; 1411 : 		return FALSE;

  03274	33 c0		 xor	 eax, eax
  03276	e9 4f 04 00 00	 jmp	 $LN13@Strengthen@2
$LN9@Strengthen@2:

; 1412 : 
; 1413 : 	if ( lpObj->pInventory[source].IsItem() == FALSE )

  0327b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0327e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03284	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03287	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0328d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  03292	85 c0		 test	 eax, eax
  03294	75 07		 jne	 SHORT $LN7@Strengthen@2

; 1414 : 		return FALSE;

  03296	33 c0		 xor	 eax, eax
  03298	e9 2d 04 00 00	 jmp	 $LN13@Strengthen@2
$LN7@Strengthen@2:

; 1415 : 
; 1416 : 	if ( lpObj->pInventory[target].IsItem() == FALSE )

  0329d	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  032a0	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  032a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  032a9	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  032af	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  032b4	85 c0		 test	 eax, eax
  032b6	75 07		 jne	 SHORT $LN6@Strengthen@2

; 1417 : 		return FALSE;

  032b8	33 c0		 xor	 eax, eax
  032ba	e9 0b 04 00 00	 jmp	 $LN13@Strengthen@2
$LN6@Strengthen@2:

; 1418 : 
; 1419 : 	CItem * pSource = &lpObj->pInventory[source];

  032bf	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  032c2	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  032c8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  032cb	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  032d1	89 45 f8	 mov	 DWORD PTR _pSource$[ebp], eax

; 1420 : 	CItem * pTarget = &lpObj->pInventory[target];

  032d4	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  032d7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  032dd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  032e0	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  032e6	89 45 f4	 mov	 DWORD PTR _pTarget$[ebp], eax

; 1421 : 
; 1422 : #ifdef LUCKYITEM
; 1423 : 	if( g_LuckyItemManager.IsLuckyItemEquipment(pTarget->m_Type) )

  032e9	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  032ec	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  032f0	51		 push	 ecx
  032f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  032f6	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  032fb	85 c0		 test	 eax, eax
  032fd	74 07		 je	 SHORT $LN5@Strengthen@2

; 1424 : 	{
; 1425 : 		return false;

  032ff	33 c0		 xor	 eax, eax
  03301	e9 c4 03 00 00	 jmp	 $LN13@Strengthen@2
$LN5@Strengthen@2:

; 1426 : 	}
; 1427 : #endif
; 1428 : 	if ( this->IsStrengthenByJewelOfHarmony(pTarget) == TRUE )

  03306	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  03309	50		 push	 eax
  0330a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0330d	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  03312	83 f8 01	 cmp	 eax, 1
  03315	75 23		 jne	 SHORT $LN4@Strengthen@2

; 1429 : 	{
; 1430 : 		LogAddTD("[LuckyItem][Strengthen Item] Already Strengtened [%s][%s]",
; 1431 : 			lpObj->AccountID, lpObj->Name);

  03317	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0331a	83 c0 77	 add	 eax, 119		; 00000077H
  0331d	50		 push	 eax
  0331e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03321	83 c1 6c	 add	 ecx, 108		; 0000006cH
  03324	51		 push	 ecx
  03325	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@IGAHEKOO@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Alr@
  0332a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03330	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1432 : 
; 1433 : 		return FALSE;

  03333	33 c0		 xor	 eax, eax
  03335	e9 90 03 00 00	 jmp	 $LN13@Strengthen@2
$LN4@Strengthen@2:

; 1434 : 	}
; 1435 : 
; 1436 : 	int iItemType = this->_GetItemType(pTarget);

  0333a	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0333d	50		 push	 eax
  0333e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03341	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  03346	89 45 f0	 mov	 DWORD PTR _iItemType$[ebp], eax

; 1437 : 
; 1438 : 	if ( iItemType == JEWELOFHARMONY_ITEM_TYPE_NULL )

  03349	83 7d f0 00	 cmp	 DWORD PTR _iItemType$[ebp], 0
  0334d	75 44		 jne	 SHORT $LN3@Strengthen@2

; 1439 : 	{
; 1440 : 		LogAddTD("[LuckyItem][Strengthen Item] Strengthen Fail [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) Invalid ItemType[%d]",
; 1441 : 			lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 1442 : 			pTarget->m_Number, pSource->m_Number, iItemType);

  0334f	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  03352	50		 push	 eax
  03353	8b 4d f8	 mov	 ecx, DWORD PTR _pSource$[ebp]
  03356	8b 11		 mov	 edx, DWORD PTR [ecx]
  03358	52		 push	 edx
  03359	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0335c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0335e	51		 push	 ecx
  0335f	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  03362	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  03366	50		 push	 eax
  03367	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0336a	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0336f	50		 push	 eax
  03370	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03373	83 c1 77	 add	 ecx, 119		; 00000077H
  03376	51		 push	 ecx
  03377	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0337a	83 c2 6c	 add	 edx, 108		; 0000006cH
  0337d	52		 push	 edx
  0337e	68 00 00 00 00	 push	 OFFSET ??_C@_0HI@MLKDMOMN@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
  03383	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03389	83 c4 20	 add	 esp, 32			; 00000020H

; 1443 : 		
; 1444 : 		return FALSE;

  0338c	33 c0		 xor	 eax, eax
  0338e	e9 37 03 00 00	 jmp	 $LN13@Strengthen@2
$LN3@Strengthen@2:

; 1445 : 	}
; 1446 : 
; 1447 : 	int iItemOption = this->_GetSelectRandomOption(pTarget, iItemType);

  03393	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  03396	50		 push	 eax
  03397	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0339a	51		 push	 ecx
  0339b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0339e	e8 00 00 00 00	 call	 ?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ; CJewelOfHarmonySystem::_GetSelectRandomOption
  033a3	89 45 ec	 mov	 DWORD PTR _iItemOption$[ebp], eax

; 1448 : 
; 1449 : 	if ( iItemOption == AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM )

  033a6	83 7d ec 00	 cmp	 DWORD PTR _iItemOption$[ebp], 0
  033aa	75 44		 jne	 SHORT $LN2@Strengthen@2

; 1450 : 	{
; 1451 : 		LogAddTD("[LuckyItem][Strengthen Item] Strengthen Fail - NOT OPTION [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) ItemType[%d]",
; 1452 : 			lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 1453 : 			pTarget->m_Number, pSource->m_Number, iItemType);

  033ac	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  033af	50		 push	 eax
  033b0	8b 4d f8	 mov	 ecx, DWORD PTR _pSource$[ebp]
  033b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  033b5	52		 push	 edx
  033b6	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  033b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  033bb	51		 push	 ecx
  033bc	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  033bf	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  033c3	50		 push	 eax
  033c4	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  033c7	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  033cc	50		 push	 eax
  033cd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  033d0	83 c1 77	 add	 ecx, 119		; 00000077H
  033d3	51		 push	 ecx
  033d4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  033d7	83 c2 6c	 add	 edx, 108		; 0000006cH
  033da	52		 push	 edx
  033db	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@OPIFLCLD@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
  033e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  033e6	83 c4 20	 add	 esp, 32			; 00000020H

; 1454 : 		
; 1455 : 		return FALSE;

  033e9	33 c0		 xor	 eax, eax
  033eb	e9 da 02 00 00	 jmp	 $LN13@Strengthen@2
$LN2@Strengthen@2:

; 1456 : 	}
; 1457 : 
; 1458 : 	int iItemOptionLevel = this->m_itemOption[iItemType][iItemOption].iRequireLevel;

  033f0	8b 45 f0	 mov	 eax, DWORD PTR _iItemType$[ebp]
  033f3	69 c0 c0 14 00
	00		 imul	 eax, 5312		; 000014c0H
  033f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  033fc	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  03400	8b 45 ec	 mov	 eax, DWORD PTR _iItemOption$[ebp]
  03403	69 c0 4c 01 00
	00		 imul	 eax, 332		; 0000014cH
  03409	0f b6 4c 02 05	 movzx	 ecx, BYTE PTR [edx+eax+5]
  0340e	89 4d e8	 mov	 DWORD PTR _iItemOptionLevel$[ebp], ecx

; 1459 : 	int iSuccessRate = rand() % 100;

  03411	e8 00 00 00 00	 call	 _rand
  03416	99		 cdq
  03417	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0341c	f7 f9		 idiv	 ecx
  0341e	89 55 e4	 mov	 DWORD PTR _iSuccessRate$[ebp], edx

; 1460 : 
; 1461 : 	if ( iSuccessRate >= this->m_iRateStrengthenSuccess )

  03421	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03424	8b 4d e4	 mov	 ecx, DWORD PTR _iSuccessRate$[ebp]
  03427	3b 88 40 53 00
	00		 cmp	 ecx, DWORD PTR [eax+21312]
  0342d	7c 71		 jl	 SHORT $LN1@Strengthen@2

; 1462 : 	{
; 1463 : 		LogAddTD("[LuckyItem][Strengthen Item] Strengthen Fail [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d)",
; 1464 : 			lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type,
; 1465 : 			pTarget->m_Number, pSource->m_Number, iSuccessRate, this->m_iRateStrengthenSuccess);

  0342f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03432	8b 88 40 53 00
	00		 mov	 ecx, DWORD PTR [eax+21312]
  03438	51		 push	 ecx
  03439	8b 55 e4	 mov	 edx, DWORD PTR _iSuccessRate$[ebp]
  0343c	52		 push	 edx
  0343d	8b 45 f8	 mov	 eax, DWORD PTR _pSource$[ebp]
  03440	8b 08		 mov	 ecx, DWORD PTR [eax]
  03442	51		 push	 ecx
  03443	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  03446	8b 02		 mov	 eax, DWORD PTR [edx]
  03448	50		 push	 eax
  03449	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0344c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  03450	52		 push	 edx
  03451	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  03454	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  03459	50		 push	 eax
  0345a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0345d	83 c0 77	 add	 eax, 119		; 00000077H
  03460	50		 push	 eax
  03461	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03464	83 c1 6c	 add	 ecx, 108		; 0000006cH
  03467	51		 push	 ecx
  03468	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@NENOIDMG@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
  0346d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03473	83 c4 24	 add	 esp, 36			; 00000024H

; 1466 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 45)), lpObj->m_Index, 1);

  03476	6a 01		 push	 1
  03478	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0347b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0347d	51		 push	 ecx
  0347e	68 2d 0d 00 00	 push	 3373			; 00000d2dH
  03483	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  03488	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0348d	50		 push	 eax
  0348e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  03493	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1467 : 		return TRUE;

  03496	b8 01 00 00 00	 mov	 eax, 1
  0349b	e9 2a 02 00 00	 jmp	 $LN13@Strengthen@2
$LN1@Strengthen@2:

; 1468 : 	}
; 1469 : 
; 1470 : 
; 1471 : 	this->_MakeOption(pTarget, iItemOption, iItemOptionLevel);

  034a0	0f b6 45 e8	 movzx	 eax, BYTE PTR _iItemOptionLevel$[ebp]
  034a4	50		 push	 eax
  034a5	0f b6 4d ec	 movzx	 ecx, BYTE PTR _iItemOption$[ebp]
  034a9	51		 push	 ecx
  034aa	8b 55 f4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  034ad	52		 push	 edx
  034ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  034b1	e8 00 00 00 00	 call	 ?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z ; CJewelOfHarmonySystem::_MakeOption

; 1472 : 
; 1473 : 	LogAddTD("[LuckyItem][Strengthen Item] Strengthen Success [%s][%s] Name[%s] Type[%d] Serial[%u] JewelSerial(%u) Rate (%d/%d) Option %d OptionLevel %d",
; 1474 : 		lpObj->AccountID, lpObj->Name, pTarget->GetName(), pTarget->m_Type, pTarget->m_Number,
; 1475 : 		pSource->m_Number, iSuccessRate, this->m_iRateStrengthenSuccess,
; 1476 : 		iItemOption, iItemOptionLevel);

  034b6	8b 45 e8	 mov	 eax, DWORD PTR _iItemOptionLevel$[ebp]
  034b9	50		 push	 eax
  034ba	8b 4d ec	 mov	 ecx, DWORD PTR _iItemOption$[ebp]
  034bd	51		 push	 ecx
  034be	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  034c1	8b 82 40 53 00
	00		 mov	 eax, DWORD PTR [edx+21312]
  034c7	50		 push	 eax
  034c8	8b 4d e4	 mov	 ecx, DWORD PTR _iSuccessRate$[ebp]
  034cb	51		 push	 ecx
  034cc	8b 55 f8	 mov	 edx, DWORD PTR _pSource$[ebp]
  034cf	8b 02		 mov	 eax, DWORD PTR [edx]
  034d1	50		 push	 eax
  034d2	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  034d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  034d7	52		 push	 edx
  034d8	8b 45 f4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  034db	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  034df	51		 push	 ecx
  034e0	8b 4d f4	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  034e3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  034e8	50		 push	 eax
  034e9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  034ec	83 c2 77	 add	 edx, 119		; 00000077H
  034ef	52		 push	 edx
  034f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  034f3	83 c0 6c	 add	 eax, 108		; 0000006cH
  034f6	50		 push	 eax
  034f7	68 00 00 00 00	 push	 OFFSET ??_C@_0IM@HNPECCPL@?$FLLuckyItem?$FN?$FLStrengthen?5Item?$FN?5Str@
  034fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03502	83 c4 2c	 add	 esp, 44			; 0000002cH

; 1477 : 
; 1478 : 	GCServerMsgStringSend(lMsg.Get(MSGGET(13, 46)), lpObj->m_Index, 1);

  03505	6a 01		 push	 1
  03507	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0350a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0350c	51		 push	 ecx
  0350d	68 2e 0d 00 00	 push	 3374			; 00000d2eH
  03512	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  03517	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0351c	50		 push	 eax
  0351d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  03522	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1479 : 
; 1480 : 	gObjMakePreviewCharSet(lpObj->m_Index);

  03525	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03528	8b 08		 mov	 ecx, DWORD PTR [eax]
  0352a	51		 push	 ecx
  0352b	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  03530	83 c4 04	 add	 esp, 4

; 1481 : 
; 1482 : 	float levelitemdur = ItemGetDurability(lpObj->pInventory[target].m_Type,
; 1483 : 		lpObj->pInventory[target].m_Level, lpObj->pInventory[target].IsExtItem(),
; 1484 : 		lpObj->pInventory[target].IsSetItem());

  03533	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  03536	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0353c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0353f	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  03545	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  0354a	50		 push	 eax
  0354b	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  0354e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03554	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  03557	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  0355d	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  03562	50		 push	 eax
  03563	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  03566	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0356c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0356f	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03575	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0357a	50		 push	 eax
  0357b	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  0357e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03584	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  03587	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  0358d	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  03592	51		 push	 ecx
  03593	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  03598	83 c4 10	 add	 esp, 16			; 00000010H
  0359b	89 45 9c	 mov	 DWORD PTR tv459[ebp], eax
  0359e	db 45 9c	 fild	 DWORD PTR tv459[ebp]
  035a1	d9 5d e0	 fstp	 DWORD PTR _levelitemdur$[ebp]

; 1485 : 
; 1486 : 	lpObj->pInventory[target].m_Durability = levelitemdur * lpObj->pInventory[target].m_Durability / lpObj->pInventory[target].m_BaseDurability;

  035a4	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  035a7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  035ad	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  035b0	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  035b6	d9 45 e0	 fld	 DWORD PTR _levelitemdur$[ebp]
  035b9	d8 4c 02 24	 fmul	 DWORD PTR [edx+eax+36]
  035bd	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  035c0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  035c6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  035c9	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  035cf	d8 74 02 2c	 fdiv	 DWORD PTR [edx+eax+44]
  035d3	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  035d6	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  035dc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  035df	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  035e5	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]

; 1487 : 
; 1488 : 	lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type,
; 1489 : 		lpObj->pInventory[target].m_Option1, lpObj->pInventory[target].m_Option2,
; 1490 : 		lpObj->pInventory[target].m_Option3, lpObj->pInventory[target].m_NewOption,
; 1491 : 		lpObj->pInventory[target].m_SetOption, lpObj->pInventory[target].m_ItemOptionEx, NULL, 0xFF, 0, 3);

  035e9	6a 03		 push	 3
  035eb	6a 00		 push	 0
  035ed	68 ff 00 00 00	 push	 255			; 000000ffH
  035f2	6a 00		 push	 0
  035f4	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  035f7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  035fd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03600	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03606	0f b6 84 02 ca
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+202]
  0360e	50		 push	 eax
  0360f	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  03612	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03618	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0361b	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03621	0f b6 8c 08 ae
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+174]
  03629	51		 push	 ecx
  0362a	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  0362d	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  03633	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03636	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0363c	0f b6 94 11 97
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edx+151]
  03644	52		 push	 edx
  03645	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  03648	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0364e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03651	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03657	0f b6 84 02 96
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+150]
  0365f	50		 push	 eax
  03660	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  03663	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03669	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0366c	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03672	0f b6 8c 08 95
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+149]
  0367a	51		 push	 ecx
  0367b	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  0367e	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  03684	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  03687	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0368d	0f b6 94 11 94
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edx+148]
  03695	52		 push	 edx
  03696	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  03699	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0369f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  036a2	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  036a8	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  036ad	50		 push	 eax
  036ae	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  036b1	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  036b7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  036ba	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  036c0	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 1492 : 
; 1493 : 
; 1494 : 	return TRUE;

  036c5	b8 01 00 00 00	 mov	 eax, 1
$LN13@Strengthen@2:

; 1495 : }

  036ca	5f		 pop	 edi
  036cb	5e		 pop	 esi
  036cc	5b		 pop	 ebx
  036cd	8b e5		 mov	 esp, ebp
  036cf	5d		 pop	 ebp
  036d0	c2 0c 00	 ret	 12			; 0000000cH
?StrengthenItemByJewelOfRise@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ENDP ; CJewelOfHarmonySystem::StrengthenItemByJewelOfRise
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T231956 = -70						; size = 1
$T231957 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T231956[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T231957[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
PUBLIC	??$insert@U?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int const ,int> >
PUBLIC	??0?$pair@$$CBHH@std@@QAE@ABH$$QAH@Z		; std::pair<int const ,int>::pair<int const ,int>
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
;	COMDAT ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
$T231961 = -96						; size = 4
$T231962 = -92						; size = 8
$T231963 = -84						; size = 4
$T231964 = -80						; size = 4
$T231965 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0001c	8d 45 a0	 lea	 eax, DWORD PTR $T231961[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 25		 jne	 SHORT $LN1@operator
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c8	 movzx	 ecx, al
  00059	85 c9		 test	 ecx, ecx
  0005b	74 33		 je	 SHORT $LN2@operator
$LN1@operator:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  0005d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T231963[ebp], 0
  00064	8b 45 f8	 mov	 eax, DWORD PTR __Where$[ebp]
  00067	89 45 b0	 mov	 DWORD PTR $T231964[ebp], eax
  0006a	8d 4d ac	 lea	 ecx, DWORD PTR $T231963[ebp]
  0006d	51		 push	 ecx
  0006e	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00071	52		 push	 edx
  00072	8d 4d a4	 lea	 ecx, DWORD PTR $T231962[ebp]
  00075	e8 00 00 00 00	 call	 ??0?$pair@$$CBHH@std@@QAE@ABH$$QAH@Z ; std::pair<int const ,int>::pair<int const ,int>
  0007a	50		 push	 eax
  0007b	8b 45 b0	 mov	 eax, DWORD PTR $T231964[ebp]
  0007e	50		 push	 eax
  0007f	8d 4d b4	 lea	 ecx, DWORD PTR $T231965[ebp]
  00082	51		 push	 ecx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int const ,int> >
  0008b	8b 10		 mov	 edx, DWORD PTR [eax]
  0008d	89 55 f8	 mov	 DWORD PTR __Where$[ebp], edx
$LN2@operator:

; 216  : 		return ((*_Where).second);

  00090	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00093	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
  00098	83 c0 04	 add	 eax, 4

; 217  : 		}

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
tv137 = -88						; size = 4
$T231981 = -84						; size = 4
$T231982 = -80						; size = 4
$T231984 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0001c	8d 45 b0	 lea	 eax, DWORD PTR $T231982[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 2d		 jne	 SHORT $LN3@find
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN3@find
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00060	89 4d a8	 mov	 DWORD PTR tv137[ebp], ecx
  00063	eb 0f		 jmp	 SHORT $LN4@find
$LN3@find:
  00065	8d 55 b4	 lea	 edx, DWORD PTR $T231984[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00071	89 45 a8	 mov	 DWORD PTR tv137[ebp], eax
$LN4@find:
  00074	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  00077	89 45 ac	 mov	 DWORD PTR $T231981[ebp], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T231981[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00082	89 10		 mov	 DWORD PTR [eax], edx
  00084	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : 		}

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
$T231992 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T231992[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1451 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
PUBLIC	??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$230738 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$230738[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase
$LN2@Erase:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$230738[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$230738[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$230738[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$230738[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$230738[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase
$LN4@Erase:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T232006 = -88						; size = 4
$T232007 = -84						; size = 4
$T232008 = -80						; size = 4
$T232009 = -76						; size = 4
$T232010 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T232007[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T232006[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T232009[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T232008[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T232006[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T232008[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T232010[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		return (_Left < _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 9c c0	 setl	 al

; 126  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBHH@std@@QAE@ABH$$QAH@Z	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>
PUBLIC	??$move@AAH@std@@YA$$QAHAAH@Z			; std::move<int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBHH@std@@QAE@ABH$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBHH@std@@QAE@ABH$$QAH@Z PROC		; std::pair<int const ,int>::pair<int const ,int>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Pair_base@$$CBHH@std@@QAE@ABH$$QAH@Z ; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>

; 234  : 		}

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$pair@$$CBHH@std@@QAE@ABH$$QAH@Z ENDP		; std::pair<int const ,int>::pair<int const ,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T232033 = -84						; size = 4
$T232034 = -80						; size = 4
$T232035 = -76						; size = 4
$T232036 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T232033[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T232034[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase
$LN2@erase:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T232035[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T232036[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase
$LN1@erase:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Wherenode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1742 : 		_Nodeptr _Pnode = _Root();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Wherenode$[ebp], ecx
$LN4@Lbound:

; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0002b	83 c4 04	 add	 esp, 4
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	85 c9		 test	 ecx, ecx
  00033	75 4c		 jne	 SHORT $LN3@Lbound

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 13		 je	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1748 : 			else

  00066	eb 17		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1752 : 				}

  0007f	eb a1		 jmp	 SHORT $LN4@Lbound
$LN3@Lbound:

; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1755 : 		}

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 15	 add	 eax, 21			; 00000015H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBHH@std@@QAE@ABH$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBHH@std@@QAE@ABH$$QAH@Z PROC		; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>, COMDAT
; _this$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 10		 mov	 DWORD PTR [eax], edx
  00016	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  0001f	83 c4 04	 add	 esp, 4
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 10		 mov	 edx, DWORD PTR [eax]
  00027	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 151  : 		}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBHH@std@@QAE@ABH$$QAH@Z ENDP		; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase@2

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase@2:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase@2

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase@2
$LN39@erase@2:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase@2

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase@2
$LN37@erase@2:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@2:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase@2

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase@2

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase@2:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase@2

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase@2
$LN33@erase@2:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase@2

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase@2
$LN31@erase@2:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase@2:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase@2

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase@2
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase@2
$LN43@erase@2:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase@2:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@2:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase@2

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase@2
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase@2
$LN45@erase@2:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase@2:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase@2:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase@2
$LN35@erase@2:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase@2

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase@2
$LN26@erase@2:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase@2

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase@2:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase@2:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase@2

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase@2
$LN23@erase@2:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase@2

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase@2
$LN21@erase@2:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase@2:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase@2:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase@2
  00392	eb 11		 jmp	 SHORT $LN18@erase@2
$LN17@erase@2:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@2:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase@2
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase@2

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase@2

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase@2

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@2:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase@2

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase@2
$LN13@erase@2:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase@2
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase@2

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase@2
$LN11@erase@2:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase@2

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase@2:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase@2
$LN12@erase@2:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase@2
$LN15@erase@2:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase@2

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase@2:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase@2

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase@2
$LN6@erase@2:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase@2
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase@2

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase@2
$LN4@erase@2:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase@2

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@2:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase@2
$LN8@erase@2:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase@2
$LN16@erase@2:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase@2:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase@2

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase@2:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@2:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 14	 add	 eax, 20			; 00000014H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max
$LN1@Max:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min
$LN1@Min:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$230991 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator@2
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator@2
$LN6@operator@2:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator@2

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator@2
$LN2@operator@2:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$230991[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$230991[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator@2
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$230991[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator@2

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$230991[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator@2
$LN1@operator@2:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$230991[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@2:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
PUBLIC	??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int const ,int> >
PUBLIC	??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z ; std::forward<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$insert@U?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z ; std::forward<std::pair<int const ,int> >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int const ,int> >
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	52		 push	 edx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 768  : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,int> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z ; std::allocator<std::pair<int const ,int> >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z ; std::allocator<std::pair<int const ,int> >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00012	83 c4 04	 add	 esp, 4
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	88 11		 mov	 BYTE PTR [ecx], dl

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	88 11		 mov	 BYTE PTR [ecx], dl

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T232108 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 aa aa
	aa 0a		 cmp	 DWORD PTR __Count$[ebp], 178956970 ; 0aaaaaaaH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 18	 imul	 eax, 24			; 00000018H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T232108[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T232108[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T232112 = -112						; size = 4
$T232113 = -108						; size = 4
$T232114 = -104						; size = 4
$T232115 = -100						; size = 4
$T232116 = -96						; size = 4
$T232117 = -92						; size = 4
$T232118 = -88						; size = 8
__Leftish$ = -13					; size = 1
__Next$ = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 1096 : 
; 1097 : 		const_iterator _Next;

  0001b	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >

; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence

  00023	c6 45 f3 00	 mov	 BYTE PTR __Leftish$[ebp], 0

; 1099 : 
; 1100 : 		if (size() == 0)

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
  0002f	85 c0		 test	 eax, eax
  00031	75 26		 jne	 SHORT $LN33@Insert

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  00033	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	52		 push	 edx
  0003e	6a 01		 push	 1
  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	e9 a7 05 00 00	 jmp	 $LN34@Insert
  00054	e9 83 05 00 00	 jmp	 $LN32@Insert
$LN33@Insert:

; 1102 : 		else if (this->_Multi)

  00059	33 c0		 xor	 eax, eax
  0005b	0f 84 c8 02 00
	00		 je	 $LN31@Insert

; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())

  00061	8d 45 90	 lea	 eax, DWORD PTR $T232112[ebp]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  0006d	50		 push	 eax
  0006e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00071	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00076	0f b6 c8	 movzx	 ecx, al
  00079	85 c9		 test	 ecx, ecx
  0007b	74 5a		 je	 SHORT $LN30@Insert

; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,

  0007d	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00086	83 c4 04	 add	 esp, 4
  00089	50		 push	 eax
  0008a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00098	83 c4 04	 add	 esp, 4
  0009b	50		 push	 eax
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000a4	0f b6 c8	 movzx	 ecx, al
  000a7	85 c9		 test	 ecx, ecx
  000a9	75 23		 jne	 SHORT $LN29@Insert

; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000ab	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  000ae	50		 push	 eax
  000af	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000b2	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  000b7	50		 push	 eax
  000b8	6a 01		 push	 1
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000bd	51		 push	 ecx
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  000c6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c9	e9 2d 05 00 00	 jmp	 $LN34@Insert
$LN29@Insert:

; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence

  000ce	c6 45 f3 01	 mov	 BYTE PTR __Leftish$[ebp], 1
  000d2	e9 4d 02 00 00	 jmp	 $LN28@Insert
$LN30@Insert:

; 1110 : 				}
; 1111 : 			else if (_Where == end())

  000d7	8d 45 94	 lea	 eax, DWORD PTR $T232113[ebp]
  000da	50		 push	 eax
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  000e3	50		 push	 eax
  000e4	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000e7	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  000ec	0f b6 c8	 movzx	 ecx, al
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 5a		 je	 SHORT $LN27@Insert

; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  000fb	8b 00		 mov	 eax, DWORD PTR [eax]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00103	83 c4 04	 add	 esp, 4
  00106	50		 push	 eax
  00107	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00110	83 c4 04	 add	 esp, 4
  00113	50		 push	 eax
  00114	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0011c	0f b6 d0	 movzx	 edx, al
  0011f	85 d2		 test	 edx, edx
  00121	75 25		 jne	 SHORT $LN26@Insert

; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));

  00123	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  00126	50		 push	 eax
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	51		 push	 ecx
  00132	6a 00		 push	 0
  00134	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00137	52		 push	 edx
  00138	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  00140	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00143	e9 b3 04 00 00	 jmp	 $LN34@Insert
$LN26@Insert:

; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,

  00148	e9 d7 01 00 00	 jmp	 $LN28@Insert
$LN27@Insert:

; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,

  0014d	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00156	83 c4 04	 add	 esp, 4
  00159	50		 push	 eax
  0015a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0015d	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00168	83 c4 04	 add	 esp, 4
  0016b	50		 push	 eax
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00174	0f b6 c8	 movzx	 ecx, al
  00177	85 c9		 test	 ecx, ecx
  00179	0f 85 ab 00 00
	00		 jne	 $LN24@Insert
  0017f	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00182	89 45 f4	 mov	 DWORD PTR __Next$[ebp], eax
  00185	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00188	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
  0018d	8b c8		 mov	 ecx, eax
  0018f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  001a1	51		 push	 ecx
  001a2	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  001a7	83 c4 04	 add	 esp, 4
  001aa	50		 push	 eax
  001ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b3	0f b6 d0	 movzx	 edx, al
  001b6	85 d2		 test	 edx, edx
  001b8	75 70		 jne	 SHORT $LN24@Insert

; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  001ba	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  001bd	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  001c8	83 c4 04	 add	 esp, 4
  001cb	8b 00		 mov	 eax, DWORD PTR [eax]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  001d3	83 c4 04	 add	 esp, 4
  001d6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001d9	85 c9		 test	 ecx, ecx
  001db	74 25		 je	 SHORT $LN23@Insert

; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));

  001dd	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  001e0	50		 push	 eax
  001e1	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  001e9	50		 push	 eax
  001ea	6a 00		 push	 0
  001ec	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001ef	51		 push	 ecx
  001f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f3	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  001f8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001fb	e9 fb 03 00 00	 jmp	 $LN34@Insert

; 1125 : 				else

  00200	eb 23		 jmp	 SHORT $LN22@Insert
$LN23@Insert:

; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00202	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  00205	50		 push	 eax
  00206	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00209	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  0020e	50		 push	 eax
  0020f	6a 01		 push	 1
  00211	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00214	51		 push	 ecx
  00215	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00218	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  0021d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00220	e9 d6 03 00 00	 jmp	 $LN34@Insert
$LN22@Insert:

; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,

  00225	e9 fa 00 00 00	 jmp	 $LN28@Insert
$LN24@Insert:

; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,

  0022a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0022d	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00238	83 c4 04	 add	 esp, 4
  0023b	50		 push	 eax
  0023c	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00245	83 c4 04	 add	 esp, 4
  00248	50		 push	 eax
  00249	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00251	0f b6 c8	 movzx	 ecx, al
  00254	85 c9		 test	 ecx, ecx
  00256	0f 85 c4 00 00
	00		 jne	 $LN20@Insert
  0025c	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0025f	89 45 f4	 mov	 DWORD PTR __Next$[ebp], eax
  00262	8d 4d 98	 lea	 ecx, DWORD PTR $T232114[ebp]
  00265	51		 push	 ecx
  00266	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  0026e	50		 push	 eax
  0026f	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00272	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
  00277	8b c8		 mov	 ecx, eax
  00279	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  0027e	0f b6 d0	 movzx	 edx, al
  00281	85 d2		 test	 edx, edx
  00283	75 2e		 jne	 SHORT $LN19@Insert
  00285	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00288	50		 push	 eax
  00289	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  0028e	83 c4 04	 add	 esp, 4
  00291	50		 push	 eax
  00292	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00295	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  002a0	83 c4 04	 add	 esp, 4
  002a3	50		 push	 eax
  002a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a7	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  002ac	0f b6 c8	 movzx	 ecx, al
  002af	85 c9		 test	 ecx, ecx
  002b1	75 6d		 jne	 SHORT $LN20@Insert
$LN19@Insert:

; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  002b3	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  002b6	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  002c1	83 c4 04	 add	 esp, 4
  002c4	8b 00		 mov	 eax, DWORD PTR [eax]
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  002cc	83 c4 04	 add	 esp, 4
  002cf	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002d2	85 c9		 test	 ecx, ecx
  002d4	74 25		 je	 SHORT $LN18@Insert

; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));

  002d6	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  002d9	50		 push	 eax
  002da	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  002dd	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  002e2	50		 push	 eax
  002e3	6a 00		 push	 0
  002e5	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002e8	51		 push	 ecx
  002e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ec	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  002f1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002f4	e9 02 03 00 00	 jmp	 $LN34@Insert

; 1136 : 				else

  002f9	eb 23		 jmp	 SHORT $LN17@Insert
$LN18@Insert:

; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));

  002fb	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  002fe	50		 push	 eax
  002ff	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00302	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00307	50		 push	 eax
  00308	6a 01		 push	 1
  0030a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0030d	51		 push	 ecx
  0030e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00311	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  00316	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00319	e9 dd 02 00 00	 jmp	 $LN34@Insert
$LN17@Insert:

; 1138 : 				}
; 1139 : 			else

  0031e	eb 04		 jmp	 SHORT $LN28@Insert
$LN20@Insert:

; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence

  00320	c6 45 f3 01	 mov	 BYTE PTR __Leftish$[ebp], 1
$LN28@Insert:

; 1141 : 			}
; 1142 : 		else

  00324	e9 b3 02 00 00	 jmp	 $LN32@Insert
$LN31@Insert:

; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  00329	8d 45 9c	 lea	 eax, DWORD PTR $T232115[ebp]
  0032c	50		 push	 eax
  0032d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00330	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00335	50		 push	 eax
  00336	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00339	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  0033e	0f b6 c8	 movzx	 ecx, al
  00341	85 c9		 test	 ecx, ecx
  00343	74 56		 je	 SHORT $LN14@Insert

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00345	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00348	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  0034d	50		 push	 eax
  0034e	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00353	83 c4 04	 add	 esp, 4
  00356	50		 push	 eax
  00357	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00360	83 c4 04	 add	 esp, 4
  00363	50		 push	 eax
  00364	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00367	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0036c	0f b6 c8	 movzx	 ecx, al
  0036f	85 c9		 test	 ecx, ecx
  00371	74 23		 je	 SHORT $LN13@Insert

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00373	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  00376	50		 push	 eax
  00377	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0037a	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  0037f	50		 push	 eax
  00380	6a 01		 push	 1
  00382	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00385	51		 push	 ecx
  00386	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00389	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  0038e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00391	e9 65 02 00 00	 jmp	 $LN34@Insert
$LN13@Insert:

; 1149 : 				}

  00396	e9 41 02 00 00	 jmp	 $LN32@Insert
$LN14@Insert:

; 1150 : 			else if (_Where == end())

  0039b	8d 45 a0	 lea	 eax, DWORD PTR $T232116[ebp]
  0039e	50		 push	 eax
  0039f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a2	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  003a7	50		 push	 eax
  003a8	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  003ab	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  003b0	0f b6 c8	 movzx	 ecx, al
  003b3	85 c9		 test	 ecx, ecx
  003b5	74 5a		 je	 SHORT $LN11@Insert

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  003b7	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  003c0	83 c4 04	 add	 esp, 4
  003c3	50		 push	 eax
  003c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c7	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  003cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  003d4	83 c4 04	 add	 esp, 4
  003d7	50		 push	 eax
  003d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003db	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  003e0	0f b6 d0	 movzx	 edx, al
  003e3	85 d2		 test	 edx, edx
  003e5	74 25		 je	 SHORT $LN10@Insert

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  003e7	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  003ea	50		 push	 eax
  003eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ee	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	51		 push	 ecx
  003f6	6a 00		 push	 0
  003f8	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  003fb	52		 push	 edx
  003fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ff	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  00404	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00407	e9 ef 01 00 00	 jmp	 $LN34@Insert
$LN10@Insert:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,

  0040c	e9 cb 01 00 00	 jmp	 $LN32@Insert
$LN11@Insert:

; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00411	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00414	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  0041f	83 c4 04	 add	 esp, 4
  00422	50		 push	 eax
  00423	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00426	50		 push	 eax
  00427	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  0042c	83 c4 04	 add	 esp, 4
  0042f	50		 push	 eax
  00430	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00433	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00438	0f b6 c8	 movzx	 ecx, al
  0043b	85 c9		 test	 ecx, ecx
  0043d	0f 84 ab 00 00
	00		 je	 $LN8@Insert
  00443	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00446	89 45 f4	 mov	 DWORD PTR __Next$[ebp], eax
  00449	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0044c	51		 push	 ecx
  0044d	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00452	83 c4 04	 add	 esp, 4
  00455	50		 push	 eax
  00456	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00459	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
  0045e	8b c8		 mov	 ecx, eax
  00460	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00465	50		 push	 eax
  00466	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  0046b	83 c4 04	 add	 esp, 4
  0046e	50		 push	 eax
  0046f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00472	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00477	0f b6 d0	 movzx	 edx, al
  0047a	85 d2		 test	 edx, edx
  0047c	74 70		 je	 SHORT $LN8@Insert

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  0047e	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00481	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 00		 mov	 eax, DWORD PTR [eax]
  00491	50		 push	 eax
  00492	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0049d	85 c9		 test	 ecx, ecx
  0049f	74 25		 je	 SHORT $LN7@Insert

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  004a1	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  004a4	50		 push	 eax
  004a5	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  004a8	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  004ad	50		 push	 eax
  004ae	6a 00		 push	 0
  004b0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  004b3	51		 push	 ecx
  004b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  004bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004bf	e9 37 01 00 00	 jmp	 $LN34@Insert

; 1164 : 				else

  004c4	eb 23		 jmp	 SHORT $LN6@Insert
$LN7@Insert:

; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  004c6	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  004c9	50		 push	 eax
  004ca	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  004cd	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  004d2	50		 push	 eax
  004d3	6a 01		 push	 1
  004d5	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  004d8	51		 push	 ecx
  004d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004dc	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  004e1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004e4	e9 12 01 00 00	 jmp	 $LN34@Insert
$LN6@Insert:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,

  004e9	e9 ee 00 00 00	 jmp	 $LN32@Insert
$LN8@Insert:

; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  004ee	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  004f1	50		 push	 eax
  004f2	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  004f7	83 c4 04	 add	 esp, 4
  004fa	50		 push	 eax
  004fb	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  004fe	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00503	50		 push	 eax
  00504	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00509	83 c4 04	 add	 esp, 4
  0050c	50		 push	 eax
  0050d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00510	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00515	0f b6 c8	 movzx	 ecx, al
  00518	85 c9		 test	 ecx, ecx
  0051a	0f 84 bc 00 00
	00		 je	 $LN32@Insert
  00520	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00523	89 45 f4	 mov	 DWORD PTR __Next$[ebp], eax
  00526	8d 4d a4	 lea	 ecx, DWORD PTR $T232117[ebp]
  00529	51		 push	 ecx
  0052a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0052d	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00532	50		 push	 eax
  00533	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  00536	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
  0053b	8b c8		 mov	 ecx, eax
  0053d	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00542	0f b6 d0	 movzx	 edx, al
  00545	85 d2		 test	 edx, edx
  00547	75 2e		 jne	 SHORT $LN3@Insert
  00549	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  0054c	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00557	83 c4 04	 add	 esp, 4
  0055a	50		 push	 eax
  0055b	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0055e	50		 push	 eax
  0055f	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00564	83 c4 04	 add	 esp, 4
  00567	50		 push	 eax
  00568	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056b	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00570	0f b6 c8	 movzx	 ecx, al
  00573	85 c9		 test	 ecx, ecx
  00575	74 65		 je	 SHORT $LN32@Insert
$LN3@Insert:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  00577	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0057a	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  0057f	50		 push	 eax
  00580	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00585	83 c4 04	 add	 esp, 4
  00588	8b 00		 mov	 eax, DWORD PTR [eax]
  0058a	50		 push	 eax
  0058b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00590	83 c4 04	 add	 esp, 4
  00593	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00596	85 c9		 test	 ecx, ecx
  00598	74 22		 je	 SHORT $LN2@Insert

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  0059a	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  0059d	50		 push	 eax
  0059e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  005a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  005a6	50		 push	 eax
  005a7	6a 00		 push	 0
  005a9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  005ac	51		 push	 ecx
  005ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005b0	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  005b5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005b8	eb 41		 jmp	 SHORT $LN34@Insert

; 1175 : 				else

  005ba	eb 20		 jmp	 SHORT $LN32@Insert
$LN2@Insert:

; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  005bc	8b 45 10	 mov	 eax, DWORD PTR __Node$[ebp]
  005bf	50		 push	 eax
  005c0	8d 4d f4	 lea	 ecx, DWORD PTR __Next$[ebp]
  005c3	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  005c8	50		 push	 eax
  005c9	6a 01		 push	 1
  005cb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  005ce	51		 push	 ecx
  005cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005d2	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  005d7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005da	eb 1f		 jmp	 SHORT $LN34@Insert
$LN32@Insert:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  005dc	0f b6 45 f3	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  005e0	50		 push	 eax
  005e1	8b 4d 10	 mov	 ecx, DWORD PTR __Node$[ebp]
  005e4	51		 push	 ecx
  005e5	8d 55 a8	 lea	 edx, DWORD PTR $T232118[ebp]
  005e8	52		 push	 edx
  005e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005ec	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert
  005f1	8b 00		 mov	 eax, DWORD PTR [eax]
  005f3	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  005f6	89 01		 mov	 DWORD PTR [ecx], eax
  005f8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN34@Insert:

; 1181 : 		}

  005fb	5f		 pop	 edi
  005fc	5e		 pop	 esi
  005fd	5b		 pop	 ebx
  005fe	8b e5		 mov	 esp, ebp
  00600	5d		 pop	 ebp
  00601	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z ; std::_Destroy<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z PROC ; std::allocator<std::pair<int const ,int> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z ; std::_Destroy<std::pair<int const ,int> >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z ENDP ; std::allocator<std::pair<int const ,int> >::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 868  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 		return (this->_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 870  : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T232127 = -117						; size = 1
$T232128 = -116						; size = 4
$T232129 = -112						; size = 4
$T232130 = -105						; size = 1
$T232131 = -104						; size = 4
$T232132 = -97						; size = 1
$T232133 = -96						; size = 4
$T232134 = -89						; size = 1
__Where$231329 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert
$LN11@Linsert:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T232127[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T232127[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T232128[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert
$LN8@Linsert:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$231329[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert
$LN6@Linsert:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T232129[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$231329[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T232130[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T232130[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T232131[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert
$LN4@Linsert:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$231329[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
$LN5@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$231329[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T232132[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T232132[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T232133[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert
$LN2@Linsert:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T232134[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T232134[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$231329[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$231362 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert@2

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert@2:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert@2

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert@2
$LN16@Insert@2:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert@2

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert@2

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert@2:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert@2
$LN14@Insert@2:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert@2

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert@2:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$231362[ebp], eax
$LN10@Insert@2:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert@2

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$231362[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert@2

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert@2

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$231362[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert@2
$LN7@Insert@2:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$231362[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert@2

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$231362[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN5@Insert@2:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN6@Insert@2:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert@2
$LN8@Insert@2:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert@2

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$231362[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert@2
$LN3@Insert@2:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$231362[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert@2

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$231362[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN1@Insert@2:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231362[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN4@Insert@2:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert@2
$LN9@Insert@2:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@2:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>

; 209  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$231393 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@3

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@3
$LN8@operator@3:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@3

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@3
$LN4@operator@3:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$231393[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231393[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@3
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$231393[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@3

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$231393[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@3
$LN3@operator@3:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@3

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@3
$LN2@operator@3:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$231393[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@3:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::forward<std::pair<int const ,int> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::forward<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int const ,int> >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z ; std::forward<std::pair<int const ,int> >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int const ,int> >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode
__catch$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@$$CBHH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@$$CBHH@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z PROC ; std::_Destroy<std::pair<int const ,int> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z ENDP ; std::_Destroy<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z ; std::allocator<std::pair<int const ,int> >::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int const ,int> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z ; std::forward<std::pair<int const ,int> >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z ; std::allocator<std::pair<int const ,int> >::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$?0$$CBHH@?$pair@$$CBHH@std@@QAE@$$QAU01@@Z	; std::pair<int const ,int>::pair<int const ,int><int const ,int>
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T232196 = -88						; size = 4
$T232197 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z PROC ; std::allocator<std::pair<int const ,int> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T232197[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T232197[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@$$CBHH@std@@@std@@YA$$QAU?$pair@$$CBHH@0@AAU10@@Z ; std::forward<std::pair<int const ,int> >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T232197[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0$$CBHH@?$pair@$$CBHH@std@@QAE@$$QAU01@@Z ; std::pair<int const ,int>::pair<int const ,int><int const ,int>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T232196[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T232197[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<int const ,int> >::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBHH@std@@QAE@$$QBH$$QAH@Z	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>
PUBLIC	??$forward@$$CBH@std@@YA$$QBHABH@Z		; std::forward<int const >
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0$$CBHH@?$pair@$$CBHH@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0$$CBHH@?$pair@$$CBHH@std@@QAE@$$QAU01@@Z PROC	; std::pair<int const ,int>::pair<int const ,int><int const ,int>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@$$CBH@std@@YA$$QBHABH@Z ; std::forward<int const >
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$_Pair_base@$$CBHH@std@@QAE@$$QBH$$QAH@Z ; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0$$CBHH@?$pair@$$CBHH@std@@QAE@$$QAU01@@Z ENDP	; std::pair<int const ,int>::pair<int const ,int><int const ,int>
_TEXT	ENDS
PUBLIC	??$move@ABH@std@@YA$$QBHABH@Z			; std::move<int const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Pair_base@$$CBHH@std@@QAE@$$QBH$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBHH@std@@QAE@$$QBH$$QAH@Z PROC	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@ABH@std@@YA$$QBHABH@Z ; std::move<int const &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBHH@std@@QAE@$$QBH$$QAH@Z ENDP	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@$$CBH@std@@YA$$QBHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@$$CBH@std@@YA$$QBHABH@Z PROC			; std::forward<int const >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@$$CBH@std@@YA$$QBHABH@Z ENDP			; std::forward<int const >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@ABH@std@@YA$$QBHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@ABH@std@@YA$$QBHABH@Z PROC			; std::move<int const &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@ABH@std@@YA$$QBHABH@Z ENDP			; std::move<int const &>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\jewelofharmonysystem.cpp
;	COMDAT ??__Eg_kJewelOfHarmonySystem@@YAXXZ
text$yc	SEGMENT
??__Eg_kJewelOfHarmonySystem@@YAXXZ PROC		; `dynamic initializer for 'g_kJewelOfHarmonySystem'', COMDAT

; 17   : CJewelOfHarmonySystem g_kJewelOfHarmonySystem;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0000e	e8 00 00 00 00	 call	 ??0CJewelOfHarmonySystem@@QAE@XZ ; CJewelOfHarmonySystem::CJewelOfHarmonySystem
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_kJewelOfHarmonySystem@@YAXXZ ; `dynamic atexit destructor for 'g_kJewelOfHarmonySystem''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_kJewelOfHarmonySystem@@YAXXZ ENDP		; `dynamic initializer for 'g_kJewelOfHarmonySystem''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_kJewelOfHarmonySystem@@YAXXZ
text$yd	SEGMENT
??__Fg_kJewelOfHarmonySystem@@YAXXZ PROC		; `dynamic atexit destructor for 'g_kJewelOfHarmonySystem'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0000e	e8 00 00 00 00	 call	 ??1CJewelOfHarmonySystem@@UAE@XZ ; CJewelOfHarmonySystem::~CJewelOfHarmonySystem
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_kJewelOfHarmonySystem@@YAXXZ ENDP		; `dynamic atexit destructor for 'g_kJewelOfHarmonySystem''
text$yd	ENDS
PUBLIC	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
_BSS	SEGMENT
?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A DB 05374H DUP (?) ; g_kJewelOfHarmonySystem
_BSS	ENDS
CRT$XCU	SEGMENT
_g_kJewelOfHarmonySystem$initializer$ DD FLAT:??__Eg_kJewelOfHarmonySystem@@YAXXZ
CRT$XCU	ENDS
END
