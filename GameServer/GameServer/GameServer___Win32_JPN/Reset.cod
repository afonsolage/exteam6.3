; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\Reset.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back
PUBLIC	??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
PUBLIC	??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@		; `string'
PUBLIC	??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@		; `string'
PUBLIC	??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@		; `string'
PUBLIC	??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@		; `string'
PUBLIC	??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@	; `string'
PUBLIC	??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@		; `string'
PUBLIC	??_C@_03LGLGIONO@cmd?$AA@			; `string'
PUBLIC	??_C@_06DAJLIHEI@?1reset?$AA@			; `string'
PUBLIC	??_C@_0L@JFOEGHOM@DinamicExp?$AA@		; `string'
PUBLIC	??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@		; `string'
PUBLIC	??_C@_09PFIPMMFI@AddWcoinP?$AA@			; `string'
PUBLIC	??_C@_09JEGAINMK@AddWcoinC?$AA@			; `string'
PUBLIC	??_C@_0L@KDJHOFMG@AddCredits?$AA@		; `string'
PUBLIC	??_C@_0M@POBAKBPM@MapForReset?$AA@		; `string'
PUBLIC	??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@		; `string'
PUBLIC	??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@		; `string'
PUBLIC	??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@		; `string'
PUBLIC	??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@		; `string'
PUBLIC	??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@		; `string'
PUBLIC	??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@		; `string'
PUBLIC	??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@		; `string'
PUBLIC	??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@		; `string'
PUBLIC	??_C@_08PFDBLNIM@Add?4Form?$AA@			; `string'
PUBLIC	??_C@_0L@BKBHHLKP@Need?4Level?$AA@		; `string'
PUBLIC	??_C@_08LCGFICFE@Need?4Zen?$AA@			; `string'
PUBLIC	??_C@_07IGJLCBJI@ZenForm?$AA@			; `string'
PUBLIC	??_C@_07BHDMOFNL@Max?4res?$AA@			; `string'
PUBLIC	??_C@_05CCGMLFNG@Reset?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@ ; `string'
PUBLIC	?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear
PUBLIC	?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cResetSystem@@QAEXXZ			; cResetSystem::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Ex_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Ex_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
; File d:\projects\exteam6.3\source\gameserver\gameserver\reset.cpp
CONST	SEGMENT
??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%d %d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@ DB '%d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@
CONST	SEGMENT
??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@ DB 'Reset_NPC_Y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@
CONST	SEGMENT
??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@ DB 'Reset_NPC_X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@
CONST	SEGMENT
??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@ DB 'Reset_NPC_MAP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@
CONST	SEGMENT
??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@ DB 'Reset_NPC_ID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@
CONST	SEGMENT
??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@ DB 'NeedCreditToReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@
CONST	SEGMENT
??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@ DB 'NeedWCoinToReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGLGIONO@cmd?$AA@
CONST	SEGMENT
??_C@_03LGLGIONO@cmd?$AA@ DB 'cmd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAJLIHEI@?1reset?$AA@
CONST	SEGMENT
??_C@_06DAJLIHEI@?1reset?$AA@ DB '/reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFOEGHOM@DinamicExp?$AA@
CONST	SEGMENT
??_C@_0L@JFOEGHOM@DinamicExp?$AA@ DB 'DinamicExp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@
CONST	SEGMENT
??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@ DB 'AddGoblinPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFIPMMFI@AddWcoinP?$AA@
CONST	SEGMENT
??_C@_09PFIPMMFI@AddWcoinP?$AA@ DB 'AddWcoinP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEGAINMK@AddWcoinC?$AA@
CONST	SEGMENT
??_C@_09JEGAINMK@AddWcoinC?$AA@ DB 'AddWcoinC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDJHOFMG@AddCredits?$AA@
CONST	SEGMENT
??_C@_0L@KDJHOFMG@AddCredits?$AA@ DB 'AddCredits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POBAKBPM@MapForReset?$AA@
CONST	SEGMENT
??_C@_0M@POBAKBPM@MapForReset?$AA@ DB 'MapForReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@
CONST	SEGMENT
??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@ DB 'Need.EmptyInv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@
CONST	SEGMENT
??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@ DB 'Add.PointsRF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@
CONST	SEGMENT
??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@ DB 'Add.PointsDL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@
CONST	SEGMENT
??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@ DB 'Add.PointsMG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@
CONST	SEGMENT
??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@ DB 'Add.PointsSUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@
CONST	SEGMENT
??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@ DB 'Add.PointsELF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@
CONST	SEGMENT
??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@ DB 'Add.PointsDK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@
CONST	SEGMENT
??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@ DB 'Add.PointsDW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFDBLNIM@Add?4Form?$AA@
CONST	SEGMENT
??_C@_08PFDBLNIM@Add?4Form?$AA@ DB 'Add.Form', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKBHHLKP@Need?4Level?$AA@
CONST	SEGMENT
??_C@_0L@BKBHHLKP@Need?4Level?$AA@ DB 'Need.Level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LCGFICFE@Need?4Zen?$AA@
CONST	SEGMENT
??_C@_08LCGFICFE@Need?4Zen?$AA@ DB 'Need.Zen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGJLCBJI@ZenForm?$AA@
CONST	SEGMENT
??_C@_07IGJLCBJI@ZenForm?$AA@ DB 'ZenForm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHDMOFNL@Max?4res?$AA@
CONST	SEGMENT
??_C@_07BHDMOFNL@Max?4res?$AA@ DB 'Max.res', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGMLFNG@Reset?$AA@
CONST	SEGMENT
??_C@_05CCGMLFNG@Reset?$AA@ DB 'Reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
CONST	SEGMENT
??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@ DB '..\Data\ExData'
	DB	'\Reset.ini', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_list$231735 = -372					; size = 36
_list$231731 = -336					; size = 28
_n$231727 = -308					; size = 8
_n$231722 = -300					; size = 16
_n$231717 = -284					; size = 8
_Flag$ = -276						; size = 4
_Buff$ = -272						; size = 256
_file$ = -16						; size = 4
_i$231702 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Load@cResetSystem@@QAEXXZ PROC				; cResetSystem::Load
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 01 00
	00		 sub	 esp, 436		; 000001b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : #if(ADD_RESET_WINDOW)
; 28   : 	this->Reset_NPC_ID = 0;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 80 c8 7d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+32200], 0

; 29   : 	this->Reset_NPC_MAP = 0;

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 80 cc 7d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+32204], 0

; 30   : 	this->Reset_NPC_X = 0;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 80 d0 7d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+32208], 0

; 31   : 	this->Reset_NPC_Y = 0;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 80 d4 7d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+32212], 0

; 32   : 
; 33   : 	this->m_needitem.clear();

  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  00056	e8 00 00 00 00	 call	 ?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear

; 34   : 	this->m_reward.clear();

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  00064	e8 00 00 00 00	 call	 ?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear

; 35   : #endif
; 36   : 
; 37   : 	this->EnableResetSystem = GetPrivateProfileInt("Reset","Enable",0,Reset_DIR);	

  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00080	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	89 01		 mov	 DWORD PTR [ecx], eax

; 38   : 	this->Maxres = GetPrivateProfileInt("Reset","Max.res",100,Reset_DIR);

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  0008a	6a 64		 push	 100			; 00000064H
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_07BHDMOFNL@Max?4res?$AA@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 39   : 	this->ZenForm = GetPrivateProfileInt("Reset","ZenForm",0,Reset_DIR);

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  000a7	6a 00		 push	 0
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_07IGJLCBJI@ZenForm?$AA@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 40   : 	this->NeedZen = GetPrivateProfileInt("Reset","Need.Zen",0,Reset_DIR);

  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  000c4	6a 00		 push	 0
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_08LCGFICFE@Need?4Zen?$AA@
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 41   : 	this->NeedLevel = GetPrivateProfileInt("Reset","Need.Level",0,Reset_DIR);

  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  000e1	6a 00		 push	 0
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BKBHHLKP@Need?4Level?$AA@
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 42   : 	this->AddForm = GetPrivateProfileInt("Reset","Add.Form",0,Reset_DIR);

  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  000fe	6a 00		 push	 0
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_08PFDBLNIM@Add?4Form?$AA@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 43   : 	this->AddPointsDW = GetPrivateProfileInt("Reset","Add.PointsDW",0,Reset_DIR);

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  0011b	6a 00		 push	 0
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0012d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 44   : 	this->AddPointsDK = GetPrivateProfileInt("Reset","Add.PointsDK",0,Reset_DIR);

  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00138	6a 00		 push	 0
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 45   : 	this->AddPointsELF = GetPrivateProfileInt("Reset","Add.PointsELF",0,Reset_DIR);

  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00155	6a 00		 push	 0
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 46   : 	this->AddPointsSUM = GetPrivateProfileInt("Reset","Add.PointsSUM",0,Reset_DIR);

  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00172	6a 00		 push	 0
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00184	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 47   : 	this->AddPointsMG = GetPrivateProfileInt("Reset","Add.PointsMG",0,Reset_DIR);

  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  0018f	6a 00		 push	 0
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 48   : 	this->AddPointsDL = GetPrivateProfileInt("Reset","Add.PointsDL",0,Reset_DIR);

  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  001ac	6a 00		 push	 0
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 49   : 	this->AddPointsRF = GetPrivateProfileInt("Reset","Add.PointsRF",0,Reset_DIR);

  001c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  001c9	6a 00		 push	 0
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@
  001d0	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 50   : 	this->NeedEmptyInv = GetPrivateProfileInt("Reset","Need.EmptyInv",1,Reset_DIR);

  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  001e6	6a 01		 push	 1
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 51   : 
; 52   : 	this->m_iMapForReset = GetPrivateProfileInt("Reset","MapForReset",0,Reset_DIR);

  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00203	6a 00		 push	 0
  00205	68 00 00 00 00	 push	 OFFSET ??_C@_0M@POBAKBPM@MapForReset?$AA@
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00215	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00218	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 53   : 
; 54   : 	this->AddCredits = GetPrivateProfileInt("Reset","AddCredits",0,Reset_DIR);

  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00220	6a 00		 push	 0
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KDJHOFMG@AddCredits?$AA@
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00232	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 55   : 	this->AddWcoinC = GetPrivateProfileInt("Reset","AddWcoinC",0,Reset_DIR);

  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  0023d	6a 00		 push	 0
  0023f	68 00 00 00 00	 push	 OFFSET ??_C@_09JEGAINMK@AddWcoinC?$AA@
  00244	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0024f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00252	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 56   : 	this->AddWcoinP = GetPrivateProfileInt("Reset","AddWcoinP",0,Reset_DIR);

  00255	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  0025a	6a 00		 push	 0
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_09PFIPMMFI@AddWcoinP?$AA@
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0026c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 57   : 	this->AddGoblinPoint = GetPrivateProfileInt("Reset","AddGoblinPoint",0,Reset_DIR);

  00272	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00277	6a 00		 push	 0
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00289	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028c	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 58   : 
; 59   : 	this->DinamicExp = GetPrivateProfileInt("Reset","DinamicExp",1,Reset_DIR);

  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00294	6a 01		 push	 1
  00296	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JFOEGHOM@DinamicExp?$AA@
  0029b	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  002a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002a6	85 c0		 test	 eax, eax
  002a8	0f 95 c0	 setne	 al
  002ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ae	88 41 4c	 mov	 BYTE PTR [ecx+76], al

; 60   : 
; 61   : 	GetPrivateProfileString("Reset", "cmd","/reset",this->CommandReset,100,Reset_DIR);

  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  002b6	6a 64		 push	 100			; 00000064H
  002b8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002bb	83 c0 4d	 add	 eax, 77			; 0000004dH
  002be	50		 push	 eax
  002bf	68 00 00 00 00	 push	 OFFSET ??_C@_06DAJLIHEI@?1reset?$AA@
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_03LGLGIONO@cmd?$AA@
  002c9	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 62   : 
; 63   : #ifdef PRIVATE_MODULE
; 64   : 	if(g_ExLicense.CheckUser(eExUB::Local3) || g_ExLicense.CheckUser(SILVER1) || g_ExLicense.CheckUser(SILVER2) || g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::Cherkashin))

  002d4	6a 1c		 push	 28			; 0000001cH
  002d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  002db	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  002e0	0f b6 c0	 movzx	 eax, al
  002e3	85 c0		 test	 eax, eax
  002e5	75 4c		 jne	 SHORT $LN20@Load
  002e7	6a 07		 push	 7
  002e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  002ee	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  002f3	0f b6 c0	 movzx	 eax, al
  002f6	85 c0		 test	 eax, eax
  002f8	75 39		 jne	 SHORT $LN20@Load
  002fa	6a 08		 push	 8
  002fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00301	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00306	0f b6 c0	 movzx	 eax, al
  00309	85 c0		 test	 eax, eax
  0030b	75 26		 jne	 SHORT $LN20@Load
  0030d	6a 01		 push	 1
  0030f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00314	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00319	0f b6 c0	 movzx	 eax, al
  0031c	85 c0		 test	 eax, eax
  0031e	75 13		 jne	 SHORT $LN20@Load
  00320	6a 12		 push	 18			; 00000012H
  00322	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00327	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0032c	0f b6 c0	 movzx	 eax, al
  0032f	85 c0		 test	 eax, eax
  00331	74 40		 je	 SHORT $LN21@Load
$LN20@Load:

; 65   : 		{
; 66   : 		this->NeedWCoinToReset = GetPrivateProfileInt("Reset","NeedWCoinToReset",0,Reset_DIR);

  00333	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00338	6a 00		 push	 0
  0033a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0034a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034d	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax

; 67   : 		
; 68   : #if _CONFLICT_
; 69   : 		this->NeedCreditToReset = GetPrivateProfileInt("Reset","NeedCreditToReset",0,Reset_DIR);

  00353	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00358	6a 00		 push	 0
  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0036a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0036d	89 81 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], eax
$LN21@Load:

; 70   : #endif
; 71   : 		
; 72   : 		}
; 73   : #endif
; 74   : #if(ADD_RESET_WINDOW)
; 75   : 	this->Reset_NPC_ID = GetPrivateProfileInt("Reset", "Reset_NPC_ID", 0, Reset_DIR);

  00373	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00378	6a 00		 push	 0
  0037a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@
  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00384	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0038a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0038d	89 81 c8 7d 00
	00		 mov	 DWORD PTR [ecx+32200], eax

; 76   : 	this->Reset_NPC_MAP = GetPrivateProfileInt("Reset", "Reset_NPC_MAP", 0, Reset_DIR);

  00393	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  00398	6a 00		 push	 0
  0039a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  003a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  003aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ad	89 81 cc 7d 00
	00		 mov	 DWORD PTR [ecx+32204], eax

; 77   : 	this->Reset_NPC_X = GetPrivateProfileInt("Reset", "Reset_NPC_X", 0, Reset_DIR);

  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  003b8	6a 00		 push	 0
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@
  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  003c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  003ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003cd	89 81 d0 7d 00
	00		 mov	 DWORD PTR [ecx+32208], eax

; 78   : 	this->Reset_NPC_Y = GetPrivateProfileInt("Reset", "Reset_NPC_Y", 0, Reset_DIR);

  003d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  003d8	6a 00		 push	 0
  003da	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@
  003df	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  003e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  003ea	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ed	89 81 d4 7d 00
	00		 mov	 DWORD PTR [ecx+32212], eax

; 79   : #endif
; 80   : 
; 81   : 	for(int i(0);i<RESET_EXP_MAX_RES;i++)

  003f3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231702[ebp], 0
  003fa	eb 09		 jmp	 SHORT $LN19@Load
$LN18@Load:
  003fc	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  003ff	83 c0 01	 add	 eax, 1
  00402	89 45 f4	 mov	 DWORD PTR _i$231702[ebp], eax
$LN19@Load:
  00405	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _i$231702[ebp], 1000 ; 000003e8H
  0040c	0f 8d 99 00 00
	00		 jge	 $LN17@Load

; 82   : 	{
; 83   : 		this->Number[i].Res = 0;

  00412	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  00415	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00418	c7 84 c1 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*8+188], 0

; 84   : 		this->Number[i].Exp = 0;

  00423	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  00426	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00429	c7 84 c1 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*8+192], 0

; 85   : 		
; 86   : #ifdef PRIVATE_MODULE
; 87   : 		this->ItemsRes[i].ItemCount = 0;

  00434	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  00437	c1 e0 04	 shl	 eax, 4
  0043a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0043d	c7 84 01 0c 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+8204], 0

; 88   : 		this->ItemsRes[i].ItemIndex = 0;

  00448	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  0044b	c1 e0 04	 shl	 eax, 4
  0044e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00451	c7 84 01 08 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+8200], 0

; 89   : 		this->ItemsRes[i].ItemType = 0;

  0045c	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  0045f	c1 e0 04	 shl	 eax, 4
  00462	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00465	c7 84 01 04 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+8196], 0

; 90   : 		this->ItemsRes[i].Res = 0;

  00470	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  00473	c1 e0 04	 shl	 eax, 4
  00476	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00479	c7 84 01 00 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+8192], 0

; 91   : 		this->LevelRes[i].Res = 0;

  00484	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  00487	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0048a	c7 84 c1 84 5e
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*8+24196], 0

; 92   : 		this->LevelRes[i].Level = 0;

  00495	8b 45 f4	 mov	 eax, DWORD PTR _i$231702[ebp]
  00498	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0049b	c7 84 c1 88 5e
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*8+24200], 0

; 93   : #endif
; 94   : 	}

  004a6	e9 51 ff ff ff	 jmp	 $LN18@Load
$LN17@Load:

; 95   : 	FILE * file = fopen(Reset_DIR,"r");

  004ab	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  004b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  004b5	e8 00 00 00 00	 call	 _fopen
  004ba	83 c4 08	 add	 esp, 8
  004bd	89 45 f0	 mov	 DWORD PTR _file$[ebp], eax

; 96   : 	if(file == NULL)

  004c0	83 7d f0 00	 cmp	 DWORD PTR _file$[ebp], 0
  004c4	75 1c		 jne	 SHORT $LN16@Load

; 97   : 	{
; 98   : 		MessageBoxA(0,Reset_DIR,"LOAD FILE ERROR",0);

  004c6	6a 00		 push	 0
  004c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  004cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EHHHJCEO@?4?4?2Data?2ExData?2Reset?4ini?$AA@
  004d2	6a 00		 push	 0
  004d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 99   : 		ExitProcess(0);

  004da	6a 00		 push	 0
  004dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN16@Load:

; 100  : 	}
; 101  : 
; 102  : 	char Buff[256];
; 103  : 	int Flag = 0;

  004e2	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _Flag$[ebp], 0

; 104  : 	this->rCount = 0;

  004ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004ef	c7 80 fc 1f 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+8188], 0

; 105  : 	this->iCount = 0;

  004f9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004fc	c7 80 80 5e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+24192], 0

; 106  : 	this->lCount = 0;

  00506	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00509	c7 80 c4 7d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+32196], 0
$LN15@Load:

; 107  : 
; 108  : 	while(!feof(file))

  00513	8b 45 f0	 mov	 eax, DWORD PTR _file$[ebp]
  00516	50		 push	 eax
  00517	e8 00 00 00 00	 call	 _feof
  0051c	83 c4 04	 add	 esp, 4
  0051f	85 c0		 test	 eax, eax
  00521	0f 85 5f 06 00
	00		 jne	 $LN14@Load

; 109  : 	{
; 110  : 		fgets(Buff,256,file);

  00527	8b 45 f0	 mov	 eax, DWORD PTR _file$[ebp]
  0052a	50		 push	 eax
  0052b	68 00 01 00 00	 push	 256			; 00000100H
  00530	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00536	51		 push	 ecx
  00537	e8 00 00 00 00	 call	 _fgets
  0053c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 		if(Ex_IsBadFileLine(Buff, Flag))

  0053f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _Flag$[ebp]
  00545	50		 push	 eax
  00546	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  0054c	51		 push	 ecx
  0054d	e8 00 00 00 00	 call	 ?Ex_IsBadFileLine@@YA_NPADAAH@Z ; Ex_IsBadFileLine
  00552	83 c4 08	 add	 esp, 8
  00555	0f b6 d0	 movzx	 edx, al
  00558	85 d2		 test	 edx, edx
  0055a	74 02		 je	 SHORT $LN13@Load

; 112  : 			continue;

  0055c	eb b5		 jmp	 SHORT $LN15@Load
$LN13@Load:

; 113  : 		if(Flag == 1)

  0055e	83 bd ec fe ff
	ff 01		 cmp	 DWORD PTR _Flag$[ebp], 1
  00565	75 69		 jne	 SHORT $LN12@Load

; 114  : 		{
; 115  : 			int n[2];
; 116  : 			sscanf(Buff, "%d %d", &n[0], &n[1]);

  00567	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _n$231717[ebp+4]
  0056d	50		 push	 eax
  0056e	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$231717[ebp]
  00574	51		 push	 ecx
  00575	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  0057a	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00580	52		 push	 edx
  00581	e8 00 00 00 00	 call	 _sscanf
  00586	83 c4 10	 add	 esp, 16			; 00000010H

; 117  : 			this->Number[this->rCount].Res = n[0];

  00589	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0058c	8b 88 fc 1f 00
	00		 mov	 ecx, DWORD PTR [eax+8188]
  00592	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00595	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _n$231717[ebp]
  0059b	89 84 ca bc 00
	00 00		 mov	 DWORD PTR [edx+ecx*8+188], eax

; 118  : 			this->Number[this->rCount].Exp = n[1];

  005a2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005a5	8b 88 fc 1f 00
	00		 mov	 ecx, DWORD PTR [eax+8188]
  005ab	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005ae	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$231717[ebp+4]
  005b4	89 84 ca c0 00
	00 00		 mov	 DWORD PTR [edx+ecx*8+192], eax

; 119  : 			this->rCount++;

  005bb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005be	8b 88 fc 1f 00
	00		 mov	 ecx, DWORD PTR [eax+8188]
  005c4	83 c1 01	 add	 ecx, 1
  005c7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005ca	89 8a fc 1f 00
	00		 mov	 DWORD PTR [edx+8188], ecx
$LN12@Load:

; 120  : 		}
; 121  : #ifdef PRIVATE_MODULE
; 122  : 		if(g_ExLicense.CheckUser(eExUB::Vadim) || g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::Local3) || 
; 123  : 			g_ExLicense.CheckUser(eExUB::Cherkashin) || g_ExLicense.CheckUser(eExUB::EpicMU) || 
; 124  : 			g_ExLicense.CheckUser(Gredy) || g_ExLicense.CheckUser(Gredy2) || g_ExLicense.CheckUser(GredyLocal))

  005d0	6a 09		 push	 9
  005d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  005d7	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  005dc	0f b6 c0	 movzx	 eax, al
  005df	85 c0		 test	 eax, eax
  005e1	0f 85 89 00 00
	00		 jne	 $LN10@Load
  005e7	6a 01		 push	 1
  005e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  005ee	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  005f3	0f b6 c0	 movzx	 eax, al
  005f6	85 c0		 test	 eax, eax
  005f8	75 76		 jne	 SHORT $LN10@Load
  005fa	6a 1c		 push	 28			; 0000001cH
  005fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00601	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00606	0f b6 c0	 movzx	 eax, al
  00609	85 c0		 test	 eax, eax
  0060b	75 63		 jne	 SHORT $LN10@Load
  0060d	6a 12		 push	 18			; 00000012H
  0060f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00614	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00619	0f b6 c0	 movzx	 eax, al
  0061c	85 c0		 test	 eax, eax
  0061e	75 50		 jne	 SHORT $LN10@Load
  00620	6a 3b		 push	 59			; 0000003bH
  00622	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00627	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0062c	0f b6 c0	 movzx	 eax, al
  0062f	85 c0		 test	 eax, eax
  00631	75 3d		 jne	 SHORT $LN10@Load
  00633	6a 20		 push	 32			; 00000020H
  00635	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0063a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0063f	0f b6 c0	 movzx	 eax, al
  00642	85 c0		 test	 eax, eax
  00644	75 2a		 jne	 SHORT $LN10@Load
  00646	6a 22		 push	 34			; 00000022H
  00648	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0064d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00652	0f b6 c0	 movzx	 eax, al
  00655	85 c0		 test	 eax, eax
  00657	75 17		 jne	 SHORT $LN10@Load
  00659	6a 21		 push	 33			; 00000021H
  0065b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00660	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00665	0f b6 c0	 movzx	 eax, al
  00668	85 c0		 test	 eax, eax
  0066a	0f 84 c2 00 00
	00		 je	 $LN11@Load
$LN10@Load:

; 125  : 		{
; 126  : 			if(Flag == 2)

  00670	83 bd ec fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  00677	0f 85 b5 00 00
	00		 jne	 $LN11@Load

; 127  : 			{
; 128  : 				int n[4];
; 129  : 				sscanf(Buff, "%d %d %d %d", &n[0], &n[1], &n[2], &n[3]);

  0067d	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _n$231722[ebp+12]
  00683	50		 push	 eax
  00684	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _n$231722[ebp+8]
  0068a	51		 push	 ecx
  0068b	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _n$231722[ebp+4]
  00691	52		 push	 edx
  00692	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _n$231722[ebp]
  00698	50		 push	 eax
  00699	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0069e	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  006a4	51		 push	 ecx
  006a5	e8 00 00 00 00	 call	 _sscanf
  006aa	83 c4 18	 add	 esp, 24			; 00000018H

; 130  : 				this->ItemsRes[this->iCount].Res = n[0];

  006ad	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006b0	8b 88 80 5e 00
	00		 mov	 ecx, DWORD PTR [eax+24192]
  006b6	c1 e1 04	 shl	 ecx, 4
  006b9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006bc	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _n$231722[ebp]
  006c2	89 84 0a 00 20
	00 00		 mov	 DWORD PTR [edx+ecx+8192], eax

; 131  : 				this->ItemsRes[this->iCount].ItemType = n[1];

  006c9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006cc	8b 88 80 5e 00
	00		 mov	 ecx, DWORD PTR [eax+24192]
  006d2	c1 e1 04	 shl	 ecx, 4
  006d5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006d8	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _n$231722[ebp+4]
  006de	89 84 0a 04 20
	00 00		 mov	 DWORD PTR [edx+ecx+8196], eax

; 132  : 				this->ItemsRes[this->iCount].ItemIndex = n[2];

  006e5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006e8	8b 88 80 5e 00
	00		 mov	 ecx, DWORD PTR [eax+24192]
  006ee	c1 e1 04	 shl	 ecx, 4
  006f1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006f4	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$231722[ebp+8]
  006fa	89 84 0a 08 20
	00 00		 mov	 DWORD PTR [edx+ecx+8200], eax

; 133  : 				this->ItemsRes[this->iCount].ItemCount = n[3];

  00701	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00704	8b 88 80 5e 00
	00		 mov	 ecx, DWORD PTR [eax+24192]
  0070a	c1 e1 04	 shl	 ecx, 4
  0070d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00710	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _n$231722[ebp+12]
  00716	89 84 0a 0c 20
	00 00		 mov	 DWORD PTR [edx+ecx+8204], eax

; 134  : 				this->iCount++;

  0071d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00720	8b 88 80 5e 00
	00		 mov	 ecx, DWORD PTR [eax+24192]
  00726	83 c1 01	 add	 ecx, 1
  00729	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0072c	89 8a 80 5e 00
	00		 mov	 DWORD PTR [edx+24192], ecx
$LN11@Load:

; 135  : 			}
; 136  : 		}
; 137  : 		if(g_ExLicense.CheckUser(eExUB::Local) || 
; 138  : 			g_ExLicense.CheckUser(eExUB::ulasevich) || 
; 139  : 			g_ExLicense.CheckUser(eExUB::Cherkashin) || 
; 140  : 			g_ExLicense.CheckUser(eExUB::Local3) || 
; 141  : 			g_ExLicense.CheckUser(eExUB::MU2Play) || g_ExLicense.CheckUser(eExUB::Sentinel) || g_ExLicense.CheckUser(eExUB::EpicMU) || g_ExLicense.CheckUser(eExUB::AlterMU) ||
; 142  : 			g_ExLicense.CheckUser(eExUB::EpicMU) || g_ExLicense.CheckUser(eExUB::Escalate) || g_ExLicense.CheckUser(eExUB::eternalmu) ||
; 143  : 			g_ExLicense.CheckUser(eExUB::Gredy) ||
; 144  : 			g_ExLicense.CheckUser(eExUB::Gredy2) || 
; 145  : 			g_ExLicense.CheckUser(eExUB::GredyLocal) ||
; 146  : 			g_ExLicense.CheckUser(eExUB::mu4you) ||
; 147  : 			g_ExLicense.CheckUser(eExUB::NSGames))

  00732	6a 00		 push	 0
  00734	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00739	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0073e	0f b6 c0	 movzx	 eax, al
  00741	85 c0		 test	 eax, eax
  00743	0f 85 3d 01 00
	00		 jne	 $LN7@Load
  00749	6a 17		 push	 23			; 00000017H
  0074b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00750	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00755	0f b6 c0	 movzx	 eax, al
  00758	85 c0		 test	 eax, eax
  0075a	0f 85 26 01 00
	00		 jne	 $LN7@Load
  00760	6a 12		 push	 18			; 00000012H
  00762	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00767	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0076c	0f b6 c0	 movzx	 eax, al
  0076f	85 c0		 test	 eax, eax
  00771	0f 85 0f 01 00
	00		 jne	 $LN7@Load
  00777	6a 1c		 push	 28			; 0000001cH
  00779	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0077e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00783	0f b6 c0	 movzx	 eax, al
  00786	85 c0		 test	 eax, eax
  00788	0f 85 f8 00 00
	00		 jne	 $LN7@Load
  0078e	6a 36		 push	 54			; 00000036H
  00790	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00795	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0079a	0f b6 c0	 movzx	 eax, al
  0079d	85 c0		 test	 eax, eax
  0079f	0f 85 e1 00 00
	00		 jne	 $LN7@Load
  007a5	6a 38		 push	 56			; 00000038H
  007a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007ac	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007b1	0f b6 c0	 movzx	 eax, al
  007b4	85 c0		 test	 eax, eax
  007b6	0f 85 ca 00 00
	00		 jne	 $LN7@Load
  007bc	6a 3b		 push	 59			; 0000003bH
  007be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007c3	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007c8	0f b6 c0	 movzx	 eax, al
  007cb	85 c0		 test	 eax, eax
  007cd	0f 85 b3 00 00
	00		 jne	 $LN7@Load
  007d3	6a 3e		 push	 62			; 0000003eH
  007d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007da	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007df	0f b6 c0	 movzx	 eax, al
  007e2	85 c0		 test	 eax, eax
  007e4	0f 85 9c 00 00
	00		 jne	 $LN7@Load
  007ea	6a 3b		 push	 59			; 0000003bH
  007ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007f1	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007f6	0f b6 c0	 movzx	 eax, al
  007f9	85 c0		 test	 eax, eax
  007fb	0f 85 85 00 00
	00		 jne	 $LN7@Load
  00801	6a 40		 push	 64			; 00000040H
  00803	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00808	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0080d	0f b6 c0	 movzx	 eax, al
  00810	85 c0		 test	 eax, eax
  00812	75 72		 jne	 SHORT $LN7@Load
  00814	6a 4f		 push	 79			; 0000004fH
  00816	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0081b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00820	0f b6 c0	 movzx	 eax, al
  00823	85 c0		 test	 eax, eax
  00825	75 5f		 jne	 SHORT $LN7@Load
  00827	6a 20		 push	 32			; 00000020H
  00829	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0082e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00833	0f b6 c0	 movzx	 eax, al
  00836	85 c0		 test	 eax, eax
  00838	75 4c		 jne	 SHORT $LN7@Load
  0083a	6a 22		 push	 34			; 00000022H
  0083c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00841	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00846	0f b6 c0	 movzx	 eax, al
  00849	85 c0		 test	 eax, eax
  0084b	75 39		 jne	 SHORT $LN7@Load
  0084d	6a 21		 push	 33			; 00000021H
  0084f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00854	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00859	0f b6 c0	 movzx	 eax, al
  0085c	85 c0		 test	 eax, eax
  0085e	75 26		 jne	 SHORT $LN7@Load
  00860	6a 4e		 push	 78			; 0000004eH
  00862	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00867	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0086c	0f b6 c0	 movzx	 eax, al
  0086f	85 c0		 test	 eax, eax
  00871	75 13		 jne	 SHORT $LN7@Load
  00873	6a 51		 push	 81			; 00000051H
  00875	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0087a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0087f	0f b6 c0	 movzx	 eax, al
  00882	85 c0		 test	 eax, eax
  00884	74 72		 je	 SHORT $LN8@Load
$LN7@Load:

; 148  : 		{
; 149  : 			if(Flag == 3)

  00886	83 bd ec fe ff
	ff 03		 cmp	 DWORD PTR _Flag$[ebp], 3
  0088d	75 69		 jne	 SHORT $LN8@Load

; 150  : 			{
; 151  : 				int n[2];
; 152  : 				sscanf(Buff, "%d %d", &n[0], &n[1]);

  0088f	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _n$231727[ebp+4]
  00895	50		 push	 eax
  00896	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _n$231727[ebp]
  0089c	51		 push	 ecx
  0089d	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  008a2	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  008a8	52		 push	 edx
  008a9	e8 00 00 00 00	 call	 _sscanf
  008ae	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 				this->LevelRes[this->lCount].Res = n[0];

  008b1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008b4	8b 88 c4 7d 00
	00		 mov	 ecx, DWORD PTR [eax+32196]
  008ba	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  008bd	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _n$231727[ebp]
  008c3	89 84 ca 84 5e
	00 00		 mov	 DWORD PTR [edx+ecx*8+24196], eax

; 154  : 				this->LevelRes[this->lCount].Level = n[1];

  008ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008cd	8b 88 c4 7d 00
	00		 mov	 ecx, DWORD PTR [eax+32196]
  008d3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  008d6	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _n$231727[ebp+4]
  008dc	89 84 ca 88 5e
	00 00		 mov	 DWORD PTR [edx+ecx*8+24200], eax

; 155  : 				this->lCount++;

  008e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008e6	8b 88 c4 7d 00
	00		 mov	 ecx, DWORD PTR [eax+32196]
  008ec	83 c1 01	 add	 ecx, 1
  008ef	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  008f2	89 8a c4 7d 00
	00		 mov	 DWORD PTR [edx+32196], ecx
$LN8@Load:

; 156  : 			}
; 157  : 		}
; 158  : 		if(g_ExLicense.CheckUser(eExUB::Local) || g_ExLicense.CheckUser(eExUB::ulasevich) || g_ExLicense.CheckUser(eExUB::ulasevich2) || g_ExLicense.CheckUser(eExUB::MU2Play)
; 159  : 			 || g_ExLicense.CheckUser(eExUB::Sentinel) || g_ExLicense.CheckUser(eExUB::EpicMU) ||
; 160  : 				g_ExLicense.CheckUser(eExUB::Gredy) ||
; 161  : 				g_ExLicense.CheckUser(eExUB::Gredy2) || 
; 162  : 				g_ExLicense.CheckUser(eExUB::GredyLocal) || g_ExLicense.CheckUser(eExUB::Escalate) || g_ExLicense.CheckUser(eExUB::eternalmu) ||
; 163  : 				g_ExLicense.CheckUser(eExUB::Artem) || g_ExLicense.CheckUser(eExUB::Artem2) ||
; 164  : 				g_ExLicense.CheckUser(eExUB::RevoMU) || g_ExLicense.CheckUser(eExUB::GloryMU) ||
; 165  : 				g_ExLicense.CheckUser(eExUB::MedoniAndrei) ||
; 166  : 				g_ExLicense.CheckUser(eExUB::mu4you) || g_ExLicense.CheckUser(eExUB::NSGames))

  008f8	6a 00		 push	 0
  008fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  008ff	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00904	0f b6 c0	 movzx	 eax, al
  00907	85 c0		 test	 eax, eax
  00909	0f 85 6f 01 00
	00		 jne	 $LN4@Load
  0090f	6a 17		 push	 23			; 00000017H
  00911	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00916	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0091b	0f b6 c0	 movzx	 eax, al
  0091e	85 c0		 test	 eax, eax
  00920	0f 85 58 01 00
	00		 jne	 $LN4@Load
  00926	6a 24		 push	 36			; 00000024H
  00928	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0092d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00932	0f b6 c0	 movzx	 eax, al
  00935	85 c0		 test	 eax, eax
  00937	0f 85 41 01 00
	00		 jne	 $LN4@Load
  0093d	6a 36		 push	 54			; 00000036H
  0093f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00944	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00949	0f b6 c0	 movzx	 eax, al
  0094c	85 c0		 test	 eax, eax
  0094e	0f 85 2a 01 00
	00		 jne	 $LN4@Load
  00954	6a 38		 push	 56			; 00000038H
  00956	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0095b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00960	0f b6 c0	 movzx	 eax, al
  00963	85 c0		 test	 eax, eax
  00965	0f 85 13 01 00
	00		 jne	 $LN4@Load
  0096b	6a 3b		 push	 59			; 0000003bH
  0096d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00972	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00977	0f b6 c0	 movzx	 eax, al
  0097a	85 c0		 test	 eax, eax
  0097c	0f 85 fc 00 00
	00		 jne	 $LN4@Load
  00982	6a 20		 push	 32			; 00000020H
  00984	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00989	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0098e	0f b6 c0	 movzx	 eax, al
  00991	85 c0		 test	 eax, eax
  00993	0f 85 e5 00 00
	00		 jne	 $LN4@Load
  00999	6a 22		 push	 34			; 00000022H
  0099b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009a0	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009a5	0f b6 c0	 movzx	 eax, al
  009a8	85 c0		 test	 eax, eax
  009aa	0f 85 ce 00 00
	00		 jne	 $LN4@Load
  009b0	6a 21		 push	 33			; 00000021H
  009b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009b7	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009bc	0f b6 c0	 movzx	 eax, al
  009bf	85 c0		 test	 eax, eax
  009c1	0f 85 b7 00 00
	00		 jne	 $LN4@Load
  009c7	6a 40		 push	 64			; 00000040H
  009c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009ce	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009d3	0f b6 c0	 movzx	 eax, al
  009d6	85 c0		 test	 eax, eax
  009d8	0f 85 a0 00 00
	00		 jne	 $LN4@Load
  009de	6a 4f		 push	 79			; 0000004fH
  009e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009e5	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009ea	0f b6 c0	 movzx	 eax, al
  009ed	85 c0		 test	 eax, eax
  009ef	0f 85 89 00 00
	00		 jne	 $LN4@Load
  009f5	6a 30		 push	 48			; 00000030H
  009f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009fc	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a01	0f b6 c0	 movzx	 eax, al
  00a04	85 c0		 test	 eax, eax
  00a06	75 76		 jne	 SHORT $LN4@Load
  00a08	6a 31		 push	 49			; 00000031H
  00a0a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a0f	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a14	0f b6 c0	 movzx	 eax, al
  00a17	85 c0		 test	 eax, eax
  00a19	75 63		 jne	 SHORT $LN4@Load
  00a1b	6a 43		 push	 67			; 00000043H
  00a1d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a22	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a27	0f b6 c0	 movzx	 eax, al
  00a2a	85 c0		 test	 eax, eax
  00a2c	75 50		 jne	 SHORT $LN4@Load
  00a2e	6a 46		 push	 70			; 00000046H
  00a30	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a35	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a3a	0f b6 c0	 movzx	 eax, al
  00a3d	85 c0		 test	 eax, eax
  00a3f	75 3d		 jne	 SHORT $LN4@Load
  00a41	6a 32		 push	 50			; 00000032H
  00a43	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a48	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a4d	0f b6 c0	 movzx	 eax, al
  00a50	85 c0		 test	 eax, eax
  00a52	75 2a		 jne	 SHORT $LN4@Load
  00a54	6a 4e		 push	 78			; 0000004eH
  00a56	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a5b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a60	0f b6 c0	 movzx	 eax, al
  00a63	85 c0		 test	 eax, eax
  00a65	75 17		 jne	 SHORT $LN4@Load
  00a67	6a 51		 push	 81			; 00000051H
  00a69	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a6e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a73	0f b6 c0	 movzx	 eax, al
  00a76	85 c0		 test	 eax, eax
  00a78	0f 84 03 01 00
	00		 je	 $LN5@Load
$LN4@Load:

; 167  : 		{
; 168  : 			if(Flag == 4)

  00a7e	83 bd ec fe ff
	ff 04		 cmp	 DWORD PTR _Flag$[ebp], 4
  00a85	75 74		 jne	 SHORT $LN3@Load

; 169  : 			{
; 170  : 				RESET_NEEDITEM_DATA list;
; 171  : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d", &list.ResetNum,&list.Type,&list.Index,&list.Level,&list.Skill,&list.Luck,&list.Opt,&list.Exl,&list.Anc,&list.Count);

  00a87	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _list$231731[ebp+24]
  00a8d	50		 push	 eax
  00a8e	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _list$231731[ebp+20]
  00a94	51		 push	 ecx
  00a95	8d 95 c3 fe ff
	ff		 lea	 edx, DWORD PTR _list$231731[ebp+19]
  00a9b	52		 push	 edx
  00a9c	8d 85 c2 fe ff
	ff		 lea	 eax, DWORD PTR _list$231731[ebp+18]
  00aa2	50		 push	 eax
  00aa3	8d 8d c1 fe ff
	ff		 lea	 ecx, DWORD PTR _list$231731[ebp+17]
  00aa9	51		 push	 ecx
  00aaa	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _list$231731[ebp+16]
  00ab0	52		 push	 edx
  00ab1	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _list$231731[ebp+12]
  00ab7	50		 push	 eax
  00ab8	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _list$231731[ebp+8]
  00abe	51		 push	 ecx
  00abf	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _list$231731[ebp+4]
  00ac5	52		 push	 edx
  00ac6	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _list$231731[ebp]
  00acc	50		 push	 eax
  00acd	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00ad2	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00ad8	51		 push	 ecx
  00ad9	e8 00 00 00 00	 call	 _sscanf
  00ade	83 c4 30	 add	 esp, 48			; 00000030H

; 172  : 				this->m_needitem.push_back(list);

  00ae1	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _list$231731[ebp]
  00ae7	50		 push	 eax
  00ae8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00aeb	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  00af1	e8 00 00 00 00	 call	 ?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
  00af6	e9 86 00 00 00	 jmp	 $LN5@Load
$LN3@Load:

; 173  : 			}
; 174  : 			else if(Flag == 5)

  00afb	83 bd ec fe ff
	ff 05		 cmp	 DWORD PTR _Flag$[ebp], 5
  00b02	75 7d		 jne	 SHORT $LN5@Load

; 175  : 			{
; 176  : 				RESET_REWARD_DATA list;
; 177  : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d %d %d",&list.ResetNum,&list.WcoinC,&list.EnableItem,&list.Type,&list.Index,&list.Level,&list.Skill,&list.Luck,&list.Opt,&list.Exl,&list.Anc,&list.Credit);

  00b04	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _list$231735[ebp+32]
  00b0a	50		 push	 eax
  00b0b	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _list$231735[ebp+28]
  00b11	51		 push	 ecx
  00b12	8d 95 a7 fe ff
	ff		 lea	 edx, DWORD PTR _list$231735[ebp+27]
  00b18	52		 push	 edx
  00b19	8d 85 a6 fe ff
	ff		 lea	 eax, DWORD PTR _list$231735[ebp+26]
  00b1f	50		 push	 eax
  00b20	8d 8d a5 fe ff
	ff		 lea	 ecx, DWORD PTR _list$231735[ebp+25]
  00b26	51		 push	 ecx
  00b27	8d 95 a4 fe ff
	ff		 lea	 edx, DWORD PTR _list$231735[ebp+24]
  00b2d	52		 push	 edx
  00b2e	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _list$231735[ebp+20]
  00b34	50		 push	 eax
  00b35	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _list$231735[ebp+16]
  00b3b	51		 push	 ecx
  00b3c	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR _list$231735[ebp+12]
  00b42	52		 push	 edx
  00b43	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _list$231735[ebp+8]
  00b49	50		 push	 eax
  00b4a	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _list$231735[ebp+4]
  00b50	51		 push	 ecx
  00b51	8d 95 8c fe ff
	ff		 lea	 edx, DWORD PTR _list$231735[ebp]
  00b57	52		 push	 edx
  00b58	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  00b5d	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00b63	50		 push	 eax
  00b64	e8 00 00 00 00	 call	 _sscanf
  00b69	83 c4 38	 add	 esp, 56			; 00000038H

; 178  : 				this->m_reward.push_back(list);

  00b6c	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _list$231735[ebp]
  00b72	50		 push	 eax
  00b73	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b76	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  00b7c	e8 00 00 00 00	 call	 ?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back
$LN5@Load:

; 179  : 			}
; 180  : 		}
; 181  : #endif
; 182  : 	}

  00b81	e9 8d f9 ff ff	 jmp	 $LN15@Load
$LN14@Load:

; 183  : 	fclose(file);

  00b86	8b 45 f0	 mov	 eax, DWORD PTR _file$[ebp]
  00b89	50		 push	 eax
  00b8a	e8 00 00 00 00	 call	 _fclose
  00b8f	83 c4 04	 add	 esp, 4
$LN23@Load:

; 184  : }

  00b92	5f		 pop	 edi
  00b93	5e		 pop	 esi
  00b94	5b		 pop	 ebx
  00b95	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b98	33 cd		 xor	 ecx, ebp
  00b9a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b9f	8b e5		 mov	 esp, ebp
  00ba1	5d		 pop	 ebp
  00ba2	c3		 ret	 0
?Load@cResetSystem@@QAEXXZ ENDP				; cResetSystem::Load
_TEXT	ENDS
PUBLIC	??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@ ; `string'
PUBLIC	?ExResetSystemFunciton@cResetSystem@@QAEXH@Z	; cResetSystem::ExResetSystemFunciton
EXTRN	?ResetUp@CAchievements@@QAEXH@Z:PROC		; CAchievements::ResetUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
EXTRN	?ExConfig@@3VcExConfigs@@A:BYTE			; ExConfig
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; ResetSystemGC_CharUpdate
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?GCManaSend@@YAXHHEEH@Z:PROC			; GCManaSend
EXTRN	?GCReFillSend@@YAXHHEEH@Z:PROC			; GCReFillSend
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?ExFireCracker@@YAXHEE@Z:PROC			; ExFireCracker
EXTRN	?gGrandReset@@3VcGrandReset@@A:BYTE		; gGrandReset
EXTRN	?ExUserDataSend@@YAXH@Z:PROC			; ExUserDataSend
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?gObjDeleteItemsCount@@YAHHFFH@Z:PROC		; gObjDeleteItemsCount
EXTRN	?gObjGetItemCountInInventory@@YAHHHH@Z:PROC	; gObjGetItemCountInInventory
EXTRN	?ReturnCalc@cSystemOfRage@@QAEHHHH@Z:PROC	; cSystemOfRage::ReturnCalc
EXTRN	?gSystemOfRage@@3VcSystemOfRage@@A:BYTE		; gSystemOfRage
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
EXTRN	?GetText@CExText@@QAEPADH@Z:PROC		; CExText::GetText
EXTRN	?g_ExText@@3VCExText@@A:BYTE			; g_ExText
EXTRN	?exMapName@@YAPADH@Z:PROC			; exMapName
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@
CONST	SEGMENT
??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@ DB '['
	DB	'ResetSystem] Accaunt: %s , Name: %s , Reset: %d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv1456 = -104						; size = 4
tv1442 = -104						; size = 4
tv1428 = -104						; size = 4
tv1414 = -104						; size = 4
tv1451 = -100						; size = 4
tv1437 = -100						; size = 4
tv1423 = -100						; size = 4
tv1409 = -100						; size = 4
tv619 = -100						; size = 4
tv579 = -100						; size = 4
tv535 = -100						; size = 4
tv243 = -100						; size = 4
_i$231784 = -32						; size = 4
_CreditMoney$ = -28					; size = 4
_WCoinMoney$ = -24					; size = 4
_i$231755 = -20						; size = 4
_SearchRes$231754 = -13					; size = 1
_ZenMoney$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?ExResetSystemFunciton@cResetSystem@@QAEXH@Z PROC	; cResetSystem::ExResetSystemFunciton
; _this$ = ecx

; 187  : {

  00bb0	55		 push	 ebp
  00bb1	8b ec		 mov	 ebp, esp
  00bb3	83 ec 68	 sub	 esp, 104		; 00000068H
  00bb6	53		 push	 ebx
  00bb7	56		 push	 esi
  00bb8	57		 push	 edi
  00bb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 188  : 	if(!this->EnableResetSystem)return;

  00bbc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bbf	83 38 00	 cmp	 DWORD PTR [eax], 0
  00bc2	75 05		 jne	 SHORT $LN92@ExResetSys
  00bc4	e9 85 11 00 00	 jmp	 $LN93@ExResetSys
$LN92@ExResetSys:

; 189  : 
; 190  : 	LPOBJ lpObj = &gObj[aIndex];

  00bc9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bcc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00bd2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bd8	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 191  : 
; 192  : 	int ZenMoney = 0;

  00bdb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ZenMoney$[ebp], 0

; 193  : 
; 194  : 	if ( (GetTickCount() - lpObj->MySelfDefenseTime ) < 60000)

  00be2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00be8	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00beb	2b 81 1c 04 00
	00		 sub	 eax, DWORD PTR [ecx+1052]
  00bf1	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00bf6	73 36		 jae	 SHORT $LN91@ExResetSys

; 195  : 	{
; 196  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), lpObj->m_Index, 1);

  00bf8	6a 01		 push	 1
  00bfa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfd	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bff	51		 push	 ecx
  00c00	68 6d 04 00 00	 push	 1133			; 0000046dH
  00c05	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00c0a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00c0f	50		 push	 eax
  00c10	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00c15	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  : 		GCCloseMsgSend(aIndex,-1); //Season 2.5 add-on

  00c18	68 ff 00 00 00	 push	 255			; 000000ffH
  00c1d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c20	50		 push	 eax
  00c21	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00c26	83 c4 08	 add	 esp, 8

; 198  : 		return;

  00c29	e9 20 11 00 00	 jmp	 $LN93@ExResetSys
$LN91@ExResetSys:

; 199  : 	}
; 200  : 
; 201  : 	if(lpObj->SkillRecallParty_Time != 0)

  00c2e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c31	0f b7 88 74 12
	00 00		 movzx	 ecx, WORD PTR [eax+4724]
  00c38	85 c9		 test	 ecx, ecx
  00c3a	74 05		 je	 SHORT $LN90@ExResetSys

; 202  : 	{
; 203  : 		return;

  00c3c	e9 0d 11 00 00	 jmp	 $LN93@ExResetSys
$LN90@ExResetSys:

; 204  : 	}
; 205  : 
; 206  : 	if(lpObj->MapNumber != this->m_iMapForReset)

  00c41	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c44	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00c4b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00c4e	3b 4a 48	 cmp	 ecx, DWORD PTR [edx+72]
  00c51	74 2e		 je	 SHORT $LN89@ExResetSys

; 207  : 	{
; 208  : 		MsgNormal(aIndex, g_ExText.GetText(3), exMapName(this->m_iMapForReset));

  00c53	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c56	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00c59	51		 push	 ecx
  00c5a	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  00c5f	83 c4 04	 add	 esp, 4
  00c62	50		 push	 eax
  00c63	6a 03		 push	 3
  00c65	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00c6a	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00c6f	50		 push	 eax
  00c70	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00c73	52		 push	 edx
  00c74	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00c79	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  : 		return;

  00c7c	e9 cd 10 00 00	 jmp	 $LN93@ExResetSys
$LN89@ExResetSys:

; 210  : 	}
; 211  : 
; 212  : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  00c81	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c84	50		 push	 eax
  00c85	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00c8a	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  00c8f	85 c0		 test	 eax, eax
  00c91	75 22		 jne	 SHORT $LN88@ExResetSys

; 213  : 	{
; 214  : 		GCServerMsgStringSend(g_ExText.GetText(4),lpObj->m_Index,1);

  00c93	6a 01		 push	 1
  00c95	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c98	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c9a	51		 push	 ecx
  00c9b	6a 04		 push	 4
  00c9d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00ca2	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00ca7	50		 push	 eax
  00ca8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00cad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 215  : 		return;

  00cb0	e9 99 10 00 00	 jmp	 $LN93@ExResetSys
$LN88@ExResetSys:

; 216  : 	}
; 217  : 
; 218  : 	//    
; 219  : 	if(lpObj->Reset >= this->Maxres)

  00cb5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cbb	8b 90 90 22 00
	00		 mov	 edx, DWORD PTR [eax+8848]
  00cc1	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00cc4	7c 25		 jl	 SHORT $LN87@ExResetSys

; 220  : 	{
; 221  : 		MsgNormal(aIndex,g_ExText.GetText(5),this->Maxres);

  00cc6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cc9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ccc	51		 push	 ecx
  00ccd	6a 05		 push	 5
  00ccf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00cd4	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00cd9	50		 push	 eax
  00cda	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00cdd	52		 push	 edx
  00cde	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00ce3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 222  : 		return;

  00ce6	e9 63 10 00 00	 jmp	 $LN93@ExResetSys
$LN87@ExResetSys:

; 223  : 	}
; 224  : 	
; 225  : 	//  
; 226  : 	if(g_ExLicense.user.Rage)

  00ceb	0f b6 05 c9 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+201
  00cf2	85 c0		 test	 eax, eax
  00cf4	74 66		 je	 SHORT $LN86@ExResetSys

; 227  : 	{
; 228  : 		if((this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpObj->Level))

  00cf6	6a 00		 push	 0
  00cf8	6a 07		 push	 7
  00cfa	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00cfd	50		 push	 eax
  00cfe	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00d03	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  00d08	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d0b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00d0e	2b d0		 sub	 edx, eax
  00d10	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d13	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00d1a	3b d1		 cmp	 edx, ecx
  00d1c	7e 39		 jle	 SHORT $LN85@ExResetSys

; 229  : 		{
; 230  : 			MsgNormal(aIndex,g_ExText.GetText(6),this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0));

  00d1e	6a 00		 push	 0
  00d20	6a 07		 push	 7
  00d22	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00d25	50		 push	 eax
  00d26	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00d2b	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  00d30	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d33	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00d36	2b d0		 sub	 edx, eax
  00d38	52		 push	 edx
  00d39	6a 06		 push	 6
  00d3b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00d40	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00d45	50		 push	 eax
  00d46	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00d49	50		 push	 eax
  00d4a	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00d4f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 231  : 			return;

  00d52	e9 f7 0f 00 00	 jmp	 $LN93@ExResetSys
$LN85@ExResetSys:

; 232  : 		}
; 233  : 	}
; 234  : 	else

  00d57	e9 52 01 00 00	 jmp	 $LN73@ExResetSys
$LN86@ExResetSys:

; 235  : 	{
; 236  : #ifdef PRIVATE_MODULE
; 237  : 		if(g_ExLicense.CheckUser(eExUB::Cherkashin) || g_ExLicense.CheckUser(eExUB::Local3) || g_ExLicense.CheckUser(eExUB::AlterMU) || g_ExLicense.CheckUser(eExUB::EpicMU))

  00d5c	6a 12		 push	 18			; 00000012H
  00d5e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00d63	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00d68	0f b6 c0	 movzx	 eax, al
  00d6b	85 c0		 test	 eax, eax
  00d6d	75 3d		 jne	 SHORT $LN82@ExResetSys
  00d6f	6a 1c		 push	 28			; 0000001cH
  00d71	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00d76	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00d7b	0f b6 c0	 movzx	 eax, al
  00d7e	85 c0		 test	 eax, eax
  00d80	75 2a		 jne	 SHORT $LN82@ExResetSys
  00d82	6a 3e		 push	 62			; 0000003eH
  00d84	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00d89	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00d8e	0f b6 c0	 movzx	 eax, al
  00d91	85 c0		 test	 eax, eax
  00d93	75 17		 jne	 SHORT $LN82@ExResetSys
  00d95	6a 3b		 push	 59			; 0000003bH
  00d97	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00d9c	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00da1	0f b6 c0	 movzx	 eax, al
  00da4	85 c0		 test	 eax, eax
  00da6	0f 84 cb 00 00
	00		 je	 $LN83@ExResetSys
$LN82@ExResetSys:

; 238  : 		{
; 239  : 			bool SearchRes = false;

  00dac	c6 45 f3 00	 mov	 BYTE PTR _SearchRes$231754[ebp], 0

; 240  : 			for(int i=0;i<lCount;i++)

  00db0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$231755[ebp], 0
  00db7	eb 09		 jmp	 SHORT $LN81@ExResetSys
$LN80@ExResetSys:
  00db9	8b 45 ec	 mov	 eax, DWORD PTR _i$231755[ebp]
  00dbc	83 c0 01	 add	 eax, 1
  00dbf	89 45 ec	 mov	 DWORD PTR _i$231755[ebp], eax
$LN81@ExResetSys:
  00dc2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00dc5	8b 4d ec	 mov	 ecx, DWORD PTR _i$231755[ebp]
  00dc8	3b 88 c4 7d 00
	00		 cmp	 ecx, DWORD PTR [eax+32196]
  00dce	7d 66		 jge	 SHORT $LN79@ExResetSys

; 241  : 			{
; 242  : 				if(this->LevelRes[i].Res == (lpObj->Reset + 1))

  00dd0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dd3	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  00dd9	83 c1 01	 add	 ecx, 1
  00ddc	8b 55 ec	 mov	 edx, DWORD PTR _i$231755[ebp]
  00ddf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00de2	39 8c d0 84 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24196], ecx
  00de9	75 49		 jne	 SHORT $LN78@ExResetSys

; 243  : 				{
; 244  : 					if(this->LevelRes[i].Level > lpObj->Level)

  00deb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dee	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00df5	8b 55 ec	 mov	 edx, DWORD PTR _i$231755[ebp]
  00df8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00dfb	39 8c d0 88 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24200], ecx
  00e02	7e 2c		 jle	 SHORT $LN77@ExResetSys

; 245  : 					{
; 246  : 						MsgNormal(aIndex,g_ExText.GetText(6),this->LevelRes[i].Level);

  00e04	8b 45 ec	 mov	 eax, DWORD PTR _i$231755[ebp]
  00e07	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e0a	8b 94 c1 88 5e
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+24200]
  00e11	52		 push	 edx
  00e12	6a 06		 push	 6
  00e14	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00e19	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00e1e	50		 push	 eax
  00e1f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00e22	50		 push	 eax
  00e23	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00e28	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  : 						return;

  00e2b	e9 1e 0f 00 00	 jmp	 $LN93@ExResetSys
$LN77@ExResetSys:

; 248  : 					} 
; 249  : 					SearchRes = true; 

  00e30	c6 45 f3 01	 mov	 BYTE PTR _SearchRes$231754[ebp], 1
$LN78@ExResetSys:

; 250  : 				}
; 251  : 			} 

  00e34	eb 83		 jmp	 SHORT $LN80@ExResetSys
$LN79@ExResetSys:

; 252  : 			if (!SearchRes)

  00e36	0f b6 45 f3	 movzx	 eax, BYTE PTR _SearchRes$231754[ebp]
  00e3a	85 c0		 test	 eax, eax
  00e3c	75 37		 jne	 SHORT $LN75@ExResetSys

; 253  : 			{
; 254  : 				if(this->NeedLevel > lpObj->Level)

  00e3e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e41	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00e48	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e4b	39 4a 10	 cmp	 DWORD PTR [edx+16], ecx
  00e4e	7e 25		 jle	 SHORT $LN75@ExResetSys

; 255  : 				{
; 256  : 					MsgNormal(aIndex,g_ExText.GetText(6),this->NeedLevel);

  00e50	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e53	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00e56	51		 push	 ecx
  00e57	6a 06		 push	 6
  00e59	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00e5e	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00e63	50		 push	 eax
  00e64	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00e67	52		 push	 edx
  00e68	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00e6d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  : 					return;

  00e70	e9 d9 0e 00 00	 jmp	 $LN93@ExResetSys
$LN75@ExResetSys:

; 258  : 				} 
; 259  : 			}
; 260  : 			
; 261  : 		 
; 262  : 		}
; 263  : 		else

  00e75	eb 37		 jmp	 SHORT $LN73@ExResetSys
$LN83@ExResetSys:

; 264  : 		{
; 265  : 			if(this->NeedLevel > lpObj->Level)

  00e77	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e7a	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00e81	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e84	39 4a 10	 cmp	 DWORD PTR [edx+16], ecx
  00e87	7e 25		 jle	 SHORT $LN73@ExResetSys

; 266  : 			{
; 267  : 				MsgNormal(aIndex,g_ExText.GetText(6),this->NeedLevel);

  00e89	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e8c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00e8f	51		 push	 ecx
  00e90	6a 06		 push	 6
  00e92	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00e97	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00e9c	50		 push	 eax
  00e9d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00ea0	52		 push	 edx
  00ea1	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00ea6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 268  : 				return;

  00ea9	e9 a0 0e 00 00	 jmp	 $LN93@ExResetSys
$LN73@ExResetSys:

; 269  : 			} 
; 270  : 		}
; 271  : 
; 272  : #else
; 273  : 		if(this->NeedLevel > lpObj->Level)
; 274  : 		{
; 275  : 			MsgNormal(aIndex,g_ExText.GetText(6),this->NeedLevel);
; 276  : 			return;
; 277  : 		}
; 278  : #endif
; 279  : 		
; 280  : 	}
; 281  : 
; 282  : 	//  
; 283  : 	switch(this->ZenForm)

  00eae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00eb1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00eb4	89 4d 9c	 mov	 DWORD PTR tv243[ebp], ecx
  00eb7	83 7d 9c 01	 cmp	 DWORD PTR tv243[ebp], 1
  00ebb	74 08		 je	 SHORT $LN70@ExResetSys
  00ebd	83 7d 9c 02	 cmp	 DWORD PTR tv243[ebp], 2
  00ec1	74 1a		 je	 SHORT $LN69@ExResetSys
  00ec3	eb 21		 jmp	 SHORT $LN71@ExResetSys
$LN70@ExResetSys:

; 284  : 	{
; 285  : 		case 1: ZenMoney = this->NeedZen * ( lpObj->Reset + 1 ); break;

  00ec5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ec8	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  00ece	83 c1 01	 add	 ecx, 1
  00ed1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ed4	0f af 4a 0c	 imul	 ecx, DWORD PTR [edx+12]
  00ed8	89 4d f4	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
  00edb	eb 09		 jmp	 SHORT $LN71@ExResetSys
$LN69@ExResetSys:

; 286  : 		case 2: ZenMoney = this->NeedZen; break;

  00edd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ee0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00ee3	89 4d f4	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
$LN71@ExResetSys:

; 287  : 	}
; 288  : 
; 289  : #ifdef PRIVATE_MODULE
; 290  : 	int WCoinMoney = 0;

  00ee6	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _WCoinMoney$[ebp], 0

; 291  : 	int CreditMoney = 0;

  00eed	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _CreditMoney$[ebp], 0

; 292  : 	if(g_ExLicense.CheckUser(eExUB::Local3) || g_ExLicense.CheckUser(SILVER1) || g_ExLicense.CheckUser(SILVER2) || g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::Cherkashin))

  00ef4	6a 1c		 push	 28			; 0000001cH
  00ef6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00efb	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00f00	0f b6 c0	 movzx	 eax, al
  00f03	85 c0		 test	 eax, eax
  00f05	75 50		 jne	 SHORT $LN67@ExResetSys
  00f07	6a 07		 push	 7
  00f09	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00f0e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00f13	0f b6 c0	 movzx	 eax, al
  00f16	85 c0		 test	 eax, eax
  00f18	75 3d		 jne	 SHORT $LN67@ExResetSys
  00f1a	6a 08		 push	 8
  00f1c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00f21	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00f26	0f b6 c0	 movzx	 eax, al
  00f29	85 c0		 test	 eax, eax
  00f2b	75 2a		 jne	 SHORT $LN67@ExResetSys
  00f2d	6a 01		 push	 1
  00f2f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00f34	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00f39	0f b6 c0	 movzx	 eax, al
  00f3c	85 c0		 test	 eax, eax
  00f3e	75 17		 jne	 SHORT $LN67@ExResetSys
  00f40	6a 12		 push	 18			; 00000012H
  00f42	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00f47	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00f4c	0f b6 c0	 movzx	 eax, al
  00f4f	85 c0		 test	 eax, eax
  00f51	0f 84 9e 00 00
	00		 je	 $LN65@ExResetSys
$LN67@ExResetSys:

; 293  : 		{
; 294  : 		WCoinMoney  = this->NeedWCoinToReset * ( lpObj->Reset + 1 );

  00f57	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f5a	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  00f60	83 c1 01	 add	 ecx, 1
  00f63	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f66	0f af 8a b4 00
	00 00		 imul	 ecx, DWORD PTR [edx+180]
  00f6d	89 4d e8	 mov	 DWORD PTR _WCoinMoney$[ebp], ecx

; 295  : 		
; 296  : #if _CONFLICT_
; 297  : 		CreditMoney  = this->NeedCreditToReset * ( lpObj->Reset + 1 );

  00f70	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f73	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  00f79	83 c1 01	 add	 ecx, 1
  00f7c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f7f	0f af 8a b8 00
	00 00		 imul	 ecx, DWORD PTR [edx+184]
  00f86	89 4d e4	 mov	 DWORD PTR _CreditMoney$[ebp], ecx

; 298  : #endif
; 299  : 		if( lpObj->GameShop.WCoinC < WCoinMoney)

  00f89	db 45 e8	 fild	 DWORD PTR _WCoinMoney$[ebp]
  00f8c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f8f	dc 98 00 23 00
	00		 fcomp	 QWORD PTR [eax+8960]
  00f95	df e0		 fnstsw	 ax
  00f97	f6 c4 41	 test	 ah, 65			; 00000041H
  00f9a	75 22		 jne	 SHORT $LN66@ExResetSys

; 300  : 		{
; 301  : 				MsgNormal(aIndex,g_ExText.GetText(7),WCoinMoney);

  00f9c	8b 45 e8	 mov	 eax, DWORD PTR _WCoinMoney$[ebp]
  00f9f	50		 push	 eax
  00fa0	6a 07		 push	 7
  00fa2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00fa7	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00fac	50		 push	 eax
  00fad	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00fb0	51		 push	 ecx
  00fb1	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00fb6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 				return;	

  00fb9	e9 90 0d 00 00	 jmp	 $LN93@ExResetSys
$LN66@ExResetSys:

; 303  : 		}
; 304  : 		
; 305  : #if _CONFLICT_
; 306  : 	
; 307  : 
; 308  : 		if( lpObj->ExCred < CreditMoney)

  00fbe	db 45 e4	 fild	 DWORD PTR _CreditMoney$[ebp]
  00fc1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fc4	d9 80 a8 22 00
	00		 fld	 DWORD PTR [eax+8872]
  00fca	de d9		 fcompp
  00fcc	df e0		 fnstsw	 ax
  00fce	f6 c4 05	 test	 ah, 5
  00fd1	7a 22		 jp	 SHORT $LN65@ExResetSys

; 309  : 		{
; 310  : 			MsgNormal(aIndex, g_ExText.GetText(8),CreditMoney);

  00fd3	8b 45 e4	 mov	 eax, DWORD PTR _CreditMoney$[ebp]
  00fd6	50		 push	 eax
  00fd7	6a 08		 push	 8
  00fd9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  00fde	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  00fe3	50		 push	 eax
  00fe4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00fe7	51		 push	 ecx
  00fe8	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00fed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 311  : 				return;	

  00ff0	e9 59 0d 00 00	 jmp	 $LN93@ExResetSys
$LN65@ExResetSys:

; 312  : 		}
; 313  : #endif
; 314  : 	}
; 315  : #endif
; 316  : 	
; 317  : 	if(this->ZenForm != 0)

  00ff5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ff8	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00ffc	74 30		 je	 SHORT $LN63@ExResetSys

; 318  : 	{
; 319  : 		if(lpObj->Money < ZenMoney)

  00ffe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01001	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01007	3b 4d f4	 cmp	 ecx, DWORD PTR _ZenMoney$[ebp]
  0100a	7d 22		 jge	 SHORT $LN63@ExResetSys

; 320  : 		{
; 321  : 			MsgNormal(aIndex, g_ExText.GetText(9), ZenMoney);

  0100c	8b 45 f4	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  0100f	50		 push	 eax
  01010	6a 09		 push	 9
  01012	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01017	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0101c	50		 push	 eax
  0101d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01020	51		 push	 ecx
  01021	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 322  : 			return;

  01029	e9 20 0d 00 00	 jmp	 $LN93@ExResetSys
$LN63@ExResetSys:

; 323  : 		}
; 324  : 	}
; 325  : 	//   
; 326  : 	if(this->NeedEmptyInv)

  0102e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01031	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  01035	0f 84 2b 01 00
	00		 je	 $LN61@ExResetSys

; 327  : 	{
; 328  : 		if(lpObj->pInventory[0].m_Type != -1 || lpObj->pInventory[1].m_Type != -1 || lpObj->pInventory[2].m_Type != -1 ||
; 329  : 		   lpObj->pInventory[3].m_Type != -1 || lpObj->pInventory[4].m_Type != -1 || lpObj->pInventory[5].m_Type != -1 ||
; 330  : 		   lpObj->pInventory[6].m_Type != -1 || lpObj->pInventory[7].m_Type != -1 || lpObj->pInventory[8].m_Type != -1 ||
; 331  : 		   lpObj->pInventory[9].m_Type != -1 || lpObj->pInventory[10].m_Type != -1|| lpObj->pInventory[11].m_Type != -1)

  0103b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0103e	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01044	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  01048	83 fa ff	 cmp	 edx, -1
  0104b	0f 85 f7 00 00
	00		 jne	 $LN60@ExResetSys
  01051	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01054	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0105a	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  01061	83 fa ff	 cmp	 edx, -1
  01064	0f 85 de 00 00
	00		 jne	 $LN60@ExResetSys
  0106a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0106d	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01073	0f bf 91 ae 01
	00 00		 movsx	 edx, WORD PTR [ecx+430]
  0107a	83 fa ff	 cmp	 edx, -1
  0107d	0f 85 c5 00 00
	00		 jne	 $LN60@ExResetSys
  01083	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01086	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0108c	0f bf 91 82 02
	00 00		 movsx	 edx, WORD PTR [ecx+642]
  01093	83 fa ff	 cmp	 edx, -1
  01096	0f 85 ac 00 00
	00		 jne	 $LN60@ExResetSys
  0109c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0109f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010a5	0f bf 91 56 03
	00 00		 movsx	 edx, WORD PTR [ecx+854]
  010ac	83 fa ff	 cmp	 edx, -1
  010af	0f 85 93 00 00
	00		 jne	 $LN60@ExResetSys
  010b5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010b8	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010be	0f bf 91 2a 04
	00 00		 movsx	 edx, WORD PTR [ecx+1066]
  010c5	83 fa ff	 cmp	 edx, -1
  010c8	75 7e		 jne	 SHORT $LN60@ExResetSys
  010ca	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010cd	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010d3	0f bf 91 fe 04
	00 00		 movsx	 edx, WORD PTR [ecx+1278]
  010da	83 fa ff	 cmp	 edx, -1
  010dd	75 69		 jne	 SHORT $LN60@ExResetSys
  010df	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010e2	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010e8	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  010ef	83 fa ff	 cmp	 edx, -1
  010f2	75 54		 jne	 SHORT $LN60@ExResetSys
  010f4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010f7	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  010fd	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  01104	83 fa ff	 cmp	 edx, -1
  01107	75 3f		 jne	 SHORT $LN60@ExResetSys
  01109	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0110c	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01112	0f bf 91 7a 07
	00 00		 movsx	 edx, WORD PTR [ecx+1914]
  01119	83 fa ff	 cmp	 edx, -1
  0111c	75 2a		 jne	 SHORT $LN60@ExResetSys
  0111e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01121	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  01127	0f bf 91 4e 08
	00 00		 movsx	 edx, WORD PTR [ecx+2126]
  0112e	83 fa ff	 cmp	 edx, -1
  01131	75 15		 jne	 SHORT $LN60@ExResetSys
  01133	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01136	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0113c	0f bf 91 22 09
	00 00		 movsx	 edx, WORD PTR [ecx+2338]
  01143	83 fa ff	 cmp	 edx, -1
  01146	74 1e		 je	 SHORT $LN61@ExResetSys
$LN60@ExResetSys:

; 332  : 		{
; 333  : 			MsgNormal(aIndex, g_ExText.GetText(10));

  01148	6a 0a		 push	 10			; 0000000aH
  0114a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  0114f	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  01154	50		 push	 eax
  01155	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01158	50		 push	 eax
  01159	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0115e	83 c4 08	 add	 esp, 8

; 334  : 			return;

  01161	e9 e8 0b 00 00	 jmp	 $LN93@ExResetSys
$LN61@ExResetSys:

; 335  : 		}
; 336  : 	}
; 337  : 
; 338  : #ifdef PRIVATE_MODULE
; 339  : 	if(g_ExLicense.CheckUser(eExUB::Vadim) || g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::Local3) || g_ExLicense.CheckUser(eExUB::Cherkashin))

  01166	6a 09		 push	 9
  01168	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0116d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01172	0f b6 c0	 movzx	 eax, al
  01175	85 c0		 test	 eax, eax
  01177	75 3d		 jne	 SHORT $LN58@ExResetSys
  01179	6a 01		 push	 1
  0117b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01180	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01185	0f b6 c0	 movzx	 eax, al
  01188	85 c0		 test	 eax, eax
  0118a	75 2a		 jne	 SHORT $LN58@ExResetSys
  0118c	6a 1c		 push	 28			; 0000001cH
  0118e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01193	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01198	0f b6 c0	 movzx	 eax, al
  0119b	85 c0		 test	 eax, eax
  0119d	75 17		 jne	 SHORT $LN58@ExResetSys
  0119f	6a 12		 push	 18			; 00000012H
  011a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  011a6	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  011ab	0f b6 c0	 movzx	 eax, al
  011ae	85 c0		 test	 eax, eax
  011b0	0f 84 03 01 00
	00		 je	 $LN55@ExResetSys
$LN58@ExResetSys:

; 340  : 	{
; 341  : 		for(int i=0;i<iCount;i++)

  011b6	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$231784[ebp], 0
  011bd	eb 09		 jmp	 SHORT $LN57@ExResetSys
$LN56@ExResetSys:
  011bf	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  011c2	83 c0 01	 add	 eax, 1
  011c5	89 45 e0	 mov	 DWORD PTR _i$231784[ebp], eax
$LN57@ExResetSys:
  011c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011cb	8b 4d e0	 mov	 ecx, DWORD PTR _i$231784[ebp]
  011ce	3b 88 80 5e 00
	00		 cmp	 ecx, DWORD PTR [eax+24192]
  011d4	0f 8d df 00 00
	00		 jge	 $LN55@ExResetSys

; 342  : 		{
; 343  : 			if(this->ItemsRes[i].Res == (lpObj->Reset + 1))

  011da	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  011dd	c1 e0 04	 shl	 eax, 4
  011e0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011e3	8b 91 90 22 00
	00		 mov	 edx, DWORD PTR [ecx+8848]
  011e9	83 c2 01	 add	 edx, 1
  011ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011ef	39 94 01 00 20
	00 00		 cmp	 DWORD PTR [ecx+eax+8192], edx
  011f6	0f 85 b8 00 00
	00		 jne	 $LN54@ExResetSys

; 344  : 			{
; 345  : 				if(gObjGetItemCountInInventory(aIndex,ITEMGET(this->ItemsRes[i].ItemType,this->ItemsRes[i].ItemIndex),0) < this->ItemsRes[i].ItemCount)

  011fc	6a 00		 push	 0
  011fe	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  01201	c1 e0 04	 shl	 eax, 4
  01204	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01207	8b 94 01 04 20
	00 00		 mov	 edx, DWORD PTR [ecx+eax+8196]
  0120e	c1 e2 09	 shl	 edx, 9
  01211	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  01214	c1 e0 04	 shl	 eax, 4
  01217	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0121a	03 94 01 08 20
	00 00		 add	 edx, DWORD PTR [ecx+eax+8200]
  01221	52		 push	 edx
  01222	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01225	52		 push	 edx
  01226	e8 00 00 00 00	 call	 ?gObjGetItemCountInInventory@@YAHHHH@Z ; gObjGetItemCountInInventory
  0122b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0122e	8b 4d e0	 mov	 ecx, DWORD PTR _i$231784[ebp]
  01231	c1 e1 04	 shl	 ecx, 4
  01234	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01237	3b 84 0a 0c 20
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+8204]
  0123e	7d 2f		 jge	 SHORT $LN53@ExResetSys

; 346  : 				{
; 347  : 					MsgNormal(aIndex, g_ExText.GetText(11),this->ItemsRes[i].ItemCount);

  01240	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  01243	c1 e0 04	 shl	 eax, 4
  01246	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01249	8b 94 01 0c 20
	00 00		 mov	 edx, DWORD PTR [ecx+eax+8204]
  01250	52		 push	 edx
  01251	6a 0b		 push	 11			; 0000000bH
  01253	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  01258	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0125d	50		 push	 eax
  0125e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01261	50		 push	 eax
  01262	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01267	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 					return;

  0126a	e9 df 0a 00 00	 jmp	 $LN93@ExResetSys
$LN53@ExResetSys:

; 349  : 				}
; 350  : 				gObjDeleteItemsCount(aIndex,ITEMGET(this->ItemsRes[i].ItemType,this->ItemsRes[i].ItemIndex),0,this->ItemsRes[i].ItemCount);

  0126f	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  01272	c1 e0 04	 shl	 eax, 4
  01275	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01278	8b 94 01 0c 20
	00 00		 mov	 edx, DWORD PTR [ecx+eax+8204]
  0127f	52		 push	 edx
  01280	6a 00		 push	 0
  01282	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  01285	c1 e0 04	 shl	 eax, 4
  01288	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0128b	8b 94 01 04 20
	00 00		 mov	 edx, DWORD PTR [ecx+eax+8196]
  01292	c1 e2 09	 shl	 edx, 9
  01295	8b 45 e0	 mov	 eax, DWORD PTR _i$231784[ebp]
  01298	c1 e0 04	 shl	 eax, 4
  0129b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0129e	03 94 01 08 20
	00 00		 add	 edx, DWORD PTR [ecx+eax+8200]
  012a5	52		 push	 edx
  012a6	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  012a9	52		 push	 edx
  012aa	e8 00 00 00 00	 call	 ?gObjDeleteItemsCount@@YAHHFFH@Z ; gObjDeleteItemsCount
  012af	83 c4 10	 add	 esp, 16			; 00000010H

; 351  : 				break;

  012b2	eb 05		 jmp	 SHORT $LN55@ExResetSys
$LN54@ExResetSys:

; 352  : 			}
; 353  : 		}

  012b4	e9 06 ff ff ff	 jmp	 $LN56@ExResetSys
$LN55@ExResetSys:

; 354  : 	}
; 355  : #endif
; 356  : 
; 357  : 	/////////////////////
; 358  : 	// //
; 359  : 	/////////////////////
; 360  : 	lpObj->Money -= ZenMoney;

  012b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012bc	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  012c2	2b 4d f4	 sub	 ecx, DWORD PTR _ZenMoney$[ebp]
  012c5	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012c8	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 361  : #ifdef PRIVATE_MODULE
; 362  : if(g_ExLicense.CheckUser(eExUB::Local3) || g_ExLicense.CheckUser(SILVER1) || g_ExLicense.CheckUser(SILVER2) || g_ExLicense.CheckUser(eExUB::drynea)|| g_ExLicense.CheckUser(eExUB::Cherkashin))

  012ce	6a 1c		 push	 28			; 0000001cH
  012d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  012d5	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  012da	0f b6 c0	 movzx	 eax, al
  012dd	85 c0		 test	 eax, eax
  012df	75 4c		 jne	 SHORT $LN51@ExResetSys
  012e1	6a 07		 push	 7
  012e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  012e8	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  012ed	0f b6 c0	 movzx	 eax, al
  012f0	85 c0		 test	 eax, eax
  012f2	75 39		 jne	 SHORT $LN51@ExResetSys
  012f4	6a 08		 push	 8
  012f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  012fb	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01300	0f b6 c0	 movzx	 eax, al
  01303	85 c0		 test	 eax, eax
  01305	75 26		 jne	 SHORT $LN51@ExResetSys
  01307	6a 01		 push	 1
  01309	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0130e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01313	0f b6 c0	 movzx	 eax, al
  01316	85 c0		 test	 eax, eax
  01318	75 13		 jne	 SHORT $LN51@ExResetSys
  0131a	6a 12		 push	 18			; 00000012H
  0131c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01321	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01326	0f b6 c0	 movzx	 eax, al
  01329	85 c0		 test	 eax, eax
  0132b	74 48		 je	 SHORT $LN52@ExResetSys
$LN51@ExResetSys:

; 363  : 			{
; 364  : 		lpObj->GameShop.WCoinC -= WCoinMoney;

  0132d	db 45 e8	 fild	 DWORD PTR _WCoinMoney$[ebp]
  01330	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01333	dc a8 00 23 00
	00		 fsubr	 QWORD PTR [eax+8960]
  01339	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0133c	dd 99 00 23 00
	00		 fstp	 QWORD PTR [ecx+8960]

; 365  : 		gGameShop.GDSaveUserInfo(lpObj->m_Index);

  01342	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01345	8b 08		 mov	 ecx, DWORD PTR [eax]
  01347	51		 push	 ecx
  01348	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0134d	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 366  : #if _CONFLICT_
; 367  : 		lpObj->ExCred -= CreditMoney;

  01352	db 45 e4	 fild	 DWORD PTR _CreditMoney$[ebp]
  01355	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01358	d8 a8 a8 22 00
	00		 fsubr	 DWORD PTR [eax+8872]
  0135e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01361	d9 99 a8 22 00
	00		 fstp	 DWORD PTR [ecx+8872]

; 368  : 		ExUserDataSend(lpObj->m_Index);

  01367	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0136a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0136c	51		 push	 ecx
  0136d	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  01372	83 c4 04	 add	 esp, 4
$LN52@ExResetSys:

; 369  : #endif
; 370  : 	}
; 371  : #endif
; 372  : 
; 373  : 	lpObj->Level = 1;

  01375	b8 01 00 00 00	 mov	 eax, 1
  0137a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0137d	66 89 81 be 00
	00 00		 mov	 WORD PTR [ecx+190], ax

; 374  : 	lpObj->Experience = 0;

  01384	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01387	c7 80 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+200], 0

; 375  : 	lpObj->NextExp = 100;

  01391	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01394	c7 80 cc 00 00
	00 64 00 00 00	 mov	 DWORD PTR [eax+204], 100 ; 00000064H

; 376  : 	if(this->AddForm == 2)

  0139e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013a1	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  013a5	0f 85 95 00 00
	00		 jne	 $LN46@ExResetSys

; 377  : 	{
; 378  : 		lpObj->Strength = 25;

  013ab	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  013b0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013b3	66 89 81 f4 00
	00 00		 mov	 WORD PTR [ecx+244], ax

; 379  : 		lpObj->Dexterity = 25;

  013ba	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  013bf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013c2	66 89 81 f6 00
	00 00		 mov	 WORD PTR [ecx+246], ax

; 380  : 		lpObj->Vitality = 25;

  013c9	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  013ce	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013d1	66 89 81 f8 00
	00 00		 mov	 WORD PTR [ecx+248], ax

; 381  : 		lpObj->Energy = 25;

  013d8	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  013dd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013e0	66 89 81 fa 00
	00 00		 mov	 WORD PTR [ecx+250], ax

; 382  : 		if(g_ExLicense.CheckUser(eExUB::DavitRazmadze) || g_ExLicense.CheckUser(eExUB::DavitRazmadze2) || g_ExLicense.CheckUser(eExUB::DavitRazmadze3))

  013e7	6a 0a		 push	 10			; 0000000aH
  013e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  013ee	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  013f3	0f b6 c0	 movzx	 eax, al
  013f6	85 c0		 test	 eax, eax
  013f8	75 26		 jne	 SHORT $LN48@ExResetSys
  013fa	6a 19		 push	 25			; 00000019H
  013fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01401	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01406	0f b6 c0	 movzx	 eax, al
  01409	85 c0		 test	 eax, eax
  0140b	75 13		 jne	 SHORT $LN48@ExResetSys
  0140d	6a 1d		 push	 29			; 0000001dH
  0140f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01414	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01419	0f b6 c0	 movzx	 eax, al
  0141c	85 c0		 test	 eax, eax
  0141e	74 02		 je	 SHORT $LN49@ExResetSys
$LN48@ExResetSys:

; 383  : 		{
; 384  : 		}
; 385  : 		else

  01420	eb 1e		 jmp	 SHORT $LN46@ExResetSys
$LN49@ExResetSys:

; 386  : 		{
; 387  : 			if(lpObj->Class == 4)

  01422	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01425	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0142c	83 f9 04	 cmp	 ecx, 4
  0142f	75 0f		 jne	 SHORT $LN46@ExResetSys

; 388  : 				lpObj->Leadership = 25;

  01431	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  01436	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01439	66 89 81 18 01
	00 00		 mov	 WORD PTR [ecx+280], ax
$LN46@ExResetSys:

; 389  : 		}
; 390  : 	}
; 391  : 	//  
; 392  : 	if(this->AddForm == 1 || this->AddForm == 2)

  01440	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01443	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  01447	74 0d		 je	 SHORT $LN44@ExResetSys
  01449	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0144c	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  01450	0f 85 f7 00 00
	00		 jne	 $LN42@ExResetSys
$LN44@ExResetSys:

; 393  : 	{
; 394  : 		switch (lpObj->Class)

  01456	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01459	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01460	89 4d 9c	 mov	 DWORD PTR tv535[ebp], ecx
  01463	83 7d 9c 06	 cmp	 DWORD PTR tv535[ebp], 6
  01467	0f 87 e0 00 00
	00		 ja	 $LN42@ExResetSys
  0146d	8b 55 9c	 mov	 edx, DWORD PTR tv535[ebp]
  01470	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN95@ExResetSys[edx*4]
$LN41@ExResetSys:

; 395  : 		{
; 396  : 			case 0: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsDW ;  break;

  01477	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0147a	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  01480	83 c1 01	 add	 ecx, 1
  01483	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01486	0f af 4a 18	 imul	 ecx, DWORD PTR [edx+24]
  0148a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0148d	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01493	e9 b5 00 00 00	 jmp	 $LN42@ExResetSys
$LN40@ExResetSys:

; 397  : 			case 1: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsDK ;  break;

  01498	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0149b	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  014a1	83 c1 01	 add	 ecx, 1
  014a4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014a7	0f af 4a 1c	 imul	 ecx, DWORD PTR [edx+28]
  014ab	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014ae	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  014b4	e9 94 00 00 00	 jmp	 $LN42@ExResetSys
$LN39@ExResetSys:

; 398  : 			case 2: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsELF ; break;

  014b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014bc	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  014c2	83 c1 01	 add	 ecx, 1
  014c5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014c8	0f af 4a 20	 imul	 ecx, DWORD PTR [edx+32]
  014cc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014cf	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  014d5	eb 76		 jmp	 SHORT $LN42@ExResetSys
$LN38@ExResetSys:

; 399  : 			case 3: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsMG ;  break;

  014d7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014da	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  014e0	83 c1 01	 add	 ecx, 1
  014e3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014e6	0f af 4a 28	 imul	 ecx, DWORD PTR [edx+40]
  014ea	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014ed	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  014f3	eb 58		 jmp	 SHORT $LN42@ExResetSys
$LN37@ExResetSys:

; 400  : 			case 4: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsDL ;  break;

  014f5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014f8	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  014fe	83 c1 01	 add	 ecx, 1
  01501	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01504	0f af 4a 2c	 imul	 ecx, DWORD PTR [edx+44]
  01508	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0150b	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01511	eb 3a		 jmp	 SHORT $LN42@ExResetSys
$LN36@ExResetSys:

; 401  : 			case 5: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsSUM ; break;

  01513	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01516	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0151c	83 c1 01	 add	 ecx, 1
  0151f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01522	0f af 4a 24	 imul	 ecx, DWORD PTR [edx+36]
  01526	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01529	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  0152f	eb 1c		 jmp	 SHORT $LN42@ExResetSys
$LN35@ExResetSys:

; 402  : 			case 6: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsRF ; break;

  01531	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01534	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0153a	83 c1 01	 add	 ecx, 1
  0153d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01540	0f af 4a 30	 imul	 ecx, DWORD PTR [edx+48]
  01544	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01547	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
$LN42@ExResetSys:

; 403  : 		}
; 404  : 	}
; 405  : 	//   
; 406  : 	if(gGrandReset.EnableGrandResetSystem)

  0154d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A, 0
  01554	0f 84 e7 02 00
	00		 je	 $LN19@ExResetSys

; 407  : 	{
; 408  : 		if(lpObj->GReset > 0)

  0155a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0155d	83 b8 94 22 00
	00 00		 cmp	 DWORD PTR [eax+8852], 0
  01564	0f 8e d7 02 00
	00		 jle	 $LN19@ExResetSys

; 409  : 		{
; 410  : 			if(gGrandReset.AddForm == 1 || gGrandReset.AddForm == 2)

  0156a	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 1
  01571	74 0d		 je	 SHORT $LN31@ExResetSys
  01573	83 3d 18 00 00
	00 02		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 2
  0157a	0f 85 24 01 00
	00		 jne	 $LN29@ExResetSys
$LN31@ExResetSys:

; 411  : 			{
; 412  : 				switch (lpObj->Class)

  01580	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01583	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0158a	89 4d 9c	 mov	 DWORD PTR tv579[ebp], ecx
  0158d	83 7d 9c 06	 cmp	 DWORD PTR tv579[ebp], 6
  01591	0f 87 0d 01 00
	00		 ja	 $LN29@ExResetSys
  01597	8b 55 9c	 mov	 edx, DWORD PTR tv579[ebp]
  0159a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN96@ExResetSys[edx*4]
$LN28@ExResetSys:

; 413  : 				{
; 414  : 					case 0: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDW ;  break;

  015a1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015a4	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  015aa	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  015b1	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015b4	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  015ba	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015bd	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  015c3	e9 dc 00 00 00	 jmp	 $LN29@ExResetSys
$LN27@ExResetSys:

; 415  : 					case 1: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDK ;  break;

  015c8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015cb	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  015d1	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  015d8	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015db	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  015e1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015e4	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  015ea	e9 b5 00 00 00	 jmp	 $LN29@ExResetSys
$LN26@ExResetSys:

; 416  : 					case 2: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsELF ; break;

  015ef	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015f2	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  015f8	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  015ff	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01602	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01608	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0160b	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01611	e9 8e 00 00 00	 jmp	 $LN29@ExResetSys
$LN25@ExResetSys:

; 417  : 					case 3: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsMG ;  break;

  01616	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01619	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0161f	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  01626	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01629	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  0162f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01632	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01638	eb 6a		 jmp	 SHORT $LN29@ExResetSys
$LN24@ExResetSys:

; 418  : 					case 4: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDL ;  break;

  0163a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0163d	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  01643	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  0164a	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0164d	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01653	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01656	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  0165c	eb 46		 jmp	 SHORT $LN29@ExResetSys
$LN23@ExResetSys:

; 419  : 					case 5: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsSUM ; break;

  0165e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01661	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  01667	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  0166e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01671	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01677	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0167a	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01680	eb 22		 jmp	 SHORT $LN29@ExResetSys
$LN22@ExResetSys:

; 420  : 					case 6: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsRF ; break;

  01682	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01685	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0168b	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
  01692	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01695	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  0169b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0169e	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
$LN29@ExResetSys:

; 421  : 				}
; 422  : 			}
; 423  : 			if(gGrandReset.AddForm == 3)

  016a4	83 3d 18 00 00
	00 03		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 3
  016ab	0f 85 90 01 00
	00		 jne	 $LN19@ExResetSys

; 424  : 			{
; 425  : 				switch (lpObj->Class)

  016b1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016b4	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  016bb	89 4d 9c	 mov	 DWORD PTR tv619[ebp], ecx
  016be	83 7d 9c 06	 cmp	 DWORD PTR tv619[ebp], 6
  016c2	0f 87 79 01 00
	00		 ja	 $LN19@ExResetSys
  016c8	8b 55 9c	 mov	 edx, DWORD PTR tv619[ebp]
  016cb	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN97@ExResetSys[edx*4]
$LN18@ExResetSys:

; 426  : 				{
; 427  : 					case 0: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDW  * ( lpObj->Reset+1 ); break;

  016d2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016d5	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  016db	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  016e2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016e5	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  016eb	83 c0 01	 add	 eax, 1
  016ee	0f af c8	 imul	 ecx, eax
  016f1	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016f4	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  016fa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016fd	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01703	e9 39 01 00 00	 jmp	 $LN19@ExResetSys
$LN17@ExResetSys:

; 428  : 					case 1: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDK  * ( lpObj->Reset+1 ); break;

  01708	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0170b	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  01711	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  01718	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0171b	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  01721	83 c0 01	 add	 eax, 1
  01724	0f af c8	 imul	 ecx, eax
  01727	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0172a	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01730	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01733	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  01739	e9 03 01 00 00	 jmp	 $LN19@ExResetSys
$LN16@ExResetSys:

; 429  : 					case 2: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsELF * ( lpObj->Reset+1 ); break;

  0173e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01741	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  01747	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  0174e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01751	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  01757	83 c0 01	 add	 eax, 1
  0175a	0f af c8	 imul	 ecx, eax
  0175d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01760	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01766	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01769	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  0176f	e9 cd 00 00 00	 jmp	 $LN19@ExResetSys
$LN15@ExResetSys:

; 430  : 					case 3: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsMG  * ( lpObj->Reset+1 ); break;

  01774	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01777	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0177d	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  01784	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01787	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  0178d	83 c0 01	 add	 eax, 1
  01790	0f af c8	 imul	 ecx, eax
  01793	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01796	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  0179c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0179f	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  017a5	e9 97 00 00 00	 jmp	 $LN19@ExResetSys
$LN14@ExResetSys:

; 431  : 					case 4: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDL  * ( lpObj->Reset+1 ); break;

  017aa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017ad	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  017b3	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  017ba	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017bd	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  017c3	83 c0 01	 add	 eax, 1
  017c6	0f af c8	 imul	 ecx, eax
  017c9	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017cc	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  017d2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017d5	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  017db	eb 64		 jmp	 SHORT $LN19@ExResetSys
$LN13@ExResetSys:

; 432  : 					case 5: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsSUM * ( lpObj->Reset+1 ); break;

  017dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017e0	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  017e6	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  017ed	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017f0	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  017f6	83 c0 01	 add	 eax, 1
  017f9	0f af c8	 imul	 ecx, eax
  017fc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017ff	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01805	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01808	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  0180e	eb 31		 jmp	 SHORT $LN19@ExResetSys
$LN12@ExResetSys:

; 433  : 					case 6: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsRF * ( lpObj->Reset+1 ); break;

  01810	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01813	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  01819	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
  01820	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01823	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  01829	83 c0 01	 add	 eax, 1
  0182c	0f af c8	 imul	 ecx, eax
  0182f	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01832	03 8a c0 00 00
	00		 add	 ecx, DWORD PTR [edx+192]
  01838	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0183b	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
$LN19@ExResetSys:

; 434  : 				}
; 435  : 			}
; 436  : 		}
; 437  : 	}
; 438  : 
; 439  : 	lpObj->LevelUpPoint += lpObj->ExFreePoints;

  01841	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01844	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0184a	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0184d	03 8a 8c 22 00
	00		 add	 ecx, DWORD PTR [edx+8844]
  01853	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01856	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx

; 440  : 	
; 441  : 	lpObj->Reset += 1;

  0185c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0185f	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  01865	83 c1 01	 add	 ecx, 1
  01868	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0186b	89 8a 90 22 00
	00		 mov	 DWORD PTR [edx+8848], ecx

; 442  : 
; 443  : 	if(this->AddCredits > 0)

  01871	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01874	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  01878	7e 45		 jle	 SHORT $LN9@ExResetSys

; 444  : 	{
; 445  : 		if(g_ExLicense.CheckUser(eExUB::NSGames))

  0187a	6a 51		 push	 81			; 00000051H
  0187c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01881	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01886	0f b6 c0	 movzx	 eax, al
  01889	85 c0		 test	 eax, eax
  0188b	74 1a		 je	 SHORT $LN10@ExResetSys

; 446  : 		{
; 447  : 			lpObj->PCPoint += this->AddCredits;	

  0188d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01890	8b 88 88 22 00
	00		 mov	 ecx, DWORD PTR [eax+8840]
  01896	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01899	03 4a 38	 add	 ecx, DWORD PTR [edx+56]
  0189c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0189f	89 88 88 22 00
	00		 mov	 DWORD PTR [eax+8840], ecx

; 448  : 		}
; 449  : 		else

  018a5	eb 18		 jmp	 SHORT $LN9@ExResetSys
$LN10@ExResetSys:

; 450  : 		{
; 451  : 			lpObj->ExCred += this->AddCredits;		

  018a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018aa	db 40 38	 fild	 DWORD PTR [eax+56]
  018ad	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  018b0	d8 81 a8 22 00
	00		 fadd	 DWORD PTR [ecx+8872]
  018b6	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  018b9	d9 9a a8 22 00
	00		 fstp	 DWORD PTR [edx+8872]
$LN9@ExResetSys:

; 452  : 		}
; 453  : 	}
; 454  : 	if(this->AddWcoinC > 0)

  018bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018c2	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  018c6	7e 18		 jle	 SHORT $LN8@ExResetSys

; 455  : 	{
; 456  : 		lpObj->GameShop.WCoinC += this->AddWcoinC;

  018c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018cb	db 40 3c	 fild	 DWORD PTR [eax+60]
  018ce	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  018d1	dc 81 00 23 00
	00		 fadd	 QWORD PTR [ecx+8960]
  018d7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  018da	dd 9a 00 23 00
	00		 fstp	 QWORD PTR [edx+8960]
$LN8@ExResetSys:

; 457  : 	}
; 458  : 	if(this->AddWcoinP > 0)

  018e0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018e3	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  018e7	7e 18		 jle	 SHORT $LN7@ExResetSys

; 459  : 	{
; 460  : 		lpObj->GameShop.WCoinP += this->AddWcoinP;

  018e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018ec	db 40 40	 fild	 DWORD PTR [eax+64]
  018ef	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  018f2	dc 81 f8 22 00
	00		 fadd	 QWORD PTR [ecx+8952]
  018f8	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  018fb	dd 9a f8 22 00
	00		 fstp	 QWORD PTR [edx+8952]
$LN7@ExResetSys:

; 461  : 	}
; 462  : 	if(this->AddGoblinPoint > 0)

  01901	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01904	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  01908	7e 18		 jle	 SHORT $LN6@ExResetSys

; 463  : 	{
; 464  : 		lpObj->GameShop.GoblinPoint += this->AddGoblinPoint;

  0190a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0190d	db 40 44	 fild	 DWORD PTR [eax+68]
  01910	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01913	dc 81 08 23 00
	00		 fadd	 QWORD PTR [ecx+8968]
  01919	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0191c	dd 9a 08 23 00
	00		 fstp	 QWORD PTR [edx+8968]
$LN6@ExResetSys:

; 465  : 	}
; 466  : 
; 467  : 	if(this->AddWcoinC > 0 || this->AddWcoinP > 0 || this->AddGoblinPoint > 0)

  01922	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01925	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  01929	7f 12		 jg	 SHORT $LN4@ExResetSys
  0192b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0192e	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  01932	7f 09		 jg	 SHORT $LN4@ExResetSys
  01934	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01937	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0193b	7e 0e		 jle	 SHORT $LN5@ExResetSys
$LN4@ExResetSys:

; 468  : 	{
; 469  : 		gGameShop.GDSaveUserInfo(aIndex);

  0193d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01940	50		 push	 eax
  01941	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  01946	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN5@ExResetSys:

; 470  : 	}	
; 471  : 
; 472  : 	ExFireCracker(aIndex, lpObj->X, lpObj->Y);

  0194b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0194e	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  01955	51		 push	 ecx
  01956	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01959	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  01960	50		 push	 eax
  01961	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01964	51		 push	 ecx
  01965	e8 00 00 00 00	 call	 ?ExFireCracker@@YAXHEE@Z ; ExFireCracker
  0196a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 473  : 
; 474  : 	lpObj->Life = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  0196d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01970	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01977	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  0197d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01980	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  01987	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0198a	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  01991	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  01995	89 45 9c	 mov	 DWORD PTR tv1409[ebp], eax
  01998	db 45 9c	 fild	 DWORD PTR tv1409[ebp]
  0199b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0199e	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  019a5	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  019ab	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  019b1	d8 81 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+20]
  019b7	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  019ba	0f b7 91 f8 00
	00 00		 movzx	 edx, WORD PTR [ecx+248]
  019c1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019c4	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  019cb	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  019d1	0f b7 81 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+12]
  019d8	2b d0		 sub	 edx, eax
  019da	89 55 98	 mov	 DWORD PTR tv1414[ebp], edx
  019dd	db 45 98	 fild	 DWORD PTR tv1414[ebp]
  019e0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  019e3	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  019ea	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  019f0	d8 8a 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+40]
  019f6	de c1		 faddp	 ST(1), ST(0)
  019f8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  019fb	d9 98 fc 00 00
	00		 fstp	 DWORD PTR [eax+252]

; 475  : 	lpObj->Mana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  01a01	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a04	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01a0b	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01a11	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01a14	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  01a1b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01a1e	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  01a25	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  01a29	89 45 9c	 mov	 DWORD PTR tv1423[ebp], eax
  01a2c	db 45 9c	 fild	 DWORD PTR tv1423[ebp]
  01a2f	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01a32	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  01a39	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  01a3f	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  01a45	d8 81 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+32]
  01a4b	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01a4e	0f b7 91 fa 00
	00 00		 movzx	 edx, WORD PTR [ecx+250]
  01a55	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a58	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01a5f	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01a65	0f b7 81 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+14]
  01a6c	2b d0		 sub	 edx, eax
  01a6e	89 55 98	 mov	 DWORD PTR tv1428[ebp], edx
  01a71	db 45 98	 fild	 DWORD PTR tv1428[ebp]
  01a74	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01a77	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  01a7e	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  01a84	d8 8a 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+44]
  01a8a	de c1		 faddp	 ST(1), ST(0)
  01a8c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a8f	d9 98 10 01 00
	00		 fstp	 DWORD PTR [eax+272]

; 476  : 
; 477  : 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  01a95	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01a98	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01a9f	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01aa5	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01aa8	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  01aaf	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01ab2	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  01ab9	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  01abd	89 45 9c	 mov	 DWORD PTR tv1437[ebp], eax
  01ac0	db 45 9c	 fild	 DWORD PTR tv1437[ebp]
  01ac3	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01ac6	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  01acd	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  01ad3	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  01ad9	d8 81 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+20]
  01adf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01ae2	0f b7 91 f8 00
	00 00		 movzx	 edx, WORD PTR [ecx+248]
  01ae9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01aec	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01af3	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01af9	0f b7 81 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+12]
  01b00	2b d0		 sub	 edx, eax
  01b02	89 55 98	 mov	 DWORD PTR tv1442[ebp], edx
  01b05	db 45 98	 fild	 DWORD PTR tv1442[ebp]
  01b08	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b0b	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  01b12	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  01b18	d8 8a 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+40]
  01b1e	de c1		 faddp	 ST(1), ST(0)
  01b20	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b23	d9 98 00 01 00
	00		 fstp	 DWORD PTR [eax+256]

; 478  : 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  01b29	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b2c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01b33	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01b39	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b3c	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  01b43	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b46	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  01b4d	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  01b51	89 45 9c	 mov	 DWORD PTR tv1451[ebp], eax
  01b54	db 45 9c	 fild	 DWORD PTR tv1451[ebp]
  01b57	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01b5a	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  01b61	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  01b67	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  01b6d	d8 81 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+32]
  01b73	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b76	0f b7 91 fa 00
	00 00		 movzx	 edx, WORD PTR [ecx+250]
  01b7d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01b80	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01b87	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01b8d	0f b7 81 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+14]
  01b94	2b d0		 sub	 edx, eax
  01b96	89 55 98	 mov	 DWORD PTR tv1456[ebp], edx
  01b99	db 45 98	 fild	 DWORD PTR tv1456[ebp]
  01b9c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01b9f	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  01ba6	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  01bac	d8 8a 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+44]
  01bb2	de c1		 faddp	 ST(1), ST(0)
  01bb4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01bb7	d9 98 14 01 00
	00		 fstp	 DWORD PTR [eax+276]

; 479  : 
; 480  : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;

  01bbd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01bc0	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01bc7	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01bcd	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01bd0	d9 81 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+40]
  01bd6	d9 9a 34 01 00
	00		 fstp	 DWORD PTR [edx+308]

; 481  : 	lpObj->EnergyToMana = DCInfo.DefClass[lpObj->Class].EnergyToMana;

  01bdc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01bdf	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  01be6	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  01bec	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01bef	d9 81 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+44]
  01bf5	d9 9a 38 01 00
	00		 fstp	 DWORD PTR [edx+312]

; 482  : 
; 483  : 	::gObjSetBP(aIndex);

  01bfb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01bfe	50		 push	 eax
  01bff	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  01c04	83 c4 04	 add	 esp, 4

; 484  : 	lpObj->BP = lpObj->MaxBP / 2;

  01c07	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c0a	8b 80 2c 01 00
	00		 mov	 eax, DWORD PTR [eax+300]
  01c10	99		 cdq
  01c11	2b c2		 sub	 eax, edx
  01c13	d1 f8		 sar	 eax, 1
  01c15	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01c18	89 81 28 01 00
	00		 mov	 DWORD PTR [ecx+296], eax

; 485  : 	::gObjCalcMaxLifePower(aIndex);

  01c1e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01c21	50		 push	 eax
  01c22	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  01c27	83 c4 04	 add	 esp, 4

; 486  : 
; 487  : 	GCReFillSend(aIndex, (int)lpObj->MaxLife + lpObj->AddLife, 0xFE, 0, lpObj->iMaxShield + lpObj->iAddShield);

  01c2a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c2d	8b 88 58 01 00
	00		 mov	 ecx, DWORD PTR [eax+344]
  01c33	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c36	03 8a 5c 01 00
	00		 add	 ecx, DWORD PTR [edx+348]
  01c3c	51		 push	 ecx
  01c3d	6a 00		 push	 0
  01c3f	68 fe 00 00 00	 push	 254			; 000000feH
  01c44	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c47	d9 80 00 01 00
	00		 fld	 DWORD PTR [eax+256]
  01c4d	e8 00 00 00 00	 call	 __ftol2_sse
  01c52	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01c55	03 81 4c 01 00
	00		 add	 eax, DWORD PTR [ecx+332]
  01c5b	50		 push	 eax
  01c5c	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01c5f	52		 push	 edx
  01c60	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  01c65	83 c4 14	 add	 esp, 20			; 00000014H

; 488  : 	//gObjSetBP(aIndex);
; 489  : 	GCManaSend(aIndex,(int)lpObj->MaxMana + lpObj->AddMana, 0xFE, 0, lpObj->MaxBP + lpObj->AddBP);

  01c68	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c6b	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  01c71	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01c74	03 8a 30 01 00
	00		 add	 ecx, DWORD PTR [edx+304]
  01c7a	51		 push	 ecx
  01c7b	6a 00		 push	 0
  01c7d	68 fe 00 00 00	 push	 254			; 000000feH
  01c82	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01c85	d9 80 14 01 00
	00		 fld	 DWORD PTR [eax+276]
  01c8b	e8 00 00 00 00	 call	 __ftol2_sse
  01c90	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01c93	03 81 50 01 00
	00		 add	 eax, DWORD PTR [ecx+336]
  01c99	50		 push	 eax
  01c9a	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01c9d	52		 push	 edx
  01c9e	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  01ca3	83 c4 14	 add	 esp, 20			; 00000014H

; 490  : 	gObjCalCharacter(aIndex);

  01ca6	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01ca9	50		 push	 eax
  01caa	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  01caf	83 c4 04	 add	 esp, 4

; 491  : 
; 492  : 	//gObjCloseSet(aIndex, 1);
; 493  : 	ResetSystemGC_CharUpdate(lpObj);

  01cb2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01cb5	50		 push	 eax
  01cb6	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate
  01cbb	83 c4 04	 add	 esp, 4

; 494  : 
; 495  : 	GCMoneySend(aIndex, lpObj->Money);

  01cbe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01cc1	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01cc7	51		 push	 ecx
  01cc8	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01ccb	52		 push	 edx
  01ccc	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  01cd1	83 c4 08	 add	 esp, 8

; 496  : 
; 497  : #if(CUSTOM_NOOBBUFF)
; 498  : 	if(ExConfig.CommonServer.bNoobBuffEnable)

  01cd4	0f b6 05 18 01
	00 00		 movzx	 eax, BYTE PTR ?ExConfig@@3VcExConfigs@@A+280
  01cdb	85 c0		 test	 eax, eax
  01cdd	74 3b		 je	 SHORT $LN1@ExResetSys

; 499  : 	{
; 500  : 		if(ExConfig.CommonServer.iNoobBuffMaxReset > lpObj->Reset)

  01cdf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01ce2	8b 0d 1c 01 00
	00		 mov	 ecx, DWORD PTR ?ExConfig@@3VcExConfigs@@A+284
  01ce8	3b 88 90 22 00
	00		 cmp	 ecx, DWORD PTR [eax+8848]
  01cee	7e 2a		 jle	 SHORT $LN1@ExResetSys

; 501  : 		{
; 502  : 			if(gObjSearchActiveEffect(lpObj,AT_NOOB_BUFF) == TRUE)

  01cf0	68 b6 00 00 00	 push	 182			; 000000b6H
  01cf5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01cf8	50		 push	 eax
  01cf9	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  01cfe	83 c4 08	 add	 esp, 8
  01d01	0f b6 c8	 movzx	 ecx, al
  01d04	83 f9 01	 cmp	 ecx, 1
  01d07	75 11		 jne	 SHORT $LN1@ExResetSys

; 503  : 			{
; 504  : 				gObjRemoveBuffEffect(lpObj,AT_NOOB_BUFF);

  01d09	68 b6 00 00 00	 push	 182			; 000000b6H
  01d0e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01d11	50		 push	 eax
  01d12	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  01d17	83 c4 08	 add	 esp, 8
$LN1@ExResetSys:

; 505  : 			}
; 506  : 		}
; 507  : 	}
; 508  : #endif
; 509  : 
; 510  : 	LogAddTD("[ResetSystem] Accaunt: %s , Name: %s , Reset: %d",lpObj->AccountID, lpObj->Name,lpObj->Reset);

  01d1a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01d1d	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  01d23	51		 push	 ecx
  01d24	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01d27	83 c2 77	 add	 edx, 119		; 00000077H
  01d2a	52		 push	 edx
  01d2b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01d2e	83 c0 6c	 add	 eax, 108		; 0000006cH
  01d31	50		 push	 eax
  01d32	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@
  01d37	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01d3d	83 c4 10	 add	 esp, 16			; 00000010H

; 511  : 
; 512  : #if(SYSTEM_ACHIEVEMENTS)
; 513  : 	g_Achievements.ResetUp(aIndex);

  01d40	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01d43	50		 push	 eax
  01d44	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  01d49	e8 00 00 00 00	 call	 ?ResetUp@CAchievements@@QAEXH@Z ; CAchievements::ResetUp
$LN93@ExResetSys:

; 514  : #endif
; 515  : }

  01d4e	5f		 pop	 edi
  01d4f	5e		 pop	 esi
  01d50	5b		 pop	 ebx
  01d51	8b e5		 mov	 esp, ebp
  01d53	5d		 pop	 ebp
  01d54	c2 04 00	 ret	 4
  01d57	90		 npad	 1
$LN95@ExResetSys:
  01d58	00 00 00 00	 DD	 $LN41@ExResetSys
  01d5c	00 00 00 00	 DD	 $LN40@ExResetSys
  01d60	00 00 00 00	 DD	 $LN39@ExResetSys
  01d64	00 00 00 00	 DD	 $LN38@ExResetSys
  01d68	00 00 00 00	 DD	 $LN37@ExResetSys
  01d6c	00 00 00 00	 DD	 $LN36@ExResetSys
  01d70	00 00 00 00	 DD	 $LN35@ExResetSys
$LN96@ExResetSys:
  01d74	00 00 00 00	 DD	 $LN28@ExResetSys
  01d78	00 00 00 00	 DD	 $LN27@ExResetSys
  01d7c	00 00 00 00	 DD	 $LN26@ExResetSys
  01d80	00 00 00 00	 DD	 $LN25@ExResetSys
  01d84	00 00 00 00	 DD	 $LN24@ExResetSys
  01d88	00 00 00 00	 DD	 $LN23@ExResetSys
  01d8c	00 00 00 00	 DD	 $LN22@ExResetSys
$LN97@ExResetSys:
  01d90	00 00 00 00	 DD	 $LN18@ExResetSys
  01d94	00 00 00 00	 DD	 $LN17@ExResetSys
  01d98	00 00 00 00	 DD	 $LN16@ExResetSys
  01d9c	00 00 00 00	 DD	 $LN15@ExResetSys
  01da0	00 00 00 00	 DD	 $LN14@ExResetSys
  01da4	00 00 00 00	 DD	 $LN13@ExResetSys
  01da8	00 00 00 00	 DD	 $LN12@ExResetSys
?ExResetSystemFunciton@cResetSystem@@QAEXH@Z ENDP	; cResetSystem::ExResetSystemFunciton
_TEXT	ENDS
PUBLIC	?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z	; cResetSystem::Main
EXTRN	?gAddExperience@@3MA:DWORD			; gAddExperience
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231857 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; cResetSystem::Main
; _this$ = ecx

; 518  : {

  01db0	55		 push	 ebp
  01db1	8b ec		 mov	 ebp, esp
  01db3	83 ec 48	 sub	 esp, 72			; 00000048H
  01db6	53		 push	 ebx
  01db7	56		 push	 esi
  01db8	57		 push	 edi
  01db9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 519  : 	if(!this->EnableResetSystem || !this->DinamicExp)

  01dbc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dbf	83 38 00	 cmp	 DWORD PTR [eax], 0
  01dc2	74 0b		 je	 SHORT $LN5@Main
  01dc4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dc7	0f b6 48 4c	 movzx	 ecx, BYTE PTR [eax+76]
  01dcb	85 c9		 test	 ecx, ecx
  01dcd	75 0d		 jne	 SHORT $LN6@Main
$LN5@Main:

; 520  : 	{
; 521  : 		return gAddExperience;

  01dcf	d9 05 00 00 00
	00		 fld	 DWORD PTR ?gAddExperience@@3MA ; gAddExperience
  01dd5	e8 00 00 00 00	 call	 __ftol2_sse
  01dda	eb 54		 jmp	 SHORT $LN7@Main
$LN6@Main:

; 522  : 	}
; 523  : 
; 524  : 	for(int i=0;i<this->rCount;i++)

  01ddc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231857[ebp], 0
  01de3	eb 09		 jmp	 SHORT $LN4@Main
$LN3@Main:
  01de5	8b 45 f8	 mov	 eax, DWORD PTR _i$231857[ebp]
  01de8	83 c0 01	 add	 eax, 1
  01deb	89 45 f8	 mov	 DWORD PTR _i$231857[ebp], eax
$LN4@Main:
  01dee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01df1	8b 4d f8	 mov	 ecx, DWORD PTR _i$231857[ebp]
  01df4	3b 88 fc 1f 00
	00		 cmp	 ecx, DWORD PTR [eax+8188]
  01dfa	7d 29		 jge	 SHORT $LN2@Main

; 525  : 	{
; 526  : 		if(this->Number[i].Res == lpObj->Reset)

  01dfc	8b 45 f8	 mov	 eax, DWORD PTR _i$231857[ebp]
  01dff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e02	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01e05	8b 84 c1 bc 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+188]
  01e0c	3b 82 90 22 00
	00		 cmp	 eax, DWORD PTR [edx+8848]
  01e12	75 0f		 jne	 SHORT $LN1@Main

; 527  : 		{
; 528  : 			return this->Number[i].Exp;

  01e14	8b 45 f8	 mov	 eax, DWORD PTR _i$231857[ebp]
  01e17	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e1a	8b 84 c1 c0 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+192]
  01e21	eb 0d		 jmp	 SHORT $LN7@Main
$LN1@Main:

; 529  : 		}
; 530  : 	}

  01e23	eb c0		 jmp	 SHORT $LN3@Main
$LN2@Main:

; 531  : 
; 532  : 	return gAddExperience;

  01e25	d9 05 00 00 00
	00		 fld	 DWORD PTR ?gAddExperience@@3MA ; gAddExperience
  01e2b	e8 00 00 00 00	 call	 __ftol2_sse
$LN7@Main:

; 533  : }

  01e30	5f		 pop	 edi
  01e31	5e		 pop	 esi
  01e32	5b		 pop	 ebx
  01e33	8b e5		 mov	 esp, ebp
  01e35	5d		 pop	 ebp
  01e36	c2 04 00	 ret	 4
?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; cResetSystem::Main
_TEXT	ENDS
PUBLIC	?GCDialogInfo@cResetSystem@@QAEXH@Z		; cResetSystem::GCDialogInfo
PUBLIC	?NpcDialog@cResetSystem@@QAE_NHH@Z		; cResetSystem::NpcDialog
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv179 = -80						; size = 4
tv174 = -80						; size = 4
_lpNpc$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aNpcIndex$ = 12					; size = 4
?NpcDialog@cResetSystem@@QAE_NHH@Z PROC			; cResetSystem::NpcDialog
; _this$ = ecx

; 536  : {

  01e40	55		 push	 ebp
  01e41	8b ec		 mov	 ebp, esp
  01e43	83 ec 50	 sub	 esp, 80			; 00000050H
  01e46	53		 push	 ebx
  01e47	56		 push	 esi
  01e48	57		 push	 edi
  01e49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 537  : 	if( !g_ExLicense.CheckUser(eExUB::Local) && 
; 538  : 		!g_ExLicense.CheckUser(eExUB::ulasevich) && 
; 539  : 		!g_ExLicense.CheckUser(eExUB::ulasevich2)&& 
; 540  : 		!g_ExLicense.CheckUser(eExUB::MU2Play)  && 
; 541  : 		!g_ExLicense.CheckUser(eExUB::Sentinel) &&
; 542  : 		!g_ExLicense.CheckUser(eExUB::EpicMU) && 
; 543  : 		!g_ExLicense.CheckUser(eExUB::Escalate) &&
; 544  : 		!g_ExLicense.CheckUser(eExUB::Artem) && 
; 545  : 		!g_ExLicense.CheckUser(eExUB::Artem2) &&
; 546  : 		!g_ExLicense.CheckUser(eExUB::RevoMU) &&
; 547  : 		!g_ExLicense.CheckUser(eExUB::GloryMU) &&
; 548  : 		!g_ExLicense.CheckUser(eExUB::MedoniAndrei)&&
; 549  : 		!g_ExLicense.CheckUser(eExUB::mu4you) &&
; 550  : 		!g_ExLicense.CheckUser(eExUB::eternalmu) &&
; 551  : 		!g_ExLicense.CheckUser(eExUB::NSGames))

  01e4c	6a 00		 push	 0
  01e4e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01e53	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01e58	0f b6 c0	 movzx	 eax, al
  01e5b	85 c0		 test	 eax, eax
  01e5d	0f 85 2d 01 00
	00		 jne	 $LN4@NpcDialog
  01e63	6a 17		 push	 23			; 00000017H
  01e65	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01e6a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01e6f	0f b6 c0	 movzx	 eax, al
  01e72	85 c0		 test	 eax, eax
  01e74	0f 85 16 01 00
	00		 jne	 $LN4@NpcDialog
  01e7a	6a 24		 push	 36			; 00000024H
  01e7c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01e81	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01e86	0f b6 c0	 movzx	 eax, al
  01e89	85 c0		 test	 eax, eax
  01e8b	0f 85 ff 00 00
	00		 jne	 $LN4@NpcDialog
  01e91	6a 36		 push	 54			; 00000036H
  01e93	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01e98	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01e9d	0f b6 c0	 movzx	 eax, al
  01ea0	85 c0		 test	 eax, eax
  01ea2	0f 85 e8 00 00
	00		 jne	 $LN4@NpcDialog
  01ea8	6a 38		 push	 56			; 00000038H
  01eaa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01eaf	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01eb4	0f b6 c0	 movzx	 eax, al
  01eb7	85 c0		 test	 eax, eax
  01eb9	0f 85 d1 00 00
	00		 jne	 $LN4@NpcDialog
  01ebf	6a 3b		 push	 59			; 0000003bH
  01ec1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01ec6	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01ecb	0f b6 c0	 movzx	 eax, al
  01ece	85 c0		 test	 eax, eax
  01ed0	0f 85 ba 00 00
	00		 jne	 $LN4@NpcDialog
  01ed6	6a 40		 push	 64			; 00000040H
  01ed8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01edd	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01ee2	0f b6 c0	 movzx	 eax, al
  01ee5	85 c0		 test	 eax, eax
  01ee7	0f 85 a3 00 00
	00		 jne	 $LN4@NpcDialog
  01eed	6a 30		 push	 48			; 00000030H
  01eef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01ef4	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01ef9	0f b6 c0	 movzx	 eax, al
  01efc	85 c0		 test	 eax, eax
  01efe	0f 85 8c 00 00
	00		 jne	 $LN4@NpcDialog
  01f04	6a 31		 push	 49			; 00000031H
  01f06	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f0b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f10	0f b6 c0	 movzx	 eax, al
  01f13	85 c0		 test	 eax, eax
  01f15	75 79		 jne	 SHORT $LN4@NpcDialog
  01f17	6a 43		 push	 67			; 00000043H
  01f19	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f1e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f23	0f b6 c0	 movzx	 eax, al
  01f26	85 c0		 test	 eax, eax
  01f28	75 66		 jne	 SHORT $LN4@NpcDialog
  01f2a	6a 46		 push	 70			; 00000046H
  01f2c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f31	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f36	0f b6 c0	 movzx	 eax, al
  01f39	85 c0		 test	 eax, eax
  01f3b	75 53		 jne	 SHORT $LN4@NpcDialog
  01f3d	6a 32		 push	 50			; 00000032H
  01f3f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f44	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f49	0f b6 c0	 movzx	 eax, al
  01f4c	85 c0		 test	 eax, eax
  01f4e	75 40		 jne	 SHORT $LN4@NpcDialog
  01f50	6a 4e		 push	 78			; 0000004eH
  01f52	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f57	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f5c	0f b6 c0	 movzx	 eax, al
  01f5f	85 c0		 test	 eax, eax
  01f61	75 2d		 jne	 SHORT $LN4@NpcDialog
  01f63	6a 4f		 push	 79			; 0000004fH
  01f65	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f6a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f6f	0f b6 c0	 movzx	 eax, al
  01f72	85 c0		 test	 eax, eax
  01f74	75 1a		 jne	 SHORT $LN4@NpcDialog
  01f76	6a 51		 push	 81			; 00000051H
  01f78	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  01f7d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  01f82	0f b6 c0	 movzx	 eax, al
  01f85	85 c0		 test	 eax, eax
  01f87	75 07		 jne	 SHORT $LN4@NpcDialog

; 552  : 	{
; 553  : 		return false;

  01f89	32 c0		 xor	 al, al
  01f8b	e9 e6 00 00 00	 jmp	 $LN5@NpcDialog
$LN4@NpcDialog:

; 554  : 	}
; 555  : 
; 556  : 	if(!OBJMAX_RANGE(aIndex) && !OBJMAX_RANGE(aNpcIndex))

  01f90	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  01f94	7d 09		 jge	 SHORT $LN7@NpcDialog
  01f96	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv174[ebp], 0
  01f9d	eb 0f		 jmp	 SHORT $LN8@NpcDialog
$LN7@NpcDialog:
  01f9f	33 c0		 xor	 eax, eax
  01fa1	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  01fa8	0f 9e c0	 setle	 al
  01fab	89 45 b0	 mov	 DWORD PTR tv174[ebp], eax
$LN8@NpcDialog:
  01fae	83 7d b0 00	 cmp	 DWORD PTR tv174[ebp], 0
  01fb2	75 2b		 jne	 SHORT $LN3@NpcDialog
  01fb4	83 7d 0c 00	 cmp	 DWORD PTR _aNpcIndex$[ebp], 0
  01fb8	7d 09		 jge	 SHORT $LN9@NpcDialog
  01fba	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  01fc1	eb 0f		 jmp	 SHORT $LN10@NpcDialog
$LN9@NpcDialog:
  01fc3	33 c0		 xor	 eax, eax
  01fc5	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aNpcIndex$[ebp], 14999 ; 00003a97H
  01fcc	0f 9e c0	 setle	 al
  01fcf	89 45 b0	 mov	 DWORD PTR tv179[ebp], eax
$LN10@NpcDialog:
  01fd2	83 7d b0 00	 cmp	 DWORD PTR tv179[ebp], 0
  01fd6	75 07		 jne	 SHORT $LN3@NpcDialog

; 557  : 	{
; 558  : 		return false;

  01fd8	32 c0		 xor	 al, al
  01fda	e9 97 00 00 00	 jmp	 $LN5@NpcDialog
$LN3@NpcDialog:

; 559  : 	}
; 560  : 
; 561  : 	LPOBJ lpUser = &gObj[aIndex];

  01fdf	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01fe2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01fe8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fee	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 562  : 	LPOBJ lpNpc = &gObj[aNpcIndex];

  01ff1	8b 45 0c	 mov	 eax, DWORD PTR _aNpcIndex$[ebp]
  01ff4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ffa	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02000	89 45 f4	 mov	 DWORD PTR _lpNpc$[ebp], eax

; 563  : 
; 564  : 	if(lpUser->Connected < PLAYER_PLAYING)

  02003	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02006	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0200a	7d 04		 jge	 SHORT $LN2@NpcDialog

; 565  : 	{
; 566  : 		return false;

  0200c	32 c0		 xor	 al, al
  0200e	eb 66		 jmp	 SHORT $LN5@NpcDialog
$LN2@NpcDialog:

; 567  : 	}
; 568  : 
; 569  : 	if(lpNpc->Class		== this->Reset_NPC_ID  &&
; 570  : 	   lpNpc->MapNumber	== this->Reset_NPC_MAP &&
; 571  : 	   lpNpc->X			== this->Reset_NPC_X   &&
; 572  : 	   lpNpc->Y			== this->Reset_NPC_Y )

  02010	8b 45 f4	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  02013	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0201a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0201d	3b 8a c8 7d 00
	00		 cmp	 ecx, DWORD PTR [edx+32200]
  02023	75 4f		 jne	 SHORT $LN1@NpcDialog
  02025	8b 45 f4	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  02028	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0202f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02032	3b 8a cc 7d 00
	00		 cmp	 ecx, DWORD PTR [edx+32204]
  02038	75 3a		 jne	 SHORT $LN1@NpcDialog
  0203a	8b 45 f4	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  0203d	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  02044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02047	3b 8a d0 7d 00
	00		 cmp	 ecx, DWORD PTR [edx+32208]
  0204d	75 25		 jne	 SHORT $LN1@NpcDialog
  0204f	8b 45 f4	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  02052	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  02059	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0205c	3b 8a d4 7d 00
	00		 cmp	 ecx, DWORD PTR [edx+32212]
  02062	75 10		 jne	 SHORT $LN1@NpcDialog

; 573  : 	{
; 574  : 		this->GCDialogInfo(aIndex);

  02064	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02067	50		 push	 eax
  02068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0206b	e8 00 00 00 00	 call	 ?GCDialogInfo@cResetSystem@@QAEXH@Z ; cResetSystem::GCDialogInfo

; 575  : 		return true;

  02070	b0 01		 mov	 al, 1
  02072	eb 02		 jmp	 SHORT $LN5@NpcDialog
$LN1@NpcDialog:

; 576  : 	}
; 577  : 
; 578  : 	return false;

  02074	32 c0		 xor	 al, al
$LN5@NpcDialog:

; 579  : }

  02076	5f		 pop	 edi
  02077	5e		 pop	 esi
  02078	5b		 pop	 ebx
  02079	8b e5		 mov	 esp, ebp
  0207b	5d		 pop	 ebp
  0207c	c2 08 00	 ret	 8
?NpcDialog@cResetSystem@@QAE_NHH@Z ENDP			; cResetSystem::NpcDialog
_TEXT	ENDS
PUBLIC	??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[]
PUBLIC	?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
PUBLIC	?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z	; cResetSystem::SearchItem
PUBLIC	??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
PUBLIC	?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
PUBLIC	??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@ ; `string'
PUBLIC	??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@ ; `string'
PUBLIC	??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@ ; `string'
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
;	COMDAT ??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@
CONST	SEGMENT
??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@ DB '[Rese'
	DB	't]: You need Empty Inventory to Reset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@
CONST	SEGMENT
??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@ DB '[Reset]: '
	DB	'Interface Disable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@
CONST	SEGMENT
??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@ DB '[Rese'
	DB	't]: Skill Recall Party Time', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv346 = -176						; size = 4
tv320 = -176						; size = 4
tv283 = -176						; size = 4
tv202 = -176						; size = 4
_ritem$231967 = -108					; size = 4
_i$231963 = -104					; size = 4
_nitem$231960 = -100					; size = 4
_i$231956 = -96						; size = 4
_LevelUpPoint$ = -92					; size = 4
_ZenMoney$ = -88					; size = 4
_i$231888 = -84						; size = 4
_SearchRes$ = -77					; size = 1
_pMsg$ = -76						; size = 64
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCDialogInfo@cResetSystem@@QAEXH@Z PROC		; cResetSystem::GCDialogInfo
; _this$ = ecx

; 582  : {

  02080	55		 push	 ebp
  02081	8b ec		 mov	 ebp, esp
  02083	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  02089	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0208e	33 c5		 xor	 eax, ebp
  02090	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02093	53		 push	 ebx
  02094	56		 push	 esi
  02095	57		 push	 edi
  02096	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 583  : 	LPOBJ lpUser = &gObj[aIndex];

  02099	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0209c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  020a2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020a8	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 584  : 
; 585  : 	GC_RESET_DATA pMsg;
; 586  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x43, sizeof(pMsg));

  020ab	6a 40		 push	 64			; 00000040H
  020ad	6a 43		 push	 67			; 00000043H
  020af	68 fb 00 00 00	 push	 251			; 000000fbH
  020b4	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  020b7	50		 push	 eax
  020b8	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  020bb	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 587  : 
; 588  : 	pMsg.Result = true;

  020c0	c6 45 b8 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 589  : 
; 590  : 	if((GetTickCount() - lpUser->MySelfDefenseTime ) < 60000)

  020c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  020ca	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  020cd	2b 81 1c 04 00
	00		 sub	 eax, DWORD PTR [ecx+1052]
  020d3	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  020d8	73 34		 jae	 SHORT $LN70@GCDialogIn

; 591  : 	{
; 592  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), aIndex, 1);

  020da	6a 01		 push	 1
  020dc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  020df	50		 push	 eax
  020e0	68 6d 04 00 00	 push	 1133			; 0000046dH
  020e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  020ea	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  020ef	50		 push	 eax
  020f0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  020f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 593  : 		GCCloseMsgSend(aIndex,-1);

  020f8	68 ff 00 00 00	 push	 255			; 000000ffH
  020fd	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02100	50		 push	 eax
  02101	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  02106	83 c4 08	 add	 esp, 8

; 594  : 		return;

  02109	e9 3d 09 00 00	 jmp	 $LN71@GCDialogIn
$LN70@GCDialogIn:

; 595  : 	}
; 596  : 
; 597  : 	if(lpUser->MapNumber != this->m_iMapForReset)

  0210e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02111	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  02118	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0211b	3b 4a 48	 cmp	 ecx, DWORD PTR [edx+72]
  0211e	74 2e		 je	 SHORT $LN69@GCDialogIn

; 598  : 	{
; 599  : 		MsgNormal(aIndex, g_ExText.GetText(3), exMapName(this->m_iMapForReset));

  02120	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02123	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  02126	51		 push	 ecx
  02127	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  0212c	83 c4 04	 add	 esp, 4
  0212f	50		 push	 eax
  02130	6a 03		 push	 3
  02132	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  02137	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  0213c	50		 push	 eax
  0213d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02140	52		 push	 edx
  02141	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 600  : 		return;

  02149	e9 fd 08 00 00	 jmp	 $LN71@GCDialogIn
$LN69@GCDialogIn:

; 601  : 	}
; 602  : 
; 603  : 	if(lpUser->SkillRecallParty_Time != 0)

  0214e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02151	0f b7 88 74 12
	00 00		 movzx	 ecx, WORD PTR [eax+4724]
  02158	85 c9		 test	 ecx, ecx
  0215a	74 16		 je	 SHORT $LN68@GCDialogIn

; 604  : 	{
; 605  : 		MsgNormal(aIndex,"[Reset]: Skill Recall Party Time");

  0215c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@
  02161	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02164	50		 push	 eax
  02165	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0216a	83 c4 08	 add	 esp, 8

; 606  : 		return;

  0216d	e9 d9 08 00 00	 jmp	 $LN71@GCDialogIn
$LN68@GCDialogIn:

; 607  : 	}
; 608  : 	
; 609  : 	if(gMoveCommand.CheckInterfaceToMove(lpUser) == 0)

  02172	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02175	50		 push	 eax
  02176	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0217b	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  02180	85 c0		 test	 eax, eax
  02182	75 1a		 jne	 SHORT $LN67@GCDialogIn

; 610  : 	{
; 611  : 		GCServerMsgStringSend("[Reset]: Interface Disable",lpUser->m_Index,1);

  02184	6a 01		 push	 1
  02186	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0218b	51		 push	 ecx
  0218c	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@
  02191	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02196	83 c4 0c	 add	 esp, 12			; 0000000cH

; 612  : 		return;

  02199	e9 ad 08 00 00	 jmp	 $LN71@GCDialogIn
$LN67@GCDialogIn:

; 613  : 	}
; 614  : 
; 615  : 	pMsg.Reset = lpUser->Reset;

  0219e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  021a1	66 8b 88 90 22
	00 00		 mov	 cx, WORD PTR [eax+8848]
  021a8	66 89 4d ba	 mov	 WORD PTR _pMsg$[ebp+6], cx

; 616  : 	pMsg.MaxReset = this->Maxres;

  021ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  021af	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  021b3	66 89 4d bc	 mov	 WORD PTR _pMsg$[ebp+8], cx

; 617  : 	if(lpUser->Reset >= this->Maxres)

  021b7	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  021ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  021bd	8b 90 90 22 00
	00		 mov	 edx, DWORD PTR [eax+8848]
  021c3	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  021c6	7c 04		 jl	 SHORT $LN66@GCDialogIn

; 618  : 	{
; 619  : 		pMsg.Result = false;

  021c8	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN66@GCDialogIn:

; 620  : 	}
; 621  : 	
; 622  : 	//  
; 623  : 	pMsg.NeedLevel = this->NeedLevel;

  021cc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  021cf	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  021d3	66 89 4d be	 mov	 WORD PTR _pMsg$[ebp+10], cx

; 624  : 
; 625  : 	bool SearchRes = false;

  021d7	c6 45 b3 00	 mov	 BYTE PTR _SearchRes$[ebp], 0

; 626  : 	for(int i=0; i<this->lCount; i++)

  021db	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$231888[ebp], 0
  021e2	eb 09		 jmp	 SHORT $LN65@GCDialogIn
$LN64@GCDialogIn:
  021e4	8b 45 ac	 mov	 eax, DWORD PTR _i$231888[ebp]
  021e7	83 c0 01	 add	 eax, 1
  021ea	89 45 ac	 mov	 DWORD PTR _i$231888[ebp], eax
$LN65@GCDialogIn:
  021ed	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  021f0	8b 4d ac	 mov	 ecx, DWORD PTR _i$231888[ebp]
  021f3	3b 88 c4 7d 00
	00		 cmp	 ecx, DWORD PTR [eax+32196]
  021f9	0f 8d a7 00 00
	00		 jge	 $LN63@GCDialogIn

; 627  : 	{
; 628  : 		if(this->LevelRes[i].Res == (lpUser->Reset + 1))

  021ff	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02202	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02208	83 c1 01	 add	 ecx, 1
  0220b	8b 55 ac	 mov	 edx, DWORD PTR _i$231888[ebp]
  0220e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02211	39 8c d0 84 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24196], ecx
  02218	0f 85 83 00 00
	00		 jne	 $LN62@GCDialogIn

; 629  : 		{
; 630  : 			if(g_ExLicense.user.Rage)

  0221e	0f b6 05 c9 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+201
  02225	85 c0		 test	 eax, eax
  02227	74 43		 je	 SHORT $LN61@GCDialogIn

; 631  : 			{
; 632  : 				pMsg.NeedLevel = this->LevelRes[i].Level - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0);

  02229	6a 00		 push	 0
  0222b	6a 07		 push	 7
  0222d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02230	50		 push	 eax
  02231	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  02236	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  0223b	8b 4d ac	 mov	 ecx, DWORD PTR _i$231888[ebp]
  0223e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02241	8b 8c ca 88 5e
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*8+24200]
  02248	2b c8		 sub	 ecx, eax
  0224a	66 89 4d be	 mov	 WORD PTR _pMsg$[ebp+10], cx

; 633  : 				if(pMsg.NeedLevel > lpUser->Level)

  0224e	0f b7 45 be	 movzx	 eax, WORD PTR _pMsg$[ebp+10]
  02252	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  02255	0f bf 91 be 00
	00 00		 movsx	 edx, WORD PTR [ecx+190]
  0225c	3b c2		 cmp	 eax, edx
  0225e	7e 04		 jle	 SHORT $LN60@GCDialogIn

; 634  : 				{
; 635  : 					pMsg.Result = false;

  02260	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN60@GCDialogIn:

; 636  : 				} 
; 637  : 				SearchRes = true; 

  02264	c6 45 b3 01	 mov	 BYTE PTR _SearchRes$[ebp], 1

; 638  : 				break;

  02268	eb 3c		 jmp	 SHORT $LN63@GCDialogIn

; 639  : 			}
; 640  : 			else

  0226a	eb 35		 jmp	 SHORT $LN62@GCDialogIn
$LN61@GCDialogIn:

; 641  : 			{
; 642  : 				pMsg.NeedLevel = this->LevelRes[i].Level;

  0226c	8b 45 ac	 mov	 eax, DWORD PTR _i$231888[ebp]
  0226f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02272	66 8b 94 c1 88
	5e 00 00	 mov	 dx, WORD PTR [ecx+eax*8+24200]
  0227a	66 89 55 be	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 643  : 				if(this->LevelRes[i].Level > lpUser->Level)

  0227e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02281	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  02288	8b 55 ac	 mov	 edx, DWORD PTR _i$231888[ebp]
  0228b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0228e	39 8c d0 88 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24200], ecx
  02295	7e 04		 jle	 SHORT $LN58@GCDialogIn

; 644  : 				{
; 645  : 					pMsg.Result = false;

  02297	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN58@GCDialogIn:

; 646  : 				} 
; 647  : 				SearchRes = true; 

  0229b	c6 45 b3 01	 mov	 BYTE PTR _SearchRes$[ebp], 1

; 648  : 				break;

  0229f	eb 05		 jmp	 SHORT $LN63@GCDialogIn
$LN62@GCDialogIn:

; 649  : 			}
; 650  : 		}
; 651  : 	} 

  022a1	e9 3e ff ff ff	 jmp	 $LN64@GCDialogIn
$LN63@GCDialogIn:

; 652  : 	if (!SearchRes)

  022a6	0f b6 45 b3	 movzx	 eax, BYTE PTR _SearchRes$[ebp]
  022aa	85 c0		 test	 eax, eax
  022ac	75 4f		 jne	 SHORT $LN57@GCDialogIn

; 653  : 	{
; 654  : 		if(g_ExLicense.user.Rage)

  022ae	0f b6 05 c9 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+201
  022b5	85 c0		 test	 eax, eax
  022b7	74 2e		 je	 SHORT $LN56@GCDialogIn

; 655  : 		{
; 656  : 			if((this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpUser->Level))

  022b9	6a 00		 push	 0
  022bb	6a 07		 push	 7
  022bd	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  022c0	50		 push	 eax
  022c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  022c6	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  022cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  022ce	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  022d1	2b d0		 sub	 edx, eax
  022d3	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  022d6	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  022dd	3b d1		 cmp	 edx, ecx
  022df	7e 04		 jle	 SHORT $LN55@GCDialogIn

; 657  : 			{
; 658  : 				pMsg.Result = false;

  022e1	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN55@GCDialogIn:

; 659  : 			}
; 660  : 		}
; 661  : 		else

  022e5	eb 16		 jmp	 SHORT $LN57@GCDialogIn
$LN56@GCDialogIn:

; 662  : 		{
; 663  : 			if(this->NeedLevel > lpUser->Level)

  022e7	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  022ea	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  022f1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  022f4	39 4a 10	 cmp	 DWORD PTR [edx+16], ecx
  022f7	7e 04		 jle	 SHORT $LN57@GCDialogIn

; 664  : 			{
; 665  : 				pMsg.Result = false;

  022f9	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN57@GCDialogIn:

; 666  : 			} 
; 667  : 		}
; 668  : 	}
; 669  : 
; 670  : 	//  
; 671  : 	int ZenMoney = 0;

  022fd	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _ZenMoney$[ebp], 0

; 672  : 
; 673  : 	switch(this->ZenForm)

  02304	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02307	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0230a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv202[ebp], ecx
  02310	83 bd 50 ff ff
	ff 01		 cmp	 DWORD PTR tv202[ebp], 1
  02317	74 0b		 je	 SHORT $LN50@GCDialogIn
  02319	83 bd 50 ff ff
	ff 02		 cmp	 DWORD PTR tv202[ebp], 2
  02320	74 1a		 je	 SHORT $LN49@GCDialogIn
  02322	eb 21		 jmp	 SHORT $LN51@GCDialogIn
$LN50@GCDialogIn:

; 674  : 	{
; 675  : 		case 1: ZenMoney = this->NeedZen * ( lpUser->Reset + 1 ); break;

  02324	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02327	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0232d	83 c1 01	 add	 ecx, 1
  02330	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02333	0f af 4a 0c	 imul	 ecx, DWORD PTR [edx+12]
  02337	89 4d a8	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
  0233a	eb 09		 jmp	 SHORT $LN51@GCDialogIn
$LN49@GCDialogIn:

; 676  : 		case 2: ZenMoney = this->NeedZen; break;

  0233c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0233f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02342	89 4d a8	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
$LN51@GCDialogIn:

; 677  : 	}
; 678  : 
; 679  : 	if(this->ZenForm != 0)

  02345	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02348	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0234c	74 12		 je	 SHORT $LN48@GCDialogIn

; 680  : 	{
; 681  : 		if(lpUser->Money < ZenMoney)

  0234e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02351	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02357	3b 4d a8	 cmp	 ecx, DWORD PTR _ZenMoney$[ebp]
  0235a	7d 04		 jge	 SHORT $LN48@GCDialogIn

; 682  : 		{
; 683  : 			pMsg.Result = false;

  0235c	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN48@GCDialogIn:

; 684  : 		}
; 685  : 	}
; 686  : 
; 687  : 	pMsg.NeedMoney = ZenMoney;

  02360	8b 45 a8	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  02363	89 45 c0	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 688  : 
; 689  : 	//   
; 690  : 	if(this->NeedEmptyInv)

  02366	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02369	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0236d	0f 84 23 01 00
	00		 je	 $LN46@GCDialogIn

; 691  : 	{
; 692  : 		if(lpUser->pInventory[0].m_Type != -1 || lpUser->pInventory[1].m_Type != -1 || lpUser->pInventory[2].m_Type != -1 ||
; 693  : 		   lpUser->pInventory[3].m_Type != -1 || lpUser->pInventory[4].m_Type != -1 || lpUser->pInventory[5].m_Type != -1 ||
; 694  : 		   lpUser->pInventory[6].m_Type != -1 || lpUser->pInventory[7].m_Type != -1 || lpUser->pInventory[8].m_Type != -1 ||
; 695  : 		   lpUser->pInventory[9].m_Type != -1 || lpUser->pInventory[10].m_Type != -1|| lpUser->pInventory[11].m_Type != -1)

  02373	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02376	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0237c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  02380	83 fa ff	 cmp	 edx, -1
  02383	0f 85 f7 00 00
	00		 jne	 $LN44@GCDialogIn
  02389	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0238c	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02392	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  02399	83 fa ff	 cmp	 edx, -1
  0239c	0f 85 de 00 00
	00		 jne	 $LN44@GCDialogIn
  023a2	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  023a5	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  023ab	0f bf 91 ae 01
	00 00		 movsx	 edx, WORD PTR [ecx+430]
  023b2	83 fa ff	 cmp	 edx, -1
  023b5	0f 85 c5 00 00
	00		 jne	 $LN44@GCDialogIn
  023bb	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  023be	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  023c4	0f bf 91 82 02
	00 00		 movsx	 edx, WORD PTR [ecx+642]
  023cb	83 fa ff	 cmp	 edx, -1
  023ce	0f 85 ac 00 00
	00		 jne	 $LN44@GCDialogIn
  023d4	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  023d7	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  023dd	0f bf 91 56 03
	00 00		 movsx	 edx, WORD PTR [ecx+854]
  023e4	83 fa ff	 cmp	 edx, -1
  023e7	0f 85 93 00 00
	00		 jne	 $LN44@GCDialogIn
  023ed	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  023f0	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  023f6	0f bf 91 2a 04
	00 00		 movsx	 edx, WORD PTR [ecx+1066]
  023fd	83 fa ff	 cmp	 edx, -1
  02400	75 7e		 jne	 SHORT $LN44@GCDialogIn
  02402	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02405	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0240b	0f bf 91 fe 04
	00 00		 movsx	 edx, WORD PTR [ecx+1278]
  02412	83 fa ff	 cmp	 edx, -1
  02415	75 69		 jne	 SHORT $LN44@GCDialogIn
  02417	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0241a	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02420	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  02427	83 fa ff	 cmp	 edx, -1
  0242a	75 54		 jne	 SHORT $LN44@GCDialogIn
  0242c	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0242f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02435	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  0243c	83 fa ff	 cmp	 edx, -1
  0243f	75 3f		 jne	 SHORT $LN44@GCDialogIn
  02441	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02444	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0244a	0f bf 91 7a 07
	00 00		 movsx	 edx, WORD PTR [ecx+1914]
  02451	83 fa ff	 cmp	 edx, -1
  02454	75 2a		 jne	 SHORT $LN44@GCDialogIn
  02456	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02459	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0245f	0f bf 91 4e 08
	00 00		 movsx	 edx, WORD PTR [ecx+2126]
  02466	83 fa ff	 cmp	 edx, -1
  02469	75 15		 jne	 SHORT $LN44@GCDialogIn
  0246b	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0246e	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02474	0f bf 91 22 09
	00 00		 movsx	 edx, WORD PTR [ecx+2338]
  0247b	83 fa ff	 cmp	 edx, -1
  0247e	74 16		 je	 SHORT $LN46@GCDialogIn
$LN44@GCDialogIn:

; 696  : 		{
; 697  : 			MsgNormal(aIndex,"[Reset]: You need Empty Inventory to Reset");

  02480	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@
  02485	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02488	50		 push	 eax
  02489	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0248e	83 c4 08	 add	 esp, 8

; 698  : 			return;

  02491	e9 b5 05 00 00	 jmp	 $LN71@GCDialogIn
$LN46@GCDialogIn:

; 699  : 		}
; 700  : 	}
; 701  : 
; 702  : 	//  
; 703  : 	int LevelUpPoint = 0;

  02496	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _LevelUpPoint$[ebp], 0

; 704  : 
; 705  : 	if(this->AddForm == 1 || this->AddForm == 2)

  0249d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  024a0	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  024a4	74 0d		 je	 SHORT $LN42@GCDialogIn
  024a6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  024a9	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  024ad	0f 85 d3 00 00
	00		 jne	 $LN43@GCDialogIn
$LN42@GCDialogIn:

; 706  : 	{
; 707  : 		switch (lpUser->Class)

  024b3	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  024b6	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  024bd	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv283[ebp], ecx
  024c3	83 bd 50 ff ff
	ff 06		 cmp	 DWORD PTR tv283[ebp], 6
  024ca	0f 87 b6 00 00
	00		 ja	 $LN43@GCDialogIn
  024d0	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv283[ebp]
  024d6	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN73@GCDialogIn[edx*4]
$LN39@GCDialogIn:

; 708  : 		{
; 709  : 			case 0: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDW ;  break;

  024dd	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  024e0	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  024e6	83 c1 01	 add	 ecx, 1
  024e9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  024ec	0f af 4a 18	 imul	 ecx, DWORD PTR [edx+24]
  024f0	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  024f3	e9 8e 00 00 00	 jmp	 $LN43@GCDialogIn
$LN38@GCDialogIn:

; 710  : 			case 1: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDK ;  break;

  024f8	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  024fb	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02501	83 c1 01	 add	 ecx, 1
  02504	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02507	0f af 4a 1c	 imul	 ecx, DWORD PTR [edx+28]
  0250b	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0250e	eb 76		 jmp	 SHORT $LN43@GCDialogIn
$LN37@GCDialogIn:

; 711  : 			case 2: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsELF ; break;

  02510	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02513	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02519	83 c1 01	 add	 ecx, 1
  0251c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0251f	0f af 4a 20	 imul	 ecx, DWORD PTR [edx+32]
  02523	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02526	eb 5e		 jmp	 SHORT $LN43@GCDialogIn
$LN36@GCDialogIn:

; 712  : 			case 3: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsMG ;  break;

  02528	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0252b	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02531	83 c1 01	 add	 ecx, 1
  02534	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02537	0f af 4a 28	 imul	 ecx, DWORD PTR [edx+40]
  0253b	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0253e	eb 46		 jmp	 SHORT $LN43@GCDialogIn
$LN35@GCDialogIn:

; 713  : 			case 4: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDL ;  break;

  02540	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02543	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02549	83 c1 01	 add	 ecx, 1
  0254c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0254f	0f af 4a 2c	 imul	 ecx, DWORD PTR [edx+44]
  02553	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02556	eb 2e		 jmp	 SHORT $LN43@GCDialogIn
$LN34@GCDialogIn:

; 714  : 			case 5: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsSUM ; break;

  02558	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0255b	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02561	83 c1 01	 add	 ecx, 1
  02564	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02567	0f af 4a 24	 imul	 ecx, DWORD PTR [edx+36]
  0256b	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0256e	eb 16		 jmp	 SHORT $LN43@GCDialogIn
$LN33@GCDialogIn:

; 715  : 			case 6: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsRF ; break;

  02570	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02573	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02579	83 c1 01	 add	 ecx, 1
  0257c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0257f	0f af 4a 30	 imul	 ecx, DWORD PTR [edx+48]
  02583	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
$LN43@GCDialogIn:

; 716  : 		}
; 717  : 	}
; 718  : 
; 719  : 	//   
; 720  : 	if(gGrandReset.EnableGrandResetSystem)

  02586	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A, 0
  0258d	0f 84 48 02 00
	00		 je	 $LN32@GCDialogIn

; 721  : 	{
; 722  : 		if(lpUser->GReset > 0)

  02593	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02596	83 b8 94 22 00
	00 00		 cmp	 DWORD PTR [eax+8852], 0
  0259d	0f 8e 38 02 00
	00		 jle	 $LN32@GCDialogIn

; 723  : 		{
; 724  : 			if(gGrandReset.AddForm == 1 || gGrandReset.AddForm == 2)

  025a3	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 1
  025aa	74 0d		 je	 SHORT $LN29@GCDialogIn
  025ac	83 3d 18 00 00
	00 02		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 2
  025b3	0f 85 d3 00 00
	00		 jne	 $LN30@GCDialogIn
$LN29@GCDialogIn:

; 725  : 			{
; 726  : 				switch (lpUser->Class)

  025b9	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  025bc	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  025c3	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv320[ebp], ecx
  025c9	83 bd 50 ff ff
	ff 06		 cmp	 DWORD PTR tv320[ebp], 6
  025d0	0f 87 b6 00 00
	00		 ja	 $LN30@GCDialogIn
  025d6	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv320[ebp]
  025dc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN74@GCDialogIn[edx*4]
$LN26@GCDialogIn:

; 727  : 				{
; 728  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW ;  break;

  025e3	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  025e6	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  025ec	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  025f3	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  025f6	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  025f9	e9 8e 00 00 00	 jmp	 $LN30@GCDialogIn
$LN25@GCDialogIn:

; 729  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK ;  break;

  025fe	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02601	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  02607	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  0260e	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02611	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02614	eb 76		 jmp	 SHORT $LN30@GCDialogIn
$LN24@GCDialogIn:

; 730  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF ; break;

  02616	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02619	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0261f	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  02626	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02629	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0262c	eb 5e		 jmp	 SHORT $LN30@GCDialogIn
$LN23@GCDialogIn:

; 731  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG ;  break;

  0262e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02631	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  02637	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  0263e	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02641	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02644	eb 46		 jmp	 SHORT $LN30@GCDialogIn
$LN22@GCDialogIn:

; 732  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL ;  break;

  02646	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02649	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0264f	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  02656	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02659	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0265c	eb 2e		 jmp	 SHORT $LN30@GCDialogIn
$LN21@GCDialogIn:

; 733  : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM ; break;

  0265e	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02661	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  02667	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  0266e	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02671	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02674	eb 16		 jmp	 SHORT $LN30@GCDialogIn
$LN20@GCDialogIn:

; 734  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF ; break;

  02676	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02679	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0267f	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
  02686	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02689	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
$LN30@GCDialogIn:

; 735  : 				}
; 736  : 			}
; 737  : 			if(gGrandReset.AddForm == 3)

  0268c	83 3d 18 00 00
	00 03		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 3
  02693	0f 85 42 01 00
	00		 jne	 $LN32@GCDialogIn

; 738  : 			{
; 739  : 				switch (lpUser->Class)

  02699	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0269c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  026a3	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv346[ebp], ecx
  026a9	83 bd 50 ff ff
	ff 06		 cmp	 DWORD PTR tv346[ebp], 6
  026b0	0f 87 25 01 00
	00		 ja	 $LN32@GCDialogIn
  026b6	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv346[ebp]
  026bc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN75@GCDialogIn[edx*4]
$LN16@GCDialogIn:

; 740  : 				{
; 741  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW  * ( lpUser->Reset+1 ); break;

  026c3	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  026c6	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  026cc	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  026d3	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  026d6	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  026dc	83 c0 01	 add	 eax, 1
  026df	0f af c8	 imul	 ecx, eax
  026e2	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  026e5	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  026e8	e9 ee 00 00 00	 jmp	 $LN32@GCDialogIn
$LN15@GCDialogIn:

; 742  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK  * ( lpUser->Reset+1 ); break;

  026ed	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  026f0	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  026f6	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  026fd	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  02700	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  02706	83 c0 01	 add	 eax, 1
  02709	0f af c8	 imul	 ecx, eax
  0270c	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  0270f	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02712	e9 c4 00 00 00	 jmp	 $LN32@GCDialogIn
$LN14@GCDialogIn:

; 743  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF * ( lpUser->Reset+1 ); break;

  02717	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0271a	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  02720	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  02727	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0272a	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  02730	83 c0 01	 add	 eax, 1
  02733	0f af c8	 imul	 ecx, eax
  02736	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02739	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0273c	e9 9a 00 00 00	 jmp	 $LN32@GCDialogIn
$LN13@GCDialogIn:

; 744  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG  * ( lpUser->Reset+1 ); break;

  02741	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02744	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0274a	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  02751	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  02754	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  0275a	83 c0 01	 add	 eax, 1
  0275d	0f af c8	 imul	 ecx, eax
  02760	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  02763	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02766	eb 73		 jmp	 SHORT $LN32@GCDialogIn
$LN12@GCDialogIn:

; 745  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL  * ( lpUser->Reset+1 ); break;

  02768	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0276b	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  02771	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  02778	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0277b	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  02781	83 c0 01	 add	 eax, 1
  02784	0f af c8	 imul	 ecx, eax
  02787	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  0278a	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0278d	eb 4c		 jmp	 SHORT $LN32@GCDialogIn
$LN11@GCDialogIn:

; 746  : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM * ( lpUser->Reset+1 ); break;

  0278f	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02792	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  02798	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  0279f	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  027a2	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  027a8	83 c0 01	 add	 eax, 1
  027ab	0f af c8	 imul	 ecx, eax
  027ae	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  027b1	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  027b4	eb 25		 jmp	 SHORT $LN32@GCDialogIn
$LN10@GCDialogIn:

; 747  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF  * ( lpUser->Reset+1 ); break;

  027b6	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  027b9	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  027bf	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
  027c6	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  027c9	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  027cf	83 c0 01	 add	 eax, 1
  027d2	0f af c8	 imul	 ecx, eax
  027d5	03 4d a4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  027d8	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
$LN32@GCDialogIn:

; 748  : 				}
; 749  : 			}
; 750  : 		}
; 751  : 	}
; 752  : 
; 753  : 	LevelUpPoint += lpUser->ExFreePoints;

  027db	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  027de	8b 4d a4	 mov	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  027e1	03 88 8c 22 00
	00		 add	 ecx, DWORD PTR [eax+8844]
  027e7	89 4d a4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx

; 754  : 	pMsg.RewardPoint = LevelUpPoint;

  027ea	8b 45 a4	 mov	 eax, DWORD PTR _LevelUpPoint$[ebp]
  027ed	89 45 c4	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 755  : 
; 756  : 	pMsg.AddCredits = this->AddCredits;

  027f0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  027f3	66 8b 48 38	 mov	 cx, WORD PTR [eax+56]
  027f7	66 89 4d c8	 mov	 WORD PTR _pMsg$[ebp+20], cx

; 757  : 	pMsg.AddWcoinC = this->AddWcoinC;

  027fb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  027fe	66 8b 48 3c	 mov	 cx, WORD PTR [eax+60]
  02802	66 89 4d ca	 mov	 WORD PTR _pMsg$[ebp+22], cx

; 758  : 	pMsg.AddWcoinP = this->AddWcoinP;

  02806	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02809	66 8b 48 40	 mov	 cx, WORD PTR [eax+64]
  0280d	66 89 4d cc	 mov	 WORD PTR _pMsg$[ebp+24], cx

; 759  : 	pMsg.AddWcoinG = this->AddGoblinPoint;

  02811	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02814	66 8b 48 44	 mov	 cx, WORD PTR [eax+68]
  02818	66 89 4d ce	 mov	 WORD PTR _pMsg$[ebp+26], cx

; 760  : 
; 761  : 	// Need Item
; 762  : 	pMsg.AddEnableItem = false;

  0281c	c6 45 d4 00	 mov	 BYTE PTR _pMsg$[ebp+32], 0

; 763  : 	pMsg.AddItem = -1;

  02820	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+36], -1

; 764  : 	pMsg.AddItemLevel = 0;

  02827	c6 45 dc 00	 mov	 BYTE PTR _pMsg$[ebp+40], 0

; 765  : 	pMsg.AddItemSkill = 0;

  0282b	c6 45 dd 00	 mov	 BYTE PTR _pMsg$[ebp+41], 0

; 766  : 	pMsg.AddItemLuck = 0;

  0282f	c6 45 de 00	 mov	 BYTE PTR _pMsg$[ebp+42], 0

; 767  : 	pMsg.AddItemOpt = 0;

  02833	c6 45 df 00	 mov	 BYTE PTR _pMsg$[ebp+43], 0

; 768  : 	pMsg.AddItemExl = 0;

  02837	c6 45 e0 00	 mov	 BYTE PTR _pMsg$[ebp+44], 0

; 769  : 	pMsg.AddItemAnc = 0;

  0283b	c6 45 e1 00	 mov	 BYTE PTR _pMsg$[ebp+45], 0

; 770  : 	pMsg.AddItemCount = 0;

  0283f	c6 45 e2 00	 mov	 BYTE PTR _pMsg$[ebp+46], 0

; 771  : 
; 772  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  02843	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _i$231956[ebp], 0
  0284a	eb 09		 jmp	 SHORT $LN9@GCDialogIn
$LN8@GCDialogIn:
  0284c	8b 45 a0	 mov	 eax, DWORD PTR _i$231956[ebp]
  0284f	83 c0 01	 add	 eax, 1
  02852	89 45 a0	 mov	 DWORD PTR _i$231956[ebp], eax
$LN9@GCDialogIn:
  02855	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02858	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  0285e	e8 00 00 00 00	 call	 ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
  02863	39 45 a0	 cmp	 DWORD PTR _i$231956[ebp], eax
  02866	0f 83 e5 00 00
	00		 jae	 $LN7@GCDialogIn

; 773  : 	{
; 774  : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];

  0286c	8b 45 a0	 mov	 eax, DWORD PTR _i$231956[ebp]
  0286f	50		 push	 eax
  02870	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02873	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  02879	e8 00 00 00 00	 call	 ??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
  0287e	89 45 9c	 mov	 DWORD PTR _nitem$231960[ebp], eax

; 775  : 		if(nitem.ResetNum == (lpUser->Reset + 1))

  02881	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02884	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0288a	83 c1 01	 add	 ecx, 1
  0288d	8b 55 9c	 mov	 edx, DWORD PTR _nitem$231960[ebp]
  02890	39 0a		 cmp	 DWORD PTR [edx], ecx
  02892	0f 85 b4 00 00
	00		 jne	 $LN6@GCDialogIn

; 776  : 		{
; 777  : 			pMsg.AddEnableItem = true;

  02898	c6 45 d4 01	 mov	 BYTE PTR _pMsg$[ebp+32], 1

; 778  : 			pMsg.AddItem = ITEMGET(nitem.Type, nitem.Index);

  0289c	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  0289f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  028a2	c1 e1 09	 shl	 ecx, 9
  028a5	8b 55 9c	 mov	 edx, DWORD PTR _nitem$231960[ebp]
  028a8	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  028ab	89 4d d8	 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 779  : 			pMsg.AddItemLevel = nitem.Level;

  028ae	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028b1	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  028b4	88 4d dc	 mov	 BYTE PTR _pMsg$[ebp+40], cl

; 780  : 			pMsg.AddItemSkill = nitem.Skill;

  028b7	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028ba	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  028bd	88 4d dd	 mov	 BYTE PTR _pMsg$[ebp+41], cl

; 781  : 			pMsg.AddItemLuck = nitem.Luck;

  028c0	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028c3	8a 48 11	 mov	 cl, BYTE PTR [eax+17]
  028c6	88 4d de	 mov	 BYTE PTR _pMsg$[ebp+42], cl

; 782  : 			pMsg.AddItemOpt = nitem.Opt;

  028c9	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028cc	8a 48 12	 mov	 cl, BYTE PTR [eax+18]
  028cf	88 4d df	 mov	 BYTE PTR _pMsg$[ebp+43], cl

; 783  : 			pMsg.AddItemExl = nitem.Exl;

  028d2	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028d5	8a 48 13	 mov	 cl, BYTE PTR [eax+19]
  028d8	88 4d e0	 mov	 BYTE PTR _pMsg$[ebp+44], cl

; 784  : 			pMsg.AddItemAnc = nitem.Anc;

  028db	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028de	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  028e1	88 4d e1	 mov	 BYTE PTR _pMsg$[ebp+45], cl

; 785  : 			pMsg.AddItemCount = nitem.Count;

  028e4	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028e7	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  028ea	88 4d e2	 mov	 BYTE PTR _pMsg$[ebp+46], cl

; 786  : 
; 787  : 			if(!SearchItem(aIndex, nitem.Type, nitem.Index, nitem.Level, nitem.Skill, nitem.Luck, nitem.Opt, nitem.Exl, nitem.Anc, nitem.Count, false))

  028ed	6a 00		 push	 0
  028ef	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  028f2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  028f5	51		 push	 ecx
  028f6	8b 55 9c	 mov	 edx, DWORD PTR _nitem$231960[ebp]
  028f9	0f b6 42 14	 movzx	 eax, BYTE PTR [edx+20]
  028fd	50		 push	 eax
  028fe	8b 4d 9c	 mov	 ecx, DWORD PTR _nitem$231960[ebp]
  02901	0f b6 51 13	 movzx	 edx, BYTE PTR [ecx+19]
  02905	52		 push	 edx
  02906	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  02909	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  0290d	51		 push	 ecx
  0290e	8b 55 9c	 mov	 edx, DWORD PTR _nitem$231960[ebp]
  02911	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  02915	50		 push	 eax
  02916	8b 4d 9c	 mov	 ecx, DWORD PTR _nitem$231960[ebp]
  02919	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  0291d	52		 push	 edx
  0291e	8b 45 9c	 mov	 eax, DWORD PTR _nitem$231960[ebp]
  02921	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02924	51		 push	 ecx
  02925	8b 55 9c	 mov	 edx, DWORD PTR _nitem$231960[ebp]
  02928	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0292b	50		 push	 eax
  0292c	8b 4d 9c	 mov	 ecx, DWORD PTR _nitem$231960[ebp]
  0292f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02932	52		 push	 edx
  02933	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02936	50		 push	 eax
  02937	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0293a	e8 00 00 00 00	 call	 ?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z ; cResetSystem::SearchItem
  0293f	0f b6 c8	 movzx	 ecx, al
  02942	85 c9		 test	 ecx, ecx
  02944	75 04		 jne	 SHORT $LN5@GCDialogIn

; 788  : 			{
; 789  : 				pMsg.Result = false;

  02946	c6 45 b8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN5@GCDialogIn:

; 790  : 			}
; 791  : 
; 792  : 			break;

  0294a	eb 05		 jmp	 SHORT $LN7@GCDialogIn
$LN6@GCDialogIn:

; 793  : 		}
; 794  : 	}

  0294c	e9 fb fe ff ff	 jmp	 $LN8@GCDialogIn
$LN7@GCDialogIn:

; 795  : 
; 796  : 	//reward Item
; 797  : 	pMsg.RewardEnableItem = false;

  02951	c6 45 e3 00	 mov	 BYTE PTR _pMsg$[ebp+47], 0

; 798  : 	pMsg.RewardItem = 0;

  02955	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+48], 0

; 799  : 	pMsg.RewardLevel = 0;

  0295c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+52], 0

; 800  : 	pMsg.RewardSkill = 0;

  02963	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp+56], 0

; 801  : 	pMsg.RewardLuck = 0;

  02967	c6 45 ed 00	 mov	 BYTE PTR _pMsg$[ebp+57], 0

; 802  : 	pMsg.RewardOpt = 0;

  0296b	c6 45 ee 00	 mov	 BYTE PTR _pMsg$[ebp+58], 0

; 803  : 	pMsg.RewardExl = 0;

  0296f	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+59], 0

; 804  : 	pMsg.RewardAnc = 0;

  02973	c6 45 f0 00	 mov	 BYTE PTR _pMsg$[ebp+60], 0

; 805  : 
; 806  : 	for(int i = 0; i < this->m_reward.size(); i++)

  02977	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$231963[ebp], 0
  0297e	eb 09		 jmp	 SHORT $LN4@GCDialogIn
$LN3@GCDialogIn:
  02980	8b 45 98	 mov	 eax, DWORD PTR _i$231963[ebp]
  02983	83 c0 01	 add	 eax, 1
  02986	89 45 98	 mov	 DWORD PTR _i$231963[ebp], eax
$LN4@GCDialogIn:
  02989	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0298c	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  02992	e8 00 00 00 00	 call	 ?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
  02997	39 45 98	 cmp	 DWORD PTR _i$231963[ebp], eax
  0299a	0f 83 96 00 00
	00		 jae	 $LN2@GCDialogIn

; 807  : 	{
; 808  : 		RESET_REWARD_DATA & ritem = this->m_reward[i];

  029a0	8b 45 98	 mov	 eax, DWORD PTR _i$231963[ebp]
  029a3	50		 push	 eax
  029a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  029a7	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  029ad	e8 00 00 00 00	 call	 ??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[]
  029b2	89 45 94	 mov	 DWORD PTR _ritem$231967[ebp], eax

; 809  : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  029b5	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  029b8	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  029be	83 c1 01	 add	 ecx, 1
  029c1	8b 55 94	 mov	 edx, DWORD PTR _ritem$231967[ebp]
  029c4	39 0a		 cmp	 DWORD PTR [edx], ecx
  029c6	75 69		 jne	 SHORT $LN1@GCDialogIn

; 810  : 		{
; 811  : 			pMsg.AddWcoinC = ritem.WcoinC;

  029c8	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  029cb	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  029cf	66 89 4d ca	 mov	 WORD PTR _pMsg$[ebp+22], cx

; 812  : 			pMsg.RewardEnableItem = ritem.EnableItem;

  029d3	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  029d6	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  029d9	88 4d e3	 mov	 BYTE PTR _pMsg$[ebp+47], cl

; 813  : 			pMsg.RewardItem = ITEMGET(ritem.Type, ritem.Index);

  029dc	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  029df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  029e2	c1 e1 09	 shl	 ecx, 9
  029e5	8b 55 94	 mov	 edx, DWORD PTR _ritem$231967[ebp]
  029e8	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  029eb	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+48], ecx

; 814  : 			pMsg.RewardLevel = ritem.Level;

  029ee	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  029f1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  029f4	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+52], ecx

; 815  : 			pMsg.RewardSkill = ritem.Skill;

  029f7	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  029fa	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  029fd	88 4d ec	 mov	 BYTE PTR _pMsg$[ebp+56], cl

; 816  : 			pMsg.RewardLuck = ritem.Luck;

  02a00	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  02a03	8a 48 19	 mov	 cl, BYTE PTR [eax+25]
  02a06	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+57], cl

; 817  : 			pMsg.RewardOpt = ritem.Opt;

  02a09	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  02a0c	8a 48 1a	 mov	 cl, BYTE PTR [eax+26]
  02a0f	88 4d ee	 mov	 BYTE PTR _pMsg$[ebp+58], cl

; 818  : 			pMsg.RewardExl = ritem.Exl;

  02a12	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  02a15	8a 48 1b	 mov	 cl, BYTE PTR [eax+27]
  02a18	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+59], cl

; 819  : 			pMsg.RewardAnc = ritem.Anc;

  02a1b	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  02a1e	8a 48 1c	 mov	 cl, BYTE PTR [eax+28]
  02a21	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+60], cl

; 820  : 			pMsg.AddCredits = ritem.Credit;

  02a24	8b 45 94	 mov	 eax, DWORD PTR _ritem$231967[ebp]
  02a27	66 8b 48 20	 mov	 cx, WORD PTR [eax+32]
  02a2b	66 89 4d c8	 mov	 WORD PTR _pMsg$[ebp+20], cx

; 821  : 			break;

  02a2f	eb 05		 jmp	 SHORT $LN2@GCDialogIn
$LN1@GCDialogIn:

; 822  : 		}
; 823  : 	}

  02a31	e9 4a ff ff ff	 jmp	 $LN3@GCDialogIn
$LN2@GCDialogIn:

; 824  : 
; 825  : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  02a36	0f b6 45 b5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02a3a	50		 push	 eax
  02a3b	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02a3e	51		 push	 ecx
  02a3f	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02a42	52		 push	 edx
  02a43	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02a48	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN71@GCDialogIn:

; 826  : }

  02a4b	5f		 pop	 edi
  02a4c	5e		 pop	 esi
  02a4d	5b		 pop	 ebx
  02a4e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02a51	33 cd		 xor	 ecx, ebp
  02a53	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02a58	8b e5		 mov	 esp, ebp
  02a5a	5d		 pop	 ebp
  02a5b	c2 04 00	 ret	 4
  02a5e	8b ff		 npad	 2
$LN73@GCDialogIn:
  02a60	00 00 00 00	 DD	 $LN39@GCDialogIn
  02a64	00 00 00 00	 DD	 $LN38@GCDialogIn
  02a68	00 00 00 00	 DD	 $LN37@GCDialogIn
  02a6c	00 00 00 00	 DD	 $LN36@GCDialogIn
  02a70	00 00 00 00	 DD	 $LN35@GCDialogIn
  02a74	00 00 00 00	 DD	 $LN34@GCDialogIn
  02a78	00 00 00 00	 DD	 $LN33@GCDialogIn
$LN74@GCDialogIn:
  02a7c	00 00 00 00	 DD	 $LN26@GCDialogIn
  02a80	00 00 00 00	 DD	 $LN25@GCDialogIn
  02a84	00 00 00 00	 DD	 $LN24@GCDialogIn
  02a88	00 00 00 00	 DD	 $LN23@GCDialogIn
  02a8c	00 00 00 00	 DD	 $LN22@GCDialogIn
  02a90	00 00 00 00	 DD	 $LN21@GCDialogIn
  02a94	00 00 00 00	 DD	 $LN20@GCDialogIn
$LN75@GCDialogIn:
  02a98	00 00 00 00	 DD	 $LN16@GCDialogIn
  02a9c	00 00 00 00	 DD	 $LN15@GCDialogIn
  02aa0	00 00 00 00	 DD	 $LN14@GCDialogIn
  02aa4	00 00 00 00	 DD	 $LN13@GCDialogIn
  02aa8	00 00 00 00	 DD	 $LN12@GCDialogIn
  02aac	00 00 00 00	 DD	 $LN11@GCDialogIn
  02ab0	00 00 00 00	 DD	 $LN10@GCDialogIn
?GCDialogInfo@cResetSystem@@QAEXH@Z ENDP		; cResetSystem::GCDialogInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@ ; `string'
PUBLIC	??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@ ; `string'
PUBLIC	??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@ ; `string'
PUBLIC	??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@ ; `string'
PUBLIC	?CGResulInfo@cResetSystem@@QAEXH@Z		; cResetSystem::CGResulInfo
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
;	COMDAT ??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\reset.cpp
CONST	SEGMENT
??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@ DB '[Reset]: '
	DB	'Need Reset Items', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@
CONST	SEGMENT
??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@ DB '['
	DB	'Reset]: You need above %d Zen to Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
CONST	SEGMENT
??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@ DB '['
	DB	'Reset]: You need above %d Level to Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@ DB '[Reset]: M'
	DB	'ax Reset %d', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv1232 = -116						; size = 4
tv1218 = -116						; size = 4
tv1204 = -116						; size = 4
tv1190 = -116						; size = 4
tv1227 = -112						; size = 4
tv1213 = -112						; size = 4
tv1199 = -112						; size = 4
tv1185 = -112						; size = 4
tv375 = -112						; size = 4
tv349 = -112						; size = 4
tv312 = -112						; size = 4
tv228 = -112						; size = 4
_ritem$232066 = -44					; size = 4
_i$232062 = -40						; size = 4
_nitem$232058 = -36					; size = 4
_i$232054 = -32						; size = 4
_LevelUpPoint$ = -28					; size = 4
_ZenMoney$ = -24					; size = 4
_i$231984 = -20						; size = 4
_SearchRes$ = -13					; size = 1
_iNeedLevel$ = -12					; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CGResulInfo@cResetSystem@@QAEXH@Z PROC			; cResetSystem::CGResulInfo
; _this$ = ecx

; 829  : {

  02ac0	55		 push	 ebp
  02ac1	8b ec		 mov	 ebp, esp
  02ac3	83 ec 74	 sub	 esp, 116		; 00000074H
  02ac6	53		 push	 ebx
  02ac7	56		 push	 esi
  02ac8	57		 push	 edi
  02ac9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 830  : 	if(!this->EnableResetSystem)return;

  02acc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02acf	83 38 00	 cmp	 DWORD PTR [eax], 0
  02ad2	75 05		 jne	 SHORT $LN82@CGResulInf
  02ad4	e9 a7 0e 00 00	 jmp	 $LN83@CGResulInf
$LN82@CGResulInf:

; 831  : 
; 832  : 	LPOBJ lpUser = &gObj[aIndex];

  02ad9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02adc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02ae2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ae8	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 833  : 
; 834  : 	if((GetTickCount() - lpUser->MySelfDefenseTime ) < 60000)

  02aeb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  02af1	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  02af4	2b 81 1c 04 00
	00		 sub	 eax, DWORD PTR [ecx+1052]
  02afa	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  02aff	73 34		 jae	 SHORT $LN81@CGResulInf

; 835  : 	{
; 836  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), aIndex, 1);

  02b01	6a 01		 push	 1
  02b03	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02b06	50		 push	 eax
  02b07	68 6d 04 00 00	 push	 1133			; 0000046dH
  02b0c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02b11	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02b16	50		 push	 eax
  02b17	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02b1c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 837  : 		GCCloseMsgSend(aIndex,-1);

  02b1f	68 ff 00 00 00	 push	 255			; 000000ffH
  02b24	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02b27	50		 push	 eax
  02b28	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  02b2d	83 c4 08	 add	 esp, 8

; 838  : 		return;

  02b30	e9 4b 0e 00 00	 jmp	 $LN83@CGResulInf
$LN81@CGResulInf:

; 839  : 	}
; 840  : 
; 841  : 	if(lpUser->MapNumber != this->m_iMapForReset)

  02b35	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02b38	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  02b3f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02b42	3b 4a 48	 cmp	 ecx, DWORD PTR [edx+72]
  02b45	74 2e		 je	 SHORT $LN80@CGResulInf

; 842  : 	{
; 843  : 		MsgNormal(aIndex, g_ExText.GetText(3), exMapName(this->m_iMapForReset));

  02b47	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02b4a	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  02b4d	51		 push	 ecx
  02b4e	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  02b53	83 c4 04	 add	 esp, 4
  02b56	50		 push	 eax
  02b57	6a 03		 push	 3
  02b59	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExText@@3VCExText@@A ; g_ExText
  02b5e	e8 00 00 00 00	 call	 ?GetText@CExText@@QAEPADH@Z ; CExText::GetText
  02b63	50		 push	 eax
  02b64	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02b67	52		 push	 edx
  02b68	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02b6d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 844  : 		return;

  02b70	e9 0b 0e 00 00	 jmp	 $LN83@CGResulInf
$LN80@CGResulInf:

; 845  : 	}
; 846  : 
; 847  : 	if(lpUser->SkillRecallParty_Time != 0)

  02b75	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02b78	0f b7 88 74 12
	00 00		 movzx	 ecx, WORD PTR [eax+4724]
  02b7f	85 c9		 test	 ecx, ecx
  02b81	74 16		 je	 SHORT $LN79@CGResulInf

; 848  : 	{
; 849  : 		MsgNormal(aIndex,"[Reset]: Skill Recall Party Time");

  02b83	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@
  02b88	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02b8b	50		 push	 eax
  02b8c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02b91	83 c4 08	 add	 esp, 8

; 850  : 		return;

  02b94	e9 e7 0d 00 00	 jmp	 $LN83@CGResulInf
$LN79@CGResulInf:

; 851  : 	}
; 852  : 	
; 853  : 	if(gMoveCommand.CheckInterfaceToMove(lpUser) == 0)

  02b99	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02b9c	50		 push	 eax
  02b9d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  02ba2	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  02ba7	85 c0		 test	 eax, eax
  02ba9	75 1a		 jne	 SHORT $LN78@CGResulInf

; 854  : 	{
; 855  : 		GCServerMsgStringSend("[Reset]: Interface Disable",lpUser->m_Index,1);

  02bab	6a 01		 push	 1
  02bad	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02bb0	8b 08		 mov	 ecx, DWORD PTR [eax]
  02bb2	51		 push	 ecx
  02bb3	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@
  02bb8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02bbd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 856  : 		return;

  02bc0	e9 bb 0d 00 00	 jmp	 $LN83@CGResulInf
$LN78@CGResulInf:

; 857  : 	}
; 858  : 
; 859  : 	if(lpUser->Reset >= this->Maxres)

  02bc5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02bc8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02bcb	8b 90 90 22 00
	00		 mov	 edx, DWORD PTR [eax+8848]
  02bd1	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  02bd4	7c 1d		 jl	 SHORT $LN77@CGResulInf

; 860  : 	{
; 861  : 		MsgNormal(aIndex,"[Reset]: Max Reset %d",this->Maxres);

  02bd6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02bd9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02bdc	51		 push	 ecx
  02bdd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@
  02be2	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02be5	52		 push	 edx
  02be6	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02beb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 862  : 		return;

  02bee	e9 8d 0d 00 00	 jmp	 $LN83@CGResulInf
$LN77@CGResulInf:

; 863  : 	}
; 864  : 	
; 865  : 	//  
; 866  : 	int iNeedLevel = this->NeedLevel;

  02bf3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02bf6	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02bf9	89 4d f4	 mov	 DWORD PTR _iNeedLevel$[ebp], ecx

; 867  : 
; 868  : 	bool SearchRes = false;

  02bfc	c6 45 f3 00	 mov	 BYTE PTR _SearchRes$[ebp], 0

; 869  : 	for(int i=0; i<this->lCount; i++)

  02c00	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$231984[ebp], 0
  02c07	eb 09		 jmp	 SHORT $LN76@CGResulInf
$LN75@CGResulInf:
  02c09	8b 45 ec	 mov	 eax, DWORD PTR _i$231984[ebp]
  02c0c	83 c0 01	 add	 eax, 1
  02c0f	89 45 ec	 mov	 DWORD PTR _i$231984[ebp], eax
$LN76@CGResulInf:
  02c12	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02c15	8b 4d ec	 mov	 ecx, DWORD PTR _i$231984[ebp]
  02c18	3b 88 c4 7d 00
	00		 cmp	 ecx, DWORD PTR [eax+32196]
  02c1e	0f 8d e4 00 00
	00		 jge	 $LN74@CGResulInf

; 870  : 	{
; 871  : 		if(g_ExLicense.user.Rage)

  02c24	0f b6 05 c9 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+201
  02c2b	85 c0		 test	 eax, eax
  02c2d	74 76		 je	 SHORT $LN73@CGResulInf

; 872  : 		{
; 873  : 			if(this->LevelRes[i].Res == (lpUser->Reset + 1))

  02c2f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02c32	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02c38	83 c1 01	 add	 ecx, 1
  02c3b	8b 55 ec	 mov	 edx, DWORD PTR _i$231984[ebp]
  02c3e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02c41	39 8c d0 84 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24196], ecx
  02c48	75 59		 jne	 SHORT $LN72@CGResulInf

; 874  : 			{
; 875  : 				if(this->LevelRes[i].Level - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpUser->Level)

  02c4a	6a 00		 push	 0
  02c4c	6a 07		 push	 7
  02c4e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02c51	50		 push	 eax
  02c52	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  02c57	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  02c5c	8b 4d ec	 mov	 ecx, DWORD PTR _i$231984[ebp]
  02c5f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02c62	8b 8c ca 88 5e
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*8+24200]
  02c69	2b c8		 sub	 ecx, eax
  02c6b	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  02c6e	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  02c75	3b c8		 cmp	 ecx, eax
  02c77	7e 24		 jle	 SHORT $LN71@CGResulInf

; 876  : 				{
; 877  : 					MsgNormal(aIndex,"[Reset]: You need above %d Level to Reset",this->LevelRes[i].Level);

  02c79	8b 45 ec	 mov	 eax, DWORD PTR _i$231984[ebp]
  02c7c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02c7f	8b 94 c1 88 5e
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+24200]
  02c86	52		 push	 edx
  02c87	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  02c8c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02c8f	50		 push	 eax
  02c90	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02c95	83 c4 0c	 add	 esp, 12			; 0000000cH

; 878  : 					return;

  02c98	e9 e3 0c 00 00	 jmp	 $LN83@CGResulInf
$LN71@CGResulInf:

; 879  : 				} 
; 880  : 				SearchRes = true; 

  02c9d	c6 45 f3 01	 mov	 BYTE PTR _SearchRes$[ebp], 1

; 881  : 				break;

  02ca1	eb 65		 jmp	 SHORT $LN74@CGResulInf
$LN72@CGResulInf:

; 882  : 			}
; 883  : 		}
; 884  : 		else

  02ca3	eb 5e		 jmp	 SHORT $LN69@CGResulInf
$LN73@CGResulInf:

; 885  : 		{
; 886  : 			if(this->LevelRes[i].Res == (lpUser->Reset + 1))

  02ca5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02ca8	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02cae	83 c1 01	 add	 ecx, 1
  02cb1	8b 55 ec	 mov	 edx, DWORD PTR _i$231984[ebp]
  02cb4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02cb7	39 8c d0 84 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24196], ecx
  02cbe	75 43		 jne	 SHORT $LN69@CGResulInf

; 887  : 			{
; 888  : 				if(this->LevelRes[i].Level > lpUser->Level)

  02cc0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02cc3	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  02cca	8b 55 ec	 mov	 edx, DWORD PTR _i$231984[ebp]
  02ccd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02cd0	39 8c d0 88 5e
	00 00		 cmp	 DWORD PTR [eax+edx*8+24200], ecx
  02cd7	7e 24		 jle	 SHORT $LN68@CGResulInf

; 889  : 				{
; 890  : 					MsgNormal(aIndex,"[Reset]: You need above %d Level to Reset",this->LevelRes[i].Level);

  02cd9	8b 45 ec	 mov	 eax, DWORD PTR _i$231984[ebp]
  02cdc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02cdf	8b 94 c1 88 5e
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+24200]
  02ce6	52		 push	 edx
  02ce7	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  02cec	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02cef	50		 push	 eax
  02cf0	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02cf5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 891  : 					return;

  02cf8	e9 83 0c 00 00	 jmp	 $LN83@CGResulInf
$LN68@CGResulInf:

; 892  : 				} 
; 893  : 				SearchRes = true; 

  02cfd	c6 45 f3 01	 mov	 BYTE PTR _SearchRes$[ebp], 1

; 894  : 				break;

  02d01	eb 05		 jmp	 SHORT $LN74@CGResulInf
$LN69@CGResulInf:

; 895  : 			}
; 896  : 		}
; 897  : 	} 

  02d03	e9 01 ff ff ff	 jmp	 $LN75@CGResulInf
$LN74@CGResulInf:

; 898  : 	if(!SearchRes)

  02d08	0f b6 45 f3	 movzx	 eax, BYTE PTR _SearchRes$[ebp]
  02d0c	85 c0		 test	 eax, eax
  02d0e	0f 85 95 00 00
	00		 jne	 $LN63@CGResulInf

; 899  : 	{
; 900  : 		if(g_ExLicense.user.Rage)

  02d14	0f b6 05 c9 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+201
  02d1b	85 c0		 test	 eax, eax
  02d1d	74 5b		 je	 SHORT $LN66@CGResulInf

; 901  : 		{
; 902  : 			if((this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpUser->Level))

  02d1f	6a 00		 push	 0
  02d21	6a 07		 push	 7
  02d23	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02d26	50		 push	 eax
  02d27	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  02d2c	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  02d31	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02d34	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02d37	2b d0		 sub	 edx, eax
  02d39	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02d3c	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  02d43	3b d1		 cmp	 edx, ecx
  02d45	7e 31		 jle	 SHORT $LN65@CGResulInf

; 903  : 			{
; 904  : 				MsgNormal(aIndex, "[Reset]: You need above %d Level to Reset", (this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0)));

  02d47	6a 00		 push	 0
  02d49	6a 07		 push	 7
  02d4b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02d4e	50		 push	 eax
  02d4f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  02d54	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  02d59	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02d5c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02d5f	2b d0		 sub	 edx, eax
  02d61	52		 push	 edx
  02d62	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  02d67	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02d6a	50		 push	 eax
  02d6b	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02d70	83 c4 0c	 add	 esp, 12			; 0000000cH

; 905  : 				return;

  02d73	e9 08 0c 00 00	 jmp	 $LN83@CGResulInf
$LN65@CGResulInf:

; 906  : 			}
; 907  : 		}
; 908  : 		else

  02d78	eb 2f		 jmp	 SHORT $LN63@CGResulInf
$LN66@CGResulInf:

; 909  : 		{
; 910  : 			if(this->NeedLevel > lpUser->Level)

  02d7a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02d7d	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  02d84	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02d87	39 4a 10	 cmp	 DWORD PTR [edx+16], ecx
  02d8a	7e 1d		 jle	 SHORT $LN63@CGResulInf

; 911  : 			{
; 912  : 				MsgNormal(aIndex,"[Reset]: You need above %d Level to Reset",this->NeedLevel);

  02d8c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02d8f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02d92	51		 push	 ecx
  02d93	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  02d98	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  02d9b	52		 push	 edx
  02d9c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02da1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 913  : 				return;

  02da4	e9 d7 0b 00 00	 jmp	 $LN83@CGResulInf
$LN63@CGResulInf:

; 914  : 			} 
; 915  : 		}
; 916  : 	}
; 917  : 
; 918  : 	//  
; 919  : 	int ZenMoney = 0;

  02da9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ZenMoney$[ebp], 0

; 920  : 
; 921  : 	switch(this->ZenForm)

  02db0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02db3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02db6	89 4d 90	 mov	 DWORD PTR tv228[ebp], ecx
  02db9	83 7d 90 01	 cmp	 DWORD PTR tv228[ebp], 1
  02dbd	74 08		 je	 SHORT $LN60@CGResulInf
  02dbf	83 7d 90 02	 cmp	 DWORD PTR tv228[ebp], 2
  02dc3	74 1a		 je	 SHORT $LN59@CGResulInf
  02dc5	eb 21		 jmp	 SHORT $LN61@CGResulInf
$LN60@CGResulInf:

; 922  : 	{
; 923  : 		case 1: ZenMoney = this->NeedZen * ( lpUser->Reset + 1 ); break;

  02dc7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02dca	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02dd0	83 c1 01	 add	 ecx, 1
  02dd3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02dd6	0f af 4a 0c	 imul	 ecx, DWORD PTR [edx+12]
  02dda	89 4d e8	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
  02ddd	eb 09		 jmp	 SHORT $LN61@CGResulInf
$LN59@CGResulInf:

; 924  : 		case 2: ZenMoney = this->NeedZen; break;

  02ddf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02de2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02de5	89 4d e8	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
$LN61@CGResulInf:

; 925  : 	}
; 926  : 
; 927  : 	if(this->ZenForm != 0)

  02de8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02deb	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  02def	74 28		 je	 SHORT $LN57@CGResulInf

; 928  : 	{
; 929  : 		if(lpUser->Money < ZenMoney)

  02df1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02df4	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  02dfa	3b 4d e8	 cmp	 ecx, DWORD PTR _ZenMoney$[ebp]
  02dfd	7d 1a		 jge	 SHORT $LN57@CGResulInf

; 930  : 		{
; 931  : 			MsgNormal(aIndex,"[Reset]: You need above %d Zen to Reset",ZenMoney);

  02dff	8b 45 e8	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  02e02	50		 push	 eax
  02e03	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@
  02e08	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  02e0b	51		 push	 ecx
  02e0c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02e11	83 c4 0c	 add	 esp, 12			; 0000000cH

; 932  : 			return;

  02e14	e9 67 0b 00 00	 jmp	 $LN83@CGResulInf
$LN57@CGResulInf:

; 933  : 		}
; 934  : 	}
; 935  : 
; 936  : 	//   
; 937  : 	if(this->NeedEmptyInv)

  02e19	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02e1c	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  02e20	0f 84 23 01 00
	00		 je	 $LN55@CGResulInf

; 938  : 	{
; 939  : 		if(lpUser->pInventory[0].m_Type != -1 || lpUser->pInventory[1].m_Type != -1 || lpUser->pInventory[2].m_Type != -1 ||
; 940  : 		   lpUser->pInventory[3].m_Type != -1 || lpUser->pInventory[4].m_Type != -1 || lpUser->pInventory[5].m_Type != -1 ||
; 941  : 		   lpUser->pInventory[6].m_Type != -1 || lpUser->pInventory[7].m_Type != -1 || lpUser->pInventory[8].m_Type != -1 ||
; 942  : 		   lpUser->pInventory[9].m_Type != -1 || lpUser->pInventory[10].m_Type != -1|| lpUser->pInventory[11].m_Type != -1)

  02e26	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02e29	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02e2f	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  02e33	83 fa ff	 cmp	 edx, -1
  02e36	0f 85 f7 00 00
	00		 jne	 $LN54@CGResulInf
  02e3c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02e3f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02e45	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  02e4c	83 fa ff	 cmp	 edx, -1
  02e4f	0f 85 de 00 00
	00		 jne	 $LN54@CGResulInf
  02e55	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02e58	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02e5e	0f bf 91 ae 01
	00 00		 movsx	 edx, WORD PTR [ecx+430]
  02e65	83 fa ff	 cmp	 edx, -1
  02e68	0f 85 c5 00 00
	00		 jne	 $LN54@CGResulInf
  02e6e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02e71	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02e77	0f bf 91 82 02
	00 00		 movsx	 edx, WORD PTR [ecx+642]
  02e7e	83 fa ff	 cmp	 edx, -1
  02e81	0f 85 ac 00 00
	00		 jne	 $LN54@CGResulInf
  02e87	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02e8a	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02e90	0f bf 91 56 03
	00 00		 movsx	 edx, WORD PTR [ecx+854]
  02e97	83 fa ff	 cmp	 edx, -1
  02e9a	0f 85 93 00 00
	00		 jne	 $LN54@CGResulInf
  02ea0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02ea3	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02ea9	0f bf 91 2a 04
	00 00		 movsx	 edx, WORD PTR [ecx+1066]
  02eb0	83 fa ff	 cmp	 edx, -1
  02eb3	75 7e		 jne	 SHORT $LN54@CGResulInf
  02eb5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02eb8	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02ebe	0f bf 91 fe 04
	00 00		 movsx	 edx, WORD PTR [ecx+1278]
  02ec5	83 fa ff	 cmp	 edx, -1
  02ec8	75 69		 jne	 SHORT $LN54@CGResulInf
  02eca	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02ecd	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02ed3	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  02eda	83 fa ff	 cmp	 edx, -1
  02edd	75 54		 jne	 SHORT $LN54@CGResulInf
  02edf	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02ee2	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02ee8	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  02eef	83 fa ff	 cmp	 edx, -1
  02ef2	75 3f		 jne	 SHORT $LN54@CGResulInf
  02ef4	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02ef7	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02efd	0f bf 91 7a 07
	00 00		 movsx	 edx, WORD PTR [ecx+1914]
  02f04	83 fa ff	 cmp	 edx, -1
  02f07	75 2a		 jne	 SHORT $LN54@CGResulInf
  02f09	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02f0c	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02f12	0f bf 91 4e 08
	00 00		 movsx	 edx, WORD PTR [ecx+2126]
  02f19	83 fa ff	 cmp	 edx, -1
  02f1c	75 15		 jne	 SHORT $LN54@CGResulInf
  02f1e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02f21	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  02f27	0f bf 91 22 09
	00 00		 movsx	 edx, WORD PTR [ecx+2338]
  02f2e	83 fa ff	 cmp	 edx, -1
  02f31	74 16		 je	 SHORT $LN55@CGResulInf
$LN54@CGResulInf:

; 943  : 		{
; 944  : 			MsgNormal(aIndex,"[Reset]: You need Empty Inventory to Reset");

  02f33	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@
  02f38	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  02f3b	50		 push	 eax
  02f3c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  02f41	83 c4 08	 add	 esp, 8

; 945  : 			return;

  02f44	e9 37 0a 00 00	 jmp	 $LN83@CGResulInf
$LN55@CGResulInf:

; 946  : 		}
; 947  : 	}
; 948  : 
; 949  : 	//  
; 950  : 	int LevelUpPoint = 0;

  02f49	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _LevelUpPoint$[ebp], 0

; 951  : 
; 952  : 	if(this->AddForm == 1 || this->AddForm == 2)

  02f50	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02f53	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  02f57	74 0d		 je	 SHORT $LN52@CGResulInf
  02f59	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02f5c	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  02f60	0f 85 ca 00 00
	00		 jne	 $LN50@CGResulInf
$LN52@CGResulInf:

; 953  : 	{
; 954  : 		switch (lpUser->Class)

  02f66	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02f69	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  02f70	89 4d 90	 mov	 DWORD PTR tv312[ebp], ecx
  02f73	83 7d 90 06	 cmp	 DWORD PTR tv312[ebp], 6
  02f77	0f 87 b3 00 00
	00		 ja	 $LN50@CGResulInf
  02f7d	8b 55 90	 mov	 edx, DWORD PTR tv312[ebp]
  02f80	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN85@CGResulInf[edx*4]
$LN49@CGResulInf:

; 955  : 		{
; 956  : 			case 0: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDW ;  break;

  02f87	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02f8a	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02f90	83 c1 01	 add	 ecx, 1
  02f93	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02f96	0f af 4a 18	 imul	 ecx, DWORD PTR [edx+24]
  02f9a	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02f9d	e9 8e 00 00 00	 jmp	 $LN50@CGResulInf
$LN48@CGResulInf:

; 957  : 			case 1: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDK ;  break;

  02fa2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02fa5	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02fab	83 c1 01	 add	 ecx, 1
  02fae	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02fb1	0f af 4a 1c	 imul	 ecx, DWORD PTR [edx+28]
  02fb5	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02fb8	eb 76		 jmp	 SHORT $LN50@CGResulInf
$LN47@CGResulInf:

; 958  : 			case 2: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsELF ; break;

  02fba	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02fbd	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02fc3	83 c1 01	 add	 ecx, 1
  02fc6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02fc9	0f af 4a 20	 imul	 ecx, DWORD PTR [edx+32]
  02fcd	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02fd0	eb 5e		 jmp	 SHORT $LN50@CGResulInf
$LN46@CGResulInf:

; 959  : 			case 3: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsMG ;  break;

  02fd2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02fd5	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02fdb	83 c1 01	 add	 ecx, 1
  02fde	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02fe1	0f af 4a 28	 imul	 ecx, DWORD PTR [edx+40]
  02fe5	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  02fe8	eb 46		 jmp	 SHORT $LN50@CGResulInf
$LN45@CGResulInf:

; 960  : 			case 4: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDL ;  break;

  02fea	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  02fed	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  02ff3	83 c1 01	 add	 ecx, 1
  02ff6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02ff9	0f af 4a 2c	 imul	 ecx, DWORD PTR [edx+44]
  02ffd	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  03000	eb 2e		 jmp	 SHORT $LN50@CGResulInf
$LN44@CGResulInf:

; 961  : 			case 5: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsSUM ; break;

  03002	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03005	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0300b	83 c1 01	 add	 ecx, 1
  0300e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03011	0f af 4a 24	 imul	 ecx, DWORD PTR [edx+36]
  03015	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  03018	eb 16		 jmp	 SHORT $LN50@CGResulInf
$LN43@CGResulInf:

; 962  : 			case 6: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsRF ; break;

  0301a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0301d	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  03023	83 c1 01	 add	 ecx, 1
  03026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03029	0f af 4a 30	 imul	 ecx, DWORD PTR [edx+48]
  0302d	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
$LN50@CGResulInf:

; 963  : 		}
; 964  : 	}
; 965  : 
; 966  : 	//   
; 967  : 	if(gGrandReset.EnableGrandResetSystem)

  03030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A, 0
  03037	0f 84 36 02 00
	00		 je	 $LN27@CGResulInf

; 968  : 	{
; 969  : 		if(lpUser->GReset > 0)

  0303d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03040	83 b8 94 22 00
	00 00		 cmp	 DWORD PTR [eax+8852], 0
  03047	0f 8e 26 02 00
	00		 jle	 $LN27@CGResulInf

; 970  : 		{
; 971  : 			if(gGrandReset.AddForm == 1 || gGrandReset.AddForm == 2)

  0304d	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 1
  03054	74 0d		 je	 SHORT $LN39@CGResulInf
  03056	83 3d 18 00 00
	00 02		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 2
  0305d	0f 85 ca 00 00
	00		 jne	 $LN37@CGResulInf
$LN39@CGResulInf:

; 972  : 			{
; 973  : 				switch (lpUser->Class)

  03063	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03066	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0306d	89 4d 90	 mov	 DWORD PTR tv349[ebp], ecx
  03070	83 7d 90 06	 cmp	 DWORD PTR tv349[ebp], 6
  03074	0f 87 b3 00 00
	00		 ja	 $LN37@CGResulInf
  0307a	8b 55 90	 mov	 edx, DWORD PTR tv349[ebp]
  0307d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN86@CGResulInf[edx*4]
$LN36@CGResulInf:

; 974  : 				{
; 975  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW ;  break;

  03084	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03087	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0308d	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  03094	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  03097	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0309a	e9 8e 00 00 00	 jmp	 $LN37@CGResulInf
$LN35@CGResulInf:

; 976  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK ;  break;

  0309f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  030a2	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  030a8	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  030af	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  030b2	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  030b5	eb 76		 jmp	 SHORT $LN37@CGResulInf
$LN34@CGResulInf:

; 977  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF ; break;

  030b7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  030ba	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  030c0	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  030c7	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  030ca	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  030cd	eb 5e		 jmp	 SHORT $LN37@CGResulInf
$LN33@CGResulInf:

; 978  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG ;  break;

  030cf	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  030d2	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  030d8	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  030df	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  030e2	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  030e5	eb 46		 jmp	 SHORT $LN37@CGResulInf
$LN32@CGResulInf:

; 979  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL ;  break;

  030e7	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  030ea	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  030f0	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  030f7	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  030fa	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  030fd	eb 2e		 jmp	 SHORT $LN37@CGResulInf
$LN31@CGResulInf:

; 980  : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM ; break;

  030ff	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03102	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  03108	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  0310f	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  03112	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  03115	eb 16		 jmp	 SHORT $LN37@CGResulInf
$LN30@CGResulInf:

; 981  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF ; break;

  03117	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0311a	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  03120	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
  03127	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  0312a	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
$LN37@CGResulInf:

; 982  : 				}
; 983  : 			}
; 984  : 			if(gGrandReset.AddForm == 3)

  0312d	83 3d 18 00 00
	00 03		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 3
  03134	0f 85 39 01 00
	00		 jne	 $LN27@CGResulInf

; 985  : 			{
; 986  : 				switch (lpUser->Class)

  0313a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0313d	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  03144	89 4d 90	 mov	 DWORD PTR tv375[ebp], ecx
  03147	83 7d 90 06	 cmp	 DWORD PTR tv375[ebp], 6
  0314b	0f 87 22 01 00
	00		 ja	 $LN27@CGResulInf
  03151	8b 55 90	 mov	 edx, DWORD PTR tv375[ebp]
  03154	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN87@CGResulInf[edx*4]
$LN26@CGResulInf:

; 987  : 				{
; 988  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW  * ( lpUser->Reset+1 ); break;

  0315b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0315e	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  03164	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  0316b	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0316e	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  03174	83 c0 01	 add	 eax, 1
  03177	0f af c8	 imul	 ecx, eax
  0317a	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  0317d	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  03180	e9 ee 00 00 00	 jmp	 $LN27@CGResulInf
$LN25@CGResulInf:

; 989  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK  * ( lpUser->Reset+1 ); break;

  03185	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03188	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  0318e	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  03195	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03198	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  0319e	83 c0 01	 add	 eax, 1
  031a1	0f af c8	 imul	 ecx, eax
  031a4	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  031a7	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  031aa	e9 c4 00 00 00	 jmp	 $LN27@CGResulInf
$LN24@CGResulInf:

; 990  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF * ( lpUser->Reset+1 ); break;

  031af	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  031b2	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  031b8	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  031bf	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  031c2	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  031c8	83 c0 01	 add	 eax, 1
  031cb	0f af c8	 imul	 ecx, eax
  031ce	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  031d1	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  031d4	e9 9a 00 00 00	 jmp	 $LN27@CGResulInf
$LN23@CGResulInf:

; 991  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG  * ( lpUser->Reset+1 ); break;

  031d9	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  031dc	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  031e2	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  031e9	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  031ec	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  031f2	83 c0 01	 add	 eax, 1
  031f5	0f af c8	 imul	 ecx, eax
  031f8	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  031fb	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  031fe	eb 73		 jmp	 SHORT $LN27@CGResulInf
$LN22@CGResulInf:

; 992  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL  * ( lpUser->Reset+1 ); break;

  03200	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03203	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  03209	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  03210	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03213	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  03219	83 c0 01	 add	 eax, 1
  0321c	0f af c8	 imul	 ecx, eax
  0321f	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  03222	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  03225	eb 4c		 jmp	 SHORT $LN27@CGResulInf
$LN21@CGResulInf:

; 993  : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM * ( lpUser->Reset+1 ); break;

  03227	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0322a	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  03230	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  03237	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0323a	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  03240	83 c0 01	 add	 eax, 1
  03243	0f af c8	 imul	 ecx, eax
  03246	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  03249	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
  0324c	eb 25		 jmp	 SHORT $LN27@CGResulInf
$LN20@CGResulInf:

; 994  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF  * ( lpUser->Reset+1 ); break;

  0324e	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03251	8b 88 94 22 00
	00		 mov	 ecx, DWORD PTR [eax+8852]
  03257	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
  0325e	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03261	8b 82 90 22 00
	00		 mov	 eax, DWORD PTR [edx+8848]
  03267	83 c0 01	 add	 eax, 1
  0326a	0f af c8	 imul	 ecx, eax
  0326d	03 4d e4	 add	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  03270	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx
$LN27@CGResulInf:

; 995  : 				}
; 996  : 			}
; 997  : 		}
; 998  : 	}
; 999  : 
; 1000 : 	LevelUpPoint += lpUser->ExFreePoints;

  03273	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03276	8b 4d e4	 mov	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  03279	03 88 8c 22 00
	00		 add	 ecx, DWORD PTR [eax+8844]
  0327f	89 4d e4	 mov	 DWORD PTR _LevelUpPoint$[ebp], ecx

; 1001 : 
; 1002 : 	/*
; 1003 : 	pMsg.AddCredits = this->AddCredits;
; 1004 : 	pMsg.AddWcoinC = this->AddWcoinC;
; 1005 : 	pMsg.AddWcoinP = this->AddWcoinP;
; 1006 : 	pMsg.AddWcoinG = this->AddGoblinPoint;
; 1007 : 	*/
; 1008 : 
; 1009 : 	// Need Item
; 1010 : 	for(int i = 0; i < this->m_needitem.size(); i++)

  03282	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$232054[ebp], 0
  03289	eb 09		 jmp	 SHORT $LN19@CGResulInf
$LN18@CGResulInf:
  0328b	8b 45 e0	 mov	 eax, DWORD PTR _i$232054[ebp]
  0328e	83 c0 01	 add	 eax, 1
  03291	89 45 e0	 mov	 DWORD PTR _i$232054[ebp], eax
$LN19@CGResulInf:
  03294	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03297	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  0329d	e8 00 00 00 00	 call	 ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
  032a2	39 45 e0	 cmp	 DWORD PTR _i$232054[ebp], eax
  032a5	0f 83 9e 00 00
	00		 jae	 $LN17@CGResulInf

; 1011 : 	{
; 1012 : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];

  032ab	8b 45 e0	 mov	 eax, DWORD PTR _i$232054[ebp]
  032ae	50		 push	 eax
  032af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  032b2	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  032b8	e8 00 00 00 00	 call	 ??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
  032bd	89 45 dc	 mov	 DWORD PTR _nitem$232058[ebp], eax

; 1013 : 		if(nitem.ResetNum == (lpUser->Reset + 1))

  032c0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  032c3	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  032c9	83 c1 01	 add	 ecx, 1
  032cc	8b 55 dc	 mov	 edx, DWORD PTR _nitem$232058[ebp]
  032cf	39 0a		 cmp	 DWORD PTR [edx], ecx
  032d1	75 71		 jne	 SHORT $LN16@CGResulInf

; 1014 : 		{
; 1015 : 			if(!SearchItem(aIndex, nitem.Type, nitem.Index, nitem.Level, nitem.Skill, nitem.Luck, nitem.Opt, nitem.Exl, nitem.Anc, nitem.Count, true))

  032d3	6a 01		 push	 1
  032d5	8b 45 dc	 mov	 eax, DWORD PTR _nitem$232058[ebp]
  032d8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  032db	51		 push	 ecx
  032dc	8b 55 dc	 mov	 edx, DWORD PTR _nitem$232058[ebp]
  032df	0f b6 42 14	 movzx	 eax, BYTE PTR [edx+20]
  032e3	50		 push	 eax
  032e4	8b 4d dc	 mov	 ecx, DWORD PTR _nitem$232058[ebp]
  032e7	0f b6 51 13	 movzx	 edx, BYTE PTR [ecx+19]
  032eb	52		 push	 edx
  032ec	8b 45 dc	 mov	 eax, DWORD PTR _nitem$232058[ebp]
  032ef	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  032f3	51		 push	 ecx
  032f4	8b 55 dc	 mov	 edx, DWORD PTR _nitem$232058[ebp]
  032f7	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  032fb	50		 push	 eax
  032fc	8b 4d dc	 mov	 ecx, DWORD PTR _nitem$232058[ebp]
  032ff	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  03303	52		 push	 edx
  03304	8b 45 dc	 mov	 eax, DWORD PTR _nitem$232058[ebp]
  03307	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0330a	51		 push	 ecx
  0330b	8b 55 dc	 mov	 edx, DWORD PTR _nitem$232058[ebp]
  0330e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  03311	50		 push	 eax
  03312	8b 4d dc	 mov	 ecx, DWORD PTR _nitem$232058[ebp]
  03315	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  03318	52		 push	 edx
  03319	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0331c	50		 push	 eax
  0331d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03320	e8 00 00 00 00	 call	 ?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z ; cResetSystem::SearchItem
  03325	0f b6 c8	 movzx	 ecx, al
  03328	85 c9		 test	 ecx, ecx
  0332a	75 16		 jne	 SHORT $LN15@CGResulInf

; 1016 : 			{
; 1017 : 				MsgNormal(aIndex,"[Reset]: Need Reset Items");

  0332c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@
  03331	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03334	50		 push	 eax
  03335	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0333a	83 c4 08	 add	 esp, 8

; 1018 : 				return;

  0333d	e9 3e 06 00 00	 jmp	 $LN83@CGResulInf
$LN15@CGResulInf:

; 1019 : 			}
; 1020 : 			break;

  03342	eb 05		 jmp	 SHORT $LN17@CGResulInf
$LN16@CGResulInf:

; 1021 : 		}
; 1022 : 	}

  03344	e9 42 ff ff ff	 jmp	 $LN18@CGResulInf
$LN17@CGResulInf:

; 1023 : 
; 1024 : 	//reward Item
; 1025 : 	for(int i = 0; i < this->m_reward.size(); i++)

  03349	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$232062[ebp], 0
  03350	eb 09		 jmp	 SHORT $LN14@CGResulInf
$LN13@CGResulInf:
  03352	8b 45 d8	 mov	 eax, DWORD PTR _i$232062[ebp]
  03355	83 c0 01	 add	 eax, 1
  03358	89 45 d8	 mov	 DWORD PTR _i$232062[ebp], eax
$LN14@CGResulInf:
  0335b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0335e	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  03364	e8 00 00 00 00	 call	 ?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
  03369	39 45 d8	 cmp	 DWORD PTR _i$232062[ebp], eax
  0336c	0f 83 03 01 00
	00		 jae	 $LN12@CGResulInf

; 1026 : 	{
; 1027 : 		RESET_REWARD_DATA & ritem = this->m_reward[i];

  03372	8b 45 d8	 mov	 eax, DWORD PTR _i$232062[ebp]
  03375	50		 push	 eax
  03376	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03379	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  0337f	e8 00 00 00 00	 call	 ??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[]
  03384	89 45 d4	 mov	 DWORD PTR _ritem$232066[ebp], eax

; 1028 : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  03387	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0338a	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  03390	83 c1 01	 add	 ecx, 1
  03393	8b 55 d4	 mov	 edx, DWORD PTR _ritem$232066[ebp]
  03396	39 0a		 cmp	 DWORD PTR [edx], ecx
  03398	0f 85 d2 00 00
	00		 jne	 $LN11@CGResulInf

; 1029 : 		{
; 1030 : 			if(ritem.WcoinC > 0)

  0339e	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  033a1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  033a5	7e 28		 jle	 SHORT $LN10@CGResulInf

; 1031 : 			{
; 1032 : 				lpUser->GameShop.WCoinC += ritem.WcoinC;

  033a7	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  033aa	db 40 04	 fild	 DWORD PTR [eax+4]
  033ad	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  033b0	dc 81 00 23 00
	00		 fadd	 QWORD PTR [ecx+8960]
  033b6	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  033b9	dd 9a 00 23 00
	00		 fstp	 QWORD PTR [edx+8960]

; 1033 : 				gGameShop.GDSaveUserInfo(lpUser->m_Index);

  033bf	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  033c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  033c4	51		 push	 ecx
  033c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  033ca	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN10@CGResulInf:

; 1034 : 			}
; 1035 : 			if(ritem.EnableItem)

  033cf	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  033d2	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  033d6	85 c9		 test	 ecx, ecx
  033d8	74 73		 je	 SHORT $LN9@CGResulInf

; 1036 : 			{
; 1037 : 				ItemSerialCreateSend(aIndex,lpUser->MapNumber,lpUser->X,lpUser->Y,ITEMGET(ritem.Type, ritem.Index),ritem.Level,0,ritem.Skill,ritem.Luck,ritem.Opt,aIndex,ritem.Exl,ritem.Anc);

  033da	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  033dd	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  033e1	51		 push	 ecx
  033e2	8b 55 d4	 mov	 edx, DWORD PTR _ritem$232066[ebp]
  033e5	0f b6 42 1b	 movzx	 eax, BYTE PTR [edx+27]
  033e9	50		 push	 eax
  033ea	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  033ed	51		 push	 ecx
  033ee	8b 55 d4	 mov	 edx, DWORD PTR _ritem$232066[ebp]
  033f1	0f b6 42 1a	 movzx	 eax, BYTE PTR [edx+26]
  033f5	50		 push	 eax
  033f6	8b 4d d4	 mov	 ecx, DWORD PTR _ritem$232066[ebp]
  033f9	0f b6 51 19	 movzx	 edx, BYTE PTR [ecx+25]
  033fd	52		 push	 edx
  033fe	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  03401	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  03405	51		 push	 ecx
  03406	6a 00		 push	 0
  03408	8b 55 d4	 mov	 edx, DWORD PTR _ritem$232066[ebp]
  0340b	0f b6 42 14	 movzx	 eax, BYTE PTR [edx+20]
  0340f	50		 push	 eax
  03410	8b 4d d4	 mov	 ecx, DWORD PTR _ritem$232066[ebp]
  03413	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  03416	c1 e2 09	 shl	 edx, 9
  03419	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  0341c	03 50 10	 add	 edx, DWORD PTR [eax+16]
  0341f	52		 push	 edx
  03420	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03423	0f b6 91 46 01
	00 00		 movzx	 edx, BYTE PTR [ecx+326]
  0342a	52		 push	 edx
  0342b	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0342e	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  03435	51		 push	 ecx
  03436	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03439	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  03440	50		 push	 eax
  03441	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  03444	51		 push	 ecx
  03445	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0344a	83 c4 34	 add	 esp, 52			; 00000034H
$LN9@CGResulInf:

; 1038 : 			}
; 1039 : 			if(ritem.Credit > 0)

  0344d	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  03450	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  03454	7e 18		 jle	 SHORT $LN8@CGResulInf

; 1040 : 			{
; 1041 : 				lpUser->ExCred += ritem.Credit;

  03456	8b 45 d4	 mov	 eax, DWORD PTR _ritem$232066[ebp]
  03459	db 40 20	 fild	 DWORD PTR [eax+32]
  0345c	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0345f	d8 81 a8 22 00
	00		 fadd	 DWORD PTR [ecx+8872]
  03465	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03468	d9 9a a8 22 00
	00		 fstp	 DWORD PTR [edx+8872]
$LN8@CGResulInf:

; 1042 : 			}
; 1043 : 			break;

  0346e	eb 05		 jmp	 SHORT $LN12@CGResulInf
$LN11@CGResulInf:

; 1044 : 		}
; 1045 : 	}

  03470	e9 dd fe ff ff	 jmp	 $LN13@CGResulInf
$LN12@CGResulInf:

; 1046 : 
; 1047 : 	/////////////////////
; 1048 : 	// //
; 1049 : 	/////////////////////
; 1050 : 	lpUser->Money -= ZenMoney;

  03475	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03478	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0347e	2b 4d e8	 sub	 ecx, DWORD PTR _ZenMoney$[ebp]
  03481	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03484	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 1051 : 	lpUser->Level = 1;

  0348a	b8 01 00 00 00	 mov	 eax, 1
  0348f	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03492	66 89 81 be 00
	00 00		 mov	 WORD PTR [ecx+190], ax

; 1052 : 	lpUser->Experience = 0;

  03499	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0349c	c7 80 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+200], 0

; 1053 : 	lpUser->NextExp = 100;

  034a6	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  034a9	c7 80 cc 00 00
	00 64 00 00 00	 mov	 DWORD PTR [eax+204], 100 ; 00000064H

; 1054 : 	if(this->AddForm == 2)

  034b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  034b6	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  034ba	75 5a		 jne	 SHORT $LN6@CGResulInf

; 1055 : 	{
; 1056 : 		lpUser->Strength = 25;

  034bc	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  034c1	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  034c4	66 89 81 f4 00
	00 00		 mov	 WORD PTR [ecx+244], ax

; 1057 : 		lpUser->Dexterity = 25;

  034cb	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  034d0	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  034d3	66 89 81 f6 00
	00 00		 mov	 WORD PTR [ecx+246], ax

; 1058 : 		lpUser->Vitality = 25;

  034da	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  034df	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  034e2	66 89 81 f8 00
	00 00		 mov	 WORD PTR [ecx+248], ax

; 1059 : 		lpUser->Energy = 25;

  034e9	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  034ee	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  034f1	66 89 81 fa 00
	00 00		 mov	 WORD PTR [ecx+250], ax

; 1060 : 
; 1061 : 		if(lpUser->Class == 4)

  034f8	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  034fb	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  03502	83 f9 04	 cmp	 ecx, 4
  03505	75 0f		 jne	 SHORT $LN6@CGResulInf

; 1062 : 		{
; 1063 : 			lpUser->Leadership = 25;

  03507	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  0350c	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0350f	66 89 81 18 01
	00 00		 mov	 WORD PTR [ecx+280], ax
$LN6@CGResulInf:

; 1064 : 		}
; 1065 : 	}
; 1066 : 	lpUser->LevelUpPoint = LevelUpPoint;

  03516	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03519	8b 4d e4	 mov	 ecx, DWORD PTR _LevelUpPoint$[ebp]
  0351c	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx

; 1067 : 	
; 1068 : 	lpUser->Reset++;

  03522	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03525	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  0352b	83 c1 01	 add	 ecx, 1
  0352e	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03531	89 8a 90 22 00
	00		 mov	 DWORD PTR [edx+8848], ecx

; 1069 : 
; 1070 : 	if(this->AddCredits>0)

  03537	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0353a	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0353e	7e 18		 jle	 SHORT $LN5@CGResulInf

; 1071 : 	{
; 1072 : 		lpUser->ExCred += AddCredits;

  03540	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03543	db 40 38	 fild	 DWORD PTR [eax+56]
  03546	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03549	d8 81 a8 22 00
	00		 fadd	 DWORD PTR [ecx+8872]
  0354f	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03552	d9 9a a8 22 00
	00		 fstp	 DWORD PTR [edx+8872]
$LN5@CGResulInf:

; 1073 : 	}
; 1074 : 
; 1075 : 	/*if(this->AddWcoinC > 0)
; 1076 : 	{
; 1077 : 		lpUser->GameShop.WCoinC += this->AddWcoinC;
; 1078 : 	}*/
; 1079 : 	if(this->AddWcoinP > 0)

  03558	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0355b	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  0355f	7e 18		 jle	 SHORT $LN4@CGResulInf

; 1080 : 	{
; 1081 : 		lpUser->GameShop.WCoinP += this->AddWcoinP;

  03561	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03564	db 40 40	 fild	 DWORD PTR [eax+64]
  03567	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0356a	dc 81 f8 22 00
	00		 fadd	 QWORD PTR [ecx+8952]
  03570	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03573	dd 9a f8 22 00
	00		 fstp	 QWORD PTR [edx+8952]
$LN4@CGResulInf:

; 1082 : 	}
; 1083 : 	if(this->AddGoblinPoint > 0)

  03579	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0357c	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  03580	7e 18		 jle	 SHORT $LN3@CGResulInf

; 1084 : 	{
; 1085 : 		lpUser->GameShop.GoblinPoint += this->AddGoblinPoint;

  03582	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  03585	db 40 44	 fild	 DWORD PTR [eax+68]
  03588	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0358b	dc 81 08 23 00
	00		 fadd	 QWORD PTR [ecx+8968]
  03591	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03594	dd 9a 08 23 00
	00		 fstp	 QWORD PTR [edx+8968]
$LN3@CGResulInf:

; 1086 : 	}
; 1087 : 
; 1088 : 	if(this->AddWcoinC > 0 || this->AddWcoinP > 0 || this->AddGoblinPoint > 0)

  0359a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0359d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  035a1	7f 12		 jg	 SHORT $LN1@CGResulInf
  035a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  035a6	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  035aa	7f 09		 jg	 SHORT $LN1@CGResulInf
  035ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  035af	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  035b3	7e 0e		 jle	 SHORT $LN2@CGResulInf
$LN1@CGResulInf:

; 1089 : 	{
; 1090 : 		gGameShop.GDSaveUserInfo(aIndex);

  035b5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  035b8	50		 push	 eax
  035b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  035be	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN2@CGResulInf:

; 1091 : 	}	
; 1092 : 
; 1093 : 	ExFireCracker(aIndex, lpUser->X, lpUser->Y);

  035c3	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  035c6	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  035cd	51		 push	 ecx
  035ce	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  035d1	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  035d8	50		 push	 eax
  035d9	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  035dc	51		 push	 ecx
  035dd	e8 00 00 00 00	 call	 ?ExFireCracker@@YAXHEE@Z ; ExFireCracker
  035e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1094 : 
; 1095 : 	lpUser->Life = DCInfo.DefClass[lpUser->Class].Life + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelLife  + ((lpUser->Vitality - DCInfo.DefClass[lpUser->Class].Vitality ) * DCInfo.DefClass[lpUser->Class].VitalityToLife);

  035e5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  035e8	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  035ef	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  035f5	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  035f8	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  035ff	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03602	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  03609	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  0360d	89 45 90	 mov	 DWORD PTR tv1185[ebp], eax
  03610	db 45 90	 fild	 DWORD PTR tv1185[ebp]
  03613	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03616	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  0361d	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  03623	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  03629	d8 81 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+20]
  0362f	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03632	0f b7 91 f8 00
	00 00		 movzx	 edx, WORD PTR [ecx+248]
  03639	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0363c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  03643	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  03649	0f b7 81 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+12]
  03650	2b d0		 sub	 edx, eax
  03652	89 55 8c	 mov	 DWORD PTR tv1190[ebp], edx
  03655	db 45 8c	 fild	 DWORD PTR tv1190[ebp]
  03658	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0365b	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  03662	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  03668	d8 8a 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+40]
  0366e	de c1		 faddp	 ST(1), ST(0)
  03670	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03673	d9 98 fc 00 00
	00		 fstp	 DWORD PTR [eax+252]

; 1096 : 	lpUser->Mana = DCInfo.DefClass[lpUser->Class].Mana + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelMana  + ((lpUser->Energy - DCInfo.DefClass[lpUser->Class].Energy ) * DCInfo.DefClass[lpUser->Class].EnergyToMana);

  03679	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0367c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  03683	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  03689	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0368c	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  03693	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03696	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  0369d	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  036a1	89 45 90	 mov	 DWORD PTR tv1199[ebp], eax
  036a4	db 45 90	 fild	 DWORD PTR tv1199[ebp]
  036a7	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  036aa	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  036b1	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  036b7	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  036bd	d8 81 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+32]
  036c3	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  036c6	0f b7 91 fa 00
	00 00		 movzx	 edx, WORD PTR [ecx+250]
  036cd	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  036d0	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  036d7	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  036dd	0f b7 81 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+14]
  036e4	2b d0		 sub	 edx, eax
  036e6	89 55 8c	 mov	 DWORD PTR tv1204[ebp], edx
  036e9	db 45 8c	 fild	 DWORD PTR tv1204[ebp]
  036ec	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  036ef	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  036f6	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  036fc	d8 8a 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+44]
  03702	de c1		 faddp	 ST(1), ST(0)
  03704	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03707	d9 98 10 01 00
	00		 fstp	 DWORD PTR [eax+272]

; 1097 : 
; 1098 : 	lpUser->MaxLife = DCInfo.DefClass[lpUser->Class].Life + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelLife  + ((lpUser->Vitality - DCInfo.DefClass[lpUser->Class].Vitality ) * DCInfo.DefClass[lpUser->Class].VitalityToLife);

  0370d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03710	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  03717	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  0371d	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03720	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  03727	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0372a	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  03731	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  03735	89 45 90	 mov	 DWORD PTR tv1213[ebp], eax
  03738	db 45 90	 fild	 DWORD PTR tv1213[ebp]
  0373b	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  0373e	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  03745	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  0374b	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  03751	d8 81 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+20]
  03757	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0375a	0f b7 91 f8 00
	00 00		 movzx	 edx, WORD PTR [ecx+248]
  03761	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03764	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0376b	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  03771	0f b7 81 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+12]
  03778	2b d0		 sub	 edx, eax
  0377a	89 55 8c	 mov	 DWORD PTR tv1218[ebp], edx
  0377d	db 45 8c	 fild	 DWORD PTR tv1218[ebp]
  03780	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03783	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  0378a	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  03790	d8 8a 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+40]
  03796	de c1		 faddp	 ST(1), ST(0)
  03798	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0379b	d9 98 00 01 00
	00		 fstp	 DWORD PTR [eax+256]

; 1099 : 	lpUser->MaxMana = DCInfo.DefClass[lpUser->Class].Mana + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelMana  + ((lpUser->Energy - DCInfo.DefClass[lpUser->Class].Energy ) * DCInfo.DefClass[lpUser->Class].EnergyToMana);

  037a1	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  037a4	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  037ab	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  037b1	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  037b4	0f bf 82 be 00
	00 00		 movsx	 eax, WORD PTR [edx+190]
  037bb	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  037be	0f bf 92 d0 00
	00 00		 movsx	 edx, WORD PTR [edx+208]
  037c5	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  037c9	89 45 90	 mov	 DWORD PTR tv1227[ebp], eax
  037cc	db 45 90	 fild	 DWORD PTR tv1227[ebp]
  037cf	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  037d2	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  037d9	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  037df	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  037e5	d8 81 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+32]
  037eb	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  037ee	0f b7 91 fa 00
	00 00		 movzx	 edx, WORD PTR [ecx+250]
  037f5	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  037f8	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  037ff	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  03805	0f b7 81 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+14]
  0380c	2b d0		 sub	 edx, eax
  0380e	89 55 8c	 mov	 DWORD PTR tv1232[ebp], edx
  03811	db 45 8c	 fild	 DWORD PTR tv1232[ebp]
  03814	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03817	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  0381e	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  03824	d8 8a 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+44]
  0382a	de c1		 faddp	 ST(1), ST(0)
  0382c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0382f	d9 98 14 01 00
	00		 fstp	 DWORD PTR [eax+276]

; 1100 : 
; 1101 : 	lpUser->VitalityToLife = DCInfo.DefClass[lpUser->Class].VitalityToLife;

  03835	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03838	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0383f	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  03845	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03848	d9 81 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+40]
  0384e	d9 9a 34 01 00
	00		 fstp	 DWORD PTR [edx+308]

; 1102 : 	lpUser->EnergyToMana = DCInfo.DefClass[lpUser->Class].EnergyToMana;

  03854	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03857	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0385e	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  03864	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03867	d9 81 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+44]
  0386d	d9 9a 38 01 00
	00		 fstp	 DWORD PTR [edx+312]

; 1103 : 
; 1104 : 	::gObjSetBP(aIndex);

  03873	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03876	50		 push	 eax
  03877	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  0387c	83 c4 04	 add	 esp, 4

; 1105 : 	lpUser->BP = lpUser->MaxBP / 2;

  0387f	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03882	8b 80 2c 01 00
	00		 mov	 eax, DWORD PTR [eax+300]
  03888	99		 cdq
  03889	2b c2		 sub	 eax, edx
  0388b	d1 f8		 sar	 eax, 1
  0388d	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03890	89 81 28 01 00
	00		 mov	 DWORD PTR [ecx+296], eax

; 1106 : 	::gObjCalcMaxLifePower(aIndex);

  03896	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03899	50		 push	 eax
  0389a	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  0389f	83 c4 04	 add	 esp, 4

; 1107 : 
; 1108 : 	GCReFillSend(aIndex, (int)lpUser->MaxLife + lpUser->AddLife, 0xFE, 0, lpUser->iMaxShield + lpUser->iAddShield);

  038a2	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  038a5	8b 88 58 01 00
	00		 mov	 ecx, DWORD PTR [eax+344]
  038ab	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  038ae	03 8a 5c 01 00
	00		 add	 ecx, DWORD PTR [edx+348]
  038b4	51		 push	 ecx
  038b5	6a 00		 push	 0
  038b7	68 fe 00 00 00	 push	 254			; 000000feH
  038bc	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  038bf	d9 80 00 01 00
	00		 fld	 DWORD PTR [eax+256]
  038c5	e8 00 00 00 00	 call	 __ftol2_sse
  038ca	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  038cd	03 81 4c 01 00
	00		 add	 eax, DWORD PTR [ecx+332]
  038d3	50		 push	 eax
  038d4	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  038d7	52		 push	 edx
  038d8	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  038dd	83 c4 14	 add	 esp, 20			; 00000014H

; 1109 : 	//gObjSetBP(aIndex);
; 1110 : 	GCManaSend(aIndex,(int)lpUser->MaxMana + lpUser->AddMana, 0xFE, 0, lpUser->MaxBP + lpUser->AddBP);

  038e0	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  038e3	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  038e9	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  038ec	03 8a 30 01 00
	00		 add	 ecx, DWORD PTR [edx+304]
  038f2	51		 push	 ecx
  038f3	6a 00		 push	 0
  038f5	68 fe 00 00 00	 push	 254			; 000000feH
  038fa	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  038fd	d9 80 14 01 00
	00		 fld	 DWORD PTR [eax+276]
  03903	e8 00 00 00 00	 call	 __ftol2_sse
  03908	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0390b	03 81 50 01 00
	00		 add	 eax, DWORD PTR [ecx+336]
  03911	50		 push	 eax
  03912	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  03915	52		 push	 edx
  03916	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  0391b	83 c4 14	 add	 esp, 20			; 00000014H

; 1111 : 	gObjCalCharacter(aIndex);

  0391e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03921	50		 push	 eax
  03922	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  03927	83 c4 04	 add	 esp, 4

; 1112 : 
; 1113 : 	//gObjCloseSet(aIndex, 1);
; 1114 : 	ResetSystemGC_CharUpdate(lpUser);

  0392a	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0392d	50		 push	 eax
  0392e	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate
  03933	83 c4 04	 add	 esp, 4

; 1115 : 
; 1116 : 	GCMoneySend(aIndex, lpUser->Money);

  03936	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03939	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0393f	51		 push	 ecx
  03940	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  03943	52		 push	 edx
  03944	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  03949	83 c4 08	 add	 esp, 8

; 1117 : 	LogAddTD("[ResetSystem] Accaunt: %s , Name: %s , Reset: %d",lpUser->AccountID, lpUser->Name,lpUser->Reset);

  0394c	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  0394f	8b 88 90 22 00
	00		 mov	 ecx, DWORD PTR [eax+8848]
  03955	51		 push	 ecx
  03956	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03959	83 c2 77	 add	 edx, 119		; 00000077H
  0395c	52		 push	 edx
  0395d	8b 45 f8	 mov	 eax, DWORD PTR _lpUser$[ebp]
  03960	83 c0 6c	 add	 eax, 108		; 0000006cH
  03963	50		 push	 eax
  03964	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@
  03969	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0396f	83 c4 10	 add	 esp, 16			; 00000010H

; 1118 : 
; 1119 : #if(SYSTEM_ACHIEVEMENTS)
; 1120 : 	g_Achievements.ResetUp(aIndex);

  03972	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03975	50		 push	 eax
  03976	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  0397b	e8 00 00 00 00	 call	 ?ResetUp@CAchievements@@QAEXH@Z ; CAchievements::ResetUp
$LN83@CGResulInf:

; 1121 : #endif
; 1122 : }

  03980	5f		 pop	 edi
  03981	5e		 pop	 esi
  03982	5b		 pop	 ebx
  03983	8b e5		 mov	 esp, ebp
  03985	5d		 pop	 ebp
  03986	c2 04 00	 ret	 4
  03989	8d 49 00	 npad	 3
$LN85@CGResulInf:
  0398c	00 00 00 00	 DD	 $LN49@CGResulInf
  03990	00 00 00 00	 DD	 $LN48@CGResulInf
  03994	00 00 00 00	 DD	 $LN47@CGResulInf
  03998	00 00 00 00	 DD	 $LN46@CGResulInf
  0399c	00 00 00 00	 DD	 $LN45@CGResulInf
  039a0	00 00 00 00	 DD	 $LN44@CGResulInf
  039a4	00 00 00 00	 DD	 $LN43@CGResulInf
$LN86@CGResulInf:
  039a8	00 00 00 00	 DD	 $LN36@CGResulInf
  039ac	00 00 00 00	 DD	 $LN35@CGResulInf
  039b0	00 00 00 00	 DD	 $LN34@CGResulInf
  039b4	00 00 00 00	 DD	 $LN33@CGResulInf
  039b8	00 00 00 00	 DD	 $LN32@CGResulInf
  039bc	00 00 00 00	 DD	 $LN31@CGResulInf
  039c0	00 00 00 00	 DD	 $LN30@CGResulInf
$LN87@CGResulInf:
  039c4	00 00 00 00	 DD	 $LN26@CGResulInf
  039c8	00 00 00 00	 DD	 $LN25@CGResulInf
  039cc	00 00 00 00	 DD	 $LN24@CGResulInf
  039d0	00 00 00 00	 DD	 $LN23@CGResulInf
  039d4	00 00 00 00	 DD	 $LN22@CGResulInf
  039d8	00 00 00 00	 DD	 $LN21@CGResulInf
  039dc	00 00 00 00	 DD	 $LN20@CGResulInf
?CGResulInfo@cResetSystem@@QAEXH@Z ENDP			; cResetSystem::CGResulInfo
_TEXT	ENDS
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?CheckOptionItem@@YA_NHHH@Z:PROC		; CheckOptionItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$232105 = -28						; size = 4
_iDelCount$232104 = -24					; size = 4
_i$232097 = -20						; size = 4
_iType$ = -16						; size = 2
_iCount$ = -12						; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 4
_Index$ = 16						; size = 4
_Level$ = 20						; size = 4
_Skill$ = 24						; size = 1
_Luck$ = 28						; size = 1
_Opt$ = 32						; size = 1
_Exl$ = 36						; size = 1
_Anc$ = 40						; size = 1
_count$ = 44						; size = 4
_del$ = 48						; size = 1
?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z PROC	; cResetSystem::SearchItem
; _this$ = ecx

; 1125 : {

  039e0	55		 push	 ebp
  039e1	8b ec		 mov	 ebp, esp
  039e3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  039e6	53		 push	 ebx
  039e7	56		 push	 esi
  039e8	57		 push	 edi
  039e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1126 : 	LPOBJ lpUser = &gObj[aIndex];

  039ec	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  039ef	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  039f5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  039fb	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 1127 : 	int iCount = 0;

  039fe	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0

; 1128 : 	short iType = ITEMGET(Type, Index);

  03a05	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  03a08	c1 e0 09	 shl	 eax, 9
  03a0b	03 45 10	 add	 eax, DWORD PTR _Index$[ebp]
  03a0e	66 89 45 f0	 mov	 WORD PTR _iType$[ebp], ax

; 1129 : 
; 1130 : 	for (int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  03a12	c7 45 ec 0c 00
	00 00		 mov	 DWORD PTR _i$232097[ebp], 12 ; 0000000cH
  03a19	eb 09		 jmp	 SHORT $LN12@SearchItem
$LN11@SearchItem:
  03a1b	8b 45 ec	 mov	 eax, DWORD PTR _i$232097[ebp]
  03a1e	83 c0 01	 add	 eax, 1
  03a21	89 45 ec	 mov	 DWORD PTR _i$232097[ebp], eax
$LN12@SearchItem:
  03a24	81 7d ec ec 00
	00 00		 cmp	 DWORD PTR _i$232097[ebp], 236 ; 000000ecH
  03a2b	0f 8d 4e 01 00
	00		 jge	 $LN10@SearchItem

; 1131 : 	{
; 1132 : 		if( lpUser->pInventory[i].m_Type == iType && 
; 1133 : 			lpUser->pInventory[i].m_Level >= Level &&
; 1134 : 			CheckOptionItem(lpUser->pInventory[i].m_Option1, Skill, FALSE) &&
; 1135 : 			CheckOptionItem(lpUser->pInventory[i].m_Option2, Luck, FALSE) &&
; 1136 : 			CheckOptionItem(lpUser->pInventory[i].m_Option3, Opt, FALSE) &&
; 1137 : 			CheckOptionItem(lpUser->pInventory[i].m_NewOption, Exl, FALSE) &&
; 1138 : 			CheckOptionItem(lpUser->pInventory[i].m_SetOption, Anc, FALSE) )

  03a31	8b 45 ec	 mov	 eax, DWORD PTR _i$232097[ebp]
  03a34	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  03a3a	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03a3d	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03a43	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  03a48	0f bf 4d f0	 movsx	 ecx, WORD PTR _iType$[ebp]
  03a4c	3b c1		 cmp	 eax, ecx
  03a4e	0f 85 26 01 00
	00		 jne	 $LN9@SearchItem
  03a54	8b 45 ec	 mov	 eax, DWORD PTR _i$232097[ebp]
  03a57	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  03a5d	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03a60	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03a66	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  03a6b	3b 45 14	 cmp	 eax, DWORD PTR _Level$[ebp]
  03a6e	0f 8c 06 01 00
	00		 jl	 $LN9@SearchItem
  03a74	6a 00		 push	 0
  03a76	0f b6 45 18	 movzx	 eax, BYTE PTR _Skill$[ebp]
  03a7a	50		 push	 eax
  03a7b	8b 4d ec	 mov	 ecx, DWORD PTR _i$232097[ebp]
  03a7e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03a84	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03a87	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03a8d	0f b6 8c 08 94
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+148]
  03a95	51		 push	 ecx
  03a96	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03a9b	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a9e	0f b6 d0	 movzx	 edx, al
  03aa1	85 d2		 test	 edx, edx
  03aa3	0f 84 d1 00 00
	00		 je	 $LN9@SearchItem
  03aa9	6a 00		 push	 0
  03aab	0f b6 45 1c	 movzx	 eax, BYTE PTR _Luck$[ebp]
  03aaf	50		 push	 eax
  03ab0	8b 4d ec	 mov	 ecx, DWORD PTR _i$232097[ebp]
  03ab3	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03ab9	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03abc	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03ac2	0f b6 8c 08 95
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+149]
  03aca	51		 push	 ecx
  03acb	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03ad0	83 c4 0c	 add	 esp, 12			; 0000000cH
  03ad3	0f b6 d0	 movzx	 edx, al
  03ad6	85 d2		 test	 edx, edx
  03ad8	0f 84 9c 00 00
	00		 je	 $LN9@SearchItem
  03ade	6a 00		 push	 0
  03ae0	0f b6 45 20	 movzx	 eax, BYTE PTR _Opt$[ebp]
  03ae4	50		 push	 eax
  03ae5	8b 4d ec	 mov	 ecx, DWORD PTR _i$232097[ebp]
  03ae8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03aee	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03af1	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03af7	0f b6 8c 08 96
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+150]
  03aff	51		 push	 ecx
  03b00	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03b05	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b08	0f b6 d0	 movzx	 edx, al
  03b0b	85 d2		 test	 edx, edx
  03b0d	74 6b		 je	 SHORT $LN9@SearchItem
  03b0f	6a 00		 push	 0
  03b11	0f b6 45 24	 movzx	 eax, BYTE PTR _Exl$[ebp]
  03b15	50		 push	 eax
  03b16	8b 4d ec	 mov	 ecx, DWORD PTR _i$232097[ebp]
  03b19	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03b1f	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03b22	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03b28	0f b6 8c 08 97
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+151]
  03b30	51		 push	 ecx
  03b31	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03b36	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b39	0f b6 d0	 movzx	 edx, al
  03b3c	85 d2		 test	 edx, edx
  03b3e	74 3a		 je	 SHORT $LN9@SearchItem
  03b40	6a 00		 push	 0
  03b42	0f b6 45 28	 movzx	 eax, BYTE PTR _Anc$[ebp]
  03b46	50		 push	 eax
  03b47	8b 4d ec	 mov	 ecx, DWORD PTR _i$232097[ebp]
  03b4a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03b50	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03b53	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03b59	0f b6 8c 08 ae
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+174]
  03b61	51		 push	 ecx
  03b62	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03b67	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b6a	0f b6 d0	 movzx	 edx, al
  03b6d	85 d2		 test	 edx, edx
  03b6f	74 09		 je	 SHORT $LN9@SearchItem

; 1139 : 		{
; 1140 : 			iCount++;

  03b71	8b 45 f4	 mov	 eax, DWORD PTR _iCount$[ebp]
  03b74	83 c0 01	 add	 eax, 1
  03b77	89 45 f4	 mov	 DWORD PTR _iCount$[ebp], eax
$LN9@SearchItem:

; 1141 : 		}
; 1142 : 	}

  03b7a	e9 9c fe ff ff	 jmp	 $LN11@SearchItem
$LN10@SearchItem:

; 1143 : 
; 1144 : 	if(iCount >= count)

  03b7f	8b 45 f4	 mov	 eax, DWORD PTR _iCount$[ebp]
  03b82	3b 45 2c	 cmp	 eax, DWORD PTR _count$[ebp]
  03b85	0f 8c b9 01 00
	00		 jl	 $LN8@SearchItem

; 1145 : 	{
; 1146 : 		if(del)

  03b8b	0f b6 45 30	 movzx	 eax, BYTE PTR _del$[ebp]
  03b8f	85 c0		 test	 eax, eax
  03b91	0f 84 a7 01 00
	00		 je	 $LN7@SearchItem

; 1147 : 		{
; 1148 : 			int iDelCount = 0;

  03b97	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iDelCount$232104[ebp], 0

; 1149 : 			for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  03b9e	c7 45 e4 0c 00
	00 00		 mov	 DWORD PTR _i$232105[ebp], 12 ; 0000000cH
  03ba5	eb 09		 jmp	 SHORT $LN6@SearchItem
$LN5@SearchItem:
  03ba7	8b 45 e4	 mov	 eax, DWORD PTR _i$232105[ebp]
  03baa	83 c0 01	 add	 eax, 1
  03bad	89 45 e4	 mov	 DWORD PTR _i$232105[ebp], eax
$LN6@SearchItem:
  03bb0	81 7d e4 ec 00
	00 00		 cmp	 DWORD PTR _i$232105[ebp], 236 ; 000000ecH
  03bb7	0f 8d 81 01 00
	00		 jge	 $LN7@SearchItem

; 1150 : 			{
; 1151 : 				if( lpUser->pInventory[i].m_Type == iType && 
; 1152 : 					lpUser->pInventory[i].m_Level >= Level &&
; 1153 : 					CheckOptionItem(lpUser->pInventory[i].m_Option1, Skill, FALSE) &&
; 1154 : 					CheckOptionItem(lpUser->pInventory[i].m_Option2, Luck, FALSE) &&
; 1155 : 					CheckOptionItem(lpUser->pInventory[i].m_Option3, Opt, FALSE) &&
; 1156 : 					CheckOptionItem(lpUser->pInventory[i].m_NewOption, Exl, FALSE) &&
; 1157 : 					CheckOptionItem(lpUser->pInventory[i].m_SetOption, Anc, FALSE) )

  03bbd	8b 45 e4	 mov	 eax, DWORD PTR _i$232105[ebp]
  03bc0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  03bc6	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03bc9	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03bcf	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  03bd4	0f bf 4d f0	 movsx	 ecx, WORD PTR _iType$[ebp]
  03bd8	3b c1		 cmp	 eax, ecx
  03bda	0f 85 59 01 00
	00		 jne	 $LN3@SearchItem
  03be0	8b 45 e4	 mov	 eax, DWORD PTR _i$232105[ebp]
  03be3	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  03be9	8b 4d f8	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  03bec	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  03bf2	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  03bf7	3b 45 14	 cmp	 eax, DWORD PTR _Level$[ebp]
  03bfa	0f 8c 39 01 00
	00		 jl	 $LN3@SearchItem
  03c00	6a 00		 push	 0
  03c02	0f b6 45 18	 movzx	 eax, BYTE PTR _Skill$[ebp]
  03c06	50		 push	 eax
  03c07	8b 4d e4	 mov	 ecx, DWORD PTR _i$232105[ebp]
  03c0a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03c10	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03c13	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03c19	0f b6 8c 08 94
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+148]
  03c21	51		 push	 ecx
  03c22	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03c27	83 c4 0c	 add	 esp, 12			; 0000000cH
  03c2a	0f b6 d0	 movzx	 edx, al
  03c2d	85 d2		 test	 edx, edx
  03c2f	0f 84 04 01 00
	00		 je	 $LN3@SearchItem
  03c35	6a 00		 push	 0
  03c37	0f b6 45 1c	 movzx	 eax, BYTE PTR _Luck$[ebp]
  03c3b	50		 push	 eax
  03c3c	8b 4d e4	 mov	 ecx, DWORD PTR _i$232105[ebp]
  03c3f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03c45	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03c48	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03c4e	0f b6 8c 08 95
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+149]
  03c56	51		 push	 ecx
  03c57	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03c5c	83 c4 0c	 add	 esp, 12			; 0000000cH
  03c5f	0f b6 d0	 movzx	 edx, al
  03c62	85 d2		 test	 edx, edx
  03c64	0f 84 cf 00 00
	00		 je	 $LN3@SearchItem
  03c6a	6a 00		 push	 0
  03c6c	0f b6 45 20	 movzx	 eax, BYTE PTR _Opt$[ebp]
  03c70	50		 push	 eax
  03c71	8b 4d e4	 mov	 ecx, DWORD PTR _i$232105[ebp]
  03c74	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03c7a	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03c7d	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03c83	0f b6 8c 08 96
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+150]
  03c8b	51		 push	 ecx
  03c8c	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03c91	83 c4 0c	 add	 esp, 12			; 0000000cH
  03c94	0f b6 d0	 movzx	 edx, al
  03c97	85 d2		 test	 edx, edx
  03c99	0f 84 9a 00 00
	00		 je	 $LN3@SearchItem
  03c9f	6a 00		 push	 0
  03ca1	0f b6 45 24	 movzx	 eax, BYTE PTR _Exl$[ebp]
  03ca5	50		 push	 eax
  03ca6	8b 4d e4	 mov	 ecx, DWORD PTR _i$232105[ebp]
  03ca9	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03caf	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03cb2	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03cb8	0f b6 8c 08 97
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+151]
  03cc0	51		 push	 ecx
  03cc1	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03cc6	83 c4 0c	 add	 esp, 12			; 0000000cH
  03cc9	0f b6 d0	 movzx	 edx, al
  03ccc	85 d2		 test	 edx, edx
  03cce	74 69		 je	 SHORT $LN3@SearchItem
  03cd0	6a 00		 push	 0
  03cd2	0f b6 45 28	 movzx	 eax, BYTE PTR _Anc$[ebp]
  03cd6	50		 push	 eax
  03cd7	8b 4d e4	 mov	 ecx, DWORD PTR _i$232105[ebp]
  03cda	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03ce0	8b 55 f8	 mov	 edx, DWORD PTR _lpUser$[ebp]
  03ce3	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  03ce9	0f b6 8c 08 ae
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+174]
  03cf1	51		 push	 ecx
  03cf2	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  03cf7	83 c4 0c	 add	 esp, 12			; 0000000cH
  03cfa	0f b6 d0	 movzx	 edx, al
  03cfd	85 d2		 test	 edx, edx
  03cff	74 38		 je	 SHORT $LN3@SearchItem

; 1158 : 				{
; 1159 : 					gObjInventoryDeleteItem(aIndex, i);

  03d01	8b 45 e4	 mov	 eax, DWORD PTR _i$232105[ebp]
  03d04	50		 push	 eax
  03d05	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  03d08	51		 push	 ecx
  03d09	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  03d0e	83 c4 08	 add	 esp, 8

; 1160 : 					GCInventoryItemDeleteSend(aIndex, i, 1);

  03d11	6a 01		 push	 1
  03d13	0f b6 45 e4	 movzx	 eax, BYTE PTR _i$232105[ebp]
  03d17	50		 push	 eax
  03d18	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  03d1b	51		 push	 ecx
  03d1c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  03d21	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1161 : 					iDelCount++;

  03d24	8b 45 e8	 mov	 eax, DWORD PTR _iDelCount$232104[ebp]
  03d27	83 c0 01	 add	 eax, 1
  03d2a	89 45 e8	 mov	 DWORD PTR _iDelCount$232104[ebp], eax

; 1162 : 					if(iDelCount == count)

  03d2d	8b 45 e8	 mov	 eax, DWORD PTR _iDelCount$232104[ebp]
  03d30	3b 45 2c	 cmp	 eax, DWORD PTR _count$[ebp]
  03d33	75 04		 jne	 SHORT $LN3@SearchItem

; 1163 : 					{
; 1164 : 						return true;

  03d35	b0 01		 mov	 al, 1
  03d37	eb 0d		 jmp	 SHORT $LN13@SearchItem
$LN3@SearchItem:

; 1165 : 					}
; 1166 : 				}
; 1167 : 			}

  03d39	e9 69 fe ff ff	 jmp	 $LN5@SearchItem
$LN7@SearchItem:

; 1168 : 		}
; 1169 : 		return true;

  03d3e	b0 01		 mov	 al, 1
  03d40	eb 04		 jmp	 SHORT $LN13@SearchItem

; 1170 : 	}
; 1171 : 	else

  03d42	eb 02		 jmp	 SHORT $LN13@SearchItem
$LN8@SearchItem:

; 1172 : 	{
; 1173 : 		return false;

  03d44	32 c0		 xor	 al, al
$LN13@SearchItem:

; 1174 : 	}
; 1175 : }

  03d46	5f		 pop	 edi
  03d47	5e		 pop	 esi
  03d48	5b		 pop	 ebx
  03d49	8b e5		 mov	 esp, ebp
  03d4b	5d		 pop	 ebp
  03d4c	c2 2c 00	 ret	 44			; 0000002cH
?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z ENDP	; cResetSystem::SearchItem
_TEXT	ENDS
PUBLIC	?CGResetMenu@cResetSystem@@QAEXH@Z		; cResetSystem::CGResetMenu
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CGResetMenu@cResetSystem@@QAEXH@Z PROC			; cResetSystem::CGResetMenu
; _this$ = ecx

; 1178 : {

  03d50	55		 push	 ebp
  03d51	8b ec		 mov	 ebp, esp
  03d53	83 ec 44	 sub	 esp, 68			; 00000044H
  03d56	53		 push	 ebx
  03d57	56		 push	 esi
  03d58	57		 push	 edi
  03d59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 : 	if( !g_ExLicense.CheckUser(eExUB::Local) && 
; 1180 : 		!g_ExLicense.CheckUser(eExUB::Gredy) &&
; 1181 : 		!g_ExLicense.CheckUser(eExUB::Gredy2) && 
; 1182 : 		!g_ExLicense.CheckUser(eExUB::GredyLocal) &&
; 1183 : 		!g_ExLicense.CheckUser(eExUB::MedoniAndrei))

  03d5c	6a 00		 push	 0
  03d5e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  03d63	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  03d68	0f b6 c0	 movzx	 eax, al
  03d6b	85 c0		 test	 eax, eax
  03d6d	75 4e		 jne	 SHORT $LN1@CGResetMen
  03d6f	6a 20		 push	 32			; 00000020H
  03d71	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  03d76	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  03d7b	0f b6 c0	 movzx	 eax, al
  03d7e	85 c0		 test	 eax, eax
  03d80	75 3b		 jne	 SHORT $LN1@CGResetMen
  03d82	6a 22		 push	 34			; 00000022H
  03d84	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  03d89	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  03d8e	0f b6 c0	 movzx	 eax, al
  03d91	85 c0		 test	 eax, eax
  03d93	75 28		 jne	 SHORT $LN1@CGResetMen
  03d95	6a 21		 push	 33			; 00000021H
  03d97	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  03d9c	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  03da1	0f b6 c0	 movzx	 eax, al
  03da4	85 c0		 test	 eax, eax
  03da6	75 15		 jne	 SHORT $LN1@CGResetMen
  03da8	6a 32		 push	 50			; 00000032H
  03daa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  03daf	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  03db4	0f b6 c0	 movzx	 eax, al
  03db7	85 c0		 test	 eax, eax
  03db9	75 02		 jne	 SHORT $LN1@CGResetMen

; 1184 : 	{
; 1185 : 		return;

  03dbb	eb 0c		 jmp	 SHORT $LN2@CGResetMen
$LN1@CGResetMen:

; 1186 : 	}
; 1187 : 
; 1188 : 	this->GCDialogInfo(aIndex);

  03dbd	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  03dc0	50		 push	 eax
  03dc1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03dc4	e8 00 00 00 00	 call	 ?GCDialogInfo@cResetSystem@@QAEXH@Z ; cResetSystem::GCDialogInfo
$LN2@CGResetMen:

; 1189 : }

  03dc9	5f		 pop	 edi
  03dca	5e		 pop	 esi
  03dcb	5b		 pop	 ebx
  03dcc	8b e5		 mov	 esp, ebp
  03dce	5d		 pop	 ebp
  03dcf	c2 04 00	 ret	 4
?CGResetMenu@cResetSystem@@QAEXH@Z ENDP			; cResetSystem::CGResetMenu
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
PUBLIC	?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
PUBLIC	??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ; std::addressof<RESET_NEEDITEM_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Idx$232140 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ; std::addressof<RESET_NEEDITEM_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ; std::addressof<RESET_NEEDITEM_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$232140[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$232140[ebp]
  00075	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase
PUBLIC	?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin
PUBLIC	?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T234034 = -88						; size = 4
$T234035 = -84						; size = 4
$T234036 = -80						; size = 4
$T234037 = -76						; size = 4
$T234038 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T234035[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T234034[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T234037[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T234036[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T234034[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T234036[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T234038[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 24	 imul	 eax, 36			; 00000024H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>
PUBLIC	?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside
PUBLIC	??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z ; std::addressof<RESET_REWARD_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Idx$232316 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z ; std::addressof<RESET_REWARD_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z ; std::addressof<RESET_REWARD_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$232316[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$232316[ebp]
  00075	6b c0 24	 imul	 eax, 36			; 00000024H
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 24	 add	 ecx, 36			; 00000024H
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 24	 add	 ecx, 36			; 00000024H
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase
PUBLIC	?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin
PUBLIC	?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T234047 = -88						; size = 4
$T234048 = -84						; size = 4
$T234049 = -80						; size = 4
$T234050 = -76						; size = 4
$T234051 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T234048[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T234047[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T234050[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T234049[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T234047[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T234049[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T234051[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy
PUBLIC	??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T234058 = -84						; size = 4
__Ptr$232507 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$232507[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$232507[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$232507[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T234058[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T234058[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy
PUBLIC	??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T234073 = -84						; size = 4
__Ptr$232569 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$232569[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$232569[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$232569[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T234073[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T234073[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
PUBLIC	??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
PUBLIC	?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocate
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232611 = -28					; size = 4
__Ptr$232604 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232604[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232604[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232604[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232611[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$232604[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$232611[ebp]
  00125	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$232604[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232604[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ; std::allocator<RESET_NEEDITEM_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ; std::allocator<RESET_NEEDITEM_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::deallocate
PUBLIC	??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>
PUBLIC	?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232652 = -28					; size = 4
__Ptr$232645 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232645[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232645[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232645[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232652[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 24	 imul	 eax, 36			; 00000024H
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$232645[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$232652[ebp]
  00125	6b c0 24	 imul	 eax, 36			; 00000024H
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$232645[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232645[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ ; std::allocator<RESET_REWARD_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ ; std::allocator<RESET_REWARD_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z PROC ; std::allocator<RESET_REWARD_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ENDP ; std::allocator<RESET_REWARD_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ; std::_Allocate<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ; std::_Allocate<RESET_NEEDITEM_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ PROC ; std::allocator<RESET_NEEDITEM_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ENDP ; std::allocator<RESET_NEEDITEM_DATA>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z ; std::_Allocate<RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z PROC ; std::allocator<RESET_REWARD_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z ; std::_Allocate<RESET_REWARD_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z ENDP ; std::allocator<RESET_REWARD_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ PROC ; std::allocator<RESET_REWARD_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 c7 71
	1c 07		 mov	 DWORD PTR __Count$[ebp], 119304647 ; 071c71c7H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ ENDP ; std::allocator<RESET_REWARD_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::addressof<RESET_NEEDITEM_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::addressof<RESET_NEEDITEM_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>
PUBLIC	??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct
PUBLIC	??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ; std::forward<RESET_NEEDITEM_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ; std::forward<RESET_NEEDITEM_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z PROC ; std::addressof<RESET_REWARD_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z ENDP ; std::addressof<RESET_REWARD_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>
PUBLIC	??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z ; std::allocator<RESET_REWARD_DATA>::construct
PUBLIC	??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z ; std::forward<RESET_REWARD_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z ; std::forward<RESET_REWARD_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z ; std::allocator<RESET_REWARD_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
PUBLIC	??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T234194 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z PROC ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T234194[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T234194[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z ENDP ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
PUBLIC	??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T234197 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z PROC ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T234197[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T234197[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z ENDP ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z
_TEXT	SEGMENT
$T234202 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T234202[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T234202[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z
_TEXT	SEGMENT
$T234207 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T234207[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T234207[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T234210 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z PROC ; std::_Allocate<RESET_NEEDITEM_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 49 92
	24 09		 cmp	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T234210[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T234210[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ENDP ; std::_Allocate<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T234213 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z PROC ; std::_Allocate<RESET_REWARD_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 c7 71
	1c 07		 cmp	 DWORD PTR __Count$[ebp], 119304647 ; 071c71c7H
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 24	 imul	 eax, 36			; 00000024H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T234213[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T234213[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z ENDP ; std::_Allocate<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z PROC ; std::allocator<RESET_REWARD_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T234222 = -88						; size = 4
$T234223 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T234223[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T234223[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 07 00 00 00	 mov	 ecx, 7
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T234223[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T234223[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T234222[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T234223[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z PROC ; std::forward<RESET_REWARD_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z ENDP ; std::forward<RESET_REWARD_DATA &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T234243 = -88						; size = 4
$T234244 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z PROC ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 24		 push	 36			; 00000024H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T234244[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T234244[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 09 00 00 00	 mov	 ecx, 9
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T234244[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T234244[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T234243[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T234244[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z PROC ; std::forward<RESET_REWARD_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z ENDP ; std::forward<RESET_REWARD_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z PROC ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::move<RESET_NEEDITEM_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1a		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::move<RESET_NEEDITEM_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 07 00 00 00	 mov	 ecx, 7
  00036	8b f0		 mov	 esi, eax
  00038	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0003b	f3 a5		 rep movsd
  0003d	eb cc		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z PROC ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ENDP ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::move<RESET_REWARD_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@2
$LN2@Move@2:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 24	 add	 eax, 36			; 00000024H
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 24	 add	 ecx, 36			; 00000024H
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@2:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1a		 je	 SHORT $LN1@Move@2

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::move<RESET_REWARD_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 09 00 00 00	 mov	 ecx, 9
  00036	8b f0		 mov	 esi, eax
  00038	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0003b	f3 a5		 rep movsd
  0003d	eb cc		 jmp	 SHORT $LN2@Move@2
$LN1@Move@2:

; 2515 : 	return (_Dest);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
PUBLIC	??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ; std::_Val_type<RESET_NEEDITEM_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z
_TEXT	SEGMENT
$T234266 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T234266[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T234266[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ; std::_Val_type<RESET_NEEDITEM_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
PUBLIC	??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z ; std::_Val_type<RESET_REWARD_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z
_TEXT	SEGMENT
$T234271 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T234271[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T234271[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z ; std::_Val_type<RESET_REWARD_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 24	 add	 eax, 36			; 00000024H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T234276 = -88						; size = 4
$T234277 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 1c		 push	 28			; 0000001cH
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T234277[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T234277[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ; std::forward<RESET_NEEDITEM_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 07 00 00 00	 mov	 ecx, 7
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T234277[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T234277[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T234276[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T234277[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T234289 = -88						; size = 4
$T234290 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z PROC ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 24		 push	 36			; 00000024H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T234290[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T234290[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z ; std::forward<RESET_REWARD_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 09 00 00 00	 mov	 ecx, 9
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T234290[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T234290[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T234289[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T234290[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z ENDP ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::move<RESET_NEEDITEM_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::move<RESET_NEEDITEM_DATA &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z PROC ; std::move<RESET_REWARD_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ENDP ; std::move<RESET_REWARD_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z PROC ; std::_Val_type<RESET_NEEDITEM_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ENDP ; std::_Val_type<RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 1c	 add	 eax, 28			; 0000001cH
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
PUBLIC	?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ; std::allocator<RESET_NEEDITEM_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z PROC ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ; std::allocator<RESET_NEEDITEM_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z PROC ; std::_Val_type<RESET_REWARD_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z ENDP ; std::_Val_type<RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 24	 add	 eax, 36			; 00000024H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 24	 add	 ecx, 36			; 00000024H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 24	 add	 eax, 36			; 00000024H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
PUBLIC	?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z ; std::allocator<RESET_REWARD_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z PROC ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z ; std::allocator<RESET_REWARD_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ; std::_Destroy<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ; std::_Destroy<RESET_NEEDITEM_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z ; std::_Destroy<RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z PROC ; std::allocator<RESET_REWARD_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z ; std::_Destroy<RESET_REWARD_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct
PUBLIC	??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z ; std::allocator<RESET_REWARD_DATA>::construct
PUBLIC	??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z ; std::allocator<RESET_REWARD_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z PROC ; std::_Destroy<RESET_NEEDITEM_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ENDP ; std::_Destroy<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z PROC ; std::_Destroy<RESET_REWARD_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z ENDP ; std::_Destroy<RESET_REWARD_DATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T234356 = -88						; size = 4
$T234357 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T234357[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T234357[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 07 00 00 00	 mov	 ecx, 7
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T234357[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T234357[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@3:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T234356[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T234357[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T234369 = -88						; size = 4
$T234370 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z PROC ; std::allocator<RESET_REWARD_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 24		 push	 36			; 00000024H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T234370[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T234370[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 09 00 00 00	 mov	 ecx, 9
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T234370[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T234370[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@4:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T234369[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T234370[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z PROC ; std::forward<RESET_REWARD_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ENDP ; std::forward<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0cResetSystem@@QAE@XZ				; cResetSystem::cResetSystem
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\reset.cpp
;	COMDAT ??__EgResetSystem@@YAXXZ
text$yc	SEGMENT
??__EgResetSystem@@YAXXZ PROC				; `dynamic initializer for 'gResetSystem'', COMDAT

; 23   : cResetSystem gResetSystem;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gResetSystem@@3VcResetSystem@@A ; gResetSystem
  0000e	e8 00 00 00 00	 call	 ??0cResetSystem@@QAE@XZ
  00013	68 00 00 00 00	 push	 OFFSET ??__FgResetSystem@@YAXXZ ; `dynamic atexit destructor for 'gResetSystem''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EgResetSystem@@YAXXZ ENDP				; `dynamic initializer for 'gResetSystem''
text$yc	ENDS
PUBLIC	??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
PUBLIC	??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
PUBLIC	??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0cResetSystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0cResetSystem@@QAE@XZ$0
__ehfuncinfo$??0cResetSystem@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0cResetSystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0cResetSystem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0cResetSystem@@QAE@XZ PROC				; cResetSystem::cResetSystem, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0cResetSystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  00034	e8 00 00 00 00	 call	 ??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  00049	e8 00 00 00 00	 call	 ??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0cResetSystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
__ehhandler$??0cResetSystem@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0cResetSystem@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0cResetSystem@@QAE@XZ ENDP				; cResetSystem::cResetSystem
PUBLIC	??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
PUBLIC	??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T234412 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T234412[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
PUBLIC	?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
__ehhandler$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
PUBLIC	??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
PUBLIC	??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ	; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T234425 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T234425[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z PROC ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ENDP ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ PROC	; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z PROC ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z ENDP ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ PROC	; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??1cResetSystem@@QAE@XZ				; cResetSystem::~cResetSystem
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgResetSystem@@YAXXZ
text$yd	SEGMENT
??__FgResetSystem@@YAXXZ PROC				; `dynamic atexit destructor for 'gResetSystem'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gResetSystem@@3VcResetSystem@@A ; gResetSystem
  0000e	e8 00 00 00 00	 call	 ??1cResetSystem@@QAE@XZ
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FgResetSystem@@YAXXZ ENDP				; `dynamic atexit destructor for 'gResetSystem''
text$yd	ENDS
PUBLIC	??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1cResetSystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1cResetSystem@@QAE@XZ$0
__ehfuncinfo$??1cResetSystem@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1cResetSystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1cResetSystem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1cResetSystem@@QAE@XZ PROC				; cResetSystem::~cResetSystem, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1cResetSystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 e8 7d 00
	00		 add	 ecx, 32232		; 00007de8H
  0003b	e8 00 00 00 00	 call	 ??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
  00040	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  00050	e8 00 00 00 00	 call	 ??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1cResetSystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 d8 7d 00
	00		 add	 ecx, 32216		; 00007dd8H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
__ehhandler$??1cResetSystem@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1cResetSystem@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1cResetSystem@@QAE@XZ ENDP				; cResetSystem::~cResetSystem
PUBLIC	??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
PUBLIC	?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
__ehhandler$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?gResetSystem@@3VcResetSystem@@A		; gResetSystem
_BSS	SEGMENT
?gResetSystem@@3VcResetSystem@@A DB 07df8H DUP (?)	; gResetSystem
_BSS	ENDS
CRT$XCU	SEGMENT
_gResetSystem$initializer$ DD FLAT:??__EgResetSystem@@YAXXZ
CRT$XCU	ENDS
END
