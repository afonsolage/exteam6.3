; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MonsterMsg.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
PUBLIC	?Init@CMonsterMsg@@QAEXXZ			; CMonsterMsg::Init
PUBLIC	??0?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
PUBLIC	??0CMonsterMsg@@QAE@XZ				; CMonsterMsg::CMonsterMsg
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0CMonsterMsg@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CMonsterMsg@@QAE@XZ$0
__ehfuncinfo$??0CMonsterMsg@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CMonsterMsg@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstermsg.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMonsterMsg@@QAE@XZ PROC				; CMonsterMsg::CMonsterMsg
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMonsterMsg@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 14   : 	this->Init();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?Init@CMonsterMsg@@QAEXXZ ; CMonsterMsg::Init

; 15   : }

  00042	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CMonsterMsg@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
__ehhandler$??0CMonsterMsg@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CMonsterMsg@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CMonsterMsg@@QAE@XZ ENDP				; CMonsterMsg::CMonsterMsg
PUBLIC	??1CMonsterMsg@@QAE@XZ				; CMonsterMsg::~CMonsterMsg
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMonsterMsg@@QAE@XZ PROC				; CMonsterMsg::~CMonsterMsg
; _this$ = ecx

; 18   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	83 ec 44	 sub	 esp, 68			; 00000044H
  00066	53		 push	 ebx
  00067	56		 push	 esi
  00068	57		 push	 edi
  00069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??1CMonsterMsg@@QAE@XZ ENDP				; CMonsterMsg::~CMonsterMsg
_TEXT	ENDS
PUBLIC	?clear@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CMonsterMsg@@QAEXXZ PROC				; CMonsterMsg::Init
; _this$ = ecx

; 22   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 44	 sub	 esp, 68			; 00000044H
  00086	53		 push	 ebx
  00087	56		 push	 esi
  00088	57		 push	 edi
  00089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 	this->m_Data.clear();

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?clear@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::clear

; 24   : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?Init@CMonsterMsg@@QAEXXZ ENDP				; CMonsterMsg::Init
_TEXT	ENDS
PUBLIC	?Read@CMonsterMsg@@QAEXPAD@Z			; CMonsterMsg::Read
PUBLIC	??_C@_0BG@BLKKAAMB@ExData?2MonsterMsg?4dat?$AA@	; `string'
PUBLIC	?Load@CMonsterMsg@@QAEXXZ			; CMonsterMsg::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0BG@BLKKAAMB@ExData?2MonsterMsg?4dat?$AA@
CONST	SEGMENT
??_C@_0BG@BLKKAAMB@ExData?2MonsterMsg?4dat?$AA@ DB 'ExData\MonsterMsg.dat'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CMonsterMsg@@QAEXXZ PROC				; CMonsterMsg::Load
; _this$ = ecx

; 27   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	83 ec 44	 sub	 esp, 68			; 00000044H
  000a6	53		 push	 ebx
  000a7	56		 push	 esi
  000a8	57		 push	 edi
  000a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 	if(!g_ExLicense.CheckUser(eExUB::Local)			&&
; 29   : 	   !g_ExLicense.CheckUser(eExUB::Gredy)			&& 
; 30   : 	   !g_ExLicense.CheckUser(eExUB::Gredy2)		&&
; 31   : 	   !g_ExLicense.CheckUser(eExUB::GredyLocal)	&&
; 32   : 	   !g_ExLicense.CheckUser(eExUB::SILVER1)		&&
; 33   : 	   !g_ExLicense.CheckUser(eExUB::SILVER2)		&&
; 34   : 	   !g_ExLicense.CheckUser(eExUB::MU2Play)		&&
; 35   : 	   !g_ExLicense.CheckUser(eExUB::SILVER_Local)  &&
; 36   : 	   !g_ExLicense.CheckUser(eExUB::Artem)			&&
; 37   : 	   !g_ExLicense.CheckUser(eExUB::Artem2)		&&
; 38   : 	   !g_ExLicense.CheckUser(eExUB::Escalate)		&&
; 39   : 	   !g_ExLicense.CheckUser(eExUB::ArcMu)			&&
; 40   : 	   !g_ExLicense.CheckUser(eExUB::MedoniAndrei)  &&
; 41   : 	   !g_ExLicense.CheckUser(eExUB::mu4you)		&&
; 42   : 	   !g_ExLicense.CheckUser(eExUB::eternalmu)		&&
; 43   : 	   !g_ExLicense.CheckUser(eExUB::NSGames))

  000ac	6a 00		 push	 0
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  000b3	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  000b8	0f b6 c0	 movzx	 eax, al
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 3f 01 00
	00		 jne	 $LN1@Load
  000c3	6a 20		 push	 32			; 00000020H
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  000ca	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  000cf	0f b6 c0	 movzx	 eax, al
  000d2	85 c0		 test	 eax, eax
  000d4	0f 85 28 01 00
	00		 jne	 $LN1@Load
  000da	6a 22		 push	 34			; 00000022H
  000dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  000e1	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  000e6	0f b6 c0	 movzx	 eax, al
  000e9	85 c0		 test	 eax, eax
  000eb	0f 85 11 01 00
	00		 jne	 $LN1@Load
  000f1	6a 21		 push	 33			; 00000021H
  000f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  000f8	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	0f 85 fa 00 00
	00		 jne	 $LN1@Load
  00108	6a 07		 push	 7
  0010a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0010f	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00114	0f b6 c0	 movzx	 eax, al
  00117	85 c0		 test	 eax, eax
  00119	0f 85 e3 00 00
	00		 jne	 $LN1@Load
  0011f	6a 08		 push	 8
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00126	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0012b	0f b6 c0	 movzx	 eax, al
  0012e	85 c0		 test	 eax, eax
  00130	0f 85 cc 00 00
	00		 jne	 $LN1@Load
  00136	6a 36		 push	 54			; 00000036H
  00138	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0013d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00142	0f b6 c0	 movzx	 eax, al
  00145	85 c0		 test	 eax, eax
  00147	0f 85 b5 00 00
	00		 jne	 $LN1@Load
  0014d	6a 2b		 push	 43			; 0000002bH
  0014f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00154	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00159	0f b6 c0	 movzx	 eax, al
  0015c	85 c0		 test	 eax, eax
  0015e	0f 85 9e 00 00
	00		 jne	 $LN1@Load
  00164	6a 30		 push	 48			; 00000030H
  00166	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0016b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00170	0f b6 c0	 movzx	 eax, al
  00173	85 c0		 test	 eax, eax
  00175	0f 85 87 00 00
	00		 jne	 $LN1@Load
  0017b	6a 31		 push	 49			; 00000031H
  0017d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00182	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00187	0f b6 c0	 movzx	 eax, al
  0018a	85 c0		 test	 eax, eax
  0018c	75 74		 jne	 SHORT $LN1@Load
  0018e	6a 40		 push	 64			; 00000040H
  00190	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00195	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0019a	0f b6 c0	 movzx	 eax, al
  0019d	85 c0		 test	 eax, eax
  0019f	75 61		 jne	 SHORT $LN1@Load
  001a1	6a 48		 push	 72			; 00000048H
  001a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001a8	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001ad	0f b6 c0	 movzx	 eax, al
  001b0	85 c0		 test	 eax, eax
  001b2	75 4e		 jne	 SHORT $LN1@Load
  001b4	6a 32		 push	 50			; 00000032H
  001b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001bb	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001c0	0f b6 c0	 movzx	 eax, al
  001c3	85 c0		 test	 eax, eax
  001c5	75 3b		 jne	 SHORT $LN1@Load
  001c7	6a 4e		 push	 78			; 0000004eH
  001c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001ce	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001d3	0f b6 c0	 movzx	 eax, al
  001d6	85 c0		 test	 eax, eax
  001d8	75 28		 jne	 SHORT $LN1@Load
  001da	6a 4f		 push	 79			; 0000004fH
  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001e1	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001e6	0f b6 c0	 movzx	 eax, al
  001e9	85 c0		 test	 eax, eax
  001eb	75 15		 jne	 SHORT $LN1@Load
  001ed	6a 51		 push	 81			; 00000051H
  001ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001f4	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001f9	0f b6 c0	 movzx	 eax, al
  001fc	85 c0		 test	 eax, eax
  001fe	75 02		 jne	 SHORT $LN1@Load

; 44   : 	{
; 45   : 		return;

  00200	eb 20		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 46   : 	}
; 47   : 
; 48   : 	this->Init();

  00202	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	e8 00 00 00 00	 call	 ?Init@CMonsterMsg@@QAEXXZ ; CMonsterMsg::Init

; 49   : 	this->Read(gDirPath.GetNewPath("ExData\\MonsterMsg.dat"));

  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BLKKAAMB@ExData?2MonsterMsg?4dat?$AA@
  0020f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00214	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00219	50		 push	 eax
  0021a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021d	e8 00 00 00 00	 call	 ?Read@CMonsterMsg@@QAEXPAD@Z ; CMonsterMsg::Read
$LN2@Load:

; 50   : }

  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c3		 ret	 0
?Load@CMonsterMsg@@QAEXXZ ENDP				; CMonsterMsg::Load
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXABUMOB_MSG_DATA@@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::push_back
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	_fclose:PROC
EXTRN	_strncpy:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_List$227754 = -116					; size = 104
_Token$227736 = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?Read@CMonsterMsg@@QAEXPAD@Z PROC			; CMonsterMsg::Read
; _this$ = ecx

; 53   : {

  00230	55		 push	 ebp
  00231	8b ec		 mov	 ebp, esp
  00233	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00239	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0023e	33 c5		 xor	 eax, ebp
  00240	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00243	53		 push	 ebx
  00244	56		 push	 esi
  00245	57		 push	 edi
  00246	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 54   : 	SMDFile = fopen(filename, "r");

  00249	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0024e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _fopen
  00257	83 c4 08	 add	 esp, 8
  0025a	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 55   : 
; 56   : 	if( SMDFile == NULL )

  0025f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00266	75 1f		 jne	 SHORT $LN4@Read

; 57   : 	{
; 58   : 		LogAdd(lMsg.Get(MSGGET(1, 198)), filename);

  00268	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0026b	50		 push	 eax
  0026c	68 c6 01 00 00	 push	 454			; 000001c6H
  00271	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00276	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0027b	50		 push	 eax
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00282	83 c4 08	 add	 esp, 8

; 59   : 		return;

  00285	eb 5b		 jmp	 SHORT $LN5@Read
$LN4@Read:

; 60   : 	}
; 61   : 
; 62   : 	while(true)

  00287	b8 01 00 00 00	 mov	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 44		 je	 SHORT $LN2@Read

; 63   : 	{
; 64   : 		SMDToken Token = GetToken();

  00290	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00295	89 45 f4	 mov	 DWORD PTR _Token$227736[ebp], eax

; 65   : 
; 66   : 		if( Token == END )

  00298	83 7d f4 02	 cmp	 DWORD PTR _Token$227736[ebp], 2
  0029c	75 02		 jne	 SHORT $LN1@Read

; 67   : 		{
; 68   : 			break;

  0029e	eb 34		 jmp	 SHORT $LN2@Read
$LN1@Read:

; 69   : 		}
; 70   : 
; 71   : 		MOB_MSG_DATA List;
; 72   : 
; 73   : 		List.iClass			= TokenNumber;

  002a0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002a6	e8 00 00 00 00	 call	 __ftol2_sse
  002ab	89 45 8c	 mov	 DWORD PTR _List$227754[ebp], eax

; 74   : 
; 75   : 		GetToken();

  002ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 76   : 		strncpy(List.szMsg, TokenString, 100);

  002b3	6a 64		 push	 100			; 00000064H
  002b5	68 00 00 00 00	 push	 OFFSET _TokenString
  002ba	8d 45 90	 lea	 eax, DWORD PTR _List$227754[ebp+4]
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 _strncpy
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 77   : 
; 78   : 		this->m_Data.push_back(List);

  002c6	8d 45 8c	 lea	 eax, DWORD PTR _List$227754[ebp]
  002c9	50		 push	 eax
  002ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	e8 00 00 00 00	 call	 ?push_back@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXABUMOB_MSG_DATA@@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::push_back

; 79   : 	}

  002d2	eb b3		 jmp	 SHORT $LN4@Read
$LN2@Read:

; 80   : 
; 81   : 	fclose(SMDFile);

  002d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002d9	50		 push	 eax
  002da	e8 00 00 00 00	 call	 _fclose
  002df	83 c4 04	 add	 esp, 4
$LN5@Read:

; 82   : }

  002e2	5f		 pop	 edi
  002e3	5e		 pop	 esi
  002e4	5b		 pop	 ebx
  002e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e8	33 cd		 xor	 ecx, ebp
  002ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	c2 04 00	 ret	 4
?Read@CMonsterMsg@@QAEXPAD@Z ENDP			; CMonsterMsg::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00300	55		 push	 ebp
  00301	8b ec		 mov	 ebp, esp
  00303	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00309	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0030e	33 c5		 xor	 eax, ebp
  00310	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00313	53		 push	 ebx
  00314	56		 push	 esi
  00315	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00316	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0031d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00322	50		 push	 eax
  00323	e8 00 00 00 00	 call	 _fgetc
  00328	83 c4 04	 add	 esp, 4
  0032b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0032e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00332	83 f9 ff	 cmp	 ecx, -1
  00335	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00337	b8 02 00 00 00	 mov	 eax, 2
  0033c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00341	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00343	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00347	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0034a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0034c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 _fgetc
  00357	83 c4 04	 add	 esp, 4
  0035a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0035d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00361	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00364	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00366	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0036a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0036d	74 1c		 je	 SHORT $LN23@GetToken
  0036f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00373	83 f8 ff	 cmp	 eax, -1
  00376	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00378	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 _fgetc
  00383	83 c4 04	 add	 esp, 4
  00386	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00389	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0038b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0038f	83 f8 ff	 cmp	 eax, -1
  00392	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00394	b8 02 00 00 00	 mov	 eax, 2
  00399	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0039e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 _isspace
  003a8	83 c4 04	 add	 esp, 4
  003ab	85 c0		 test	 eax, eax
  003ad	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  003b3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003b7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  003bd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  003c3	83 e9 22	 sub	 ecx, 34			; 00000022H
  003c6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  003cc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  003d3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  003d9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  003df	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  003e6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  003ed	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  003f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  003fc	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00401	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00406	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00410	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00415	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0041a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0041f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00429	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0042e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00433	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00438	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00442	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00447	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0044c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00451	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0045b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00460	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00465	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0046a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0046f	50		 push	 eax
  00470	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00474	51		 push	 ecx
  00475	e8 00 00 00 00	 call	 _ungetc
  0047a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0047d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00480	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00483	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00488	50		 push	 eax
  00489	e8 00 00 00 00	 call	 _getc
  0048e	83 c4 04	 add	 esp, 4
  00491	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00494	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00498	83 f9 ff	 cmp	 ecx, -1
  0049b	74 36		 je	 SHORT $LN12@GetToken
  0049d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004a1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  004a4	74 1a		 je	 SHORT $LN11@GetToken
  004a6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004aa	50		 push	 eax
  004ab	e8 00 00 00 00	 call	 _isdigit
  004b0	83 c4 04	 add	 esp, 4
  004b3	85 c0		 test	 eax, eax
  004b5	75 09		 jne	 SHORT $LN11@GetToken
  004b7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004bb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  004be	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  004c0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004c3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  004c6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  004c8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004cb	83 c0 01	 add	 eax, 1
  004ce	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  004d1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  004d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004d6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  004d9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 _atof
  004e2	83 c4 04	 add	 esp, 4
  004e5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  004eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  004f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004fa	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  004ff	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00504	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0050b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00510	50		 push	 eax
  00511	e8 00 00 00 00	 call	 _getc
  00516	83 c4 04	 add	 esp, 4
  00519	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0051c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00520	83 f9 ff	 cmp	 ecx, -1
  00523	74 1c		 je	 SHORT $LN8@GetToken
  00525	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00529	83 f8 22	 cmp	 eax, 34			; 00000022H
  0052c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0052e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00531	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00534	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00536	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00539	83 c0 01	 add	 eax, 1
  0053c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0053f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00541	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00545	83 f8 22	 cmp	 eax, 34			; 00000022H
  00548	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0054a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0054f	50		 push	 eax
  00550	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00554	51		 push	 ecx
  00555	e8 00 00 00 00	 call	 _ungetc
  0055a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0055d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00560	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00563	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0056d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00572	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00577	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0057c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 _isalpha
  00586	83 c4 04	 add	 esp, 4
  00589	85 c0		 test	 eax, eax
  0058b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00591	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00598	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0059b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0059e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  005a0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005a3	83 c0 01	 add	 eax, 1
  005a6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  005a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005ae	50		 push	 eax
  005af	e8 00 00 00 00	 call	 _getc
  005b4	83 c4 04	 add	 esp, 4
  005b7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005ba	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005be	83 f9 ff	 cmp	 ecx, -1
  005c1	74 36		 je	 SHORT $LN3@GetToken
  005c3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005c7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  005ca	74 1a		 je	 SHORT $LN2@GetToken
  005cc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005d0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  005d3	74 11		 je	 SHORT $LN2@GetToken
  005d5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005d9	50		 push	 eax
  005da	e8 00 00 00 00	 call	 _isalnum
  005df	83 c4 04	 add	 esp, 4
  005e2	85 c0		 test	 eax, eax
  005e4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  005e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005e9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005ec	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  005ee	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005f1	83 c0 01	 add	 eax, 1
  005f4	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  005f7	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  005f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005fe	50		 push	 eax
  005ff	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00603	51		 push	 ecx
  00604	e8 00 00 00 00	 call	 _ungetc
  00609	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0060c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0060f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00612	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0061c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00621	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00623	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00625	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0062f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00634	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00636	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00638	5f		 pop	 edi
  00639	5e		 pop	 esi
  0063a	5b		 pop	 ebx
  0063b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0063e	33 cd		 xor	 ecx, ebp
  00640	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00645	8b e5		 mov	 esp, ebp
  00647	5d		 pop	 ebp
  00648	c3		 ret	 0
  00649	8d 49 00	 npad	 3
$LN35@GetToken:
  0064c	00 00 00 00	 DD	 $LN10@GetToken
  00650	00 00 00 00	 DD	 $LN19@GetToken
  00654	00 00 00 00	 DD	 $LN17@GetToken
  00658	00 00 00 00	 DD	 $LN14@GetToken
  0065c	00 00 00 00	 DD	 $LN18@GetToken
  00660	00 00 00 00	 DD	 $LN16@GetToken
  00664	00 00 00 00	 DD	 $LN15@GetToken
  00668	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0066c	00		 DB	 0
  0066d	01		 DB	 1
  0066e	07		 DB	 7
  0066f	07		 DB	 7
  00670	07		 DB	 7
  00671	07		 DB	 7
  00672	07		 DB	 7
  00673	07		 DB	 7
  00674	07		 DB	 7
  00675	07		 DB	 7
  00676	02		 DB	 2
  00677	03		 DB	 3
  00678	03		 DB	 3
  00679	07		 DB	 7
  0067a	03		 DB	 3
  0067b	03		 DB	 3
  0067c	03		 DB	 3
  0067d	03		 DB	 3
  0067e	03		 DB	 3
  0067f	03		 DB	 3
  00680	03		 DB	 3
  00681	03		 DB	 3
  00682	03		 DB	 3
  00683	03		 DB	 3
  00684	07		 DB	 7
  00685	04		 DB	 4
  00686	07		 DB	 7
  00687	07		 DB	 7
  00688	07		 DB	 7
  00689	07		 DB	 7
  0068a	07		 DB	 7
  0068b	07		 DB	 7
  0068c	07		 DB	 7
  0068d	07		 DB	 7
  0068e	07		 DB	 7
  0068f	07		 DB	 7
  00690	07		 DB	 7
  00691	07		 DB	 7
  00692	07		 DB	 7
  00693	07		 DB	 7
  00694	07		 DB	 7
  00695	07		 DB	 7
  00696	07		 DB	 7
  00697	07		 DB	 7
  00698	07		 DB	 7
  00699	07		 DB	 7
  0069a	07		 DB	 7
  0069b	07		 DB	 7
  0069c	07		 DB	 7
  0069d	07		 DB	 7
  0069e	07		 DB	 7
  0069f	07		 DB	 7
  006a0	07		 DB	 7
  006a1	07		 DB	 7
  006a2	07		 DB	 7
  006a3	07		 DB	 7
  006a4	07		 DB	 7
  006a5	07		 DB	 7
  006a6	07		 DB	 7
  006a7	07		 DB	 7
  006a8	07		 DB	 7
  006a9	07		 DB	 7
  006aa	07		 DB	 7
  006ab	07		 DB	 7
  006ac	07		 DB	 7
  006ad	07		 DB	 7
  006ae	07		 DB	 7
  006af	07		 DB	 7
  006b0	07		 DB	 7
  006b1	07		 DB	 7
  006b2	07		 DB	 7
  006b3	07		 DB	 7
  006b4	07		 DB	 7
  006b5	07		 DB	 7
  006b6	07		 DB	 7
  006b7	07		 DB	 7
  006b8	07		 DB	 7
  006b9	07		 DB	 7
  006ba	07		 DB	 7
  006bb	07		 DB	 7
  006bc	07		 DB	 7
  006bd	07		 DB	 7
  006be	07		 DB	 7
  006bf	07		 DB	 7
  006c0	07		 DB	 7
  006c1	07		 DB	 7
  006c2	07		 DB	 7
  006c3	07		 DB	 7
  006c4	07		 DB	 7
  006c5	05		 DB	 5
  006c6	07		 DB	 7
  006c7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??A?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEAAUMOB_MSG_DATA@@I@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::operator[]
PUBLIC	?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size
PUBLIC	?RegenMessage@CMonsterMsg@@QAEXH@Z		; CMonsterMsg::RegenMessage
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstermsg.cpp
_TEXT	SEGMENT
tv179 = -84						; size = 4
_Mob$227766 = -16					; size = 4
_i$227762 = -12						; size = 4
_lpMonster$ = -8					; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?RegenMessage@CMonsterMsg@@QAEXH@Z PROC			; CMonsterMsg::RegenMessage
; _this$ = ecx

; 85   : {

  006d0	55		 push	 ebp
  006d1	8b ec		 mov	 ebp, esp
  006d3	83 ec 54	 sub	 esp, 84			; 00000054H
  006d6	53		 push	 ebx
  006d7	56		 push	 esi
  006d8	57		 push	 edi
  006d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 86   : 	if(!g_ExLicense.CheckUser(eExUB::Local)			&&
; 87   : 	   !g_ExLicense.CheckUser(eExUB::Gredy)			&& 
; 88   : 	   !g_ExLicense.CheckUser(eExUB::Gredy2)		&&
; 89   : 	   !g_ExLicense.CheckUser(eExUB::GredyLocal)	&&
; 90   : 	   !g_ExLicense.CheckUser(eExUB::SILVER1)		&&
; 91   : 	   !g_ExLicense.CheckUser(eExUB::SILVER2)		&&
; 92   : 	   !g_ExLicense.CheckUser(eExUB::MU2Play)		&&
; 93   : 	   !g_ExLicense.CheckUser(eExUB::SILVER_Local)  &&
; 94   : 	   !g_ExLicense.CheckUser(eExUB::Artem)			&& 
; 95   : 	   !g_ExLicense.CheckUser(eExUB::Artem2)		&&
; 96   : 	   !g_ExLicense.CheckUser(eExUB::Escalate)		&&
; 97   : 	   !g_ExLicense.CheckUser(eExUB::ArcMu)			&&
; 98   : 	   !g_ExLicense.CheckUser(eExUB::MedoniAndrei)	&&
; 99   : 	   !g_ExLicense.CheckUser(eExUB::mu4you)		&&
; 100  : 	   !g_ExLicense.CheckUser(eExUB::eternalmu)		&&
; 101  : 	   !g_ExLicense.CheckUser(eExUB::NSGames))

  006dc	6a 00		 push	 0
  006de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  006e3	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  006e8	0f b6 c0	 movzx	 eax, al
  006eb	85 c0		 test	 eax, eax
  006ed	0f 85 42 01 00
	00		 jne	 $LN6@RegenMessa
  006f3	6a 20		 push	 32			; 00000020H
  006f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  006fa	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  006ff	0f b6 c0	 movzx	 eax, al
  00702	85 c0		 test	 eax, eax
  00704	0f 85 2b 01 00
	00		 jne	 $LN6@RegenMessa
  0070a	6a 22		 push	 34			; 00000022H
  0070c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00711	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00716	0f b6 c0	 movzx	 eax, al
  00719	85 c0		 test	 eax, eax
  0071b	0f 85 14 01 00
	00		 jne	 $LN6@RegenMessa
  00721	6a 21		 push	 33			; 00000021H
  00723	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00728	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0072d	0f b6 c0	 movzx	 eax, al
  00730	85 c0		 test	 eax, eax
  00732	0f 85 fd 00 00
	00		 jne	 $LN6@RegenMessa
  00738	6a 07		 push	 7
  0073a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0073f	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00744	0f b6 c0	 movzx	 eax, al
  00747	85 c0		 test	 eax, eax
  00749	0f 85 e6 00 00
	00		 jne	 $LN6@RegenMessa
  0074f	6a 08		 push	 8
  00751	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00756	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0075b	0f b6 c0	 movzx	 eax, al
  0075e	85 c0		 test	 eax, eax
  00760	0f 85 cf 00 00
	00		 jne	 $LN6@RegenMessa
  00766	6a 36		 push	 54			; 00000036H
  00768	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0076d	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00772	0f b6 c0	 movzx	 eax, al
  00775	85 c0		 test	 eax, eax
  00777	0f 85 b8 00 00
	00		 jne	 $LN6@RegenMessa
  0077d	6a 2b		 push	 43			; 0000002bH
  0077f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00784	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00789	0f b6 c0	 movzx	 eax, al
  0078c	85 c0		 test	 eax, eax
  0078e	0f 85 a1 00 00
	00		 jne	 $LN6@RegenMessa
  00794	6a 30		 push	 48			; 00000030H
  00796	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0079b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007a0	0f b6 c0	 movzx	 eax, al
  007a3	85 c0		 test	 eax, eax
  007a5	0f 85 8a 00 00
	00		 jne	 $LN6@RegenMessa
  007ab	6a 31		 push	 49			; 00000031H
  007ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007b2	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007b7	0f b6 c0	 movzx	 eax, al
  007ba	85 c0		 test	 eax, eax
  007bc	75 77		 jne	 SHORT $LN6@RegenMessa
  007be	6a 40		 push	 64			; 00000040H
  007c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007c5	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007ca	0f b6 c0	 movzx	 eax, al
  007cd	85 c0		 test	 eax, eax
  007cf	75 64		 jne	 SHORT $LN6@RegenMessa
  007d1	6a 48		 push	 72			; 00000048H
  007d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007d8	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007dd	0f b6 c0	 movzx	 eax, al
  007e0	85 c0		 test	 eax, eax
  007e2	75 51		 jne	 SHORT $LN6@RegenMessa
  007e4	6a 32		 push	 50			; 00000032H
  007e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007eb	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  007f0	0f b6 c0	 movzx	 eax, al
  007f3	85 c0		 test	 eax, eax
  007f5	75 3e		 jne	 SHORT $LN6@RegenMessa
  007f7	6a 4e		 push	 78			; 0000004eH
  007f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  007fe	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00803	0f b6 c0	 movzx	 eax, al
  00806	85 c0		 test	 eax, eax
  00808	75 2b		 jne	 SHORT $LN6@RegenMessa
  0080a	6a 4f		 push	 79			; 0000004fH
  0080c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00811	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00816	0f b6 c0	 movzx	 eax, al
  00819	85 c0		 test	 eax, eax
  0081b	75 18		 jne	 SHORT $LN6@RegenMessa
  0081d	6a 51		 push	 81			; 00000051H
  0081f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00824	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00829	0f b6 c0	 movzx	 eax, al
  0082c	85 c0		 test	 eax, eax
  0082e	75 05		 jne	 SHORT $LN6@RegenMessa

; 102  : 	{
; 103  : 		return;

  00830	e9 8a 00 00 00	 jmp	 $LN7@RegenMessa
$LN6@RegenMessa:

; 104  : 	}
; 105  : 
; 106  : 	if(!OBJMON_RANGE(aIndex))

  00835	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00839	7d 09		 jge	 SHORT $LN9@RegenMessa
  0083b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  00842	eb 0f		 jmp	 SHORT $LN10@RegenMessa
$LN9@RegenMessa:
  00844	33 c0		 xor	 eax, eax
  00846	81 7d 08 c7 32
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 12999 ; 000032c7H
  0084d	0f 9e c0	 setle	 al
  00850	89 45 ac	 mov	 DWORD PTR tv179[ebp], eax
$LN10@RegenMessa:
  00853	83 7d ac 00	 cmp	 DWORD PTR tv179[ebp], 0
  00857	75 02		 jne	 SHORT $LN5@RegenMessa

; 107  : 	{
; 108  : 		return;

  00859	eb 64		 jmp	 SHORT $LN7@RegenMessa
$LN5@RegenMessa:

; 109  : 	}
; 110  : 
; 111  : 	LPOBJ lpMonster = &gObj[aIndex];

  0085b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0085e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00864	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0086a	89 45 f8	 mov	 DWORD PTR _lpMonster$[ebp], eax

; 112  : 
; 113  : 	for(int i = 0; i < this->m_Data.size(); i++)

  0086d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$227762[ebp], 0
  00874	eb 09		 jmp	 SHORT $LN4@RegenMessa
$LN3@RegenMessa:
  00876	8b 45 f4	 mov	 eax, DWORD PTR _i$227762[ebp]
  00879	83 c0 01	 add	 eax, 1
  0087c	89 45 f4	 mov	 DWORD PTR _i$227762[ebp], eax
$LN4@RegenMessa:
  0087f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00882	e8 00 00 00 00	 call	 ?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size
  00887	39 45 f4	 cmp	 DWORD PTR _i$227762[ebp], eax
  0088a	73 33		 jae	 SHORT $LN7@RegenMessa

; 114  : 	{
; 115  : 		MOB_MSG_DATA & Mob = this->m_Data[i];

  0088c	8b 45 f4	 mov	 eax, DWORD PTR _i$227762[ebp]
  0088f	50		 push	 eax
  00890	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00893	e8 00 00 00 00	 call	 ??A?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEAAUMOB_MSG_DATA@@I@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::operator[]
  00898	89 45 f0	 mov	 DWORD PTR _Mob$227766[ebp], eax

; 116  : 		if(Mob.iClass == lpMonster->Class)

  0089b	8b 45 f8	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  0089e	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  008a5	8b 55 f0	 mov	 edx, DWORD PTR _Mob$227766[ebp]
  008a8	39 0a		 cmp	 DWORD PTR [edx], ecx
  008aa	75 11		 jne	 SHORT $LN1@RegenMessa

; 117  : 		{
; 118  : 			AllSendServerMsg(Mob.szMsg);

  008ac	8b 45 f0	 mov	 eax, DWORD PTR _Mob$227766[ebp]
  008af	83 c0 04	 add	 eax, 4
  008b2	50		 push	 eax
  008b3	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  008b8	83 c4 04	 add	 esp, 4

; 119  : 			return;

  008bb	eb 02		 jmp	 SHORT $LN7@RegenMessa
$LN1@RegenMessa:

; 120  : 		}
; 121  : 	}

  008bd	eb b7		 jmp	 SHORT $LN3@RegenMessa
$LN7@RegenMessa:

; 122  : }

  008bf	5f		 pop	 edi
  008c0	5e		 pop	 esi
  008c1	5b		 pop	 ebx
  008c2	8b e5		 mov	 esp, ebp
  008c4	5d		 pop	 ebp
  008c5	c2 04 00	 ret	 4
?RegenMessage@CMonsterMsg@@QAEXH@Z ENDP			; CMonsterMsg::RegenMessage
_TEXT	ENDS
PUBLIC	??_C@_0BI@CCHBMMDP@?$CFs?5defeated?5by?5?$CFs?5in?5?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DieMessage@CMonsterMsg@@QAEXHH@Z		; CMonsterMsg::DieMessage
EXTRN	_sprintf:PROC
EXTRN	?exMapName@@YAPADH@Z:PROC			; exMapName
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
;	COMDAT ??_C@_0BI@CCHBMMDP@?$CFs?5defeated?5by?5?$CFs?5in?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BI@CCHBMMDP@?$CFs?5defeated?5by?5?$CFs?5in?5?$CFs?$AA@ DB '%s defe'
	DB	'ated by %s in %s', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv197 = -228						; size = 4
tv184 = -228						; size = 4
tv179 = -228						; size = 4
_szMsg$227788 = -160					; size = 128
_lpMonsterAttr$227787 = -32				; size = 4
_Mob$227785 = -28					; size = 4
_i$227781 = -24						; size = 4
_iMapNumber$ = -20					; size = 4
_lpMonster$ = -16					; size = 4
_lpUser$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?DieMessage@CMonsterMsg@@QAEXHH@Z PROC			; CMonsterMsg::DieMessage
; _this$ = ecx

; 125  : {

  008d0	55		 push	 ebp
  008d1	8b ec		 mov	 ebp, esp
  008d3	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  008d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  008de	33 c5		 xor	 eax, ebp
  008e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  008e3	53		 push	 ebx
  008e4	56		 push	 esi
  008e5	57		 push	 edi
  008e6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 126  : 	if(!g_ExLicense.CheckUser(eExUB::Local)			&&
; 127  : 	   !g_ExLicense.CheckUser(eExUB::Gredy)			&& 
; 128  : 	   !g_ExLicense.CheckUser(eExUB::Gredy2)		&&
; 129  : 	   !g_ExLicense.CheckUser(eExUB::GredyLocal)	&&
; 130  : 	   !g_ExLicense.CheckUser(eExUB::SILVER1)		&&
; 131  : 	   !g_ExLicense.CheckUser(eExUB::SILVER2)		&&
; 132  : 	   !g_ExLicense.CheckUser(eExUB::MU2Play)		&&
; 133  : 	   !g_ExLicense.CheckUser(eExUB::SILVER_Local)  &&
; 134  : 	   !g_ExLicense.CheckUser(eExUB::Artem)			&&
; 135  : 	   !g_ExLicense.CheckUser(eExUB::Artem2)		&&
; 136  : 	   !g_ExLicense.CheckUser(eExUB::Escalate)		&&
; 137  : 	   !g_ExLicense.CheckUser(eExUB::ArcMu)			&&
; 138  : 	   !g_ExLicense.CheckUser(eExUB::MedoniAndrei)	&&
; 139  : 	   !g_ExLicense.CheckUser(eExUB::mu4you)		&&
; 140  : 	   !g_ExLicense.CheckUser(eExUB::eternalmu)		&&
; 141  : 	   !g_ExLicense.CheckUser(eExUB::NSGames))

  008e9	6a 00		 push	 0
  008eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  008f0	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  008f5	0f b6 c0	 movzx	 eax, al
  008f8	85 c0		 test	 eax, eax
  008fa	0f 85 42 01 00
	00		 jne	 $LN9@DieMessage
  00900	6a 20		 push	 32			; 00000020H
  00902	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00907	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0090c	0f b6 c0	 movzx	 eax, al
  0090f	85 c0		 test	 eax, eax
  00911	0f 85 2b 01 00
	00		 jne	 $LN9@DieMessage
  00917	6a 22		 push	 34			; 00000022H
  00919	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0091e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00923	0f b6 c0	 movzx	 eax, al
  00926	85 c0		 test	 eax, eax
  00928	0f 85 14 01 00
	00		 jne	 $LN9@DieMessage
  0092e	6a 21		 push	 33			; 00000021H
  00930	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00935	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0093a	0f b6 c0	 movzx	 eax, al
  0093d	85 c0		 test	 eax, eax
  0093f	0f 85 fd 00 00
	00		 jne	 $LN9@DieMessage
  00945	6a 07		 push	 7
  00947	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0094c	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00951	0f b6 c0	 movzx	 eax, al
  00954	85 c0		 test	 eax, eax
  00956	0f 85 e6 00 00
	00		 jne	 $LN9@DieMessage
  0095c	6a 08		 push	 8
  0095e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00963	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00968	0f b6 c0	 movzx	 eax, al
  0096b	85 c0		 test	 eax, eax
  0096d	0f 85 cf 00 00
	00		 jne	 $LN9@DieMessage
  00973	6a 36		 push	 54			; 00000036H
  00975	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0097a	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0097f	0f b6 c0	 movzx	 eax, al
  00982	85 c0		 test	 eax, eax
  00984	0f 85 b8 00 00
	00		 jne	 $LN9@DieMessage
  0098a	6a 2b		 push	 43			; 0000002bH
  0098c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00991	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00996	0f b6 c0	 movzx	 eax, al
  00999	85 c0		 test	 eax, eax
  0099b	0f 85 a1 00 00
	00		 jne	 $LN9@DieMessage
  009a1	6a 30		 push	 48			; 00000030H
  009a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009a8	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009ad	0f b6 c0	 movzx	 eax, al
  009b0	85 c0		 test	 eax, eax
  009b2	0f 85 8a 00 00
	00		 jne	 $LN9@DieMessage
  009b8	6a 31		 push	 49			; 00000031H
  009ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009bf	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009c4	0f b6 c0	 movzx	 eax, al
  009c7	85 c0		 test	 eax, eax
  009c9	75 77		 jne	 SHORT $LN9@DieMessage
  009cb	6a 40		 push	 64			; 00000040H
  009cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009d2	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009d7	0f b6 c0	 movzx	 eax, al
  009da	85 c0		 test	 eax, eax
  009dc	75 64		 jne	 SHORT $LN9@DieMessage
  009de	6a 48		 push	 72			; 00000048H
  009e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009e5	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009ea	0f b6 c0	 movzx	 eax, al
  009ed	85 c0		 test	 eax, eax
  009ef	75 51		 jne	 SHORT $LN9@DieMessage
  009f1	6a 32		 push	 50			; 00000032H
  009f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  009f8	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  009fd	0f b6 c0	 movzx	 eax, al
  00a00	85 c0		 test	 eax, eax
  00a02	75 3e		 jne	 SHORT $LN9@DieMessage
  00a04	6a 4e		 push	 78			; 0000004eH
  00a06	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a0b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a10	0f b6 c0	 movzx	 eax, al
  00a13	85 c0		 test	 eax, eax
  00a15	75 2b		 jne	 SHORT $LN9@DieMessage
  00a17	6a 4f		 push	 79			; 0000004fH
  00a19	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a1e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a23	0f b6 c0	 movzx	 eax, al
  00a26	85 c0		 test	 eax, eax
  00a28	75 18		 jne	 SHORT $LN9@DieMessage
  00a2a	6a 51		 push	 81			; 00000051H
  00a2c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00a31	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00a36	0f b6 c0	 movzx	 eax, al
  00a39	85 c0		 test	 eax, eax
  00a3b	75 05		 jne	 SHORT $LN9@DieMessage

; 142  : 	{
; 143  : 		return;

  00a3d	e9 69 01 00 00	 jmp	 $LN10@DieMessage
$LN9@DieMessage:

; 144  : 	}
; 145  : 
; 146  : 	if(!OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(aTargetIndex))

  00a42	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00a46	7d 0c		 jge	 SHORT $LN12@DieMessage
  00a48	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv179[ebp], 0
  00a52	eb 12		 jmp	 SHORT $LN13@DieMessage
$LN12@DieMessage:
  00a54	33 c0		 xor	 eax, eax
  00a56	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00a5d	0f 9e c0	 setle	 al
  00a60	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
$LN13@DieMessage:
  00a66	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR tv179[ebp], 0
  00a6d	74 2d		 je	 SHORT $LN7@DieMessage
  00a6f	83 7d 0c 00	 cmp	 DWORD PTR _aTargetIndex$[ebp], 0
  00a73	7d 0c		 jge	 SHORT $LN14@DieMessage
  00a75	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv184[ebp], 0
  00a7f	eb 12		 jmp	 SHORT $LN15@DieMessage
$LN14@DieMessage:
  00a81	33 c0		 xor	 eax, eax
  00a83	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aTargetIndex$[ebp], 14999 ; 00003a97H
  00a8a	0f 9e c0	 setle	 al
  00a8d	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv184[ebp], eax
$LN15@DieMessage:
  00a93	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR tv184[ebp], 0
  00a9a	75 05		 jne	 SHORT $LN8@DieMessage
$LN7@DieMessage:

; 147  : 	{
; 148  : 		return;

  00a9c	e9 0a 01 00 00	 jmp	 $LN10@DieMessage
$LN8@DieMessage:

; 149  : 	}
; 150  : 
; 151  : 	LPOBJ lpUser = &gObj[aIndex];

  00aa1	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aa4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00aaa	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab0	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax

; 152  : 	LPOBJ lpMonster = &gObj[aTargetIndex];

  00ab3	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00ab6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00abc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ac2	89 45 f0	 mov	 DWORD PTR _lpMonster$[ebp], eax

; 153  : 
; 154  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00ac5	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00ac8	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00acc	7d 05		 jge	 SHORT $LN6@DieMessage

; 155  : 	{
; 156  : 		return;

  00ace	e9 d8 00 00 00	 jmp	 $LN10@DieMessage
$LN6@DieMessage:

; 157  : 	}
; 158  : 
; 159  : 	int iMapNumber = lpMonster->MapNumber;

  00ad3	8b 45 f0	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00ad6	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00add	89 4d ec	 mov	 DWORD PTR _iMapNumber$[ebp], ecx

; 160  : 
; 161  : 	if(!MAX_MAP_RANGE(iMapNumber)) 

  00ae0	83 7d ec 00	 cmp	 DWORD PTR _iMapNumber$[ebp], 0
  00ae4	7d 0c		 jge	 SHORT $LN16@DieMessage
  00ae6	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv197[ebp], 0
  00af0	eb 0f		 jmp	 SHORT $LN17@DieMessage
$LN16@DieMessage:
  00af2	33 c0		 xor	 eax, eax
  00af4	83 7d ec 59	 cmp	 DWORD PTR _iMapNumber$[ebp], 89 ; 00000059H
  00af8	0f 9e c0	 setle	 al
  00afb	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
$LN17@DieMessage:
  00b01	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR tv197[ebp], 0
  00b08	75 05		 jne	 SHORT $LN5@DieMessage

; 162  : 	{
; 163  : 		return;

  00b0a	e9 9c 00 00 00	 jmp	 $LN10@DieMessage
$LN5@DieMessage:

; 164  : 	}
; 165  : 
; 166  : 	for(int i = 0; i < this->m_Data.size(); i++)

  00b0f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$227781[ebp], 0
  00b16	eb 09		 jmp	 SHORT $LN4@DieMessage
$LN3@DieMessage:
  00b18	8b 45 e8	 mov	 eax, DWORD PTR _i$227781[ebp]
  00b1b	83 c0 01	 add	 eax, 1
  00b1e	89 45 e8	 mov	 DWORD PTR _i$227781[ebp], eax
$LN4@DieMessage:
  00b21	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b24	e8 00 00 00 00	 call	 ?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size
  00b29	39 45 e8	 cmp	 DWORD PTR _i$227781[ebp], eax
  00b2c	73 7d		 jae	 SHORT $LN10@DieMessage

; 167  : 	{
; 168  : 		MOB_MSG_DATA & Mob = this->m_Data[i];

  00b2e	8b 45 e8	 mov	 eax, DWORD PTR _i$227781[ebp]
  00b31	50		 push	 eax
  00b32	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b35	e8 00 00 00 00	 call	 ??A?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEAAUMOB_MSG_DATA@@I@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::operator[]
  00b3a	89 45 e4	 mov	 DWORD PTR _Mob$227785[ebp], eax

; 169  : 		if(Mob.iClass == lpMonster->Class)

  00b3d	8b 45 f0	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00b40	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00b47	8b 55 e4	 mov	 edx, DWORD PTR _Mob$227785[ebp]
  00b4a	39 0a		 cmp	 DWORD PTR [edx], ecx
  00b4c	75 58		 jne	 SHORT $LN1@DieMessage

; 170  : 		{
; 171  : 			LPMONSTER_ATTRIBUTE lpMonsterAttr = gMAttr.GetAttr(lpMonster->Class);

  00b4e	8b 45 f0	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00b51	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00b58	51		 push	 ecx
  00b59	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00b5e	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00b63	89 45 e0	 mov	 DWORD PTR _lpMonsterAttr$227787[ebp], eax

; 172  : 			char szMsg[128];
; 173  : 			sprintf(szMsg,"%s defeated by %s in %s", lpMonsterAttr->m_Name, lpUser->Name, exMapName(iMapNumber));

  00b66	8b 45 ec	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  00b69	50		 push	 eax
  00b6a	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  00b6f	83 c4 04	 add	 esp, 4
  00b72	50		 push	 eax
  00b73	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00b76	83 c1 77	 add	 ecx, 119		; 00000077H
  00b79	51		 push	 ecx
  00b7a	8b 55 e0	 mov	 edx, DWORD PTR _lpMonsterAttr$227787[ebp]
  00b7d	83 c2 08	 add	 edx, 8
  00b80	52		 push	 edx
  00b81	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CCHBMMDP@?$CFs?5defeated?5by?5?$CFs?5in?5?$CFs?$AA@
  00b86	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$227788[ebp]
  00b8c	50		 push	 eax
  00b8d	e8 00 00 00 00	 call	 _sprintf
  00b92	83 c4 14	 add	 esp, 20			; 00000014H

; 174  : 			AllSendServerMsg(szMsg);

  00b95	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$227788[ebp]
  00b9b	50		 push	 eax
  00b9c	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00ba1	83 c4 04	 add	 esp, 4

; 175  : 			return;

  00ba4	eb 05		 jmp	 SHORT $LN10@DieMessage
$LN1@DieMessage:

; 176  : 		}
; 177  : 	}

  00ba6	e9 6d ff ff ff	 jmp	 $LN3@DieMessage
$LN10@DieMessage:

; 178  : }

  00bab	5f		 pop	 edi
  00bac	5e		 pop	 esi
  00bad	5b		 pop	 ebx
  00bae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bb1	33 cd		 xor	 ecx, ebp
  00bb3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bb8	8b e5		 mov	 esp, ebp
  00bba	5d		 pop	 ebp
  00bbb	c2 08 00	 ret	 8
?DieMessage@CMonsterMsg@@QAEXHH@Z ENDP			; CMonsterMsg::DieMessage
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@V?$allocator@UMOB_MSG_DATA@@@1@@Z ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
PUBLIC	??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@XZ	; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T228805 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T228805[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@XZ ; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@V?$allocator@UMOB_MSG_DATA@@@1@@Z ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
PUBLIC	?_Tidy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
__ehhandler$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEAAUMOB_MSG_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEAAUMOB_MSG_DATA@@I@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 68	 imul	 eax, 104		; 00000068H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEAAUMOB_MSG_DATA@@I@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@ABU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@AAU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA &>
PUBLIC	?_Orphan_range@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXI@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBE_NPBUMOB_MSG_DATA@@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUMOB_MSG_DATA@@@std@@YAPBUMOB_MSG_DATA@@ABU1@@Z ; std::addressof<MOB_MSG_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXABUMOB_MSG_DATA@@@Z
_TEXT	SEGMENT
__Idx$227813 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXABUMOB_MSG_DATA@@@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUMOB_MSG_DATA@@@std@@YAPBUMOB_MSG_DATA@@ABU1@@Z ; std::addressof<MOB_MSG_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBE_NPBUMOB_MSG_DATA@@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUMOB_MSG_DATA@@@std@@YAPBUMOB_MSG_DATA@@ABU1@@Z ; std::addressof<MOB_MSG_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$227813[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXI@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$227813[ebp]
  00075	6b c0 68	 imul	 eax, 104		; 00000068H
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@AAU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 68	 add	 ecx, 104		; 00000068H
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXI@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@ABU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 68	 add	 ecx, 104		; 00000068H
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXABUMOB_MSG_DATA@@@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::erase
PUBLIC	?begin@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::begin
PUBLIC	?end@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T228824 = -88						; size = 4
$T228825 = -84						; size = 4
$T228826 = -80						; size = 4
$T228827 = -76						; size = 4
$T228828 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T228825[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T228824[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T228827[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T228826[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T228824[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T228826[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T228828[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Destroy
PUBLIC	??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00@Z ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T228835 = -84						; size = 4
__Ptr$228004 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00@Z ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$228004[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$228004[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$228004[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T228835[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T228835[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBE_NPBUMOB_MSG_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBE_NPBUMOB_MSG_DATA@@@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBE_NPBUMOB_MSG_DATA@@@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEII@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEII@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z ; std::allocator<MOB_MSG_DATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z ; std::allocator<MOB_MSG_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXPAUMOB_MSG_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXPAUMOB_MSG_DATA@@0@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXPAUMOB_MSG_DATA@@0@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@V?$allocator@UMOB_MSG_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@V?$allocator@UMOB_MSG_DATA@@@1@@Z PROC ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@V?$allocator@UMOB_MSG_DATA@@@1@@Z ENDP ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::~_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@XZ PROC		; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@XZ ENDP		; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUMOB_MSG_DATA@@@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEPAUMOB_MSG_DATA@@PAU2@00@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Umove<MOB_MSG_DATA *>
PUBLIC	?allocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEPAUMOB_MSG_DATA@@I@Z ; std::allocator<MOB_MSG_DATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$228046 = -28					; size = 4
__Ptr$228039 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEPAUMOB_MSG_DATA@@I@Z ; std::allocator<MOB_MSG_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$228039[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$228039[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUMOB_MSG_DATA@@@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEPAUMOB_MSG_DATA@@PAU2@00@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Umove<MOB_MSG_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228039[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z ; std::allocator<MOB_MSG_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$228046[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z ; std::allocator<MOB_MSG_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 68	 imul	 eax, 104		; 00000068H
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$228039[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$228046[ebp]
  00125	6b c0 68	 imul	 eax, 104		; 00000068H
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$228039[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228039[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UMOB_MSG_DATA@@@std@@QBEIXZ ; std::allocator<MOB_MSG_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UMOB_MSG_DATA@@@std@@QBEIXZ ; std::allocator<MOB_MSG_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEXPAUMOB_MSG_DATA@@0@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@QBEIXZ ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UMOB_MSG_DATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<MOB_MSG_DATA>::allocator<MOB_MSG_DATA>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z PROC ; std::allocator<MOB_MSG_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@I@Z ENDP ; std::allocator<MOB_MSG_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@IPAU1@@Z ; std::_Allocate<MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEPAUMOB_MSG_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEPAUMOB_MSG_DATA@@I@Z PROC ; std::allocator<MOB_MSG_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@IPAU1@@Z ; std::_Allocate<MOB_MSG_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UMOB_MSG_DATA@@@std@@QAEPAUMOB_MSG_DATA@@I@Z ENDP ; std::allocator<MOB_MSG_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UMOB_MSG_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UMOB_MSG_DATA@@@std@@QBEIXZ PROC	; std::allocator<MOB_MSG_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 62 27
	76 02		 mov	 DWORD PTR __Count$[ebp], 41297762 ; 02762762H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UMOB_MSG_DATA@@@std@@QBEIXZ ENDP	; std::allocator<MOB_MSG_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QAE@PAUMOB_MSG_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUMOB_MSG_DATA@@@std@@YAPBUMOB_MSG_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUMOB_MSG_DATA@@@std@@YAPBUMOB_MSG_DATA@@ABU1@@Z PROC ; std::addressof<MOB_MSG_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUMOB_MSG_DATA@@@std@@YAPBUMOB_MSG_DATA@@ABU1@@Z ENDP ; std::addressof<MOB_MSG_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z ; std::allocator<MOB_MSG_DATA>::construct<MOB_MSG_DATA &>
PUBLIC	??$forward@AAUMOB_MSG_DATA@@@std@@YAAAUMOB_MSG_DATA@@AAU1@@Z ; std::forward<MOB_MSG_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@AAU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@AAU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUMOB_MSG_DATA@@@std@@YAAAUMOB_MSG_DATA@@AAU1@@Z ; std::forward<MOB_MSG_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z ; std::allocator<MOB_MSG_DATA>::construct<MOB_MSG_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@AAU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@ABU3@@Z ; std::allocator<MOB_MSG_DATA>::construct
PUBLIC	??$forward@ABUMOB_MSG_DATA@@@std@@YAABUMOB_MSG_DATA@@ABU1@@Z ; std::forward<MOB_MSG_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@ABU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@ABU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUMOB_MSG_DATA@@@std@@YAABUMOB_MSG_DATA@@ABU1@@Z ; std::forward<MOB_MSG_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@ABU3@@Z ; std::allocator<MOB_MSG_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@ABU3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>
PUBLIC	??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z ; std::_Ptr_cat<MOB_MSG_DATA,MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T228910 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00@Z PROC ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z ; std::_Ptr_cat<MOB_MSG_DATA,MOB_MSG_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T228910[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T228910[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00@Z ENDP ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@@Z ; std::_Uninitialized_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUMOB_MSG_DATA@@@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEPAUMOB_MSG_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUMOB_MSG_DATA@@@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEPAUMOB_MSG_DATA@@PAU2@00@Z PROC ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Umove<MOB_MSG_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@@Z ; std::_Uninitialized_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUMOB_MSG_DATA@@@?$vector@UMOB_MSG_DATA@@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@IAEPAUMOB_MSG_DATA@@PAU2@00@Z ENDP ; std::vector<MOB_MSG_DATA,std::allocator<MOB_MSG_DATA> >::_Umove<MOB_MSG_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@@Z
_TEXT	SEGMENT
$T228915 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z ; std::_Ptr_cat<MOB_MSG_DATA,MOB_MSG_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T228915[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T228915[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T228918 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@IPAU1@@Z PROC ; std::_Allocate<MOB_MSG_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 62 27
	76 02		 cmp	 DWORD PTR __Count$[ebp], 41297762 ; 02762762H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 68	 imul	 eax, 104		; 00000068H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T228918[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T228918[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@IPAU1@@Z ENDP ; std::_Allocate<MOB_MSG_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z ; std::_Construct<MOB_MSG_DATA,MOB_MSG_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@ABU3@@Z PROC ; std::allocator<MOB_MSG_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z ; std::_Construct<MOB_MSG_DATA,MOB_MSG_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@ABU3@@Z ENDP ; std::allocator<MOB_MSG_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUMOB_MSG_DATA@@@std@@YAAAUMOB_MSG_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUMOB_MSG_DATA@@@std@@YAAAUMOB_MSG_DATA@@AAU1@@Z PROC ; std::forward<MOB_MSG_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUMOB_MSG_DATA@@@std@@YAAAUMOB_MSG_DATA@@AAU1@@Z ENDP ; std::forward<MOB_MSG_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T228925 = -88						; size = 4
$T228926 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z PROC ; std::allocator<MOB_MSG_DATA>::construct<MOB_MSG_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 68		 push	 104			; 00000068H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T228926[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T228926[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUMOB_MSG_DATA@@@std@@YAAAUMOB_MSG_DATA@@AAU1@@Z ; std::forward<MOB_MSG_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T228926[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T228926[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T228925[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T228926[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUMOB_MSG_DATA@@@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@AAU2@@Z ENDP ; std::allocator<MOB_MSG_DATA>::construct<MOB_MSG_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUMOB_MSG_DATA@@@std@@YAABUMOB_MSG_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUMOB_MSG_DATA@@@std@@YAABUMOB_MSG_DATA@@ABU1@@Z PROC ; std::forward<MOB_MSG_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUMOB_MSG_DATA@@@std@@YAABUMOB_MSG_DATA@@ABU1@@Z ENDP ; std::forward<MOB_MSG_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z PROC ; std::_Ptr_cat<MOB_MSG_DATA,MOB_MSG_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z ENDP ; std::_Ptr_cat<MOB_MSG_DATA,MOB_MSG_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAUMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ; std::move<MOB_MSG_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 68	 add	 eax, 104		; 00000068H
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 68	 add	 ecx, 104		; 00000068H
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1a		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ; std::move<MOB_MSG_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00036	8b f0		 mov	 esi, eax
  00038	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0003b	f3 a5		 rep movsd
  0003d	eb cc		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Move@PAUMOB_MSG_DATA@@PAU1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<MOB_MSG_DATA *,MOB_MSG_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
PUBLIC	??$_Val_type@PAUMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@PAU1@@Z ; std::_Val_type<MOB_MSG_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@@Z
_TEXT	SEGMENT
$T228948 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@@Z PROC ; std::_Uninitialized_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UMOB_MSG_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMOB_MSG_DATA@@0@Z ; std::_Ptr_cat<MOB_MSG_DATA,MOB_MSG_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T228948[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T228948[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@PAU1@@Z ; std::_Val_type<MOB_MSG_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@@Z ; std::_Dest_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 68	 add	 eax, 104		; 00000068H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@@Z ; std::_Dest_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UMOB_MSG_DATA@@@std@@@std@@YAXPAUMOB_MSG_DATA@@0AAV?$allocator@UMOB_MSG_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<MOB_MSG_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T228953 = -88						; size = 4
$T228954 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z PROC ; std::_Construct<MOB_MSG_DATA,MOB_MSG_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 68		 push	 104			; 00000068H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T228954[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T228954[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUMOB_MSG_DATA@@@std@@YAABUMOB_MSG_DATA@@ABU1@@Z ; std::forward<MOB_MSG_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T228954[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T228954[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T228953[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T228954[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UMOB_MSG_DATA@@ABU1@@std@@YAXPAUMOB_MSG_DATA@@ABU1@@Z ENDP ; std::_Construct<MOB_MSG_DATA,MOB_MSG_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z PROC ; std::move<MOB_MSG_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ENDP ; std::move<MOB_MSG_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@PAU1@@Z PROC ; std::_Val_type<MOB_MSG_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUMOB_MSG_DATA@@@std@@YAPAUMOB_MSG_DATA@@PAU1@@Z ENDP ; std::_Val_type<MOB_MSG_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@U3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 68	 add	 eax, 104		; 00000068H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 68	 add	 ecx, 104		; 00000068H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@U3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 68	 add	 eax, 104		; 00000068H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@@Z ; std::_Dest_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUMOB_MSG_DATA@@PAU1@V?$allocator@UMOB_MSG_DATA@@@std@@U1@@std@@YAPAUMOB_MSG_DATA@@PAU1@00AAV?$allocator@UMOB_MSG_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<MOB_MSG_DATA *,MOB_MSG_DATA *,std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
PUBLIC	?destroy@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@@Z ; std::allocator<MOB_MSG_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@@Z PROC ; std::_Dest_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@@Z ; std::allocator<MOB_MSG_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UMOB_MSG_DATA@@@std@@YAXPAUMOB_MSG_DATA@@@Z ; std::_Destroy<MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@@Z PROC ; std::allocator<MOB_MSG_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UMOB_MSG_DATA@@@std@@YAXPAUMOB_MSG_DATA@@@Z ; std::_Destroy<MOB_MSG_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@@Z ENDP ; std::allocator<MOB_MSG_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z ; std::allocator<MOB_MSG_DATA>::construct
PUBLIC	??$forward@UMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ; std::forward<MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@U3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@U3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ; std::forward<MOB_MSG_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z ; std::allocator<MOB_MSG_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UMOB_MSG_DATA@@@std@@UMOB_MSG_DATA@@U3@@std@@YAXAAV?$allocator@UMOB_MSG_DATA@@@0@PAUMOB_MSG_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<MOB_MSG_DATA>,MOB_MSG_DATA,MOB_MSG_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UMOB_MSG_DATA@@@std@@YAXPAUMOB_MSG_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UMOB_MSG_DATA@@@std@@YAXPAUMOB_MSG_DATA@@@Z PROC ; std::_Destroy<MOB_MSG_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UMOB_MSG_DATA@@@std@@YAXPAUMOB_MSG_DATA@@@Z ENDP ; std::_Destroy<MOB_MSG_DATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T228993 = -88						; size = 4
$T228994 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z PROC ; std::allocator<MOB_MSG_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 68		 push	 104			; 00000068H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T228994[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T228994[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ; std::forward<MOB_MSG_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T228994[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T228994[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T228993[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T228994[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UMOB_MSG_DATA@@@std@@QAEXPAUMOB_MSG_DATA@@$$QAU3@@Z ENDP ; std::allocator<MOB_MSG_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z PROC ; std::forward<MOB_MSG_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UMOB_MSG_DATA@@@std@@YA$$QAUMOB_MSG_DATA@@AAU1@@Z ENDP ; std::forward<MOB_MSG_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\monstermsg.cpp
;	COMDAT ??__Eg_MonsterMsg@@YAXXZ
text$yc	SEGMENT
??__Eg_MonsterMsg@@YAXXZ PROC				; `dynamic initializer for 'g_MonsterMsg'', COMDAT

; 10   : CMonsterMsg g_MonsterMsg;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterMsg@@3VCMonsterMsg@@A ; g_MonsterMsg
  0000e	e8 00 00 00 00	 call	 ??0CMonsterMsg@@QAE@XZ	; CMonsterMsg::CMonsterMsg
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MonsterMsg@@YAXXZ ; `dynamic atexit destructor for 'g_MonsterMsg''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MonsterMsg@@YAXXZ ENDP				; `dynamic initializer for 'g_MonsterMsg''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_MonsterMsg@@YAXXZ
text$yd	SEGMENT
??__Fg_MonsterMsg@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MonsterMsg'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterMsg@@3VCMonsterMsg@@A ; g_MonsterMsg
  0000e	e8 00 00 00 00	 call	 ??1CMonsterMsg@@QAE@XZ	; CMonsterMsg::~CMonsterMsg
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MonsterMsg@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MonsterMsg''
text$yd	ENDS
PUBLIC	?g_MonsterMsg@@3VCMonsterMsg@@A			; g_MonsterMsg
_BSS	SEGMENT
?g_MonsterMsg@@3VCMonsterMsg@@A DB 010H DUP (?)		; g_MonsterMsg
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MonsterMsg$initializer$ DD FLAT:??__Eg_MonsterMsg@@YAXXZ
CRT$XCU	ENDS
END
