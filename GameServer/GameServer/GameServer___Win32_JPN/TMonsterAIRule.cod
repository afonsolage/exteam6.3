; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\TMonsterAIRule.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_iMonsterCurrentAIUnitTable@TMonsterAIRule@@2PAHA ; TMonsterAIRule::s_iMonsterCurrentAIUnitTable
PUBLIC	?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA	; TMonsterAIRule::s_iMonsterAIRuleInfoCount
PUBLIC	?s_bDataLoad@TMonsterAIRule@@2HA		; TMonsterAIRule::s_bDataLoad
_BSS	SEGMENT
?s_iMonsterCurrentAIUnitTable@TMonsterAIRule@@2PAHA DD 03e8H DUP (?) ; TMonsterAIRule::s_iMonsterCurrentAIUnitTable
?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA DD 01H DUP (?) ; TMonsterAIRule::s_iMonsterAIRuleInfoCount
?s_bDataLoad@TMonsterAIRule@@2HA DD 01H DUP (?)		; TMonsterAIRule::s_bDataLoad
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?DelAllAIRule@TMonsterAIRule@@SAHXZ		; TMonsterAIRule::DelAllAIRule
PUBLIC	??_7TMonsterAIRule@@6B@				; TMonsterAIRule::`vftable'
PUBLIC	??0TMonsterAIRule@@QAE@XZ			; TMonsterAIRule::TMonsterAIRule
PUBLIC	??_R4TMonsterAIRule@@6B@			; TMonsterAIRule::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIRule@@@8			; TMonsterAIRule `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIRule@@8				; TMonsterAIRule::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIRule@@8				; TMonsterAIRule::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIRule@@8			; TMonsterAIRule::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAIRule@@UAEPAXI@Z:PROC		; TMonsterAIRule::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAIRule@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsterairule.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIRule@@8 DD FLAT:??_R0?AVTMonsterAIRule@@@8 ; TMonsterAIRule::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIRule@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIRule@@8
rdata$r	SEGMENT
??_R2TMonsterAIRule@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIRule@@8 ; TMonsterAIRule::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIRule@@8
rdata$r	SEGMENT
??_R3TMonsterAIRule@@8 DD 00H				; TMonsterAIRule::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIRule@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIRule@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAIRule@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAIRule `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIRule@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAIRule@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIRule@@6B@ DD 00H				; TMonsterAIRule::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIRule@@@8
	DD	FLAT:??_R3TMonsterAIRule@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIRule@@6B@
CONST	SEGMENT
??_7TMonsterAIRule@@6B@ DD FLAT:??_R4TMonsterAIRule@@6B@ ; TMonsterAIRule::`vftable'
	DD	FLAT:??_ETMonsterAIRule@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIRule@@QAE@XZ PROC				; TMonsterAIRule::TMonsterAIRule
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIRule@@6B@

; 27   : 	this->DelAllAIRule();

  00015	e8 00 00 00 00	 call	 ?DelAllAIRule@TMonsterAIRule@@SAHXZ ; TMonsterAIRule::DelAllAIRule

; 28   : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??0TMonsterAIRule@@QAE@XZ ENDP				; TMonsterAIRule::TMonsterAIRule
_TEXT	ENDS
PUBLIC	??1TMonsterAIRule@@UAE@XZ			; TMonsterAIRule::~TMonsterAIRule
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GTMonsterAIRule@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTMonsterAIRule@@UAEPAXI@Z PROC			; TMonsterAIRule::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1TMonsterAIRule@@UAE@XZ ; TMonsterAIRule::~TMonsterAIRule
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GTMonsterAIRule@@UAEPAXI@Z ENDP			; TMonsterAIRule::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TMonsterAIRule@@UAE@XZ PROC				; TMonsterAIRule::~TMonsterAIRule
; _this$ = ecx

; 31   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIRule@@6B@

; 32   : 	return;
; 33   : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??1TMonsterAIRule@@UAE@XZ ENDP				; TMonsterAIRule::~TMonsterAIRule
_TEXT	ENDS
PUBLIC	??_C@_0DI@ODGOPJDM@?$FLMonster?5AI?5Rule?$FN?5?9?5Loading?5Exce@ ; `string'
PUBLIC	??_C@_0CH@BFNKLGPG@?$FLMonster?5AI?5Rule?5?$FN?5?9?5?$CFs?5file?5is?5@ ; `string'
PUBLIC	??_C@_0DH@HGLCKALN@?$FLMonster?5AI?5Rule?$FN?5?9?5MonsterClass@ ; `string'
PUBLIC	??_C@_0DH@NNPFAJJI@?$FLMonster?5AI?5Rule?$FN?5?9?5AIRuleNumber@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CD@PMAANPFL@?$FLMonster?5AI?5Rule?$FN?5?9?5Can?8t?5Open?5?$CF@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0DG@HPPFCDDL@?$FLMonster?5AI?5Rule?$FN?5?9?5File?5load?5er@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadData@TMonsterAIRule@@SAHPAD@Z		; TMonsterAIRule::LoadData
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_fclose:PROC
EXTRN	_memcpy:PROC
EXTRN	??0TMonsterAIRuleInfo@@QAE@XZ:PROC		; TMonsterAIRuleInfo::TMonsterAIRuleInfo
EXTRN	_fopen:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_strcmp:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DI@ODGOPJDM@?$FLMonster?5AI?5Rule?$FN?5?9?5Loading?5Exce@
CONST	SEGMENT
??_C@_0DI@ODGOPJDM@?$FLMonster?5AI?5Rule?$FN?5?9?5Loading?5Exce@ DB '[Mon'
	DB	'ster AI Rule] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BFNKLGPG@?$FLMonster?5AI?5Rule?5?$FN?5?9?5?$CFs?5file?5is?5@
CONST	SEGMENT
??_C@_0CH@BFNKLGPG@?$FLMonster?5AI?5Rule?5?$FN?5?9?5?$CFs?5file?5is?5@ DB '['
	DB	'Monster AI Rule ] - %s file is Loaded', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HGLCKALN@?$FLMonster?5AI?5Rule?$FN?5?9?5MonsterClass@
CONST	SEGMENT
??_C@_0DH@HGLCKALN@?$FLMonster?5AI?5Rule?$FN?5?9?5MonsterClass@ DB '[Mons'
	DB	'ter AI Rule] - MonsterClass(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NNPFAJJI@?$FLMonster?5AI?5Rule?$FN?5?9?5AIRuleNumber@
CONST	SEGMENT
??_C@_0DH@NNPFAJJI@?$FLMonster?5AI?5Rule?$FN?5?9?5AIRuleNumber@ DB '[Mons'
	DB	'ter AI Rule] - AIRuleNumber(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PMAANPFL@?$FLMonster?5AI?5Rule?$FN?5?9?5Can?8t?5Open?5?$CF@
CONST	SEGMENT
??_C@_0CD@PMAANPFL@?$FLMonster?5AI?5Rule?$FN?5?9?5Can?8t?5Open?5?$CF@ DB '['
	DB	'Monster AI Rule] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HPPFCDDL@?$FLMonster?5AI?5Rule?$FN?5?9?5File?5load?5er@
CONST	SEGMENT
??_C@_0DG@HPPFCDDL@?$FLMonster?5AI?5Rule?$FN?5?9?5File?5load?5er@ DB '[Mo'
	DB	'nster AI Rule] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterAIRule@@SAHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterAIRule@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterAIRule@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterAIRule@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterAIRule@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterAIRule@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterAIRule@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterAIRule@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv180 = -256						; size = 4
tv179 = -256						; size = 4
tv178 = -256						; size = 4
tv177 = -256						; size = 4
tv176 = -256						; size = 4
tv175 = -256						; size = 4
tv174 = -256						; size = 4
tv173 = -256						; size = 4
tv172 = -256						; size = 4
tv171 = -256						; size = 4
tv170 = -256						; size = 4
tv169 = -256						; size = 4
tv168 = -256						; size = 4
_MonsterAIRuleInfo$204626 = -188			; size = 152
_iMonsterClass$204625 = -36				; size = 4
_iAIRuleNumber$204624 = -32				; size = 4
_iType$204614 = -28					; size = 4
_Token$204610 = -24					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterAIRule@@SAHPAD@Z PROC			; TMonsterAIRule::LoadData

; 39   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	6a ff		 push	 -1
  00055	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterAIRule@@SAHPAD@Z
  0005a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00060	50		 push	 eax
  00061	51		 push	 ecx
  00062	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0006d	33 c5		 xor	 eax, ebp
  0006f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00072	53		 push	 ebx
  00073	56		 push	 esi
  00074	57		 push	 edi
  00075	50		 push	 eax
  00076	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00079	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0007f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 40   : 	TMonsterAIRule::s_bDataLoad = FALSE;

  00082	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIRule@@2HA, 0 ; TMonsterAIRule::s_bDataLoad

; 41   : 
; 42   : 	if ( !lpszFileName || !strcmp(lpszFileName, ""))

  0008c	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  00090	74 15		 je	 SHORT $LN14@LoadData
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00097	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _strcmp
  000a0	83 c4 08	 add	 esp, 8
  000a3	85 c0		 test	 eax, eax
  000a5	75 14		 jne	 SHORT $LN15@LoadData
$LN14@LoadData:

; 43   : 	{
; 44   : 		MsgBox("[Monster AI Rule] - File load error : File Name Error");

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HPPFCDDL@?$FLMonster?5AI?5Rule?$FN?5?9?5File?5load?5er@
  000ac	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000b1	83 c4 04	 add	 esp, 4

; 45   : 		return FALSE;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 81 03 00 00	 jmp	 $LN16@LoadData
$LN15@LoadData:

; 46   : 	}
; 47   : 
; 48   : 	try
; 49   : 	{

  000bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 50   : 		SMDToken Token;
; 51   : 		SMDFile = fopen(lpszFileName, "r");

  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000c7	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _fopen
  000d0	83 c4 08	 add	 esp, 8
  000d3	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 52   : 
; 53   : 		if ( SMDFile == NULL )

  000d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  000df	75 18		 jne	 SHORT $LN12@LoadData

; 54   : 		{
; 55   : 			MsgBox("[Monster AI Rule] - Can't Open %s ", lpszFileName);

  000e1	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@PMAANPFL@?$FLMonster?5AI?5Rule?$FN?5?9?5Can?8t?5Open?5?$CF@
  000ea	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000ef	83 c4 08	 add	 esp, 8

; 56   : 			return FALSE;

  000f2	33 c0		 xor	 eax, eax
  000f4	e9 43 03 00 00	 jmp	 $LN16@LoadData
$LN12@LoadData:

; 57   : 		}
; 58   : 
; 59   : 		TMonsterAIRule::DelAllAIRule();

  000f9	e8 00 00 00 00	 call	 ?DelAllAIRule@TMonsterAIRule@@SAHXZ ; TMonsterAIRule::DelAllAIRule

; 60   : 		int iType = -1;

  000fe	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _iType$204614[ebp], -1
$LN11@LoadData:

; 61   : 
; 62   : 		while ( true )

  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	85 c0		 test	 eax, eax
  0010c	0f 84 d5 02 00
	00		 je	 $LN10@LoadData

; 63   : 		{
; 64   : 			Token = GetToken();

  00112	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00117	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  0011d	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv168[ebp]
  00123	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 65   : 
; 66   : 			if ( Token == END )

  00126	83 7d e8 02	 cmp	 DWORD PTR _Token$204610[ebp], 2
  0012a	75 05		 jne	 SHORT $LN9@LoadData

; 67   : 				break;

  0012c	e9 b6 02 00 00	 jmp	 $LN10@LoadData
$LN9@LoadData:

; 68   : 
; 69   : 			iType = (int)TokenNumber;

  00131	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00137	e8 00 00 00 00	 call	 __ftol2_sse
  0013c	89 45 e4	 mov	 DWORD PTR _iType$204614[ebp], eax
$LN8@LoadData:

; 70   : 
; 71   : 			while ( true )

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	85 c0		 test	 eax, eax
  00146	0f 84 96 02 00
	00		 je	 $LN7@LoadData

; 72   : 			{
; 73   : 				if ( iType == 0 )

  0014c	83 7d e4 00	 cmp	 DWORD PTR _iType$204614[ebp], 0
  00150	0f 85 87 02 00
	00		 jne	 $LN6@LoadData

; 74   : 				{
; 75   : 					int iAIRuleNumber = -1;

  00156	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _iAIRuleNumber$204624[ebp], -1

; 76   : 					int iMonsterClass = -1;

  0015d	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _iMonsterClass$204625[ebp], -1

; 77   : 					TMonsterAIRuleInfo MonsterAIRuleInfo;

  00164	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _MonsterAIRuleInfo$204626[ebp]
  0016a	e8 00 00 00 00	 call	 ??0TMonsterAIRuleInfo@@QAE@XZ ; TMonsterAIRuleInfo::TMonsterAIRuleInfo

; 78   : 
; 79   : 					Token = GetToken();

  0016f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00174	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv169[ebp], eax
  0017a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv169[ebp]
  00180	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 80   : 
; 81   : 					if ( !strcmp("end", TokenString))

  00183	68 00 00 00 00	 push	 OFFSET _TokenString
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0018d	e8 00 00 00 00	 call	 _strcmp
  00192	83 c4 08	 add	 esp, 8
  00195	85 c0		 test	 eax, eax
  00197	75 05		 jne	 SHORT $LN5@LoadData

; 82   : 						break;

  00199	e9 44 02 00 00	 jmp	 $LN7@LoadData
$LN5@LoadData:

; 83   : 
; 84   : 					iAIRuleNumber = (int)TokenNumber;

  0019e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a4	e8 00 00 00 00	 call	 __ftol2_sse
  001a9	89 45 e0	 mov	 DWORD PTR _iAIRuleNumber$204624[ebp], eax

; 85   : 
; 86   : 					Token = GetToken();

  001ac	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001b1	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv170[ebp], eax
  001b7	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv170[ebp]
  001bd	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 87   : 					iMonsterClass = (int)TokenNumber;

  001c0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001c6	e8 00 00 00 00	 call	 __ftol2_sse
  001cb	89 45 dc	 mov	 DWORD PTR _iMonsterClass$204625[ebp], eax

; 88   : 
; 89   : 					Token = GetToken();

  001ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001d3	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv171[ebp], eax
  001d9	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv171[ebp]
  001df	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 90   : 					memcpy(MonsterAIRuleInfo.m_szRuleDesc, TokenString, sizeof(MonsterAIRuleInfo.m_szRuleDesc));

  001e2	6a 64		 push	 100			; 00000064H
  001e4	68 00 00 00 00	 push	 OFFSET _TokenString
  001e9	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _MonsterAIRuleInfo$204626[ebp+52]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _memcpy
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 
; 92   : 					Token = GetToken();

  001f8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001fd	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
  00203	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  00209	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 93   : 					MonsterAIRuleInfo.m_iMonsterAIUnit = (int)TokenNumber;

  0020c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00212	e8 00 00 00 00	 call	 __ftol2_sse
  00217	89 85 4c ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+8], eax

; 94   : 
; 95   : 					Token = GetToken();

  0021d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00222	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv173[ebp], eax
  00228	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv173[ebp]
  0022e	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 96   : 					MonsterAIRuleInfo.m_iRuleCondition = (int)TokenNumber;

  00231	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00237	e8 00 00 00 00	 call	 __ftol2_sse
  0023c	89 85 50 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+12], eax

; 97   : 
; 98   : 					Token = GetToken();

  00242	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00247	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  0024d	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv174[ebp]
  00253	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 99   : 					MonsterAIRuleInfo.m_iWaitTime = (int)TokenNumber;

  00256	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0025c	e8 00 00 00 00	 call	 __ftol2_sse
  00261	89 85 54 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+16], eax

; 100  : 
; 101  : 					Token = GetToken();

  00267	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0026c	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv175[ebp], eax
  00272	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv175[ebp]
  00278	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 102  : 					MonsterAIRuleInfo.m_iContinuanceTime = (int)TokenNumber;

  0027b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00281	e8 00 00 00 00	 call	 __ftol2_sse
  00286	89 85 58 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+20], eax

; 103  : 
; 104  : 					Token = GetToken();

  0028c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00291	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  00297	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  0029d	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 105  : 					MonsterAIRuleInfo.m_iMonth = (int)TokenNumber;

  002a0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002a6	e8 00 00 00 00	 call	 __ftol2_sse
  002ab	89 85 5c ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+24], eax

; 106  : 
; 107  : 					Token = GetToken();

  002b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002b6	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv177[ebp], eax
  002bc	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv177[ebp]
  002c2	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 108  : 					MonsterAIRuleInfo.m_iDay = (int)TokenNumber;

  002c5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002cb	e8 00 00 00 00	 call	 __ftol2_sse
  002d0	89 85 60 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+28], eax

; 109  : 
; 110  : 					Token = GetToken();

  002d6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002db	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv178[ebp], eax
  002e1	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv178[ebp]
  002e7	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 111  : 					MonsterAIRuleInfo.m_iWeekDay = (int)TokenNumber;

  002ea	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002f0	e8 00 00 00 00	 call	 __ftol2_sse
  002f5	89 85 64 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+32], eax

; 112  : 
; 113  : 					Token = GetToken();

  002fb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00300	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  00306	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv179[ebp]
  0030c	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 114  : 					MonsterAIRuleInfo.m_iHour = (int)TokenNumber;

  0030f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00315	e8 00 00 00 00	 call	 __ftol2_sse
  0031a	89 85 68 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+36], eax

; 115  : 
; 116  : 					Token = GetToken();

  00320	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00325	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv180[ebp], eax
  0032b	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv180[ebp]
  00331	89 45 e8	 mov	 DWORD PTR _Token$204610[ebp], eax

; 117  : 					MonsterAIRuleInfo.m_iMinute = (int)TokenNumber;

  00334	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0033a	e8 00 00 00 00	 call	 __ftol2_sse
  0033f	89 85 6c ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+40], eax

; 118  : 
; 119  : 					if ( iAIRuleNumber  < 0 || iAIRuleNumber >= MAX_MONSTER_AI_RULE_INFO )

  00345	83 7d e0 00	 cmp	 DWORD PTR _iAIRuleNumber$204624[ebp], 0
  00349	7c 09		 jl	 SHORT $LN3@LoadData
  0034b	81 7d e0 c8 00
	00 00		 cmp	 DWORD PTR _iAIRuleNumber$204624[ebp], 200 ; 000000c8H
  00352	7c 1a		 jl	 SHORT $LN4@LoadData
$LN3@LoadData:

; 120  : 					{
; 121  : 						MsgBox("[Monster AI Rule] - AIRuleNumber(%d) Error (%s) File. ",
; 122  : 							iAIRuleNumber, lpszFileName);

  00354	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00357	50		 push	 eax
  00358	8b 4d e0	 mov	 ecx, DWORD PTR _iAIRuleNumber$204624[ebp]
  0035b	51		 push	 ecx
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NNPFAJJI@?$FLMonster?5AI?5Rule?$FN?5?9?5AIRuleNumber@
  00361	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00366	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : 
; 124  : 						continue;

  00369	e9 d1 fd ff ff	 jmp	 $LN8@LoadData
$LN4@LoadData:

; 125  : 					}
; 126  : 
; 127  : 					if ( iMonsterClass  < 0 || iMonsterClass >= MAX_MONSTER_AI_RULE_TABLE )

  0036e	83 7d dc 00	 cmp	 DWORD PTR _iMonsterClass$204625[ebp], 0
  00372	7c 09		 jl	 SHORT $LN1@LoadData
  00374	81 7d dc e8 03
	00 00		 cmp	 DWORD PTR _iMonsterClass$204625[ebp], 1000 ; 000003e8H
  0037b	7c 1a		 jl	 SHORT $LN2@LoadData
$LN1@LoadData:

; 128  : 					{
; 129  : 						MsgBox("[Monster AI Rule] - MonsterClass(%d) Error (%s) File. ",
; 130  : 							iMonsterClass, lpszFileName);

  0037d	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00380	50		 push	 eax
  00381	8b 4d dc	 mov	 ecx, DWORD PTR _iMonsterClass$204625[ebp]
  00384	51		 push	 ecx
  00385	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@HGLCKALN@?$FLMonster?5AI?5Rule?$FN?5?9?5MonsterClass@
  0038a	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0038f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 131  : 
; 132  : 						continue;

  00392	e9 a8 fd ff ff	 jmp	 $LN8@LoadData
$LN2@LoadData:

; 133  : 					}
; 134  : 
; 135  : 					MonsterAIRuleInfo.m_iRuleNumber = iAIRuleNumber;

  00397	8b 45 e0	 mov	 eax, DWORD PTR _iAIRuleNumber$204624[ebp]
  0039a	89 85 44 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp], eax

; 136  : 					MonsterAIRuleInfo.m_iMonsterClass = iMonsterClass;

  003a0	8b 45 dc	 mov	 eax, DWORD PTR _iMonsterClass$204625[ebp]
  003a3	89 85 48 ff ff
	ff		 mov	 DWORD PTR _MonsterAIRuleInfo$204626[ebp+4], eax

; 137  : 
; 138  : 					memcpy(&TMonsterAIRule::s_MonsterAIRuleInfoArray[TMonsterAIRule::s_iMonsterAIRuleInfoCount], 
; 139  : 						&MonsterAIRuleInfo,
; 140  : 						sizeof(MonsterAIRuleInfo));

  003a9	68 98 00 00 00	 push	 152			; 00000098H
  003ae	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _MonsterAIRuleInfo$204626[ebp]
  003b4	50		 push	 eax
  003b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA ; TMonsterAIRule::s_iMonsterAIRuleInfoCount
  003bb	69 c9 98 00 00
	00		 imul	 ecx, 152		; 00000098H
  003c1	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A ; TMonsterAIRule::s_MonsterAIRuleInfoArray
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 _memcpy
  003cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 141  : 
; 142  : 					TMonsterAIRule::s_iMonsterAIRuleInfoCount++;

  003d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA ; TMonsterAIRule::s_iMonsterAIRuleInfoCount
  003d5	83 c0 01	 add	 eax, 1
  003d8	a3 00 00 00 00	 mov	 DWORD PTR ?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA, eax ; TMonsterAIRule::s_iMonsterAIRuleInfoCount
$LN6@LoadData:

; 143  : 				}
; 144  : 			}

  003dd	e9 5d fd ff ff	 jmp	 $LN8@LoadData
$LN7@LoadData:

; 145  : 		}

  003e2	e9 1e fd ff ff	 jmp	 $LN11@LoadData
$LN10@LoadData:

; 146  : 
; 147  : 		fclose(SMDFile);

  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  003ec	50		 push	 eax
  003ed	e8 00 00 00 00	 call	 _fclose
  003f2	83 c4 04	 add	 esp, 4

; 148  : 
; 149  : 		LogAddC(2, "[Monster AI Rule ] - %s file is Loaded", lpszFileName);

  003f5	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  003f8	50		 push	 eax
  003f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BFNKLGPG@?$FLMonster?5AI?5Rule?5?$FN?5?9?5?$CFs?5file?5is?5@
  003fe	6a 02		 push	 2
  00400	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00406	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 
; 151  : 		TMonsterAIRule::s_bDataLoad = TRUE;

  00409	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIRule@@2HA, 1 ; TMonsterAIRule::s_bDataLoad

; 152  : 	}

  00413	eb 1e		 jmp	 SHORT $LN18@LoadData
__catch$?LoadData@TMonsterAIRule@@SAHPAD@Z$0:

; 153  : 	catch(...)
; 154  : 	{
; 155  : 		MsgBox("[Monster AI Rule] - Loading Exception Error (%s) File. ", lpszFileName);

  00415	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00418	50		 push	 eax
  00419	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@ODGOPJDM@?$FLMonster?5AI?5Rule?$FN?5?9?5Loading?5Exce@
  0041e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00423	83 c4 08	 add	 esp, 8

; 156  : 	}

  00426	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0042d	b8 00 00 00 00	 mov	 eax, $LN21@LoadData
  00432	c3		 ret	 0
$LN18@LoadData:
  00433	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN21@LoadData:

; 157  : 
; 158  : 	return FALSE;

  0043a	33 c0		 xor	 eax, eax
$LN16@LoadData:

; 159  : }

  0043c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0043f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00446	59		 pop	 ecx
  00447	5f		 pop	 edi
  00448	5e		 pop	 esi
  00449	5b		 pop	 ebx
  0044a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044d	33 cd		 xor	 ecx, ebp
  0044f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterAIRule@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a fc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-260]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterAIRule@@SAHPAD@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterAIRule@@SAHPAD@Z ENDP			; TMonsterAIRule::LoadData
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00460	55		 push	 ebp
  00461	8b ec		 mov	 ebp, esp
  00463	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00469	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0046e	33 c5		 xor	 eax, ebp
  00470	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00473	53		 push	 ebx
  00474	56		 push	 esi
  00475	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00476	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0047d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00482	50		 push	 eax
  00483	e8 00 00 00 00	 call	 _fgetc
  00488	83 c4 04	 add	 esp, 4
  0048b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0048e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00492	83 f9 ff	 cmp	 ecx, -1
  00495	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00497	b8 02 00 00 00	 mov	 eax, 2
  0049c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  004a1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  004a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004a7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  004aa	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  004ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004b1	50		 push	 eax
  004b2	e8 00 00 00 00	 call	 _fgetc
  004b7	83 c4 04	 add	 esp, 4
  004ba	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004bd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004c1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  004c4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  004c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ca	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  004cd	74 1c		 je	 SHORT $LN23@GetToken
  004cf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004d3	83 f8 ff	 cmp	 eax, -1
  004d6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  004d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004dd	50		 push	 eax
  004de	e8 00 00 00 00	 call	 _fgetc
  004e3	83 c4 04	 add	 esp, 4
  004e6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  004e9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  004eb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ef	83 f8 ff	 cmp	 eax, -1
  004f2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  004f4	b8 02 00 00 00	 mov	 eax, 2
  004f9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  004fe	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00502	50		 push	 eax
  00503	e8 00 00 00 00	 call	 _isspace
  00508	83 c4 04	 add	 esp, 4
  0050b	85 c0		 test	 eax, eax
  0050d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00513	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00517	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0051d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00523	83 e9 22	 sub	 ecx, 34			; 00000022H
  00526	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0052c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00533	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00539	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0053f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00546	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0054d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00557	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0055c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00561	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00566	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00570	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00575	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0057a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0057f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00589	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0058e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00593	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00598	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  005a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005a7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  005ac	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  005b1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  005bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005c0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  005c5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  005ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005cf	50		 push	 eax
  005d0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005d4	51		 push	 ecx
  005d5	e8 00 00 00 00	 call	 _ungetc
  005da	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  005dd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  005e0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  005e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005e8	50		 push	 eax
  005e9	e8 00 00 00 00	 call	 _getc
  005ee	83 c4 04	 add	 esp, 4
  005f1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005f4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005f8	83 f9 ff	 cmp	 ecx, -1
  005fb	74 36		 je	 SHORT $LN12@GetToken
  005fd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00601	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00604	74 1a		 je	 SHORT $LN11@GetToken
  00606	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0060a	50		 push	 eax
  0060b	e8 00 00 00 00	 call	 _isdigit
  00610	83 c4 04	 add	 esp, 4
  00613	85 c0		 test	 eax, eax
  00615	75 09		 jne	 SHORT $LN11@GetToken
  00617	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0061b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0061e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00620	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00623	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00626	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00628	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0062b	83 c0 01	 add	 eax, 1
  0062e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00631	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00633	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00636	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00639	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 _atof
  00642	83 c4 04	 add	 esp, 4
  00645	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0064b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00655	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0065a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0065f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00664	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0066b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00670	50		 push	 eax
  00671	e8 00 00 00 00	 call	 _getc
  00676	83 c4 04	 add	 esp, 4
  00679	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0067c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00680	83 f9 ff	 cmp	 ecx, -1
  00683	74 1c		 je	 SHORT $LN8@GetToken
  00685	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00689	83 f8 22	 cmp	 eax, 34			; 00000022H
  0068c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0068e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00691	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00694	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00696	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00699	83 c0 01	 add	 eax, 1
  0069c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0069f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  006a1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006a5	83 f8 22	 cmp	 eax, 34			; 00000022H
  006a8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  006aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006af	50		 push	 eax
  006b0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006b4	51		 push	 ecx
  006b5	e8 00 00 00 00	 call	 _ungetc
  006ba	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  006bd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  006c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  006cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006d2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  006d7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  006dc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006e0	50		 push	 eax
  006e1	e8 00 00 00 00	 call	 _isalpha
  006e6	83 c4 04	 add	 esp, 4
  006e9	85 c0		 test	 eax, eax
  006eb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  006f1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  006f8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006fb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  006fe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00700	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00703	83 c0 01	 add	 eax, 1
  00706	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00709	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0070e	50		 push	 eax
  0070f	e8 00 00 00 00	 call	 _getc
  00714	83 c4 04	 add	 esp, 4
  00717	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0071a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0071e	83 f9 ff	 cmp	 ecx, -1
  00721	74 36		 je	 SHORT $LN3@GetToken
  00723	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00727	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0072a	74 1a		 je	 SHORT $LN2@GetToken
  0072c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00730	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00733	74 11		 je	 SHORT $LN2@GetToken
  00735	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00739	50		 push	 eax
  0073a	e8 00 00 00 00	 call	 _isalnum
  0073f	83 c4 04	 add	 esp, 4
  00742	85 c0		 test	 eax, eax
  00744	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00746	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00749	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0074c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0074e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00751	83 c0 01	 add	 eax, 1
  00754	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00757	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00759	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0075e	50		 push	 eax
  0075f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00763	51		 push	 ecx
  00764	e8 00 00 00 00	 call	 _ungetc
  00769	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0076c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0076f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00772	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0077c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00781	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00783	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00785	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0078f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00794	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00796	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00798	5f		 pop	 edi
  00799	5e		 pop	 esi
  0079a	5b		 pop	 ebx
  0079b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0079e	33 cd		 xor	 ecx, ebp
  007a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007a5	8b e5		 mov	 esp, ebp
  007a7	5d		 pop	 ebp
  007a8	c3		 ret	 0
  007a9	8d 49 00	 npad	 3
$LN35@GetToken:
  007ac	00 00 00 00	 DD	 $LN10@GetToken
  007b0	00 00 00 00	 DD	 $LN19@GetToken
  007b4	00 00 00 00	 DD	 $LN17@GetToken
  007b8	00 00 00 00	 DD	 $LN14@GetToken
  007bc	00 00 00 00	 DD	 $LN18@GetToken
  007c0	00 00 00 00	 DD	 $LN16@GetToken
  007c4	00 00 00 00	 DD	 $LN15@GetToken
  007c8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  007cc	00		 DB	 0
  007cd	01		 DB	 1
  007ce	07		 DB	 7
  007cf	07		 DB	 7
  007d0	07		 DB	 7
  007d1	07		 DB	 7
  007d2	07		 DB	 7
  007d3	07		 DB	 7
  007d4	07		 DB	 7
  007d5	07		 DB	 7
  007d6	02		 DB	 2
  007d7	03		 DB	 3
  007d8	03		 DB	 3
  007d9	07		 DB	 7
  007da	03		 DB	 3
  007db	03		 DB	 3
  007dc	03		 DB	 3
  007dd	03		 DB	 3
  007de	03		 DB	 3
  007df	03		 DB	 3
  007e0	03		 DB	 3
  007e1	03		 DB	 3
  007e2	03		 DB	 3
  007e3	03		 DB	 3
  007e4	07		 DB	 7
  007e5	04		 DB	 4
  007e6	07		 DB	 7
  007e7	07		 DB	 7
  007e8	07		 DB	 7
  007e9	07		 DB	 7
  007ea	07		 DB	 7
  007eb	07		 DB	 7
  007ec	07		 DB	 7
  007ed	07		 DB	 7
  007ee	07		 DB	 7
  007ef	07		 DB	 7
  007f0	07		 DB	 7
  007f1	07		 DB	 7
  007f2	07		 DB	 7
  007f3	07		 DB	 7
  007f4	07		 DB	 7
  007f5	07		 DB	 7
  007f6	07		 DB	 7
  007f7	07		 DB	 7
  007f8	07		 DB	 7
  007f9	07		 DB	 7
  007fa	07		 DB	 7
  007fb	07		 DB	 7
  007fc	07		 DB	 7
  007fd	07		 DB	 7
  007fe	07		 DB	 7
  007ff	07		 DB	 7
  00800	07		 DB	 7
  00801	07		 DB	 7
  00802	07		 DB	 7
  00803	07		 DB	 7
  00804	07		 DB	 7
  00805	07		 DB	 7
  00806	07		 DB	 7
  00807	07		 DB	 7
  00808	07		 DB	 7
  00809	07		 DB	 7
  0080a	07		 DB	 7
  0080b	07		 DB	 7
  0080c	07		 DB	 7
  0080d	07		 DB	 7
  0080e	07		 DB	 7
  0080f	07		 DB	 7
  00810	07		 DB	 7
  00811	07		 DB	 7
  00812	07		 DB	 7
  00813	07		 DB	 7
  00814	07		 DB	 7
  00815	07		 DB	 7
  00816	07		 DB	 7
  00817	07		 DB	 7
  00818	07		 DB	 7
  00819	07		 DB	 7
  0081a	07		 DB	 7
  0081b	07		 DB	 7
  0081c	07		 DB	 7
  0081d	07		 DB	 7
  0081e	07		 DB	 7
  0081f	07		 DB	 7
  00820	07		 DB	 7
  00821	07		 DB	 7
  00822	07		 DB	 7
  00823	07		 DB	 7
  00824	07		 DB	 7
  00825	05		 DB	 5
  00826	07		 DB	 7
  00827	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
EXTRN	?Reset@TMonsterAIRuleInfo@@QAEXXZ:PROC		; TMonsterAIRuleInfo::Reset
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsterairule.cpp
_TEXT	SEGMENT
_j$204654 = -8						; size = 4
_i$204650 = -4						; size = 4
?DelAllAIRule@TMonsterAIRule@@SAHXZ PROC		; TMonsterAIRule::DelAllAIRule

; 164  : {

  00830	55		 push	 ebp
  00831	8b ec		 mov	 ebp, esp
  00833	83 ec 48	 sub	 esp, 72			; 00000048H
  00836	53		 push	 ebx
  00837	56		 push	 esi
  00838	57		 push	 edi

; 165  : 	for ( int i=0;i<MAX_MONSTER_AI_RULE_INFO;i++)

  00839	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$204650[ebp], 0
  00840	eb 09		 jmp	 SHORT $LN6@DelAllAIRu
$LN5@DelAllAIRu:
  00842	8b 45 fc	 mov	 eax, DWORD PTR _i$204650[ebp]
  00845	83 c0 01	 add	 eax, 1
  00848	89 45 fc	 mov	 DWORD PTR _i$204650[ebp], eax
$LN6@DelAllAIRu:
  0084b	81 7d fc c8 00
	00 00		 cmp	 DWORD PTR _i$204650[ebp], 200 ; 000000c8H
  00852	7d 16		 jge	 SHORT $LN4@DelAllAIRu

; 166  : 	{
; 167  : 		TMonsterAIRule::s_MonsterAIRuleInfoArray[i].Reset();

  00854	8b 4d fc	 mov	 ecx, DWORD PTR _i$204650[ebp]
  00857	69 c9 98 00 00
	00		 imul	 ecx, 152		; 00000098H
  0085d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A ; TMonsterAIRule::s_MonsterAIRuleInfoArray
  00863	e8 00 00 00 00	 call	 ?Reset@TMonsterAIRuleInfo@@QAEXXZ ; TMonsterAIRuleInfo::Reset

; 168  : 	}

  00868	eb d8		 jmp	 SHORT $LN5@DelAllAIRu
$LN4@DelAllAIRu:

; 169  : 
; 170  : 	for ( int j=0;j<MAX_MONSTER_AI_RULE_TABLE;j++)

  0086a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$204654[ebp], 0
  00871	eb 09		 jmp	 SHORT $LN3@DelAllAIRu
$LN2@DelAllAIRu:
  00873	8b 45 f8	 mov	 eax, DWORD PTR _j$204654[ebp]
  00876	83 c0 01	 add	 eax, 1
  00879	89 45 f8	 mov	 DWORD PTR _j$204654[ebp], eax
$LN3@DelAllAIRu:
  0087c	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _j$204654[ebp], 1000 ; 000003e8H
  00883	7d 10		 jge	 SHORT $LN1@DelAllAIRu

; 171  : 	{
; 172  : 		TMonsterAIRule::s_iMonsterCurrentAIUnitTable[j] = 0;

  00885	8b 45 f8	 mov	 eax, DWORD PTR _j$204654[ebp]
  00888	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?s_iMonsterCurrentAIUnitTable@TMonsterAIRule@@2PAHA[eax*4], 0

; 173  : 	}

  00893	eb de		 jmp	 SHORT $LN2@DelAllAIRu
$LN1@DelAllAIRu:

; 174  : 
; 175  : 	TMonsterAIRule::s_iMonsterAIRuleInfoCount = 0;

  00895	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA, 0 ; TMonsterAIRule::s_iMonsterAIRuleInfoCount

; 176  : 
; 177  : 	return FALSE;

  0089f	33 c0		 xor	 eax, eax

; 178  : }

  008a1	5f		 pop	 edi
  008a2	5e		 pop	 esi
  008a3	5b		 pop	 ebx
  008a4	8b e5		 mov	 esp, ebp
  008a6	5d		 pop	 ebp
  008a7	c3		 ret	 0
?DelAllAIRule@TMonsterAIRule@@SAHXZ ENDP		; TMonsterAIRule::DelAllAIRule
_TEXT	ENDS
PUBLIC	??_C@_0EA@CHKKBCOM@?$FLMonster?5AI?5Rule?$FN?5GetCurrentAIUn@ ; `string'
PUBLIC	?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z	; TMonsterAIRule::GetCurrentAIUnit
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0EA@CHKKBCOM@?$FLMonster?5AI?5Rule?$FN?5GetCurrentAIUn@
CONST	SEGMENT
??_C@_0EA@CHKKBCOM@?$FLMonster?5AI?5Rule?$FN?5GetCurrentAIUn@ DB '[Monste'
	DB	'r AI Rule] GetCurrentAIUnit() Error - (MonsterClass=%d) ', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iMonsterClass$ = 8					; size = 4
?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z PROC		; TMonsterAIRule::GetCurrentAIUnit

; 182  : {

  008b0	55		 push	 ebp
  008b1	8b ec		 mov	 ebp, esp
  008b3	83 ec 40	 sub	 esp, 64			; 00000040H
  008b6	53		 push	 ebx
  008b7	56		 push	 esi
  008b8	57		 push	 edi

; 183  : 	if ( iMonsterClass < 0 || iMonsterClass >= MAX_MONSTER_AI_RULE_TABLE )

  008b9	83 7d 08 00	 cmp	 DWORD PTR _iMonsterClass$[ebp], 0
  008bd	7c 09		 jl	 SHORT $LN1@GetCurrent
  008bf	81 7d 08 e8 03
	00 00		 cmp	 DWORD PTR _iMonsterClass$[ebp], 1000 ; 000003e8H
  008c6	7c 16		 jl	 SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 184  : 	{
; 185  : 		LogAddTD("[Monster AI Rule] GetCurrentAIUnit() Error - (MonsterClass=%d) ", iMonsterClass);

  008c8	8b 45 08	 mov	 eax, DWORD PTR _iMonsterClass$[ebp]
  008cb	50		 push	 eax
  008cc	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@CHKKBCOM@?$FLMonster?5AI?5Rule?$FN?5GetCurrentAIUn@
  008d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  008d7	83 c4 08	 add	 esp, 8

; 186  : 		return 0;

  008da	33 c0		 xor	 eax, eax
  008dc	eb 0a		 jmp	 SHORT $LN3@GetCurrent
$LN2@GetCurrent:

; 187  : 	}
; 188  : 
; 189  : 	return TMonsterAIRule::s_iMonsterCurrentAIUnitTable[iMonsterClass];

  008de	8b 45 08	 mov	 eax, DWORD PTR _iMonsterClass$[ebp]
  008e1	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?s_iMonsterCurrentAIUnitTable@TMonsterAIRule@@2PAHA[eax*4]
$LN3@GetCurrent:

; 190  : }

  008e8	5f		 pop	 edi
  008e9	5e		 pop	 esi
  008ea	5b		 pop	 ebx
  008eb	8b e5		 mov	 esp, ebp
  008ed	5d		 pop	 ebp
  008ee	c3		 ret	 0
?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z ENDP		; TMonsterAIRule::GetCurrentAIUnit
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ	; TMonsterAIRule::MonsterAIRuleProc
EXTRN	?IsValid@TMonsterAIRuleInfo@@QAEHXZ:PROC	; TMonsterAIRuleInfo::IsValid
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_j$204678 = -1620					; size = 4
_RuleInfo$204673 = -1616				; size = 4
_i$204669 = -1612					; size = 4
_iChangedListCount$ = -1608				; size = 4
_iChangedAIUnitList$ = -1604				; size = 800
_iChangedMonsterClassList$ = -804			; size = 800
__$ArrayPad$ = -4					; size = 4
?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ PROC		; TMonsterAIRule::MonsterAIRuleProc

; 196  : {

  008f0	55		 push	 ebp
  008f1	8b ec		 mov	 ebp, esp
  008f3	81 ec 94 06 00
	00		 sub	 esp, 1684		; 00000694H
  008f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  008fe	33 c5		 xor	 eax, ebp
  00900	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00903	53		 push	 ebx
  00904	56		 push	 esi
  00905	57		 push	 edi

; 197  : 	int iChangedMonsterClassList[MAX_MONSTER_AI_RULE_INFO] = {-1};

  00906	c7 85 dc fc ff
	ff ff ff ff ff	 mov	 DWORD PTR _iChangedMonsterClassList$[ebp], -1
  00910	68 1c 03 00 00	 push	 796			; 0000031cH
  00915	6a 00		 push	 0
  00917	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _iChangedMonsterClassList$[ebp+4]
  0091d	50		 push	 eax
  0091e	e8 00 00 00 00	 call	 _memset
  00923	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  : 	int iChangedAIUnitList[MAX_MONSTER_AI_RULE_INFO] = {0};

  00926	c7 85 bc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iChangedAIUnitList$[ebp], 0
  00930	68 1c 03 00 00	 push	 796			; 0000031cH
  00935	6a 00		 push	 0
  00937	8d 85 c0 f9 ff
	ff		 lea	 eax, DWORD PTR _iChangedAIUnitList$[ebp+4]
  0093d	50		 push	 eax
  0093e	e8 00 00 00 00	 call	 _memset
  00943	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  : 	int iChangedListCount = 0;

  00946	c7 85 b8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iChangedListCount$[ebp], 0

; 200  : 	
; 201  : 	for (int i=0;i<TMonsterAIRule::s_iMonsterAIRuleInfoCount;i++)

  00950	c7 85 b4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$204669[ebp], 0
  0095a	eb 0f		 jmp	 SHORT $LN10@MonsterAIR
$LN9@MonsterAIR:
  0095c	8b 85 b4 f9 ff
	ff		 mov	 eax, DWORD PTR _i$204669[ebp]
  00962	83 c0 01	 add	 eax, 1
  00965	89 85 b4 f9 ff
	ff		 mov	 DWORD PTR _i$204669[ebp], eax
$LN10@MonsterAIR:
  0096b	8b 85 b4 f9 ff
	ff		 mov	 eax, DWORD PTR _i$204669[ebp]
  00971	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_iMonsterAIRuleInfoCount@TMonsterAIRule@@2HA ; TMonsterAIRule::s_iMonsterAIRuleInfoCount
  00977	0f 8d 9c 00 00
	00		 jge	 $LN8@MonsterAIR

; 202  : 	{
; 203  : 		TMonsterAIRuleInfo & RuleInfo = TMonsterAIRule::s_MonsterAIRuleInfoArray[i];

  0097d	8b 85 b4 f9 ff
	ff		 mov	 eax, DWORD PTR _i$204669[ebp]
  00983	69 c0 98 00 00
	00		 imul	 eax, 152		; 00000098H
  00989	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A ; TMonsterAIRule::s_MonsterAIRuleInfoArray
  0098e	89 85 b0 f9 ff
	ff		 mov	 DWORD PTR _RuleInfo$204673[ebp], eax

; 204  : 
; 205  : 		if ( RuleInfo.m_iMonsterClass < 0 || RuleInfo.m_iMonsterClass >= MAX_MONSTER_AI_RULE_TABLE )

  00994	8b 85 b0 f9 ff
	ff		 mov	 eax, DWORD PTR _RuleInfo$204673[ebp]
  0099a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0099e	7c 0f		 jl	 SHORT $LN6@MonsterAIR
  009a0	8b 85 b0 f9 ff
	ff		 mov	 eax, DWORD PTR _RuleInfo$204673[ebp]
  009a6	81 78 04 e8 03
	00 00		 cmp	 DWORD PTR [eax+4], 1000	; 000003e8H
  009ad	7c 05		 jl	 SHORT $LN7@MonsterAIR
$LN6@MonsterAIR:

; 206  : 			return;

  009af	e9 b1 00 00 00	 jmp	 $LN11@MonsterAIR
$LN7@MonsterAIR:

; 207  : 
; 208  : 		if ( RuleInfo.IsValid() )

  009b4	8b 8d b0 f9 ff
	ff		 mov	 ecx, DWORD PTR _RuleInfo$204673[ebp]
  009ba	e8 00 00 00 00	 call	 ?IsValid@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::IsValid
  009bf	85 c0		 test	 eax, eax
  009c1	74 3d		 je	 SHORT $LN5@MonsterAIR

; 209  : 		{
; 210  : 			iChangedMonsterClassList[iChangedListCount] = RuleInfo.m_iMonsterClass;

  009c3	8b 85 b8 f9 ff
	ff		 mov	 eax, DWORD PTR _iChangedListCount$[ebp]
  009c9	8b 8d b0 f9 ff
	ff		 mov	 ecx, DWORD PTR _RuleInfo$204673[ebp]
  009cf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  009d2	89 94 85 dc fc
	ff ff		 mov	 DWORD PTR _iChangedMonsterClassList$[ebp+eax*4], edx

; 211  : 			iChangedAIUnitList[iChangedListCount] = RuleInfo.m_iMonsterAIUnit;

  009d9	8b 85 b8 f9 ff
	ff		 mov	 eax, DWORD PTR _iChangedListCount$[ebp]
  009df	8b 8d b0 f9 ff
	ff		 mov	 ecx, DWORD PTR _RuleInfo$204673[ebp]
  009e5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  009e8	89 94 85 bc f9
	ff ff		 mov	 DWORD PTR _iChangedAIUnitList$[ebp+eax*4], edx

; 212  : 			iChangedListCount++;

  009ef	8b 85 b8 f9 ff
	ff		 mov	 eax, DWORD PTR _iChangedListCount$[ebp]
  009f5	83 c0 01	 add	 eax, 1
  009f8	89 85 b8 f9 ff
	ff		 mov	 DWORD PTR _iChangedListCount$[ebp], eax

; 213  : 		}
; 214  : 		else

  009fe	eb 14		 jmp	 SHORT $LN4@MonsterAIR
$LN5@MonsterAIR:

; 215  : 		{
; 216  : 			TMonsterAIRule::s_iMonsterCurrentAIUnitTable[RuleInfo.m_iMonsterClass] = 0;

  00a00	8b 85 b0 f9 ff
	ff		 mov	 eax, DWORD PTR _RuleInfo$204673[ebp]
  00a06	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a09	c7 04 8d 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?s_iMonsterCurrentAIUnitTable@TMonsterAIRule@@2PAHA[ecx*4], 0
$LN4@MonsterAIR:

; 217  : 		}
; 218  : 	}

  00a14	e9 43 ff ff ff	 jmp	 $LN9@MonsterAIR
$LN8@MonsterAIR:

; 219  : 
; 220  : 	for(int j=0;j<iChangedListCount;j++)

  00a19	c7 85 ac f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$204678[ebp], 0
  00a23	eb 0f		 jmp	 SHORT $LN3@MonsterAIR
$LN2@MonsterAIR:
  00a25	8b 85 ac f9 ff
	ff		 mov	 eax, DWORD PTR _j$204678[ebp]
  00a2b	83 c0 01	 add	 eax, 1
  00a2e	89 85 ac f9 ff
	ff		 mov	 DWORD PTR _j$204678[ebp], eax
$LN3@MonsterAIR:
  00a34	8b 85 ac f9 ff
	ff		 mov	 eax, DWORD PTR _j$204678[ebp]
  00a3a	3b 85 b8 f9 ff
	ff		 cmp	 eax, DWORD PTR _iChangedListCount$[ebp]
  00a40	7d 23		 jge	 SHORT $LN11@MonsterAIR

; 221  : 	{
; 222  : 		TMonsterAIRule::s_iMonsterCurrentAIUnitTable[iChangedMonsterClassList[j]] = iChangedAIUnitList[j];

  00a42	8b 85 ac f9 ff
	ff		 mov	 eax, DWORD PTR _j$204678[ebp]
  00a48	8b 8c 85 dc fc
	ff ff		 mov	 ecx, DWORD PTR _iChangedMonsterClassList$[ebp+eax*4]
  00a4f	8b 95 ac f9 ff
	ff		 mov	 edx, DWORD PTR _j$204678[ebp]
  00a55	8b 84 95 bc f9
	ff ff		 mov	 eax, DWORD PTR _iChangedAIUnitList$[ebp+edx*4]
  00a5c	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?s_iMonsterCurrentAIUnitTable@TMonsterAIRule@@2PAHA[ecx*4], eax

; 223  : 	}

  00a63	eb c0		 jmp	 SHORT $LN2@MonsterAIR
$LN11@MonsterAIR:

; 224  : }

  00a65	5f		 pop	 edi
  00a66	5e		 pop	 esi
  00a67	5b		 pop	 ebx
  00a68	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a6b	33 cd		 xor	 ecx, ebp
  00a6d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a72	8b e5		 mov	 esp, ebp
  00a74	5d		 pop	 ebp
  00a75	c3		 ret	 0
?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ ENDP		; TMonsterAIRule::MonsterAIRuleProc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??__E?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A@@YAXXZ
text$yc	SEGMENT
??__E?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterAIRule::s_MonsterAIRuleInfoArray'', COMDAT

; 17   : TMonsterAIRuleInfo TMonsterAIRule::s_MonsterAIRuleInfoArray[MAX_MONSTER_AI_RULE_INFO];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIRuleInfo@@QAE@XZ ; TMonsterAIRuleInfo::TMonsterAIRuleInfo
  0000e	68 c8 00 00 00	 push	 200			; 000000c8H
  00013	68 98 00 00 00	 push	 152			; 00000098H
  00018	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A ; TMonsterAIRule::s_MonsterAIRuleInfoArray
  0001d	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??__E?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterAIRule::s_MonsterAIRuleInfoArray''
text$yc	ENDS
PUBLIC	?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A ; TMonsterAIRule::s_MonsterAIRuleInfoArray
_BSS	SEGMENT
?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A DB 076c0H DUP (?) ; TMonsterAIRule::s_MonsterAIRuleInfoArray
_BSS	ENDS
CRT$XCU	SEGMENT
?s_MonsterAIRuleInfoArray$initializer$@TMonsterAIRule@@2P6AXXZA DD FLAT:??__E?s_MonsterAIRuleInfoArray@TMonsterAIRule@@2PAVTMonsterAIRuleInfo@@A@@YAXXZ ; TMonsterAIRule::s_MonsterAIRuleInfoArray$initializer$
CRT$XCU	ENDS
END
