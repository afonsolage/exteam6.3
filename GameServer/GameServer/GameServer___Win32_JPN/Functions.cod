; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\Functions.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetRandomExeOption@@YAEE@Z			; GetRandomExeOption
EXTRN	_rand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\functions.cpp
_TEXT	SEGMENT
_i$220398 = -20						; size = 4
_ReturnValue$ = -15					; size = 1
_RandomEx$ = -14					; size = 1
_Random$ = -13						; size = 1
_ExeOptions$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_MaxOption$ = 8						; size = 1
?GetRandomExeOption@@YAEE@Z PROC			; GetRandomExeOption

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 11   : 	unsigned char ExeOptions[6] = {1,2,4,8,16,32};

  00013	c6 45 f4 01	 mov	 BYTE PTR _ExeOptions$[ebp], 1
  00017	c6 45 f5 02	 mov	 BYTE PTR _ExeOptions$[ebp+1], 2
  0001b	c6 45 f6 04	 mov	 BYTE PTR _ExeOptions$[ebp+2], 4
  0001f	c6 45 f7 08	 mov	 BYTE PTR _ExeOptions$[ebp+3], 8
  00023	c6 45 f8 10	 mov	 BYTE PTR _ExeOptions$[ebp+4], 16 ; 00000010H
  00027	c6 45 f9 20	 mov	 BYTE PTR _ExeOptions$[ebp+5], 32 ; 00000020H

; 12   : 	// ----
; 13   : 	unsigned char Random = 0;

  0002b	c6 45 f3 00	 mov	 BYTE PTR _Random$[ebp], 0

; 14   : 	unsigned char RandomEx = 0;

  0002f	c6 45 f2 00	 mov	 BYTE PTR _RandomEx$[ebp], 0

; 15   : 	unsigned char ReturnValue = 0;

  00033	c6 45 f1 00	 mov	 BYTE PTR _ReturnValue$[ebp], 0

; 16   : 
; 17   : 	Random = rand()%(MaxOption+1);

  00037	e8 00 00 00 00	 call	 _rand
  0003c	0f b6 4d 08	 movzx	 ecx, BYTE PTR _MaxOption$[ebp]
  00040	83 c1 01	 add	 ecx, 1
  00043	99		 cdq
  00044	f7 f9		 idiv	 ecx
  00046	88 55 f3	 mov	 BYTE PTR _Random$[ebp], dl

; 18   : 
; 19   : 	for (int i=0;i<Random;i++)

  00049	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$220398[ebp], 0
  00050	eb 09		 jmp	 SHORT $LN6@GetRandomE
$LN5@GetRandomE:
  00052	8b 45 ec	 mov	 eax, DWORD PTR _i$220398[ebp]
  00055	83 c0 01	 add	 eax, 1
  00058	89 45 ec	 mov	 DWORD PTR _i$220398[ebp], eax
$LN6@GetRandomE:
  0005b	0f b6 45 f3	 movzx	 eax, BYTE PTR _Random$[ebp]
  0005f	39 45 ec	 cmp	 DWORD PTR _i$220398[ebp], eax
  00062	7d 3c		 jge	 SHORT $LN4@GetRandomE
$LN3@GetRandomE:

; 20   : 	{
; 21   : 		while ( true )

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	85 c0		 test	 eax, eax
  0006b	74 31		 je	 SHORT $LN2@GetRandomE

; 22   : 		{
; 23   : 			RandomEx = ExeOptions[rand()%6];

  0006d	e8 00 00 00 00	 call	 _rand
  00072	99		 cdq
  00073	b9 06 00 00 00	 mov	 ecx, 6
  00078	f7 f9		 idiv	 ecx
  0007a	8a 54 15 f4	 mov	 dl, BYTE PTR _ExeOptions$[ebp+edx]
  0007e	88 55 f2	 mov	 BYTE PTR _RandomEx$[ebp], dl

; 24   : 
; 25   : 			if ( (ReturnValue&RandomEx) == 0 )

  00081	0f b6 45 f1	 movzx	 eax, BYTE PTR _ReturnValue$[ebp]
  00085	0f b6 4d f2	 movzx	 ecx, BYTE PTR _RandomEx$[ebp]
  00089	23 c1		 and	 eax, ecx
  0008b	75 0f		 jne	 SHORT $LN1@GetRandomE

; 26   : 			{
; 27   : 				ReturnValue+=RandomEx;

  0008d	0f b6 45 f2	 movzx	 eax, BYTE PTR _RandomEx$[ebp]
  00091	0f b6 4d f1	 movzx	 ecx, BYTE PTR _ReturnValue$[ebp]
  00095	03 c8		 add	 ecx, eax
  00097	88 4d f1	 mov	 BYTE PTR _ReturnValue$[ebp], cl

; 28   : 				break;

  0009a	eb 02		 jmp	 SHORT $LN2@GetRandomE
$LN1@GetRandomE:

; 29   : 			}
; 30   : 		}

  0009c	eb c6		 jmp	 SHORT $LN3@GetRandomE
$LN2@GetRandomE:

; 31   : 	}

  0009e	eb b2		 jmp	 SHORT $LN5@GetRandomE
$LN4@GetRandomE:

; 32   : 	return ReturnValue;

  000a0	8a 45 f1	 mov	 al, BYTE PTR _ReturnValue$[ebp]

; 33   : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?GetRandomExeOption@@YAEE@Z ENDP			; GetRandomExeOption
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?Ex_IsBadFileLine@@YA_NPADAAH@Z			; Ex_IsBadFileLine
EXTRN	_isalnum:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	_isdigit:PROC
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$220419 = -4						; size = 4
_FileLine$ = 8						; size = 4
_Flag$ = 12						; size = 4
?Ex_IsBadFileLine@@YA_NPADAAH@Z PROC			; Ex_IsBadFileLine

; 35   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 44	 sub	 esp, 68			; 00000044H
  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	57		 push	 edi

; 36   : 	if(Flag == 0)

  000c9	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	75 2a		 jne	 SHORT $LN12@Ex_IsBadFi

; 37   : 	{
; 38   : 		if(isdigit(FileLine[0]))

  000d1	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  000d4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _isdigit
  000dd	83 c4 04	 add	 esp, 4
  000e0	85 c0		 test	 eax, eax
  000e2	74 15		 je	 SHORT $LN11@Ex_IsBadFi

; 39   : 		{
; 40   : 			Flag = FileLine[0] - 48;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  000e7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ea	83 e9 30	 sub	 ecx, 48			; 00000030H
  000ed	8b 55 0c	 mov	 edx, DWORD PTR _Flag$[ebp]
  000f0	89 0a		 mov	 DWORD PTR [edx], ecx

; 41   : 			return true;

  000f2	b0 01		 mov	 al, 1
  000f4	e9 9a 00 00 00	 jmp	 $LN13@Ex_IsBadFi
$LN11@Ex_IsBadFi:

; 42   : 		}
; 43   : 	}

  000f9	eb 19		 jmp	 SHORT $LN10@Ex_IsBadFi
$LN12@Ex_IsBadFi:

; 44   : 	else if(Flag < 0 || Flag > 9)	//Old 9

  000fb	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  000fe	83 38 00	 cmp	 DWORD PTR [eax], 0
  00101	7c 08		 jl	 SHORT $LN8@Ex_IsBadFi
  00103	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  00106	83 38 09	 cmp	 DWORD PTR [eax], 9
  00109	7e 09		 jle	 SHORT $LN10@Ex_IsBadFi
$LN8@Ex_IsBadFi:

; 45   : 	{
; 46   : 		Flag = 0;

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  0010e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN10@Ex_IsBadFi:

; 47   : 	}
; 48   : 
; 49   : 	if(!strncmp(FileLine, "end", 3))

  00114	6a 03		 push	 3
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0011b	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _strncmp
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
  00127	85 c0		 test	 eax, eax
  00129	75 0d		 jne	 SHORT $LN7@Ex_IsBadFi

; 50   : 	{
; 51   : 		Flag = 0;

  0012b	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  0012e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 52   : 		return true;

  00134	b0 01		 mov	 al, 1
  00136	eb 5b		 jmp	 SHORT $LN13@Ex_IsBadFi
$LN7@Ex_IsBadFi:

; 53   : 	}
; 54   : 
; 55   : 	if(FileLine[0] == '/' || FileLine[0] == '\n')

  00138	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  0013b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0013e	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00141	74 0b		 je	 SHORT $LN5@Ex_IsBadFi
  00143	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00146	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00149	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0014c	75 04		 jne	 SHORT $LN6@Ex_IsBadFi
$LN5@Ex_IsBadFi:

; 56   : 		return true;

  0014e	b0 01		 mov	 al, 1
  00150	eb 41		 jmp	 SHORT $LN13@Ex_IsBadFi
$LN6@Ex_IsBadFi:

; 57   : 
; 58   : 
; 59   : 	for(UINT i = 0; i < strlen(FileLine); i++)

  00152	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$220419[ebp], 0
  00159	eb 09		 jmp	 SHORT $LN4@Ex_IsBadFi
$LN3@Ex_IsBadFi:
  0015b	8b 45 fc	 mov	 eax, DWORD PTR _i$220419[ebp]
  0015e	83 c0 01	 add	 eax, 1
  00161	89 45 fc	 mov	 DWORD PTR _i$220419[ebp], eax
$LN4@Ex_IsBadFi:
  00164	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _strlen
  0016d	83 c4 04	 add	 esp, 4
  00170	39 45 fc	 cmp	 DWORD PTR _i$220419[ebp], eax
  00173	73 1c		 jae	 SHORT $LN2@Ex_IsBadFi

; 60   : 	{
; 61   : 		if(isalnum(FileLine[i]))

  00175	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00178	03 45 fc	 add	 eax, DWORD PTR _i$220419[ebp]
  0017b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0017e	51		 push	 ecx
  0017f	e8 00 00 00 00	 call	 _isalnum
  00184	83 c4 04	 add	 esp, 4
  00187	85 c0		 test	 eax, eax
  00189	74 04		 je	 SHORT $LN1@Ex_IsBadFi

; 62   : 			return false;

  0018b	32 c0		 xor	 al, al
  0018d	eb 04		 jmp	 SHORT $LN13@Ex_IsBadFi
$LN1@Ex_IsBadFi:

; 63   : 	}

  0018f	eb ca		 jmp	 SHORT $LN3@Ex_IsBadFi
$LN2@Ex_IsBadFi:

; 64   : 	return true;

  00191	b0 01		 mov	 al, 1
$LN13@Ex_IsBadFi:

; 65   : }

  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	5b		 pop	 ebx
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
?Ex_IsBadFileLine@@YA_NPADAAH@Z ENDP			; Ex_IsBadFileLine
_TEXT	ENDS
PUBLIC	?GetNumberByPercent@@YAHHHH@Z			; GetNumberByPercent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_Random$ = -4						; size = 4
_Proc$ = 8						; size = 4
_Min$ = 12						; size = 4
_Max$ = 16						; size = 4
?GetNumberByPercent@@YAHHHH@Z PROC			; GetNumberByPercent

; 67   : {

  001a0	55		 push	 ebp
  001a1	8b ec		 mov	 ebp, esp
  001a3	83 ec 44	 sub	 esp, 68			; 00000044H
  001a6	53		 push	 ebx
  001a7	56		 push	 esi
  001a8	57		 push	 edi

; 68   : 	int Random = rand()%100;

  001a9	e8 00 00 00 00	 call	 _rand
  001ae	99		 cdq
  001af	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b4	f7 f9		 idiv	 ecx
  001b6	89 55 fc	 mov	 DWORD PTR _Random$[ebp], edx

; 69   : 
; 70   : 	if(Proc == 0 || Max == Min)

  001b9	83 7d 08 00	 cmp	 DWORD PTR _Proc$[ebp], 0
  001bd	74 08		 je	 SHORT $LN6@GetNumberB
  001bf	8b 45 10	 mov	 eax, DWORD PTR _Max$[ebp]
  001c2	3b 45 0c	 cmp	 eax, DWORD PTR _Min$[ebp]
  001c5	75 05		 jne	 SHORT $LN7@GetNumberB
$LN6@GetNumberB:

; 71   : 		return Min;

  001c7	8b 45 0c	 mov	 eax, DWORD PTR _Min$[ebp]
  001ca	eb 73		 jmp	 SHORT $LN8@GetNumberB
$LN7@GetNumberB:

; 72   : 	
; 73   : 	if(Random <= Proc)

  001cc	8b 45 fc	 mov	 eax, DWORD PTR _Random$[ebp]
  001cf	3b 45 08	 cmp	 eax, DWORD PTR _Proc$[ebp]
  001d2	7f 05		 jg	 SHORT $LN5@GetNumberB

; 74   : 		return Max;

  001d4	8b 45 10	 mov	 eax, DWORD PTR _Max$[ebp]
  001d7	eb 66		 jmp	 SHORT $LN8@GetNumberB
$LN5@GetNumberB:

; 75   : 
; 76   : 	if(Proc > 50)

  001d9	83 7d 08 32	 cmp	 DWORD PTR _Proc$[ebp], 50 ; 00000032H
  001dd	7e 20		 jle	 SHORT $LN4@GetNumberB

; 77   : 		return GetNumberByPercent(Proc/2, Min, Max-1);

  001df	8b 45 10	 mov	 eax, DWORD PTR _Max$[ebp]
  001e2	83 e8 01	 sub	 eax, 1
  001e5	50		 push	 eax
  001e6	8b 4d 0c	 mov	 ecx, DWORD PTR _Min$[ebp]
  001e9	51		 push	 ecx
  001ea	8b 45 08	 mov	 eax, DWORD PTR _Proc$[ebp]
  001ed	99		 cdq
  001ee	2b c2		 sub	 eax, edx
  001f0	d1 f8		 sar	 eax, 1
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?GetNumberByPercent@@YAHHHH@Z ; GetNumberByPercent
  001f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fb	eb 42		 jmp	 SHORT $LN8@GetNumberB
  001fd	eb 40		 jmp	 SHORT $LN8@GetNumberB
$LN4@GetNumberB:

; 78   : 	else if(Proc < 30)

  001ff	83 7d 08 1e	 cmp	 DWORD PTR _Proc$[ebp], 30 ; 0000001eH
  00203	7d 23		 jge	 SHORT $LN2@GetNumberB

; 79   : 		return GetNumberByPercent(Proc*3/2, Min, Max-1);

  00205	8b 45 10	 mov	 eax, DWORD PTR _Max$[ebp]
  00208	83 e8 01	 sub	 eax, 1
  0020b	50		 push	 eax
  0020c	8b 4d 0c	 mov	 ecx, DWORD PTR _Min$[ebp]
  0020f	51		 push	 ecx
  00210	8b 45 08	 mov	 eax, DWORD PTR _Proc$[ebp]
  00213	6b c0 03	 imul	 eax, 3
  00216	99		 cdq
  00217	2b c2		 sub	 eax, edx
  00219	d1 f8		 sar	 eax, 1
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 ?GetNumberByPercent@@YAHHHH@Z ; GetNumberByPercent
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
  00224	eb 19		 jmp	 SHORT $LN8@GetNumberB

; 80   : 	else

  00226	eb 17		 jmp	 SHORT $LN8@GetNumberB
$LN2@GetNumberB:

; 81   : 		return GetNumberByPercent(Proc, Min, Max-1);

  00228	8b 45 10	 mov	 eax, DWORD PTR _Max$[ebp]
  0022b	83 e8 01	 sub	 eax, 1
  0022e	50		 push	 eax
  0022f	8b 4d 0c	 mov	 ecx, DWORD PTR _Min$[ebp]
  00232	51		 push	 ecx
  00233	8b 55 08	 mov	 edx, DWORD PTR _Proc$[ebp]
  00236	52		 push	 edx
  00237	e8 00 00 00 00	 call	 ?GetNumberByPercent@@YAHHHH@Z ; GetNumberByPercent
  0023c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@GetNumberB:

; 82   : }

  0023f	5f		 pop	 edi
  00240	5e		 pop	 esi
  00241	5b		 pop	 ebx
  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c3		 ret	 0
?GetNumberByPercent@@YAHHHH@Z ENDP			; GetNumberByPercent
_TEXT	ENDS
PUBLIC	??$random_shuffle@PAH@std@@YAXPAH0@Z		; std::random_shuffle<int *>
PUBLIC	__$ArrayPad$
PUBLIC	?GenExcOpt@@YAHH@Z				; GenExcOpt
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_n$220449 = -40						; size = 4
_exc$ = -36						; size = 4
_opt_db$ = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_amount$ = 8						; size = 4
?GenExcOpt@@YAHH@Z PROC					; GenExcOpt

; 84   : {

  00250	55		 push	 ebp
  00251	8b ec		 mov	 ebp, esp
  00253	83 ec 68	 sub	 esp, 104		; 00000068H
  00256	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0025b	33 c5		 xor	 eax, ebp
  0025d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00260	53		 push	 ebx
  00261	56		 push	 esi
  00262	57		 push	 edi

; 85   : 	// User input errors
; 86   : 	if (amount > 6) amount = 6;

  00263	83 7d 08 06	 cmp	 DWORD PTR _amount$[ebp], 6
  00267	7e 07		 jle	 SHORT $LN5@GenExcOpt
  00269	c7 45 08 06 00
	00 00		 mov	 DWORD PTR _amount$[ebp], 6
$LN5@GenExcOpt:

; 87   : 	if (amount < 1) return 0;

  00270	83 7d 08 01	 cmp	 DWORD PTR _amount$[ebp], 1
  00274	7d 04		 jge	 SHORT $LN4@GenExcOpt
  00276	33 c0		 xor	 eax, eax
  00278	eb 6d		 jmp	 SHORT $LN6@GenExcOpt
$LN4@GenExcOpt:

; 88   : 
; 89   : 	int opt_db[6]  = {1, 2, 4, 8, 16, 32};

  0027a	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp], 1
  00281	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+4], 2
  00288	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+8], 4
  0028f	c7 45 ec 08 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+12], 8
  00296	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+16], 16 ; 00000010H
  0029d	c7 45 f4 20 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+20], 32 ; 00000020H

; 90   : 	int exc = 0;

  002a4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _exc$[ebp], 0

; 91   : 
; 92   : 	std::random_shuffle(opt_db, opt_db + 6);

  002ab	8d 45 f8	 lea	 eax, DWORD PTR _opt_db$[ebp+24]
  002ae	50		 push	 eax
  002af	8d 4d e0	 lea	 ecx, DWORD PTR _opt_db$[ebp]
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 ??$random_shuffle@PAH@std@@YAXPAH0@Z ; std::random_shuffle<int *>
  002b8	83 c4 08	 add	 esp, 8

; 93   : 
; 94   : 	for(int n=0; n < amount; n++)

  002bb	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$220449[ebp], 0
  002c2	eb 09		 jmp	 SHORT $LN3@GenExcOpt
$LN2@GenExcOpt:
  002c4	8b 45 d8	 mov	 eax, DWORD PTR _n$220449[ebp]
  002c7	83 c0 01	 add	 eax, 1
  002ca	89 45 d8	 mov	 DWORD PTR _n$220449[ebp], eax
$LN3@GenExcOpt:
  002cd	8b 45 d8	 mov	 eax, DWORD PTR _n$220449[ebp]
  002d0	3b 45 08	 cmp	 eax, DWORD PTR _amount$[ebp]
  002d3	7d 0f		 jge	 SHORT $LN1@GenExcOpt

; 95   : 		exc += opt_db[n];

  002d5	8b 45 d8	 mov	 eax, DWORD PTR _n$220449[ebp]
  002d8	8b 4d dc	 mov	 ecx, DWORD PTR _exc$[ebp]
  002db	03 4c 85 e0	 add	 ecx, DWORD PTR _opt_db$[ebp+eax*4]
  002df	89 4d dc	 mov	 DWORD PTR _exc$[ebp], ecx
  002e2	eb e0		 jmp	 SHORT $LN2@GenExcOpt
$LN1@GenExcOpt:

; 96   : 
; 97   : 	return exc;

  002e4	8b 45 dc	 mov	 eax, DWORD PTR _exc$[ebp]
$LN6@GenExcOpt:

; 98   : }

  002e7	5f		 pop	 edi
  002e8	5e		 pop	 esi
  002e9	5b		 pop	 ebx
  002ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ed	33 cd		 xor	 ecx, ebp
  002ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f4	8b e5		 mov	 esp, ebp
  002f6	5d		 pop	 ebp
  002f7	c3		 ret	 0
?GenExcOpt@@YAHH@Z ENDP					; GenExcOpt
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ExGenExcOpt@@YAHH@Z				; ExGenExcOpt
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_n$220460 = -40						; size = 4
_exc$ = -36						; size = 4
_opt_db$ = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_amount$ = 8						; size = 4
?ExGenExcOpt@@YAHH@Z PROC				; ExGenExcOpt

; 101  : {

  00300	55		 push	 ebp
  00301	8b ec		 mov	 ebp, esp
  00303	83 ec 68	 sub	 esp, 104		; 00000068H
  00306	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0030b	33 c5		 xor	 eax, ebp
  0030d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00310	53		 push	 ebx
  00311	56		 push	 esi
  00312	57		 push	 edi

; 102  : 	// User input errors
; 103  : 	if (amount > 6) amount = 6;

  00313	83 7d 08 06	 cmp	 DWORD PTR _amount$[ebp], 6
  00317	7e 07		 jle	 SHORT $LN5@ExGenExcOp
  00319	c7 45 08 06 00
	00 00		 mov	 DWORD PTR _amount$[ebp], 6
$LN5@ExGenExcOp:

; 104  : 	if (amount < 1) return 0;

  00320	83 7d 08 01	 cmp	 DWORD PTR _amount$[ebp], 1
  00324	7d 04		 jge	 SHORT $LN4@ExGenExcOp
  00326	33 c0		 xor	 eax, eax
  00328	eb 6d		 jmp	 SHORT $LN6@ExGenExcOp
$LN4@ExGenExcOp:

; 105  : 
; 106  : 	int opt_db[6]  = {1, 2, 4, 8, 16, 32};

  0032a	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp], 1
  00331	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+4], 2
  00338	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+8], 4
  0033f	c7 45 ec 08 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+12], 8
  00346	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+16], 16 ; 00000010H
  0034d	c7 45 f4 20 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+20], 32 ; 00000020H

; 107  : 	int exc = 0;

  00354	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _exc$[ebp], 0

; 108  : 
; 109  : 	std::random_shuffle(opt_db, opt_db + 6);

  0035b	8d 45 f8	 lea	 eax, DWORD PTR _opt_db$[ebp+24]
  0035e	50		 push	 eax
  0035f	8d 4d e0	 lea	 ecx, DWORD PTR _opt_db$[ebp]
  00362	51		 push	 ecx
  00363	e8 00 00 00 00	 call	 ??$random_shuffle@PAH@std@@YAXPAH0@Z ; std::random_shuffle<int *>
  00368	83 c4 08	 add	 esp, 8

; 110  : 
; 111  : 	for(int n=0; n < amount; n++)

  0036b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$220460[ebp], 0
  00372	eb 09		 jmp	 SHORT $LN3@ExGenExcOp
$LN2@ExGenExcOp:
  00374	8b 45 d8	 mov	 eax, DWORD PTR _n$220460[ebp]
  00377	83 c0 01	 add	 eax, 1
  0037a	89 45 d8	 mov	 DWORD PTR _n$220460[ebp], eax
$LN3@ExGenExcOp:
  0037d	8b 45 d8	 mov	 eax, DWORD PTR _n$220460[ebp]
  00380	3b 45 08	 cmp	 eax, DWORD PTR _amount$[ebp]
  00383	7d 0f		 jge	 SHORT $LN1@ExGenExcOp

; 112  : 		exc += opt_db[n];

  00385	8b 45 d8	 mov	 eax, DWORD PTR _n$220460[ebp]
  00388	8b 4d dc	 mov	 ecx, DWORD PTR _exc$[ebp]
  0038b	03 4c 85 e0	 add	 ecx, DWORD PTR _opt_db$[ebp+eax*4]
  0038f	89 4d dc	 mov	 DWORD PTR _exc$[ebp], ecx
  00392	eb e0		 jmp	 SHORT $LN2@ExGenExcOp
$LN1@ExGenExcOp:

; 113  : 
; 114  : 	return exc;

  00394	8b 45 dc	 mov	 eax, DWORD PTR _exc$[ebp]
$LN6@ExGenExcOp:

; 115  : }

  00397	5f		 pop	 edi
  00398	5e		 pop	 esi
  00399	5b		 pop	 ebx
  0039a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039d	33 cd		 xor	 ecx, ebp
  0039f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a4	8b e5		 mov	 esp, ebp
  003a6	5d		 pop	 ebp
  003a7	c3		 ret	 0
?ExGenExcOpt@@YAHH@Z ENDP				; ExGenExcOpt
_TEXT	ENDS
PUBLIC	?gObjGetItemCountInInventory@@YAHHHH@Z		; gObjGetItemCountInInventory
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220472 = -12						; size = 4
_Count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_ItemID$ = 12						; size = 4
_ItemLevel$ = 16					; size = 4
?gObjGetItemCountInInventory@@YAHHHH@Z PROC		; gObjGetItemCountInInventory

; 119  : {

  003b0	55		 push	 ebp
  003b1	8b ec		 mov	 ebp, esp
  003b3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  003b6	53		 push	 ebx
  003b7	56		 push	 esi
  003b8	57		 push	 edi

; 120  : 	if(aIndex >= OBJMAX)

  003b9	81 7d 08 98 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 15000 ; 00003a98H
  003c0	7c 04		 jl	 SHORT $LN5@gObjGetIte

; 121  : 		return 0;

  003c2	33 c0		 xor	 eax, eax
  003c4	eb 7a		 jmp	 SHORT $LN6@gObjGetIte
$LN5@gObjGetIte:

; 122  : 
; 123  : 	LPOBJ lpObj = &gObj[aIndex];

  003c6	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003c9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  003cf	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d5	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 124  : 
; 125  : 	int Count = 0;

  003d8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Count$[ebp], 0

; 126  : 	for (int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  003df	c7 45 f4 0c 00
	00 00		 mov	 DWORD PTR _i$220472[ebp], 12 ; 0000000cH
  003e6	eb 09		 jmp	 SHORT $LN4@gObjGetIte
$LN3@gObjGetIte:
  003e8	8b 45 f4	 mov	 eax, DWORD PTR _i$220472[ebp]
  003eb	83 c0 01	 add	 eax, 1
  003ee	89 45 f4	 mov	 DWORD PTR _i$220472[ebp], eax
$LN4@gObjGetIte:
  003f1	81 7d f4 ec 00
	00 00		 cmp	 DWORD PTR _i$220472[ebp], 236 ; 000000ecH
  003f8	7d 43		 jge	 SHORT $LN2@gObjGetIte

; 127  : 	{
; 128  : 		if (lpObj->pInventory[i].m_Type == ItemID && lpObj->pInventory[i].m_Level == ItemLevel)

  003fa	8b 45 f4	 mov	 eax, DWORD PTR _i$220472[ebp]
  003fd	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00403	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00406	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0040c	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00411	3b 45 0c	 cmp	 eax, DWORD PTR _ItemID$[ebp]
  00414	75 25		 jne	 SHORT $LN1@gObjGetIte
  00416	8b 45 f4	 mov	 eax, DWORD PTR _i$220472[ebp]
  00419	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0041f	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00422	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00428	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0042d	3b 45 10	 cmp	 eax, DWORD PTR _ItemLevel$[ebp]
  00430	75 09		 jne	 SHORT $LN1@gObjGetIte

; 129  : 			Count++;

  00432	8b 45 f8	 mov	 eax, DWORD PTR _Count$[ebp]
  00435	83 c0 01	 add	 eax, 1
  00438	89 45 f8	 mov	 DWORD PTR _Count$[ebp], eax
$LN1@gObjGetIte:

; 130  : 	}

  0043b	eb ab		 jmp	 SHORT $LN3@gObjGetIte
$LN2@gObjGetIte:

; 131  : 	return Count;

  0043d	8b 45 f8	 mov	 eax, DWORD PTR _Count$[ebp]
$LN6@gObjGetIte:

; 132  : }

  00440	5f		 pop	 edi
  00441	5e		 pop	 esi
  00442	5b		 pop	 ebx
  00443	8b e5		 mov	 esp, ebp
  00445	5d		 pop	 ebp
  00446	c3		 ret	 0
?gObjGetItemCountInInventory@@YAHHHH@Z ENDP		; gObjGetItemCountInInventory
_TEXT	ENDS
PUBLIC	?gObjDeleteItemsCount@@YAHHFFH@Z		; gObjDeleteItemsCount
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220486 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 2
_Level$ = 16						; size = 2
_dCount$ = 20						; size = 4
?gObjDeleteItemsCount@@YAHHFFH@Z PROC			; gObjDeleteItemsCount

; 135  : {

  00450	55		 push	 ebp
  00451	8b ec		 mov	 ebp, esp
  00453	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00456	53		 push	 ebx
  00457	56		 push	 esi
  00458	57		 push	 edi

; 136  : 	if(aIndex >= OBJMAX)

  00459	81 7d 08 98 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 15000 ; 00003a98H
  00460	7c 07		 jl	 SHORT $LN6@gObjDelete

; 137  : 		return 0;

  00462	33 c0		 xor	 eax, eax
  00464	e9 b0 00 00 00	 jmp	 $LN7@gObjDelete
$LN6@gObjDelete:

; 138  : 
; 139  : 	LPOBJ lpObj = &gObj[aIndex];

  00469	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0046c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00472	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00478	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 140  : 
; 141  : 	int count = 0;

  0047b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 142  : 	for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  00482	c7 45 f4 0c 00
	00 00		 mov	 DWORD PTR _i$220486[ebp], 12 ; 0000000cH
  00489	eb 09		 jmp	 SHORT $LN5@gObjDelete
$LN4@gObjDelete:
  0048b	8b 45 f4	 mov	 eax, DWORD PTR _i$220486[ebp]
  0048e	83 c0 01	 add	 eax, 1
  00491	89 45 f4	 mov	 DWORD PTR _i$220486[ebp], eax
$LN5@gObjDelete:
  00494	81 7d f4 ec 00
	00 00		 cmp	 DWORD PTR _i$220486[ebp], 236 ; 000000ecH
  0049b	7d 79		 jge	 SHORT $LN3@gObjDelete

; 143  : 	{
; 144  : 		if(lpObj->pInventory[i].m_Type == Type && lpObj->pInventory[i].m_Level == Level)

  0049d	8b 45 f4	 mov	 eax, DWORD PTR _i$220486[ebp]
  004a0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  004a6	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004a9	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  004af	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  004b4	0f bf 4d 0c	 movsx	 ecx, WORD PTR _Type$[ebp]
  004b8	3b c1		 cmp	 eax, ecx
  004ba	75 55		 jne	 SHORT $LN2@gObjDelete
  004bc	8b 45 f4	 mov	 eax, DWORD PTR _i$220486[ebp]
  004bf	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  004c5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004c8	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  004ce	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  004d3	0f bf 4d 10	 movsx	 ecx, WORD PTR _Level$[ebp]
  004d7	3b c1		 cmp	 eax, ecx
  004d9	75 36		 jne	 SHORT $LN2@gObjDelete

; 145  : 		{
; 146  : 			gObjInventoryDeleteItem(aIndex, i);

  004db	8b 45 f4	 mov	 eax, DWORD PTR _i$220486[ebp]
  004de	50		 push	 eax
  004df	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  004e2	51		 push	 ecx
  004e3	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  004e8	83 c4 08	 add	 esp, 8

; 147  : 			GCInventoryItemDeleteSend(aIndex, i, 1);

  004eb	6a 01		 push	 1
  004ed	0f b6 45 f4	 movzx	 eax, BYTE PTR _i$220486[ebp]
  004f1	50		 push	 eax
  004f2	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  004f5	51		 push	 ecx
  004f6	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  004fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 148  : 			count++;

  004fe	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00501	83 c0 01	 add	 eax, 1
  00504	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 149  : 
; 150  : 			if(dCount == count)

  00507	8b 45 14	 mov	 eax, DWORD PTR _dCount$[ebp]
  0050a	3b 45 f8	 cmp	 eax, DWORD PTR _count$[ebp]
  0050d	75 02		 jne	 SHORT $LN2@gObjDelete

; 151  : 				break;

  0050f	eb 05		 jmp	 SHORT $LN3@gObjDelete
$LN2@gObjDelete:

; 152  : 		}
; 153  : 	}

  00511	e9 75 ff ff ff	 jmp	 $LN4@gObjDelete
$LN3@gObjDelete:

; 154  : 	return count;

  00516	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
$LN7@gObjDelete:

; 155  : }

  00519	5f		 pop	 edi
  0051a	5e		 pop	 esi
  0051b	5b		 pop	 ebx
  0051c	8b e5		 mov	 esp, ebp
  0051e	5d		 pop	 ebp
  0051f	c3		 ret	 0
?gObjDeleteItemsCount@@YAHHFFH@Z ENDP			; gObjDeleteItemsCount
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ExFireCracker@@YAXHEE@Z			; ExFireCracker
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_Packet5$ = -48						; size = 7
_Packet4$ = -40						; size = 7
_Packet3$ = -32						; size = 7
_Packet2$ = -24						; size = 7
_Packet$ = -16						; size = 7
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_X$ = 12						; size = 1
_Y$ = 16						; size = 1
?ExFireCracker@@YAXHEE@Z PROC				; ExFireCracker

; 160  : {

  00520	55		 push	 ebp
  00521	8b ec		 mov	 ebp, esp
  00523	83 ec 70	 sub	 esp, 112		; 00000070H
  00526	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0052b	33 c5		 xor	 eax, ebp
  0052d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00530	53		 push	 ebx
  00531	56		 push	 esi
  00532	57		 push	 edi

; 161  : 	LPOBJ lpObj = &gObj[aIndex];

  00533	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00536	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0053c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00542	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 162  : 	BYTE Packet[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X, Y};

  00545	c6 45 f0 c1	 mov	 BYTE PTR _Packet$[ebp], 193 ; 000000c1H
  00549	c6 45 f1 07	 mov	 BYTE PTR _Packet$[ebp+1], 7
  0054d	c6 45 f2 f3	 mov	 BYTE PTR _Packet$[ebp+2], 243 ; 000000f3H
  00551	c6 45 f3 40	 mov	 BYTE PTR _Packet$[ebp+3], 64 ; 00000040H
  00555	c6 45 f4 00	 mov	 BYTE PTR _Packet$[ebp+4], 0
  00559	8a 45 0c	 mov	 al, BYTE PTR _X$[ebp]
  0055c	88 45 f5	 mov	 BYTE PTR _Packet$[ebp+5], al
  0055f	8a 45 10	 mov	 al, BYTE PTR _Y$[ebp]
  00562	88 45 f6	 mov	 BYTE PTR _Packet$[ebp+6], al

; 163  : 	DataSend(aIndex,Packet,Packet[1]);

  00565	0f b6 45 f1	 movzx	 eax, BYTE PTR _Packet$[ebp+1]
  00569	50		 push	 eax
  0056a	8d 4d f0	 lea	 ecx, DWORD PTR _Packet$[ebp]
  0056d	51		 push	 ecx
  0056e	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00571	52		 push	 edx
  00572	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00577	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 	BYTE Packet2[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X+1, Y};

  0057a	c6 45 e8 c1	 mov	 BYTE PTR _Packet2$[ebp], 193 ; 000000c1H
  0057e	c6 45 e9 07	 mov	 BYTE PTR _Packet2$[ebp+1], 7
  00582	c6 45 ea f3	 mov	 BYTE PTR _Packet2$[ebp+2], 243 ; 000000f3H
  00586	c6 45 eb 40	 mov	 BYTE PTR _Packet2$[ebp+3], 64 ; 00000040H
  0058a	c6 45 ec 00	 mov	 BYTE PTR _Packet2$[ebp+4], 0
  0058e	0f b6 45 0c	 movzx	 eax, BYTE PTR _X$[ebp]
  00592	83 c0 01	 add	 eax, 1
  00595	88 45 ed	 mov	 BYTE PTR _Packet2$[ebp+5], al
  00598	8a 45 10	 mov	 al, BYTE PTR _Y$[ebp]
  0059b	88 45 ee	 mov	 BYTE PTR _Packet2$[ebp+6], al

; 165  : 	DataSend(aIndex,Packet2,Packet2[1]);

  0059e	0f b6 45 e9	 movzx	 eax, BYTE PTR _Packet2$[ebp+1]
  005a2	50		 push	 eax
  005a3	8d 4d e8	 lea	 ecx, DWORD PTR _Packet2$[ebp]
  005a6	51		 push	 ecx
  005a7	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005aa	52		 push	 edx
  005ab	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 166  : 	BYTE Packet3[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X, Y+1};

  005b3	c6 45 e0 c1	 mov	 BYTE PTR _Packet3$[ebp], 193 ; 000000c1H
  005b7	c6 45 e1 07	 mov	 BYTE PTR _Packet3$[ebp+1], 7
  005bb	c6 45 e2 f3	 mov	 BYTE PTR _Packet3$[ebp+2], 243 ; 000000f3H
  005bf	c6 45 e3 40	 mov	 BYTE PTR _Packet3$[ebp+3], 64 ; 00000040H
  005c3	c6 45 e4 00	 mov	 BYTE PTR _Packet3$[ebp+4], 0
  005c7	8a 45 0c	 mov	 al, BYTE PTR _X$[ebp]
  005ca	88 45 e5	 mov	 BYTE PTR _Packet3$[ebp+5], al
  005cd	0f b6 45 10	 movzx	 eax, BYTE PTR _Y$[ebp]
  005d1	83 c0 01	 add	 eax, 1
  005d4	88 45 e6	 mov	 BYTE PTR _Packet3$[ebp+6], al

; 167  : 	DataSend(aIndex,Packet3,Packet3[1]);

  005d7	0f b6 45 e1	 movzx	 eax, BYTE PTR _Packet3$[ebp+1]
  005db	50		 push	 eax
  005dc	8d 4d e0	 lea	 ecx, DWORD PTR _Packet3$[ebp]
  005df	51		 push	 ecx
  005e0	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005e3	52		 push	 edx
  005e4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  : 	BYTE Packet4[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X, Y-1};

  005ec	c6 45 d8 c1	 mov	 BYTE PTR _Packet4$[ebp], 193 ; 000000c1H
  005f0	c6 45 d9 07	 mov	 BYTE PTR _Packet4$[ebp+1], 7
  005f4	c6 45 da f3	 mov	 BYTE PTR _Packet4$[ebp+2], 243 ; 000000f3H
  005f8	c6 45 db 40	 mov	 BYTE PTR _Packet4$[ebp+3], 64 ; 00000040H
  005fc	c6 45 dc 00	 mov	 BYTE PTR _Packet4$[ebp+4], 0
  00600	8a 45 0c	 mov	 al, BYTE PTR _X$[ebp]
  00603	88 45 dd	 mov	 BYTE PTR _Packet4$[ebp+5], al
  00606	0f b6 45 10	 movzx	 eax, BYTE PTR _Y$[ebp]
  0060a	83 e8 01	 sub	 eax, 1
  0060d	88 45 de	 mov	 BYTE PTR _Packet4$[ebp+6], al

; 169  : 	DataSend(aIndex,Packet4,Packet4[1]);

  00610	0f b6 45 d9	 movzx	 eax, BYTE PTR _Packet4$[ebp+1]
  00614	50		 push	 eax
  00615	8d 4d d8	 lea	 ecx, DWORD PTR _Packet4$[ebp]
  00618	51		 push	 ecx
  00619	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0061c	52		 push	 edx
  0061d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00622	83 c4 0c	 add	 esp, 12			; 0000000cH

; 170  : 	BYTE Packet5[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X-1, Y};

  00625	c6 45 d0 c1	 mov	 BYTE PTR _Packet5$[ebp], 193 ; 000000c1H
  00629	c6 45 d1 07	 mov	 BYTE PTR _Packet5$[ebp+1], 7
  0062d	c6 45 d2 f3	 mov	 BYTE PTR _Packet5$[ebp+2], 243 ; 000000f3H
  00631	c6 45 d3 40	 mov	 BYTE PTR _Packet5$[ebp+3], 64 ; 00000040H
  00635	c6 45 d4 00	 mov	 BYTE PTR _Packet5$[ebp+4], 0
  00639	0f b6 45 0c	 movzx	 eax, BYTE PTR _X$[ebp]
  0063d	83 e8 01	 sub	 eax, 1
  00640	88 45 d5	 mov	 BYTE PTR _Packet5$[ebp+5], al
  00643	8a 45 10	 mov	 al, BYTE PTR _Y$[ebp]
  00646	88 45 d6	 mov	 BYTE PTR _Packet5$[ebp+6], al

; 171  : 	DataSend(aIndex,Packet5,Packet5[1]);

  00649	0f b6 45 d1	 movzx	 eax, BYTE PTR _Packet5$[ebp+1]
  0064d	50		 push	 eax
  0064e	8d 4d d0	 lea	 ecx, DWORD PTR _Packet5$[ebp]
  00651	51		 push	 ecx
  00652	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00655	52		 push	 edx
  00656	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0065b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : }

  0065e	5f		 pop	 edi
  0065f	5e		 pop	 esi
  00660	5b		 pop	 ebx
  00661	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00664	33 cd		 xor	 ecx, ebp
  00666	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066b	8b e5		 mov	 esp, ebp
  0066d	5d		 pop	 ebp
  0066e	c3		 ret	 0
?ExFireCracker@@YAXHEE@Z ENDP				; ExFireCracker
_TEXT	ENDS
PUBLIC	?GetExcOptionCount@@YAEE@Z			; GetExcOptionCount
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220507 = -8						; size = 4
_ExcellentCount$ = -4					; size = 4
_ExcellentOption$ = 8					; size = 1
?GetExcOptionCount@@YAEE@Z PROC				; GetExcOptionCount

; 219  : {

  00670	55		 push	 ebp
  00671	8b ec		 mov	 ebp, esp
  00673	83 ec 48	 sub	 esp, 72			; 00000048H
  00676	53		 push	 ebx
  00677	56		 push	 esi
  00678	57		 push	 edi

; 220  : 	int ExcellentCount = 0;

  00679	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ExcellentCount$[ebp], 0

; 221  : 	// ----
; 222  : 	for( int i = 0; i < 6; i++ )

  00680	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220507[ebp], 0
  00687	eb 09		 jmp	 SHORT $LN4@GetExcOpti
$LN3@GetExcOpti:
  00689	8b 45 f8	 mov	 eax, DWORD PTR _i$220507[ebp]
  0068c	83 c0 01	 add	 eax, 1
  0068f	89 45 f8	 mov	 DWORD PTR _i$220507[ebp], eax
$LN4@GetExcOpti:
  00692	83 7d f8 06	 cmp	 DWORD PTR _i$220507[ebp], 6
  00696	7d 19		 jge	 SHORT $LN2@GetExcOpti

; 223  : 	{
; 224  : 		if( (ExcellentOption >> i) & 1 )

  00698	0f b6 45 08	 movzx	 eax, BYTE PTR _ExcellentOption$[ebp]
  0069c	8b 4d f8	 mov	 ecx, DWORD PTR _i$220507[ebp]
  0069f	d3 f8		 sar	 eax, cl
  006a1	83 e0 01	 and	 eax, 1
  006a4	74 09		 je	 SHORT $LN1@GetExcOpti

; 225  : 		{
; 226  : 			ExcellentCount++;

  006a6	8b 45 fc	 mov	 eax, DWORD PTR _ExcellentCount$[ebp]
  006a9	83 c0 01	 add	 eax, 1
  006ac	89 45 fc	 mov	 DWORD PTR _ExcellentCount$[ebp], eax
$LN1@GetExcOpti:

; 227  : 		}
; 228  : 	}

  006af	eb d8		 jmp	 SHORT $LN3@GetExcOpti
$LN2@GetExcOpti:

; 229  : 	// ----
; 230  : 	return ExcellentCount;

  006b1	8a 45 fc	 mov	 al, BYTE PTR _ExcellentCount$[ebp]

; 231  : }

  006b4	5f		 pop	 edi
  006b5	5e		 pop	 esi
  006b6	5b		 pop	 ebx
  006b7	8b e5		 mov	 esp, ebp
  006b9	5d		 pop	 ebp
  006ba	c3		 ret	 0
?GetExcOptionCount@@YAEE@Z ENDP				; GetExcOptionCount
_TEXT	ENDS
PUBLIC	?EmptyPointInventory@@YAHH@Z			; EmptyPointInventory
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220529 = -20						; size = 4
_i$220523 = -16						; size = 4
_i$220517 = -12						; size = 4
_Empty$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?EmptyPointInventory@@YAHH@Z PROC			; EmptyPointInventory

; 234  : {

  006c0	55		 push	 ebp
  006c1	8b ec		 mov	 ebp, esp
  006c3	83 ec 54	 sub	 esp, 84			; 00000054H
  006c6	53		 push	 ebx
  006c7	56		 push	 esi
  006c8	57		 push	 edi

; 235  : 	LPOBJ lpObj = &gObj[aIndex];

  006c9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006cc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  006d2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006d8	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 236  : 	int Empty = 0;

  006db	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Empty$[ebp], 0

; 237  : 	// ----
; 238  : 
; 239  : 	for( int i = INVETORY_WEAR_SIZE; i < 76; i++ )

  006e2	c7 45 f4 0c 00
	00 00		 mov	 DWORD PTR _i$220517[ebp], 12 ; 0000000cH
  006e9	eb 09		 jmp	 SHORT $LN14@EmptyPoint
$LN13@EmptyPoint:
  006eb	8b 45 f4	 mov	 eax, DWORD PTR _i$220517[ebp]
  006ee	83 c0 01	 add	 eax, 1
  006f1	89 45 f4	 mov	 DWORD PTR _i$220517[ebp], eax
$LN14@EmptyPoint:
  006f4	83 7d f4 4c	 cmp	 DWORD PTR _i$220517[ebp], 76 ; 0000004cH
  006f8	7d 26		 jge	 SHORT $LN12@EmptyPoint

; 240  :     {
; 241  :         if( !lpObj->pInventory[i].IsItem() )

  006fa	8b 4d f4	 mov	 ecx, DWORD PTR _i$220517[ebp]
  006fd	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00703	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00706	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0070c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00711	85 c0		 test	 eax, eax
  00713	75 09		 jne	 SHORT $LN11@EmptyPoint

; 242  : 		{
; 243  : 			Empty++;

  00715	8b 45 f8	 mov	 eax, DWORD PTR _Empty$[ebp]
  00718	83 c0 01	 add	 eax, 1
  0071b	89 45 f8	 mov	 DWORD PTR _Empty$[ebp], eax
$LN11@EmptyPoint:

; 244  : 		}
; 245  : 	}

  0071e	eb cb		 jmp	 SHORT $LN13@EmptyPoint
$LN12@EmptyPoint:

; 246  : 
; 247  : 	if(lpObj->ExpandedInventory == 0)

  00720	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00723	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  0072a	85 c9		 test	 ecx, ecx
  0072c	75 08		 jne	 SHORT $LN10@EmptyPoint

; 248  : 	{
; 249  : 		return Empty;

  0072e	8b 45 f8	 mov	 eax, DWORD PTR _Empty$[ebp]
  00731	e9 96 00 00 00	 jmp	 $LN15@EmptyPoint
$LN10@EmptyPoint:

; 250  : 	}
; 251  : 
; 252  : 	for( int i = 76; i < 108; i++ )

  00736	c7 45 f0 4c 00
	00 00		 mov	 DWORD PTR _i$220523[ebp], 76 ; 0000004cH
  0073d	eb 09		 jmp	 SHORT $LN9@EmptyPoint
$LN8@EmptyPoint:
  0073f	8b 45 f0	 mov	 eax, DWORD PTR _i$220523[ebp]
  00742	83 c0 01	 add	 eax, 1
  00745	89 45 f0	 mov	 DWORD PTR _i$220523[ebp], eax
$LN9@EmptyPoint:
  00748	83 7d f0 6c	 cmp	 DWORD PTR _i$220523[ebp], 108 ; 0000006cH
  0074c	7d 26		 jge	 SHORT $LN7@EmptyPoint

; 253  :     {
; 254  :         if( !lpObj->pInventory[i].IsItem() )

  0074e	8b 4d f0	 mov	 ecx, DWORD PTR _i$220523[ebp]
  00751	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00757	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0075a	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  00760	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00765	85 c0		 test	 eax, eax
  00767	75 09		 jne	 SHORT $LN6@EmptyPoint

; 255  : 		{
; 256  : 			Empty++;

  00769	8b 45 f8	 mov	 eax, DWORD PTR _Empty$[ebp]
  0076c	83 c0 01	 add	 eax, 1
  0076f	89 45 f8	 mov	 DWORD PTR _Empty$[ebp], eax
$LN6@EmptyPoint:

; 257  : 		}
; 258  : 	}	

  00772	eb cb		 jmp	 SHORT $LN8@EmptyPoint
$LN7@EmptyPoint:

; 259  : 
; 260  : 	if(lpObj->ExpandedInventory == 1)

  00774	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00777	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  0077e	83 f9 01	 cmp	 ecx, 1
  00781	75 05		 jne	 SHORT $LN5@EmptyPoint

; 261  : 	{
; 262  : 		return Empty;

  00783	8b 45 f8	 mov	 eax, DWORD PTR _Empty$[ebp]
  00786	eb 44		 jmp	 SHORT $LN15@EmptyPoint
$LN5@EmptyPoint:

; 263  : 	}
; 264  : 
; 265  : 	for( int i = 108; i < 140; i++ )

  00788	c7 45 ec 6c 00
	00 00		 mov	 DWORD PTR _i$220529[ebp], 108 ; 0000006cH
  0078f	eb 09		 jmp	 SHORT $LN4@EmptyPoint
$LN3@EmptyPoint:
  00791	8b 45 ec	 mov	 eax, DWORD PTR _i$220529[ebp]
  00794	83 c0 01	 add	 eax, 1
  00797	89 45 ec	 mov	 DWORD PTR _i$220529[ebp], eax
$LN4@EmptyPoint:
  0079a	81 7d ec 8c 00
	00 00		 cmp	 DWORD PTR _i$220529[ebp], 140 ; 0000008cH
  007a1	7d 26		 jge	 SHORT $LN2@EmptyPoint

; 266  :     {
; 267  :         if( !lpObj->pInventory[i].IsItem() )

  007a3	8b 4d ec	 mov	 ecx, DWORD PTR _i$220529[ebp]
  007a6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  007ac	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007af	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  007b5	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  007ba	85 c0		 test	 eax, eax
  007bc	75 09		 jne	 SHORT $LN1@EmptyPoint

; 268  : 		{
; 269  : 			Empty++;

  007be	8b 45 f8	 mov	 eax, DWORD PTR _Empty$[ebp]
  007c1	83 c0 01	 add	 eax, 1
  007c4	89 45 f8	 mov	 DWORD PTR _Empty$[ebp], eax
$LN1@EmptyPoint:

; 270  : 		}
; 271  : 	}	

  007c7	eb c8		 jmp	 SHORT $LN3@EmptyPoint
$LN2@EmptyPoint:

; 272  : 
; 273  : 	return Empty;

  007c9	8b 45 f8	 mov	 eax, DWORD PTR _Empty$[ebp]
$LN15@EmptyPoint:

; 274  : }

  007cc	5f		 pop	 edi
  007cd	5e		 pop	 esi
  007ce	5b		 pop	 ebx
  007cf	8b e5		 mov	 esp, ebp
  007d1	5d		 pop	 ebp
  007d2	c3		 ret	 0
?EmptyPointInventory@@YAHH@Z ENDP			; EmptyPointInventory
_TEXT	ENDS
PUBLIC	?ExCheckInventoryEmptySpace@@YAHH@Z		; ExCheckInventoryEmptySpace
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_x$220551 = -20						; size = 4
_x$220545 = -16						; size = 4
_x$220539 = -12						; size = 4
_iEmptyCount$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?ExCheckInventoryEmptySpace@@YAHH@Z PROC		; ExCheckInventoryEmptySpace

; 277  : {

  007e0	55		 push	 ebp
  007e1	8b ec		 mov	 ebp, esp
  007e3	83 ec 54	 sub	 esp, 84			; 00000054H
  007e6	53		 push	 ebx
  007e7	56		 push	 esi
  007e8	57		 push	 edi

; 278  : 	LPOBJ lpObj = &gObj[aIndex];

  007e9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007ec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  007f2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007f8	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 279  : 	int iEmptyCount = 0;

  007fb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iEmptyCount$[ebp], 0

; 280  : 	for ( int x=0;x<64;x++)

  00802	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$220539[ebp], 0
  00809	eb 09		 jmp	 SHORT $LN14@ExCheckInv
$LN13@ExCheckInv:
  0080b	8b 45 f4	 mov	 eax, DWORD PTR _x$220539[ebp]
  0080e	83 c0 01	 add	 eax, 1
  00811	89 45 f4	 mov	 DWORD PTR _x$220539[ebp], eax
$LN14@ExCheckInv:
  00814	83 7d f4 40	 cmp	 DWORD PTR _x$220539[ebp], 64 ; 00000040H
  00818	7d 22		 jge	 SHORT $LN12@ExCheckInv

; 281  : 	{
; 282  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0081a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0081d	8b 88 28 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3624]
  00823	8b 55 f4	 mov	 edx, DWORD PTR _x$220539[ebp]
  00826	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  0082a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0082f	75 09		 jne	 SHORT $LN11@ExCheckInv

; 283  : 		{
; 284  : 			iEmptyCount++;

  00831	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00834	83 c0 01	 add	 eax, 1
  00837	89 45 f8	 mov	 DWORD PTR _iEmptyCount$[ebp], eax
$LN11@ExCheckInv:

; 285  : 		}
; 286  : 	}

  0083a	eb cf		 jmp	 SHORT $LN13@ExCheckInv
$LN12@ExCheckInv:

; 287  : 
; 288  : 	if(lpObj->ExpandedInventory == 0)

  0083c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0083f	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  00846	85 c9		 test	 ecx, ecx
  00848	75 08		 jne	 SHORT $LN10@ExCheckInv

; 289  : 	{
; 290  : 		return iEmptyCount;

  0084a	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  0084d	e9 8e 00 00 00	 jmp	 $LN15@ExCheckInv
$LN10@ExCheckInv:

; 291  : 	}
; 292  : 
; 293  : 	for ( int x=64;x<96;x++)

  00852	c7 45 f0 40 00
	00 00		 mov	 DWORD PTR _x$220545[ebp], 64 ; 00000040H
  00859	eb 09		 jmp	 SHORT $LN9@ExCheckInv
$LN8@ExCheckInv:
  0085b	8b 45 f0	 mov	 eax, DWORD PTR _x$220545[ebp]
  0085e	83 c0 01	 add	 eax, 1
  00861	89 45 f0	 mov	 DWORD PTR _x$220545[ebp], eax
$LN9@ExCheckInv:
  00864	83 7d f0 60	 cmp	 DWORD PTR _x$220545[ebp], 96 ; 00000060H
  00868	7d 22		 jge	 SHORT $LN7@ExCheckInv

; 294  : 	{
; 295  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0086a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0086d	8b 88 28 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3624]
  00873	8b 55 f0	 mov	 edx, DWORD PTR _x$220545[ebp]
  00876	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  0087a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0087f	75 09		 jne	 SHORT $LN6@ExCheckInv

; 296  : 		{
; 297  : 			iEmptyCount++;

  00881	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00884	83 c0 01	 add	 eax, 1
  00887	89 45 f8	 mov	 DWORD PTR _iEmptyCount$[ebp], eax
$LN6@ExCheckInv:

; 298  : 		}
; 299  : 	}

  0088a	eb cf		 jmp	 SHORT $LN8@ExCheckInv
$LN7@ExCheckInv:

; 300  : 
; 301  : 	if(lpObj->ExpandedInventory == 1)

  0088c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0088f	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  00896	83 f9 01	 cmp	 ecx, 1
  00899	75 05		 jne	 SHORT $LN5@ExCheckInv

; 302  : 	{
; 303  : 		return iEmptyCount;

  0089b	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  0089e	eb 40		 jmp	 SHORT $LN15@ExCheckInv
$LN5@ExCheckInv:

; 304  : 	}
; 305  : 
; 306  : 	for ( int x=96;x<128;x++)

  008a0	c7 45 ec 60 00
	00 00		 mov	 DWORD PTR _x$220551[ebp], 96 ; 00000060H
  008a7	eb 09		 jmp	 SHORT $LN4@ExCheckInv
$LN3@ExCheckInv:
  008a9	8b 45 ec	 mov	 eax, DWORD PTR _x$220551[ebp]
  008ac	83 c0 01	 add	 eax, 1
  008af	89 45 ec	 mov	 DWORD PTR _x$220551[ebp], eax
$LN4@ExCheckInv:
  008b2	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _x$220551[ebp], 128 ; 00000080H
  008b9	7d 22		 jge	 SHORT $LN2@ExCheckInv

; 307  : 	{
; 308  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  008bb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008be	8b 88 28 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3624]
  008c4	8b 55 ec	 mov	 edx, DWORD PTR _x$220551[ebp]
  008c7	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  008cb	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  008d0	75 09		 jne	 SHORT $LN1@ExCheckInv

; 309  : 		{
; 310  : 			iEmptyCount++;

  008d2	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  008d5	83 c0 01	 add	 eax, 1
  008d8	89 45 f8	 mov	 DWORD PTR _iEmptyCount$[ebp], eax
$LN1@ExCheckInv:

; 311  : 		}
; 312  : 	}

  008db	eb cc		 jmp	 SHORT $LN3@ExCheckInv
$LN2@ExCheckInv:

; 313  : 
; 314  : 	return iEmptyCount;

  008dd	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
$LN15@ExCheckInv:

; 315  : 
; 316  : 	//LPOBJ lpObj = &gObj[aIndex];
; 317  : 	//int h=0;
; 318  : 	//int w=0;
; 319  : 	//int iItemWidth = 1, iItemHeight = 1;
; 320  : 	//BYTE blank = 0;
; 321  : 
; 322  : 	//int Point = 0;
; 323  : 	//
; 324  : 	//for(h=0;h<8;h++)
; 325  : 	//{
; 326  : 	//	for(w=0;w<8;w++)
; 327  : 	//	{
; 328  : 	//		if(*(BYTE*)(lpObj->pInventoryMap+(h)*8+(w)) == 255)
; 329  : 	//		{
; 330  : 	//			blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, 1, 1);
; 331  : 
; 332  : 	//			//if ( blank == 0xFE )
; 333  : 	//			//{
; 334  : 	//			//	continue;
; 335  : 	//			//	//result = FALSE;
; 336  : 	//			//	//break;
; 337  : 	//			//}
; 338  : 
; 339  : 	//			//if ( blank == 0xFF )
; 340  : 	//			//{
; 341  : 	//			//	Point++;
; 342  : 	//			//	//return TRUE;
; 343  : 	//			//}
; 344  : 
; 345  : 	//			if ( blank == 0xFF )
; 346  : 	//			{
; 347  : 	//				Point++;
; 348  : 	//			}
; 349  : 	//				
; 350  : 	//		}
; 351  : 	//	}
; 352  : 	//}
; 353  : 	//
; 354  : 	//if(lpObj->ExpandedInventory == 0)
; 355  : 	//{
; 356  : 	//	return Point;
; 357  : 	//}
; 358  : 	//
; 359  : 	//for(h=0;h<4;h++)
; 360  : 	//{
; 361  : 	//	for(w=0;w<8;w++)
; 362  : 	//	{
; 363  : 	//		if(*(BYTE*)((lpObj->pInventoryMap+64)+(h)*8+(w)) == 255)
; 364  : 	//		{
; 365  : 	//			blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, 1, 1);
; 366  : 
; 367  : 	//			//if ( blank == 0xFE )
; 368  : 	//			//{
; 369  : 	//			//	continue;
; 370  : 	//			//	//result = FALSE;
; 371  : 	//			//	//break;
; 372  : 	//			//}
; 373  : 
; 374  : 	//			//if ( blank == 0xFF )
; 375  : 	//			//{
; 376  : 	//			//	Point++;
; 377  : 	//			//	//return TRUE;
; 378  : 	//			//}
; 379  : 	//			
; 380  : 	//			if ( blank == 0xFF )
; 381  : 	//			{
; 382  : 	//				Point++;
; 383  : 	//			}
; 384  : 	//		}
; 385  : 	//	}
; 386  : 	//}
; 387  : 	//
; 388  : 	//if(lpObj->ExpandedInventory == 1)
; 389  : 	//{
; 390  : 	//	return Point;
; 391  : 	//}
; 392  : 	//
; 393  : 	//for(h=0;h<4;h++)
; 394  : 	//{
; 395  : 	//	for(w=0;w<8;w++)
; 396  : 	//	{
; 397  : 	//		if(*(BYTE*)((lpObj->pInventoryMap+96)+(h)*8+(w)) == 255)
; 398  : 	//		{
; 399  : 	//			blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, 1, 1);
; 400  : 
; 401  : 	//			LogAdd("0x%X",blank);
; 402  : 
; 403  : 	//			//if ( blank == 0xFE )
; 404  : 	//			//{
; 405  : 	//			//	continue;
; 406  : 	//			//	//result = FALSE;
; 407  : 	//			//	//break;
; 408  : 	//			//}
; 409  : 
; 410  : 	//			//if ( blank == 0xFF )
; 411  : 	//			//{
; 412  : 	//			//	Point++;
; 413  : 	//			//	//return TRUE;
; 414  : 	//			//}
; 415  : 	//			if ( blank == 0xFF )
; 416  : 	//			{
; 417  : 	//				Point++;
; 418  : 	//			}
; 419  : 	//		}
; 420  : 	//	}
; 421  : 	//}
; 422  : 
; 423  : 	//LogAdd("Point: %d",Point);
; 424  : 
; 425  : 	//return Point;
; 426  : }

  008e0	5f		 pop	 edi
  008e1	5e		 pop	 esi
  008e2	5b		 pop	 ebx
  008e3	8b e5		 mov	 esp, ebp
  008e5	5d		 pop	 ebp
  008e6	c3		 ret	 0
?ExCheckInventoryEmptySpace@@YAHH@Z ENDP		; ExCheckInventoryEmptySpace
_TEXT	ENDS
PUBLIC	?ExIsBadFileLineV2@@YA_NPADAAH@Z		; ExIsBadFileLineV2
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220568 = -4						; size = 4
_FileLine$ = 8						; size = 4
_Flag$ = 12						; size = 4
?ExIsBadFileLineV2@@YA_NPADAAH@Z PROC			; ExIsBadFileLineV2

; 429  : {

  008f0	55		 push	 ebp
  008f1	8b ec		 mov	 ebp, esp
  008f3	83 ec 44	 sub	 esp, 68			; 00000044H
  008f6	53		 push	 ebx
  008f7	56		 push	 esi
  008f8	57		 push	 edi

; 430  : 	if(Flag == 0)

  008f9	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  008fc	83 38 00	 cmp	 DWORD PTR [eax], 0
  008ff	75 2a		 jne	 SHORT $LN12@ExIsBadFil

; 431  : 	{
; 432  : 		if(isdigit(FileLine[0]))

  00901	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00904	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00907	51		 push	 ecx
  00908	e8 00 00 00 00	 call	 _isdigit
  0090d	83 c4 04	 add	 esp, 4
  00910	85 c0		 test	 eax, eax
  00912	74 15		 je	 SHORT $LN11@ExIsBadFil

; 433  : 		{
; 434  : 			Flag = FileLine[0] - 48;

  00914	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00917	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0091a	83 e9 30	 sub	 ecx, 48			; 00000030H
  0091d	8b 55 0c	 mov	 edx, DWORD PTR _Flag$[ebp]
  00920	89 0a		 mov	 DWORD PTR [edx], ecx

; 435  : 			return true;

  00922	b0 01		 mov	 al, 1
  00924	e9 9d 00 00 00	 jmp	 $LN13@ExIsBadFil
$LN11@ExIsBadFil:

; 436  : 		}
; 437  : 	}

  00929	eb 1c		 jmp	 SHORT $LN10@ExIsBadFil
$LN12@ExIsBadFil:

; 438  : 	else if(Flag < 0 || Flag > 999)	//Old 9

  0092b	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  0092e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00931	7c 0b		 jl	 SHORT $LN8@ExIsBadFil
  00933	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  00936	81 38 e7 03 00
	00		 cmp	 DWORD PTR [eax], 999	; 000003e7H
  0093c	7e 09		 jle	 SHORT $LN10@ExIsBadFil
$LN8@ExIsBadFil:

; 439  : 	{
; 440  : 		Flag = -1;

  0093e	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  00941	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
$LN10@ExIsBadFil:

; 441  : 	}
; 442  : 
; 443  : 	if(!strncmp(FileLine, "end", 3))

  00947	6a 03		 push	 3
  00949	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0094e	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00951	50		 push	 eax
  00952	e8 00 00 00 00	 call	 _strncmp
  00957	83 c4 0c	 add	 esp, 12			; 0000000cH
  0095a	85 c0		 test	 eax, eax
  0095c	75 0d		 jne	 SHORT $LN7@ExIsBadFil

; 444  : 	{
; 445  : 		Flag = -1;

  0095e	8b 45 0c	 mov	 eax, DWORD PTR _Flag$[ebp]
  00961	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 446  : 		return true;

  00967	b0 01		 mov	 al, 1
  00969	eb 5b		 jmp	 SHORT $LN13@ExIsBadFil
$LN7@ExIsBadFil:

; 447  : 	}
; 448  : 
; 449  : 	if(FileLine[0] == '/' || FileLine[0] == '\n')

  0096b	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  0096e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00971	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00974	74 0b		 je	 SHORT $LN5@ExIsBadFil
  00976	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  00979	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0097c	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0097f	75 04		 jne	 SHORT $LN6@ExIsBadFil
$LN5@ExIsBadFil:

; 450  : 		return true;

  00981	b0 01		 mov	 al, 1
  00983	eb 41		 jmp	 SHORT $LN13@ExIsBadFil
$LN6@ExIsBadFil:

; 451  : 
; 452  : 	for(UINT i = 0; i < strlen(FileLine); i++)

  00985	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$220568[ebp], 0
  0098c	eb 09		 jmp	 SHORT $LN4@ExIsBadFil
$LN3@ExIsBadFil:
  0098e	8b 45 fc	 mov	 eax, DWORD PTR _i$220568[ebp]
  00991	83 c0 01	 add	 eax, 1
  00994	89 45 fc	 mov	 DWORD PTR _i$220568[ebp], eax
$LN4@ExIsBadFil:
  00997	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  0099a	50		 push	 eax
  0099b	e8 00 00 00 00	 call	 _strlen
  009a0	83 c4 04	 add	 esp, 4
  009a3	39 45 fc	 cmp	 DWORD PTR _i$220568[ebp], eax
  009a6	73 1c		 jae	 SHORT $LN2@ExIsBadFil

; 453  : 	{
; 454  : 		if(isalnum(FileLine[i]))

  009a8	8b 45 08	 mov	 eax, DWORD PTR _FileLine$[ebp]
  009ab	03 45 fc	 add	 eax, DWORD PTR _i$220568[ebp]
  009ae	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  009b1	51		 push	 ecx
  009b2	e8 00 00 00 00	 call	 _isalnum
  009b7	83 c4 04	 add	 esp, 4
  009ba	85 c0		 test	 eax, eax
  009bc	74 04		 je	 SHORT $LN1@ExIsBadFil

; 455  : 			return false;

  009be	32 c0		 xor	 al, al
  009c0	eb 04		 jmp	 SHORT $LN13@ExIsBadFil
$LN1@ExIsBadFil:

; 456  : 	}

  009c2	eb ca		 jmp	 SHORT $LN3@ExIsBadFil
$LN2@ExIsBadFil:

; 457  : 	return true;

  009c4	b0 01		 mov	 al, 1
$LN13@ExIsBadFil:

; 458  : }

  009c6	5f		 pop	 edi
  009c7	5e		 pop	 esi
  009c8	5b		 pop	 ebx
  009c9	8b e5		 mov	 esp, ebp
  009cb	5d		 pop	 ebp
  009cc	c3		 ret	 0
?ExIsBadFileLineV2@@YA_NPADAAH@Z ENDP			; ExIsBadFileLineV2
_TEXT	ENDS
PUBLIC	?CheckOptions@@YA_N_NHH@Z			; CheckOptions
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_bItem$ = 8						; size = 1
_Item1$ = 12						; size = 4
_Item2$ = 16						; size = 4
?CheckOptions@@YA_N_NHH@Z PROC				; CheckOptions

; 461  : {

  009d0	55		 push	 ebp
  009d1	8b ec		 mov	 ebp, esp
  009d3	83 ec 40	 sub	 esp, 64			; 00000040H
  009d6	53		 push	 ebx
  009d7	56		 push	 esi
  009d8	57		 push	 edi

; 462  : 	if(bItem)

  009d9	0f b6 45 08	 movzx	 eax, BYTE PTR _bItem$[ebp]
  009dd	85 c0		 test	 eax, eax
  009df	74 14		 je	 SHORT $LN8@CheckOptio

; 463  : 	{
; 464  : 		if(Item1 == Item2)

  009e1	8b 45 0c	 mov	 eax, DWORD PTR _Item1$[ebp]
  009e4	3b 45 10	 cmp	 eax, DWORD PTR _Item2$[ebp]
  009e7	75 06		 jne	 SHORT $LN7@CheckOptio

; 465  : 		{
; 466  : 			return true;

  009e9	b0 01		 mov	 al, 1
  009eb	eb 2e		 jmp	 SHORT $LN9@CheckOptio

; 467  : 		}
; 468  : 		else

  009ed	eb 04		 jmp	 SHORT $LN6@CheckOptio
$LN7@CheckOptio:

; 469  : 		{
; 470  : 			return false;

  009ef	32 c0		 xor	 al, al
  009f1	eb 28		 jmp	 SHORT $LN9@CheckOptio
$LN6@CheckOptio:

; 471  : 		}
; 472  : 	}
; 473  : 	else

  009f3	eb 26		 jmp	 SHORT $LN9@CheckOptio
$LN8@CheckOptio:

; 474  : 	{
; 475  : 		if(Item2 && Item2)

  009f5	83 7d 10 00	 cmp	 DWORD PTR _Item2$[ebp], 0
  009f9	74 0c		 je	 SHORT $LN4@CheckOptio
  009fb	83 7d 10 00	 cmp	 DWORD PTR _Item2$[ebp], 0
  009ff	74 06		 je	 SHORT $LN4@CheckOptio

; 476  : 		{
; 477  : 			return true;

  00a01	b0 01		 mov	 al, 1
  00a03	eb 16		 jmp	 SHORT $LN9@CheckOptio
  00a05	eb 14		 jmp	 SHORT $LN9@CheckOptio
$LN4@CheckOptio:

; 478  : 		}
; 479  : 		else if(!Item2 && !Item2)

  00a07	83 7d 10 00	 cmp	 DWORD PTR _Item2$[ebp], 0
  00a0b	75 0c		 jne	 SHORT $LN2@CheckOptio
  00a0d	83 7d 10 00	 cmp	 DWORD PTR _Item2$[ebp], 0
  00a11	75 06		 jne	 SHORT $LN2@CheckOptio

; 480  : 		{
; 481  : 			return true;

  00a13	b0 01		 mov	 al, 1
  00a15	eb 04		 jmp	 SHORT $LN9@CheckOptio

; 482  : 		}
; 483  : 		else

  00a17	eb 02		 jmp	 SHORT $LN9@CheckOptio
$LN2@CheckOptio:

; 484  : 		{
; 485  : 			return false;

  00a19	32 c0		 xor	 al, al
$LN9@CheckOptio:

; 486  : 		}
; 487  : 	}
; 488  : }

  00a1b	5f		 pop	 edi
  00a1c	5e		 pop	 esi
  00a1d	5b		 pop	 ebx
  00a1e	8b e5		 mov	 esp, ebp
  00a20	5d		 pop	 ebp
  00a21	c3		 ret	 0
?CheckOptions@@YA_N_NHH@Z ENDP				; CheckOptions
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?CheckInCharacterItem@@YA_NHH@Z			; CheckInCharacterItem
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$220591 = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_ItemType$ = 12						; size = 4
?CheckInCharacterItem@@YA_NHH@Z PROC			; CheckInCharacterItem

; 491  : {

  00a30	55		 push	 ebp
  00a31	8b ec		 mov	 ebp, esp
  00a33	83 ec 48	 sub	 esp, 72			; 00000048H
  00a36	53		 push	 ebx
  00a37	56		 push	 esi
  00a38	57		 push	 edi

; 492  : 	LPOBJ lpObj = &gObj[aIndex];

  00a39	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a3c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a42	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a48	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 493  : 
; 494  : 	for (int i=0;i<INVETORY_WEAR_SIZE;i++)

  00a4b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220591[ebp], 0
  00a52	eb 09		 jmp	 SHORT $LN6@CheckInCha
$LN5@CheckInCha:
  00a54	8b 45 f8	 mov	 eax, DWORD PTR _i$220591[ebp]
  00a57	83 c0 01	 add	 eax, 1
  00a5a	89 45 f8	 mov	 DWORD PTR _i$220591[ebp], eax
$LN6@CheckInCha:
  00a5d	83 7d f8 0c	 cmp	 DWORD PTR _i$220591[ebp], 12 ; 0000000cH
  00a61	7d 66		 jge	 SHORT $LN4@CheckInCha

; 495  : 	{
; 496  : 		if(!lpObj->pInventory[i].IsItem())

  00a63	8b 4d f8	 mov	 ecx, DWORD PTR _i$220591[ebp]
  00a66	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00a6c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a6f	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  00a75	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00a7a	85 c0		 test	 eax, eax
  00a7c	75 02		 jne	 SHORT $LN3@CheckInCha

; 497  : 		{
; 498  : 			continue;

  00a7e	eb d4		 jmp	 SHORT $LN5@CheckInCha
$LN3@CheckInCha:

; 499  : 		}
; 500  : 
; 501  : 		if(lpObj->pInventory[i].m_Durability <= 0.0f)

  00a80	8b 45 f8	 mov	 eax, DWORD PTR _i$220591[ebp]
  00a83	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00a89	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a8c	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00a92	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  00a96	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00a9c	df e0		 fnstsw	 ax
  00a9e	f6 c4 41	 test	 ah, 65			; 00000041H
  00aa1	7a 02		 jp	 SHORT $LN2@CheckInCha

; 502  : 		{
; 503  : 			continue;

  00aa3	eb af		 jmp	 SHORT $LN5@CheckInCha
$LN2@CheckInCha:

; 504  : 		}
; 505  : 
; 506  : 		if(lpObj->pInventory[i].m_Type != ItemType)

  00aa5	8b 45 f8	 mov	 eax, DWORD PTR _i$220591[ebp]
  00aa8	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00aae	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ab1	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00ab7	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00abc	3b 45 0c	 cmp	 eax, DWORD PTR _ItemType$[ebp]
  00abf	74 02		 je	 SHORT $LN1@CheckInCha

; 507  : 		{
; 508  : 			continue;

  00ac1	eb 91		 jmp	 SHORT $LN5@CheckInCha
$LN1@CheckInCha:

; 509  : 		}
; 510  : 
; 511  : 		return true;

  00ac3	b0 01		 mov	 al, 1
  00ac5	eb 04		 jmp	 SHORT $LN7@CheckInCha

; 512  : 		
; 513  : 	}

  00ac7	eb 8b		 jmp	 SHORT $LN5@CheckInCha
$LN4@CheckInCha:

; 514  : 	return false;

  00ac9	32 c0		 xor	 al, al
$LN7@CheckInCha:

; 515  : }

  00acb	5f		 pop	 edi
  00acc	5e		 pop	 esi
  00acd	5b		 pop	 ebx
  00ace	8b e5		 mov	 esp, ebp
  00ad0	5d		 pop	 ebp
  00ad1	c3		 ret	 0
?CheckInCharacterItem@@YA_NHH@Z ENDP			; CheckInCharacterItem
_TEXT	ENDS
PUBLIC	?CheckInventoryItem@@YA_NHH@Z			; CheckInventoryItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$220603 = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_ItemType$ = 12						; size = 4
?CheckInventoryItem@@YA_NHH@Z PROC			; CheckInventoryItem

; 518  : {

  00ae0	55		 push	 ebp
  00ae1	8b ec		 mov	 ebp, esp
  00ae3	83 ec 48	 sub	 esp, 72			; 00000048H
  00ae6	53		 push	 ebx
  00ae7	56		 push	 esi
  00ae8	57		 push	 edi

; 519  : 	LPOBJ lpObj = &gObj[aIndex];

  00ae9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00af2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00af8	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 520  : 
; 521  : 	for ( int i=INVETORY_WEAR_SIZE;i<INVENTORY_SIZE;i++)

  00afb	c7 45 f8 0c 00
	00 00		 mov	 DWORD PTR _i$220603[ebp], 12 ; 0000000cH
  00b02	eb 09		 jmp	 SHORT $LN4@CheckInven
$LN3@CheckInven:
  00b04	8b 45 f8	 mov	 eax, DWORD PTR _i$220603[ebp]
  00b07	83 c0 01	 add	 eax, 1
  00b0a	89 45 f8	 mov	 DWORD PTR _i$220603[ebp], eax
$LN4@CheckInven:
  00b0d	81 7d f8 ec 00
	00 00		 cmp	 DWORD PTR _i$220603[ebp], 236 ; 000000ecH
  00b14	7d 22		 jge	 SHORT $LN2@CheckInven

; 522  : 	{
; 523  : 		
; 524  : 			if(lpObj->pInventory[i].m_Type == ItemType)

  00b16	8b 45 f8	 mov	 eax, DWORD PTR _i$220603[ebp]
  00b19	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00b1f	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b22	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00b28	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00b2d	3b 45 0c	 cmp	 eax, DWORD PTR _ItemType$[ebp]
  00b30	75 04		 jne	 SHORT $LN1@CheckInven

; 525  : 			{
; 526  : 				return true;

  00b32	b0 01		 mov	 al, 1
  00b34	eb 04		 jmp	 SHORT $LN5@CheckInven
$LN1@CheckInven:

; 527  : 			}
; 528  : 	}

  00b36	eb cc		 jmp	 SHORT $LN3@CheckInven
$LN2@CheckInven:

; 529  : 	return false;

  00b38	32 c0		 xor	 al, al
$LN5@CheckInven:

; 530  : }

  00b3a	5f		 pop	 edi
  00b3b	5e		 pop	 esi
  00b3c	5b		 pop	 ebx
  00b3d	8b e5		 mov	 esp, ebp
  00b3f	5d		 pop	 ebp
  00b40	c3		 ret	 0
?CheckInventoryItem@@YA_NHH@Z ENDP			; CheckInventoryItem
_TEXT	ENDS
PUBLIC	?Max90Procent@@YAXAAH@Z				; Max90Procent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_Value$ = 8						; size = 4
?Max90Procent@@YAXAAH@Z PROC				; Max90Procent

; 534  : {

  00b50	55		 push	 ebp
  00b51	8b ec		 mov	 ebp, esp
  00b53	83 ec 40	 sub	 esp, 64			; 00000040H
  00b56	53		 push	 ebx
  00b57	56		 push	 esi
  00b58	57		 push	 edi

; 535  : 	if(Value > 90)

  00b59	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00b5c	83 38 5a	 cmp	 DWORD PTR [eax], 90	; 0000005aH
  00b5f	7e 09		 jle	 SHORT $LN2@Max90Proce

; 536  : 	{
; 537  : 		Value = 90;

  00b61	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00b64	c7 00 5a 00 00
	00		 mov	 DWORD PTR [eax], 90	; 0000005aH
$LN2@Max90Proce:

; 538  : 	}
; 539  : }

  00b6a	5f		 pop	 edi
  00b6b	5e		 pop	 esi
  00b6c	5b		 pop	 ebx
  00b6d	8b e5		 mov	 esp, ebp
  00b6f	5d		 pop	 ebp
  00b70	c3		 ret	 0
?Max90Procent@@YAXAAH@Z ENDP				; Max90Procent
_TEXT	ENDS
PUBLIC	?GetInventoryEmptyPoint@@YAHH@Z			; GetInventoryEmptyPoint
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_x$220629 = -20						; size = 4
_x$220623 = -16						; size = 4
_x$220617 = -12						; size = 4
_iEmptyCount$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?GetInventoryEmptyPoint@@YAHH@Z PROC			; GetInventoryEmptyPoint

; 543  : {

  00b80	55		 push	 ebp
  00b81	8b ec		 mov	 ebp, esp
  00b83	83 ec 54	 sub	 esp, 84			; 00000054H
  00b86	53		 push	 ebx
  00b87	56		 push	 esi
  00b88	57		 push	 edi

; 544  : 	LPOBJ lpObj = &gObj[aIndex];

  00b89	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b8c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b92	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b98	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 545  : 	int iEmptyCount = 0;

  00b9b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iEmptyCount$[ebp], 0

; 546  : 
; 547  : 	for ( int x=0;x<64;x++)

  00ba2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$220617[ebp], 0
  00ba9	eb 09		 jmp	 SHORT $LN14@GetInvento
$LN13@GetInvento:
  00bab	8b 45 f4	 mov	 eax, DWORD PTR _x$220617[ebp]
  00bae	83 c0 01	 add	 eax, 1
  00bb1	89 45 f4	 mov	 DWORD PTR _x$220617[ebp], eax
$LN14@GetInvento:
  00bb4	83 7d f4 40	 cmp	 DWORD PTR _x$220617[ebp], 64 ; 00000040H
  00bb8	7d 22		 jge	 SHORT $LN12@GetInvento

; 548  : 	{
; 549  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00bba	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bbd	8b 88 28 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3624]
  00bc3	8b 55 f4	 mov	 edx, DWORD PTR _x$220617[ebp]
  00bc6	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00bca	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00bcf	75 09		 jne	 SHORT $LN11@GetInvento

; 550  : 		{
; 551  : 			iEmptyCount++;

  00bd1	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00bd4	83 c0 01	 add	 eax, 1
  00bd7	89 45 f8	 mov	 DWORD PTR _iEmptyCount$[ebp], eax
$LN11@GetInvento:

; 552  : 		}
; 553  : 	}

  00bda	eb cf		 jmp	 SHORT $LN13@GetInvento
$LN12@GetInvento:

; 554  : 
; 555  : 	if(lpObj->ExpandedInventory == 0)

  00bdc	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bdf	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  00be6	85 c9		 test	 ecx, ecx
  00be8	75 08		 jne	 SHORT $LN10@GetInvento

; 556  : 	{
; 557  : 		return iEmptyCount;

  00bea	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00bed	e9 8e 00 00 00	 jmp	 $LN15@GetInvento
$LN10@GetInvento:

; 558  : 	}
; 559  : 
; 560  : 	for ( int x=64;x<96;x++)

  00bf2	c7 45 f0 40 00
	00 00		 mov	 DWORD PTR _x$220623[ebp], 64 ; 00000040H
  00bf9	eb 09		 jmp	 SHORT $LN9@GetInvento
$LN8@GetInvento:
  00bfb	8b 45 f0	 mov	 eax, DWORD PTR _x$220623[ebp]
  00bfe	83 c0 01	 add	 eax, 1
  00c01	89 45 f0	 mov	 DWORD PTR _x$220623[ebp], eax
$LN9@GetInvento:
  00c04	83 7d f0 60	 cmp	 DWORD PTR _x$220623[ebp], 96 ; 00000060H
  00c08	7d 22		 jge	 SHORT $LN7@GetInvento

; 561  : 	{
; 562  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00c0a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c0d	8b 88 28 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3624]
  00c13	8b 55 f0	 mov	 edx, DWORD PTR _x$220623[ebp]
  00c16	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00c1a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00c1f	75 09		 jne	 SHORT $LN6@GetInvento

; 563  : 		{
; 564  : 			iEmptyCount++;

  00c21	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00c24	83 c0 01	 add	 eax, 1
  00c27	89 45 f8	 mov	 DWORD PTR _iEmptyCount$[ebp], eax
$LN6@GetInvento:

; 565  : 		}
; 566  : 	}

  00c2a	eb cf		 jmp	 SHORT $LN8@GetInvento
$LN7@GetInvento:

; 567  : 
; 568  : 	if(lpObj->ExpandedInventory == 1)

  00c2c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c2f	0f b6 88 24 26
	00 00		 movzx	 ecx, BYTE PTR [eax+9764]
  00c36	83 f9 01	 cmp	 ecx, 1
  00c39	75 05		 jne	 SHORT $LN5@GetInvento

; 569  : 	{
; 570  : 		return iEmptyCount;

  00c3b	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00c3e	eb 40		 jmp	 SHORT $LN15@GetInvento
$LN5@GetInvento:

; 571  : 	}
; 572  : 
; 573  : 	for ( int x=96;x<128;x++)

  00c40	c7 45 ec 60 00
	00 00		 mov	 DWORD PTR _x$220629[ebp], 96 ; 00000060H
  00c47	eb 09		 jmp	 SHORT $LN4@GetInvento
$LN3@GetInvento:
  00c49	8b 45 ec	 mov	 eax, DWORD PTR _x$220629[ebp]
  00c4c	83 c0 01	 add	 eax, 1
  00c4f	89 45 ec	 mov	 DWORD PTR _x$220629[ebp], eax
$LN4@GetInvento:
  00c52	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _x$220629[ebp], 128 ; 00000080H
  00c59	7d 22		 jge	 SHORT $LN2@GetInvento

; 574  : 	{
; 575  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00c5b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c5e	8b 88 28 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3624]
  00c64	8b 55 ec	 mov	 edx, DWORD PTR _x$220629[ebp]
  00c67	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00c6b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00c70	75 09		 jne	 SHORT $LN1@GetInvento

; 576  : 		{
; 577  : 			iEmptyCount++;

  00c72	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
  00c75	83 c0 01	 add	 eax, 1
  00c78	89 45 f8	 mov	 DWORD PTR _iEmptyCount$[ebp], eax
$LN1@GetInvento:

; 578  : 		}
; 579  : 	}

  00c7b	eb cc		 jmp	 SHORT $LN3@GetInvento
$LN2@GetInvento:

; 580  : 
; 581  : 	return iEmptyCount;

  00c7d	8b 45 f8	 mov	 eax, DWORD PTR _iEmptyCount$[ebp]
$LN15@GetInvento:

; 582  : }

  00c80	5f		 pop	 edi
  00c81	5e		 pop	 esi
  00c82	5b		 pop	 ebx
  00c83	8b e5		 mov	 esp, ebp
  00c85	5d		 pop	 ebp
  00c86	c3		 ret	 0
?GetInventoryEmptyPoint@@YAHH@Z ENDP			; GetInventoryEmptyPoint
_TEXT	ENDS
PUBLIC	??$_Random_shuffle@PAHH@std@@YAXPAH00@Z		; std::_Random_shuffle<int *,int>
PUBLIC	??$_Unchecked@PAH@std@@YAPAHPAH@Z		; std::_Unchecked<int *>
PUBLIC	??$_Dist_type@PAH@std@@YAPAHPAH@Z		; std::_Dist_type<int *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$random_shuffle@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$random_shuffle@PAH@std@@YAXPAH0@Z PROC		; std::random_shuffle<int *>, COMDAT

; 2234 : 	{	// shuffle [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2235 : 	_DEBUG_RANGE(_First, _Last);
; 2236 : 	if (_First != _Last)

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000f	74 2f		 je	 SHORT $LN2@random_shu

; 2237 : 		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last),
; 2238 : 			_Dist_type(_First));

  00011	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Dist_type@PAH@std@@YAPAHPAH@Z ; std::_Dist_type<int *>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Random_shuffle@PAHH@std@@YAXPAH00@Z ; std::_Random_shuffle<int *,int>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@random_shu:

; 2239 : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$random_shuffle@PAH@std@@YAXPAH0@Z ENDP		; std::random_shuffle<int *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAH@std@@YAPAHPAH@Z PROC			; std::_Unchecked<int *>, COMDAT

; 266  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 267  : 	return (_Src);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 268  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unchecked@PAH@std@@YAPAHPAH@Z ENDP			; std::_Unchecked<int *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Dist_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Dist_type<int *>, COMDAT

; 849  : 	{	// return distance type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 850  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 851  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Dist_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Dist_type<int *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAHPAH@std@@YAXPAH0@Z		; std::iter_swap<int *,int *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Random_shuffle@PAHH@std@@YAXPAH00@Z
_TEXT	SEGMENT
__Rn$220677 = -24					; size = 4
__Rm$220676 = -20					; size = 4
__Index$220672 = -16					; size = 4
__Next$ = -12						; size = 4
__RANDOM_MAX$ = -8					; size = 4
__RANDOM_BITS$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Random_shuffle@PAHH@std@@YAXPAH00@Z PROC		; std::_Random_shuffle<int *,int>, COMDAT

; 2214 : 	{	// shuffle [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2215 : 	const int _RANDOM_BITS = 15;	// minimum random bits from rand()

  00009	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __RANDOM_BITS$[ebp], 15 ; 0000000fH

; 2216 : 	const int _RANDOM_MAX = (1U << _RANDOM_BITS) - 1;

  00010	c7 45 f8 ff 7f
	00 00		 mov	 DWORD PTR __RANDOM_MAX$[ebp], 32767 ; 00007fffH

; 2217 : 
; 2218 : 	_RanIt _Next = _First;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR __Next$[ebp], eax

; 2219 : 	for (unsigned long _Index = 2; ++_Next != _Last; ++_Index)

  0001d	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR __Index$220672[ebp], 2
  00024	eb 09		 jmp	 SHORT $LN6@Random_shu
$LN5@Random_shu:
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Index$220672[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f0	 mov	 DWORD PTR __Index$220672[ebp], eax
$LN6@Random_shu:
  0002f	8b 45 f4	 mov	 eax, DWORD PTR __Next$[ebp]
  00032	83 c0 04	 add	 eax, 4
  00035	89 45 f4	 mov	 DWORD PTR __Next$[ebp], eax
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __Next$[ebp]
  0003b	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0003e	74 66		 je	 SHORT $LN7@Random_shu

; 2220 : 		{	// assume unsigned long big enough for _Diff count
; 2221 : 		unsigned long _Rm = _RANDOM_MAX;

  00040	c7 45 ec ff 7f
	00 00		 mov	 DWORD PTR __Rm$220676[ebp], 32767 ; 00007fffH

; 2222 : 		unsigned long _Rn = _CSTD rand() & _RANDOM_MAX;

  00047	e8 00 00 00 00	 call	 _rand
  0004c	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00051	89 45 e8	 mov	 DWORD PTR __Rn$220677[ebp], eax
  00054	eb 0e		 jmp	 SHORT $LN3@Random_shu
$LN2@Random_shu:

; 2223 : 		for (; _Rm < _Index && _Rm != ~0UL;
; 2224 : 			_Rm = _Rm << _RANDOM_BITS | _RANDOM_MAX)

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Rm$220676[ebp]
  00059	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0005c	0d ff 7f 00 00	 or	 eax, 32767		; 00007fffH
  00061	89 45 ec	 mov	 DWORD PTR __Rm$220676[ebp], eax
$LN3@Random_shu:
  00064	8b 45 ec	 mov	 eax, DWORD PTR __Rm$220676[ebp]
  00067	3b 45 f0	 cmp	 eax, DWORD PTR __Index$220672[ebp]
  0006a	73 1d		 jae	 SHORT $LN1@Random_shu
  0006c	83 7d ec ff	 cmp	 DWORD PTR __Rm$220676[ebp], -1
  00070	74 17		 je	 SHORT $LN1@Random_shu

; 2225 : 			_Rn = _Rn << _RANDOM_BITS
; 2226 : 				| (_CSTD rand() & _RANDOM_MAX);	// build random value

  00072	8b 75 e8	 mov	 esi, DWORD PTR __Rn$220677[ebp]
  00075	c1 e6 0f	 shl	 esi, 15			; 0000000fH
  00078	e8 00 00 00 00	 call	 _rand
  0007d	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00082	0b f0		 or	 esi, eax
  00084	89 75 e8	 mov	 DWORD PTR __Rn$220677[ebp], esi
  00087	eb cd		 jmp	 SHORT $LN2@Random_shu
$LN1@Random_shu:

; 2227 : 
; 2228 : 		_STD iter_swap(_Next, _First + _Diff(_Rn % _Index));	// swap a pair

  00089	8b 45 e8	 mov	 eax, DWORD PTR __Rn$220677[ebp]
  0008c	33 d2		 xor	 edx, edx
  0008e	f7 75 f0	 div	 DWORD PTR __Index$220672[ebp]
  00091	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00094	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00097	51		 push	 ecx
  00098	8b 55 f4	 mov	 edx, DWORD PTR __Next$[ebp]
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 ??$iter_swap@PAHPAH@std@@YAXPAH0@Z ; std::iter_swap<int *,int *>
  000a1	83 c4 08	 add	 esp, 8

; 2229 : 		}

  000a4	eb 80		 jmp	 SHORT $LN5@Random_shu
$LN7@Random_shu:

; 2230 : 	}

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$_Random_shuffle@PAHH@std@@YAXPAH00@Z ENDP		; std::_Random_shuffle<int *,int>
_TEXT	ENDS
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$iter_swap@PAHPAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAHPAH@std@@YAXPAH0@Z PROC			; std::iter_swap<int *,int *>, COMDAT

; 2133 : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2134 : 	swap(*_Left, *_Right);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$swap@H@std@@YAXAAH0@Z ; std::swap<int>
  00016	83 c4 08	 add	 esp, 8

; 2135 : 	}

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$iter_swap@PAHPAH@std@@YAXPAH0@Z ENDP			; std::iter_swap<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Move@AAH@std@@YA$$QAHAAH@Z			; std::_Move<int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	89 11		 mov	 DWORD PTR [ecx], edx

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 fc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	89 11		 mov	 DWORD PTR [ecx], edx

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAH@std@@YA$$QAHAAH@Z PROC			; std::_Move<int &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::_Move<int &>
_TEXT	ENDS
END
