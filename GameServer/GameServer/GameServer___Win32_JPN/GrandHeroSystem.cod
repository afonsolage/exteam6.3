; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\GrandHeroSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXABUGRANDMIX_DATA@@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::push_back
PUBLIC	??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?clear@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::clear
PUBLIC	??_C@_0BA@KPCJHCMJ@SocketMixEnable?$AA@		; `string'
PUBLIC	??_C@_03JNBBHALL@TPY?$AA@			; `string'
PUBLIC	??_C@_03IEAKEBPK@TPX?$AA@			; `string'
PUBLIC	??_C@_05OOGFIDHH@TPMap?$AA@			; `string'
PUBLIC	??_C@_0O@PIPGGBGE@BossDropCount?$AA@		; `string'
PUBLIC	??_C@_07LNGHNMMO@ResetTP?$AA@			; `string'
PUBLIC	??_C@_0M@PPCBFIMA@BossAncDrop?$AA@		; `string'
PUBLIC	??_C@_0BA@FBNHFGMC@ExStoneDropRate?$AA@		; `string'
PUBLIC	??_C@_08OFLEJILH@MixMoney?$AA@			; `string'
PUBLIC	??_C@_0M@FJBFOEAM@MixItemRate?$AA@		; `string'
PUBLIC	??_C@_06INIINDFI@GRItem?$AA@			; `string'
PUBLIC	??_C@_04PGIALEAI@GRTp?$AA@			; `string'
PUBLIC	??_C@_06POMJKEPM@Common?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cGrandHero@@QAEXXZ			; cGrandHero::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Ex_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Ex_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\grandherosystem.cpp
CONST	SEGMENT
??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@ DB '%d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%'
	DB	'd %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPCJHCMJ@SocketMixEnable?$AA@
CONST	SEGMENT
??_C@_0BA@KPCJHCMJ@SocketMixEnable?$AA@ DB 'SocketMixEnable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JNBBHALL@TPY?$AA@
CONST	SEGMENT
??_C@_03JNBBHALL@TPY?$AA@ DB 'TPY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEAKEBPK@TPX?$AA@
CONST	SEGMENT
??_C@_03IEAKEBPK@TPX?$AA@ DB 'TPX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OOGFIDHH@TPMap?$AA@
CONST	SEGMENT
??_C@_05OOGFIDHH@TPMap?$AA@ DB 'TPMap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PIPGGBGE@BossDropCount?$AA@
CONST	SEGMENT
??_C@_0O@PIPGGBGE@BossDropCount?$AA@ DB 'BossDropCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNGHNMMO@ResetTP?$AA@
CONST	SEGMENT
??_C@_07LNGHNMMO@ResetTP?$AA@ DB 'ResetTP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PPCBFIMA@BossAncDrop?$AA@
CONST	SEGMENT
??_C@_0M@PPCBFIMA@BossAncDrop?$AA@ DB 'BossAncDrop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FBNHFGMC@ExStoneDropRate?$AA@
CONST	SEGMENT
??_C@_0BA@FBNHFGMC@ExStoneDropRate?$AA@ DB 'ExStoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OFLEJILH@MixMoney?$AA@
CONST	SEGMENT
??_C@_08OFLEJILH@MixMoney?$AA@ DB 'MixMoney', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FJBFOEAM@MixItemRate?$AA@
CONST	SEGMENT
??_C@_0M@FJBFOEAM@MixItemRate?$AA@ DB 'MixItemRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06INIINDFI@GRItem?$AA@
CONST	SEGMENT
??_C@_06INIINDFI@GRItem?$AA@ DB 'GRItem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGIALEAI@GRTp?$AA@
CONST	SEGMENT
??_C@_04PGIALEAI@GRTp?$AA@ DB 'GRTp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06POMJKEPM@Common?$AA@
CONST	SEGMENT
??_C@_06POMJKEPM@Common?$AA@ DB 'Common', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
CONST	SEGMENT
??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@ DB '..\Data\Ex'
	DB	'Data\GrandHeroSystem.ini', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_info$221538 = -324					; size = 8
_n$221536 = -316					; size = 8
_n$221533 = -308					; size = 32
_Flag$ = -276						; size = 4
_Buff$ = -272						; size = 256
_file$ = -16						; size = 4
_i$221519 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Load@cGrandHero@@QAEXXZ PROC				; cGrandHero::Load
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 01 00
	00		 sub	 esp, 388		; 00000184H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	if(!g_ExLicense.user.GrandHero) return;

  00019	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  00020	85 c0		 test	 eax, eax
  00022	75 05		 jne	 SHORT $LN10@Load
  00024	e9 67 04 00 00	 jmp	 $LN11@Load
$LN10@Load:

; 22   : 	//CheckFile(GRANDHERO_DIR);
; 23   : 	this->Enable = GetPrivateProfileInt("Common","Enable",0,GRANDHERO_DIR);

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  0002e	6a 00		 push	 0
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	89 01		 mov	 DWORD PTR [ecx], eax

; 24   : 	this->GRTp = GetPrivateProfileInt("Common","GRTp",0,GRANDHERO_DIR);

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  0004a	6a 00		 push	 0
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_04PGIALEAI@GRTp?$AA@
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 25   : 	this->GRItem = GetPrivateProfileInt("Common","GRItem",1,GRANDHERO_DIR);

  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00067	6a 01		 push	 1
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_06INIINDFI@GRItem?$AA@
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 26   : 	this->MixItemRate = GetPrivateProfileInt("Common","MixItemRate",100,GRANDHERO_DIR);

  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00084	6a 64		 push	 100			; 00000064H
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJBFOEAM@MixItemRate?$AA@
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 27   : 	this->MixMoney = GetPrivateProfileInt("Common","MixMoney",0,GRANDHERO_DIR);

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  000a1	6a 00		 push	 0
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_08OFLEJILH@MixMoney?$AA@
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 28   : 	this->ExStoneDropRate = GetPrivateProfileInt("Common","ExStoneDropRate",0,GRANDHERO_DIR);

  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  000be	6a 00		 push	 0
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FBNHFGMC@ExStoneDropRate?$AA@
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 29   : 	//this->OffTradeLoren = GetPrivateProfileInt("Common","OffTradeLoren",1,GRANDHERO_DIR);
; 30   : 	this->BossAncDrop = GetPrivateProfileInt("Common","BossAncDrop",10000,GRANDHERO_DIR);

  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  000db	68 10 27 00 00	 push	 10000			; 00002710H
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PPCBFIMA@BossAncDrop?$AA@
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 31   : 
; 32   : 	
; 33   : 
; 34   : 	this->ResetTP = GetPrivateProfileInt("Common","ResetTP",0,GRANDHERO_DIR);

  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  000fb	6a 00		 push	 0
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_07LNGHNMMO@ResetTP?$AA@
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 35   : 
; 36   : 	this->BossDropCount = GetPrivateProfileInt("Common","BossDropCount",1,GRANDHERO_DIR);

  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00118	6a 01		 push	 1
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PIPGGBGE@BossDropCount?$AA@
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 37   : 
; 38   : 	this->TPMap = GetPrivateProfileInt("Common","TPMap",81,GRANDHERO_DIR);

  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00135	6a 51		 push	 81			; 00000051H
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_05OOGFIDHH@TPMap?$AA@
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 39   : 	this->TPX = GetPrivateProfileInt("Common","TPX",165,GRANDHERO_DIR);

  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00152	68 a5 00 00 00	 push	 165			; 000000a5H
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_03IEAKEBPK@TPX?$AA@
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 40   : 	this->TPY = GetPrivateProfileInt("Common","TPY",15,GRANDHERO_DIR);

  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00172	6a 0f		 push	 15			; 0000000fH
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_03JNBBHALL@TPY?$AA@
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00184	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 41   : 
; 42   : 	this->m_SocketMixEnable = GetPrivateProfileInt("Common","SocketMixEnable",1,GRANDHERO_DIR);

  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  0018f	6a 01		 push	 1
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KPCJHCMJ@SocketMixEnable?$AA@
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 43   : 
; 44   : 	for (int i=0; i < 100; i++)

  001a7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$221519[ebp], 0
  001ae	eb 09		 jmp	 SHORT $LN9@Load
$LN8@Load:
  001b0	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  001b3	83 c0 01	 add	 eax, 1
  001b6	89 45 f4	 mov	 DWORD PTR _i$221519[ebp], eax
$LN9@Load:
  001b9	83 7d f4 64	 cmp	 DWORD PTR _i$221519[ebp], 100 ; 00000064H
  001bd	0f 8d 85 00 00
	00		 jge	 $LN7@Load

; 45   : 	{
; 46   : 		Items[i].Index		= 0;

  001c3	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  001c6	c1 e0 04	 shl	 eax, 4
  001c9	33 c9		 xor	 ecx, ecx
  001cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001ce	66 89 4c 02 38	 mov	 WORD PTR [edx+eax+56], cx

; 47   : 		Items[i].ItemID		= 0;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  001d6	c1 e0 04	 shl	 eax, 4
  001d9	33 c9		 xor	 ecx, ecx
  001db	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001de	66 89 4c 02 3a	 mov	 WORD PTR [edx+eax+58], cx

; 48   : 		Items[i].Level		= 0;

  001e3	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  001e6	c1 e0 04	 shl	 eax, 4
  001e9	33 c9		 xor	 ecx, ecx
  001eb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001ee	66 89 4c 02 3c	 mov	 WORD PTR [edx+eax+60], cx

; 49   : 		Items[i].Skill		= 0;

  001f3	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  001f6	c1 e0 04	 shl	 eax, 4
  001f9	33 c9		 xor	 ecx, ecx
  001fb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001fe	66 89 4c 02 3e	 mov	 WORD PTR [edx+eax+62], cx

; 50   : 		Items[i].Luck		= 0;

  00203	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  00206	c1 e0 04	 shl	 eax, 4
  00209	33 c9		 xor	 ecx, ecx
  0020b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0020e	66 89 4c 02 40	 mov	 WORD PTR [edx+eax+64], cx

; 51   : 		Items[i].Options	= 0;

  00213	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  00216	c1 e0 04	 shl	 eax, 4
  00219	33 c9		 xor	 ecx, ecx
  0021b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0021e	66 89 4c 02 42	 mov	 WORD PTR [edx+eax+66], cx

; 52   : 		Items[i].Exl		= 0;

  00223	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  00226	c1 e0 04	 shl	 eax, 4
  00229	33 c9		 xor	 ecx, ecx
  0022b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0022e	66 89 4c 02 44	 mov	 WORD PTR [edx+eax+68], cx

; 53   : 		Items[i].Anc		= 0;

  00233	8b 45 f4	 mov	 eax, DWORD PTR _i$221519[ebp]
  00236	c1 e0 04	 shl	 eax, 4
  00239	33 c9		 xor	 ecx, ecx
  0023b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0023e	66 89 4c 02 46	 mov	 WORD PTR [edx+eax+70], cx

; 54   : 	}

  00243	e9 68 ff ff ff	 jmp	 $LN8@Load
$LN7@Load:

; 55   : 
; 56   : 	this->m_MixData.clear();

  00248	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024b	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  00251	e8 00 00 00 00	 call	 ?clear@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::clear

; 57   : 
; 58   : 	FILE * file = fopen(GRANDHERO_DIR,"r");

  00256	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ILALPHKP@?4?4?2Data?2ExData?2GrandHeroSystem?4i@
  00260	e8 00 00 00 00	 call	 _fopen
  00265	83 c4 08	 add	 esp, 8
  00268	89 45 f0	 mov	 DWORD PTR _file$[ebp], eax

; 59   : 
; 60   : 	if (file == NULL)

  0026b	83 7d f0 00	 cmp	 DWORD PTR _file$[ebp], 0
  0026f	75 0e		 jne	 SHORT $LN6@Load

; 61   : 	{
; 62   : 		this->Enable = 0;

  00271	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00274	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 63   : 		return;

  0027a	e9 11 02 00 00	 jmp	 $LN11@Load
$LN6@Load:

; 64   : 	}
; 65   : 
; 66   : 	char Buff[256];
; 67   : 	int Flag = 0;

  0027f	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _Flag$[ebp], 0

; 68   : 	this->ItemCoint = 0;

  00289	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0028c	c7 80 78 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1656], 0
$LN5@Load:

; 69   : 
; 70   : 	while (!feof(file))

  00296	8b 45 f0	 mov	 eax, DWORD PTR _file$[ebp]
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 _feof
  0029f	83 c4 04	 add	 esp, 4
  002a2	85 c0		 test	 eax, eax
  002a4	0f 85 da 01 00
	00		 jne	 $LN4@Load

; 71   : 	{
; 72   : 		fgets(Buff,256,file);

  002aa	8b 45 f0	 mov	 eax, DWORD PTR _file$[ebp]
  002ad	50		 push	 eax
  002ae	68 00 01 00 00	 push	 256			; 00000100H
  002b3	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  002b9	51		 push	 ecx
  002ba	e8 00 00 00 00	 call	 _fgets
  002bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   : 
; 74   : 		if(Ex_IsBadFileLine(Buff, Flag))

  002c2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _Flag$[ebp]
  002c8	50		 push	 eax
  002c9	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  002cf	51		 push	 ecx
  002d0	e8 00 00 00 00	 call	 ?Ex_IsBadFileLine@@YA_NPADAAH@Z ; Ex_IsBadFileLine
  002d5	83 c4 08	 add	 esp, 8
  002d8	0f b6 d0	 movzx	 edx, al
  002db	85 d2		 test	 edx, edx
  002dd	74 02		 je	 SHORT $LN3@Load

; 75   : 			continue;

  002df	eb b5		 jmp	 SHORT $LN5@Load
$LN3@Load:

; 76   : 
; 77   : 		if (Flag == 1)

  002e1	83 bd ec fe ff
	ff 01		 cmp	 DWORD PTR _Flag$[ebp], 1
  002e8	0f 85 39 01 00
	00		 jne	 $LN2@Load

; 78   : 		{
; 79   : 			int n[8];
; 80   : 
; 81   : 			sscanf(Buff,"%d %d %d %d %d %d %d %d", &n[0], &n[1], &n[2], &n[3], &n[4], &n[5], &n[6], &n[7]);

  002ee	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _n$221533[ebp+28]
  002f4	50		 push	 eax
  002f5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$221533[ebp+24]
  002fb	51		 push	 ecx
  002fc	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _n$221533[ebp+20]
  00302	52		 push	 edx
  00303	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _n$221533[ebp+16]
  00309	50		 push	 eax
  0030a	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$221533[ebp+12]
  00310	51		 push	 ecx
  00311	8d 95 d4 fe ff
	ff		 lea	 edx, DWORD PTR _n$221533[ebp+8]
  00317	52		 push	 edx
  00318	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _n$221533[ebp+4]
  0031e	50		 push	 eax
  0031f	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _n$221533[ebp]
  00325	51		 push	 ecx
  00326	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0032b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00331	52		 push	 edx
  00332	e8 00 00 00 00	 call	 _sscanf
  00337	83 c4 28	 add	 esp, 40			; 00000028H

; 82   : 
; 83   : 			Items[this->ItemCoint].Index	= n[0];

  0033a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0033d	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  00343	c1 e1 04	 shl	 ecx, 4
  00346	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00349	66 8b 85 cc fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp]
  00350	66 89 44 0a 38	 mov	 WORD PTR [edx+ecx+56], ax

; 84   : 			Items[this->ItemCoint].ItemID	= n[1];

  00355	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00358	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  0035e	c1 e1 04	 shl	 ecx, 4
  00361	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00364	66 8b 85 d0 fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+4]
  0036b	66 89 44 0a 3a	 mov	 WORD PTR [edx+ecx+58], ax

; 85   : 			Items[this->ItemCoint].Level	= n[2];

  00370	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00373	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  00379	c1 e1 04	 shl	 ecx, 4
  0037c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0037f	66 8b 85 d4 fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+8]
  00386	66 89 44 0a 3c	 mov	 WORD PTR [edx+ecx+60], ax

; 86   : 			Items[this->ItemCoint].Skill	= n[3];

  0038b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0038e	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  00394	c1 e1 04	 shl	 ecx, 4
  00397	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0039a	66 8b 85 d8 fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+12]
  003a1	66 89 44 0a 3e	 mov	 WORD PTR [edx+ecx+62], ax

; 87   : 			Items[this->ItemCoint].Luck		= n[4];

  003a6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003a9	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  003af	c1 e1 04	 shl	 ecx, 4
  003b2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003b5	66 8b 85 dc fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+16]
  003bc	66 89 44 0a 40	 mov	 WORD PTR [edx+ecx+64], ax

; 88   : 			Items[this->ItemCoint].Options	= n[5];

  003c1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c4	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  003ca	c1 e1 04	 shl	 ecx, 4
  003cd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003d0	66 8b 85 e0 fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+20]
  003d7	66 89 44 0a 42	 mov	 WORD PTR [edx+ecx+66], ax

; 89   : 			Items[this->ItemCoint].Exl		= n[6];

  003dc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003df	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  003e5	c1 e1 04	 shl	 ecx, 4
  003e8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003eb	66 8b 85 e4 fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+24]
  003f2	66 89 44 0a 44	 mov	 WORD PTR [edx+ecx+68], ax

; 90   : 			Items[this->ItemCoint].Anc		= n[7];

  003f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003fa	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  00400	c1 e1 04	 shl	 ecx, 4
  00403	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00406	66 8b 85 e8 fe
	ff ff		 mov	 ax, WORD PTR _n$221533[ebp+28]
  0040d	66 89 44 0a 46	 mov	 WORD PTR [edx+ecx+70], ax

; 91   : 
; 92   : 			this->ItemCoint++;

  00412	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00415	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  0041b	83 c1 01	 add	 ecx, 1
  0041e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00421	89 8a 78 06 00
	00		 mov	 DWORD PTR [edx+1656], ecx
$LN2@Load:

; 93   : 		}
; 94   : 
; 95   : 		if (Flag == 2)

  00427	83 bd ec fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  0042e	75 4f		 jne	 SHORT $LN1@Load

; 96   : 		{
; 97   : 			int n[2];
; 98   : 			sscanf(Buff,"%d %d",  &n[0], &n[1]);

  00430	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _n$221536[ebp+4]
  00436	50		 push	 eax
  00437	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$221536[ebp]
  0043d	51		 push	 ecx
  0043e	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  00443	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00449	52		 push	 edx
  0044a	e8 00 00 00 00	 call	 _sscanf
  0044f	83 c4 10	 add	 esp, 16			; 00000010H

; 99   : 			GRANDMIX_DATA info;
; 100  : 			info.iType = n[0];

  00452	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _n$221536[ebp]
  00458	89 85 bc fe ff
	ff		 mov	 DWORD PTR _info$221538[ebp], eax

; 101  : 			info.iIndex = n[1];

  0045e	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _n$221536[ebp+4]
  00464	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _info$221538[ebp+4], eax

; 102  : 			this->m_MixData.push_back(info);

  0046a	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _info$221538[ebp]
  00470	50		 push	 eax
  00471	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00474	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  0047a	e8 00 00 00 00	 call	 ?push_back@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXABUGRANDMIX_DATA@@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::push_back
$LN1@Load:

; 103  : 		}
; 104  : 	}

  0047f	e9 12 fe ff ff	 jmp	 $LN5@Load
$LN4@Load:

; 105  : 
; 106  : 	fclose(file);

  00484	8b 45 f0	 mov	 eax, DWORD PTR _file$[ebp]
  00487	50		 push	 eax
  00488	e8 00 00 00 00	 call	 _fclose
  0048d	83 c4 04	 add	 esp, 4
$LN11@Load:

; 107  : }

  00490	5f		 pop	 edi
  00491	5e		 pop	 esi
  00492	5b		 pop	 ebx
  00493	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00496	33 cd		 xor	 ecx, ebp
  00498	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0049d	8b e5		 mov	 esp, ebp
  0049f	5d		 pop	 ebp
  004a0	c3		 ret	 0
?Load@cGrandHero@@QAEXXZ ENDP				; cGrandHero::Load
_TEXT	ENDS
PUBLIC	?NPCLoad@cGrandHero@@QAEXHH@Z			; cGrandHero::NPCLoad
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_MonsterClass$ = 12					; size = 4
?NPCLoad@cGrandHero@@QAEXHH@Z PROC			; cGrandHero::NPCLoad
; _this$ = ecx

; 110  : {

  004b0	55		 push	 ebp
  004b1	8b ec		 mov	 ebp, esp
  004b3	83 ec 48	 sub	 esp, 72			; 00000048H
  004b6	53		 push	 ebx
  004b7	56		 push	 esi
  004b8	57		 push	 edi
  004b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 	if(!g_ExLicense.user.GrandHero) return;

  004bc	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  004c3	85 c0		 test	 eax, eax
  004c5	75 02		 jne	 SHORT $LN3@NPCLoad
  004c7	eb 31		 jmp	 SHORT $LN4@NPCLoad
$LN3@NPCLoad:

; 112  : 	if(!this->Enable)return;

  004c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  004cf	75 02		 jne	 SHORT $LN2@NPCLoad
  004d1	eb 27		 jmp	 SHORT $LN4@NPCLoad
$LN2@NPCLoad:

; 113  : 
; 114  :  	LPOBJ lpObj = &gObj[aIndex];

  004d3	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004d6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  004dc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004e2	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 115  : 
; 116  : 	if(/*MonsterClass == 520 ||*/ MonsterClass == 586)

  004e5	81 7d 0c 4a 02
	00 00		 cmp	 DWORD PTR _MonsterClass$[ebp], 586 ; 0000024aH
  004ec	75 0c		 jne	 SHORT $LN4@NPCLoad

; 117  : 	{
; 118  : 		lpObj->Type = OBJ_NPC;

  004ee	b8 03 00 00 00	 mov	 eax, 3
  004f3	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004f6	66 89 41 68	 mov	 WORD PTR [ecx+104], ax
$LN4@NPCLoad:

; 119  : 	}
; 120  : }

  004fa	5f		 pop	 edi
  004fb	5e		 pop	 esi
  004fc	5b		 pop	 ebx
  004fd	8b e5		 mov	 esp, ebp
  004ff	5d		 pop	 ebp
  00500	c2 08 00	 ret	 8
?NPCLoad@cGrandHero@@QAEXHH@Z ENDP			; cGrandHero::NPCLoad
_TEXT	ENDS
PUBLIC	??_C@_0BB@IBKAIPHM@Need?5Grand?5Reset?$AA@	; `string'
PUBLIC	??_C@_0O@JHDAALMN@Need?5?$CFd?5Reset?$AA@	; `string'
PUBLIC	??_C@_0O@BLCJAAEN@Need?5?$CFd?5Level?$AA@	; `string'
PUBLIC	?NPCTeleport@cGrandHero@@QAE_NPAUOBJECTSTRUCT@@0@Z ; cGrandHero::NPCTeleport
EXTRN	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z:PROC ; ChatTargetSend
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
;	COMDAT ??_C@_0BB@IBKAIPHM@Need?5Grand?5Reset?$AA@
CONST	SEGMENT
??_C@_0BB@IBKAIPHM@Need?5Grand?5Reset?$AA@ DB 'Need Grand Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JHDAALMN@Need?5?$CFd?5Reset?$AA@
CONST	SEGMENT
??_C@_0O@JHDAALMN@Need?5?$CFd?5Reset?$AA@ DB 'Need %d Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BLCJAAEN@Need?5?$CFd?5Level?$AA@
CONST	SEGMENT
??_C@_0O@BLCJAAEN@Need?5?$CFd?5Level?$AA@ DB 'Need %d Level', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?NPCTeleport@cGrandHero@@QAE_NPAUOBJECTSTRUCT@@0@Z PROC	; cGrandHero::NPCTeleport
; _this$ = ecx

; 123  : {

  00510	55		 push	 ebp
  00511	8b ec		 mov	 ebp, esp
  00513	83 ec 44	 sub	 esp, 68			; 00000044H
  00516	53		 push	 ebx
  00517	56		 push	 esi
  00518	57		 push	 edi
  00519	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 	if(!g_ExLicense.user.GrandHero) return false;

  0051c	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  00523	85 c0		 test	 eax, eax
  00525	75 07		 jne	 SHORT $LN13@NPCTelepor
  00527	32 c0		 xor	 al, al
  00529	e9 60 01 00 00	 jmp	 $LN14@NPCTelepor
$LN13@NPCTelepor:

; 125  : 	if(!this->Enable) return false;

  0052e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00531	83 38 00	 cmp	 DWORD PTR [eax], 0
  00534	75 0c		 jne	 SHORT $LN12@NPCTelepor
  00536	32 c0		 xor	 al, al
  00538	e9 51 01 00 00	 jmp	 $LN14@NPCTelepor
  0053d	e9 4a 01 00 00	 jmp	 $LN11@NPCTelepor
$LN12@NPCTelepor:

; 126  : 
; 127  : 	/*if(lpNpc->Class == 520)
; 128  : 	{
; 129  : 		if(lpObj->MapNumber == 79)
; 130  : 		{
; 131  : 			gObjTeleport(lpObj->m_Index,0,146,136);
; 132  : 		}
; 133  : 		else
; 134  : 		{
; 135  : 			gObjTeleport(lpObj->m_Index,79,116,127);
; 136  : 		}
; 137  : 		return true;
; 138  : 	}*/
; 139  : 	else if(lpNpc->Class == 586)

  00542	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  00545	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0054c	81 f9 4a 02 00
	00		 cmp	 ecx, 586		; 0000024aH
  00552	0f 85 34 01 00
	00		 jne	 $LN11@NPCTelepor

; 140  : 	{
; 141  : 		if(lpObj->GReset >= this->GRTp && lpObj->Reset >= this->ResetTP )

  00558	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0055e	8b 90 94 22 00
	00		 mov	 edx, DWORD PTR [eax+8852]
  00564	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00567	0f 8c d7 00 00
	00		 jl	 $LN9@NPCTelepor
  0056d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00570	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00573	8b 90 90 22 00
	00		 mov	 edx, DWORD PTR [eax+8848]
  00579	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  0057c	0f 8c c2 00 00
	00		 jl	 $LN9@NPCTelepor

; 142  : 		{
; 143  : 			if(g_ExLicense.CheckUser(eExUB::PrideMuLocal) || g_ExLicense.CheckUser(eExUB::PrideMu) || g_ExLicense.CheckUser(eExUB::Local3) || g_ExLicense.CheckUser(eExUB::Local))

  00582	6a 1a		 push	 26			; 0000001aH
  00584	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00589	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0058e	0f b6 c0	 movzx	 eax, al
  00591	85 c0		 test	 eax, eax
  00593	75 39		 jne	 SHORT $LN7@NPCTelepor
  00595	6a 11		 push	 17			; 00000011H
  00597	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0059c	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  005a1	0f b6 c0	 movzx	 eax, al
  005a4	85 c0		 test	 eax, eax
  005a6	75 26		 jne	 SHORT $LN7@NPCTelepor
  005a8	6a 1c		 push	 28			; 0000001cH
  005aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  005af	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  005b4	0f b6 c0	 movzx	 eax, al
  005b7	85 c0		 test	 eax, eax
  005b9	75 13		 jne	 SHORT $LN7@NPCTelepor
  005bb	6a 00		 push	 0
  005bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  005c2	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  005c7	0f b6 c0	 movzx	 eax, al
  005ca	85 c0		 test	 eax, eax
  005cc	74 51		 je	 SHORT $LN8@NPCTelepor
$LN7@NPCTelepor:

; 144  : 			{
; 145  : 				if (lpObj->Level < 300)

  005ce	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d1	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  005d8	81 f9 2c 01 00
	00		 cmp	 ecx, 300		; 0000012cH
  005de	7d 1a		 jge	 SHORT $LN6@NPCTelepor

; 146  : 				{
; 147  : 					MsgOutput(lpObj->m_Index,"Need %d Level",300);

  005e0	68 2c 01 00 00	 push	 300			; 0000012cH
  005e5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BLCJAAEN@Need?5?$CFd?5Level?$AA@
  005ea	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ef	51		 push	 ecx
  005f0	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  005f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 148  : 				}
; 149  : 				else

  005f8	eb 23		 jmp	 SHORT $LN5@NPCTelepor
$LN6@NPCTelepor:

; 150  : 				{
; 151  : 					gObjTeleport(lpObj->m_Index,this->TPMap,this->TPX,this->TPY);

  005fa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005fd	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00600	51		 push	 ecx
  00601	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00604	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00607	50		 push	 eax
  00608	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0060b	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0060e	52		 push	 edx
  0060f	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00612	8b 08		 mov	 ecx, DWORD PTR [eax]
  00614	51		 push	 ecx
  00615	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  0061a	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@NPCTelepor:

; 152  : 				}
; 153  : 
; 154  : 			}
; 155  : 			else

  0061d	eb 23		 jmp	 SHORT $LN4@NPCTelepor
$LN8@NPCTelepor:

; 156  : 			{
; 157  : 				gObjTeleport(lpObj->m_Index,this->TPMap,this->TPX,this->TPY);

  0061f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00622	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00625	51		 push	 ecx
  00626	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00629	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0062c	50		 push	 eax
  0062d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00630	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00633	52		 push	 edx
  00634	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00637	8b 08		 mov	 ecx, DWORD PTR [eax]
  00639	51		 push	 ecx
  0063a	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  0063f	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@NPCTelepor:

; 158  : 			}
; 159  : 		}
; 160  : 		else

  00642	eb 44		 jmp	 SHORT $LN3@NPCTelepor
$LN9@NPCTelepor:

; 161  : 		{
; 162  : 			if(this->ResetTP > lpObj->Reset)

  00644	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00647	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0064a	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0064d	3b 91 90 22 00
	00		 cmp	 edx, DWORD PTR [ecx+8848]
  00653	7e 1c		 jle	 SHORT $LN2@NPCTelepor

; 163  : 			{
; 164  : 				MsgOutput(lpObj->m_Index,"Need %d Reset",this->ResetTP);

  00655	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00658	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0065b	51		 push	 ecx
  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JHDAALMN@Need?5?$CFd?5Reset?$AA@
  00661	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00664	8b 02		 mov	 eax, DWORD PTR [edx]
  00666	50		 push	 eax
  00667	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0066c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 			}
; 166  : 			else

  0066f	eb 17		 jmp	 SHORT $LN3@NPCTelepor
$LN2@NPCTelepor:

; 167  : 			{
; 168  : 				ChatTargetSend(lpNpc, "Need Grand Reset", lpObj->m_Index);

  00671	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00674	8b 08		 mov	 ecx, DWORD PTR [eax]
  00676	51		 push	 ecx
  00677	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IBKAIPHM@Need?5Grand?5Reset?$AA@
  0067c	8b 55 08	 mov	 edx, DWORD PTR _lpNpc$[ebp]
  0067f	52		 push	 edx
  00680	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00685	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@NPCTelepor:

; 169  : 			}
; 170  : 			
; 171  : 		}
; 172  : 
; 173  : 		return true;

  00688	b0 01		 mov	 al, 1
  0068a	eb 02		 jmp	 SHORT $LN14@NPCTelepor
$LN11@NPCTelepor:

; 174  : 	}
; 175  : 	return false;

  0068c	32 c0		 xor	 al, al
$LN14@NPCTelepor:

; 176  : }

  0068e	5f		 pop	 edi
  0068f	5e		 pop	 esi
  00690	5b		 pop	 ebx
  00691	8b e5		 mov	 esp, ebp
  00693	5d		 pop	 ebp
  00694	c2 08 00	 ret	 8
?NPCTeleport@cGrandHero@@QAE_NPAUOBJECTSTRUCT@@0@Z ENDP	; cGrandHero::NPCTeleport
_TEXT	ENDS
PUBLIC	?ItemOption@cGrandHero@@QAEXH@Z			; cGrandHero::ItemOption
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?ItemOption@cGrandHero@@QAEXH@Z PROC			; cGrandHero::ItemOption
; _this$ = ecx

; 179  : {

  006a0	55		 push	 ebp
  006a1	8b ec		 mov	 ebp, esp
  006a3	83 ec 48	 sub	 esp, 72			; 00000048H
  006a6	53		 push	 ebx
  006a7	56		 push	 esi
  006a8	57		 push	 edi
  006a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 180  : 	if(!g_ExLicense.user.GrandHero) return;

  006ac	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  006b3	85 c0		 test	 eax, eax
  006b5	75 05		 jne	 SHORT $LN15@ItemOption
  006b7	e9 eb 05 00 00	 jmp	 $LN16@ItemOption
$LN15@ItemOption:

; 181  : 	LPOBJ lpObj = &gObj[aIndex];

  006bc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006bf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  006c5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006cb	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 182  : 
; 183  : 	if( lpObj->pInventory[7].m_Type >= ITEMGET(7,84) && lpObj->pInventory[7].m_Type <= ITEMGET(7,90) )

  006ce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006d1	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  006d7	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  006de	81 fa 54 0e 00
	00		 cmp	 edx, 3668		; 00000e54H
  006e4	0f 8c af 00 00
	00		 jl	 $LN14@ItemOption
  006ea	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ed	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  006f3	0f bf 91 d2 05
	00 00		 movsx	 edx, WORD PTR [ecx+1490]
  006fa	81 fa 5a 0e 00
	00		 cmp	 edx, 3674		; 00000e5aH
  00700	0f 8f 93 00 00
	00		 jg	 $LN14@ItemOption

; 184  : 	{
; 185  : 		lpObj->m_Defense += 30;

  00706	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00709	8b 88 94 04 00
	00		 mov	 ecx, DWORD PTR [eax+1172]
  0070f	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00712	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00715	89 8a 94 04 00
	00		 mov	 DWORD PTR [edx+1172], ecx

; 186  : 
; 187  : 		lpObj->m_AttackDamageMaxLeft +=  30;

  0071b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071e	8b 88 78 04 00
	00		 mov	 ecx, DWORD PTR [eax+1144]
  00724	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00727	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0072a	89 8a 78 04 00
	00		 mov	 DWORD PTR [edx+1144], ecx

; 188  : 		lpObj->m_AttackDamageMinLeft +=  30;

  00730	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00733	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  00739	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0073c	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0073f	89 8a 7c 04 00
	00		 mov	 DWORD PTR [edx+1148], ecx

; 189  : 		lpObj->m_AttackDamageMaxRight += 30;

  00745	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00748	8b 88 80 04 00
	00		 mov	 ecx, DWORD PTR [eax+1152]
  0074e	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00751	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00754	89 8a 80 04 00
	00		 mov	 DWORD PTR [edx+1152], ecx

; 190  : 		lpObj->m_AttackDamageMinRight += 30;

  0075a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0075d	8b 88 84 04 00
	00		 mov	 ecx, DWORD PTR [eax+1156]
  00763	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00766	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00769	89 8a 84 04 00
	00		 mov	 DWORD PTR [edx+1156], ecx

; 191  : 		lpObj->m_MagicDamageMax += 30;

  0076f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00772	8b 88 6c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1132]
  00778	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0077b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0077e	89 8a 6c 04 00
	00		 mov	 DWORD PTR [edx+1132], ecx

; 192  : 		lpObj->m_MagicDamageMin += 30;

  00784	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00787	8b 88 68 04 00
	00		 mov	 ecx, DWORD PTR [eax+1128]
  0078d	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00790	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00793	89 8a 68 04 00
	00		 mov	 DWORD PTR [edx+1128], ecx
$LN14@ItemOption:

; 193  : 	}
; 194  : 	if( lpObj->pInventory[8].m_Type >= ITEMGET(8,84) && lpObj->pInventory[8].m_Type <= ITEMGET(8,90) )

  00799	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0079c	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  007a2	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  007a9	81 fa 54 10 00
	00		 cmp	 edx, 4180		; 00001054H
  007af	0f 8c af 00 00
	00		 jl	 $LN13@ItemOption
  007b5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b8	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  007be	0f bf 91 a6 06
	00 00		 movsx	 edx, WORD PTR [ecx+1702]
  007c5	81 fa 5a 10 00
	00		 cmp	 edx, 4186		; 0000105aH
  007cb	0f 8f 93 00 00
	00		 jg	 $LN13@ItemOption

; 195  : 	{
; 196  : 		lpObj->m_Defense += 30;

  007d1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d4	8b 88 94 04 00
	00		 mov	 ecx, DWORD PTR [eax+1172]
  007da	83 c1 1e	 add	 ecx, 30			; 0000001eH
  007dd	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007e0	89 8a 94 04 00
	00		 mov	 DWORD PTR [edx+1172], ecx

; 197  : 
; 198  : 		lpObj->m_AttackDamageMaxLeft +=  30;

  007e6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e9	8b 88 78 04 00
	00		 mov	 ecx, DWORD PTR [eax+1144]
  007ef	83 c1 1e	 add	 ecx, 30			; 0000001eH
  007f2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007f5	89 8a 78 04 00
	00		 mov	 DWORD PTR [edx+1144], ecx

; 199  : 		lpObj->m_AttackDamageMinLeft +=  30;

  007fb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007fe	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  00804	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00807	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0080a	89 8a 7c 04 00
	00		 mov	 DWORD PTR [edx+1148], ecx

; 200  : 		lpObj->m_AttackDamageMaxRight += 30;

  00810	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00813	8b 88 80 04 00
	00		 mov	 ecx, DWORD PTR [eax+1152]
  00819	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0081c	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0081f	89 8a 80 04 00
	00		 mov	 DWORD PTR [edx+1152], ecx

; 201  : 		lpObj->m_AttackDamageMinRight += 30;

  00825	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00828	8b 88 84 04 00
	00		 mov	 ecx, DWORD PTR [eax+1156]
  0082e	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00831	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00834	89 8a 84 04 00
	00		 mov	 DWORD PTR [edx+1156], ecx

; 202  : 		lpObj->m_MagicDamageMax += 30;

  0083a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0083d	8b 88 6c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1132]
  00843	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00846	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00849	89 8a 6c 04 00
	00		 mov	 DWORD PTR [edx+1132], ecx

; 203  : 		lpObj->m_MagicDamageMin += 30;

  0084f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00852	8b 88 68 04 00
	00		 mov	 ecx, DWORD PTR [eax+1128]
  00858	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0085b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0085e	89 8a 68 04 00
	00		 mov	 DWORD PTR [edx+1128], ecx
$LN13@ItemOption:

; 204  : 	}
; 205  : 	if( lpObj->pInventory[9].m_Type >= ITEMGET(9,84) && lpObj->pInventory[9].m_Type <= ITEMGET(9,90) )

  00864	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00867	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0086d	0f bf 91 7a 07
	00 00		 movsx	 edx, WORD PTR [ecx+1914]
  00874	81 fa 54 12 00
	00		 cmp	 edx, 4692		; 00001254H
  0087a	0f 8c af 00 00
	00		 jl	 $LN12@ItemOption
  00880	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00883	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00889	0f bf 91 7a 07
	00 00		 movsx	 edx, WORD PTR [ecx+1914]
  00890	81 fa 5a 12 00
	00		 cmp	 edx, 4698		; 0000125aH
  00896	0f 8f 93 00 00
	00		 jg	 $LN12@ItemOption

; 206  : 	{
; 207  : 		lpObj->m_Defense += 30;

  0089c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0089f	8b 88 94 04 00
	00		 mov	 ecx, DWORD PTR [eax+1172]
  008a5	83 c1 1e	 add	 ecx, 30			; 0000001eH
  008a8	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008ab	89 8a 94 04 00
	00		 mov	 DWORD PTR [edx+1172], ecx

; 208  : 
; 209  : 		lpObj->m_AttackDamageMaxLeft +=  30;

  008b1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008b4	8b 88 78 04 00
	00		 mov	 ecx, DWORD PTR [eax+1144]
  008ba	83 c1 1e	 add	 ecx, 30			; 0000001eH
  008bd	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008c0	89 8a 78 04 00
	00		 mov	 DWORD PTR [edx+1144], ecx

; 210  : 		lpObj->m_AttackDamageMinLeft +=  30;

  008c6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008c9	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  008cf	83 c1 1e	 add	 ecx, 30			; 0000001eH
  008d2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008d5	89 8a 7c 04 00
	00		 mov	 DWORD PTR [edx+1148], ecx

; 211  : 		lpObj->m_AttackDamageMaxRight += 30;

  008db	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008de	8b 88 80 04 00
	00		 mov	 ecx, DWORD PTR [eax+1152]
  008e4	83 c1 1e	 add	 ecx, 30			; 0000001eH
  008e7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008ea	89 8a 80 04 00
	00		 mov	 DWORD PTR [edx+1152], ecx

; 212  : 		lpObj->m_AttackDamageMinRight += 30;

  008f0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008f3	8b 88 84 04 00
	00		 mov	 ecx, DWORD PTR [eax+1156]
  008f9	83 c1 1e	 add	 ecx, 30			; 0000001eH
  008fc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008ff	89 8a 84 04 00
	00		 mov	 DWORD PTR [edx+1156], ecx

; 213  : 		lpObj->m_MagicDamageMax += 30;

  00905	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00908	8b 88 6c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1132]
  0090e	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00911	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00914	89 8a 6c 04 00
	00		 mov	 DWORD PTR [edx+1132], ecx

; 214  : 		lpObj->m_MagicDamageMin += 30;

  0091a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0091d	8b 88 68 04 00
	00		 mov	 ecx, DWORD PTR [eax+1128]
  00923	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00926	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00929	89 8a 68 04 00
	00		 mov	 DWORD PTR [edx+1128], ecx
$LN12@ItemOption:

; 215  : 	}
; 216  : 	if( lpObj->pInventory[10].m_Type >= ITEMGET(10,84) && lpObj->pInventory[10].m_Type <= ITEMGET(10,90) )

  0092f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00932	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00938	0f bf 91 4e 08
	00 00		 movsx	 edx, WORD PTR [ecx+2126]
  0093f	81 fa 54 14 00
	00		 cmp	 edx, 5204		; 00001454H
  00945	0f 8c af 00 00
	00		 jl	 $LN11@ItemOption
  0094b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0094e	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00954	0f bf 91 4e 08
	00 00		 movsx	 edx, WORD PTR [ecx+2126]
  0095b	81 fa 5a 14 00
	00		 cmp	 edx, 5210		; 0000145aH
  00961	0f 8f 93 00 00
	00		 jg	 $LN11@ItemOption

; 217  : 	{
; 218  : 		lpObj->m_Defense += 30;

  00967	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0096a	8b 88 94 04 00
	00		 mov	 ecx, DWORD PTR [eax+1172]
  00970	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00973	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00976	89 8a 94 04 00
	00		 mov	 DWORD PTR [edx+1172], ecx

; 219  : 
; 220  : 		lpObj->m_AttackDamageMaxLeft +=  30;

  0097c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0097f	8b 88 78 04 00
	00		 mov	 ecx, DWORD PTR [eax+1144]
  00985	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00988	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0098b	89 8a 78 04 00
	00		 mov	 DWORD PTR [edx+1144], ecx

; 221  : 		lpObj->m_AttackDamageMinLeft +=  30;

  00991	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00994	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  0099a	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0099d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009a0	89 8a 7c 04 00
	00		 mov	 DWORD PTR [edx+1148], ecx

; 222  : 		lpObj->m_AttackDamageMaxRight += 30;

  009a6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009a9	8b 88 80 04 00
	00		 mov	 ecx, DWORD PTR [eax+1152]
  009af	83 c1 1e	 add	 ecx, 30			; 0000001eH
  009b2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009b5	89 8a 80 04 00
	00		 mov	 DWORD PTR [edx+1152], ecx

; 223  : 		lpObj->m_AttackDamageMinRight += 30;

  009bb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009be	8b 88 84 04 00
	00		 mov	 ecx, DWORD PTR [eax+1156]
  009c4	83 c1 1e	 add	 ecx, 30			; 0000001eH
  009c7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009ca	89 8a 84 04 00
	00		 mov	 DWORD PTR [edx+1156], ecx

; 224  : 		lpObj->m_MagicDamageMax += 30;

  009d0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009d3	8b 88 6c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1132]
  009d9	83 c1 1e	 add	 ecx, 30			; 0000001eH
  009dc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009df	89 8a 6c 04 00
	00		 mov	 DWORD PTR [edx+1132], ecx

; 225  : 		lpObj->m_MagicDamageMin += 30;

  009e5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009e8	8b 88 68 04 00
	00		 mov	 ecx, DWORD PTR [eax+1128]
  009ee	83 c1 1e	 add	 ecx, 30			; 0000001eH
  009f1	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009f4	89 8a 68 04 00
	00		 mov	 DWORD PTR [edx+1128], ecx
$LN11@ItemOption:

; 226  : 	}
; 227  : 	if( lpObj->pInventory[11].m_Type >= ITEMGET(11,84) && lpObj->pInventory[11].m_Type <= ITEMGET(11,90) )

  009fa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009fd	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00a03	0f bf 91 22 09
	00 00		 movsx	 edx, WORD PTR [ecx+2338]
  00a0a	81 fa 54 16 00
	00		 cmp	 edx, 5716		; 00001654H
  00a10	0f 8c af 00 00
	00		 jl	 $LN10@ItemOption
  00a16	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a19	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00a1f	0f bf 91 22 09
	00 00		 movsx	 edx, WORD PTR [ecx+2338]
  00a26	81 fa 5a 16 00
	00		 cmp	 edx, 5722		; 0000165aH
  00a2c	0f 8f 93 00 00
	00		 jg	 $LN10@ItemOption

; 228  : 	{
; 229  : 		lpObj->m_Defense += 30;

  00a32	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a35	8b 88 94 04 00
	00		 mov	 ecx, DWORD PTR [eax+1172]
  00a3b	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00a3e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a41	89 8a 94 04 00
	00		 mov	 DWORD PTR [edx+1172], ecx

; 230  : 
; 231  : 		lpObj->m_AttackDamageMaxLeft +=  30;

  00a47	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a4a	8b 88 78 04 00
	00		 mov	 ecx, DWORD PTR [eax+1144]
  00a50	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00a53	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a56	89 8a 78 04 00
	00		 mov	 DWORD PTR [edx+1144], ecx

; 232  : 		lpObj->m_AttackDamageMinLeft +=  30;

  00a5c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a5f	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  00a65	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00a68	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a6b	89 8a 7c 04 00
	00		 mov	 DWORD PTR [edx+1148], ecx

; 233  : 		lpObj->m_AttackDamageMaxRight += 30;

  00a71	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a74	8b 88 80 04 00
	00		 mov	 ecx, DWORD PTR [eax+1152]
  00a7a	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00a7d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a80	89 8a 80 04 00
	00		 mov	 DWORD PTR [edx+1152], ecx

; 234  : 		lpObj->m_AttackDamageMinRight += 30;

  00a86	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a89	8b 88 84 04 00
	00		 mov	 ecx, DWORD PTR [eax+1156]
  00a8f	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00a92	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a95	89 8a 84 04 00
	00		 mov	 DWORD PTR [edx+1156], ecx

; 235  : 		lpObj->m_MagicDamageMax += 30;

  00a9b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a9e	8b 88 6c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1132]
  00aa4	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00aa7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00aaa	89 8a 6c 04 00
	00		 mov	 DWORD PTR [edx+1132], ecx

; 236  : 		lpObj->m_MagicDamageMin += 30;

  00ab0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ab3	8b 88 68 04 00
	00		 mov	 ecx, DWORD PTR [eax+1128]
  00ab9	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00abc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00abf	89 8a 68 04 00
	00		 mov	 DWORD PTR [edx+1128], ecx
$LN10@ItemOption:

; 237  : 	}
; 238  : 	if(g_ExLicense.CheckUser(eExUB::PrideMuLocal) || g_ExLicense.CheckUser(eExUB::PrideMu))

  00ac5	6a 1a		 push	 26			; 0000001aH
  00ac7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00acc	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00ad1	0f b6 c0	 movzx	 eax, al
  00ad4	85 c0		 test	 eax, eax
  00ad6	75 17		 jne	 SHORT $LN8@ItemOption
  00ad8	6a 11		 push	 17			; 00000011H
  00ada	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00adf	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00ae4	0f b6 c0	 movzx	 eax, al
  00ae7	85 c0		 test	 eax, eax
  00ae9	0f 84 a9 00 00
	00		 je	 $LN9@ItemOption
$LN8@ItemOption:

; 239  : 	{
; 240  : 		if( lpObj->pInventory[0].m_Type == ITEMGET(0,41) || 
; 241  : 			lpObj->pInventory[0].m_Type == ITEMGET(0,42) ||
; 242  : 			lpObj->pInventory[1].m_Type == ITEMGET(0,41) || 
; 243  : 			lpObj->pInventory[1].m_Type == ITEMGET(0,42) ||
; 244  : 			lpObj->pInventory[1].m_Type == ITEMGET(0,34) ||
; 245  : 			lpObj->pInventory[0].m_Type == ITEMGET(2,20) )

  00aef	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00af2	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00af8	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00afc	83 fa 29	 cmp	 edx, 41			; 00000029H
  00aff	74 66		 je	 SHORT $LN6@ItemOption
  00b01	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b04	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00b0a	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00b0e	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00b11	74 54		 je	 SHORT $LN6@ItemOption
  00b13	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b16	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00b1c	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  00b23	83 fa 29	 cmp	 edx, 41			; 00000029H
  00b26	74 3f		 je	 SHORT $LN6@ItemOption
  00b28	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b2b	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00b31	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  00b38	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00b3b	74 2a		 je	 SHORT $LN6@ItemOption
  00b3d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b40	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00b46	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  00b4d	83 fa 22	 cmp	 edx, 34			; 00000022H
  00b50	74 15		 je	 SHORT $LN6@ItemOption
  00b52	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b55	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00b5b	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00b5f	81 fa 14 04 00
	00		 cmp	 edx, 1044		; 00000414H
  00b65	75 2c		 jne	 SHORT $LN7@ItemOption
$LN6@ItemOption:

; 246  : 		{
; 247  : 			lpObj->SetOpDoubleDamage += 3;

  00b67	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b6a	0f b6 88 3f 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4415]
  00b71	83 c1 03	 add	 ecx, 3
  00b74	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b77	88 8a 3f 11 00
	00		 mov	 BYTE PTR [edx+4415], cl

; 248  : 			lpObj->SetOpIgnoreDefense += 3;

  00b7d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b80	0f b6 88 3e 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4414]
  00b87	83 c1 03	 add	 ecx, 3
  00b8a	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b8d	88 8a 3e 11 00
	00		 mov	 BYTE PTR [edx+4414], cl
$LN7@ItemOption:

; 249  : 		}
; 250  : 	}
; 251  : 	else

  00b93	e9 a4 00 00 00	 jmp	 $LN5@ItemOption
$LN9@ItemOption:

; 252  : 	{
; 253  : 		if( lpObj->pInventory[0].m_Type == ITEMGET(0,41) || 
; 254  : 			lpObj->pInventory[0].m_Type == ITEMGET(0,42) ||
; 255  : 			lpObj->pInventory[1].m_Type == ITEMGET(0,41) || 
; 256  : 			lpObj->pInventory[1].m_Type == ITEMGET(0,42) ||
; 257  : 			lpObj->pInventory[1].m_Type == ITEMGET(0,34) ||
; 258  : 			lpObj->pInventory[0].m_Type == ITEMGET(2,20) )

  00b98	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b9b	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00ba1	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00ba5	83 fa 29	 cmp	 edx, 41			; 00000029H
  00ba8	74 66		 je	 SHORT $LN3@ItemOption
  00baa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bad	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00bb3	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00bb7	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00bba	74 54		 je	 SHORT $LN3@ItemOption
  00bbc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bbf	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00bc5	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  00bcc	83 fa 29	 cmp	 edx, 41			; 00000029H
  00bcf	74 3f		 je	 SHORT $LN3@ItemOption
  00bd1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd4	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00bda	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  00be1	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00be4	74 2a		 je	 SHORT $LN3@ItemOption
  00be6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00be9	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00bef	0f bf 91 da 00
	00 00		 movsx	 edx, WORD PTR [ecx+218]
  00bf6	83 fa 22	 cmp	 edx, 34			; 00000022H
  00bf9	74 15		 je	 SHORT $LN3@ItemOption
  00bfb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfe	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00c04	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00c08	81 fa 14 04 00
	00		 cmp	 edx, 1044		; 00000414H
  00c0e	75 2c		 jne	 SHORT $LN5@ItemOption
$LN3@ItemOption:

; 259  : 		{
; 260  : 			lpObj->SetOpDoubleDamage += 3;

  00c10	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c13	0f b6 88 3f 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4415]
  00c1a	83 c1 03	 add	 ecx, 3
  00c1d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c20	88 8a 3f 11 00
	00		 mov	 BYTE PTR [edx+4415], cl

; 261  : 			lpObj->SetOpIgnoreDefense += 3;

  00c26	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c29	0f b6 88 3e 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4414]
  00c30	83 c1 03	 add	 ecx, 3
  00c33	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c36	88 8a 3e 11 00
	00		 mov	 BYTE PTR [edx+4414], cl
$LN5@ItemOption:

; 262  : 		}
; 263  : 	}
; 264  : 	if(	lpObj->pInventory[0].m_Type == ITEMGET(4,30) ||
; 265  : 		lpObj->pInventory[0].m_Type == ITEMGET(5,41) ||
; 266  : 		lpObj->pInventory[0].m_Type == ITEMGET(5,42) )

  00c3c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c3f	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00c45	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00c49	81 fa 1e 08 00
	00		 cmp	 edx, 2078		; 0000081eH
  00c4f	74 2a		 je	 SHORT $LN1@ItemOption
  00c51	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c54	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00c5a	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00c5e	81 fa 29 0a 00
	00		 cmp	 edx, 2601		; 00000a29H
  00c64	74 15		 je	 SHORT $LN1@ItemOption
  00c66	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c69	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00c6f	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00c73	81 fa 2a 0a 00
	00		 cmp	 edx, 2602		; 00000a2aH
  00c79	75 2c		 jne	 SHORT $LN16@ItemOption
$LN1@ItemOption:

; 267  : 	{
; 268  : 		lpObj->SetOpDoubleDamage += 6;

  00c7b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c7e	0f b6 88 3f 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4415]
  00c85	83 c1 06	 add	 ecx, 6
  00c88	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c8b	88 8a 3f 11 00
	00		 mov	 BYTE PTR [edx+4415], cl

; 269  : 		lpObj->SetOpIgnoreDefense += 6;

  00c91	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c94	0f b6 88 3e 11
	00 00		 movzx	 ecx, BYTE PTR [eax+4414]
  00c9b	83 c1 06	 add	 ecx, 6
  00c9e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ca1	88 8a 3e 11 00
	00		 mov	 BYTE PTR [edx+4414], cl
$LN16@ItemOption:

; 270  : 	}
; 271  : }

  00ca7	5f		 pop	 edi
  00ca8	5e		 pop	 esi
  00ca9	5b		 pop	 ebx
  00caa	8b e5		 mov	 esp, ebp
  00cac	5d		 pop	 ebp
  00cad	c2 04 00	 ret	 4
?ItemOption@cGrandHero@@QAEXH@Z ENDP			; cGrandHero::ItemOption
_TEXT	ENDS
PUBLIC	?SockeetItem@cGrandHero@@QAE_NH@Z		; cGrandHero::SockeetItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -72						; size = 4
_this$ = -4						; size = 4
_ItemNumber$ = 8					; size = 4
?SockeetItem@cGrandHero@@QAE_NH@Z PROC			; cGrandHero::SockeetItem
; _this$ = ecx

; 274  : {

  00cb0	55		 push	 ebp
  00cb1	8b ec		 mov	 ebp, esp
  00cb3	83 ec 48	 sub	 esp, 72			; 00000048H
  00cb6	53		 push	 ebx
  00cb7	56		 push	 esi
  00cb8	57		 push	 edi
  00cb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	if(!g_ExLicense.user.GrandHero) return false;

  00cbc	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  00cc3	85 c0		 test	 eax, eax
  00cc5	75 07		 jne	 SHORT $LN11@SockeetIte
  00cc7	32 c0		 xor	 al, al
  00cc9	e9 cb 00 00 00	 jmp	 $LN12@SockeetIte
$LN11@SockeetIte:

; 276  : 
; 277  : 	if(!this->m_SocketMixEnable)

  00cce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cd1	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00cd5	75 07		 jne	 SHORT $LN10@SockeetIte

; 278  : 	{
; 279  : 		return false;

  00cd7	32 c0		 xor	 al, al
  00cd9	e9 bb 00 00 00	 jmp	 $LN12@SockeetIte
$LN10@SockeetIte:

; 280  : 	}
; 281  : 
; 282  : 	switch(ItemNumber)

  00cde	8b 45 08	 mov	 eax, DWORD PTR _ItemNumber$[ebp]
  00ce1	89 45 b8	 mov	 DWORD PTR tv68[ebp], eax
  00ce4	81 7d b8 1e 08
	00 00		 cmp	 DWORD PTR tv68[ebp], 2078 ; 0000081eH
  00ceb	7f 20		 jg	 SHORT $LN14@SockeetIte
  00ced	81 7d b8 1e 08
	00 00		 cmp	 DWORD PTR tv68[ebp], 2078 ; 0000081eH
  00cf4	74 3f		 je	 SHORT $LN7@SockeetIte
  00cf6	83 7d b8 29	 cmp	 DWORD PTR tv68[ebp], 41	; 00000029H
  00cfa	7c 3d		 jl	 SHORT $LN8@SockeetIte
  00cfc	83 7d b8 2a	 cmp	 DWORD PTR tv68[ebp], 42	; 0000002aH
  00d00	7e 33		 jle	 SHORT $LN7@SockeetIte
  00d02	81 7d b8 14 04
	00 00		 cmp	 DWORD PTR tv68[ebp], 1044 ; 00000414H
  00d09	74 2a		 je	 SHORT $LN7@SockeetIte
  00d0b	eb 2c		 jmp	 SHORT $LN8@SockeetIte
$LN14@SockeetIte:
  00d0d	81 7d b8 21 0c
	00 00		 cmp	 DWORD PTR tv68[ebp], 3105 ; 00000c21H
  00d14	7f 1d		 jg	 SHORT $LN15@SockeetIte
  00d16	81 7d b8 1e 0c
	00 00		 cmp	 DWORD PTR tv68[ebp], 3102 ; 00000c1eH
  00d1d	7d 16		 jge	 SHORT $LN7@SockeetIte
  00d1f	81 7d b8 29 0a
	00 00		 cmp	 DWORD PTR tv68[ebp], 2601 ; 00000a29H
  00d26	7c 11		 jl	 SHORT $LN8@SockeetIte
  00d28	81 7d b8 2a 0a
	00 00		 cmp	 DWORD PTR tv68[ebp], 2602 ; 00000a2aH
  00d2f	7e 04		 jle	 SHORT $LN7@SockeetIte
  00d31	eb 06		 jmp	 SHORT $LN8@SockeetIte
$LN15@SockeetIte:
  00d33	eb 04		 jmp	 SHORT $LN8@SockeetIte
$LN7@SockeetIte:

; 283  : 	{
; 284  : 		case ITEMGET(0,41):
; 285  : 		case ITEMGET(0,42):
; 286  : 		case ITEMGET(2,20):
; 287  : 		case ITEMGET(4,30):
; 288  : 		case ITEMGET(5,41):
; 289  : 		case ITEMGET(5,42):
; 290  : 		case ITEMGET(6,30):
; 291  : 		case ITEMGET(6,31):
; 292  : 		case ITEMGET(6,32):
; 293  : 		case ITEMGET(6,33):
; 294  : 			return true;

  00d35	b0 01		 mov	 al, 1
  00d37	eb 60		 jmp	 SHORT $LN12@SockeetIte
$LN8@SockeetIte:

; 295  : 	}
; 296  : 
; 297  : 	if( ItemNumber >= ITEMGET(7,84) && ItemNumber <= ITEMGET(7,90) ||
; 298  : 		ItemNumber >= ITEMGET(8,84) && ItemNumber <= ITEMGET(8,90) ||
; 299  : 		ItemNumber >= ITEMGET(9,84) && ItemNumber <= ITEMGET(9,90) ||
; 300  : 		ItemNumber >= ITEMGET(10,84) && ItemNumber <= ITEMGET(10,90) ||
; 301  : 		ItemNumber >= ITEMGET(11,84) && ItemNumber <= ITEMGET(11,90) )

  00d39	81 7d 08 54 0e
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 3668 ; 00000e54H
  00d40	7c 09		 jl	 SHORT $LN4@SockeetIte
  00d42	81 7d 08 5a 0e
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 3674 ; 00000e5aH
  00d49	7e 48		 jle	 SHORT $LN5@SockeetIte
$LN4@SockeetIte:
  00d4b	81 7d 08 54 10
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 4180 ; 00001054H
  00d52	7c 09		 jl	 SHORT $LN3@SockeetIte
  00d54	81 7d 08 5a 10
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 4186 ; 0000105aH
  00d5b	7e 36		 jle	 SHORT $LN5@SockeetIte
$LN3@SockeetIte:
  00d5d	81 7d 08 54 12
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 4692 ; 00001254H
  00d64	7c 09		 jl	 SHORT $LN2@SockeetIte
  00d66	81 7d 08 5a 12
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 4698 ; 0000125aH
  00d6d	7e 24		 jle	 SHORT $LN5@SockeetIte
$LN2@SockeetIte:
  00d6f	81 7d 08 54 14
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 5204 ; 00001454H
  00d76	7c 09		 jl	 SHORT $LN1@SockeetIte
  00d78	81 7d 08 5a 14
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 5210 ; 0000145aH
  00d7f	7e 12		 jle	 SHORT $LN5@SockeetIte
$LN1@SockeetIte:
  00d81	81 7d 08 54 16
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 5716 ; 00001654H
  00d88	7c 0d		 jl	 SHORT $LN6@SockeetIte
  00d8a	81 7d 08 5a 16
	00 00		 cmp	 DWORD PTR _ItemNumber$[ebp], 5722 ; 0000165aH
  00d91	7f 04		 jg	 SHORT $LN6@SockeetIte
$LN5@SockeetIte:

; 302  : 	{
; 303  : 		return true;

  00d93	b0 01		 mov	 al, 1
  00d95	eb 02		 jmp	 SHORT $LN12@SockeetIte
$LN6@SockeetIte:

; 304  : 	}
; 305  : 
; 306  : 	return false;

  00d97	32 c0		 xor	 al, al
$LN12@SockeetIte:

; 307  : }

  00d99	5f		 pop	 edi
  00d9a	5e		 pop	 esi
  00d9b	5b		 pop	 ebx
  00d9c	8b e5		 mov	 esp, ebp
  00d9e	5d		 pop	 ebp
  00d9f	c2 04 00	 ret	 4
?SockeetItem@cGrandHero@@QAE_NH@Z ENDP			; cGrandHero::SockeetItem
_TEXT	ENDS
PUBLIC	??_C@_0CH@OLGCEEAC@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@ ; `string'
PUBLIC	??_C@_0EL@NDAHJHIE@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@ ; `string'
PUBLIC	?GetMixGrandData@cGrandHero@@QAEHXZ		; cGrandHero::GetMixGrandData
PUBLIC	__$ArrayPad$
PUBLIC	?MixGrandItem@cGrandHero@@QAEXPAUOBJECTSTRUCT@@@Z ; cGrandHero::MixGrandItem
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	_rand:PROC
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?CheckItemCondition@CMixSystem@@QAEHPAVCItem@@FEEEEE@Z:PROC ; CMixSystem::CheckItemCondition
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
;	COMDAT ??_C@_0CH@OLGCEEAC@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@
CONST	SEGMENT
??_C@_0CH@OLGCEEAC@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@ DB '[G'
	DB	'randHeroSystem][Mix Item] CBMix Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NDAHJHIE@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@
CONST	SEGMENT
??_C@_0EL@NDAHJHIE@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@ DB '[G'
	DB	'randHeroSystem][Mix Item] CBMix Item Create Item:%d, Accaunt:'
	DB	'%s, Nick:%s', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv200 = -180						; size = 4
_Option$221666 = -112					; size = 4
_ExlRand$221665 = -108					; size = 4
_ExcellentOpt$221664 = -104				; size = 24
_iLuck$221663 = -80					; size = 4
_iLevel$221662 = -76					; size = 4
_AncItem$221655 = -72					; size = 4
_iSkill$221646 = -68					; size = 4
_ItemType$221645 = -64					; size = 4
_n$221621 = -60						; size = 4
_Need30Soul$ = -56					; size = 4
_Need30Bless$ = -52					; size = 4
_Chaos$ = -48						; size = 4
_Creation$ = -44					; size = 4
_AncItem$ = -40						; size = 4
_ExlItem$ = -36						; size = 4
_ExStone$ = -32						; size = 4
_pMsg$ = -28						; size = 16
_Item$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?MixGrandItem@cGrandHero@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; cGrandHero::MixGrandItem
; _this$ = ecx

; 310  : {

  00db0	55		 push	 ebp
  00db1	8b ec		 mov	 ebp, esp
  00db3	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00db9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00dbe	33 c5		 xor	 eax, ebp
  00dc0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00dc3	53		 push	 ebx
  00dc4	56		 push	 esi
  00dc5	57		 push	 edi
  00dc6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	if(!g_ExLicense.user.GrandHero) return;

  00dc9	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  00dd0	85 c0		 test	 eax, eax
  00dd2	75 05		 jne	 SHORT $LN34@MixGrandIt
  00dd4	e9 da 04 00 00	 jmp	 $LN35@MixGrandIt
$LN34@MixGrandIt:

; 312  : 	int Item = 0;

  00dd9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Item$[ebp], 0

; 313  : 
; 314  : 	PMSG_CHAOSMIXRESULT pMsg;
; 315  : 
; 316  : 	pMsg.h.c = 0xC1;

  00de0	c6 45 e4 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 317  : 	pMsg.h.headcode = 0x86;

  00de4	c6 45 e6 86	 mov	 BYTE PTR _pMsg$[ebp+2], 134 ; 00000086H

; 318  : 	pMsg.h.size = sizeof(PMSG_CHAOSMIXRESULT);

  00de8	c6 45 e5 10	 mov	 BYTE PTR _pMsg$[ebp+1], 16 ; 00000010H

; 319  : 
; 320  : 	pMsg.Result = CB_ERROR;

  00dec	c6 45 e7 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 321  : 
; 322  : 	int ExStone = 0;

  00df0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ExStone$[ebp], 0

; 323  : 	int ExlItem = 0;

  00df7	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ExlItem$[ebp], 0

; 324  : 	int AncItem = 0;

  00dfe	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _AncItem$[ebp], 0

; 325  : 	int Creation = 0;

  00e05	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _Creation$[ebp], 0

; 326  : 	int Chaos = 0;

  00e0c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _Chaos$[ebp], 0

; 327  : 	int Need30Bless = 0;

  00e13	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _Need30Bless$[ebp], 0

; 328  : 	int Need30Soul = 0;

  00e1a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _Need30Soul$[ebp], 0

; 329  : 
; 330  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++ )

  00e21	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _n$221621[ebp], 0
  00e28	eb 09		 jmp	 SHORT $LN33@MixGrandIt
$LN32@MixGrandIt:
  00e2a	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00e2d	83 c0 01	 add	 eax, 1
  00e30	89 45 c4	 mov	 DWORD PTR _n$221621[ebp], eax
$LN33@MixGrandIt:
  00e33	83 7d c4 20	 cmp	 DWORD PTR _n$221621[ebp], 32 ; 00000020H
  00e37	0f 8d 6c 01 00
	00		 jge	 $LN31@MixGrandIt

; 331  : 	{
; 332  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00e3d	8b 4d c4	 mov	 ecx, DWORD PTR _n$221621[ebp]
  00e40	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00e46	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e49	03 88 78 0e 00
	00		 add	 ecx, DWORD PTR [eax+3704]
  00e4f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00e54	83 f8 01	 cmp	 eax, 1
  00e57	0f 85 47 01 00
	00		 jne	 $LN30@MixGrandIt

; 333  : 		{
; 334  : 			if( lpObj->pChaosBox[n].m_Type == ITEMGET(14,195) )

  00e5d	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00e60	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00e66	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e69	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  00e6f	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00e74	3d c3 1c 00 00	 cmp	 eax, 7363		; 00001cc3H
  00e79	75 0e		 jne	 SHORT $LN29@MixGrandIt

; 335  : 			{
; 336  : 				ExStone++;

  00e7b	8b 45 e0	 mov	 eax, DWORD PTR _ExStone$[ebp]
  00e7e	83 c0 01	 add	 eax, 1
  00e81	89 45 e0	 mov	 DWORD PTR _ExStone$[ebp], eax
  00e84	e9 1b 01 00 00	 jmp	 $LN30@MixGrandIt
$LN29@MixGrandIt:

; 337  : 			}
; 338  : 			else if(lpObj->pChaosBox[n].m_Type == ITEMGET(12,15))

  00e89	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00e8c	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00e92	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e95	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  00e9b	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00ea0	3d 0f 18 00 00	 cmp	 eax, 6159		; 0000180fH
  00ea5	75 0e		 jne	 SHORT $LN27@MixGrandIt

; 339  : 			{
; 340  : 				Chaos++;

  00ea7	8b 45 d0	 mov	 eax, DWORD PTR _Chaos$[ebp]
  00eaa	83 c0 01	 add	 eax, 1
  00ead	89 45 d0	 mov	 DWORD PTR _Chaos$[ebp], eax
  00eb0	e9 ef 00 00 00	 jmp	 $LN30@MixGrandIt
$LN27@MixGrandIt:

; 341  : 			}
; 342  : 			else if(lpObj->pChaosBox[n].m_Type == ITEMGET(14,22))

  00eb5	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00eb8	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00ebe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ec1	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  00ec7	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00ecc	3d 16 1c 00 00	 cmp	 eax, 7190		; 00001c16H
  00ed1	75 0e		 jne	 SHORT $LN25@MixGrandIt

; 343  : 			{
; 344  : 				Creation++;

  00ed3	8b 45 d4	 mov	 eax, DWORD PTR _Creation$[ebp]
  00ed6	83 c0 01	 add	 eax, 1
  00ed9	89 45 d4	 mov	 DWORD PTR _Creation$[ebp], eax
  00edc	e9 c3 00 00 00	 jmp	 $LN30@MixGrandIt
$LN25@MixGrandIt:

; 345  : 			}
; 346  : 			else if( g_MixSystem.CheckItemCondition(&lpObj->pChaosBox[n],9,0,0,1,1,0) != FALSE )

  00ee1	6a 00		 push	 0
  00ee3	6a 01		 push	 1
  00ee5	6a 01		 push	 1
  00ee7	6a 00		 push	 0
  00ee9	6a 00		 push	 0
  00eeb	6a 09		 push	 9
  00eed	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00ef0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00ef6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ef9	03 81 78 0e 00
	00		 add	 eax, DWORD PTR [ecx+3704]
  00eff	50		 push	 eax
  00f00	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00f05	e8 00 00 00 00	 call	 ?CheckItemCondition@CMixSystem@@QAEHPAVCItem@@FEEEEE@Z ; CMixSystem::CheckItemCondition
  00f0a	85 c0		 test	 eax, eax
  00f0c	74 0e		 je	 SHORT $LN23@MixGrandIt

; 347  : 			{
; 348  : 				AncItem++;

  00f0e	8b 45 d8	 mov	 eax, DWORD PTR _AncItem$[ebp]
  00f11	83 c0 01	 add	 eax, 1
  00f14	89 45 d8	 mov	 DWORD PTR _AncItem$[ebp], eax
  00f17	e9 88 00 00 00	 jmp	 $LN30@MixGrandIt
$LN23@MixGrandIt:

; 349  : 			}
; 350  : 			else if( g_MixSystem.CheckItemCondition(&lpObj->pChaosBox[n],9,0,0,1,0,1) != FALSE )

  00f1c	6a 01		 push	 1
  00f1e	6a 00		 push	 0
  00f20	6a 01		 push	 1
  00f22	6a 00		 push	 0
  00f24	6a 00		 push	 0
  00f26	6a 09		 push	 9
  00f28	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00f2b	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00f31	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f34	03 81 78 0e 00
	00		 add	 eax, DWORD PTR [ecx+3704]
  00f3a	50		 push	 eax
  00f3b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00f40	e8 00 00 00 00	 call	 ?CheckItemCondition@CMixSystem@@QAEHPAVCItem@@FEEEEE@Z ; CMixSystem::CheckItemCondition
  00f45	85 c0		 test	 eax, eax
  00f47	74 0b		 je	 SHORT $LN21@MixGrandIt

; 351  : 			{
; 352  : 				ExlItem++;

  00f49	8b 45 dc	 mov	 eax, DWORD PTR _ExlItem$[ebp]
  00f4c	83 c0 01	 add	 eax, 1
  00f4f	89 45 dc	 mov	 DWORD PTR _ExlItem$[ebp], eax
  00f52	eb 50		 jmp	 SHORT $LN30@MixGrandIt
$LN21@MixGrandIt:

; 353  : 			}
; 354  : 			else if( lpObj->pChaosBox[n].m_Type == ITEMGET(12,30))	

  00f54	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00f57	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00f5d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f60	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  00f66	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00f6b	3d 1e 18 00 00	 cmp	 eax, 6174		; 0000181eH
  00f70	75 0b		 jne	 SHORT $LN19@MixGrandIt

; 355  : 			{
; 356  : 				Need30Bless++;

  00f72	8b 45 cc	 mov	 eax, DWORD PTR _Need30Bless$[ebp]
  00f75	83 c0 01	 add	 eax, 1
  00f78	89 45 cc	 mov	 DWORD PTR _Need30Bless$[ebp], eax
  00f7b	eb 27		 jmp	 SHORT $LN30@MixGrandIt
$LN19@MixGrandIt:

; 357  : 			}
; 358  : 			else if( lpObj->pChaosBox[n].m_Type == ITEMGET(12,31))	//30 S

  00f7d	8b 45 c4	 mov	 eax, DWORD PTR _n$221621[ebp]
  00f80	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00f86	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f89	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  00f8f	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00f94	3d 1f 18 00 00	 cmp	 eax, 6175		; 0000181fH
  00f99	75 09		 jne	 SHORT $LN30@MixGrandIt

; 359  : 			{
; 360  : 				Need30Soul++;

  00f9b	8b 45 c8	 mov	 eax, DWORD PTR _Need30Soul$[ebp]
  00f9e	83 c0 01	 add	 eax, 1
  00fa1	89 45 c8	 mov	 DWORD PTR _Need30Soul$[ebp], eax
$LN30@MixGrandIt:

; 361  : 			}
; 362  : 		}
; 363  : 	}

  00fa4	e9 81 fe ff ff	 jmp	 $LN32@MixGrandIt
$LN31@MixGrandIt:

; 364  : 
; 365  : 	if(ExStone != 10 || ExlItem == 0 || AncItem == 0 || Creation == 0 || Chaos == 0 || Need30Bless != 1 || Need30Soul != 1)

  00fa9	83 7d e0 0a	 cmp	 DWORD PTR _ExStone$[ebp], 10 ; 0000000aH
  00fad	75 24		 jne	 SHORT $LN15@MixGrandIt
  00faf	83 7d dc 00	 cmp	 DWORD PTR _ExlItem$[ebp], 0
  00fb3	74 1e		 je	 SHORT $LN15@MixGrandIt
  00fb5	83 7d d8 00	 cmp	 DWORD PTR _AncItem$[ebp], 0
  00fb9	74 18		 je	 SHORT $LN15@MixGrandIt
  00fbb	83 7d d4 00	 cmp	 DWORD PTR _Creation$[ebp], 0
  00fbf	74 12		 je	 SHORT $LN15@MixGrandIt
  00fc1	83 7d d0 00	 cmp	 DWORD PTR _Chaos$[ebp], 0
  00fc5	74 0c		 je	 SHORT $LN15@MixGrandIt
  00fc7	83 7d cc 01	 cmp	 DWORD PTR _Need30Bless$[ebp], 1
  00fcb	75 06		 jne	 SHORT $LN15@MixGrandIt
  00fcd	83 7d c8 01	 cmp	 DWORD PTR _Need30Soul$[ebp], 1
  00fd1	74 20		 je	 SHORT $LN16@MixGrandIt
$LN15@MixGrandIt:

; 366  : 	{
; 367  : 		pMsg.Result = CB_INCORRECT_MIX_ITEMS;

  00fd3	c6 45 e7 07	 mov	 BYTE PTR _pMsg$[ebp+3], 7

; 368  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00fd7	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00fdb	50		 push	 eax
  00fdc	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00fdf	51		 push	 ecx
  00fe0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00fe3	8b 02		 mov	 eax, DWORD PTR [edx]
  00fe5	50		 push	 eax
  00fe6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00feb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 369  : 		return;

  00fee	e9 c0 02 00 00	 jmp	 $LN35@MixGrandIt
$LN16@MixGrandIt:

; 370  : 	}
; 371  : 
; 372  : 	if(this->MixMoney > lpObj->Money)

  00ff3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00ff6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ff9	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00ffc	3b 91 f0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+240]
  01002	7e 20		 jle	 SHORT $LN14@MixGrandIt

; 373  : 	{
; 374  : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;

  01004	c6 45 e7 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 375  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  01008	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0100c	50		 push	 eax
  0100d	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01010	51		 push	 ecx
  01011	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01014	8b 02		 mov	 eax, DWORD PTR [edx]
  01016	50		 push	 eax
  01017	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0101c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 376  : 		return;

  0101f	e9 8f 02 00 00	 jmp	 $LN35@MixGrandIt
$LN14@MixGrandIt:

; 377  : 	}
; 378  : 
; 379  : 	lpObj->Money -= this->MixMoney;

  01024	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0102a	8b 90 f0 00 00
	00		 mov	 edx, DWORD PTR [eax+240]
  01030	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  01033	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01036	89 90 f0 00 00
	00		 mov	 DWORD PTR [eax+240], edx

; 380  : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  0103c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0103f	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01045	51		 push	 ecx
  01046	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01049	8b 02		 mov	 eax, DWORD PTR [edx]
  0104b	50		 push	 eax
  0104c	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  01051	83 c4 08	 add	 esp, 8

; 381  : 
; 382  : 	if(this->MixItemRate > (rand()%100))

  01054	e8 00 00 00 00	 call	 _rand
  01059	99		 cdq
  0105a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0105f	f7 f9		 idiv	 ecx
  01061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01064	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  01067	0f 8e 05 02 00
	00		 jle	 $LN13@MixGrandIt

; 383  : 	{
; 384  : 		int ItemType = this->GetMixGrandData();

  0106d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01070	e8 00 00 00 00	 call	 ?GetMixGrandData@cGrandHero@@QAEHXZ ; cGrandHero::GetMixGrandData
  01075	89 45 c0	 mov	 DWORD PTR _ItemType$221645[ebp], eax

; 385  : 		int iSkill = 0;

  01078	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _iSkill$221646[ebp], 0

; 386  : 
; 387  : 		switch(ItemType)

  0107f	8b 45 c0	 mov	 eax, DWORD PTR _ItemType$221645[ebp]
  01082	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  01088	81 bd 4c ff ff
	ff 1e 08 00 00	 cmp	 DWORD PTR tv200[ebp], 2078 ; 0000081eH
  01092	7f 2c		 jg	 SHORT $LN37@MixGrandIt
  01094	81 bd 4c ff ff
	ff 1e 08 00 00	 cmp	 DWORD PTR tv200[ebp], 2078 ; 0000081eH
  0109e	74 3a		 je	 SHORT $LN10@MixGrandIt
  010a0	83 bd 4c ff ff
	ff 29		 cmp	 DWORD PTR tv200[ebp], 41 ; 00000029H
  010a7	7c 38		 jl	 SHORT $LN11@MixGrandIt
  010a9	83 bd 4c ff ff
	ff 2a		 cmp	 DWORD PTR tv200[ebp], 42 ; 0000002aH
  010b0	7e 28		 jle	 SHORT $LN10@MixGrandIt
  010b2	81 bd 4c ff ff
	ff 14 04 00 00	 cmp	 DWORD PTR tv200[ebp], 1044 ; 00000414H
  010bc	74 1c		 je	 SHORT $LN10@MixGrandIt
  010be	eb 21		 jmp	 SHORT $LN11@MixGrandIt
$LN37@MixGrandIt:
  010c0	81 bd 4c ff ff
	ff 1e 0c 00 00	 cmp	 DWORD PTR tv200[ebp], 3102 ; 00000c1eH
  010ca	7c 15		 jl	 SHORT $LN11@MixGrandIt
  010cc	81 bd 4c ff ff
	ff 21 0c 00 00	 cmp	 DWORD PTR tv200[ebp], 3105 ; 00000c21H
  010d6	7e 02		 jle	 SHORT $LN10@MixGrandIt
  010d8	eb 07		 jmp	 SHORT $LN11@MixGrandIt
$LN10@MixGrandIt:

; 388  : 		{
; 389  : 			case ITEMGET(0,41):
; 390  : 			case ITEMGET(0,42):
; 391  : 			case ITEMGET(2,20):
; 392  : 			case ITEMGET(4,30):
; 393  : 			case ITEMGET(6,30):
; 394  : 			case ITEMGET(6,31):
; 395  : 			case ITEMGET(6,32):
; 396  : 			case ITEMGET(6,33):
; 397  : 				iSkill = 1; //break;

  010da	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _iSkill$221646[ebp], 1
$LN11@MixGrandIt:

; 398  : 		}
; 399  : 
; 400  : 		if(ItemAttribute[ItemType].Width == 0 || ItemAttribute[ItemType].Height == 0)

  010e1	8b 45 c0	 mov	 eax, DWORD PTR _ItemType$221645[ebp]
  010e4	6b c0 70	 imul	 eax, 112		; 00000070H
  010e7	0f b6 88 23 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+35]
  010ee	85 c9		 test	 ecx, ecx
  010f0	74 11		 je	 SHORT $LN8@MixGrandIt
  010f2	8b 45 c0	 mov	 eax, DWORD PTR _ItemType$221645[ebp]
  010f5	6b c0 70	 imul	 eax, 112		; 00000070H
  010f8	0f b6 88 24 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+36]
  010ff	85 c9		 test	 ecx, ecx
  01101	75 20		 jne	 SHORT $LN9@MixGrandIt
$LN8@MixGrandIt:

; 401  : 		{
; 402  : 			pMsg.Result = CB_ERROR;

  01103	c6 45 e7 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 403  : 			DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  01107	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0110b	50		 push	 eax
  0110c	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0110f	51		 push	 ecx
  01110	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01113	8b 02		 mov	 eax, DWORD PTR [edx]
  01115	50		 push	 eax
  01116	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0111b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  : 			return;

  0111e	e9 90 01 00 00	 jmp	 $LN35@MixGrandIt
$LN9@MixGrandIt:

; 405  : 		}
; 406  : 
; 407  : 		int AncItem = 0;

  01123	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _AncItem$221655[ebp], 0

; 408  : 
; 409  : 		if( ItemType >= ITEMGET(7,84) && ItemType <= ITEMGET(7,90) ||
; 410  : 			ItemType >= ITEMGET(8,84) && ItemType <= ITEMGET(8,90) ||
; 411  : 			ItemType >= ITEMGET(9,84) && ItemType <= ITEMGET(9,90) ||
; 412  : 			ItemType >= ITEMGET(10,84) && ItemType <= ITEMGET(10,90) ||
; 413  : 			ItemType >= ITEMGET(11,84) && ItemType <= ITEMGET(11,90) )

  0112a	81 7d c0 54 0e
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 3668 ; 00000e54H
  01131	7c 09		 jl	 SHORT $LN5@MixGrandIt
  01133	81 7d c0 5a 0e
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 3674 ; 00000e5aH
  0113a	7e 48		 jle	 SHORT $LN6@MixGrandIt
$LN5@MixGrandIt:
  0113c	81 7d c0 54 10
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 4180 ; 00001054H
  01143	7c 09		 jl	 SHORT $LN4@MixGrandIt
  01145	81 7d c0 5a 10
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 4186 ; 0000105aH
  0114c	7e 36		 jle	 SHORT $LN6@MixGrandIt
$LN4@MixGrandIt:
  0114e	81 7d c0 54 12
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 4692 ; 00001254H
  01155	7c 09		 jl	 SHORT $LN3@MixGrandIt
  01157	81 7d c0 5a 12
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 4698 ; 0000125aH
  0115e	7e 24		 jle	 SHORT $LN6@MixGrandIt
$LN3@MixGrandIt:
  01160	81 7d c0 54 14
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 5204 ; 00001454H
  01167	7c 09		 jl	 SHORT $LN2@MixGrandIt
  01169	81 7d c0 5a 14
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 5210 ; 0000145aH
  01170	7e 12		 jle	 SHORT $LN6@MixGrandIt
$LN2@MixGrandIt:
  01172	81 7d c0 54 16
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 5716 ; 00001654H
  01179	7c 10		 jl	 SHORT $LN7@MixGrandIt
  0117b	81 7d c0 5a 16
	00 00		 cmp	 DWORD PTR _ItemType$221645[ebp], 5722 ; 0000165aH
  01182	7f 07		 jg	 SHORT $LN7@MixGrandIt
$LN6@MixGrandIt:

; 414  : 		{
; 415  : 			AncItem = 5;

  01184	c7 45 b8 05 00
	00 00		 mov	 DWORD PTR _AncItem$221655[ebp], 5
$LN7@MixGrandIt:

; 416  : 		}
; 417  : 
; 418  : 		//srand(time(NULL));
; 419  : 		int iLevel = rand()%5;

  0118b	e8 00 00 00 00	 call	 _rand
  01190	99		 cdq
  01191	b9 05 00 00 00	 mov	 ecx, 5
  01196	f7 f9		 idiv	 ecx
  01198	89 55 b4	 mov	 DWORD PTR _iLevel$221662[ebp], edx

; 420  : 
; 421  : 		//srand(time(NULL));
; 422  : 		int iLuck = rand()%2;

  0119b	e8 00 00 00 00	 call	 _rand
  011a0	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  011a5	79 05		 jns	 SHORT $LN38@MixGrandIt
  011a7	48		 dec	 eax
  011a8	83 c8 fe	 or	 eax, -2			; fffffffeH
  011ab	40		 inc	 eax
$LN38@MixGrandIt:
  011ac	89 45 b0	 mov	 DWORD PTR _iLuck$221663[ebp], eax

; 423  : 
; 424  : 		int ExcellentOpt[6] = { 1, 2, 4, 8, 16, 32 };

  011af	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$221664[ebp], 1
  011b6	c7 45 9c 02 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$221664[ebp+4], 2
  011bd	c7 45 a0 04 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$221664[ebp+8], 4
  011c4	c7 45 a4 08 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$221664[ebp+12], 8
  011cb	c7 45 a8 10 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$221664[ebp+16], 16 ; 00000010H
  011d2	c7 45 ac 20 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$221664[ebp+20], 32 ; 00000020H

; 425  : 		//srand(time(NULL));
; 426  : 		int ExlRand = ExcellentOpt[rand()%6];

  011d9	e8 00 00 00 00	 call	 _rand
  011de	99		 cdq
  011df	b9 06 00 00 00	 mov	 ecx, 6
  011e4	f7 f9		 idiv	 ecx
  011e6	8b 54 95 98	 mov	 edx, DWORD PTR _ExcellentOpt$221664[ebp+edx*4]
  011ea	89 55 94	 mov	 DWORD PTR _ExlRand$221665[ebp], edx

; 427  : 
; 428  : 		int Option = rand()%8;

  011ed	e8 00 00 00 00	 call	 _rand
  011f2	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  011f7	79 05		 jns	 SHORT $LN39@MixGrandIt
  011f9	48		 dec	 eax
  011fa	83 c8 f8	 or	 eax, -8			; fffffff8H
  011fd	40		 inc	 eax
$LN39@MixGrandIt:
  011fe	89 45 90	 mov	 DWORD PTR _Option$221666[ebp], eax

; 429  : 
; 430  : 		ItemSerialCreateSend(lpObj->m_Index, 0xFF, 0, 0, ItemType, iLevel, 0, iSkill, iLuck, Option, lpObj->m_Index, ExlRand, AncItem);

  01201	0f b6 45 b8	 movzx	 eax, BYTE PTR _AncItem$221655[ebp]
  01205	50		 push	 eax
  01206	0f b6 4d 94	 movzx	 ecx, BYTE PTR _ExlRand$221665[ebp]
  0120a	51		 push	 ecx
  0120b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0120e	8b 02		 mov	 eax, DWORD PTR [edx]
  01210	50		 push	 eax
  01211	0f b6 4d 90	 movzx	 ecx, BYTE PTR _Option$221666[ebp]
  01215	51		 push	 ecx
  01216	0f b6 55 b0	 movzx	 edx, BYTE PTR _iLuck$221663[ebp]
  0121a	52		 push	 edx
  0121b	0f b6 45 bc	 movzx	 eax, BYTE PTR _iSkill$221646[ebp]
  0121f	50		 push	 eax
  01220	6a 00		 push	 0
  01222	0f b6 4d b4	 movzx	 ecx, BYTE PTR _iLevel$221662[ebp]
  01226	51		 push	 ecx
  01227	8b 55 c0	 mov	 edx, DWORD PTR _ItemType$221645[ebp]
  0122a	52		 push	 edx
  0122b	6a 00		 push	 0
  0122d	6a 00		 push	 0
  0122f	68 ff 00 00 00	 push	 255			; 000000ffH
  01234	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01237	8b 08		 mov	 ecx, DWORD PTR [eax]
  01239	51		 push	 ecx
  0123a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0123f	83 c4 34	 add	 esp, 52			; 00000034H

; 431  : 		::gObjInventoryCommit(lpObj->m_Index);

  01242	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01245	8b 08		 mov	 ecx, DWORD PTR [eax]
  01247	51		 push	 ecx
  01248	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0124d	83 c4 04	 add	 esp, 4

; 432  : 
; 433  : 		LogAddTD("[GrandHeroSystem][Mix Item] CBMix Item Create Item:%d, Accaunt:%s, Nick:%s",ItemType,lpObj->AccountID,lpObj->Name);

  01250	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01253	83 c0 77	 add	 eax, 119		; 00000077H
  01256	50		 push	 eax
  01257	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0125a	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0125d	51		 push	 ecx
  0125e	8b 55 c0	 mov	 edx, DWORD PTR _ItemType$221645[ebp]
  01261	52		 push	 edx
  01262	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NDAHJHIE@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@
  01267	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0126d	83 c4 10	 add	 esp, 16			; 00000010H

; 434  : 	}
; 435  : 	else

  01270	eb 41		 jmp	 SHORT $LN35@MixGrandIt
$LN13@MixGrandIt:

; 436  : 	{
; 437  : 		g_MixSystem.ChaosBoxInit(lpObj);

  01272	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01275	50		 push	 eax
  01276	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0127b	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 438  : 		::GCUserChaosBoxSend(lpObj, 0);

  01280	6a 00		 push	 0
  01282	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01285	50		 push	 eax
  01286	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  0128b	83 c4 08	 add	 esp, 8

; 439  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0128e	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  01292	50		 push	 eax
  01293	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01296	51		 push	 ecx
  01297	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0129a	8b 02		 mov	 eax, DWORD PTR [edx]
  0129c	50		 push	 eax
  0129d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  012a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  : 
; 441  : 		LogAddTD("[GrandHeroSystem][Mix Item] CBMix Fail");

  012a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OLGCEEAC@?$FLGrandHeroSystem?$FN?$FLMix?5Item?$FN?5CBMi@
  012aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  012b0	83 c4 04	 add	 esp, 4
$LN35@MixGrandIt:

; 442  : 	}
; 443  : }

  012b3	5f		 pop	 edi
  012b4	5e		 pop	 esi
  012b5	5b		 pop	 ebx
  012b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012b9	33 cd		 xor	 ecx, ebp
  012bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012c0	8b e5		 mov	 esp, ebp
  012c2	5d		 pop	 ebp
  012c3	c2 04 00	 ret	 4
?MixGrandItem@cGrandHero@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; cGrandHero::MixGrandItem
_TEXT	ENDS
PUBLIC	?BossDrop@cGrandHero@@QAE_NPAUOBJECTSTRUCT@@0@Z	; cGrandHero::BossDrop
EXTRN	?MakeRewardSetItem@@YAXHEEHH@Z:PROC		; MakeRewardSetItem
EXTRN	_srand:PROC
EXTRN	?GenExcOpt@@YAHH@Z:PROC				; GenExcOpt
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$221685 = -24						; size = 4
_Type$221681 = -20					; size = 4
_Anc$221680 = -16					; size = 4
_Exe$221679 = -12					; size = 4
_num$221678 = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?BossDrop@cGrandHero@@QAE_NPAUOBJECTSTRUCT@@0@Z PROC	; cGrandHero::BossDrop
; _this$ = ecx

; 446  : {

  012d0	55		 push	 ebp
  012d1	8b ec		 mov	 ebp, esp
  012d3	83 ec 58	 sub	 esp, 88			; 00000058H
  012d6	53		 push	 ebx
  012d7	56		 push	 esi
  012d8	57		 push	 edi
  012d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 447  : 	if(!this->Enable)return false;

  012dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012df	83 38 00	 cmp	 DWORD PTR [eax], 0
  012e2	75 07		 jne	 SHORT $LN12@BossDrop
  012e4	32 c0		 xor	 al, al
  012e6	e9 2d 02 00 00	 jmp	 $LN13@BossDrop
$LN12@BossDrop:

; 448  : 
; 449  : 	if(lpObj->Class == 593)

  012eb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012ee	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  012f5	81 f9 51 02 00
	00		 cmp	 ecx, 593		; 00000251H
  012fb	0f 85 a9 01 00
	00		 jne	 $LN11@BossDrop

; 450  : 	{
; 451  : 		//srand(time(NULL));
; 452  : 		int num = rand()%this->ItemCoint;

  01301	e8 00 00 00 00	 call	 _rand
  01306	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01309	99		 cdq
  0130a	f7 b9 78 06 00
	00		 idiv	 DWORD PTR [ecx+1656]
  01310	89 55 f8	 mov	 DWORD PTR _num$221678[ebp], edx

; 453  : 		int Exe = 0;

  01313	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Exe$221679[ebp], 0

; 454  : 		int Anc = 0;

  0131a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Anc$221680[ebp], 0

; 455  : 		int Type = ITEMGET(this->Items[num].Index,this->Items[num].ItemID);

  01321	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  01324	c1 e0 04	 shl	 eax, 4
  01327	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0132a	0f bf 54 01 38	 movsx	 edx, WORD PTR [ecx+eax+56]
  0132f	c1 e2 09	 shl	 edx, 9
  01332	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  01335	c1 e0 04	 shl	 eax, 4
  01338	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0133b	0f bf 44 01 3a	 movsx	 eax, WORD PTR [ecx+eax+58]
  01340	03 d0		 add	 edx, eax
  01342	89 55 ec	 mov	 DWORD PTR _Type$221681[ebp], edx

; 456  : 		if ( this->Items[num].Exl > 0 )

  01345	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  01348	c1 e0 04	 shl	 eax, 4
  0134b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0134e	0f bf 54 01 44	 movsx	 edx, WORD PTR [ecx+eax+68]
  01353	85 d2		 test	 edx, edx
  01355	7e 1a		 jle	 SHORT $LN10@BossDrop

; 457  : 		{
; 458  : 			Exe = GenExcOpt(this->Items[num].Exl);

  01357	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  0135a	c1 e0 04	 shl	 eax, 4
  0135d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01360	0f bf 54 01 44	 movsx	 edx, WORD PTR [ecx+eax+68]
  01365	52		 push	 edx
  01366	e8 00 00 00 00	 call	 ?GenExcOpt@@YAHH@Z	; GenExcOpt
  0136b	83 c4 04	 add	 esp, 4
  0136e	89 45 f4	 mov	 DWORD PTR _Exe$221679[ebp], eax
$LN10@BossDrop:

; 459  : 		}
; 460  : 
; 461  : 		if ( this->Items[num].Anc == 5 || this->Items[num].Anc == 10 )

  01371	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  01374	c1 e0 04	 shl	 eax, 4
  01377	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0137a	0f bf 54 01 46	 movsx	 edx, WORD PTR [ecx+eax+70]
  0137f	83 fa 05	 cmp	 edx, 5
  01382	74 13		 je	 SHORT $LN8@BossDrop
  01384	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  01387	c1 e0 04	 shl	 eax, 4
  0138a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0138d	0f bf 54 01 46	 movsx	 edx, WORD PTR [ecx+eax+70]
  01392	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  01395	75 11		 jne	 SHORT $LN9@BossDrop
$LN8@BossDrop:

; 462  : 		{
; 463  : 			Anc = this->Items[num].Anc;

  01397	8b 45 f8	 mov	 eax, DWORD PTR _num$221678[ebp]
  0139a	c1 e0 04	 shl	 eax, 4
  0139d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013a0	0f bf 54 01 46	 movsx	 edx, WORD PTR [ecx+eax+70]
  013a5	89 55 f0	 mov	 DWORD PTR _Anc$221680[ebp], edx
$LN9@BossDrop:

; 464  : 		}
; 465  : 
; 466  : 		for(int i=0;i<this->BossDropCount;i++)

  013a8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$221685[ebp], 0
  013af	eb 09		 jmp	 SHORT $LN7@BossDrop
$LN6@BossDrop:
  013b1	8b 45 e8	 mov	 eax, DWORD PTR _i$221685[ebp]
  013b4	83 c0 01	 add	 eax, 1
  013b7	89 45 e8	 mov	 DWORD PTR _i$221685[ebp], eax
$LN7@BossDrop:
  013ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013bd	8b 4d e8	 mov	 ecx, DWORD PTR _i$221685[ebp]
  013c0	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  013c3	0f 8d 86 00 00
	00		 jge	 $LN5@BossDrop

; 467  : 		{
; 468  : 			ItemSerialCreateSend(lpTargetObj->m_Index,(BYTE)lpObj->MapNumber,(BYTE)lpObj->X,(BYTE)lpObj->Y,Type,(BYTE)Items[num].Level,0,(BYTE)Items[num].Skill,(BYTE)Items[num].Luck,(BYTE)Items[num].Options,lpTargetObj->m_Index,(BYTE)Exe,(BYTE)Anc);

  013c9	0f b6 45 f0	 movzx	 eax, BYTE PTR _Anc$221680[ebp]
  013cd	50		 push	 eax
  013ce	0f b6 4d f4	 movzx	 ecx, BYTE PTR _Exe$221679[ebp]
  013d2	51		 push	 ecx
  013d3	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  013d6	8b 02		 mov	 eax, DWORD PTR [edx]
  013d8	50		 push	 eax
  013d9	8b 4d f8	 mov	 ecx, DWORD PTR _num$221678[ebp]
  013dc	c1 e1 04	 shl	 ecx, 4
  013df	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013e2	0f b6 44 0a 42	 movzx	 eax, BYTE PTR [edx+ecx+66]
  013e7	50		 push	 eax
  013e8	8b 4d f8	 mov	 ecx, DWORD PTR _num$221678[ebp]
  013eb	c1 e1 04	 shl	 ecx, 4
  013ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013f1	0f b6 44 0a 40	 movzx	 eax, BYTE PTR [edx+ecx+64]
  013f6	50		 push	 eax
  013f7	8b 4d f8	 mov	 ecx, DWORD PTR _num$221678[ebp]
  013fa	c1 e1 04	 shl	 ecx, 4
  013fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01400	0f b6 44 0a 3e	 movzx	 eax, BYTE PTR [edx+ecx+62]
  01405	50		 push	 eax
  01406	6a 00		 push	 0
  01408	8b 4d f8	 mov	 ecx, DWORD PTR _num$221678[ebp]
  0140b	c1 e1 04	 shl	 ecx, 4
  0140e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01411	0f b6 44 0a 3c	 movzx	 eax, BYTE PTR [edx+ecx+60]
  01416	50		 push	 eax
  01417	8b 4d ec	 mov	 ecx, DWORD PTR _Type$221681[ebp]
  0141a	51		 push	 ecx
  0141b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0141e	0f b6 82 46 01
	00 00		 movzx	 eax, BYTE PTR [edx+326]
  01425	50		 push	 eax
  01426	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01429	0f b6 91 44 01
	00 00		 movzx	 edx, BYTE PTR [ecx+324]
  01430	52		 push	 edx
  01431	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01434	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0143b	51		 push	 ecx
  0143c	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0143f	8b 02		 mov	 eax, DWORD PTR [edx]
  01441	50		 push	 eax
  01442	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  01447	83 c4 34	 add	 esp, 52			; 00000034H

; 469  : 		}

  0144a	e9 62 ff ff ff	 jmp	 $LN6@BossDrop
$LN5@BossDrop:

; 470  : 
; 471  : 		srand(time(NULL));

  0144f	6a 00		 push	 0
  01451	e8 00 00 00 00	 call	 _time
  01456	83 c4 04	 add	 esp, 4
  01459	50		 push	 eax
  0145a	e8 00 00 00 00	 call	 _srand
  0145f	83 c4 04	 add	 esp, 4

; 472  : 		if(this->BossAncDrop > rand()%10000)

  01462	e8 00 00 00 00	 call	 _rand
  01467	99		 cdq
  01468	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0146d	f7 f9		 idiv	 ecx
  0146f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01472	39 50 18	 cmp	 DWORD PTR [eax+24], edx
  01475	7e 31		 jle	 SHORT $LN4@BossDrop

; 473  : 		{
; 474  : 			MakeRewardSetItem(lpTargetObj->m_Index, lpObj->X, lpObj->Y, 1, lpObj->MapNumber);

  01477	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0147a	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  01481	51		 push	 ecx
  01482	6a 01		 push	 1
  01484	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01487	0f b6 82 46 01
	00 00		 movzx	 eax, BYTE PTR [edx+326]
  0148e	50		 push	 eax
  0148f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01492	0f b6 91 44 01
	00 00		 movzx	 edx, BYTE PTR [ecx+324]
  01499	52		 push	 edx
  0149a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0149d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0149f	51		 push	 ecx
  014a0	e8 00 00 00 00	 call	 ?MakeRewardSetItem@@YAXHEEHH@Z ; MakeRewardSetItem
  014a5	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@BossDrop:

; 475  : 		}
; 476  : 
; 477  : #if(_MegaMu_)
; 478  : 		return true;
; 479  : #endif
; 480  : 	}

  014a8	eb 6c		 jmp	 SHORT $LN3@BossDrop
$LN11@BossDrop:

; 481  : 	else if(lpTargetObj->MapNumber == HERO_MAP)

  014aa	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  014ad	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  014b4	83 f9 51	 cmp	 ecx, 81			; 00000051H
  014b7	75 5d		 jne	 SHORT $LN3@BossDrop

; 482  : 	{
; 483  : 		//srand(time(NULL));
; 484  : 		if(this->ExStoneDropRate > rand()%10000)

  014b9	e8 00 00 00 00	 call	 _rand
  014be	99		 cdq
  014bf	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  014c4	f7 f9		 idiv	 ecx
  014c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014c9	39 50 14	 cmp	 DWORD PTR [eax+20], edx
  014cc	7e 48		 jle	 SHORT $LN3@BossDrop

; 485  : 		{
; 486  : 			
; 487  : 			ItemSerialCreateSend(lpTargetObj->m_Index,(BYTE)lpObj->MapNumber,(BYTE)lpObj->X,(BYTE)lpObj->Y,ITEMGET(14,195),0,0,0,0,0,lpTargetObj->m_Index,0,0);

  014ce	6a 00		 push	 0
  014d0	6a 00		 push	 0
  014d2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  014d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  014d7	51		 push	 ecx
  014d8	6a 00		 push	 0
  014da	6a 00		 push	 0
  014dc	6a 00		 push	 0
  014de	6a 00		 push	 0
  014e0	6a 00		 push	 0
  014e2	68 c3 1c 00 00	 push	 7363			; 00001cc3H
  014e7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014ea	0f b6 82 46 01
	00 00		 movzx	 eax, BYTE PTR [edx+326]
  014f1	50		 push	 eax
  014f2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  014f5	0f b6 91 44 01
	00 00		 movzx	 edx, BYTE PTR [ecx+324]
  014fc	52		 push	 edx
  014fd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01500	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  01507	51		 push	 ecx
  01508	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0150b	8b 02		 mov	 eax, DWORD PTR [edx]
  0150d	50		 push	 eax
  0150e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  01513	83 c4 34	 add	 esp, 52			; 00000034H
$LN3@BossDrop:

; 488  : 		}
; 489  : #if(_MegaMu_)
; 490  : 		return true;
; 491  : #endif
; 492  : 	}
; 493  : 	return false;

  01516	32 c0		 xor	 al, al
$LN13@BossDrop:

; 494  : }

  01518	5f		 pop	 edi
  01519	5e		 pop	 esi
  0151a	5b		 pop	 ebx
  0151b	8b e5		 mov	 esp, ebp
  0151d	5d		 pop	 ebp
  0151e	c2 08 00	 ret	 8
?BossDrop@cGrandHero@@QAE_NPAUOBJECTSTRUCT@@0@Z ENDP	; cGrandHero::BossDrop
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

  01530	55		 push	 ebp
  01531	8b ec		 mov	 ebp, esp
  01533	83 ec 40	 sub	 esp, 64			; 00000040H
  01536	53		 push	 ebx
  01537	56		 push	 esi
  01538	57		 push	 edi

; 133  :     return _time64(_Time);

  01539	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0153c	50		 push	 eax
  0153d	e8 00 00 00 00	 call	 __time64
  01542	83 c4 04	 add	 esp, 4

; 134  : }

  01545	5f		 pop	 edi
  01546	5e		 pop	 esi
  01547	5b		 pop	 ebx
  01548	8b e5		 mov	 esp, ebp
  0154a	5d		 pop	 ebp
  0154b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KEHEBAKI@Grand?5Item?5Need?5Grand?5Reset?3?5?$CFd?$AA@ ; `string'
PUBLIC	?MoveGRItem@cGrandHero@@QAE_NHHH@Z		; cGrandHero::MoveGRItem
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
;	COMDAT ??_C@_0CA@KEHEBAKI@Grand?5Item?5Need?5Grand?5Reset?3?5?$CFd?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\grandherosystem.cpp
CONST	SEGMENT
??_C@_0CA@KEHEBAKI@Grand?5Item?5Need?5Grand?5Reset?3?5?$CFd?$AA@ DB 'Gran'
	DB	'd Item Need Grand Reset: %d', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpObj$221713 = -8					; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_ItemNumber$ = 12					; size = 4
_target$ = 16						; size = 4
?MoveGRItem@cGrandHero@@QAE_NHHH@Z PROC			; cGrandHero::MoveGRItem
; _this$ = ecx

; 497  : {

  01550	55		 push	 ebp
  01551	8b ec		 mov	 ebp, esp
  01553	83 ec 48	 sub	 esp, 72			; 00000048H
  01556	53		 push	 ebx
  01557	56		 push	 esi
  01558	57		 push	 edi
  01559	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 498  : 	if(!this->Enable)return true;

  0155c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0155f	83 38 00	 cmp	 DWORD PTR [eax], 0
  01562	75 04		 jne	 SHORT $LN5@MoveGRItem
  01564	b0 01		 mov	 al, 1
  01566	eb 69		 jmp	 SHORT $LN6@MoveGRItem
$LN5@MoveGRItem:

; 499  : 
; 500  : 	if(this->SockeetItem(ItemNumber) == true && target >= 0 && target <= 6)

  01568	8b 45 0c	 mov	 eax, DWORD PTR _ItemNumber$[ebp]
  0156b	50		 push	 eax
  0156c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0156f	e8 00 00 00 00	 call	 ?SockeetItem@cGrandHero@@QAE_NH@Z ; cGrandHero::SockeetItem
  01574	0f b6 c8	 movzx	 ecx, al
  01577	83 f9 01	 cmp	 ecx, 1
  0157a	75 53		 jne	 SHORT $LN4@MoveGRItem
  0157c	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  01580	7c 4d		 jl	 SHORT $LN4@MoveGRItem
  01582	83 7d 10 06	 cmp	 DWORD PTR _target$[ebp], 6
  01586	7f 47		 jg	 SHORT $LN4@MoveGRItem

; 501  : 	{
; 502  : 		LPOBJ lpObj = &gObj[aIndex];

  01588	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0158b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01591	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01597	89 45 f8	 mov	 DWORD PTR _lpObj$221713[ebp], eax

; 503  : 		if(lpObj->GReset >= this->GRItem)

  0159a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$221713[ebp]
  0159d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015a0	8b 90 94 22 00
	00		 mov	 edx, DWORD PTR [eax+8852]
  015a6	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  015a9	7c 06		 jl	 SHORT $LN3@MoveGRItem

; 504  : 		{
; 505  : 			return true;

  015ab	b0 01		 mov	 al, 1
  015ad	eb 22		 jmp	 SHORT $LN6@MoveGRItem

; 506  : 		}
; 507  : 		else

  015af	eb 1c		 jmp	 SHORT $LN2@MoveGRItem
$LN3@MoveGRItem:

; 508  : 		{
; 509  : 			MsgNormal(aIndex, "Grand Item Need Grand Reset: %d", this->GRItem);

  015b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015b4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  015b7	51		 push	 ecx
  015b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KEHEBAKI@Grand?5Item?5Need?5Grand?5Reset?3?5?$CFd?$AA@
  015bd	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  015c0	52		 push	 edx
  015c1	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  015c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 510  : 			return false;

  015c9	32 c0		 xor	 al, al
  015cb	eb 04		 jmp	 SHORT $LN6@MoveGRItem
$LN2@MoveGRItem:

; 511  : 		}
; 512  : 	}
; 513  : 	else

  015cd	eb 02		 jmp	 SHORT $LN6@MoveGRItem
$LN4@MoveGRItem:

; 514  : 	{
; 515  : 		return true;

  015cf	b0 01		 mov	 al, 1
$LN6@MoveGRItem:

; 516  : 	}
; 517  : }

  015d1	5f		 pop	 edi
  015d2	5e		 pop	 esi
  015d3	5b		 pop	 ebx
  015d4	8b e5		 mov	 esp, ebp
  015d6	5d		 pop	 ebp
  015d7	c2 0c 00	 ret	 12			; 0000000cH
?MoveGRItem@cGrandHero@@QAE_NHHH@Z ENDP			; cGrandHero::MoveGRItem
_TEXT	ENDS
PUBLIC	?HeroMap@cGrandHero@@QAE_NH@Z			; cGrandHero::HeroMap
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iMap$ = 8						; size = 4
?HeroMap@cGrandHero@@QAE_NH@Z PROC			; cGrandHero::HeroMap
; _this$ = ecx

; 568  : {

  015e0	55		 push	 ebp
  015e1	8b ec		 mov	 ebp, esp
  015e3	83 ec 44	 sub	 esp, 68			; 00000044H
  015e6	53		 push	 ebx
  015e7	56		 push	 esi
  015e8	57		 push	 edi
  015e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 569  : 	if(!g_ExLicense.user.GrandHero) return false;

  015ec	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  015f3	85 c0		 test	 eax, eax
  015f5	75 04		 jne	 SHORT $LN3@HeroMap
  015f7	32 c0		 xor	 al, al
  015f9	eb 1d		 jmp	 SHORT $LN4@HeroMap
$LN3@HeroMap:

; 570  : 	if(!this->Enable) return false;

  015fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015fe	83 38 00	 cmp	 DWORD PTR [eax], 0
  01601	75 04		 jne	 SHORT $LN2@HeroMap
  01603	32 c0		 xor	 al, al
  01605	eb 11		 jmp	 SHORT $LN4@HeroMap
$LN2@HeroMap:

; 571  : 
; 572  : 	if(iMap == TPMap)

  01607	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0160a	8b 4d 08	 mov	 ecx, DWORD PTR _iMap$[ebp]
  0160d	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  01610	75 04		 jne	 SHORT $LN1@HeroMap

; 573  : 	{
; 574  : 		return true;

  01612	b0 01		 mov	 al, 1
  01614	eb 02		 jmp	 SHORT $LN4@HeroMap
$LN1@HeroMap:

; 575  : 	}
; 576  : 
; 577  : 	return false;

  01616	32 c0		 xor	 al, al
$LN4@HeroMap:

; 578  : }

  01618	5f		 pop	 edi
  01619	5e		 pop	 esi
  0161a	5b		 pop	 ebx
  0161b	8b e5		 mov	 esp, ebp
  0161d	5d		 pop	 ebp
  0161e	c2 04 00	 ret	 4
?HeroMap@cGrandHero@@QAE_NH@Z ENDP			; cGrandHero::HeroMap
_TEXT	ENDS
PUBLIC	??_C@_0BE@LPPOANDO@Need?5?$CFd?5Grand?5Reset?$AA@ ; `string'
PUBLIC	?CheckGRMap@cGrandHero@@QAEXH@Z			; cGrandHero::CheckGRMap
;	COMDAT ??_C@_0BE@LPPOANDO@Need?5?$CFd?5Grand?5Reset?$AA@
CONST	SEGMENT
??_C@_0BE@LPPOANDO@Need?5?$CFd?5Grand?5Reset?$AA@ DB 'Need %d Grand Reset'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CheckGRMap@cGrandHero@@QAEXH@Z PROC			; cGrandHero::CheckGRMap
; _this$ = ecx

; 581  : {

  01630	55		 push	 ebp
  01631	8b ec		 mov	 ebp, esp
  01633	83 ec 48	 sub	 esp, 72			; 00000048H
  01636	53		 push	 ebx
  01637	56		 push	 esi
  01638	57		 push	 edi
  01639	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 	if(!g_ExLicense.user.GrandHero) return;

  0163c	0f b6 05 ce 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+206
  01643	85 c0		 test	 eax, eax
  01645	75 02		 jne	 SHORT $LN3@CheckGRMap
  01647	eb 65		 jmp	 SHORT $LN4@CheckGRMap
$LN3@CheckGRMap:

; 583  : 	LPOBJ lpObj = &gObj[aIndex];

  01649	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0164c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01652	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01658	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 584  : 	if(lpObj->MapNumber == TPMap)

  0165b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0165e	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  01665	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01668	3b 4a 28	 cmp	 ecx, DWORD PTR [edx+40]
  0166b	75 41		 jne	 SHORT $LN4@CheckGRMap

; 585  : 	{
; 586  : 		if(lpObj->GReset < this->GRTp)

  0166d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01670	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01673	8b 90 94 22 00
	00		 mov	 edx, DWORD PTR [eax+8852]
  01679	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0167c	7d 30		 jge	 SHORT $LN4@CheckGRMap

; 587  : 		{
; 588  : 			MsgNormal(aIndex,"Need %d Grand Reset",this->GRTp);

  0167e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01681	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01684	51		 push	 ecx
  01685	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LPPOANDO@Need?5?$CFd?5Grand?5Reset?$AA@
  0168a	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0168d	52		 push	 edx
  0168e	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  01693	83 c4 0c	 add	 esp, 12			; 0000000cH

; 589  : 			gObjTeleport(aIndex,0,140,135);

  01696	68 87 00 00 00	 push	 135			; 00000087H
  0169b	68 8c 00 00 00	 push	 140			; 0000008cH
  016a0	6a 00		 push	 0
  016a2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  016a5	50		 push	 eax
  016a6	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  016ab	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@CheckGRMap:

; 590  : 		}
; 591  : 	}
; 592  : }

  016ae	5f		 pop	 edi
  016af	5e		 pop	 esi
  016b0	5b		 pop	 ebx
  016b1	8b e5		 mov	 esp, ebp
  016b3	5d		 pop	 ebp
  016b4	c2 04 00	 ret	 4
?CheckGRMap@cGrandHero@@QAEXH@Z ENDP			; cGrandHero::CheckGRMap
_TEXT	ENDS
PUBLIC	??A?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEAAUGRANDMIX_DATA@@I@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::operator[]
PUBLIC	?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_ItemIndex$ = -20					; size = 4
_ItemType$ = -16					; size = 4
_iRand$ = -12						; size = 4
_iSize$ = -8						; size = 4
_this$ = -4						; size = 4
?GetMixGrandData@cGrandHero@@QAEHXZ PROC		; cGrandHero::GetMixGrandData
; _this$ = ecx

; 595  : {

  016c0	55		 push	 ebp
  016c1	8b ec		 mov	 ebp, esp
  016c3	83 ec 54	 sub	 esp, 84			; 00000054H
  016c6	53		 push	 ebx
  016c7	56		 push	 esi
  016c8	57		 push	 edi
  016c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 596  : 	int iSize = this->m_MixData.size();

  016cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016cf	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  016d5	e8 00 00 00 00	 call	 ?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::size
  016da	89 45 f8	 mov	 DWORD PTR _iSize$[ebp], eax

; 597  : 
; 598  : 	if(iSize == 0)

  016dd	83 7d f8 00	 cmp	 DWORD PTR _iSize$[ebp], 0
  016e1	75 05		 jne	 SHORT $LN1@GetMixGran

; 599  : 	{
; 600  : 		return -1;

  016e3	83 c8 ff	 or	 eax, -1
  016e6	eb 44		 jmp	 SHORT $LN2@GetMixGran
$LN1@GetMixGran:

; 601  : 	}
; 602  : 
; 603  : 	int iRand = rand()%iSize;

  016e8	e8 00 00 00 00	 call	 _rand
  016ed	99		 cdq
  016ee	f7 7d f8	 idiv	 DWORD PTR _iSize$[ebp]
  016f1	89 55 f4	 mov	 DWORD PTR _iRand$[ebp], edx

; 604  : 
; 605  : 	int ItemType = this->m_MixData[iRand].iType;

  016f4	8b 45 f4	 mov	 eax, DWORD PTR _iRand$[ebp]
  016f7	50		 push	 eax
  016f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016fb	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  01701	e8 00 00 00 00	 call	 ??A?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEAAUGRANDMIX_DATA@@I@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::operator[]
  01706	8b 08		 mov	 ecx, DWORD PTR [eax]
  01708	89 4d f0	 mov	 DWORD PTR _ItemType$[ebp], ecx

; 606  : 	int ItemIndex = this->m_MixData[iRand].iIndex;

  0170b	8b 45 f4	 mov	 eax, DWORD PTR _iRand$[ebp]
  0170e	50		 push	 eax
  0170f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01712	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  01718	e8 00 00 00 00	 call	 ??A?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEAAUGRANDMIX_DATA@@I@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::operator[]
  0171d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01720	89 4d ec	 mov	 DWORD PTR _ItemIndex$[ebp], ecx

; 607  : 
; 608  : 	return ITEMGET(ItemType, ItemIndex);

  01723	8b 45 f0	 mov	 eax, DWORD PTR _ItemType$[ebp]
  01726	c1 e0 09	 shl	 eax, 9
  01729	03 45 ec	 add	 eax, DWORD PTR _ItemIndex$[ebp]
$LN2@GetMixGran:

; 609  : }

  0172c	5f		 pop	 edi
  0172d	5e		 pop	 esi
  0172e	5b		 pop	 ebx
  0172f	8b e5		 mov	 esp, ebp
  01731	5d		 pop	 ebp
  01732	c3		 ret	 0
?GetMixGrandData@cGrandHero@@QAEHXZ ENDP		; cGrandHero::GetMixGrandData
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEAAUGRANDMIX_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEAAUGRANDMIX_DATA@@I@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEAAUGRANDMIX_DATA@@I@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA &>
PUBLIC	?_Orphan_range@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXI@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBE_NPBUGRANDMIX_DATA@@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUGRANDMIX_DATA@@@std@@YAPBUGRANDMIX_DATA@@ABU1@@Z ; std::addressof<GRANDMIX_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXABUGRANDMIX_DATA@@@Z
_TEXT	SEGMENT
__Idx$221765 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXABUGRANDMIX_DATA@@@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUGRANDMIX_DATA@@@std@@YAPBUGRANDMIX_DATA@@ABU1@@Z ; std::addressof<GRANDMIX_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBE_NPBUGRANDMIX_DATA@@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUGRANDMIX_DATA@@@std@@YAPBUGRANDMIX_DATA@@ABU1@@Z ; std::addressof<GRANDMIX_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$221765[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXI@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$221765[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXI@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXABUGRANDMIX_DATA@@@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::erase
PUBLIC	?begin@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::begin
PUBLIC	?end@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T222713 = -88						; size = 4
$T222714 = -84						; size = 4
$T222715 = -80						; size = 4
$T222716 = -76						; size = 4
$T222717 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T222714[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T222713[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T222716[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T222715[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T222713[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T222715[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T222717[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Destroy
PUBLIC	??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00@Z ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T222724 = -84						; size = 4
__Ptr$221950 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00@Z ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$221950[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$221950[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$221950[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T222724[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T222724[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBE_NPBUGRANDMIX_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBE_NPBUGRANDMIX_DATA@@@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBE_NPBUGRANDMIX_DATA@@@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEII@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEII@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXPAUGRANDMIX_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXPAUGRANDMIX_DATA@@0@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXPAUGRANDMIX_DATA@@0@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z ; std::allocator<GRANDMIX_DATA>::deallocate
PUBLIC	??$_Umove@PAUGRANDMIX_DATA@@@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEPAUGRANDMIX_DATA@@PAU2@00@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Umove<GRANDMIX_DATA *>
PUBLIC	?allocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEPAUGRANDMIX_DATA@@I@Z ; std::allocator<GRANDMIX_DATA>::allocate
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$221992 = -28					; size = 4
__Ptr$221985 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEPAUGRANDMIX_DATA@@I@Z ; std::allocator<GRANDMIX_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$221985[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$221985[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUGRANDMIX_DATA@@@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEPAUGRANDMIX_DATA@@PAU2@00@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Umove<GRANDMIX_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221985[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z ; std::allocator<GRANDMIX_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$221992[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z ; std::allocator<GRANDMIX_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221985[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$221992[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221985[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$221985[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UGRANDMIX_DATA@@@std@@QBEIXZ ; std::allocator<GRANDMIX_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UGRANDMIX_DATA@@@std@@QBEIXZ ; std::allocator<GRANDMIX_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Xlen
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z PROC ; std::allocator<GRANDMIX_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z ENDP ; std::allocator<GRANDMIX_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@IPAU1@@Z ; std::_Allocate<GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEPAUGRANDMIX_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEPAUGRANDMIX_DATA@@I@Z PROC ; std::allocator<GRANDMIX_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@IPAU1@@Z ; std::_Allocate<GRANDMIX_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEPAUGRANDMIX_DATA@@I@Z ENDP ; std::allocator<GRANDMIX_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UGRANDMIX_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UGRANDMIX_DATA@@@std@@QBEIXZ PROC	; std::allocator<GRANDMIX_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UGRANDMIX_DATA@@@std@@QBEIXZ ENDP	; std::allocator<GRANDMIX_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QAE@PAUGRANDMIX_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUGRANDMIX_DATA@@@std@@YAPBUGRANDMIX_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUGRANDMIX_DATA@@@std@@YAPBUGRANDMIX_DATA@@ABU1@@Z PROC ; std::addressof<GRANDMIX_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUGRANDMIX_DATA@@@std@@YAPBUGRANDMIX_DATA@@ABU1@@Z ENDP ; std::addressof<GRANDMIX_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z ; std::allocator<GRANDMIX_DATA>::construct<GRANDMIX_DATA &>
PUBLIC	??$forward@AAUGRANDMIX_DATA@@@std@@YAAAUGRANDMIX_DATA@@AAU1@@Z ; std::forward<GRANDMIX_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUGRANDMIX_DATA@@@std@@YAAAUGRANDMIX_DATA@@AAU1@@Z ; std::forward<GRANDMIX_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z ; std::allocator<GRANDMIX_DATA>::construct<GRANDMIX_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@ABU3@@Z ; std::allocator<GRANDMIX_DATA>::construct
PUBLIC	??$forward@ABUGRANDMIX_DATA@@@std@@YAABUGRANDMIX_DATA@@ABU1@@Z ; std::forward<GRANDMIX_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUGRANDMIX_DATA@@@std@@YAABUGRANDMIX_DATA@@ABU1@@Z ; std::forward<GRANDMIX_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@ABU3@@Z ; std::allocator<GRANDMIX_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>
PUBLIC	??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z ; std::_Ptr_cat<GRANDMIX_DATA,GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T222792 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00@Z PROC ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z ; std::_Ptr_cat<GRANDMIX_DATA,GRANDMIX_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T222792[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T222792[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00@Z ENDP ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@@Z ; std::_Uninitialized_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUGRANDMIX_DATA@@@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEPAUGRANDMIX_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUGRANDMIX_DATA@@@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEPAUGRANDMIX_DATA@@PAU2@00@Z PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Umove<GRANDMIX_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@@Z ; std::_Uninitialized_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUGRANDMIX_DATA@@@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEPAUGRANDMIX_DATA@@PAU2@00@Z ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Umove<GRANDMIX_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@@Z
_TEXT	SEGMENT
$T222797 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z ; std::_Ptr_cat<GRANDMIX_DATA,GRANDMIX_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T222797[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T222797[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T222800 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@IPAU1@@Z PROC ; std::_Allocate<GRANDMIX_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T222800[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T222800[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@IPAU1@@Z ENDP ; std::_Allocate<GRANDMIX_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z ; std::_Construct<GRANDMIX_DATA,GRANDMIX_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@ABU3@@Z PROC ; std::allocator<GRANDMIX_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z ; std::_Construct<GRANDMIX_DATA,GRANDMIX_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@ABU3@@Z ENDP ; std::allocator<GRANDMIX_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUGRANDMIX_DATA@@@std@@YAAAUGRANDMIX_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUGRANDMIX_DATA@@@std@@YAAAUGRANDMIX_DATA@@AAU1@@Z PROC ; std::forward<GRANDMIX_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUGRANDMIX_DATA@@@std@@YAAAUGRANDMIX_DATA@@AAU1@@Z ENDP ; std::forward<GRANDMIX_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T222807 = -88						; size = 4
$T222808 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z PROC ; std::allocator<GRANDMIX_DATA>::construct<GRANDMIX_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T222808[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T222808[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUGRANDMIX_DATA@@@std@@YAAAUGRANDMIX_DATA@@AAU1@@Z ; std::forward<GRANDMIX_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T222808[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T222808[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T222807[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T222808[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUGRANDMIX_DATA@@@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@AAU2@@Z ENDP ; std::allocator<GRANDMIX_DATA>::construct<GRANDMIX_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUGRANDMIX_DATA@@@std@@YAABUGRANDMIX_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUGRANDMIX_DATA@@@std@@YAABUGRANDMIX_DATA@@ABU1@@Z PROC ; std::forward<GRANDMIX_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUGRANDMIX_DATA@@@std@@YAABUGRANDMIX_DATA@@ABU1@@Z ENDP ; std::forward<GRANDMIX_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z PROC ; std::_Ptr_cat<GRANDMIX_DATA,GRANDMIX_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z ENDP ; std::_Ptr_cat<GRANDMIX_DATA,GRANDMIX_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAUGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ; std::move<GRANDMIX_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ; std::move<GRANDMIX_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUGRANDMIX_DATA@@PAU1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<GRANDMIX_DATA *,GRANDMIX_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
PUBLIC	??$_Val_type@PAUGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@PAU1@@Z ; std::_Val_type<GRANDMIX_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@@Z
_TEXT	SEGMENT
$T222830 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@@Z PROC ; std::_Uninitialized_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UGRANDMIX_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDMIX_DATA@@0@Z ; std::_Ptr_cat<GRANDMIX_DATA,GRANDMIX_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T222830[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T222830[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@PAU1@@Z ; std::_Val_type<GRANDMIX_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@@Z ; std::_Dest_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@@Z ; std::_Dest_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@YAXPAUGRANDMIX_DATA@@0AAV?$allocator@UGRANDMIX_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<GRANDMIX_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T222835 = -88						; size = 4
$T222836 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z PROC ; std::_Construct<GRANDMIX_DATA,GRANDMIX_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T222836[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T222836[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUGRANDMIX_DATA@@@std@@YAABUGRANDMIX_DATA@@ABU1@@Z ; std::forward<GRANDMIX_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T222836[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T222836[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T222835[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T222836[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UGRANDMIX_DATA@@ABU1@@std@@YAXPAUGRANDMIX_DATA@@ABU1@@Z ENDP ; std::_Construct<GRANDMIX_DATA,GRANDMIX_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z PROC ; std::move<GRANDMIX_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ENDP ; std::move<GRANDMIX_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@PAU1@@Z PROC ; std::_Val_type<GRANDMIX_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUGRANDMIX_DATA@@@std@@YAPAUGRANDMIX_DATA@@PAU1@@Z ENDP ; std::_Val_type<GRANDMIX_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@@Z ; std::_Dest_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUGRANDMIX_DATA@@PAU1@V?$allocator@UGRANDMIX_DATA@@@std@@U1@@std@@YAPAUGRANDMIX_DATA@@PAU1@00AAV?$allocator@UGRANDMIX_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<GRANDMIX_DATA *,GRANDMIX_DATA *,std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
PUBLIC	?destroy@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@@Z ; std::allocator<GRANDMIX_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@@Z PROC ; std::_Dest_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@@Z ; std::allocator<GRANDMIX_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UGRANDMIX_DATA@@@std@@YAXPAUGRANDMIX_DATA@@@Z ; std::_Destroy<GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@@Z PROC ; std::allocator<GRANDMIX_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UGRANDMIX_DATA@@@std@@YAXPAUGRANDMIX_DATA@@@Z ; std::_Destroy<GRANDMIX_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@@Z ENDP ; std::allocator<GRANDMIX_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z ; std::allocator<GRANDMIX_DATA>::construct
PUBLIC	??$forward@UGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ; std::forward<GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ; std::forward<GRANDMIX_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z ; std::allocator<GRANDMIX_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UGRANDMIX_DATA@@@std@@UGRANDMIX_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDMIX_DATA@@@0@PAUGRANDMIX_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<GRANDMIX_DATA>,GRANDMIX_DATA,GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UGRANDMIX_DATA@@@std@@YAXPAUGRANDMIX_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UGRANDMIX_DATA@@@std@@YAXPAUGRANDMIX_DATA@@@Z PROC ; std::_Destroy<GRANDMIX_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UGRANDMIX_DATA@@@std@@YAXPAUGRANDMIX_DATA@@@Z ENDP ; std::_Destroy<GRANDMIX_DATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T222875 = -88						; size = 4
$T222876 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z PROC ; std::allocator<GRANDMIX_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T222876[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T222876[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ; std::forward<GRANDMIX_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T222876[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T222876[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T222875[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T222876[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@$$QAU3@@Z ENDP ; std::allocator<GRANDMIX_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z PROC ; std::forward<GRANDMIX_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UGRANDMIX_DATA@@@std@@YA$$QAUGRANDMIX_DATA@@AAU1@@Z ENDP ; std::forward<GRANDMIX_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0cGrandHero@@QAE@XZ				; cGrandHero::cGrandHero
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\grandherosystem.cpp
;	COMDAT ??__EGrandHero@@YAXXZ
text$yc	SEGMENT
??__EGrandHero@@YAXXZ PROC				; `dynamic initializer for 'GrandHero'', COMDAT

; 17   : cGrandHero GrandHero;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?GrandHero@@3VcGrandHero@@A ; GrandHero
  0000e	e8 00 00 00 00	 call	 ??0cGrandHero@@QAE@XZ
  00013	68 00 00 00 00	 push	 OFFSET ??__FGrandHero@@YAXXZ ; `dynamic atexit destructor for 'GrandHero''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EGrandHero@@YAXXZ ENDP				; `dynamic initializer for 'GrandHero''
text$yc	ENDS
PUBLIC	??0?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0cGrandHero@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0cGrandHero@@QAE@XZ PROC				; cGrandHero::cGrandHero, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  00015	e8 00 00 00 00	 call	 ??0?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??0cGrandHero@@QAE@XZ ENDP				; cGrandHero::cGrandHero
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDMIX_DATA@@@1@@Z ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
PUBLIC	??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@XZ	; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T222909 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T222909[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@XZ ; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDMIX_DATA@@@1@@Z ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDMIX_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDMIX_DATA@@@1@@Z PROC ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDMIX_DATA@@@1@@Z ENDP ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@XZ PROC	; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@XZ ENDP	; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UGRANDMIX_DATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<GRANDMIX_DATA>::allocator<GRANDMIX_DATA>
_TEXT	ENDS
PUBLIC	??1cGrandHero@@QAE@XZ				; cGrandHero::~cGrandHero
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FGrandHero@@YAXXZ
text$yd	SEGMENT
??__FGrandHero@@YAXXZ PROC				; `dynamic atexit destructor for 'GrandHero'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?GrandHero@@3VcGrandHero@@A ; GrandHero
  0000e	e8 00 00 00 00	 call	 ??1cGrandHero@@QAE@XZ
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FGrandHero@@YAXXZ ENDP				; `dynamic atexit destructor for 'GrandHero''
text$yd	ENDS
PUBLIC	??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1cGrandHero@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1cGrandHero@@QAE@XZ PROC				; cGrandHero::~cGrandHero, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 7c 06 00
	00		 add	 ecx, 1660		; 0000067cH
  00015	e8 00 00 00 00	 call	 ??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1cGrandHero@@QAE@XZ ENDP				; cGrandHero::~cGrandHero
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
PUBLIC	?_Tidy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXXZ ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
__ehhandler$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXPAUGRANDMIX_DATA@@0@Z ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UGRANDMIX_DATA@@@std@@QAEXPAUGRANDMIX_DATA@@I@Z ; std::allocator<GRANDMIX_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UGRANDMIX_DATA@@V?$allocator@UGRANDMIX_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >::~_Vector_val<GRANDMIX_DATA,std::allocator<GRANDMIX_DATA> >
_TEXT	ENDS
PUBLIC	?GrandHero@@3VcGrandHero@@A			; GrandHero
_BSS	SEGMENT
?GrandHero@@3VcGrandHero@@A DB 068cH DUP (?)		; GrandHero
_BSS	ENDS
CRT$XCU	SEGMENT
_GrandHero$initializer$ DD FLAT:??__EGrandHero@@YAXXZ
CRT$XCU	ENDS
END
