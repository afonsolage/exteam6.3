; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\DevilSquareGround.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
	DD	010eH
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?DevilSquareScoreSort@@YA_NABQAUOBJECTSTRUCT@@0@Z ; DevilSquareScoreSort
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\devilsquareground.cpp
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?DevilSquareScoreSort@@YA_NABQAUOBJECTSTRUCT@@0@Z PROC	; DevilSquareScoreSort

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 17   : 	if ( lhs->m_nEventScore == rhs->m_nEventScore )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	8b 89 90 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3728]
  00019	3b 88 90 0e 00
	00		 cmp	 ecx, DWORD PTR [eax+3728]
  0001f	75 24		 jne	 SHORT $LN3@DevilSquar

; 18   : 	{
; 19   : 		if ( lhs->Level < rhs->Level)

  00021	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	0f bf 91 be 00
	00 00		 movsx	 edx, WORD PTR [ecx+190]
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	0f bf 81 be 00
	00 00		 movsx	 eax, WORD PTR [ecx+190]
  00039	3b d0		 cmp	 edx, eax
  0003b	7d 04		 jge	 SHORT $LN2@DevilSquar

; 20   : 		{
; 21   : 			return true;

  0003d	b0 01		 mov	 al, 1
  0003f	eb 22		 jmp	 SHORT $LN4@DevilSquar
$LN2@DevilSquar:

; 22   : 		}
; 23   : 
; 24   : 		return false;

  00041	32 c0		 xor	 al, al
  00043	eb 1e		 jmp	 SHORT $LN4@DevilSquar
$LN3@DevilSquar:

; 25   : 	}
; 26   : 
; 27   : 	if ( lhs->m_nEventScore > rhs->m_nEventScore)

  00045	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  0004d	8b 02		 mov	 eax, DWORD PTR [edx]
  0004f	8b 89 90 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3728]
  00055	3b 88 90 0e 00
	00		 cmp	 ecx, DWORD PTR [eax+3728]
  0005b	7e 04		 jle	 SHORT $LN1@DevilSquar

; 28   : 	{
; 29   : 		return true;

  0005d	b0 01		 mov	 al, 1
  0005f	eb 02		 jmp	 SHORT $LN4@DevilSquar
$LN1@DevilSquar:

; 30   : 	}
; 31   : 
; 32   : 	return false;

  00061	32 c0		 xor	 al, al
$LN4@DevilSquar:

; 33   : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?DevilSquareScoreSort@@YA_NABQAUOBJECTSTRUCT@@0@Z ENDP	; DevilSquareScoreSort
_TEXT	ENDS
PUBLIC	??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
PUBLIC	?Init@CDevilSquareGround@@QAEXH@Z		; CDevilSquareGround::Init
PUBLIC	??0?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
PUBLIC	??_7CDevilSquareGround@@6B@			; CDevilSquareGround::`vftable'
PUBLIC	??0CDevilSquareGround@@QAE@XZ			; CDevilSquareGround::CDevilSquareGround
PUBLIC	??_R4CDevilSquareGround@@6B@			; CDevilSquareGround::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDevilSquareGround@@@8			; CDevilSquareGround `RTTI Type Descriptor'
PUBLIC	??_R3CDevilSquareGround@@8			; CDevilSquareGround::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDevilSquareGround@@8			; CDevilSquareGround::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDevilSquareGround@@8		; CDevilSquareGround::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECDevilSquareGround@@UAEPAXI@Z:PROC		; CDevilSquareGround::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CDevilSquareGround@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDevilSquareGround@@8 DD FLAT:??_R0?AVCDevilSquareGround@@@8 ; CDevilSquareGround::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDevilSquareGround@@8
rdata$r	ENDS
;	COMDAT ??_R2CDevilSquareGround@@8
rdata$r	SEGMENT
??_R2CDevilSquareGround@@8 DD FLAT:??_R1A@?0A@EA@CDevilSquareGround@@8 ; CDevilSquareGround::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDevilSquareGround@@8
rdata$r	SEGMENT
??_R3CDevilSquareGround@@8 DD 00H			; CDevilSquareGround::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDevilSquareGround@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDevilSquareGround@@@8
_DATA	SEGMENT
??_R0?AVCDevilSquareGround@@@8 DD FLAT:??_7type_info@@6B@ ; CDevilSquareGround `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDevilSquareGround@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDevilSquareGround@@6B@
rdata$r	SEGMENT
??_R4CDevilSquareGround@@6B@ DD 00H			; CDevilSquareGround::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDevilSquareGround@@@8
	DD	FLAT:??_R3CDevilSquareGround@@8
rdata$r	ENDS
;	COMDAT ??_7CDevilSquareGround@@6B@
CONST	SEGMENT
??_7CDevilSquareGround@@6B@ DD FLAT:??_R4CDevilSquareGround@@6B@ ; CDevilSquareGround::`vftable'
	DD	FLAT:??_ECDevilSquareGround@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CDevilSquareGround@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDevilSquareGround@@QAE@XZ$0
__ehfuncinfo$??0CDevilSquareGround@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CDevilSquareGround@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDevilSquareGround@@QAE@XZ PROC			; CDevilSquareGround::CDevilSquareGround
; _this$ = ecx

; 36   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	6a ff		 push	 -1
  00075	68 00 00 00 00	 push	 __ehhandler$??0CDevilSquareGround@@QAE@XZ
  0007a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00080	50		 push	 eax
  00081	83 ec 44	 sub	 esp, 68			; 00000044H
  00084	53		 push	 ebx
  00085	56		 push	 esi
  00086	57		 push	 edi
  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0008c	33 c5		 xor	 eax, ebp
  0008e	50		 push	 eax
  0008f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00092	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00098	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDevilSquareGround@@6B@
  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  000ad	e8 00 00 00 00	 call	 ??0?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
  000b2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 37   : 	this->Init(0);

  000b9	6a 00		 push	 0
  000bb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?Init@CDevilSquareGround@@QAEXH@Z ; CDevilSquareGround::Init

; 38   : }

  000c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ca	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CDevilSquareGround@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
__ehhandler$??0CDevilSquareGround@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDevilSquareGround@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDevilSquareGround@@QAE@XZ ENDP			; CDevilSquareGround::CDevilSquareGround
PUBLIC	??1CDevilSquareGround@@UAE@XZ			; CDevilSquareGround::~CDevilSquareGround
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCDevilSquareGround@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDevilSquareGround@@UAEPAXI@Z PROC			; CDevilSquareGround::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CDevilSquareGround@@UAE@XZ ; CDevilSquareGround::~CDevilSquareGround
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCDevilSquareGround@@UAEPAXI@Z ENDP			; CDevilSquareGround::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CDevilSquareGround@@UAE@XZ PROC			; CDevilSquareGround::~CDevilSquareGround
; _this$ = ecx

; 41   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	83 ec 44	 sub	 esp, 68			; 00000044H
  000e6	53		 push	 ebx
  000e7	56		 push	 esi
  000e8	57		 push	 edi
  000e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDevilSquareGround@@6B@

; 42   : 	//Dark Wizard until 4th Floor
; 43   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_1] = 0;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	c7 80 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1052], 0

; 44   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_2] = 0;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00105	c7 80 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1056], 0

; 45   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_3] = 0;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00112	c7 80 24 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1060], 0

; 46   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_4] = 170;

  0011c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	c7 80 28 04 00
	00 aa 00 00 00	 mov	 DWORD PTR [eax+1064], 170 ; 000000aaH

; 47   : 	
; 48   : 	//Dark Knight until 4th Floor
; 49   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_1] = 20;

  00129	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	c7 80 38 04 00
	00 14 00 00 00	 mov	 DWORD PTR [eax+1080], 20 ; 00000014H

; 50   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_2] = 90;

  00136	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00139	c7 80 3c 04 00
	00 5a 00 00 00	 mov	 DWORD PTR [eax+1084], 90 ; 0000005aH

; 51   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_3] = 120;

  00143	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00146	c7 80 40 04 00
	00 78 00 00 00	 mov	 DWORD PTR [eax+1088], 120 ; 00000078H

; 52   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_4] = 400;

  00150	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00153	c7 80 44 04 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+1092], 400 ; 00000190H

; 53   : 
; 54   : 	//Elf until 4th Floor
; 55   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_1] = 10;

  0015d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00160	c7 80 54 04 00
	00 0a 00 00 00	 mov	 DWORD PTR [eax+1108], 10 ; 0000000aH

; 56   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_2] = 10;

  0016a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	c7 80 58 04 00
	00 0a 00 00 00	 mov	 DWORD PTR [eax+1112], 10 ; 0000000aH

; 57   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_3] = 10;

  00177	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	c7 80 5c 04 00
	00 0a 00 00 00	 mov	 DWORD PTR [eax+1116], 10 ; 0000000aH

; 58   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_4] = 200;

  00184	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00187	c7 80 60 04 00
	00 c8 00 00 00	 mov	 DWORD PTR [eax+1120], 200 ; 000000c8H

; 59   : 
; 60   : 	//Magumsa until 4th Floor
; 61   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_1] = 0;

  00191	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00194	c7 80 70 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1136], 0

; 62   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_2] = 0;

  0019e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a1	c7 80 74 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1140], 0

; 63   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_3] = 0;

  001ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ae	c7 80 78 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1144], 0

; 64   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_4] = 0;

  001b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	c7 80 7c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1148], 0

; 65   : 
; 66   : 	//Dark Wizard 5th & 6th Floor
; 67   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_5] = 170;

  001c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c8	c7 80 2c 04 00
	00 aa 00 00 00	 mov	 DWORD PTR [eax+1068], 170 ; 000000aaH

; 68   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_6] = 170;

  001d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d5	c7 80 30 04 00
	00 aa 00 00 00	 mov	 DWORD PTR [eax+1072], 170 ; 000000aaH

; 69   : 
; 70   : 	//Dark Knight 5th & 6th Floor
; 71   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_5] = 400;

  001df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	c7 80 48 04 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+1096], 400 ; 00000190H

; 72   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_6] = 400;

  001ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	c7 80 4c 04 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+1100], 400 ; 00000190H

; 73   : 
; 74   : 	//Elf 5th & 6th Floor
; 75   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_5] = 200;

  001f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001fc	c7 80 64 04 00
	00 c8 00 00 00	 mov	 DWORD PTR [eax+1124], 200 ; 000000c8H

; 76   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_6] = 200;

  00206	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00209	c7 80 68 04 00
	00 c8 00 00 00	 mov	 DWORD PTR [eax+1128], 200 ; 000000c8H

; 77   : 
; 78   : 	//Magumsa 5th & 6th Floor
; 79   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_5] = 0;

  00213	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00216	c7 80 80 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1152], 0

; 80   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_6] = 0;

  00220	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00223	c7 80 84 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1156], 0

; 81   : 
; 82   : 	//Dark Lord All Floors
; 83   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_1] = 0;

  0022d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00230	c7 80 8c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1164], 0

; 84   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_2] = 0;

  0023a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	c7 80 90 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1168], 0

; 85   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_3] = 0;

  00247	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0024a	c7 80 94 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1172], 0

; 86   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_4] = 0;

  00254	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00257	c7 80 98 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1176], 0

; 87   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_5] = 0;

  00261	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00264	c7 80 9c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1180], 0

; 88   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_6] = 0;

  0026e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00271	c7 80 a0 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1184], 0

; 89   : 
; 90   : 	//Season3 add-on (All Classes 7th Floor)
; 91   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_7] = 170;

  0027b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0027e	c7 80 34 04 00
	00 aa 00 00 00	 mov	 DWORD PTR [eax+1076], 170 ; 000000aaH

; 92   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_7] = 400;

  00288	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	c7 80 50 04 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+1104], 400 ; 00000190H

; 93   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_7] = 200;

  00295	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00298	c7 80 6c 04 00
	00 c8 00 00 00	 mov	 DWORD PTR [eax+1132], 200 ; 000000c8H

; 94   : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_7] = 0;

  002a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a5	c7 80 88 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1160], 0

; 95   : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_7] = 0;

  002af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002b2	c7 80 a4 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1188], 0

; 96   : }

  002bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bf	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  002c5	e8 00 00 00 00	 call	 ??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
  002ca	5f		 pop	 edi
  002cb	5e		 pop	 esi
  002cc	5b		 pop	 ebx
  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c3		 ret	 0
??1CDevilSquareGround@@UAE@XZ ENDP			; CDevilSquareGround::~CDevilSquareGround
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Index$ = 8						; size = 4
?Init@CDevilSquareGround@@QAEXH@Z PROC			; CDevilSquareGround::Init
; _this$ = ecx

; 99   : {

  002e0	55		 push	 ebp
  002e1	8b ec		 mov	 ebp, esp
  002e3	83 ec 44	 sub	 esp, 68			; 00000044H
  002e6	53		 push	 ebx
  002e7	56		 push	 esi
  002e8	57		 push	 edi
  002e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : 	this->m_dwObjCount = 0;

  002ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ef	c7 80 18 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1048], 0

; 101  : 	this->m_iIndex = Index;

  002f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002fc	8b 4d 08	 mov	 ecx, DWORD PTR _Index$[ebp]
  002ff	89 88 f4 03 00
	00		 mov	 DWORD PTR [eax+1012], ecx

; 102  : 	memset(this->m_DevilSquareMonsterInfo, 0xFF, sizeof(this->m_DevilSquareMonsterInfo));

  00305	68 f0 00 00 00	 push	 240			; 000000f0H
  0030a	68 ff 00 00 00	 push	 255			; 000000ffH
  0030f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00312	83 c0 04	 add	 eax, 4
  00315	50		 push	 eax
  00316	e8 00 00 00 00	 call	 _memset
  0031b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 103  : 	memset(this->m_DevilSquareBossMonsterInfo, 0xFF, sizeof(this->m_DevilSquareBossMonsterInfo));

  0031e	68 e0 01 00 00	 push	 480			; 000001e0H
  00323	68 ff 00 00 00	 push	 255			; 000000ffH
  00328	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0032b	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 _memset
  00336	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  : }

  00339	5f		 pop	 edi
  0033a	5e		 pop	 esi
  0033b	5b		 pop	 ebx
  0033c	8b e5		 mov	 esp, ebp
  0033e	5d		 pop	 ebp
  0033f	c2 04 00	 ret	 4
?Init@CDevilSquareGround@@QAEXH@Z ENDP			; CDevilSquareGround::Init
_TEXT	ENDS
PUBLIC	?Clear@CDevilSquareGround@@QAEXXZ		; CDevilSquareGround::Clear
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CDevilSquareGround@@QAEXXZ PROC			; CDevilSquareGround::Clear
; _this$ = ecx

; 107  : {

  00350	55		 push	 ebp
  00351	8b ec		 mov	 ebp, esp
  00353	83 ec 44	 sub	 esp, 68			; 00000044H
  00356	53		 push	 ebx
  00357	56		 push	 esi
  00358	57		 push	 edi
  00359	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 108  : 	this->m_dwObjCount = 0;

  0035c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0035f	c7 80 18 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1048], 0

; 109  : }

  00369	5f		 pop	 edi
  0036a	5e		 pop	 esi
  0036b	5b		 pop	 ebx
  0036c	8b e5		 mov	 esp, ebp
  0036e	5d		 pop	 ebp
  0036f	c3		 ret	 0
?Clear@CDevilSquareGround@@QAEXXZ ENDP			; CDevilSquareGround::Clear
_TEXT	ENDS
PUBLIC	?Set@CDevilSquareGround@@QAEXGHH@Z		; CDevilSquareGround::Set
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$229520 = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
_starttime$ = 12					; size = 4
_endtime$ = 16						; size = 4
?Set@CDevilSquareGround@@QAEXGHH@Z PROC			; CDevilSquareGround::Set
; _this$ = ecx

; 112  : {

  00370	55		 push	 ebp
  00371	8b ec		 mov	 ebp, esp
  00373	83 ec 48	 sub	 esp, 72			; 00000048H
  00376	53		 push	 ebx
  00377	56		 push	 esi
  00378	57		 push	 edi
  00379	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	for (int i=0;i<MAX_ST_DEVILSQUARE_MONSTER;i++)

  0037c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$229520[ebp], 0
  00383	eb 09		 jmp	 SHORT $LN4@Set
$LN3@Set:
  00385	8b 45 f8	 mov	 eax, DWORD PTR _i$229520[ebp]
  00388	83 c0 01	 add	 eax, 1
  0038b	89 45 f8	 mov	 DWORD PTR _i$229520[ebp], eax
$LN4@Set:
  0038e	83 7d f8 0f	 cmp	 DWORD PTR _i$229520[ebp], 15 ; 0000000fH
  00392	7d 62		 jge	 SHORT $LN5@Set

; 114  : 	{
; 115  : 		if ( this->m_DevilSquareMonsterInfo[i].m_Type == (WORD)-1  )

  00394	8b 45 f8	 mov	 eax, DWORD PTR _i$229520[ebp]
  00397	c1 e0 04	 shl	 eax, 4
  0039a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039d	0f b7 54 01 04	 movzx	 edx, WORD PTR [ecx+eax+4]
  003a2	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  003a8	75 4a		 jne	 SHORT $LN1@Set

; 116  : 		{
; 117  : 			this->m_DevilSquareMonsterInfo[i].m_Type = type;

  003aa	8b 45 f8	 mov	 eax, DWORD PTR _i$229520[ebp]
  003ad	c1 e0 04	 shl	 eax, 4
  003b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	66 8b 55 08	 mov	 dx, WORD PTR _type$[ebp]
  003b7	66 89 54 01 04	 mov	 WORD PTR [ecx+eax+4], dx

; 118  : 			this->m_DevilSquareMonsterInfo[i].m_RegenStartTime = starttime;

  003bc	8b 45 f8	 mov	 eax, DWORD PTR _i$229520[ebp]
  003bf	c1 e0 04	 shl	 eax, 4
  003c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c5	8b 55 0c	 mov	 edx, DWORD PTR _starttime$[ebp]
  003c8	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 119  : 			this->m_DevilSquareMonsterInfo[i].m_RegenEndTime = endtime;

  003cc	8b 45 f8	 mov	 eax, DWORD PTR _i$229520[ebp]
  003cf	c1 e0 04	 shl	 eax, 4
  003d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003d5	8b 55 10	 mov	 edx, DWORD PTR _endtime$[ebp]
  003d8	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 120  : 			this->m_DevilSquareMonsterInfo[i].m_iDevilSquareNumber = this->m_iIndex;

  003dc	8b 45 f8	 mov	 eax, DWORD PTR _i$229520[ebp]
  003df	c1 e0 04	 shl	 eax, 4
  003e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003e8	8b 92 f4 03 00
	00		 mov	 edx, DWORD PTR [edx+1012]
  003ee	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx

; 121  : 			
; 122  : 			return;

  003f2	eb 02		 jmp	 SHORT $LN5@Set
$LN1@Set:

; 123  : 		}
; 124  : 	}

  003f4	eb 8f		 jmp	 SHORT $LN3@Set
$LN5@Set:

; 125  : }

  003f6	5f		 pop	 edi
  003f7	5e		 pop	 esi
  003f8	5b		 pop	 ebx
  003f9	8b e5		 mov	 esp, ebp
  003fb	5d		 pop	 ebp
  003fc	c2 0c 00	 ret	 12			; 0000000cH
?Set@CDevilSquareGround@@QAEXGHH@Z ENDP			; CDevilSquareGround::Set
_TEXT	ENDS
PUBLIC	?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z	; CDevilSquareGround::SetBoss
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$229535 = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
_starttime$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_tx$ = 24						; size = 4
_ty$ = 28						; size = 4
?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z PROC		; CDevilSquareGround::SetBoss
; _this$ = ecx

; 128  : {

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	83 ec 48	 sub	 esp, 72			; 00000048H
  00406	53		 push	 ebx
  00407	56		 push	 esi
  00408	57		 push	 edi
  00409	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  : 	for (int i=0;i<MAX_ST_DEVILSQUARE_MONSTER;i++)

  0040c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$229535[ebp], 0
  00413	eb 09		 jmp	 SHORT $LN4@SetBoss
$LN3@SetBoss:
  00415	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  00418	83 c0 01	 add	 eax, 1
  0041b	89 45 f8	 mov	 DWORD PTR _i$229535[ebp], eax
$LN4@SetBoss:
  0041e	83 7d f8 0f	 cmp	 DWORD PTR _i$229535[ebp], 15 ; 0000000fH
  00422	0f 8d b1 00 00
	00		 jge	 $LN5@SetBoss

; 130  : 	{
; 131  : 		if ( this->m_DevilSquareBossMonsterInfo[i].m_Type == (WORD)-1  )

  00428	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  0042b	c1 e0 05	 shl	 eax, 5
  0042e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00431	0f b7 94 01 f4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+244]
  00439	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0043f	0f 85 8f 00 00
	00		 jne	 $LN1@SetBoss

; 132  : 		{
; 133  : 			this->m_DevilSquareBossMonsterInfo[i].m_Type = type;

  00445	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  00448	c1 e0 05	 shl	 eax, 5
  0044b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0044e	66 8b 55 08	 mov	 dx, WORD PTR _type$[ebp]
  00452	66 89 94 01 f4
	00 00 00	 mov	 WORD PTR [ecx+eax+244], dx

; 134  : 			this->m_DevilSquareBossMonsterInfo[i].m_RegenStartTime = starttime;

  0045a	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  0045d	c1 e0 05	 shl	 eax, 5
  00460	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00463	8b 55 0c	 mov	 edx, DWORD PTR _starttime$[ebp]
  00466	89 94 01 f8 00
	00 00		 mov	 DWORD PTR [ecx+eax+248], edx

; 135  : 			this->m_DevilSquareBossMonsterInfo[i].X = x;

  0046d	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  00470	c1 e0 05	 shl	 eax, 5
  00473	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00476	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  00479	89 94 01 00 01
	00 00		 mov	 DWORD PTR [ecx+eax+256], edx

; 136  : 			this->m_DevilSquareBossMonsterInfo[i].Y = y;

  00480	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  00483	c1 e0 05	 shl	 eax, 5
  00486	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00489	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  0048c	89 94 01 04 01
	00 00		 mov	 DWORD PTR [ecx+eax+260], edx

; 137  : 			this->m_DevilSquareBossMonsterInfo[i].TX = tx;

  00493	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  00496	c1 e0 05	 shl	 eax, 5
  00499	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0049c	8b 55 18	 mov	 edx, DWORD PTR _tx$[ebp]
  0049f	89 94 01 08 01
	00 00		 mov	 DWORD PTR [ecx+eax+264], edx

; 138  : 			this->m_DevilSquareBossMonsterInfo[i].TY = ty;

  004a6	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  004a9	c1 e0 05	 shl	 eax, 5
  004ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004af	8b 55 1c	 mov	 edx, DWORD PTR _ty$[ebp]
  004b2	89 94 01 0c 01
	00 00		 mov	 DWORD PTR [ecx+eax+268], edx

; 139  : 			this->m_DevilSquareBossMonsterInfo[i].m_iDevilSquareNumber = this->m_iIndex;

  004b9	8b 45 f8	 mov	 eax, DWORD PTR _i$229535[ebp]
  004bc	c1 e0 05	 shl	 eax, 5
  004bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004c5	8b 92 f4 03 00
	00		 mov	 edx, DWORD PTR [edx+1012]
  004cb	89 94 01 10 01
	00 00		 mov	 DWORD PTR [ecx+eax+272], edx

; 140  : 			
; 141  : 			return;

  004d2	eb 05		 jmp	 SHORT $LN5@SetBoss
$LN1@SetBoss:

; 142  : 		}
; 143  : 	}

  004d4	e9 3c ff ff ff	 jmp	 $LN3@SetBoss
$LN5@SetBoss:

; 144  : }

  004d9	5f		 pop	 edi
  004da	5e		 pop	 esi
  004db	5b		 pop	 ebx
  004dc	8b e5		 mov	 esp, ebp
  004de	5d		 pop	 ebp
  004df	c2 18 00	 ret	 24			; 00000018H
?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z ENDP		; CDevilSquareGround::SetBoss
_TEXT	ENDS
PUBLIC	?SetBonus@CDevilSquareGround@@QAEXHHH@Z		; CDevilSquareGround::SetBonus
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_zen$ = 12						; size = 4
_exp$ = 16						; size = 4
?SetBonus@CDevilSquareGround@@QAEXHHH@Z PROC		; CDevilSquareGround::SetBonus
; _this$ = ecx

; 147  : {

  004f0	55		 push	 ebp
  004f1	8b ec		 mov	 ebp, esp
  004f3	83 ec 44	 sub	 esp, 68			; 00000044H
  004f6	53		 push	 ebx
  004f7	56		 push	 esi
  004f8	57		 push	 edi
  004f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 	this->m_Bonus[index][0] = exp;

  004fc	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  004ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00502	8b 55 10	 mov	 edx, DWORD PTR _exp$[ebp]
  00505	89 94 c1 f8 03
	00 00		 mov	 DWORD PTR [ecx+eax*8+1016], edx

; 149  : 	this->m_Bonus[index][1] = zen;

  0050c	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0050f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00512	8b 55 0c	 mov	 edx, DWORD PTR _zen$[ebp]
  00515	89 94 c1 fc 03
	00 00		 mov	 DWORD PTR [ecx+eax*8+1020], edx

; 150  : }

  0051c	5f		 pop	 edi
  0051d	5e		 pop	 esi
  0051e	5b		 pop	 ebx
  0051f	8b e5		 mov	 esp, ebp
  00521	5d		 pop	 ebp
  00522	c2 0c 00	 ret	 12			; 0000000cH
?SetBonus@CDevilSquareGround@@QAEXHHH@Z ENDP		; CDevilSquareGround::SetBonus
_TEXT	ENDS
PUBLIC	?IncExp@CDevilSquareGround@@QAEXM@Z		; CDevilSquareGround::IncExp
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$229551 = -8						; size = 4
_this$ = -4						; size = 4
_exp$ = 8						; size = 4
?IncExp@CDevilSquareGround@@QAEXM@Z PROC		; CDevilSquareGround::IncExp
; _this$ = ecx

; 153  : {

  00530	55		 push	 ebp
  00531	8b ec		 mov	 ebp, esp
  00533	83 ec 48	 sub	 esp, 72			; 00000048H
  00536	53		 push	 ebx
  00537	56		 push	 esi
  00538	57		 push	 edi
  00539	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	for( int i = 0; i < 4; i++)

  0053c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$229551[ebp], 0
  00543	eb 09		 jmp	 SHORT $LN3@IncExp
$LN2@IncExp:
  00545	8b 45 f8	 mov	 eax, DWORD PTR _i$229551[ebp]
  00548	83 c0 01	 add	 eax, 1
  0054b	89 45 f8	 mov	 DWORD PTR _i$229551[ebp], eax
$LN3@IncExp:
  0054e	83 7d f8 04	 cmp	 DWORD PTR _i$229551[ebp], 4
  00552	7d 25		 jge	 SHORT $LN1@IncExp

; 155  : 	{
; 156  : 		this->m_Bonus[i][1] *= (int)exp; //check

  00554	d9 45 08	 fld	 DWORD PTR _exp$[ebp]
  00557	e8 00 00 00 00	 call	 __ftol2_sse
  0055c	8b 4d f8	 mov	 ecx, DWORD PTR _i$229551[ebp]
  0055f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00562	0f af 84 ca fc
	03 00 00	 imul	 eax, DWORD PTR [edx+ecx*8+1020]
  0056a	8b 4d f8	 mov	 ecx, DWORD PTR _i$229551[ebp]
  0056d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00570	89 84 ca fc 03
	00 00		 mov	 DWORD PTR [edx+ecx*8+1020], eax

; 157  : 	}

  00577	eb cc		 jmp	 SHORT $LN2@IncExp
$LN1@IncExp:

; 158  : }

  00579	5f		 pop	 edi
  0057a	5e		 pop	 esi
  0057b	5b		 pop	 ebx
  0057c	8b e5		 mov	 esp, ebp
  0057e	5d		 pop	 ebp
  0057f	c2 04 00	 ret	 4
?IncExp@CDevilSquareGround@@QAEXM@Z ENDP		; CDevilSquareGround::IncExp
_TEXT	ENDS
PUBLIC	?IncObjCount@CDevilSquareGround@@QAEXXZ		; CDevilSquareGround::IncObjCount
EXTRN	__imp__InterlockedIncrement@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncObjCount@CDevilSquareGround@@QAEXXZ PROC		; CDevilSquareGround::IncObjCount
; _this$ = ecx

; 161  : {

  00590	55		 push	 ebp
  00591	8b ec		 mov	 ebp, esp
  00593	83 ec 44	 sub	 esp, 68			; 00000044H
  00596	53		 push	 ebx
  00597	56		 push	 esi
  00598	57		 push	 edi
  00599	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	InterlockedIncrement((LPLONG)&this->m_dwObjCount);

  0059c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0059f	05 18 04 00 00	 add	 eax, 1048		; 00000418H
  005a4	50		 push	 eax
  005a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4

; 163  : }

  005ab	5f		 pop	 edi
  005ac	5e		 pop	 esi
  005ad	5b		 pop	 ebx
  005ae	8b e5		 mov	 esp, ebp
  005b0	5d		 pop	 ebp
  005b1	c3		 ret	 0
?IncObjCount@CDevilSquareGround@@QAEXXZ ENDP		; CDevilSquareGround::IncObjCount
_TEXT	ENDS
PUBLIC	?GetObjCount@CDevilSquareGround@@QAEJXZ		; CDevilSquareGround::GetObjCount
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjCount@CDevilSquareGround@@QAEJXZ PROC		; CDevilSquareGround::GetObjCount
; _this$ = ecx

; 166  : {

  005c0	55		 push	 ebp
  005c1	8b ec		 mov	 ebp, esp
  005c3	83 ec 44	 sub	 esp, 68			; 00000044H
  005c6	53		 push	 ebx
  005c7	56		 push	 esi
  005c8	57		 push	 edi
  005c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 167  : 	return this->m_dwObjCount;

  005cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005cf	8b 80 18 04 00
	00		 mov	 eax, DWORD PTR [eax+1048]

; 168  : }

  005d5	5f		 pop	 edi
  005d6	5e		 pop	 esi
  005d7	5b		 pop	 ebx
  005d8	8b e5		 mov	 esp, ebp
  005da	5d		 pop	 ebp
  005db	c3		 ret	 0
?GetObjCount@CDevilSquareGround@@QAEJXZ ENDP		; CDevilSquareGround::GetObjCount
_TEXT	ENDS
PUBLIC	??_C@_0CE@EDJNDEMF@?$FLDevilSquare?$FN?5Boss?5?$CFd?5?$CFd?5?$CFd?5crea@ ; `string'
PUBLIC	?RegenBossMonster@CDevilSquareGround@@QAEXH@Z	; CDevilSquareGround::RegenBossMonster
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z:PROC ; CMonsterSetBase::GetBoxPosition
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
;	COMDAT ??_C@_0CE@EDJNDEMF@?$FLDevilSquare?$FN?5Boss?5?$CFd?5?$CFd?5?$CFd?5crea@
CONST	SEGMENT
??_C@_0CE@EDJNDEMF@?$FLDevilSquare?$FN?5Boss?5?$CFd?5?$CFd?5?$CFd?5crea@ DB '['
	DB	'DevilSquare] Boss %d %d %d create ', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv128 = -100						; size = 4
tv129 = -96						; size = 4
_y$229579 = -28						; size = 4
_x$229578 = -24						; size = 4
_map$229577 = -20					; size = 4
_iMonIndex$229575 = -16					; size = 4
_iMapNumber$229574 = -12				; size = 4
_i$229567 = -8						; size = 4
_this$ = -4						; size = 4
_currtime$ = 8						; size = 4
?RegenBossMonster@CDevilSquareGround@@QAEXH@Z PROC	; CDevilSquareGround::RegenBossMonster
; _this$ = ecx

; 171  : {

  005e0	55		 push	 ebp
  005e1	8b ec		 mov	 ebp, esp
  005e3	83 ec 64	 sub	 esp, 100		; 00000064H
  005e6	53		 push	 ebx
  005e7	56		 push	 esi
  005e8	57		 push	 edi
  005e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 172  : 	for ( int i=0;i<MAX_ST_DEVILSQUARE_MONSTER;i++)

  005ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$229567[ebp], 0
  005f3	eb 09		 jmp	 SHORT $LN6@RegenBossM
$LN5@RegenBossM:
  005f5	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  005f8	83 c0 01	 add	 eax, 1
  005fb	89 45 f8	 mov	 DWORD PTR _i$229567[ebp], eax
$LN6@RegenBossM:
  005fe	83 7d f8 0f	 cmp	 DWORD PTR _i$229567[ebp], 15 ; 0000000fH
  00602	0f 8d 89 03 00
	00		 jge	 $LN7@RegenBossM

; 173  : 	{
; 174  : 		if ( this->m_DevilSquareBossMonsterInfo[i].m_Type != (WORD)-1 )

  00608	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  0060b	c1 e0 05	 shl	 eax, 5
  0060e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00611	0f b7 94 01 f4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+244]
  00619	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0061f	0f 84 67 03 00
	00		 je	 $LN3@RegenBossM

; 175  : 		{
; 176  : 			if ( currtime == this->m_DevilSquareBossMonsterInfo[i].m_RegenStartTime )

  00625	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00628	c1 e0 05	 shl	 eax, 5
  0062b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0062e	8b 55 08	 mov	 edx, DWORD PTR _currtime$[ebp]
  00631	3b 94 01 f8 00
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+248]
  00638	0f 85 4e 03 00
	00		 jne	 $LN3@RegenBossM

; 177  : 			{
; 178  : 				int iMapNumber = (this->m_DevilSquareBossMonsterInfo[i].m_iDevilSquareNumber >= DEVIL_SQUARE_GROUND_1&& this->m_DevilSquareBossMonsterInfo[i].m_iDevilSquareNumber <= DEVIL_SQUARE_GROUND_4)?MAP_INDEX_DEVILSQUARE:(this->m_DevilSquareBossMonsterInfo[i].m_iDevilSquareNumber>=DEVIL_SQUARE_GROUND_5  && this->m_DevilSquareBossMonsterInfo[i].m_iDevilSquareNumber < DEVIL_SQUARE_GROUND_7+1 )?MAP_INDEX_DEVILSQUARE2:-1;

  0063e	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00641	c1 e0 05	 shl	 eax, 5
  00644	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00647	83 bc 01 10 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+272], 0
  0064f	7c 1c		 jl	 SHORT $LN9@RegenBossM
  00651	8b 55 f8	 mov	 edx, DWORD PTR _i$229567[ebp]
  00654	c1 e2 05	 shl	 edx, 5
  00657	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0065a	83 bc 10 10 01
	00 00 03	 cmp	 DWORD PTR [eax+edx+272], 3
  00662	7f 09		 jg	 SHORT $LN9@RegenBossM
  00664	c7 45 a0 09 00
	00 00		 mov	 DWORD PTR tv129[ebp], 9
  0066b	eb 3c		 jmp	 SHORT $LN12@RegenBossM
$LN9@RegenBossM:
  0066d	8b 4d f8	 mov	 ecx, DWORD PTR _i$229567[ebp]
  00670	c1 e1 05	 shl	 ecx, 5
  00673	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00676	83 bc 0a 10 01
	00 00 04	 cmp	 DWORD PTR [edx+ecx+272], 4
  0067e	7c 1c		 jl	 SHORT $LN10@RegenBossM
  00680	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00683	c1 e0 05	 shl	 eax, 5
  00686	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00689	83 bc 01 10 01
	00 00 07	 cmp	 DWORD PTR [ecx+eax+272], 7
  00691	7d 09		 jge	 SHORT $LN10@RegenBossM
  00693	c7 45 9c 20 00
	00 00		 mov	 DWORD PTR tv128[ebp], 32 ; 00000020H
  0069a	eb 07		 jmp	 SHORT $LN11@RegenBossM
$LN10@RegenBossM:
  0069c	c7 45 9c ff ff
	ff ff		 mov	 DWORD PTR tv128[ebp], -1
$LN11@RegenBossM:
  006a3	8b 55 9c	 mov	 edx, DWORD PTR tv128[ebp]
  006a6	89 55 a0	 mov	 DWORD PTR tv129[ebp], edx
$LN12@RegenBossM:
  006a9	8b 45 a0	 mov	 eax, DWORD PTR tv129[ebp]
  006ac	89 45 f4	 mov	 DWORD PTR _iMapNumber$229574[ebp], eax

; 179  : 
; 180  : 				int iMonIndex = gObjAddMonster(iMapNumber);

  006af	8b 45 f4	 mov	 eax, DWORD PTR _iMapNumber$229574[ebp]
  006b2	50		 push	 eax
  006b3	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  006b8	83 c4 04	 add	 esp, 4
  006bb	0f bf c8	 movsx	 ecx, ax
  006be	89 4d f0	 mov	 DWORD PTR _iMonIndex$229575[ebp], ecx

; 181  : 
; 182  : 				if ( iMonIndex >= 0 )

  006c1	83 7d f0 00	 cmp	 DWORD PTR _iMonIndex$229575[ebp], 0
  006c5	0f 8c c1 02 00
	00		 jl	 $LN3@RegenBossM

; 183  : 				{
; 184  : 					gObjSetMonster(iMonIndex, this->m_DevilSquareBossMonsterInfo[i].m_Type);

  006cb	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  006ce	c1 e0 05	 shl	 eax, 5
  006d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006d4	0f b7 94 01 f4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+244]
  006dc	52		 push	 edx
  006dd	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  006e0	50		 push	 eax
  006e1	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  006e6	83 c4 08	 add	 esp, 8

; 185  : 					gObj[iMonIndex].MapNumber = iMapNumber;

  006e9	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  006ec	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  006f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006f8	8a 55 f4	 mov	 dl, BYTE PTR _iMapNumber$229574[ebp]
  006fb	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 186  : 					
; 187  : 					gMSetBase.GetBoxPosition(gObj[iMonIndex].MapNumber,	this->m_DevilSquareBossMonsterInfo[i].X, this->m_DevilSquareBossMonsterInfo[i].Y, this->m_DevilSquareBossMonsterInfo[i].TX, this->m_DevilSquareBossMonsterInfo[i].TY, gObj[iMonIndex].X, gObj[iMonIndex].Y);

  00702	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00705	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0070b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00711	8d 94 01 46 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+326]
  00718	52		 push	 edx
  00719	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  0071c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00722	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00728	8d 94 01 44 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+324]
  0072f	52		 push	 edx
  00730	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00733	c1 e0 05	 shl	 eax, 5
  00736	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00739	8b 94 01 0c 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+268]
  00740	52		 push	 edx
  00741	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00744	c1 e0 05	 shl	 eax, 5
  00747	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074a	8b 94 01 08 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+264]
  00751	52		 push	 edx
  00752	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00755	c1 e0 05	 shl	 eax, 5
  00758	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0075b	8b 94 01 04 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+260]
  00762	52		 push	 edx
  00763	8b 45 f8	 mov	 eax, DWORD PTR _i$229567[ebp]
  00766	c1 e0 05	 shl	 eax, 5
  00769	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0076c	8b 94 01 00 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+256]
  00773	52		 push	 edx
  00774	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00777	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0077d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00783	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0078b	52		 push	 edx
  0078c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00791	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition

; 188  : 					
; 189  : 					int map = gObj[iMonIndex].MapNumber;

  00796	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00799	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0079f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007a5	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  007ad	89 55 ec	 mov	 DWORD PTR _map$229577[ebp], edx

; 190  : 					int x = gObj[iMonIndex].X;

  007b0	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  007b3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  007b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007bf	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  007c7	89 55 e8	 mov	 DWORD PTR _x$229578[ebp], edx

; 191  : 					int y = gObj[iMonIndex].Y;

  007ca	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  007cd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  007d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007d9	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  007e1	89 55 e4	 mov	 DWORD PTR _y$229579[ebp], edx

; 192  : 
; 193  : 					LogAddTD("[DevilSquare] Boss %d %d %d create ", map, x, y);

  007e4	8b 45 e4	 mov	 eax, DWORD PTR _y$229579[ebp]
  007e7	50		 push	 eax
  007e8	8b 4d e8	 mov	 ecx, DWORD PTR _x$229578[ebp]
  007eb	51		 push	 ecx
  007ec	8b 55 ec	 mov	 edx, DWORD PTR _map$229577[ebp]
  007ef	52		 push	 edx
  007f0	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EDJNDEMF@?$FLDevilSquare?$FN?5Boss?5?$CFd?5?$CFd?5?$CFd?5crea@
  007f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007fb	83 c4 10	 add	 esp, 16			; 00000010H

; 194  : 
; 195  : 					gObj[iMonIndex].TX = gObj[iMonIndex].X;

  007fe	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00801	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00807	8b 4d f0	 mov	 ecx, DWORD PTR _iMonIndex$229575[ebp]
  0080a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00810	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00816	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0081c	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  00824	66 89 84 0a 7c
	01 00 00	 mov	 WORD PTR [edx+ecx+380], ax

; 196  : 					gObj[iMonIndex].TY = gObj[iMonIndex].Y;

  0082c	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  0082f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00835	8b 4d f0	 mov	 ecx, DWORD PTR _iMonIndex$229575[ebp]
  00838	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0083e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00844	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0084a	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  00852	66 89 84 0a 7e
	01 00 00	 mov	 WORD PTR [edx+ecx+382], ax

; 197  : 					gObj[iMonIndex].MTX = gObj[iMonIndex].X;

  0085a	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  0085d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00863	8b 4d f0	 mov	 ecx, DWORD PTR _iMonIndex$229575[ebp]
  00866	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0086c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00872	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00878	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  00880	66 89 84 0a 80
	01 00 00	 mov	 WORD PTR [edx+ecx+384], ax

; 198  : 					gObj[iMonIndex].MTY = gObj[iMonIndex].Y;

  00888	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  0088b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00891	8b 4d f0	 mov	 ecx, DWORD PTR _iMonIndex$229575[ebp]
  00894	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0089a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008a0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008a6	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  008ae	66 89 84 0a 82
	01 00 00	 mov	 WORD PTR [edx+ecx+386], ax

; 199  : 					gObj[iMonIndex].StartX = gObj[iMonIndex].X;

  008b6	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  008b9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  008bf	8b 4d f0	 mov	 ecx, DWORD PTR _iMonIndex$229575[ebp]
  008c2	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  008c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008ce	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008d4	8a 84 06 44 01
	00 00		 mov	 al, BYTE PTR [esi+eax+324]
  008db	88 84 0a 76 01
	00 00		 mov	 BYTE PTR [edx+ecx+374], al

; 200  : 					gObj[iMonIndex].StartY = gObj[iMonIndex].Y;

  008e2	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  008e5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  008eb	8b 4d f0	 mov	 ecx, DWORD PTR _iMonIndex$229575[ebp]
  008ee	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  008f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008fa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00900	8a 84 06 46 01
	00 00		 mov	 al, BYTE PTR [esi+eax+326]
  00907	88 84 0a 77 01
	00 00		 mov	 BYTE PTR [edx+ecx+375], al

; 201  : 					gObj[iMonIndex].m_bDevilSquareIndex = this->m_iIndex;

  0090e	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00911	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00917	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0091d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00920	8a 92 f4 03 00
	00		 mov	 dl, BYTE PTR [edx+1012]
  00926	88 94 01 9c 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3740], dl

; 202  : 					gObj[iMonIndex].DieRegen = FALSE;

  0092d	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00930	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00936	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0093c	c6 84 01 a2 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+930], 0

; 203  : 					gObj[iMonIndex].m_PosNum = -1;

  00944	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00947	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0094d	83 c9 ff	 or	 ecx, -1
  00950	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00956	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 204  : 					gObj[iMonIndex].Live = TRUE;

  0095e	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00961	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00967	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0096d	c6 44 01 6a 01	 mov	 BYTE PTR [ecx+eax+106], 1

; 205  : 					gObj[iMonIndex].m_State = 1;

  00972	8b 45 f0	 mov	 eax, DWORD PTR _iMonIndex$229575[ebp]
  00975	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0097b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00981	c7 84 01 20 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+544], 1
$LN3@RegenBossM:

; 206  : 				}
; 207  : 			}
; 208  : 		}
; 209  : 	}

  0098c	e9 64 fc ff ff	 jmp	 $LN5@RegenBossM
$LN7@RegenBossM:

; 210  : }

  00991	5f		 pop	 edi
  00992	5e		 pop	 esi
  00993	5b		 pop	 ebx
  00994	8b e5		 mov	 esp, ebp
  00996	5d		 pop	 ebp
  00997	c2 04 00	 ret	 4
?RegenBossMonster@CDevilSquareGround@@QAEXH@Z ENDP	; CDevilSquareGround::RegenBossMonster
_TEXT	ENDS
PUBLIC	?FindMonsterType@CDevilSquareGround@@QAEHG@Z	; CDevilSquareGround::FindMonsterType
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$229585 = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 2
?FindMonsterType@CDevilSquareGround@@QAEHG@Z PROC	; CDevilSquareGround::FindMonsterType
; _this$ = ecx

; 213  : {

  009a0	55		 push	 ebp
  009a1	8b ec		 mov	 ebp, esp
  009a3	83 ec 48	 sub	 esp, 72			; 00000048H
  009a6	53		 push	 ebx
  009a7	56		 push	 esi
  009a8	57		 push	 edi
  009a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	for ( int i=0;i<MAX_ST_DEVILSQUARE_MONSTER;i++)

  009ac	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$229585[ebp], 0
  009b3	eb 09		 jmp	 SHORT $LN4@FindMonste
$LN3@FindMonste:
  009b5	8b 45 f8	 mov	 eax, DWORD PTR _i$229585[ebp]
  009b8	83 c0 01	 add	 eax, 1
  009bb	89 45 f8	 mov	 DWORD PTR _i$229585[ebp], eax
$LN4@FindMonste:
  009be	83 7d f8 0f	 cmp	 DWORD PTR _i$229585[ebp], 15 ; 0000000fH
  009c2	7d 1f		 jge	 SHORT $LN2@FindMonste

; 215  : 	{
; 216  : 		if ( this->m_DevilSquareMonsterInfo[i].m_Type == type )

  009c4	8b 45 f8	 mov	 eax, DWORD PTR _i$229585[ebp]
  009c7	c1 e0 04	 shl	 eax, 4
  009ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009cd	0f b7 54 01 04	 movzx	 edx, WORD PTR [ecx+eax+4]
  009d2	0f b7 45 08	 movzx	 eax, WORD PTR _type$[ebp]
  009d6	3b d0		 cmp	 edx, eax
  009d8	75 07		 jne	 SHORT $LN1@FindMonste

; 217  : 		{
; 218  : 			return TRUE;

  009da	b8 01 00 00 00	 mov	 eax, 1
  009df	eb 04		 jmp	 SHORT $LN5@FindMonste
$LN1@FindMonste:

; 219  : 		}
; 220  : 	}

  009e1	eb d2		 jmp	 SHORT $LN3@FindMonste
$LN2@FindMonste:

; 221  : 
; 222  : 	return FALSE;

  009e3	33 c0		 xor	 eax, eax
$LN5@FindMonste:

; 223  : }

  009e5	5f		 pop	 edi
  009e6	5e		 pop	 esi
  009e7	5b		 pop	 ebx
  009e8	8b e5		 mov	 esp, ebp
  009ea	5d		 pop	 ebp
  009eb	c2 04 00	 ret	 4
?FindMonsterType@CDevilSquareGround@@QAEHG@Z ENDP	; CDevilSquareGround::FindMonsterType
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetMonsterType@CDevilSquareGround@@QAEGH@Z	; CDevilSquareGround::GetMonsterType
EXTRN	_rand:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$229596 = -48						; size = 4
_icount$ = -44						; size = 4
_sTemp$ = -40						; size = 30
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_currtime$ = 8						; size = 4
?GetMonsterType@CDevilSquareGround@@QAEGH@Z PROC	; CDevilSquareGround::GetMonsterType
; _this$ = ecx

; 226  : {

  009f0	55		 push	 ebp
  009f1	8b ec		 mov	 ebp, esp
  009f3	83 ec 70	 sub	 esp, 112		; 00000070H
  009f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  009fb	33 c5		 xor	 eax, ebp
  009fd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00a00	53		 push	 ebx
  00a01	56		 push	 esi
  00a02	57		 push	 edi
  00a03	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 227  : 	WORD sTemp[MAX_ST_DEVILSQUARE_MONSTER];
; 228  : 
; 229  : 	int icount = 0;

  00a06	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _icount$[ebp], 0

; 230  : 
; 231  : 	for ( int i=0;i<MAX_ST_DEVILSQUARE_MONSTER;i++)

  00a0d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$229596[ebp], 0
  00a14	eb 09		 jmp	 SHORT $LN7@GetMonster
$LN6@GetMonster:
  00a16	8b 45 d0	 mov	 eax, DWORD PTR _i$229596[ebp]
  00a19	83 c0 01	 add	 eax, 1
  00a1c	89 45 d0	 mov	 DWORD PTR _i$229596[ebp], eax
$LN7@GetMonster:
  00a1f	83 7d d0 0f	 cmp	 DWORD PTR _i$229596[ebp], 15 ; 0000000fH
  00a23	7d 5b		 jge	 SHORT $LN5@GetMonster

; 232  : 	{
; 233  : 		if ( this->m_DevilSquareMonsterInfo[i].m_Type != (WORD)-1 )

  00a25	8b 45 d0	 mov	 eax, DWORD PTR _i$229596[ebp]
  00a28	c1 e0 04	 shl	 eax, 4
  00a2b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a2e	0f b7 54 01 04	 movzx	 edx, WORD PTR [ecx+eax+4]
  00a33	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00a39	74 43		 je	 SHORT $LN4@GetMonster

; 234  : 		{
; 235  : 			if ( currtime >= this->m_DevilSquareMonsterInfo[i].m_RegenStartTime )

  00a3b	8b 45 d0	 mov	 eax, DWORD PTR _i$229596[ebp]
  00a3e	c1 e0 04	 shl	 eax, 4
  00a41	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a44	8b 55 08	 mov	 edx, DWORD PTR _currtime$[ebp]
  00a47	3b 54 01 08	 cmp	 edx, DWORD PTR [ecx+eax+8]
  00a4b	7c 31		 jl	 SHORT $LN4@GetMonster

; 236  : 			{
; 237  : 				if ( currtime <= this->m_DevilSquareMonsterInfo[i].m_RegenEndTime )

  00a4d	8b 45 d0	 mov	 eax, DWORD PTR _i$229596[ebp]
  00a50	c1 e0 04	 shl	 eax, 4
  00a53	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a56	8b 55 08	 mov	 edx, DWORD PTR _currtime$[ebp]
  00a59	3b 54 01 0c	 cmp	 edx, DWORD PTR [ecx+eax+12]
  00a5d	7f 1f		 jg	 SHORT $LN4@GetMonster

; 238  : 				{
; 239  : 					sTemp[icount] = this->m_DevilSquareMonsterInfo[i].m_Type;

  00a5f	8b 45 d0	 mov	 eax, DWORD PTR _i$229596[ebp]
  00a62	c1 e0 04	 shl	 eax, 4
  00a65	8b 4d d4	 mov	 ecx, DWORD PTR _icount$[ebp]
  00a68	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a6b	66 8b 44 02 04	 mov	 ax, WORD PTR [edx+eax+4]
  00a70	66 89 44 4d d8	 mov	 WORD PTR _sTemp$[ebp+ecx*2], ax

; 240  : 					icount++;

  00a75	8b 45 d4	 mov	 eax, DWORD PTR _icount$[ebp]
  00a78	83 c0 01	 add	 eax, 1
  00a7b	89 45 d4	 mov	 DWORD PTR _icount$[ebp], eax
$LN4@GetMonster:

; 241  : 				}
; 242  : 			}
; 243  : 		}
; 244  : 	}

  00a7e	eb 96		 jmp	 SHORT $LN6@GetMonster
$LN5@GetMonster:

; 245  : 
; 246  : 	if ( icount == 0 )

  00a80	83 7d d4 00	 cmp	 DWORD PTR _icount$[ebp], 0
  00a84	75 07		 jne	 SHORT $LN1@GetMonster

; 247  : 	{
; 248  : 		return (BYTE)-1;

  00a86	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00a8b	eb 0e		 jmp	 SHORT $LN8@GetMonster
$LN1@GetMonster:

; 249  : 	}
; 250  : 
; 251  : 	return sTemp[rand()%icount];

  00a8d	e8 00 00 00 00	 call	 _rand
  00a92	99		 cdq
  00a93	f7 7d d4	 idiv	 DWORD PTR _icount$[ebp]
  00a96	66 8b 44 55 d8	 mov	 ax, WORD PTR _sTemp$[ebp+edx*2]
$LN8@GetMonster:

; 252  : }

  00a9b	5f		 pop	 edi
  00a9c	5e		 pop	 esi
  00a9d	5b		 pop	 ebx
  00a9e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aa1	33 cd		 xor	 ecx, ebp
  00aa3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aa8	8b e5		 mov	 esp, ebp
  00aaa	5d		 pop	 ebp
  00aab	c2 04 00	 ret	 4
?GetMonsterType@CDevilSquareGround@@QAEGH@Z ENDP	; CDevilSquareGround::GetMonsterType
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::clear
PUBLIC	?ClearScore@CDevilSquareGround@@QAEXXZ		; CDevilSquareGround::ClearScore
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearScore@CDevilSquareGround@@QAEXXZ PROC		; CDevilSquareGround::ClearScore
; _this$ = ecx

; 255  : {

  00ab0	55		 push	 ebp
  00ab1	8b ec		 mov	 ebp, esp
  00ab3	83 ec 44	 sub	 esp, 68			; 00000044H
  00ab6	53		 push	 ebx
  00ab7	56		 push	 esi
  00ab8	57		 push	 edi
  00ab9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 	this->m_DevilSquareRankList.clear();

  00abc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00abf	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00ac5	e8 00 00 00 00	 call	 ?clear@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::clear

; 257  : }

  00aca	5f		 pop	 edi
  00acb	5e		 pop	 esi
  00acc	5b		 pop	 ebx
  00acd	8b e5		 mov	 esp, ebp
  00acf	5d		 pop	 ebp
  00ad0	c3		 ret	 0
?ClearScore@CDevilSquareGround@@QAEXXZ ENDP		; CDevilSquareGround::ClearScore
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@P6A_NABQAUOBJECTSTRUCT@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@0P6A_NABQAUOBJECTSTRUCT@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin
PUBLIC	?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end
PUBLIC	?SortScore@CDevilSquareGround@@QAEXXZ		; CDevilSquareGround::SortScore
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T231218 = -76						; size = 4
$T231219 = -72						; size = 4
_this$ = -4						; size = 4
?SortScore@CDevilSquareGround@@QAEXXZ PROC		; CDevilSquareGround::SortScore
; _this$ = ecx

; 260  : {

  00ae0	55		 push	 ebp
  00ae1	8b ec		 mov	 ebp, esp
  00ae3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00ae6	53		 push	 ebx
  00ae7	56		 push	 esi
  00ae8	57		 push	 edi
  00ae9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : 	std::sort( this->m_DevilSquareRankList.begin(), this->m_DevilSquareRankList.end(), DevilSquareScoreSort);

  00aec	68 00 00 00 00	 push	 OFFSET ?DevilSquareScoreSort@@YA_NABQAUOBJECTSTRUCT@@0@Z ; DevilSquareScoreSort
  00af1	8d 45 b4	 lea	 eax, DWORD PTR $T231218[ebp]
  00af4	50		 push	 eax
  00af5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00af8	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00afe	e8 00 00 00 00	 call	 ?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end
  00b03	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b05	51		 push	 ecx
  00b06	8d 55 b8	 lea	 edx, DWORD PTR $T231219[ebp]
  00b09	52		 push	 edx
  00b0a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0d	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00b13	e8 00 00 00 00	 call	 ?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin
  00b18	8b 00		 mov	 eax, DWORD PTR [eax]
  00b1a	50		 push	 eax
  00b1b	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@P6A_NABQAUOBJECTSTRUCT@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@0P6A_NABQAUOBJECTSTRUCT@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00b20	83 c4 0c	 add	 esp, 12			; 0000000cH

; 262  : }

  00b23	5f		 pop	 edi
  00b24	5e		 pop	 esi
  00b25	5b		 pop	 ebx
  00b26	8b e5		 mov	 esp, ebp
  00b28	5d		 pop	 ebp
  00b29	c3		 ret	 0
?SortScore@CDevilSquareGround@@QAEXXZ ENDP		; CDevilSquareGround::SortScore
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXABQAUOBJECTSTRUCT@@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::push_back
PUBLIC	?InsertObj@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquareGround::InsertObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv79 = -72						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?InsertObj@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDevilSquareGround::InsertObj
; _this$ = ecx

; 265  : {

  00b30	55		 push	 ebp
  00b31	8b ec		 mov	 ebp, esp
  00b33	83 ec 48	 sub	 esp, 72			; 00000048H
  00b36	53		 push	 ebx
  00b37	56		 push	 esi
  00b38	57		 push	 edi
  00b39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 266  : 	if ( lpObj->Authority != 2 )

  00b3c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b3f	83 b8 0c 02 00
	00 02		 cmp	 DWORD PTR [eax+524], 2
  00b46	0f 84 9f 00 00
	00		 je	 $LN4@InsertObj

; 267  : 	{
; 268  : 		if ( lpObj->Class >= 0 && lpObj->Class < MAX_TYPE_PLAYER-1)

  00b4c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4f	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00b56	85 c9		 test	 ecx, ecx
  00b58	7c 7f		 jl	 SHORT $LN2@InsertObj
  00b5a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b5d	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00b64	83 f9 06	 cmp	 ecx, 6
  00b67	7d 70		 jge	 SHORT $LN2@InsertObj

; 269  : 		{
; 270  : 			if ( DS_LEVEL_RANGE(lpObj->m_bDevilSquareIndex) != FALSE )

  00b69	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b6c	0f b6 88 9c 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3740]
  00b73	85 c9		 test	 ecx, ecx
  00b75	7d 09		 jge	 SHORT $LN6@InsertObj
  00b77	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00b7e	eb 15		 jmp	 SHORT $LN7@InsertObj
$LN6@InsertObj:
  00b80	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b83	0f b6 82 9c 0e
	00 00		 movzx	 eax, BYTE PTR [edx+3740]
  00b8a	33 c9		 xor	 ecx, ecx
  00b8c	83 f8 06	 cmp	 eax, 6
  00b8f	0f 9e c1	 setle	 cl
  00b92	89 4d b8	 mov	 DWORD PTR tv79[ebp], ecx
$LN7@InsertObj:
  00b95	83 7d b8 00	 cmp	 DWORD PTR tv79[ebp], 0
  00b99	74 3e		 je	 SHORT $LN2@InsertObj

; 271  : 			{
; 272  : 				lpObj->m_nEventScore +=  this->m_BonusScoreTable[lpObj->Class][lpObj->m_bDevilSquareIndex] / 100;

  00b9b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b9e	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00ba5	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00ba8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00bab	8d 84 0a 1c 04
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1052]
  00bb2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bb5	0f b6 91 9c 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3740]
  00bbc	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00bbf	99		 cdq
  00bc0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00bc5	f7 f9		 idiv	 ecx
  00bc7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bca	03 82 90 0e 00
	00		 add	 eax, DWORD PTR [edx+3728]
  00bd0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bd3	89 81 90 0e 00
	00		 mov	 DWORD PTR [ecx+3728], eax
$LN2@InsertObj:

; 273  : 			}
; 274  : 		}
; 275  : 
; 276  : 		this->m_DevilSquareRankList.push_back(lpObj);

  00bd9	8d 45 08	 lea	 eax, DWORD PTR _lpObj$[ebp]
  00bdc	50		 push	 eax
  00bdd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00be0	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00be6	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXABQAUOBJECTSTRUCT@@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::push_back
$LN4@InsertObj:

; 277  : 	}
; 278  : }

  00beb	5f		 pop	 edi
  00bec	5e		 pop	 esi
  00bed	5b		 pop	 ebx
  00bee	8b e5		 mov	 esp, ebp
  00bf0	5d		 pop	 ebp
  00bf1	c2 04 00	 ret	 4
?InsertObj@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDevilSquareGround::InsertObj
_TEXT	ENDS
PUBLIC	??_C@_0CC@JEAIPIFD@Rank?5?3?$FL?$CFd?$FN?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd@ ; `string'
PUBLIC	?SendRankingInfo@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquareGround::SendRankingInfo
PUBLIC	??_C@_0BI@NLONHAKI@?$FLDevilSquare?$FN?5Rank?5?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
PUBLIC	?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size
PUBLIC	?SendScore@CDevilSquareGround@@QAEXXZ		; CDevilSquareGround::SendScore
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?GCKillPlayerExpSend@@YAXHHHHH@Z:PROC		; GCKillPlayerExpSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z:PROC ; gObjLevelUp
EXTRN	?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z:PROC ; gObjUserSetExp
EXTRN	?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; gObjSealUserSetExp
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0CC@JEAIPIFD@Rank?5?3?$FL?$CFd?$FN?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd@
CONST	SEGMENT
??_C@_0CC@JEAIPIFD@Rank?5?3?$FL?$CFd?$FN?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd@ DB 'R'
	DB	'ank :[%d] : [%s][%s][%d][%d][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NLONHAKI@?$FLDevilSquare?$FN?5Rank?5?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BI@NLONHAKI@?$FLDevilSquare?$FN?5Rank?5?$FL?$CFd?$FN?$AA@ DB '[Dev'
	DB	'ilSquare] Rank [%d]', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv466 = -140						; size = 4
tv458 = -140						; size = 4
tv425 = -140						; size = 4
$T231224 = -136						; size = 4
$T231225 = -132						; size = 4
$T231226 = -128						; size = 4
$T231227 = -124						; size = 4
$T231228 = -120						; size = 4
$T231229 = -116						; size = 4
_Zen$229825 = -48					; size = 4
_ret$229823 = -41					; size = 1
_exp$229821 = -40					; size = 8
_lc7$229813 = -32					; size = 4
_iSize$ = -28						; size = 4
_lc5$229792 = -24					; size = 4
_Itor$ = -20						; size = 4
_iExp$ = -16						; size = 4
_iUserCount$ = -12					; size = 4
_count$ = -5						; size = 1
_this$ = -4						; size = 4
?SendScore@CDevilSquareGround@@QAEXXZ PROC		; CDevilSquareGround::SendScore
; _this$ = ecx

; 281  : {

  00c00	55		 push	 ebp
  00c01	8b ec		 mov	 ebp, esp
  00c03	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00c09	53		 push	 ebx
  00c0a	56		 push	 esi
  00c0b	57		 push	 edi
  00c0c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 282  : 	if ( this->m_DevilSquareRankList.size() < 1 )

  00c0f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c12	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00c18	e8 00 00 00 00	 call	 ?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size
  00c1d	83 f8 01	 cmp	 eax, 1
  00c20	73 05		 jae	 SHORT $LN32@SendScore

; 283  : 	{
; 284  : 		return;

  00c22	e9 16 07 00 00	 jmp	 $LN33@SendScore
$LN32@SendScore:

; 285  : 	}
; 286  : 
; 287  : 	BYTE count = 1;

  00c27	c6 45 fb 01	 mov	 BYTE PTR _count$[ebp], 1

; 288  : 	int iUserCount = this->m_DevilSquareRankList.size();

  00c2b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c2e	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00c34	e8 00 00 00 00	 call	 ?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size
  00c39	89 45 f4	 mov	 DWORD PTR _iUserCount$[ebp], eax

; 289  : 
; 290  : 	int iExp = 0;

  00c3c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iExp$[ebp], 0

; 291  : 	std::vector<OBJECTSTRUCT *>::iterator Itor;

  00c43	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00c46	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >

; 292  : 	for (Itor = this->m_DevilSquareRankList.begin() ; Itor != this->m_DevilSquareRankList.end() ; Itor++ )

  00c4b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T231224[ebp]
  00c51	50		 push	 eax
  00c52	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c55	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00c5b	e8 00 00 00 00	 call	 ?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin
  00c60	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c62	89 4d ec	 mov	 DWORD PTR _Itor$[ebp], ecx
  00c65	eb 11		 jmp	 SHORT $LN31@SendScore
$LN30@SendScore:
  00c67	6a 00		 push	 0
  00c69	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T231225[ebp]
  00c6f	50		 push	 eax
  00c70	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00c73	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
$LN31@SendScore:
  00c78	8d 45 80	 lea	 eax, DWORD PTR $T231226[ebp]
  00c7b	50		 push	 eax
  00c7c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c7f	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00c85	e8 00 00 00 00	 call	 ?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end
  00c8a	50		 push	 eax
  00c8b	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00c8e	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator!=
  00c93	0f b6 c8	 movzx	 ecx, al
  00c96	85 c9		 test	 ecx, ecx
  00c98	0f 84 eb 01 00
	00		 je	 $LN29@SendScore

; 293  : 	{
; 294  : 		memcpy(this->m_DevilSquareScoreInfoTOP10.Score[count].Name , (*(Itor))->Name, MAX_ACCOUNT_LEN);

  00c9e	6a 0a		 push	 10			; 0000000aH
  00ca0	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00ca3	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  00ca8	8b 00		 mov	 eax, DWORD PTR [eax]
  00caa	83 c0 77	 add	 eax, 119		; 00000077H
  00cad	50		 push	 eax
  00cae	0f b6 4d fb	 movzx	 ecx, BYTE PTR _count$[ebp]
  00cb2	6b c9 18	 imul	 ecx, 24			; 00000018H
  00cb5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00cb8	8d 84 0a e9 02
	00 00		 lea	 eax, DWORD PTR [edx+ecx+745]
  00cbf	50		 push	 eax
  00cc0	e8 00 00 00 00	 call	 _memcpy
  00cc5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 295  : 		this->m_DevilSquareScoreInfoTOP10.Score[count].TotalScore = (*(Itor))->m_nEventScore;

  00cc8	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00ccb	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  00cd0	8b 00		 mov	 eax, DWORD PTR [eax]
  00cd2	0f b6 4d fb	 movzx	 ecx, BYTE PTR _count$[ebp]
  00cd6	6b c9 18	 imul	 ecx, 24			; 00000018H
  00cd9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00cdc	8b 80 90 0e 00
	00		 mov	 eax, DWORD PTR [eax+3728]
  00ce2	89 84 0a f5 02
	00 00		 mov	 DWORD PTR [edx+ecx+757], eax

; 296  : 
; 297  : 		if ( iUserCount <= 6 )

  00ce9	83 7d f4 06	 cmp	 DWORD PTR _iUserCount$[ebp], 6
  00ced	0f 8f 82 00 00
	00		 jg	 $LN28@SendScore

; 298  : 		{
; 299  : 			if ( count < 4 )

  00cf3	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00cf7	83 f8 04	 cmp	 eax, 4
  00cfa	7d 40		 jge	 SHORT $LN27@SendScore

; 300  : 			{
; 301  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusZen = this->m_Bonus[count-1][0];

  00cfc	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d00	0f b6 4d fb	 movzx	 ecx, BYTE PTR _count$[ebp]
  00d04	6b c9 18	 imul	 ecx, 24			; 00000018H
  00d07	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d0a	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00d0d	8b 84 c6 f0 03
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+1008]
  00d14	89 84 0a fd 02
	00 00		 mov	 DWORD PTR [edx+ecx+765], eax

; 302  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusExp = this->m_Bonus[count-1][1];

  00d1b	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d1f	0f b6 4d fb	 movzx	 ecx, BYTE PTR _count$[ebp]
  00d23	6b c9 18	 imul	 ecx, 24			; 00000018H
  00d26	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d29	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00d2c	8b 84 c6 f4 03
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+1012]
  00d33	89 84 0a f9 02
	00 00		 mov	 DWORD PTR [edx+ecx+761], eax

; 303  : 			}
; 304  : 			else

  00d3a	eb 34		 jmp	 SHORT $LN26@SendScore
$LN27@SendScore:

; 305  : 			{
; 306  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusZen = this->m_Bonus[3][0];

  00d3c	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d40	6b c0 18	 imul	 eax, 24			; 00000018H
  00d43	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d46	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d49	8b 92 10 04 00
	00		 mov	 edx, DWORD PTR [edx+1040]
  00d4f	89 94 01 fd 02
	00 00		 mov	 DWORD PTR [ecx+eax+765], edx

; 307  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusExp = this->m_Bonus[3][1];

  00d56	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d5a	6b c0 18	 imul	 eax, 24			; 00000018H
  00d5d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d60	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d63	8b 92 14 04 00
	00		 mov	 edx, DWORD PTR [edx+1044]
  00d69	89 94 01 f9 02
	00 00		 mov	 DWORD PTR [ecx+eax+761], edx
$LN26@SendScore:

; 308  : 			}
; 309  : 		}
; 310  : 		else

  00d70	e9 fc 00 00 00	 jmp	 $LN25@SendScore
$LN28@SendScore:

; 311  : 		{
; 312  : 			int lc5 = count*100/iUserCount;

  00d75	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d79	6b c0 64	 imul	 eax, 100		; 00000064H
  00d7c	99		 cdq
  00d7d	f7 7d f4	 idiv	 DWORD PTR _iUserCount$[ebp]
  00d80	89 45 e8	 mov	 DWORD PTR _lc5$229792[ebp], eax

; 313  : 
; 314  : 			if ( count == 1 )

  00d83	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d87	83 f8 01	 cmp	 eax, 1
  00d8a	75 39		 jne	 SHORT $LN24@SendScore

; 315  : 			{
; 316  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusZen = this->m_Bonus[0][0];

  00d8c	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00d90	6b c0 18	 imul	 eax, 24			; 00000018H
  00d93	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d96	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d99	8b 92 f8 03 00
	00		 mov	 edx, DWORD PTR [edx+1016]
  00d9f	89 94 01 fd 02
	00 00		 mov	 DWORD PTR [ecx+eax+765], edx

; 317  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusExp = this->m_Bonus[0][1];

  00da6	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00daa	6b c0 18	 imul	 eax, 24			; 00000018H
  00dad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00db0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00db3	8b 92 fc 03 00
	00		 mov	 edx, DWORD PTR [edx+1020]
  00db9	89 94 01 f9 02
	00 00		 mov	 DWORD PTR [ecx+eax+761], edx
  00dc0	e9 ac 00 00 00	 jmp	 $LN25@SendScore
$LN24@SendScore:

; 318  : 			}
; 319  : 			else if ( lc5 <= 30 )

  00dc5	83 7d e8 1e	 cmp	 DWORD PTR _lc5$229792[ebp], 30 ; 0000001eH
  00dc9	7f 36		 jg	 SHORT $LN22@SendScore

; 320  : 			{
; 321  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusZen = this->m_Bonus[1][0];

  00dcb	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00dcf	6b c0 18	 imul	 eax, 24			; 00000018H
  00dd2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dd5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00dd8	8b 92 00 04 00
	00		 mov	 edx, DWORD PTR [edx+1024]
  00dde	89 94 01 fd 02
	00 00		 mov	 DWORD PTR [ecx+eax+765], edx

; 322  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusExp = this->m_Bonus[1][1];

  00de5	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00de9	6b c0 18	 imul	 eax, 24			; 00000018H
  00dec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00def	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00df2	8b 92 04 04 00
	00		 mov	 edx, DWORD PTR [edx+1028]
  00df8	89 94 01 f9 02
	00 00		 mov	 DWORD PTR [ecx+eax+761], edx
  00dff	eb 70		 jmp	 SHORT $LN25@SendScore
$LN22@SendScore:

; 323  : 			}
; 324  : 			else if ( lc5 <= 50 )

  00e01	83 7d e8 32	 cmp	 DWORD PTR _lc5$229792[ebp], 50 ; 00000032H
  00e05	7f 36		 jg	 SHORT $LN20@SendScore

; 325  : 			{
; 326  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusZen = this->m_Bonus[2][0];

  00e07	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00e0b	6b c0 18	 imul	 eax, 24			; 00000018H
  00e0e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e11	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e14	8b 92 08 04 00
	00		 mov	 edx, DWORD PTR [edx+1032]
  00e1a	89 94 01 fd 02
	00 00		 mov	 DWORD PTR [ecx+eax+765], edx

; 327  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusExp = this->m_Bonus[2][1];

  00e21	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00e25	6b c0 18	 imul	 eax, 24			; 00000018H
  00e28	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e2b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e2e	8b 92 0c 04 00
	00		 mov	 edx, DWORD PTR [edx+1036]
  00e34	89 94 01 f9 02
	00 00		 mov	 DWORD PTR [ecx+eax+761], edx

; 328  : 			}
; 329  : 			else

  00e3b	eb 34		 jmp	 SHORT $LN25@SendScore
$LN20@SendScore:

; 330  : 			{
; 331  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusZen = this->m_Bonus[3][0];

  00e3d	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00e41	6b c0 18	 imul	 eax, 24			; 00000018H
  00e44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e47	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e4a	8b 92 10 04 00
	00		 mov	 edx, DWORD PTR [edx+1040]
  00e50	89 94 01 fd 02
	00 00		 mov	 DWORD PTR [ecx+eax+765], edx

; 332  : 				this->m_DevilSquareScoreInfoTOP10.Score[count].BonusExp = this->m_Bonus[3][1];

  00e57	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00e5b	6b c0 18	 imul	 eax, 24			; 00000018H
  00e5e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e61	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e64	8b 92 14 04 00
	00		 mov	 edx, DWORD PTR [edx+1044]
  00e6a	89 94 01 f9 02
	00 00		 mov	 DWORD PTR [ecx+eax+761], edx
$LN25@SendScore:

; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 		count++;

  00e71	8a 45 fb	 mov	 al, BYTE PTR _count$[ebp]
  00e74	04 01		 add	 al, 1
  00e76	88 45 fb	 mov	 BYTE PTR _count$[ebp], al

; 337  : 
; 338  : 		if ( count >= 10 )

  00e79	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00e7d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00e80	7c 02		 jl	 SHORT $LN18@SendScore

; 339  : 		{
; 340  : 			break;

  00e82	eb 05		 jmp	 SHORT $LN29@SendScore
$LN18@SendScore:

; 341  : 		}
; 342  : 	}

  00e84	e9 de fd ff ff	 jmp	 $LN30@SendScore
$LN29@SendScore:

; 343  : 
; 344  : 	this->m_DevilSquareScoreInfoTOP10.Count  = count;

  00e89	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e8c	8a 4d fb	 mov	 cl, BYTE PTR _count$[ebp]
  00e8f	88 88 e8 02 00
	00		 mov	 BYTE PTR [eax+744], cl

; 345  : 	int iSize = count * 24 + 5;

  00e95	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00e99	6b c0 18	 imul	 eax, 24			; 00000018H
  00e9c	83 c0 05	 add	 eax, 5
  00e9f	89 45 e4	 mov	 DWORD PTR _iSize$[ebp], eax

; 346  : 
; 347  : 	PHeadSetB((LPBYTE)&this->m_DevilSquareScoreInfoTOP10, 0x93, iSize);

  00ea2	8b 45 e4	 mov	 eax, DWORD PTR _iSize$[ebp]
  00ea5	50		 push	 eax
  00ea6	68 93 00 00 00	 push	 147			; 00000093H
  00eab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eae	81 c1 e4 02 00
	00		 add	 ecx, 740		; 000002e4H
  00eb4	51		 push	 ecx
  00eb5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00eba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 	count = 1;

  00ebd	c6 45 fb 01	 mov	 BYTE PTR _count$[ebp], 1

; 349  : 
; 350  : 	Itor = this->m_DevilSquareRankList.begin();

  00ec1	8d 45 84	 lea	 eax, DWORD PTR $T231227[ebp]
  00ec4	50		 push	 eax
  00ec5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ec8	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00ece	e8 00 00 00 00	 call	 ?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin
  00ed3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ed5	89 4d ec	 mov	 DWORD PTR _Itor$[ebp], ecx

; 351  : 
; 352  : 	LogAddTD("[DevilSquare] Rank [%d]", this->m_iIndex);

  00ed8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00edb	8b 88 f4 03 00
	00		 mov	 ecx, DWORD PTR [eax+1012]
  00ee1	51		 push	 ecx
  00ee2	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NLONHAKI@?$FLDevilSquare?$FN?5Rank?5?$FL?$CFd?$FN?$AA@
  00ee7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00eed	83 c4 08	 add	 esp, 8
  00ef0	eb 0e		 jmp	 SHORT $LN17@SendScore
$LN16@SendScore:

; 353  : 
; 354  : 	for ( ; Itor != this->m_DevilSquareRankList.end(); Itor++ )

  00ef2	6a 00		 push	 0
  00ef4	8d 45 88	 lea	 eax, DWORD PTR $T231228[ebp]
  00ef7	50		 push	 eax
  00ef8	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00efb	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
$LN17@SendScore:
  00f00	8d 45 8c	 lea	 eax, DWORD PTR $T231229[ebp]
  00f03	50		 push	 eax
  00f04	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f07	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00f0d	e8 00 00 00 00	 call	 ?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end
  00f12	50		 push	 eax
  00f13	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  00f16	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator!=
  00f1b	0f b6 c8	 movzx	 ecx, al
  00f1e	85 c9		 test	 ecx, ecx
  00f20	0f 84 17 04 00
	00		 je	 $LN33@SendScore

; 355  : 	{
; 356  : 		if ( iUserCount <= 6 )

  00f26	83 7d f4 06	 cmp	 DWORD PTR _iUserCount$[ebp], 6
  00f2a	7f 62		 jg	 SHORT $LN14@SendScore

; 357  : 		{
; 358  : 			if ( count < 4 ) //webzen fixed on season 3.0

  00f2c	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00f30	83 f8 04	 cmp	 eax, 4
  00f33	7d 30		 jge	 SHORT $LN13@SendScore

; 359  : 			{
; 360  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen = this->m_Bonus[count-1][0];

  00f35	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00f39	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f3c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f3f	8b 84 c2 f0 03
	00 00		 mov	 eax, DWORD PTR [edx+eax*8+1008]
  00f46	89 81 fd 02 00
	00		 mov	 DWORD PTR [ecx+765], eax

; 361  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp = this->m_Bonus[count-1][1];

  00f4c	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00f50	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f53	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f56	8b 84 c2 f4 03
	00 00		 mov	 eax, DWORD PTR [edx+eax*8+1012]
  00f5d	89 81 f9 02 00
	00		 mov	 DWORD PTR [ecx+761], eax

; 362  : 			}
; 363  : 			else

  00f63	eb 24		 jmp	 SHORT $LN12@SendScore
$LN13@SendScore:

; 364  : 			{
; 365  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen = this->m_Bonus[3][0];

  00f65	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f68	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f6b	8b 91 10 04 00
	00		 mov	 edx, DWORD PTR [ecx+1040]
  00f71	89 90 fd 02 00
	00		 mov	 DWORD PTR [eax+765], edx

; 366  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp = this->m_Bonus[3][1];

  00f77	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f7a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f7d	8b 91 14 04 00
	00		 mov	 edx, DWORD PTR [ecx+1044]
  00f83	89 90 f9 02 00
	00		 mov	 DWORD PTR [eax+761], edx
$LN12@SendScore:

; 367  : 			}
; 368  : 		}
; 369  : 		else

  00f89	e9 b9 00 00 00	 jmp	 $LN11@SendScore
$LN14@SendScore:

; 370  : 		{
; 371  : 			int lc7 = count*100/iUserCount;

  00f8e	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00f92	6b c0 64	 imul	 eax, 100		; 00000064H
  00f95	99		 cdq
  00f96	f7 7d f4	 idiv	 DWORD PTR _iUserCount$[ebp]
  00f99	89 45 e0	 mov	 DWORD PTR _lc7$229813[ebp], eax

; 372  : 
; 373  : 			if ( count ==1 )

  00f9c	0f b6 45 fb	 movzx	 eax, BYTE PTR _count$[ebp]
  00fa0	83 f8 01	 cmp	 eax, 1
  00fa3	75 26		 jne	 SHORT $LN10@SendScore

; 374  : 			{
; 375  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen = this->m_Bonus[0][0];

  00fa5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fa8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fab	8b 91 f8 03 00
	00		 mov	 edx, DWORD PTR [ecx+1016]
  00fb1	89 90 fd 02 00
	00		 mov	 DWORD PTR [eax+765], edx

; 376  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp = this->m_Bonus[0][1];

  00fb7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fbd	8b 91 fc 03 00
	00		 mov	 edx, DWORD PTR [ecx+1020]
  00fc3	89 90 f9 02 00
	00		 mov	 DWORD PTR [eax+761], edx
  00fc9	eb 7c		 jmp	 SHORT $LN11@SendScore
$LN10@SendScore:

; 377  : 			}
; 378  : 			else if ( lc7 <= 30 )

  00fcb	83 7d e0 1e	 cmp	 DWORD PTR _lc7$229813[ebp], 30 ; 0000001eH
  00fcf	7f 26		 jg	 SHORT $LN8@SendScore

; 379  : 			{
; 380  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen = this->m_Bonus[1][0];

  00fd1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fd4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fd7	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  00fdd	89 90 fd 02 00
	00		 mov	 DWORD PTR [eax+765], edx

; 381  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp = this->m_Bonus[1][1];

  00fe3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fe6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fe9	8b 91 04 04 00
	00		 mov	 edx, DWORD PTR [ecx+1028]
  00fef	89 90 f9 02 00
	00		 mov	 DWORD PTR [eax+761], edx
  00ff5	eb 50		 jmp	 SHORT $LN11@SendScore
$LN8@SendScore:

; 382  : 			}
; 383  : 			else if ( lc7 <= 50 )

  00ff7	83 7d e0 32	 cmp	 DWORD PTR _lc7$229813[ebp], 50 ; 00000032H
  00ffb	7f 26		 jg	 SHORT $LN6@SendScore

; 384  : 			{
; 385  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen = this->m_Bonus[2][0];

  00ffd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01000	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01003	8b 91 08 04 00
	00		 mov	 edx, DWORD PTR [ecx+1032]
  01009	89 90 fd 02 00
	00		 mov	 DWORD PTR [eax+765], edx

; 386  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp = this->m_Bonus[2][1];

  0100f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01015	8b 91 0c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1036]
  0101b	89 90 f9 02 00
	00		 mov	 DWORD PTR [eax+761], edx

; 387  : 			}
; 388  : 			else

  01021	eb 24		 jmp	 SHORT $LN11@SendScore
$LN6@SendScore:

; 389  : 			{
; 390  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen = this->m_Bonus[3][0];

  01023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01029	8b 91 10 04 00
	00		 mov	 edx, DWORD PTR [ecx+1040]
  0102f	89 90 fd 02 00
	00		 mov	 DWORD PTR [eax+765], edx

; 391  : 				this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp = this->m_Bonus[3][1];

  01035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0103b	8b 91 14 04 00
	00		 mov	 edx, DWORD PTR [ecx+1044]
  01041	89 90 f9 02 00
	00		 mov	 DWORD PTR [eax+761], edx
$LN11@SendScore:

; 392  : 			}
; 393  : 		}
; 394  : 
; 395  : 		if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty != FALSE)

  01047	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0104c	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  01051	83 f8 01	 cmp	 eax, 1
  01054	75 2e		 jne	 SHORT $LN4@SendScore
  01056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  0105d	74 25		 je	 SHORT $LN4@SendScore

; 396  : 		{
; 397  : 			this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp =  (this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp * g_CrywolfSync.GetGettingExpPenaltyRate()) / 100;

  0105f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  01064	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  01069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0106c	0f af 81 f9 02
	00 00		 imul	 eax, DWORD PTR [ecx+761]
  01073	99		 cdq
  01074	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01079	f7 f9		 idiv	 ecx
  0107b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0107e	89 82 f9 02 00
	00		 mov	 DWORD PTR [edx+761], eax
$LN4@SendScore:

; 398  : 		}
; 399  : 
; 400  : 		__int64 exp = this->m_DevilSquareScoreInfoTOP10.Score[0].BonusExp;

  01084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01087	8b 80 f9 02 00
	00		 mov	 eax, DWORD PTR [eax+761]
  0108d	99		 cdq
  0108e	89 45 d8	 mov	 DWORD PTR _exp$229821[ebp], eax
  01091	89 55 dc	 mov	 DWORD PTR _exp$229821[ebp+4], edx

; 401  : 		gObjSealUserSetExp((*(Itor)), exp, TRUE); //Seal Exp (Season3 add-on)

  01094	6a 01		 push	 1
  01096	8d 45 d8	 lea	 eax, DWORD PTR _exp$229821[ebp]
  01099	50		 push	 eax
  0109a	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0109d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  010a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  010a4	51		 push	 ecx
  010a5	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp
  010aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 402  : 		gObjUserSetExp((*(Itor)),exp);	//Panda Use

  010ad	8d 45 d8	 lea	 eax, DWORD PTR _exp$229821[ebp]
  010b0	50		 push	 eax
  010b1	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  010b4	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  010b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  010bb	51		 push	 ecx
  010bc	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp
  010c1	83 c4 08	 add	 esp, 8

; 403  : 
; 404  : 		(*(Itor))->Experience += (int)exp;		

  010c4	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  010c7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  010cc	8b 00		 mov	 eax, DWORD PTR [eax]
  010ce	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  010d3	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv425[ebp], eax
  010d9	8b 4d d8	 mov	 ecx, DWORD PTR _exp$229821[ebp]
  010dc	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv425[ebp]
  010e2	03 0a		 add	 ecx, DWORD PTR [edx]
  010e4	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv425[ebp]
  010ea	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 		
; 406  : 		bool ret = gObjLevelUp((*(Itor)), exp, 0, EVENT_TYPE_DEVILSQUARE);

  010ec	6a 02		 push	 2
  010ee	6a 00		 push	 0
  010f0	8d 45 d8	 lea	 eax, DWORD PTR _exp$229821[ebp]
  010f3	50		 push	 eax
  010f4	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  010f7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  010fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  010fe	51		 push	 ecx
  010ff	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z ; gObjLevelUp
  01104	83 c4 10	 add	 esp, 16			; 00000010H
  01107	88 45 d7	 mov	 BYTE PTR _ret$229823[ebp], al

; 407  : 
; 408  : 		(*(Itor))->m_nEventMoney = this->m_DevilSquareScoreInfoTOP10.Score[0].BonusZen;

  0110a	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0110d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01112	8b 00		 mov	 eax, DWORD PTR [eax]
  01114	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01117	8b 91 fd 02 00
	00		 mov	 edx, DWORD PTR [ecx+765]
  0111d	89 90 98 0e 00
	00		 mov	 DWORD PTR [eax+3736], edx

; 409  : 
; 410  : 		if ( gObjCheckMaxZen((*(Itor))->m_Index, (*(Itor))->m_nEventMoney) == FALSE )

  01123	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01126	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  0112b	8b 00		 mov	 eax, DWORD PTR [eax]
  0112d	8b 88 98 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3736]
  01133	51		 push	 ecx
  01134	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01137	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  0113c	8b 10		 mov	 edx, DWORD PTR [eax]
  0113e	8b 02		 mov	 eax, DWORD PTR [edx]
  01140	50		 push	 eax
  01141	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  01146	83 c4 08	 add	 esp, 8
  01149	85 c0		 test	 eax, eax
  0114b	75 42		 jne	 SHORT $LN3@SendScore

; 411  : 		{
; 412  : 			int Zen = MAX_ZEN - (*(Itor))->Money;

  0114d	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01150	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01155	8b 00		 mov	 eax, DWORD PTR [eax]
  01157	b9 00 94 35 77	 mov	 ecx, 2000000000		; 77359400H
  0115c	2b 88 f0 00 00
	00		 sub	 ecx, DWORD PTR [eax+240]
  01162	89 4d d0	 mov	 DWORD PTR _Zen$229825[ebp], ecx

; 413  : 			(*(Itor))->Money += Zen;

  01165	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01168	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  0116d	8b 00		 mov	 eax, DWORD PTR [eax]
  0116f	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  01174	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv458[ebp], eax
  0117a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv458[ebp]
  01180	8b 11		 mov	 edx, DWORD PTR [ecx]
  01182	03 55 d0	 add	 edx, DWORD PTR _Zen$229825[ebp]
  01185	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv458[ebp]
  0118b	89 10		 mov	 DWORD PTR [eax], edx

; 414  : 		}
; 415  : 		else

  0118d	eb 35		 jmp	 SHORT $LN2@SendScore
$LN3@SendScore:

; 416  : 		{
; 417  : 			(*(Itor))->Money += (*(Itor))->m_nEventMoney;

  0118f	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01192	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01197	8b 00		 mov	 eax, DWORD PTR [eax]
  01199	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  0119e	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv466[ebp], eax
  011a4	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  011a7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  011ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  011ae	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv466[ebp]
  011b4	8b 02		 mov	 eax, DWORD PTR [edx]
  011b6	03 81 98 0e 00
	00		 add	 eax, DWORD PTR [ecx+3736]
  011bc	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv466[ebp]
  011c2	89 01		 mov	 DWORD PTR [ecx], eax
$LN2@SendScore:

; 418  : 		}
; 419  : 
; 420  : 		GCMoneySend((*(Itor))->m_Index, (*(Itor))->Money);

  011c4	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  011c7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  011cc	8b 00		 mov	 eax, DWORD PTR [eax]
  011ce	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  011d4	51		 push	 ecx
  011d5	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  011d8	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  011dd	8b 10		 mov	 edx, DWORD PTR [eax]
  011df	8b 02		 mov	 eax, DWORD PTR [edx]
  011e1	50		 push	 eax
  011e2	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  011e7	83 c4 08	 add	 esp, 8

; 421  : 
; 422  : 		if ( ret == true )

  011ea	0f b6 45 d7	 movzx	 eax, BYTE PTR _ret$229823[ebp]
  011ee	83 f8 01	 cmp	 eax, 1
  011f1	75 22		 jne	 SHORT $LN1@SendScore

; 423  : 		{
; 424  : 			GCKillPlayerExpSend((*(Itor))->m_Index, (WORD)-1, exp, 0, 0);//Season 4.5 changed

  011f3	6a 00		 push	 0
  011f5	6a 00		 push	 0
  011f7	8b 45 d8	 mov	 eax, DWORD PTR _exp$229821[ebp]
  011fa	50		 push	 eax
  011fb	68 ff ff 00 00	 push	 65535			; 0000ffffH
  01200	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01203	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01208	8b 08		 mov	 ecx, DWORD PTR [eax]
  0120a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0120c	52		 push	 edx
  0120d	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  01212	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@SendScore:

; 425  : 		}
; 426  : 
; 427  : 		this->SendRankingInfo((*(Itor)));

  01215	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01218	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  0121d	8b 00		 mov	 eax, DWORD PTR [eax]
  0121f	50		 push	 eax
  01220	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01223	e8 00 00 00 00	 call	 ?SendRankingInfo@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquareGround::SendRankingInfo

; 428  : 
; 429  : 		LogAddTD("Rank :[%d] : [%s][%s][%d][%d][%d]", count, (*(Itor))->AccountID, (*(Itor))->Name, (*(Itor))->m_nEventMoney, (*(Itor))->m_nEventExp, (*(Itor))->m_nEventScore);

  01228	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0122b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01230	8b 00		 mov	 eax, DWORD PTR [eax]
  01232	8b 88 90 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3728]
  01238	51		 push	 ecx
  01239	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0123c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01241	8b 10		 mov	 edx, DWORD PTR [eax]
  01243	8b 82 94 0e 00
	00		 mov	 eax, DWORD PTR [edx+3732]
  01249	50		 push	 eax
  0124a	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0124d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01252	8b 08		 mov	 ecx, DWORD PTR [eax]
  01254	8b 91 98 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3736]
  0125a	52		 push	 edx
  0125b	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0125e	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01263	8b 00		 mov	 eax, DWORD PTR [eax]
  01265	83 c0 77	 add	 eax, 119		; 00000077H
  01268	50		 push	 eax
  01269	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0126c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01271	8b 08		 mov	 ecx, DWORD PTR [eax]
  01273	83 c1 6c	 add	 ecx, 108		; 0000006cH
  01276	51		 push	 ecx
  01277	0f b6 55 fb	 movzx	 edx, BYTE PTR _count$[ebp]
  0127b	52		 push	 edx
  0127c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JEAIPIFD@Rank?5?3?$FL?$CFd?$FN?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd@
  01281	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01287	83 c4 1c	 add	 esp, 28			; 0000001cH

; 430  : 		
; 431  : 		memcpy(this->m_DevilSquareScoreInfoTOP10.Score[0].Name , (*(Itor))->Name, MAX_ACCOUNT_LEN);

  0128a	6a 0a		 push	 10			; 0000000aH
  0128c	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  0128f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01294	8b 00		 mov	 eax, DWORD PTR [eax]
  01296	83 c0 77	 add	 eax, 119		; 00000077H
  01299	50		 push	 eax
  0129a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0129d	81 c1 e9 02 00
	00		 add	 ecx, 745		; 000002e9H
  012a3	51		 push	 ecx
  012a4	e8 00 00 00 00	 call	 _memcpy
  012a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		this->m_DevilSquareScoreInfoTOP10.Score[0].TotalScore = (*(Itor))->m_nEventScore;

  012ac	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  012af	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  012b4	8b 00		 mov	 eax, DWORD PTR [eax]
  012b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012b9	8b 90 90 0e 00
	00		 mov	 edx, DWORD PTR [eax+3728]
  012bf	89 91 f5 02 00
	00		 mov	 DWORD PTR [ecx+757], edx

; 433  : 		this->m_DevilSquareScoreInfoTOP10.MyRank = count;

  012c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012c8	8a 4d fb	 mov	 cl, BYTE PTR _count$[ebp]
  012cb	88 88 e7 02 00
	00		 mov	 BYTE PTR [eax+743], cl

; 434  : 		count++;

  012d1	8a 45 fb	 mov	 al, BYTE PTR _count$[ebp]
  012d4	04 01		 add	 al, 1
  012d6	88 45 fb	 mov	 BYTE PTR _count$[ebp], al

; 435  : 
; 436  : 		DataSend((*(Itor))->m_Index, (LPBYTE)&this->m_DevilSquareScoreInfoTOP10 , iSize);

  012d9	8b 45 e4	 mov	 eax, DWORD PTR _iSize$[ebp]
  012dc	50		 push	 eax
  012dd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012e0	81 c1 e4 02 00
	00		 add	 ecx, 740		; 000002e4H
  012e6	51		 push	 ecx
  012e7	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  012ea	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  012ef	8b 10		 mov	 edx, DWORD PTR [eax]
  012f1	8b 02		 mov	 eax, DWORD PTR [edx]
  012f3	50		 push	 eax
  012f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  012f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 
; 438  : 		(*(Itor))->m_nEventScore = 0;

  012fc	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  012ff	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01304	8b 00		 mov	 eax, DWORD PTR [eax]
  01306	c7 80 90 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3728], 0

; 439  : 		(*(Itor))->m_nEventMoney = 0;

  01310	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01313	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  01318	8b 00		 mov	 eax, DWORD PTR [eax]
  0131a	c7 80 98 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3736], 0

; 440  : 		(*(Itor))->m_nEventExp = 0;

  01324	8d 4d ec	 lea	 ecx, DWORD PTR _Itor$[ebp]
  01327	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
  0132c	8b 00		 mov	 eax, DWORD PTR [eax]
  0132e	c7 80 94 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3732], 0

; 441  : 	}

  01338	e9 b5 fb ff ff	 jmp	 $LN16@SendScore
$LN33@SendScore:

; 442  : }

  0133d	5f		 pop	 edi
  0133e	5e		 pop	 esi
  0133f	5b		 pop	 ebx
  01340	8b e5		 mov	 esp, ebp
  01342	5d		 pop	 ebp
  01343	c3		 ret	 0
?SendScore@CDevilSquareGround@@QAEXXZ ENDP		; CDevilSquareGround::SendScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?DataSendRank@@YAXPADH@Z:PROC			; DataSendRank
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?Main@cDevilSquareRewardItem@@QAEXH@Z:PROC	; cDevilSquareRewardItem::Main
EXTRN	?gDevilSquareRewardItem@@3VcDevilSquareRewardItem@@A:BYTE ; gDevilSquareRewardItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -48						; size = 40
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?SendRankingInfo@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDevilSquareGround::SendRankingInfo
; _this$ = ecx

; 445  : {

  01350	55		 push	 ebp
  01351	8b ec		 mov	 ebp, esp
  01353	83 ec 70	 sub	 esp, 112		; 00000070H
  01356	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0135b	33 c5		 xor	 eax, ebp
  0135d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01360	53		 push	 ebx
  01361	56		 push	 esi
  01362	57		 push	 edi
  01363	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 446  : 	if ( lpObj->m_nEventScore <= 0 )

  01366	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01369	83 b8 90 0e 00
	00 00		 cmp	 DWORD PTR [eax+3728], 0
  01370	7f 05		 jg	 SHORT $LN1@SendRankin

; 447  : 	{
; 448  : 		return;

  01372	e9 87 00 00 00	 jmp	 $LN2@SendRankin
$LN1@SendRankin:

; 449  : 	}
; 450  : 				//////////////////////////////////////////////////////////////////////Confict
; 451  : 				//DevilSquareRewardItem
; 452  : #ifdef DS_REWARD_ITEM
; 453  : 				gDevilSquareRewardItem.Main(lpObj->m_Index);

  01377	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0137a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0137c	51		 push	 ecx
  0137d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDevilSquareRewardItem@@3VcDevilSquareRewardItem@@A ; gDevilSquareRewardItem
  01382	e8 00 00 00 00	 call	 ?Main@cDevilSquareRewardItem@@QAEXH@Z ; cDevilSquareRewardItem::Main

; 454  : #endif // DS_REWARD_ITEM
; 455  : 	PMSG_ANS_EVENTUSERSCORE pMsg;
; 456  : 
; 457  : 	pMsg.h.c = 0xC1;

  01387	c6 45 d0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 458  : 	pMsg.h.headcode = 0x01;

  0138b	c6 45 d2 01	 mov	 BYTE PTR _pMsg$[ebp+2], 1

; 459  : 	pMsg.h.size = sizeof(pMsg);

  0138f	c6 45 d1 28	 mov	 BYTE PTR _pMsg$[ebp+1], 40 ; 00000028H

; 460  : 	pMsg.Score = lpObj->m_nEventScore;

  01393	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01396	8b 88 90 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3728]
  0139c	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+28], ecx

; 461  : 	pMsg.SquareNum = lpObj->m_bDevilSquareIndex;

  0139f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013a2	0f b6 88 9c 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3740]
  013a9	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 462  : 	pMsg.Class = lpObj->Class;

  013ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013af	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  013b6	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 463  : 	pMsg.ServerCode = gGameServerCode;

  013b9	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  013c0	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 464  : 	memcpy(pMsg.AccountID, lpObj->AccountID, MAX_ACCOUNT_LEN);

  013c3	6a 0a		 push	 10			; 0000000aH
  013c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013c8	83 c0 6c	 add	 eax, 108		; 0000006cH
  013cb	50		 push	 eax
  013cc	8d 4d d3	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  013cf	51		 push	 ecx
  013d0	e8 00 00 00 00	 call	 _memcpy
  013d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 465  : 	memcpy(pMsg.GameID, lpObj->Name, MAX_ACCOUNT_LEN);

  013d8	6a 0a		 push	 10			; 0000000aH
  013da	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013dd	83 c0 77	 add	 eax, 119		; 00000077H
  013e0	50		 push	 eax
  013e1	8d 4d dd	 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  013e4	51		 push	 ecx
  013e5	e8 00 00 00 00	 call	 _memcpy
  013ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 466  : 
; 467  : 	DataSendRank((char *)&pMsg, pMsg.h.size);

  013ed	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  013f1	50		 push	 eax
  013f2	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  013f5	51		 push	 ecx
  013f6	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank
  013fb	83 c4 08	 add	 esp, 8
$LN2@SendRankin:

; 468  : }

  013fe	5f		 pop	 edi
  013ff	5e		 pop	 esi
  01400	5b		 pop	 ebx
  01401	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01404	33 cd		 xor	 ecx, ebp
  01406	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0140b	8b e5		 mov	 esp, ebp
  0140d	5d		 pop	 ebp
  0140e	c2 04 00	 ret	 4
?SendRankingInfo@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDevilSquareGround::SendRankingInfo
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@V?$allocator@PAUOBJECTSTRUCT@@@1@@Z ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
PUBLIC	??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@XZ	; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T231233 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T231233[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@XZ ; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@V?$allocator@PAUOBJECTSTRUCT@@@1@@Z ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
PUBLIC	?_Tidy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
__ehhandler$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@ABQAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@ABQAU2@@Z ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * const &>
PUBLIC	??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@AAPAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@AAPAU2@@Z ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * &>
PUBLIC	?_Orphan_range@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXI@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Reserve
PUBLIC	?_Inside@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBE_NPBQAUOBJECTSTRUCT@@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Inside
PUBLIC	??$addressof@QAUOBJECTSTRUCT@@@std@@YAPBQAUOBJECTSTRUCT@@ABQAU1@@Z ; std::addressof<OBJECTSTRUCT * const>
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXABQAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
__Idx$229867 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXABQAUOBJECTSTRUCT@@@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@QAUOBJECTSTRUCT@@@std@@YAPBQAUOBJECTSTRUCT@@ABQAU1@@Z ; std::addressof<OBJECTSTRUCT * const>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBE_NPBQAUOBJECTSTRUCT@@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@QAUOBJECTSTRUCT@@@std@@YAPBQAUOBJECTSTRUCT@@ABQAU1@@Z ; std::addressof<OBJECTSTRUCT * const>
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$229867[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXI@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$229867[ebp]
  00075	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@AAPAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@AAPAU2@@Z ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 04	 add	 ecx, 4
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXI@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@ABQAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@ABQAU2@@Z ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 04	 add	 ecx, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXABQAUOBJECTSTRUCT@@@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T231254 = -88						; size = 4
$T231255 = -84						; size = 4
$T231256 = -80						; size = 4
$T231257 = -76						; size = 4
$T231258 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXXZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T231255[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T231254[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T231257[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@XZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T231256[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T231254[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T231256[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T231258[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXXZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEABQAUOBJECTSTRUCT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEABQAUOBJECTSTRUCT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEAAPAUOBJECTSTRUCT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Destroy
PUBLIC	??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
PUBLIC	?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T231269 = -84						; size = 4
__Ptr$229936 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@0@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$229936[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$229936[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$229936[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T231269[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T231269[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@0@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBE_NPBQAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBE_NPBQAUOBJECTSTRUCT@@@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBE_NPBQAUOBJECTSTRUCT@@@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::reserve
PUBLIC	?_Grow_to@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEII@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Grow_to
PUBLIC	?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::capacity
PUBLIC	?_Xlen@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Xlen
PUBLIC	?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXI@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEII@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXI@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z ; std::allocator<OBJECTSTRUCT *>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXXZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 02	 sar	 edx, 2
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z ; std::allocator<OBJECTSTRUCT *>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXXZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXPAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXPAPAUOBJECTSTRUCT@@0@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXPAPAUOBJECTSTRUCT@@0@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@ABV01@@Z ; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@V?$allocator@PAUOBJECTSTRUCT@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@V?$allocator@PAUOBJECTSTRUCT@@@1@@Z PROC ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@ABV01@@Z ; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@V?$allocator@PAUOBJECTSTRUCT@@@1@@Z ENDP ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::~_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@XZ PROC	; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@XZ ENDP	; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEABQAUOBJECTSTRUCT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEABQAUOBJECTSTRUCT@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEABQAUOBJECTSTRUCT@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAUOBJECTSTRUCT@@@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEPAPAUOBJECTSTRUCT@@PAPAU2@00@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Umove<OBJECTSTRUCT * *>
PUBLIC	?allocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEPAPAUOBJECTSTRUCT@@I@Z ; std::allocator<OBJECTSTRUCT *>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$229992 = -28					; size = 4
__Ptr$229985 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEPAPAUOBJECTSTRUCT@@I@Z ; std::allocator<OBJECTSTRUCT *>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$229985[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$229985[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAPAUOBJECTSTRUCT@@@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEPAPAUOBJECTSTRUCT@@PAPAU2@00@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Umove<OBJECTSTRUCT * *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229985[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z ; std::allocator<OBJECTSTRUCT *>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$229992[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z ; std::allocator<OBJECTSTRUCT *>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229985[ebp]
  00114	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$229992[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229985[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229985[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QAEXI@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@2@@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUOBJECTSTRUCT@@@std@@QBEIXZ ; std::allocator<OBJECTSTRUCT *>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAUOBJECTSTRUCT@@@std@@QBEIXZ ; std::allocator<OBJECTSTRUCT *>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEXPAPAUOBJECTSTRUCT@@0@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEII@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEII@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXXZ PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IBEXXZ ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@ABV01@@Z PROC	; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@PAUOBJECTSTRUCT@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<OBJECTSTRUCT *>::allocator<OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z PROC ; std::allocator<OBJECTSTRUCT *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@I@Z ENDP ; std::allocator<OBJECTSTRUCT *>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAE@PAPAUOBJECTSTRUCT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 04	 add	 ecx, 4
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@IPAPAU1@@Z ; std::_Allocate<OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEPAPAUOBJECTSTRUCT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEPAPAUOBJECTSTRUCT@@I@Z PROC ; std::allocator<OBJECTSTRUCT *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@PAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@IPAPAU1@@Z ; std::_Allocate<OBJECTSTRUCT *>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEPAPAUOBJECTSTRUCT@@I@Z ENDP ; std::allocator<OBJECTSTRUCT *>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUOBJECTSTRUCT@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAUOBJECTSTRUCT@@@std@@QBEIXZ PROC ; std::allocator<OBJECTSTRUCT *>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@PAUOBJECTSTRUCT@@@std@@QBEIXZ ENDP ; std::allocator<OBJECTSTRUCT *>::max_size
_TEXT	ENDS
PUBLIC	??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z ; std::_Sort<OBJECTSTRUCT * *,int,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	??$_Unchecked@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@P6A_NABQAUOBJECTSTRUCT@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@0P6A_NABQAUOBJECTSTRUCT@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@P6A_NABQAUOBJECTSTRUCT@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@0P6A_NABQAUOBJECTSTRUCT@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 3803 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3804 : 	_DEBUG_RANGE(_First, _Last);
; 3805 : 	_DEBUG_POINTER(_Pred);
; 3806 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00014	e8 00 00 00 00	 call	 ??G?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-
  00019	50		 push	 eax
  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z ; std::_Sort<OBJECTSTRUCT * *,int,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 3807 : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@P6A_NABQAUOBJECTSTRUCT@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@0P6A_NABQAUOBJECTSTRUCT@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@QAUOBJECTSTRUCT@@@std@@YAPBQAUOBJECTSTRUCT@@ABQAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAUOBJECTSTRUCT@@@std@@YAPBQAUOBJECTSTRUCT@@ABQAU1@@Z PROC ; std::addressof<OBJECTSTRUCT * const>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@QAUOBJECTSTRUCT@@@std@@YAPBQAUOBJECTSTRUCT@@ABQAU1@@Z ENDP ; std::addressof<OBJECTSTRUCT * const>
_TEXT	ENDS
PUBLIC	??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z ; std::allocator<OBJECTSTRUCT *>::construct<OBJECTSTRUCT * &>
PUBLIC	??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::forward<OBJECTSTRUCT * &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@AAPAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@AAPAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@AAPAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@AAPAU2@@Z PROC ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::forward<OBJECTSTRUCT * &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z ; std::allocator<OBJECTSTRUCT *>::construct<OBJECTSTRUCT * &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@AAPAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@AAPAU2@@Z ENDP ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@ABQAU3@@Z ; std::allocator<OBJECTSTRUCT *>::construct
PUBLIC	??$forward@ABQAUOBJECTSTRUCT@@@std@@YAABQAUOBJECTSTRUCT@@ABQAU1@@Z ; std::forward<OBJECTSTRUCT * const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@ABQAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@ABQAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@ABQAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@ABQAU2@@Z PROC ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABQAUOBJECTSTRUCT@@@std@@YAABQAUOBJECTSTRUCT@@ABQAU1@@Z ; std::forward<OBJECTSTRUCT * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@ABQAU3@@Z ; std::allocator<OBJECTSTRUCT *>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@PAUOBJECTSTRUCT@@@std@@PAUOBJECTSTRUCT@@ABQAU3@@std@@YAXAAV?$allocator@PAUOBJECTSTRUCT@@@0@PAPAUOBJECTSTRUCT@@ABQAU2@@Z ENDP ; std::_Cons_val<std::allocator<OBJECTSTRUCT *>,OBJECTSTRUCT *,OBJECTSTRUCT * const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
PUBLIC	??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z
_TEXT	SEGMENT
$T231352 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z PROC ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231352[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231352[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z ENDP ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAPAUOBJECTSTRUCT@@PAPAU1@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z ; std::_Uninitialized_move<OBJECTSTRUCT * *,OBJECTSTRUCT * *,std::allocator<OBJECTSTRUCT *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUOBJECTSTRUCT@@@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEPAPAUOBJECTSTRUCT@@PAPAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUOBJECTSTRUCT@@@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEPAPAUOBJECTSTRUCT@@PAPAU2@00@Z PROC ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Umove<OBJECTSTRUCT * *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUOBJECTSTRUCT@@PAPAU1@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z ; std::_Uninitialized_move<OBJECTSTRUCT * *,OBJECTSTRUCT * *,std::allocator<OBJECTSTRUCT *> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAUOBJECTSTRUCT@@@?$vector@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@IAEPAPAUOBJECTSTRUCT@@PAPAU2@00@Z ENDP ; std::vector<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> >::_Umove<OBJECTSTRUCT * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z
_TEXT	SEGMENT
$T231357 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231357[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231357[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@IPAPAU1@@Z
_TEXT	SEGMENT
$T231360 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@IPAPAU1@@Z PROC ; std::_Allocate<OBJECTSTRUCT *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T231360[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T231360[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@PAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@IPAPAU1@@Z ENDP ; std::_Allocate<OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z ; std::_Construct<OBJECTSTRUCT *,OBJECTSTRUCT * const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@ABQAU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@ABQAU3@@Z PROC ; std::allocator<OBJECTSTRUCT *>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z ; std::_Construct<OBJECTSTRUCT *,OBJECTSTRUCT * const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@ABQAU3@@Z ENDP ; std::allocator<OBJECTSTRUCT *>::construct
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-, COMDAT
; _this$ = ecx

; 380  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 381  : 		return (*(_Mybase *)this - _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??G?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-

; 382  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-, COMDAT
; _this$ = ecx

; 190  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Compat

; 192  : 		return (this->_Ptr - _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	2b 01		 sub	 eax, DWORD PTR [ecx]
  00022	c1 f8 02	 sar	 eax, 2

; 193  : 		}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::operator-
_TEXT	ENDS
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEPAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Unchecked
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Unchecked@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >, COMDAT

; 393  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 394  : 	return (_Iter._Unchecked());

  00009	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEPAPAUOBJECTSTRUCT@@XZ ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Unchecked

; 395  : 	}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@V?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::_Insertion_sort<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	??$sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	??$make_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::make_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	??$_Unguarded_partition@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YA?AU?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@0@PAPAUOBJECTSTRUCT@@0P6A_NABQAU2@1@Z@Z ; std::_Unguarded_partition<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__Mid$230558 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z PROC ; std::_Sort<OBJECTSTRUCT * *,int,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 3771 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN7@Sort:

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
  00015	83 7d fc 20	 cmp	 DWORD PTR __Count$[ebp], 32 ; 00000020H
  00019	0f 8e 94 00 00
	00		 jle	 $LN6@Sort
  0001f	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  00023	0f 8e 8a 00 00
	00		 jle	 $LN6@Sort

; 3774 : 		{	// divide and conquer by quicksort
; 3775 : 		_STD pair<_RanIt, _RanIt> _Mid =
; 3776 : 			_Unguarded_partition(_First, _Last, _Pred);

  00029	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	52		 push	 edx
  00035	8d 45 f4	 lea	 eax, DWORD PTR __Mid$230558[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YA?AU?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@0@PAPAUOBJECTSTRUCT@@0P6A_NABQAU2@1@Z@Z ; std::_Unguarded_partition<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 3777 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00041	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00044	99		 cdq
  00045	2b c2		 sub	 eax, edx
  00047	d1 f8		 sar	 eax, 1
  00049	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  0004f	99		 cdq
  00050	2b c2		 sub	 eax, edx
  00052	d1 f8		 sar	 eax, 1
  00054	03 45 10	 add	 eax, DWORD PTR __Ideal$[ebp]
  00057	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 3778 : 
; 3779 : 		if (_Mid.first - _First < _Last - _Mid.second)

  0005a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$230558[ebp]
  0005d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00060	c1 f8 02	 sar	 eax, 2
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00066	2b 4d f8	 sub	 ecx, DWORD PTR __Mid$230558[ebp+4]
  00069	c1 f9 02	 sar	 ecx, 2
  0006c	3b c1		 cmp	 eax, ecx
  0006e	7d 20		 jge	 SHORT $LN5@Sort

; 3780 : 			{	// loop on second half
; 3781 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  00070	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 f4	 mov	 edx, DWORD PTR __Mid$230558[ebp]
  0007b	52		 push	 edx
  0007c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z ; std::_Sort<OBJECTSTRUCT * *,int,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00085	83 c4 10	 add	 esp, 16			; 00000010H

; 3782 : 			_First = _Mid.second;

  00088	8b 45 f8	 mov	 eax, DWORD PTR __Mid$230558[ebp+4]
  0008b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 3783 : 			}
; 3784 : 		else

  0008e	eb 1e		 jmp	 SHORT $LN4@Sort
$LN5@Sort:

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  00090	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00093	50		 push	 eax
  00094	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mid$230558[ebp+4]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z ; std::_Sort<OBJECTSTRUCT * *,int,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000a5	83 c4 10	 add	 esp, 16			; 00000010H

; 3787 : 			_Last = _Mid.first;

  000a8	8b 45 f4	 mov	 eax, DWORD PTR __Mid$230558[ebp]
  000ab	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN4@Sort:

; 3788 : 			}
; 3789 : 		}

  000ae	e9 56 ff ff ff	 jmp	 $LN7@Sort
$LN6@Sort:

; 3790 : 
; 3791 : 	if (_ISORT_MAX < _Count)

  000b3	83 7d fc 20	 cmp	 DWORD PTR __Count$[ebp], 32 ; 00000020H
  000b7	7e 2a		 jle	 SHORT $LN3@Sort

; 3792 : 		{	// heap sort if too many divisions
; 3793 : 		_STD make_heap(_First, _Last, _Pred);

  000b9	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000c0	51		 push	 ecx
  000c1	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ??$make_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::make_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3794 : 		_STD sort_heap(_First, _Last, _Pred);

  000cd	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000d4	51		 push	 ecx
  000d5	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ??$sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e1	eb 1a		 jmp	 SHORT $LN8@Sort
$LN3@Sort:

; 3795 : 		}
; 3796 : 	else if (1 < _Count)

  000e3	83 7d fc 01	 cmp	 DWORD PTR __Count$[ebp], 1
  000e7	7e 14		 jle	 SHORT $LN8@Sort

; 3797 : 		_Insertion_sort(_First, _Last, _Pred);	// small

  000e9	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000f0	51		 push	 ecx
  000f1	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 ??$_Insertion_sort@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::_Insertion_sort<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@Sort:

; 3798 : 	}

  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
??$_Sort@PAPAUOBJECTSTRUCT@@HP6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0HP6A_NABQAU1@1@Z@Z ENDP ; std::_Sort<OBJECTSTRUCT * *,int,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z PROC ; std::forward<OBJECTSTRUCT * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z ENDP ; std::forward<OBJECTSTRUCT * &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z$0
__ehfuncinfo$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T231375 = -88						; size = 4
$T231376 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z PROC ; std::allocator<OBJECTSTRUCT *>::construct<OBJECTSTRUCT * &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231376[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231376[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::forward<OBJECTSTRUCT * &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T231376[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 02		 mov	 DWORD PTR [edx], eax
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T231376[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T231375[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231376[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAPAUOBJECTSTRUCT@@@?$allocator@PAUOBJECTSTRUCT@@@std@@QAEXPAPAUOBJECTSTRUCT@@AAPAU2@@Z ENDP ; std::allocator<OBJECTSTRUCT *>::construct<OBJECTSTRUCT * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABQAUOBJECTSTRUCT@@@std@@YAABQAUOBJECTSTRUCT@@ABQAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAUOBJECTSTRUCT@@@std@@YAABQAUOBJECTSTRUCT@@ABQAU1@@Z PROC ; std::forward<OBJECTSTRUCT * const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAUOBJECTSTRUCT@@@std@@YAABQAUOBJECTSTRUCT@@ABQAU1@@Z ENDP ; std::forward<OBJECTSTRUCT * const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z PROC ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z ENDP ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>
_TEXT	ENDS
EXTRN	_memmove:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 2527 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUOBJECTSTRUCT@@PAU1@PAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<OBJECTSTRUCT *,OBJECTSTRUCT *,OBJECTSTRUCT *>
PUBLIC	??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Val_type<OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAPAUOBJECTSTRUCT@@PAPAU1@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z
_TEXT	SEGMENT
$T231398 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUOBJECTSTRUCT@@PAPAU1@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z PROC ; std::_Uninitialized_move<OBJECTSTRUCT * *,OBJECTSTRUCT * *,std::allocator<OBJECTSTRUCT *> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231398[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231398[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Val_type<OBJECTSTRUCT * *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUOBJECTSTRUCT@@PAU1@PAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<OBJECTSTRUCT *,OBJECTSTRUCT *,OBJECTSTRUCT *>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAPAUOBJECTSTRUCT@@PAPAU1@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@@Z ENDP ; std::_Uninitialized_move<OBJECTSTRUCT * *,OBJECTSTRUCT * *,std::allocator<OBJECTSTRUCT *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >, COMDAT

; 104  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 105  : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@YAXPAPAUOBJECTSTRUCT@@0AAV?$allocator@PAUOBJECTSTRUCT@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<OBJECTSTRUCT *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z$0
__ehfuncinfo$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T231403 = -88						; size = 4
$T231404 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z PROC ; std::_Construct<OBJECTSTRUCT *,OBJECTSTRUCT * const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T231404[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T231404[ebp], 0
  0004a	74 1b		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABQAUOBJECTSTRUCT@@@std@@YAABQAUOBJECTSTRUCT@@ABQAU1@@Z ; std::forward<OBJECTSTRUCT * const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T231404[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 02		 mov	 DWORD PTR [edx], eax
  0005f	8b 4d ac	 mov	 ecx, DWORD PTR $T231404[ebp]
  00062	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00065	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00067	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@Construct:
  0006e	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  00071	89 55 a8	 mov	 DWORD PTR $T231403[ebp], edx
  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231404[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@PAUOBJECTSTRUCT@@ABQAU1@@std@@YAXPAPAUOBJECTSTRUCT@@ABQAU1@@Z ENDP ; std::_Construct<OBJECTSTRUCT *,OBJECTSTRUCT * const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEPAPAUOBJECTSTRUCT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEPAPAUOBJECTSTRUCT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 316  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 		return (_Unchecked_type(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 318  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@PAUOBJECTSTRUCT@@V?$allocator@PAUOBJECTSTRUCT@@@std@@@std@@@std@@QBEPAPAUOBJECTSTRUCT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<OBJECTSTRUCT *,std::allocator<OBJECTSTRUCT *> > >::_Unchecked
_TEXT	ENDS
PUBLIC	??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z ; std::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>
PUBLIC	??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
PUBLIC	??$_Median@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Median<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YA?AU?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@0@PAPAUOBJECTSTRUCT@@0P6A_NABQAU2@1@Z@Z
_TEXT	SEGMENT
tv181 = -92						; size = 4
tv195 = -88						; size = 4
tv178 = -88						; size = 4
tv147 = -88						; size = 4
__Glast$ = -20						; size = 4
__Gfirst$ = -16						; size = 4
__Plast$ = -12						; size = 4
__Pfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Unguarded_partition@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YA?AU?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@0@PAPAUOBJECTSTRUCT@@0P6A_NABQAU2@1@Z@Z PROC ; std::_Unguarded_partition<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 3712 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3713 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00009	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 0c	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	99		 cdq
  00013	2b c2		 sub	 eax, edx
  00015	d1 f8		 sar	 eax, 1
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0001a	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0001d	89 55 fc	 mov	 DWORD PTR __Mid$[ebp], edx

; 3714 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00020	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00027	83 e9 04	 sub	 ecx, 4
  0002a	51		 push	 ecx
  0002b	8b 55 fc	 mov	 edx, DWORD PTR __Mid$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??$_Median@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Median<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00038	83 c4 10	 add	 esp, 16			; 00000010H

; 3715 : 	_RanIt _Pfirst = _Mid;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Mid$[ebp]
  0003e	89 45 f8	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 3716 : 	_RanIt _Plast = _Pfirst + 1;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00044	83 c0 04	 add	 eax, 4
  00047	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax
$LN27@Unguarded_:

; 3717 : 
; 3718 : 	while (_First < _Pfirst
; 3719 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3720 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0004a	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0004d	3b 45 f8	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00050	73 3b		 jae	 SHORT $LN25@Unguarded_
  00052	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00059	83 e9 04	 sub	 ecx, 4
  0005c	51		 push	 ecx
  0005d	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00060	83 c4 08	 add	 esp, 8
  00063	0f b6 d0	 movzx	 edx, al
  00066	85 d2		 test	 edx, edx
  00068	75 23		 jne	 SHORT $LN25@Unguarded_
  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0006d	83 e8 04	 sub	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00074	51		 push	 ecx
  00075	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00078	83 c4 08	 add	 esp, 8
  0007b	0f b6 d0	 movzx	 edx, al
  0007e	85 d2		 test	 edx, edx
  00080	75 0b		 jne	 SHORT $LN25@Unguarded_

; 3721 : 		--_Pfirst;

  00082	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00085	83 e8 04	 sub	 eax, 4
  00088	89 45 f8	 mov	 DWORD PTR __Pfirst$[ebp], eax
  0008b	eb bd		 jmp	 SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  0008d	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  00090	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00093	73 35		 jae	 SHORT $LN24@Unguarded_
  00095	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00098	50		 push	 eax
  00099	8b 4d f4	 mov	 ecx, DWORD PTR __Plast$[ebp]
  0009c	51		 push	 ecx
  0009d	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  000a0	83 c4 08	 add	 esp, 8
  000a3	0f b6 d0	 movzx	 edx, al
  000a6	85 d2		 test	 edx, edx
  000a8	75 20		 jne	 SHORT $LN24@Unguarded_
  000aa	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000b1	51		 push	 ecx
  000b2	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  000b5	83 c4 08	 add	 esp, 8
  000b8	0f b6 d0	 movzx	 edx, al
  000bb	85 d2		 test	 edx, edx
  000bd	75 0b		 jne	 SHORT $LN24@Unguarded_

; 3725 : 		++_Plast;

  000bf	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  000c2	83 c0 04	 add	 eax, 4
  000c5	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax
  000c8	eb c3		 jmp	 SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3726 : 
; 3727 : 	_RanIt _Gfirst = _Plast;

  000ca	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  000cd	89 45 f0	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 3728 : 	_RanIt _Glast = _Pfirst;

  000d0	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000d3	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000d6	eb 09		 jmp	 SHORT $LN21@Unguarded_
$LN20@Unguarded_:
  000d8	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000db	83 c0 04	 add	 eax, 4
  000de	89 45 f0	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN21@Unguarded_:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000e4	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  000e7	73 51		 jae	 SHORT $LN19@Unguarded_

; 3733 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  000e9	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000f0	51		 push	 ecx
  000f1	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  000f4	83 c4 08	 add	 esp, 8
  000f7	0f b6 d0	 movzx	 edx, al
  000fa	85 d2		 test	 edx, edx
  000fc	74 02		 je	 SHORT $LN18@Unguarded_
  000fe	eb 38		 jmp	 SHORT $LN17@Unguarded_
$LN18@Unguarded_:

; 3734 : 				;
; 3735 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  00100	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00103	50		 push	 eax
  00104	8b 4d f0	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00107	51		 push	 ecx
  00108	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  0010b	83 c4 08	 add	 esp, 8
  0010e	0f b6 d0	 movzx	 edx, al
  00111	85 d2		 test	 edx, edx
  00113	74 04		 je	 SHORT $LN16@Unguarded_

; 3736 : 				break;

  00115	eb 23		 jmp	 SHORT $LN19@Unguarded_

; 3737 : 			else

  00117	eb 1f		 jmp	 SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3738 : 				_STD iter_swap(_Plast++, _Gfirst);

  00119	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  0011c	89 45 a8	 mov	 DWORD PTR tv147[ebp], eax
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR __Plast$[ebp]
  00122	83 c1 04	 add	 ecx, 4
  00125	89 4d f4	 mov	 DWORD PTR __Plast$[ebp], ecx
  00128	8b 55 f0	 mov	 edx, DWORD PTR __Gfirst$[ebp]
  0012b	52		 push	 edx
  0012c	8b 45 a8	 mov	 eax, DWORD PTR tv147[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00135	83 c4 08	 add	 esp, 8
$LN17@Unguarded_:
  00138	eb 9e		 jmp	 SHORT $LN20@Unguarded_
$LN19@Unguarded_:

; 3739 : 		for (; _First < _Glast; --_Glast)

  0013a	eb 09		 jmp	 SHORT $LN14@Unguarded_
$LN13@Unguarded_:
  0013c	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  0013f	83 e8 04	 sub	 eax, 4
  00142	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
  00145	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00148	3b 45 ec	 cmp	 eax, DWORD PTR __Glast$[ebp]
  0014b	73 54		 jae	 SHORT $LN12@Unguarded_

; 3740 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  0014d	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00150	50		 push	 eax
  00151	8b 4d ec	 mov	 ecx, DWORD PTR __Glast$[ebp]
  00154	83 e9 04	 sub	 ecx, 4
  00157	51		 push	 ecx
  00158	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  0015b	83 c4 08	 add	 esp, 8
  0015e	0f b6 d0	 movzx	 edx, al
  00161	85 d2		 test	 edx, edx
  00163	74 02		 je	 SHORT $LN11@Unguarded_
  00165	eb 38		 jmp	 SHORT $LN10@Unguarded_
$LN11@Unguarded_:

; 3741 : 				;
; 3742 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  00167	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  0016a	83 e8 04	 sub	 eax, 4
  0016d	50		 push	 eax
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00171	51		 push	 ecx
  00172	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00175	83 c4 08	 add	 esp, 8
  00178	0f b6 d0	 movzx	 edx, al
  0017b	85 d2		 test	 edx, edx
  0017d	74 04		 je	 SHORT $LN9@Unguarded_

; 3743 : 				break;

  0017f	eb 20		 jmp	 SHORT $LN12@Unguarded_

; 3744 : 			else

  00181	eb 1c		 jmp	 SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3745 : 				_STD iter_swap(--_Pfirst, _Glast - 1);

  00183	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00186	83 e8 04	 sub	 eax, 4
  00189	89 45 f8	 mov	 DWORD PTR __Pfirst$[ebp], eax
  0018c	8b 4d ec	 mov	 ecx, DWORD PTR __Glast$[ebp]
  0018f	83 e9 04	 sub	 ecx, 4
  00192	51		 push	 ecx
  00193	8b 55 f8	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  00196	52		 push	 edx
  00197	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  0019c	83 c4 08	 add	 esp, 8
$LN10@Unguarded_:
  0019f	eb 9b		 jmp	 SHORT $LN13@Unguarded_
$LN12@Unguarded_:

; 3746 : 		if (_Glast == _First && _Gfirst == _Last)

  001a1	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  001a4	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  001a7	75 20		 jne	 SHORT $LN7@Unguarded_
  001a9	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001ac	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  001af	75 18		 jne	 SHORT $LN7@Unguarded_

; 3747 : 			return (_STD pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  001b1	8d 45 f4	 lea	 eax, DWORD PTR __Plast$[ebp]
  001b4	50		 push	 eax
  001b5	8d 4d f8	 lea	 ecx, DWORD PTR __Pfirst$[ebp]
  001b8	51		 push	 ecx
  001b9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001bc	e8 00 00 00 00	 call	 ??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z ; std::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>
  001c1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001c4	e9 d3 00 00 00	 jmp	 $LN28@Unguarded_
$LN7@Unguarded_:

; 3748 : 
; 3749 : 		if (_Glast == _First)

  001c9	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  001cc	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  001cf	75 51		 jne	 SHORT $LN6@Unguarded_

; 3750 : 			{	// no room at bottom, rotate pivot upward
; 3751 : 			if (_Plast != _Gfirst)

  001d1	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  001d4	3b 45 f0	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  001d7	74 10		 je	 SHORT $LN5@Unguarded_

; 3752 : 				_STD iter_swap(_Pfirst, _Plast);

  001d9	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  001dc	50		 push	 eax
  001dd	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  001e6	83 c4 08	 add	 esp, 8
$LN5@Unguarded_:

; 3753 : 			++_Plast;

  001e9	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax

; 3754 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  001f2	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001f5	89 45 a8	 mov	 DWORD PTR tv178[ebp], eax
  001f8	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  001fb	89 4d a4	 mov	 DWORD PTR tv181[ebp], ecx
  001fe	8b 55 f8	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  00201	83 c2 04	 add	 edx, 4
  00204	89 55 f8	 mov	 DWORD PTR __Pfirst$[ebp], edx
  00207	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0020a	83 c0 04	 add	 eax, 4
  0020d	89 45 f0	 mov	 DWORD PTR __Gfirst$[ebp], eax
  00210	8b 4d a8	 mov	 ecx, DWORD PTR tv178[ebp]
  00213	51		 push	 ecx
  00214	8b 55 a4	 mov	 edx, DWORD PTR tv181[ebp]
  00217	52		 push	 edx
  00218	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  0021d	83 c4 08	 add	 esp, 8
  00220	eb 75		 jmp	 SHORT $LN4@Unguarded_
$LN6@Unguarded_:

; 3755 : 			}
; 3756 : 		else if (_Gfirst == _Last)

  00222	8b 45 f0	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00225	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00228	75 45		 jne	 SHORT $LN3@Unguarded_

; 3757 : 			{	// no room at top, rotate pivot downward
; 3758 : 			if (--_Glast != --_Pfirst)

  0022a	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  0022d	83 e8 04	 sub	 eax, 4
  00230	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
  00233	8b 4d f8	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00236	83 e9 04	 sub	 ecx, 4
  00239	89 4d f8	 mov	 DWORD PTR __Pfirst$[ebp], ecx
  0023c	8b 55 ec	 mov	 edx, DWORD PTR __Glast$[ebp]
  0023f	3b 55 f8	 cmp	 edx, DWORD PTR __Pfirst$[ebp]
  00242	74 10		 je	 SHORT $LN2@Unguarded_

; 3759 : 				_STD iter_swap(_Glast, _Pfirst);

  00244	8b 45 f8	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00247	50		 push	 eax
  00248	8b 4d ec	 mov	 ecx, DWORD PTR __Glast$[ebp]
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00251	83 c4 08	 add	 esp, 8
$LN2@Unguarded_:

; 3760 : 			_STD iter_swap(_Pfirst, --_Plast);

  00254	8b 45 f4	 mov	 eax, DWORD PTR __Plast$[ebp]
  00257	83 e8 04	 sub	 eax, 4
  0025a	89 45 f4	 mov	 DWORD PTR __Plast$[ebp], eax
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __Plast$[ebp]
  00260	51		 push	 ecx
  00261	8b 55 f8	 mov	 edx, DWORD PTR __Pfirst$[ebp]
  00264	52		 push	 edx
  00265	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  0026a	83 c4 08	 add	 esp, 8

; 3761 : 			}
; 3762 : 		else

  0026d	eb 28		 jmp	 SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3763 : 			_STD iter_swap(_Gfirst++, --_Glast);

  0026f	8b 45 ec	 mov	 eax, DWORD PTR __Glast$[ebp]
  00272	83 e8 04	 sub	 eax, 4
  00275	89 45 ec	 mov	 DWORD PTR __Glast$[ebp], eax
  00278	8b 4d f0	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  0027b	89 4d a8	 mov	 DWORD PTR tv195[ebp], ecx
  0027e	8b 55 ec	 mov	 edx, DWORD PTR __Glast$[ebp]
  00281	52		 push	 edx
  00282	8b 45 a8	 mov	 eax, DWORD PTR tv195[ebp]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  0028b	83 c4 08	 add	 esp, 8
  0028e	8b 4d f0	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00291	83 c1 04	 add	 ecx, 4
  00294	89 4d f0	 mov	 DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3764 : 		}

  00297	e9 3a fe ff ff	 jmp	 $LN23@Unguarded_
$LN28@Unguarded_:

; 3765 : 	}

  0029c	5f		 pop	 edi
  0029d	5e		 pop	 esi
  0029e	5b		 pop	 ebx
  0029f	8b e5		 mov	 esp, ebp
  002a1	5d		 pop	 ebp
  002a2	c3		 ret	 0
??$_Unguarded_partition@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YA?AU?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@0@PAPAUOBJECTSTRUCT@@0P6A_NABQAU2@1@Z@Z ENDP ; std::_Unguarded_partition<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@ZPAH0@Z ; std::_Make_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
PUBLIC	??$_Dist_type@PAPAUOBJECTSTRUCT@@@std@@YAPAHPAPAUOBJECTSTRUCT@@@Z ; std::_Dist_type<OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$make_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$make_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z PROC ; std::make_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2672 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2673 : 	_DEBUG_RANGE(_First, _Last);
; 2674 : 	_DEBUG_POINTER(_Pred);
; 2675 : 	if (1 < _Last - _First)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	83 f8 01	 cmp	 eax, 1
  00015	7e 40		 jle	 SHORT $LN2@make_heap

; 2676 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2677 : 			_Dist_type(_First), _Val_type(_First));

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Val_type<OBJECTSTRUCT * *>
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ??$_Dist_type@PAPAUOBJECTSTRUCT@@@std@@YAPAHPAPAUOBJECTSTRUCT@@@Z ; std::_Dist_type<OBJECTSTRUCT * *>
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 55 10	 mov	 edx, DWORD PTR __Pred$[ebp]
  00034	52		 push	 edx
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
  0003e	83 c4 04	 add	 esp, 4
  00041	50		 push	 eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
  0004b	83 c4 04	 add	 esp, 4
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??$_Make_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@ZPAH0@Z ; std::_Make_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00054	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@make_heap:

; 2678 : 	}

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$make_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ENDP ; std::make_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::_Sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z PROC ; std::sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2708 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2709 : 	_DEBUG_RANGE(_First, _Last);
; 2710 : 	_DEBUG_POINTER(_Pred);
; 2711 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2712 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
  00016	83 c4 04	 add	 esp, 4
  00019	50		 push	 eax
  0001a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$_Sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::_Sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 : 	}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ENDP ; std::sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@ZPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z ; std::_Insertion_sort1<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &),OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Insertion_sort@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z PROC ; std::_Insertion_sort<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 3676 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3677 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Val_type<OBJECTSTRUCT * *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@ZPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z ; std::_Insertion_sort1<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &),OBJECTSTRUCT *>
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 3678 : 	}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Insertion_sort@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ENDP ; std::_Insertion_sort<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z PROC ; std::_Val_type<OBJECTSTRUCT * *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ENDP ; std::_Val_type<OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUOBJECTSTRUCT@@PAU1@PAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUOBJECTSTRUCT@@PAU1@PAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<OBJECTSTRUCT *,OBJECTSTRUCT *,OBJECTSTRUCT *>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002f	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 462  : 	}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUOBJECTSTRUCT@@PAU1@PAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00AAV?$allocator@PAUOBJECTSTRUCT@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<OBJECTSTRUCT *,OBJECTSTRUCT *,OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Median@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__Step$230815 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Median@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z PROC ; std::_Median<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 3695 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3696 : 	if (40 < _Last - _First)

  00009	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	83 f8 28	 cmp	 eax, 40			; 00000028H
  00015	0f 8e b6 00 00
	00		 jle	 $LN2@Median

; 3697 : 		{	// median of nine
; 3698 : 		size_t _Step = (_Last - _First + 1) / 8;

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0001e	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00021	c1 f8 02	 sar	 eax, 2
  00024	83 c0 01	 add	 eax, 1
  00027	99		 cdq
  00028	83 e2 07	 and	 edx, 7
  0002b	03 c2		 add	 eax, edx
  0002d	c1 f8 03	 sar	 eax, 3
  00030	89 45 fc	 mov	 DWORD PTR __Step$230815[ebp], eax

; 3699 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00033	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230815[ebp]
  0003a	d1 e1		 shl	 ecx, 1
  0003c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003f	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230815[ebp]
  00046	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00049	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00056	83 c4 10	 add	 esp, 16			; 00000010H

; 3700 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00059	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230815[ebp]
  00060	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  00063	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00066	50		 push	 eax
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0006a	51		 push	 ecx
  0006b	8b 55 fc	 mov	 edx, DWORD PTR __Step$230815[ebp]
  0006e	c1 e2 02	 shl	 edx, 2
  00071	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00074	2b c2		 sub	 eax, edx
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  0007c	83 c4 10	 add	 esp, 16			; 00000010H

; 3701 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  0007f	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  00082	50		 push	 eax
  00083	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00086	51		 push	 ecx
  00087	8b 55 fc	 mov	 edx, DWORD PTR __Step$230815[ebp]
  0008a	c1 e2 02	 shl	 edx, 2
  0008d	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00090	2b c2		 sub	 eax, edx
  00092	50		 push	 eax
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230815[ebp]
  00096	d1 e1		 shl	 ecx, 1
  00098	c1 e1 02	 shl	 ecx, 2
  0009b	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0009e	2b d1		 sub	 edx, ecx
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000a6	83 c4 10	 add	 esp, 16			; 00000010H

; 3702 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  000a9	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230815[ebp]
  000b0	c1 e1 02	 shl	 ecx, 2
  000b3	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  000b6	2b d1		 sub	 edx, ecx
  000b8	52		 push	 edx
  000b9	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __Step$230815[ebp]
  000c0	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000c3	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000cc	83 c4 10	 add	 esp, 16			; 00000010H

; 3703 : 		}
; 3704 : 	else

  000cf	eb 18		 jmp	 SHORT $LN3@Median
$LN2@Median:

; 3705 : 		_Med3(_First, _Mid, _Last, _Pred);

  000d1	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000d8	51		 push	 ecx
  000d9	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  000dc	52		 push	 edx
  000dd	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@Median:

; 3706 : 	}

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
??$_Median@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ENDP ; std::_Median<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$swap@PAUOBJECTSTRUCT@@@std@@YAXAAPAUOBJECTSTRUCT@@0@Z ; std::swap<OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z PROC ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>, COMDAT

; 2133 : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2134 : 	swap(*_Left, *_Right);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$swap@PAUOBJECTSTRUCT@@@std@@YAXAAPAUOBJECTSTRUCT@@0@Z ; std::swap<OBJECTSTRUCT *>
  00016	83 c4 08	 add	 esp, 8

; 2135 : 	}

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ENDP ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
_TEXT	ENDS
PUBLIC	??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$_Pair_base@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z ; std::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>
PUBLIC	??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z ; std::forward<OBJECTSTRUCT * * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z PROC ; std::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z ; std::forward<OBJECTSTRUCT * * &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z ; std::forward<OBJECTSTRUCT * * &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$_Pair_base@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z ; std::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$pair@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z ENDP ; std::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::pair<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z PROC ; std::_Unchecked<OBJECTSTRUCT * *>, COMDAT

; 266  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 267  : 	return (_Src);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 268  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ENDP ; std::_Unchecked<OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Dist_type@PAPAUOBJECTSTRUCT@@@std@@YAPAHPAPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAPAUOBJECTSTRUCT@@@std@@YAPAHPAPAUOBJECTSTRUCT@@@Z PROC ; std::_Dist_type<OBJECTSTRUCT * *>, COMDAT

; 849  : 	{	// return distance type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 850  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 851  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Dist_type@PAPAUOBJECTSTRUCT@@@std@@YAPAHPAPAUOBJECTSTRUCT@@@Z ENDP ; std::_Dist_type<OBJECTSTRUCT * *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ; std::_Adjust_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
PUBLIC	??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@ZPAH0@Z
_TEXT	SEGMENT
__Val$230864 = -12					; size = 4
__Hole$230860 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@ZPAH0@Z PROC ; std::_Make_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2658 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2659 : 	_Diff _Bottom = _Last - _First;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Bottom$[ebp], eax

; 2660 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00018	99		 cdq
  00019	2b c2		 sub	 eax, edx
  0001b	d1 f8		 sar	 eax, 1
  0001d	89 45 f8	 mov	 DWORD PTR __Hole$230860[ebp], eax
$LN2@Make_heap:
  00020	83 7d f8 00	 cmp	 DWORD PTR __Hole$230860[ebp], 0
  00024	7e 47		 jle	 SHORT $LN3@Make_heap

; 2661 : 		{	// reheap top half, bottom to top
; 2662 : 		--_Hole;

  00026	8b 45 f8	 mov	 eax, DWORD PTR __Hole$230860[ebp]
  00029	83 e8 01	 sub	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR __Hole$230860[ebp], eax

; 2663 : 		_Ty _Val = _Move(*(_First + _Hole));

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Hole$230860[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00035	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 f4	 mov	 DWORD PTR __Val$230864[ebp], eax

; 2664 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2665 : 			_Move(_Val), _Pred);

  00046	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f4	 lea	 ecx, DWORD PTR __Val$230864[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00053	83 c4 04	 add	 esp, 4
  00056	50		 push	 eax
  00057	8b 55 fc	 mov	 edx, DWORD PTR __Bottom$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 f8	 mov	 eax, DWORD PTR __Hole$230860[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ; std::_Adjust_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00068	83 c4 14	 add	 esp, 20			; 00000014H

; 2666 : 		}

  0006b	eb b3		 jmp	 SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2667 : 	}

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
??$_Make_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@ZPAH0@Z ENDP ; std::_Make_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::_Pop_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z PROC ; std::_Sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2700 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2701 : 	for (; 1 < _Last - _First; --_Last)

  00009	eb 09		 jmp	 SHORT $LN3@Sort_heap
$LN2@Sort_heap:
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	83 e8 04	 sub	 eax, 4
  00011	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN3@Sort_heap:
  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	83 f8 01	 cmp	 eax, 1
  00020	7e 16		 jle	 SHORT $LN4@Sort_heap

; 2702 : 		_Pop_heap(_First, _Last, _Pred);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Pop_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ; std::_Pop_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	eb d3		 jmp	 SHORT $LN2@Sort_heap
$LN4@Sort_heap:

; 2703 : 	}

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Sort_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ENDP ; std::_Sort_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Insertion_sort1@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@ZPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z
_TEXT	SEGMENT
__First1$230918 = -16					; size = 4
__Val$230908 = -12					; size = 4
__Next1$230907 = -8					; size = 4
__Next$230903 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@ZPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z PROC ; std::_Insertion_sort1<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &),OBJECTSTRUCT *>, COMDAT

; 3650 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3651 : 	if (_First != _Last)

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000f	0f 84 d2 00 00
	00		 je	 $LN9@Insertion_

; 3652 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00015	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR __Next$230903[ebp], eax
$LN7@Insertion_:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Next$230903[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 fc	 mov	 DWORD PTR __Next$230903[ebp], eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR __Next$230903[ebp]
  00027	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0002a	0f 84 b7 00 00
	00		 je	 $LN9@Insertion_

; 3653 : 			{	// order next element
; 3654 : 			_BidIt _Next1 = _Next;

  00030	8b 45 fc	 mov	 eax, DWORD PTR __Next$230903[ebp]
  00033	89 45 f8	 mov	 DWORD PTR __Next1$230907[ebp], eax

; 3655 : 			_Ty _Val = _Move(*_Next);

  00036	8b 45 fc	 mov	 eax, DWORD PTR __Next$230903[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  0003f	83 c4 04	 add	 esp, 4
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	89 4d f4	 mov	 DWORD PTR __Val$230908[ebp], ecx

; 3656 : 
; 3657 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004a	50		 push	 eax
  0004b	8d 4d f4	 lea	 ecx, DWORD PTR __Val$230908[ebp]
  0004e	51		 push	 ecx
  0004f	ff 55 10	 call	 DWORD PTR __Pred$[ebp]
  00052	83 c4 08	 add	 esp, 8
  00055	0f b6 d0	 movzx	 edx, al
  00058	85 d2		 test	 edx, edx
  0005a	74 32		 je	 SHORT $LN5@Insertion_

; 3658 : 				{	// found new earliest element, move to front
; 3659 : 				_Move_backward(_First, _Next, ++_Next1);

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Next1$230907[ebp]
  0005f	83 c0 04	 add	 eax, 4
  00062	89 45 f8	 mov	 DWORD PTR __Next1$230907[ebp], eax
  00065	8b 4d f8	 mov	 ecx, DWORD PTR __Next1$230907[ebp]
  00068	51		 push	 ecx
  00069	8b 55 fc	 mov	 edx, DWORD PTR __Next$230903[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3660 : 				*_First = _Move(_Val);

  00079	8d 45 f4	 lea	 eax, DWORD PTR __Val$230908[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00082	83 c4 04	 add	 esp, 4
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00088	8b 10		 mov	 edx, DWORD PTR [eax]
  0008a	89 11		 mov	 DWORD PTR [ecx], edx

; 3661 : 				}
; 3662 : 			else

  0008c	eb 54		 jmp	 SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Next1$230907[ebp]
  00091	89 45 f0	 mov	 DWORD PTR __First1$230918[ebp], eax
  00094	eb 06		 jmp	 SHORT $LN3@Insertion_
$LN2@Insertion_:

; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  00096	8b 45 f0	 mov	 eax, DWORD PTR __First1$230918[ebp]
  00099	89 45 f8	 mov	 DWORD PTR __Next1$230907[ebp], eax
$LN3@Insertion_:
  0009c	8b 45 f0	 mov	 eax, DWORD PTR __First1$230918[ebp]
  0009f	83 e8 04	 sub	 eax, 4
  000a2	89 45 f0	 mov	 DWORD PTR __First1$230918[ebp], eax
  000a5	8b 4d f0	 mov	 ecx, DWORD PTR __First1$230918[ebp]
  000a8	51		 push	 ecx
  000a9	8d 55 f4	 lea	 edx, DWORD PTR __Val$230908[ebp]
  000ac	52		 push	 edx
  000ad	ff 55 10	 call	 DWORD PTR __Pred$[ebp]
  000b0	83 c4 08	 add	 esp, 8
  000b3	0f b6 c0	 movzx	 eax, al
  000b6	85 c0		 test	 eax, eax
  000b8	74 15		 je	 SHORT $LN1@Insertion_

; 3667 : 					*_Next1 = _Move(*_First1);	// move hole down

  000ba	8b 45 f0	 mov	 eax, DWORD PTR __First1$230918[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR __Next1$230907[ebp]
  000c9	8b 10		 mov	 edx, DWORD PTR [eax]
  000cb	89 11		 mov	 DWORD PTR [ecx], edx
  000cd	eb c7		 jmp	 SHORT $LN2@Insertion_
$LN1@Insertion_:

; 3668 : 				*_Next1 = _Move(_Val);	// insert element in hole

  000cf	8d 45 f4	 lea	 eax, DWORD PTR __Val$230908[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 4d f8	 mov	 ecx, DWORD PTR __Next1$230907[ebp]
  000de	8b 10		 mov	 edx, DWORD PTR [eax]
  000e0	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Insertion_:

; 3669 : 				}
; 3670 : 			}

  000e2	e9 34 ff ff ff	 jmp	 $LN7@Insertion_
$LN9@Insertion_:

; 3671 : 	}

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
??$_Insertion_sort1@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@ZPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z ENDP ; std::_Insertion_sort1<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &),OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z PROC ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 3683 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3684 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00010	51		 push	 ecx
  00011	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00014	83 c4 08	 add	 esp, 8
  00017	0f b6 d0	 movzx	 edx, al
  0001a	85 d2		 test	 edx, edx
  0001c	74 10		 je	 SHORT $LN3@Med3

; 3685 : 		_STD iter_swap(_Mid, _First);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  0002b	83 c4 08	 add	 esp, 8
$LN3@Med3:

; 3686 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00035	51		 push	 ecx
  00036	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  00039	83 c4 08	 add	 esp, 8
  0003c	0f b6 d0	 movzx	 edx, al
  0003f	85 d2		 test	 edx, edx
  00041	74 10		 je	 SHORT $LN2@Med3

; 3687 : 		_STD iter_swap(_Last, _Mid);

  00043	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00050	83 c4 08	 add	 esp, 8
$LN2@Med3:

; 3688 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00053	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0005a	51		 push	 ecx
  0005b	ff 55 14	 call	 DWORD PTR __Pred$[ebp]
  0005e	83 c4 08	 add	 esp, 8
  00061	0f b6 d0	 movzx	 edx, al
  00064	85 d2		 test	 edx, edx
  00066	74 10		 je	 SHORT $LN4@Med3

; 3689 : 		_STD iter_swap(_Mid, _First);

  00068	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ??$iter_swap@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAXPAPAUOBJECTSTRUCT@@0@Z ; std::iter_swap<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00075	83 c4 08	 add	 esp, 8
$LN4@Med3:

; 3690 : 	}

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
??$_Med3@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00P6A_NABQAU1@1@Z@Z ENDP ; std::_Med3<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PAUOBJECTSTRUCT@@@std@@YAXAAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAUOBJECTSTRUCT@@@std@@YAXAAPAUOBJECTSTRUCT@@0@Z PROC ; std::swap<OBJECTSTRUCT *>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	89 11		 mov	 DWORD PTR [ecx], edx

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 fc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	89 11		 mov	 DWORD PTR [ecx], edx

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@PAUOBJECTSTRUCT@@@std@@YAXAAPAUOBJECTSTRUCT@@0@Z ENDP ; std::swap<OBJECTSTRUCT *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z PROC ; std::forward<OBJECTSTRUCT * * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z ENDP ; std::forward<OBJECTSTRUCT * * &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$_Pair_base@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$_Pair_base@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z PROC ; std::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z ; std::forward<OBJECTSTRUCT * * &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAPAPAUOBJECTSTRUCT@@@std@@YAAAPAPAUOBJECTSTRUCT@@AAPAPAU1@@Z ; std::forward<OBJECTSTRUCT * * &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAPAPAUOBJECTSTRUCT@@AAPAPAU0@@?$_Pair_base@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@QAE@AAPAPAUOBJECTSTRUCT@@0@Z ENDP ; std::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *>::_Pair_base<OBJECTSTRUCT * *,OBJECTSTRUCT * *><OBJECTSTRUCT * * &,OBJECTSTRUCT * * &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z PROC ; std::_Move<OBJECTSTRUCT * &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ENDP ; std::_Move<OBJECTSTRUCT * &>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ; std::_Push_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z
_TEXT	SEGMENT
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Adjust_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z PROC ; std::_Adjust_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2565 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2566 : 	_Diff _Top = _Hole;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Top$[ebp], eax

; 2567 : 	_Diff _Idx = 2 * _Hole + 2;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00012	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00016	89 4d f8	 mov	 DWORD PTR __Idx$[ebp], ecx
  00019	eb 0a		 jmp	 SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:

; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001e	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00022	89 4d f8	 mov	 DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
  00025	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00028	3b 45 10	 cmp	 eax, DWORD PTR __Bottom$[ebp]
  0002b	7d 50		 jge	 SHORT $LN3@Adjust_hea

; 2570 : 		{	// move _Hole down to larger child
; 2571 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00033	8d 54 81 fc	 lea	 edx, DWORD PTR [ecx+eax*4-4]
  00037	52		 push	 edx
  00038	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00041	52		 push	 edx
  00042	ff 55 18	 call	 DWORD PTR __Pred$[ebp]
  00045	83 c4 08	 add	 esp, 8
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 09		 je	 SHORT $LN2@Adjust_hea

; 2572 : 			--_Idx;

  0004f	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00052	83 e8 01	 sub	 eax, 1
  00055	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2573 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0005e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00067	83 c4 04	 add	 esp, 4
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  0006d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00070	8b 00		 mov	 eax, DWORD PTR [eax]
  00072	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 2574 : 		_Hole = _Idx;

  00075	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00078	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 2575 : 		}

  0007b	eb 9e		 jmp	 SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2576 : 
; 2577 : 	if (_Idx == _Bottom)

  0007d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00080	3b 45 10	 cmp	 eax, DWORD PTR __Bottom$[ebp]
  00083	75 27		 jne	 SHORT $LN1@Adjust_hea

; 2578 : 		{	// only child at bottom, move _Hole down to it
; 2579 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  00085	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0008b	8d 54 81 fc	 lea	 edx, DWORD PTR [ecx+eax*4-4]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  0009b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0009e	8b 00		 mov	 eax, DWORD PTR [eax]
  000a0	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 2580 : 		_Hole = _Bottom - 1;

  000a3	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000a6	83 e8 01	 sub	 eax, 1
  000a9	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN1@Adjust_hea:

; 2581 : 		}
; 2582 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  000ac	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  000b9	83 c4 04	 add	 esp, 4
  000bc	50		 push	 eax
  000bd	8b 55 fc	 mov	 edx, DWORD PTR __Top$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??$_Push_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ; std::_Push_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  000ce	83 c4 14	 add	 esp, 20			; 00000014H

; 2583 : 	}

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
??$_Adjust_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ENDP ; std::_Adjust_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAPAUOBJECTSTRUCT@@PAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z ; std::_Pop_heap_0<OBJECTSTRUCT * *,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Pop_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z PROC ; std::_Pop_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2610 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2611 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2612 : 		_Val_type(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Val_type@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Val_type<OBJECTSTRUCT * *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAUOBJECTSTRUCT@@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@@Z ; std::_Unchecked<OBJECTSTRUCT * *>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAPAUOBJECTSTRUCT@@PAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z ; std::_Pop_heap_0<OBJECTSTRUCT * *,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 2613 : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$_Pop_heap@PAPAUOBJECTSTRUCT@@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z@Z ENDP ; std::_Pop_heap<OBJECTSTRUCT * *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z
_TEXT	SEGMENT
$T231460 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z PROC ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>, COMDAT

; 2638 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2639 : 	return (_Move_backward(_First, _Last,
; 2640 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOBJECTSTRUCT@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUOBJECTSTRUCT@@0@Z ; std::_Ptr_cat<OBJECTSTRUCT *,OBJECTSTRUCT *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231460[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231460[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2641 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00@Z ENDP ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Push_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z
_TEXT	SEGMENT
__Idx$230985 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Push_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z PROC ; std::_Push_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2455 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2456 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	89 45 fc	 mov	 DWORD PTR __Idx$230985[ebp], eax
  00017	eb 0e		 jmp	 SHORT $LN3@Push_heap
$LN2@Push_heap:

; 2457 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2458 : 		_Idx = (_Hole - 1) / 2)

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0001c	83 e8 01	 sub	 eax, 1
  0001f	99		 cdq
  00020	2b c2		 sub	 eax, edx
  00022	d1 f8		 sar	 eax, 1
  00024	89 45 fc	 mov	 DWORD PTR __Idx$230985[ebp], eax
$LN3@Push_heap:
  00027	8b 45 10	 mov	 eax, DWORD PTR __Top$[ebp]
  0002a	3b 45 0c	 cmp	 eax, DWORD PTR __Hole$[ebp]
  0002d	7d 40		 jge	 SHORT $LN1@Push_heap
  0002f	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR __Idx$230985[ebp]
  00036	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00039	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0003c	50		 push	 eax
  0003d	ff 55 18	 call	 DWORD PTR __Pred$[ebp]
  00040	83 c4 08	 add	 esp, 8
  00043	0f b6 c8	 movzx	 ecx, al
  00046	85 c9		 test	 ecx, ecx
  00048	74 25		 je	 SHORT $LN1@Push_heap

; 2459 : 		{	// move _Hole up to parent
; 2460 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0004a	8b 45 fc	 mov	 eax, DWORD PTR __Idx$230985[ebp]
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00050	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00059	83 c4 04	 add	 esp, 4
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  0005f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 2461 : 		_Hole = _Idx;

  00067	8b 45 fc	 mov	 eax, DWORD PTR __Idx$230985[ebp]
  0006a	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 2462 : 		}

  0006d	eb aa		 jmp	 SHORT $LN2@Push_heap
$LN1@Push_heap:

; 2463 : 
; 2464 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  0006f	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00078	83 c4 04	 add	 esp, 4
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR __Hole$[ebp]
  0007e	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 2465 : 	}

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
??$_Push_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ENDP ; std::_Push_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00$$QAPAU1@P6A_NABQAU1@2@ZPAH@Z ; std::_Pop_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Pop_heap_0@PAPAUOBJECTSTRUCT@@PAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z
_TEXT	SEGMENT
__Val$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAPAUOBJECTSTRUCT@@PAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z PROC ; std::_Pop_heap_0<OBJECTSTRUCT * *,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2601 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2602 : 	_Ty _Val = _Move(*(_Last - 1));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	83 e8 04	 sub	 eax, 4
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR __Val$[ebp], ecx

; 2603 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2604 : 		_Move(_Val), _Pred, _Dist_type(_First));

  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??$_Dist_type@PAPAUOBJECTSTRUCT@@@std@@YAPAHPAPAUOBJECTSTRUCT@@@Z ; std::_Dist_type<OBJECTSTRUCT * *>
  00026	83 c4 04	 add	 esp, 4
  00029	50		 push	 eax
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 55 fc	 lea	 edx, DWORD PTR __Val$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00037	83 c4 04	 add	 esp, 4
  0003a	50		 push	 eax
  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003e	83 e8 04	 sub	 eax, 4
  00041	50		 push	 eax
  00042	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00045	83 e9 04	 sub	 ecx, 4
  00048	51		 push	 ecx
  00049	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 ??$_Pop_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00$$QAPAU1@P6A_NABQAU1@2@ZPAH@Z ; std::_Pop_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00052	83 c4 18	 add	 esp, 24			; 00000018H

; 2605 : 	}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??$_Pop_heap_0@PAPAUOBJECTSTRUCT@@PAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@0P6A_NABQAU1@1@Z0@Z ENDP ; std::_Pop_heap_0<OBJECTSTRUCT * *,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>, COMDAT

; 2627 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2628 : 	ptrdiff_t _Count = _Last - _First;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 2629 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2630 : 		_Count * sizeof (*_First));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR __Count$[ebp]
  00023	c1 e2 02	 shl	 edx, 2
  00026	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00029	2b c2		 sub	 eax, edx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _memmove
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2631 : 	return (_Dest - _Count);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00037	c1 e0 02	 shl	 eax, 2
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0003d	2b c8		 sub	 ecx, eax
  0003f	8b c1		 mov	 eax, ecx

; 2632 : 	}

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Move_backward@PAPAUOBJECTSTRUCT@@PAPAU1@@std@@YAPAPAUOBJECTSTRUCT@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<OBJECTSTRUCT * *,OBJECTSTRUCT * *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Pop_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00$$QAPAU1@P6A_NABQAU1@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
___formal$ = 28						; size = 4
??$_Pop_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00$$QAPAU1@P6A_NABQAU1@2@ZPAH@Z PROC ; std::_Pop_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>, COMDAT

; 2591 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2592 : 	*_Dest = _Move(*_First);

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00012	83 c4 04	 add	 esp, 4
  00015	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	89 11		 mov	 DWORD PTR [ecx], edx

; 2593 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2594 : 		_Move(_Val), _Pred);

  0001c	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Move@AAPAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::_Move<OBJECTSTRUCT * &>
  00029	83 c4 04	 add	 esp, 4
  0002c	50		 push	 eax
  0002d	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00030	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  00033	c1 fa 02	 sar	 edx, 2
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@HH$$QAPAU1@P6A_NABQAU1@2@Z@Z ; std::_Adjust_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
  00042	83 c4 14	 add	 esp, 20			; 00000014H

; 2595 : 	}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$_Pop_heap@PAPAUOBJECTSTRUCT@@HPAU1@P6A_NABQAU1@0@Z@std@@YAXPAPAUOBJECTSTRUCT@@00$$QAPAU1@P6A_NABQAU1@2@ZPAH@Z ENDP ; std::_Pop_heap<OBJECTSTRUCT * *,int,OBJECTSTRUCT *,bool (__cdecl*)(OBJECTSTRUCT * const &,OBJECTSTRUCT * const &)>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
